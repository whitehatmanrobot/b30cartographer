ink name if necessary
    //
    if (deviceExtension->SymbolicLinkName.Buffer != NULL)
    {
        ntStatus = IoSetDeviceInterfaceState(
                       &deviceExtension->SymbolicLinkName,
                       FALSE);

        RtlFreeUnicodeString(&deviceExtension->SymbolicLinkName);
    }

    // No more user requests at this point
    //
    deviceExtension->AcceptingRequests = FALSE;

    // Abort any requests that may be lingering on any of the endpoints.
    //
    if (deviceExtension->InterfaceInfo != NULL)
    {
        ULONG   pipeIndex;
        ULONG   numPipes;

        numPipes = deviceExtension->InterfaceInfo->NumberOfPipes;

        for (pipeIndex = 0; pipeIndex < numPipes; pipeIndex++)
        {
            I82930_AbortPipe(DeviceObject,
                             &deviceExtension->PipeList[pipeIndex]);
        }
    }

    // Decrement by one to match the initial one in AddDevice
    //
    DECREMENT_OPEN_COUNT(deviceExtension);

    LOGENTRY('rem1', DeviceObject, 0, 0);

    // Wait for all pending requests to complete
    //
    KeWaitForSingleObject(&deviceExtension->RemoveEvent,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    LOGENTRY('rem2', DeviceObject, 0, 0);

    // Free everything that was allocated during IRP_MN_START_DEVICE
    //

    if (deviceExtension->DeviceDescriptor != NULL)
    {
        ExFreePool(deviceExtension->DeviceDescriptor);
    }

    if (deviceExtension->ConfigurationDescriptor != NULL)
    {
        ExFreePool(deviceExtension->ConfigurationDescriptor);
    }

    if (deviceExtension->InterfaceInfo != NULL)
    {
        ExFreePool(deviceExtension->InterfaceInfo);
    }

    // The documentation says to set the status before passing the Irp down
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    // Pass the IRP_MN_REMOVE_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

    LOGENTRY('rem3', DeviceObject, 0, 0);

    // Free everything that was allocated during AddDevice
    //
    IoDetachDevice(deviceExtension->StackDeviceObject);

    IoDeleteDevice(DeviceObject);

    DBGPRINT(2, ("exit:  I82930_RemoveDevice %08X\n", ntStatus));

    LOGENTRY('remv', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_QueryStopRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_STOP_DEVICE and
// IRP_MN_QUERY_REMOVE_DEVICE.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
//******************************************************************************

NTSTATUS
I82930_QueryStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_QueryStopRemoveDevice\n"));

    LOGENTRY('QSRD', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_QUERYSTOPDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    // Disable the SymbolicLink name
    //
    ntStatus = IoSetDeviceInterfaceState(
                   &deviceExtension->SymbolicLinkName,
                   FALSE);

    // No more user requests at this point
    //
    deviceExtension->AcceptingRequests = FALSE;

    // If there are no opens, OK to STOP or REMOVE
    //
    if (deviceExtension->OpenCount == 1)
    {
        LOGENTRY('qsr1', 0, 0, 0);

        // The documentation says to set the status before passing the Irp down
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        // Pass the IRP_MN_QUERY_STOP/REMOVE_DEVICE Irp down the stack.
        //
        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                                Irp);

    }
    else
    {
        LOGENTRY('qsr2', deviceExtension->OpenCount, 0, 0);

        ntStatus = STATUS_DEVICE_BUSY;

        Irp->IoStatus.Status = ntStatus;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  I82930_QueryStopRemoveDevice %08X\n", ntStatus));

    LOGENTRY('qsrd', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_CancelStopRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_CANCEL_STOP_DEVICE and
// IRP_MN_CANCEL_REMOVE_DEVICE.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP must be handled first by the underlying bus driver for a device
// and then by each higher driver in the device stack.
//
//******************************************************************************

NTSTATUS
I82930_CancelStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_CancelStopRemoveDevice\n"));

    LOGENTRY('CSRD', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CANCELSTOPDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    // Pass the IRP_MN_CANCEL_STOP/REMOVE_DEVICE Irp down the stack first.
    //
    ntStatus = I82930_SyncPassDownIrp(DeviceObject,
                                      Irp,
                                      TRUE);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_CANCEL_STOP/REMOVE_DEVICE\n"));
        goto I82930_CancelStopRemoveDeviceDone;
    }

    // All set for user requests at this point
    //
    deviceExtension->AcceptingRequests = TRUE;

    // Enable the SymbolicLink name
    //
    ntStatus = IoSetDeviceInterfaceState(
                   &deviceExtension->SymbolicLinkName,
                   TRUE);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("IoSetDeviceInterfaceState failed\n"));
        Irp->IoStatus.Status = ntStatus;
        goto I82930_CancelStopRemoveDeviceDone;
    }

I82930_CancelStopRemoveDeviceDone:

    // Must complete request since completion routine returned
    // STATUS_MORE_PROCESSING_REQUIRED
    //
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_CancelStopRemoveDevice %08X\n", ntStatus));

    LOGENTRY('csrd', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_QueryCapabilities()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
I82930_QueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    PDEVICE_CAPABILITIES    deviceCapabilities;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: I82930_QueryCapabilities\n"));

    LOGENTRY('FQCP', DeviceObject, Irp, 0);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceCapabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;

    // Pass IRP_MN_QUERY_CAPABILITIES Irp down the stack first before we do
    // anything.
    //
    ntStatus = I82930_SyncPassDownIrp(DeviceObject,
                                      Irp,
                                      TRUE);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_QUERY_CAPABILITIES\n"));
    }
    else
    {
        deviceCapabilities->SurpriseRemovalOK = TRUE;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_QueryCapabilities %08X\n", ntStatus));

    LOGENTRY('fqcp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_SyncPassDownIrp()
//
//******************************************************************************

NTSTATUS
I82930_SyncPassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          CopyToNext
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;
    KEVENT              localevent;

    DBGPRINT(2, ("enter: I82930_SyncPassDownIrp\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    if (CopyToNext)
    {
        // Next Stack Location not set up, copy Current Stack Location
        // to the Next Stack Location.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutine(Irp,
                           I82930_SyncCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel

    // Pass the Irp down the stack
    //
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    DBGPRINT(2, ("exit:  I82930_SyncPassDownIrp %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_SyncCompletionRoutine()
//
// Completion routine used by I82930_SyncPassDownIrp and
// I82930_SyncSendUsbRequest
//
// If the Irp is one we allocated ourself, DeviceObject is NULL unless we
// allocated a stack location for ourself and initialized the DeviceObject
// pointer in our stack location.
//
//******************************************************************************

NTSTATUS
I82930_SyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT kevent;

    LOGENTRY('SCR ', DeviceObject, Irp, Irp->IoStatus.Status);

    kevent = (PKEVENT)Context;

    KeSetEvent(kevent,
               IO_NO_INCREMENT,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//******************************************************************************
//
// I82930_SyncSendUsbRequest()
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_SyncSendUsbRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    KEVENT              localevent;
    PIRP                irp;
    PIO_STACK_LOCATION  nextStack;
    NTSTATUS            ntStatus;

    DBGPRINT(3, ("enter: I82930_SyncSendUsbRequest\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Allocate the Irp
    //
    irp = IoAllocateIrp(deviceExtension->StackDeviceObject->StackSize, FALSE);

    LOGENTRY('SSUR', DeviceObject, irp, Urb);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = Urb;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutine(irp,
                           I82930_SyncCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel



    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        LARGE_INTEGER timeout;

        // Specify a timeout of 5 seconds to wait for this call to complete.
        //
        timeout.QuadPart = -10000 * 5000;

        ntStatus = KeWaitForSingleObject(&localevent,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         &timeout);

        if (ntStatus == STATUS_TIMEOUT)
        {
            ntStatus = STATUS_IO_TIMEOUT;

            // Cancel the Irp we just sent.
            //
            IoCancelIrp(irp);

            // And wait until the cancel completes
            //
            KeWaitForSingleObject(&localevent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        else
        {
            ntStatus = irp->IoStatus.Status;
        }
    }

    // Done with the Irp, now free it.
    //
    IoFreeIrp(irp);

    LOGENTRY('ssur', ntStatus, Urb, Urb->UrbHeader.Status);

    DBGPRINT(3, ("exit:  I82930_SyncSendUsbRequest %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_GetDescriptor()
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_GetDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            DescriptorType,
    IN UCHAR            Index,
    IN USHORT           LanguageId,
    IN ULONG            RetryCount,
    IN ULONG            DescriptorLength,
    OUT PUCHAR         *Descriptor
    )
{
    USHORT      function;
    PURB        urb;
    NTSTATUS    ntStatus;

    DBGPRINT(2, ("enter: I82930_GetDescriptor\n"));

    // Set the URB function based on Recipient {Device, Interface, Endpoint}
    //
    switch (Recipient)
    {
        case USB_RECIPIENT_DEVICE:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE;
            break;
        case USB_RECIPIENT_INTERFACE:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE;
            break;
        case USB_RECIPIENT_ENDPOINT:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT;
            break;
        default:
            *Descriptor = NULL;
            return STATUS_INVALID_PARAMETER;
    }

    // Allocate a descriptor buffer
    //
    *Descriptor = ExAllocatePoolWithTag(NonPagedPool,
                                        DescriptorLength,
                                        POOL_TAG);

    if (*Descriptor != NULL)
    {
        // Allocate a URB for the Get Descriptor request
        //
        urb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                    POOL_TAG);

        if (urb != NULL)
        {
            do
            {
                // Initialize the URB
                //
                urb->UrbHeader.Function = function;
                urb->UrbHeader.Length = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);
                urb->UrbControlDescriptorRequest.TransferBufferLength = DescriptorLength;
                urb->UrbControlDescriptorRequest.TransferBuffer = *Descriptor;
                urb->UrbControlDescriptorRequest.TransferBufferMDL = NULL;
                urb->UrbControlDescriptorRequest.UrbLink = NULL;
                urb->UrbControlDescriptorRequest.DescriptorType = DescriptorType;
                urb->UrbControlDescriptorRequest.Index = Index;
                urb->UrbControlDescriptorRequest.LanguageId = LanguageId;

                // Send the URB down the stack
                //
                ntStatus = I82930_SyncSendUsbRequest(DeviceObject,
                                                     urb);

                if (NT_SUCCESS(ntStatus))
                {
                    // No error, make sure the length and type are correct
                    //
                    if ((DescriptorLength ==
                         urb->UrbControlDescriptorRequest.TransferBufferLength) &&
                        (DescriptorType ==
                         ((PUSB_COMMON_DESCRIPTOR)*Descriptor)->bDescriptorType))
                    {
                        // The length and type are correct, all done
                        //
                        break;
                    }
                    else
                    {
                        // No error, but the length or type is incorrect
                        //
                        ntStatus = STATUS_DEVICE_DATA_ERROR;
                    }
                }

            } while (RetryCount-- > 0);

            ExFreePool(urb);
        }
        else
        {
            // Failed to allocate the URB
            //
            ExFreePool(*Descriptor);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        // Failed to allocate the descriptor buffer
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(ntStatus))
    {
        *Descriptor = NULL;
    }

    DBGPRINT(2, ("exit:  I82930_GetDescriptor %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_SelectConfiguration()
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_SelectConfiguration (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    NTSTATUS    ntStatus;
    PURB        urb;
    ULONG       i;
    PDEVICE_EXTENSION               deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR   configurationDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY      interfaceList;
    PUSB_INTERFACE_DESCRIPTOR       interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION     interfaceInfo;

    DBGPRINT(2, ("enter: I82930_SelectConfiguration\n"));

    LOGENTRY('SCON', DeviceObject, 0, 0);

    deviceExtension = DeviceObject->DeviceExtension;
    configurationDescriptor = deviceExtension->ConfigurationDescriptor;


    // Allocate storage for an Inteface List to use as an input/output
    // parameter to USBD_CreateConfigurationRequestEx().
    //
    interfaceList = ExAllocatePool(
                        PagedPool,
                        sizeof(USBD_INTERFACE_LIST_ENTRY) * 2
                        );

    if (interfaceList)
    {
        // Parse the ConfigurationDescriptor (including all Interface and
        // Endpoint Descriptors) and locate a Interface Descriptor which
        // matches the InterfaceNumber, AlternateSetting, InterfaceClass,
        // InterfaceSubClass, and InterfaceProtocol parameters.  In our case
        // we just grab the first Interface Descriptor from the Configuration
        // Descriptor.
        //
        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                  configurationDescriptor,
                                  configurationDescriptor,
                                  -1, // InterfaceNumber, don't care
                                  -1, // AlternateSetting, don't care
                                  -1, // InterfaceClass, don't care
                                  -1, // InterfaceSubClass, don't care
                                  -1  // InterfaceProtocol, don't care
                                  );

        if (interfaceDescriptor)
        {
            // Add the single Interface Descriptor we care about to the
            // interface list, then terminate the list.
            //
            interfaceList[0].InterfaceDescriptor = interfaceDescriptor;
            interfaceList[1].InterfaceDescriptor = NULL;

            // Create a SELECT_CONFIGURATION URB, turning the Interface
            // Descriptors in the interfaceList into USBD_INTERFACE_INFORMATION
            // structures in the URB.
            //
            urb = USBD_CreateConfigurationRequestEx(
                      configurationDescriptor,
                      interfaceList
                      );

            if (urb)
            {
                interfaceInfo = &urb->UrbSelectConfiguration.Interface;

                // Override the USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE
                // for all pipes.
                //
                for (i = 0; i < interfaceInfo->NumberOfPipes; i++)
                {
                    interfaceInfo->Pipes[i].MaximumTransferSize = 0x10000;
                }

                // Now issue the USB request to set the Configuration
                //
                ntStatus = I82930_SyncSendUsbRequest(DeviceObject,
                                                     urb);

                if (NT_SUCCESS(ntStatus))
                {
                    // Save the configuration handle for this device in
                    // the Device Extension.
                    //
                    deviceExtension->ConfigurationHandle =
                        urb->UrbSelectConfiguration.ConfigurationHandle;

                    // Save a copy of the interface information returned
                    // by the SELECT_CONFIGURATION request in the Device
                    // Extension.  This gives us a list of PIPE_INFORMATION
                    // structures for each pipe opened in this configuration.
                    //
                    ASSERT(deviceExtension->InterfaceInfo == NULL);

                    deviceExtension->InterfaceInfo = ExAllocatePool(
                                                         PagedPool,
                                                         interfaceInfo->Length
                                                     );

                    if (deviceExtension->InterfaceInfo)
                    {
                        ULONG   pipeIndex;
                        ULONG   numPipes;

                        RtlCopyMemory(
                            deviceExtension->InterfaceInfo,
                            interfaceInfo,
                            interfaceInfo->Length
                            );

                        // Initialize the PipeList array pointers back into the
                        // InterfaceInfo.
                        //
                        numPipes = deviceExtension->InterfaceInfo->NumberOfPipes;

                        for (pipeIndex = 0; pipeIndex < numPipes; pipeIndex++)
                        {
                            deviceExtension->PipeList[pipeIndex].PipeIndex =
                                (UCHAR)pipeIndex;

                            deviceExtension->PipeList[pipeIndex].PipeInfo  =
                                &deviceExtension->InterfaceInfo->Pipes[pipeIndex];
                        }
                    }
                    else
                    {
                        // Could not allocate a copy of interface information
                        //
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                // Done with the URB
                //
                ExFreePool(urb);
            }
            else
            {
                // Could not allocate urb
                //
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            // Did not parse an Interface Descriptor out of the Configuration
            // Descriptor, the Configuration Descriptor must be bad.
            //
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        // Done with the interface list
        //
        ExFreePool(interfaceList);
    }
    else
    {
        // Could not allocate Interface List
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  I82930_SelectConfiguration %08X\n", ntStatus));

    LOGENTRY('scon', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_UnConfigure()
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_UnConfigure (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;
    PURB                urb;
    ULONG               ulSize;

    DBGPRINT(2, ("enter: I82930_UnConfigure\n"));

    LOGENTRY('UCON', DeviceObject, 0, 0);

    deviceExtension = DeviceObject->DeviceExtension;

    // Allocate a URB for the SELECT_CONFIGURATION request.  As we are
    // unconfiguring the device, the request needs no pipe and interface
    // information structures.
    //
    ulSize = sizeof(struct _URB_SELECT_CONFIGURATION) -
             sizeof(USBD_INTERFACE_INFORMATION);

    urb = ExAllocatePool(
              NonPagedPool,
              ulSize
              );

    if (urb)
    {
        // Initialize the URB.  A NULL Configuration Descriptor indicates
        // that the device should be unconfigured.
        //
        UsbBuildSelectConfigurationRequest(
            urb,
            (USHORT)ulSize,
            NULL
            );

        // Now issue the USB request to set the Configuration
        //
        ntStatus = I82930_SyncSendUsbRequest(DeviceObject,
                                             urb);

        // Done with the URB now.
        //
        ExFreePool(urb);

        // The device is no longer configured.
        //
        deviceExtension->ConfigurationHandle = 0;

        if (deviceExtension->InterfaceInfo != NULL)
        {
            ExFreePool(deviceExtension->InterfaceInfo);

            deviceExtension->InterfaceInfo = NULL;
        }
    }
    else
    {
        // Could not allocate the URB.
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  I82930_UnConfigure %08X\n", ntStatus));

    LOGENTRY('ucon', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_SelectAlternateInterface()
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_SelectAlternateInterface (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            AlternateSetting
    )
{
    NTSTATUS    ntStatus;
    USHORT      urbSize;
    PURB        urb;
    ULONG       i;
    PDEVICE_EXTENSION               deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR   configurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR       interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION     interfaceInfo;

    DBGPRINT(2, ("enter: I82930_SelectAlternateInterface\n"));

    LOGENTRY('SALT', DeviceObject, 0, 0);

    deviceExtension = DeviceObject->DeviceExtension;
    configurationDescriptor = deviceExtension->ConfigurationDescriptor;

    interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                              configurationDescriptor,
                              configurationDescriptor,
                              -1, // InterfaceNumber, don't care
                              AlternateSetting,
                              -1, // InterfaceClass, don't care
                              -1, // InterfaceSubClass, don't care
                              -1  // InterfaceProtocol, don't care
                              );

    if (interfaceDescriptor != NULL)
    {
        urbSize = GET_SELECT_INTERFACE_REQUEST_SIZE(interfaceDescriptor->bNumEndpoints);

        urb = ExAllocatePoolWithTag(NonPagedPool,
                                    urbSize,
                                    POOL_TAG);

        if (urb != NULL)
        {
            RtlZeroMemory(urb, urbSize);

            urb->UrbHeader.Length   = urbSize;

            urb->UrbHeader.Function = URB_FUNCTION_SELECT_INTERFACE;

            urb->UrbSelectInterface.ConfigurationHandle =
                deviceExtension->ConfigurationHandle;

            interfaceInfo = &urb->UrbSelectInterface.Interface;

            interfaceInfo->Length = GET_USBD_INTERFACE_SIZE(interfaceDescriptor->bNumEndpoints);

            interfaceInfo->InterfaceNumber = interfaceDescriptor->bInterfaceNumber;

            interfaceInfo->AlternateSetting = AlternateSetting;

            for (i = 0; i < interfaceDescriptor->bNumEndpoints; i++)
            {
                interfaceInfo->Pipes[i].MaximumTransferSize = 0x10000;
            }

            // Now issue the USB request to select the alternate interface
            //
            ntStatus = I82930_SyncSendUsbRequest(DeviceObject,
                                                 urb);

            if (NT_SUCCESS(ntStatus))
            {
                if (deviceExtension->InterfaceInfo != NULL)
                {
                    ExFreePool(deviceExtension->InterfaceInfo);

                    deviceExtension->InterfaceInfo = NULL;
                }

                // Save a copy of the interface information returned
                // by the SELECT_INTERFACE request in the Device
                // Extension.  This gives us a list of PIPE_INFORMATION
                // structures for each pipe opened in this configuration.
                //
                deviceExtension->InterfaceInfo = ExAllocatePool(
                                                     PagedPool,
                                                     interfaceInfo->Length
                                                     );

                if (deviceExtension->InterfaceInfo)
                {
                    ULONG   pipeIndex;
                    ULONG   numPipes;

                    RtlCopyMemory(deviceExtension->InterfaceInfo,
                                  interfaceInfo,
                                  interfaceInfo->Length
                                  );

                    // Initialize the PipeList array pointers back into the
                    // InterfaceInfo.
                    //
                    numPipes = deviceExtension->InterfaceInfo->NumberOfPipes;

                    for (pipeIndex = 0; pipeIndex < numPipes; pipeIndex++)
                    {
                        deviceExtension->PipeList[pipeIndex].PipeIndex =
                            (UCHAR)pipeIndex;

                        deviceExtension->PipeList[pipeIndex].PipeInfo  =
                            &deviceExtension->InterfaceInfo->Pipes[pipeIndex];
                    }
                }
                else
                {
                    // Could not allocate a copy of interface information
                    //
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            // Done with the URB
            //
            ExFreePool(urb);
        }
        else
        {
            // Could not allocate urb
            //
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        // Bad AlternateSetting
        //
        ntStatus = STATUS_INVALID_PARAMETER;

    }

    DBGPRINT(2, ("exit:  I82930_SelectAlternateInterface %08X\n", ntStatus));

    LOGENTRY('salt', ntStatus, 0, 0);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\i82930\exe\reconfig\reconfig.c ===
/*++

Module Name:

    RECONFIG.C

Abstract:

    This source file contains routines for exercising the I82930.SYS
    test driver.

Environment:

    user mode

Copyright (c) 1996-2001 Microsoft Corporation.  All Rights Reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <windows.h>
#include <basetyps.h>
#include <setupapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <devioctl.h>
#include <string.h>
#include <initguid.h>
#include <usb100.h>

#include "ioctl.h"

#pragma intrinsic(strlen, strcpy)

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef struct _DEVICENODE
{
    struct _DEVICENODE *Next;
    CHAR                DevicePath[0];
} DEVICENODE, *PDEVICENODE;

//*****************************************************************************
// F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
);

VOID ReconfigureDevice (
    PCHAR DevicePath,
    ULONG MPSCount,
    ULONG MPS[]
);

//*****************************************************************************
//
// main()
//
//*****************************************************************************

int _cdecl
main(
    int argc,
    char *argv[]
)
{
    PDEVICENODE deviceNode;
    PDEVICENODE deviceNodeNext;
    ULONG       devInstance;
    ULONG       devCount;
    ULONG       mpsCount;
    ULONG       mps[15];

    devInstance = 1;    // set this with cmd line arg

    for (mpsCount = 0;
         (mpsCount < (ULONG)(argc-1)) && (mpsCount < 15);
         mpsCount++)
    {
        mps[mpsCount] = atoi(argv[mpsCount+1]);
    }

    deviceNode = EnumDevices((LPGUID)&GUID_CLASS_I82930);

    devCount = 0;

    while (deviceNode)
    {
        devCount++;

        if (devCount == devInstance)
        {
            ReconfigureDevice(deviceNode->DevicePath,
                              mpsCount,
                              mps);
        }

        deviceNodeNext = deviceNode->Next;
        GlobalFree(deviceNode);
        deviceNode = deviceNodeNext;
    }

    return 0;
}

//*****************************************************************************
//
// EnumDevices()
//
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
)
{
    HDEVINFO                         deviceInfo;
    SP_DEVICE_INTERFACE_DATA         deviceInfoData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceDetailData;
    ULONG                            index;
    ULONG                            requiredLength;
    PDEVICENODE                      deviceNode;
    PDEVICENODE                      deviceNodeHead;

    deviceNodeHead = NULL;

    deviceInfo = SetupDiGetClassDevs(Guid,
                                     NULL,
                                     NULL,
                                     (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));

    deviceInfoData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    for (index=0;
         SetupDiEnumDeviceInterfaces(deviceInfo,
                                     0,
                                     Guid,
                                     index,
                                     &deviceInfoData);
         index++)
    {
        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        NULL,
                                        0,
                                        &requiredLength,
                                        NULL);

        deviceDetailData = GlobalAlloc(GPTR, requiredLength);

        deviceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        deviceDetailData,
                                        requiredLength,
                                        &requiredLength,
                                        NULL);

        requiredLength = sizeof(DEVICENODE) +
                         strlen(deviceDetailData->DevicePath) + 1;

        deviceNode = GlobalAlloc(GPTR, requiredLength);

        strcpy(deviceNode->DevicePath, deviceDetailData->DevicePath);
        deviceNode->Next = deviceNodeHead;
        deviceNodeHead = deviceNode;

        GlobalFree(deviceDetailData);
    }

    SetupDiDestroyDeviceInfoList(deviceInfo);

    return deviceNodeHead;
}

//*****************************************************************************
//
// ShowDeviceInfo()
//
//*****************************************************************************

VOID ReconfigureDevice (
    PCHAR DevicePath,
    ULONG MPSCount,
    ULONG MPS[]
)
{
    HANDLE  devHandle;
    BOOL    success;
    int     size;
    int     nBytes;
    PUSB_CONFIGURATION_DESCRIPTOR   configDesc;
    PUSB_INTERFACE_DESCRIPTOR       interfaceDesc;
    PUSB_ENDPOINT_DESCRIPTOR        endpointDesc;
    ULONG                           i;

    devHandle = CreateFile(DevicePath,
                           GENERIC_WRITE | GENERIC_READ,
                           FILE_SHARE_WRITE | FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);

    if (devHandle == INVALID_HANDLE_VALUE)
    {
        printf("Unable to open device:%s\n", DevicePath);
        return;
    }
    else
    {
        printf("Device: %s\n", DevicePath);
    }

    for (i = 0; i < MPSCount; i++)
    {
        printf("MPS[%2d] = %4d\n", i, MPS[i]);
    }

    size = sizeof(USB_CONFIGURATION_DESCRIPTOR) +
           sizeof(USB_INTERFACE_DESCRIPTOR) +
           sizeof(USB_ENDPOINT_DESCRIPTOR) * MPSCount;

    configDesc = GlobalAlloc(GPTR, size);

    if (configDesc == NULL)
    {
        return;
    }

    //
    // Initialize the Configuration Descriptor
    //
    configDesc->bLength             = sizeof(USB_CONFIGURATION_DESCRIPTOR);
    configDesc->bDescriptorType     = USB_CONFIGURATION_DESCRIPTOR_TYPE;
    configDesc->wTotalLength        = (USHORT)size;
    configDesc->bNumInterfaces      = 1;
    configDesc->bConfigurationValue = 1;
    configDesc->iConfiguration      = 0;
    configDesc->bmAttributes        = USB_CONFIG_BUS_POWERED |
                                      USB_CONFIG_SELF_POWERED;
    configDesc->MaxPower            = 0;

    //
    // Initialize the Interface Descriptor
    //
    interfaceDesc = (PUSB_INTERFACE_DESCRIPTOR)(configDesc + 1);

    interfaceDesc->bLength              = sizeof(USB_INTERFACE_DESCRIPTOR);
    interfaceDesc->bDescriptorType      = USB_INTERFACE_DESCRIPTOR_TYPE;
    interfaceDesc->bInterfaceNumber     = 0;
    interfaceDesc->bAlternateSetting    = 0;
    interfaceDesc->bNumEndpoints        = (UCHAR)MPSCount;
    interfaceDesc->bInterfaceClass      = 0xFF;
    interfaceDesc->bInterfaceSubClass   = 0xFF;
    interfaceDesc->bInterfaceProtocol   = 0xFF;
    interfaceDesc->iInterface           = 0;

    //
    // Initialize the Endpoint Descriptors
    //
    endpointDesc = (PUSB_ENDPOINT_DESCRIPTOR)(interfaceDesc + 1);

    for (i = 0; i < MPSCount; i++)
    {
        endpointDesc->bLength           = sizeof(USB_ENDPOINT_DESCRIPTOR);
        endpointDesc->bDescriptorType   = USB_ENDPOINT_DESCRIPTOR_TYPE;
        endpointDesc->bEndpointAddress  = (UCHAR)(i + 1);
        endpointDesc->bmAttributes      = USB_ENDPOINT_TYPE_ISOCHRONOUS;
        endpointDesc->wMaxPacketSize    = (USHORT)MPS[i];
        endpointDesc->bInterval         = 0;

        endpointDesc++;
    }

    //
    // Set Configuration Descriptor
    //

    success = DeviceIoControl(devHandle,
                              IOCTL_I82930_SET_CONFIG_DESCRIPTOR,
                              configDesc,
                              size,
                              NULL,
                              0,
                              &nBytes,
                              NULL);

    if (success)
    {
        printf("Reconfigured device\n");
    }

    GlobalFree(configDesc);

    CloseHandle(devHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\i82930\sys\dbg.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    DBG.C

Abstract:

    I82930 driver debug utility functions

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>

#include "i82930.h"

#ifdef ALLOC_PRAGMA
#if DBG
#pragma alloc_text(PAGE, I82930_QueryGlobalParams)
#endif
#if DEBUG_LOG
#pragma alloc_text(PAGE, I82930_LogInit)
#pragma alloc_text(PAGE, I82930_LogUnInit)
#endif
#if DBG
#pragma alloc_text(PAGE, DumpDeviceDesc)
#pragma alloc_text(PAGE, DumpConfigDesc)
#pragma alloc_text(PAGE, DumpConfigurationDescriptor)
#pragma alloc_text(PAGE, DumpInterfaceDescriptor)
#pragma alloc_text(PAGE, DumpEndpointDescriptor)
#endif
#endif


//******************************************************************************
//
// G L O B A L S
//
//******************************************************************************

#if DBG || DEBUG_LOG

DRIVERGLOBALS I82930_DriverGlobals =
{
#if DBG
    0,      // DebugFlags
    0,      // DebugLevel
#endif
    0,      // LogStart
    0,      // LogPtr
    0,      // LogEnd
    0       // LogSpinLock
};

#endif

#if DBG

//******************************************************************************
//
// I82930_QueryGlobalParams()
//
//******************************************************************************

VOID
I82930_QueryGlobalParams (
    )
{
    RTL_QUERY_REGISTRY_TABLE paramTable[3];
    ULONG zero;

    DBGPRINT(2, ("enter: I82930_QueryGlobalParams\n"));

    zero = 0;   // default value

    RtlZeroMemory (&paramTable[0], sizeof(paramTable));

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = L"DebugFlags";
    paramTable[0].EntryContext  = &I82930_DriverGlobals.DebugFlags;
    paramTable[0].DefaultType   = REG_BINARY;
    paramTable[0].DefaultData   = &zero;
    paramTable[0].DefaultLength = sizeof(ULONG);

    paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name          = L"DebugLevel";
    paramTable[1].EntryContext  = &I82930_DriverGlobals.DebugLevel;
    paramTable[1].DefaultType   = REG_BINARY;
    paramTable[1].DefaultData   = &zero;
    paramTable[1].DefaultLength = sizeof(ULONG);

    RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                           L"I82930",
                           &paramTable[0],
                           NULL,           // Context
                           NULL);          // Environment

    DBGPRINT(2, ("exit:  I82930_QueryGlobalParams\n"));
}

#endif

#if DBG || DEBUG_LOG

//*****************************************************************************
//
// I82930_LogInit()
//
//*****************************************************************************

VOID
I82930_LogInit (
)
{
    KeInitializeSpinLock(&I82930_DriverGlobals.LogSpinLock);

    I82930_DriverGlobals.LogStart = ExAllocatePool(NonPagedPool, LOGSIZE);

    if (I82930_DriverGlobals.LogStart != NULL)
    {
        I82930_DriverGlobals.LogEnd = I82930_DriverGlobals.LogStart +
                                      LOGSIZE / sizeof(I82930_LOG_ENTRY);

        I82930_DriverGlobals.LogPtr = I82930_DriverGlobals.LogEnd - 1;
    }

    DbgPrint("I82930: LogStart @ %08X, LogPtr @ %08X, LogEnd @ %08X\n",
             &I82930_DriverGlobals.LogStart,
             &I82930_DriverGlobals.LogPtr,
             &I82930_DriverGlobals.LogEnd);
}

//*****************************************************************************
//
// I82930_LogUnInit()
//
//*****************************************************************************

VOID
I82930_LogUnInit (
)
{
    PI82930_LOG_ENTRY logStart;

    logStart = I82930_DriverGlobals.LogStart;

    I82930_DriverGlobals.LogStart = 0;

    ExFreePool(logStart);
}

//*****************************************************************************
//
// I82930_LogEntry()
//
//*****************************************************************************

VOID
I82930_LogEntry (
    IN ULONG     Tag,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
)
{
    KIRQL irql;

    if (I82930_DriverGlobals.LogStart == NULL)
    {
        return;
    }

    KeAcquireSpinLock(&I82930_DriverGlobals.LogSpinLock, &irql);

    if (I82930_DriverGlobals.LogPtr > I82930_DriverGlobals.LogStart)
    {
        I82930_DriverGlobals.LogPtr--;
    }
    else
    {
        I82930_DriverGlobals.LogPtr = I82930_DriverGlobals.LogEnd - 1;
    }

    I82930_DriverGlobals.LogPtr->le_tag     = Tag;
    I82930_DriverGlobals.LogPtr->le_info1   = Info1;
    I82930_DriverGlobals.LogPtr->le_info2   = Info2;
    I82930_DriverGlobals.LogPtr->le_info3   = Info3;

    KeReleaseSpinLock(&I82930_DriverGlobals.LogSpinLock, irql);
}

#endif

#if DBG

//*****************************************************************************
//
// PnPMinorFunctionString()
//
// MinorFunction - The IRP_MJ_PNP minor function
//
//*****************************************************************************

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        default:
            return "IRP_MN_?????";
    }
}

//*****************************************************************************
//
// PowerMinorFunctionString()
//
// MinorFunction - The IRP_MJ_POWER minor function
//
//*****************************************************************************

PCHAR
PowerMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE";
        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE";
        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER";
        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER";
        default:
            return "IRP_MN_?????";
    }
}

//*****************************************************************************
//
// PowerDeviceStateString()
//
// State - The DEVICE_POWER_STATE
//
//*****************************************************************************

PCHAR
PowerDeviceStateString (
    DEVICE_POWER_STATE State
)
{
    switch (State)
    {
        case PowerDeviceUnspecified:
            return "PowerDeviceUnspecified";
        case PowerDeviceD0:
            return "PowerDeviceD0";
        case PowerDeviceD1:
            return "PowerDeviceD1";
        case PowerDeviceD2:
            return "PowerDeviceD2";
        case PowerDeviceD3:
            return "PowerDeviceD3";
        case PowerDeviceMaximum:
            return "PowerDeviceMaximum";
        default:
            return "PowerDevice?????";
    }
}

//*****************************************************************************
//
// PowerSystemStateString()
//
// State - The SYSTEM_POWER_STATE
//
//*****************************************************************************

PCHAR
PowerSystemStateString (
    SYSTEM_POWER_STATE State
)
{
    switch (State)
    {
        case PowerSystemUnspecified:
            return "PowerSystemUnspecified";
        case PowerSystemWorking:
            return "PowerSystemWorking";
        case PowerSystemSleeping1:
            return "PowerSystemSleeping1";
        case PowerSystemSleeping2:
            return "PowerSystemSleeping2";
        case PowerSystemSleeping3:
            return "PowerSystemSleeping3";
        case PowerSystemHibernate:
            return "PowerSystemHibernate";
        case PowerSystemShutdown:
            return "PowerSystemShutdown";
        case PowerSystemMaximum:
            return "PowerSystemMaximum";
        default:
            return "PowerSystem?????";
    }
}

//*****************************************************************************
//
// DumpDeviceDesc()
//
// DeviceDesc - The Device Descriptor
//
//*****************************************************************************

VOID
DumpDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
)
{
    DBGPRINT(3, ("------------------\n"));
    DBGPRINT(3, ("Device Descriptor:\n"));

    DBGPRINT(3, ("bcdUSB:             0x%04X\n",
                 DeviceDesc->bcdUSB));

    DBGPRINT(3, ("bDeviceClass:         0x%02X\n",
                 DeviceDesc->bDeviceClass));

    DBGPRINT(3, ("bDeviceSubClass:      0x%02X\n",
                 DeviceDesc->bDeviceSubClass));

    DBGPRINT(3, ("bDeviceProtocol:      0x%02X\n",
                 DeviceDesc->bDeviceProtocol));

    DBGPRINT(3, ("bMaxPacketSize0:      0x%02X (%d)\n",
                 DeviceDesc->bMaxPacketSize0,
                 DeviceDesc->bMaxPacketSize0));

    DBGPRINT(3, ("idVendor:           0x%04X\n",
                 DeviceDesc->idVendor));

    DBGPRINT(3, ("idProduct:          0x%04X\n",
                 DeviceDesc->idProduct));

    DBGPRINT(3, ("bcdDevice:          0x%04X\n",
                 DeviceDesc->bcdDevice));

    DBGPRINT(3, ("iManufacturer:        0x%02X\n",
                 DeviceDesc->iManufacturer));

    DBGPRINT(3, ("iProduct:             0x%02X\n",
                 DeviceDesc->iProduct));

    DBGPRINT(3, ("iSerialNumber:        0x%02X\n",
                 DeviceDesc->iSerialNumber));

    DBGPRINT(3, ("bNumConfigurations:   0x%02X\n",
                 DeviceDesc->bNumConfigurations));

}

//*****************************************************************************
//
// DumpConfigDesc()
//
// ConfigDesc - The Configuration Descriptor, and associated Interface and
// EndpointDescriptors
//
//*****************************************************************************

VOID
DumpConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    PUCHAR                  descEnd;
    PUSB_COMMON_DESCRIPTOR  commonDesc;
    BOOLEAN                 dumpUnknown;

    descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

    commonDesc = (PUSB_COMMON_DESCRIPTOR)ConfigDesc;

    while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
           (PUCHAR)commonDesc + commonDesc->bLength <= descEnd)
    {
        dumpUnknown = FALSE;

        switch (commonDesc->bDescriptorType)
        {
            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_CONFIGURATION_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpConfigurationDescriptor((PUSB_CONFIGURATION_DESCRIPTOR)commonDesc);
                break;

            case USB_INTERFACE_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpInterfaceDescriptor((PUSB_INTERFACE_DESCRIPTOR)commonDesc);
                break;

            case USB_ENDPOINT_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_ENDPOINT_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpEndpointDescriptor((PUSB_ENDPOINT_DESCRIPTOR)commonDesc);
                break;

            default:
                dumpUnknown = TRUE;
                break;
        }

        if (dumpUnknown)
        {
            // DumpUnknownDescriptor(commonDesc);
        }

        (PUCHAR)commonDesc += commonDesc->bLength;
    }
}


//*****************************************************************************
//
// DumpConfigurationDescriptor()
//
//*****************************************************************************

VOID
DumpConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    DBGPRINT(3, ("-------------------------\n"));
    DBGPRINT(3, ("Configuration Descriptor:\n"));

    DBGPRINT(3, ("wTotalLength:       0x%04X\n",
                 ConfigDesc->wTotalLength));

    DBGPRINT(3, ("bNumInterfaces:       0x%02X\n",
                 ConfigDesc->bNumInterfaces));

    DBGPRINT(3, ("bConfigurationValue:  0x%02X\n",
                 ConfigDesc->bConfigurationValue));

    DBGPRINT(3, ("iConfiguration:       0x%02X\n",
                 ConfigDesc->iConfiguration));

    DBGPRINT(3, ("bmAttributes:         0x%02X\n",
                 ConfigDesc->bmAttributes));

    if (ConfigDesc->bmAttributes & 0x80)
    {
        DBGPRINT(3, ("  Bus Powered\n"));
    }

    if (ConfigDesc->bmAttributes & 0x40)
    {
        DBGPRINT(3, ("  Self Powered\n"));
    }

    if (ConfigDesc->bmAttributes & 0x20)
    {
        DBGPRINT(3, ("  Remote Wakeup\n"));
    }

    DBGPRINT(3, ("MaxPower:             0x%02X (%d Ma)\n",
                 ConfigDesc->MaxPower,
                 ConfigDesc->MaxPower * 2));

}

//*****************************************************************************
//
// DumpInterfaceDescriptor()
//
//*****************************************************************************

VOID
DumpInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
)
{
    DBGPRINT(3, ("---------------------\n"));
    DBGPRINT(3, ("Interface Descriptor:\n"));

    DBGPRINT(3, ("bInterfaceNumber:     0x%02X\n",
                 InterfaceDesc->bInterfaceNumber));

    DBGPRINT(3, ("bAlternateSetting:    0x%02X\n",
                 InterfaceDesc->bAlternateSetting));

    DBGPRINT(3, ("bNumEndpoints:        0x%02X\n",
                 InterfaceDesc->bNumEndpoints));

    DBGPRINT(3, ("bInterfaceClass:      0x%02X\n",
                 InterfaceDesc->bInterfaceClass));

    DBGPRINT(3, ("bInterfaceSubClass:   0x%02X\n",
                 InterfaceDesc->bInterfaceSubClass));

    DBGPRINT(3, ("bInterfaceProtocol:   0x%02X\n",
                 InterfaceDesc->bInterfaceProtocol));

    DBGPRINT(3, ("iInterface:           0x%02X\n",
                 InterfaceDesc->iInterface));

}

//*****************************************************************************
//
// DumpEndpointDescriptor()
//
//*****************************************************************************

VOID
DumpEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
)
{
    DBGPRINT(3, ("--------------------\n"));
    DBGPRINT(3, ("Endpoint Descriptor:\n"));

    DBGPRINT(3, ("bEndpointAddress:     0x%02X\n",
                 EndpointDesc->bEndpointAddress));

    switch (EndpointDesc->bmAttributes & 0x03)
    {
        case 0x00:
            DBGPRINT(3, ("Transfer Type:     Control\n"));
            break;

        case 0x01:
            DBGPRINT(3, ("Transfer Type: Isochronous\n"));
            break;

        case 0x02:
            DBGPRINT(3, ("Transfer Type:        Bulk\n"));
            break;

        case 0x03:
            DBGPRINT(3, ("Transfer Type:   Interrupt\n"));
            break;
    }

    DBGPRINT(3, ("wMaxPacketSize:     0x%04X (%d)\n",
                 EndpointDesc->wMaxPacketSize,
                 EndpointDesc->wMaxPacketSize));

    DBGPRINT(3, ("bInterval:            0x%02X\n",
                 EndpointDesc->bInterval));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\i82930\sys\ioctl.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    IOCTL.C

Abstract:

    This source file contains the dispatch routine which handles:

    IRP_MJ_DEVICE_CONTROL

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>

#include "i82930.h"
#include "ioctl.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, I82930_DeviceControl)
#pragma alloc_text(PAGE, I82930_IoctlGetDeviceDescriptor)
#pragma alloc_text(PAGE, I82930_IoctlGetConfigDescriptor)
#pragma alloc_text(PAGE, I82930_IoctlSetConfigDescriptor)
#pragma alloc_text(PAGE, I82930_ValidateConfigurationDescriptor)
#pragma alloc_text(PAGE, I82930_IoctlGetPipeInformation)
#pragma alloc_text(PAGE, I82930_IoctlResetPipe)
#endif


//******************************************************************************
//
// I82930_DeviceControl()
//
// Dispatch routine which handles IRP_MJ_DEVICE_CONTROL
//
//******************************************************************************

NTSTATUS
I82930_DeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    ULONG               ioControlCode;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_DeviceControl\n"));

    LOGENTRY('IOCT', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_IOCTL);

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->AcceptingRequests)
    {
        irpStack = IoGetCurrentIrpStackLocation(Irp);

        ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

        switch (ioControlCode)
        {
            case IOCTL_I82930_GET_DEVICE_DESCRIPTOR:
                ntStatus = I82930_IoctlGetDeviceDescriptor(DeviceObject,
                                                           Irp);
                break;

            case IOCTL_I82930_GET_CONFIG_DESCRIPTOR:
                ntStatus = I82930_IoctlGetConfigDescriptor(DeviceObject,
                                                           Irp);
                break;

            case IOCTL_I82930_SET_CONFIG_DESCRIPTOR:
                ntStatus = I82930_IoctlSetConfigDescriptor(DeviceObject,
                                                           Irp);
                break;

            case IOCTL_I82930_GET_PIPE_INFORMATION:
                ntStatus = I82930_IoctlGetPipeInformation(DeviceObject,
                                                          Irp);
                break;

            case IOCTL_I82930_RESET_PIPE:
                ntStatus = I82930_IoctlResetPipe(DeviceObject,
                                                 Irp);
                break;

            case IOCTL_I82930_STALL_PIPE:
                ntStatus = I82930_IoctlStallPipe(DeviceObject,
                                                 Irp);
                break;

            case IOCTL_I82930_ABORT_PIPE:
                ntStatus = I82930_IoctlAbortPipe(DeviceObject,
                                                 Irp);
                break;

            case IOCTL_I82930_RESET_DEVICE:
                ntStatus = I82930_IoctlResetDevice(DeviceObject,
                                                   Irp);
                break;

            case IOCTL_I82930_SELECT_ALTERNATE_INTERFACE:
                ntStatus = I82930_IoctlSelectAlternateInterface(DeviceObject,
                                                                Irp);
                break;

            default:
                ntStatus = STATUS_INVALID_PARAMETER;
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
        }
    }
    else
    {
        ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  I82930_DeviceControl %08X\n", ntStatus));

    LOGENTRY('ioct', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlGetDeviceDescriptor()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_GET_DEVICE_DESCRIPTOR
//
//******************************************************************************

NTSTATUS
I82930_IoctlGetDeviceDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PVOID               dest;
    ULONG               destLength;
    PVOID               src;
    ULONG               srcLength;
    ULONG               copyLength;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlGetDeviceDescriptor\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack    = IoGetCurrentIrpStackLocation(Irp);

    dest        = Irp->AssociatedIrp.SystemBuffer;
    destLength  = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    src         = deviceExtension->DeviceDescriptor;
    srcLength   = sizeof(USB_DEVICE_DESCRIPTOR);

    copyLength  = (destLength < srcLength) ? destLength : srcLength;

    RtlCopyMemory(dest, src, copyLength);

    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = copyLength;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlGetDeviceDescriptor %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlGetConfigDescriptor()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_GET_CONFIG_DESCRIPTOR
//
//******************************************************************************

NTSTATUS
I82930_IoctlGetConfigDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PVOID               dest;
    ULONG               destLength;
    PVOID               src;
    ULONG               srcLength;
    ULONG               copyLength;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlGetConfigDescriptor\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack    = IoGetCurrentIrpStackLocation(Irp);

    dest        = Irp->AssociatedIrp.SystemBuffer;
    destLength  = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    src         = deviceExtension->ConfigurationDescriptor;
    srcLength   = deviceExtension->ConfigurationDescriptor->wTotalLength;

    copyLength  = (destLength < srcLength) ? destLength : srcLength;

    RtlCopyMemory(dest, src, copyLength);

    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = copyLength;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlGetConfigDescriptor %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlSetConfigDescriptor()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_SET_CONFIG_DESCRIPTOR
//
//******************************************************************************

NTSTATUS
I82930_IoctlSetConfigDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION               deviceExtension;
    PIO_STACK_LOCATION              irpStack;
    PUSB_CONFIGURATION_DESCRIPTOR   configDesc;
    PUSB_CONFIGURATION_DESCRIPTOR   configDescCopy;
    ULONG                           length;
    NTSTATUS                        ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlSetConfigDescriptor\n"));

    ntStatus    = STATUS_SUCCESS;

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack    = IoGetCurrentIrpStackLocation(Irp);

    configDesc  = (PUSB_CONFIGURATION_DESCRIPTOR)Irp->AssociatedIrp.SystemBuffer;
    length      = irpStack->Parameters.DeviceIoControl.InputBufferLength;

    if (!I82930_ValidateConfigurationDescriptor(configDesc, length))
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(ntStatus))
    {
        configDescCopy = ExAllocatePool(NonPagedPool, length);

        if (configDescCopy != NULL)
        {
            RtlCopyMemory(configDescCopy, configDesc, length);
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = I82930_UnConfigure(DeviceObject);
    }

    if (NT_SUCCESS(ntStatus))
    {
        ASSERT(deviceExtension->ConfigurationDescriptor != NULL);

        ExFreePool(deviceExtension->ConfigurationDescriptor);

        deviceExtension->ConfigurationDescriptor = configDescCopy;

        ntStatus = I82930_SelectConfiguration(DeviceObject);
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlSetConfigDescriptor %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_ValidateConfigurationDescriptor()
//
// This routine verifies that a Configuration Descriptor is valid.
//
//******************************************************************************

BOOLEAN
I82930_ValidateConfigurationDescriptor (
    IN  PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc,
    IN  ULONG                           Length
    )
{
    PUCHAR                      descEnd;
    PUSB_COMMON_DESCRIPTOR      commonDesc;
    PUSB_INTERFACE_DESCRIPTOR   interfaceDesc;
    UCHAR                       numInterfaces;
    UCHAR                       numEndpoints;

    PAGED_CODE();

    //
    // Validate the Configuration Descriptor header
    //

    if (Length < sizeof(USB_CONFIGURATION_DESCRIPTOR))
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad Length\n"));

        return FALSE;
    }

    if (ConfigDesc->bLength != sizeof(USB_CONFIGURATION_DESCRIPTOR))
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad bLength\n"));

        return FALSE;
    }

    if (ConfigDesc->bDescriptorType != USB_CONFIGURATION_DESCRIPTOR_TYPE)
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad bDescriptorType\n"));

        return FALSE;
    }

    if (ConfigDesc->wTotalLength != Length)
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: wTotalLength != Length\n"));

        return FALSE;
    }

    //
    // End of descriptor pointer, one byte past the last valid byte.
    //
    descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

    //
    // Start at first descriptor past the Configuration Descriptor header
    //
    commonDesc = (PUSB_COMMON_DESCRIPTOR)((PUCHAR)ConfigDesc +
                                          sizeof(USB_CONFIGURATION_DESCRIPTOR));

    interfaceDesc = NULL;
    numInterfaces = 0;

    while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
           (PUCHAR)commonDesc + commonDesc->bLength <= descEnd)
    {
        // Is this an Interface Descriptor?
        //
        if ((commonDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE) &&
            (commonDesc->bLength         == sizeof(USB_INTERFACE_DESCRIPTOR)))
        {
            if ((interfaceDesc == NULL) ||
                (interfaceDesc->bInterfaceNumber !=
                 ((PUSB_INTERFACE_DESCRIPTOR)commonDesc)->bInterfaceNumber))
            {
                // One more Interface Descriptor for this Configuration Descriptor
                //
                numInterfaces++;
            }

            // If there was a previous Interface Descriptor, verify that there
            // were the correct number of Endpoint Descriptors
            //
            if ((interfaceDesc != NULL) &&
                (numEndpoints != interfaceDesc->bNumEndpoints))
            {
                DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad bNumEndpoints\n"));

                return FALSE;
            }

            // Remember the current Interface Descriptor
            //
            interfaceDesc = (PUSB_INTERFACE_DESCRIPTOR)commonDesc;

            // Reset the Endpoint Descriptor count for this Interface Descriptor
            //
            numEndpoints = 0;
        }
        // Is this an Endpoint Descriptor?
        //
        else if ((commonDesc->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE) &&
                 (commonDesc->bLength         == sizeof(USB_ENDPOINT_DESCRIPTOR)))
        {
            // One more Endpoint Descriptor for this Interface Descriptor
            //
            numEndpoints++;
        }
        else
        {
            DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad bDescriptorType and/or bLength\n"));

            return FALSE;
        }

        // Advance past this descriptor
        //
        (PUCHAR)commonDesc += commonDesc->bLength;
    }

    if ((PUCHAR)commonDesc != descEnd)
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad final descriptor\n"));

        return FALSE;
    }

    if (numInterfaces != ConfigDesc->bNumInterfaces)
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad bNumInterfaces and/or bLength\n"));
    }

    // If there was a previous Interface Descriptor, verify that there
    // were the correct number of Endpoint Descriptors
    //
    if ((interfaceDesc != NULL) &&
        (numEndpoints != interfaceDesc->bNumEndpoints))
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad bNumEndpoints\n"));

        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
//
// I82930_IoctlGetPipeInformation()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_GET_PIPE_INFORMATION
//
//******************************************************************************

NTSTATUS
I82930_IoctlGetPipeInformation (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PVOID               dest;
    ULONG               destLength;
    PVOID               src;
    ULONG               srcLength;
    ULONG               copyLength;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlGetPipeInformation\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->InterfaceInfo != NULL)
    {
        irpStack    = IoGetCurrentIrpStackLocation(Irp);

        dest        = Irp->AssociatedIrp.SystemBuffer;
        destLength  = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

        src         = deviceExtension->InterfaceInfo;
        srcLength   = deviceExtension->InterfaceInfo->Length;

        copyLength  = (destLength < srcLength) ? destLength : srcLength;

        RtlCopyMemory(dest, src, copyLength);

        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        copyLength = 0;

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = copyLength;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlGetPipeInformation %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlResetPipe()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_RESET_PIPE
//
//******************************************************************************

NTSTATUS
I82930_IoctlResetPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PFILE_OBJECT        fileObject;
    PI82930_PIPE        pipe;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlResetPipe\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    fileObject = irpStack->FileObject;

    pipe = fileObject->FsContext;

    if (pipe != NULL)
    {
        DBGPRINT(2, ("Reset pipe %2d %08X\n",
                     pipe->PipeIndex, pipe));

        ntStatus = I82930_ResetPipe(DeviceObject,
                                    pipe,
                                    TRUE);
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlResetPipe %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlStallPipe()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_STALL_PIPE
//
//******************************************************************************

NTSTATUS
I82930_IoctlStallPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PFILE_OBJECT        fileObject;
    PI82930_PIPE        pipe;
    PURB                urb;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlStallPipe\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    fileObject = irpStack->FileObject;

    pipe = fileObject->FsContext;

    if (pipe != NULL)
    {
        DBGPRINT(2, ("Stall pipe %2d %08X\n",
                     pipe->PipeIndex, pipe));

        // Allocate URB for CONTROL_FEATURE request
        //
        urb = ExAllocatePool(NonPagedPool,
                             sizeof(struct _URB_CONTROL_FEATURE_REQUEST));

        if (urb != NULL)
        {
            // Initialize CONTROL_FEATURE request URB
            //
            urb->UrbHeader.Length   = sizeof (struct _URB_CONTROL_FEATURE_REQUEST);
            urb->UrbHeader.Function = URB_FUNCTION_SET_FEATURE_TO_ENDPOINT;
            urb->UrbControlFeatureRequest.UrbLink = NULL;
            urb->UrbControlFeatureRequest.FeatureSelector = USB_FEATURE_ENDPOINT_STALL;
            urb->UrbControlFeatureRequest.Index = pipe->PipeInfo->EndpointAddress;

            // Submit CONTROL_FEATURE request URB
            //
            ntStatus = I82930_SyncSendUsbRequest(DeviceObject, urb);

            // Done with URB for CONTROL_FEATURE request, free it
            //
            ExFreePool(urb);
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlStallPipe %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlAbortPipe()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_ABORT_PIPE
//
//******************************************************************************

NTSTATUS
I82930_IoctlAbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PFILE_OBJECT        fileObject;
    PI82930_PIPE        pipe;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlAbortPipe\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    fileObject = irpStack->FileObject;

    pipe = fileObject->FsContext;

    if (pipe != NULL)
    {
        DBGPRINT(2, ("Abort pipe %2d %08X\n",
                     pipe->PipeIndex, pipe));

        ntStatus = I82930_AbortPipe(DeviceObject,
                                    pipe);
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlAbortPipe %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlResetDevice()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_RESET_DEVICE
//
//******************************************************************************

NTSTATUS
I82930_IoctlResetDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  nextStack;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlResetDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(Irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_RESET_PORT;

    ntStatus = I82930_SyncPassDownIrp(DeviceObject,
                                      Irp,
                                      FALSE);

    // Must complete request since completion routine returned
    // STATUS_MORE_PROCESSING_REQUIRED
    //
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlResetDevice %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlSelectAlternateInterface()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_SELECT_ALTERNATE_INTERFACE
//
//******************************************************************************

NTSTATUS
I82930_IoctlSelectAlternateInterface (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    UCHAR               alternateSetting;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlSelectAlternateInterface\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack    = IoGetCurrentIrpStackLocation(Irp);

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength == sizeof(UCHAR))
    {
        alternateSetting = *(PUCHAR)Irp->AssociatedIrp.SystemBuffer;

        DBGPRINT(2, ("Select AlternateInterface %d\n",
                     alternateSetting));


        ntStatus = I82930_SelectAlternateInterface(DeviceObject,
                                                   alternateSetting);
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlSelectAlternateInterface %08X\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\i82930\sys\i82930.h ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    I82930.H

Abstract:

    Header file for I82930 driver

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include "dbg.h"

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#define USB_RECIPIENT_DEVICE    0
#define USB_RECIPIENT_INTERFACE 1
#define USB_RECIPIENT_ENDPOINT  2
#define USB_RECIPIENT_OTHER     3

// Endpoint numbers are 0-15.  Endpoint number 0 is the standard control
// endpoint which is not explicitly listed in the Configuration Descriptor.
// There can be an IN endpoint and an OUT endpoint at endpoint numbers
// 1-15 so there can be a maximum of 30 endpoints per device configuration.
//
#define I82930_MAX_PIPES        30

#define POOL_TAG                '039I'

#define INCREMENT_OPEN_COUNT(deviceExtension) \
    InterlockedIncrement(&(((PDEVICE_EXTENSION)(deviceExtension))->OpenCount))

#define DECREMENT_OPEN_COUNT(deviceExtension) do { \
    if (InterlockedDecrement(&(((PDEVICE_EXTENSION)(deviceExtension))->OpenCount)) == 0) { \
        KeSetEvent(&((deviceExtension)->RemoveEvent), \
                   IO_NO_INCREMENT, \
                   0); \
    } \
} while (0)


//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef struct _I82930_PIPE {

    // Pointer into PDEVICE_EXTENSION->InterfaceInfo.Pipes[]
    //
    PUSBD_PIPE_INFORMATION  PipeInfo;

    // Index into PDEVICE_EXTENSION->PipeList[]
    //
    UCHAR                   PipeIndex;

    // TRUE if pipe is currently open
    //
    BOOLEAN                 Opened;

    UCHAR                   Pad[2];

} I82930_PIPE, *PI82930_PIPE;


typedef struct _DEVICE_EXTENSION
{
    // PDO passed to I82930_AddDevice
    //
    PDEVICE_OBJECT                  PhysicalDeviceObject;

    // Our FDO is attached to this device object
    //
    PDEVICE_OBJECT                  StackDeviceObject;

    // Device Descriptor retrieved from the device
    //
    PUSB_DEVICE_DESCRIPTOR          DeviceDescriptor;

    // Configuration Descriptor retrieved from the device
    //
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigurationDescriptor;

    // ConfigurationHandle returned from URB_FUNCTION_SELECT_CONFIGURATION
    //
    USBD_CONFIGURATION_HANDLE       ConfigurationHandle;

    // Interface info returned from URB_FUNCTION_SELECT_CONFIGURATION
    //
    PUSBD_INTERFACE_INFORMATION     InterfaceInfo;

    // Name of our symbolic link
    //
    UNICODE_STRING                  SymbolicLinkName;

    // Initialized to one in AddDevice.
    // Incremented by one for every open.
    // Decremented by one for every close.
    // Decremented by one in REMOVE_DEVICE.
    //
    ULONG                           OpenCount;

    // Set when OpenCount is decremented to zero
    //
    KEVENT                          RemoveEvent;

    // Current system power state
    //
    SYSTEM_POWER_STATE              SystemPowerState;

    // Current device power state
    //
    DEVICE_POWER_STATE              DevicePowerState;

    // Current power Irp, set by I82930_FdoSetPower(), used by
    // I82930_FdoSetPowerCompletion().
    //
    PIRP                            CurrentPowerIrp;

    // Inialized to FALSE in AddDevice.
    // Set to TRUE in START_DEVICE.
    // Set to FALSE in STOP_DEVICE and REMOVE_DEVICE.
    //
    BOOLEAN                         AcceptingRequests;

    UCHAR                           Pad[3];

    // Array of info about each pipe in the current device configuration
    //
    I82930_PIPE                     PipeList[I82930_MAX_PIPES];

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************

//
// I82930.C
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

VOID
I82930_Unload (
    IN PDRIVER_OBJECT   DriverObject
    );

NTSTATUS
I82930_AddDevice (
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );

NTSTATUS
I82930_Power (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_FdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
I82930_FdoSetPowerCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
I82930_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_Pnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_StartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_StopDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_RemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_QueryStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_CancelStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_QueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_SyncPassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          CopyToNext
    );

NTSTATUS
I82930_SyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
I82930_SyncSendUsbRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    );

NTSTATUS
I82930_GetDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            DescriptorType,
    IN UCHAR            Index,
    IN USHORT           LanguageId,
    IN ULONG            RetryCount,
    IN ULONG            DescriptorLength,
    OUT PUCHAR         *Descriptor
    );

NTSTATUS
I82930_SelectConfiguration (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
I82930_UnConfigure (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
I82930_SelectAlternateInterface (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            AlternateSetting
    );

//
// OCRW.C
//

NTSTATUS
I82930_Create (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_Close (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_ReadWrite (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_ReadWrite_Complete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

PURB
I82930_BuildAsyncUrb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PI82930_PIPE     Pipe
    );

PURB
I82930_BuildIsoUrb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PI82930_PIPE     Pipe
    );

ULONG
I82930_GetCurrentFrame (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_ResetPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PI82930_PIPE     Pipe,
    IN BOOLEAN          IsoClearStall
    );

NTSTATUS
I82930_AbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PI82930_PIPE     Pipe
    );

//
// IOCTL.C
//

NTSTATUS
I82930_DeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlGetDeviceDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlGetConfigDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlSetConfigDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

BOOLEAN
I82930_ValidateConfigurationDescriptor (
    IN  PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc,
    IN  ULONG                           Length
    );

NTSTATUS
I82930_IoctlGetPipeInformation (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlResetPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlStallPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlAbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlResetDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlSelectAlternateInterface (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isodev.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isodev.c

Abstract:

    This file contains dispatch routines 
    for create and close. This file also 
    contains routines to selectively suspend 
    the device. The selective suspend feature
    is usb specific and not hardware specific.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isousr.h"
#include "isowmi.h"
#include "isorwr.h"
#include "isostrm.h"

NTSTATUS
IsoUsb_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for create.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet.

Return Value:

    NT status value

--*/
{

    LONG                        i;
    NTSTATUS                    ntStatus;
    PFILE_OBJECT                fileObject;
    PDEVICE_EXTENSION           deviceExtension;
    PIO_STACK_LOCATION          irpStack;
    PFILE_OBJECT_CONTENT        fileObjectContent;
    PUSBD_INTERFACE_INFORMATION interface;


    i = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    PAGED_CODE();

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchCreate - begins\n"));

    if(deviceExtension->DeviceState != Working) {

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto IsoUsb_DispatchCreate_Exit;
    }

    if(deviceExtension->UsbInterface) {
    
        interface = deviceExtension->UsbInterface;    
    }
    else {

        IsoUsb_DbgPrint(1, ("UsbInterface not found\n"));

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto IsoUsb_DispatchCreate_Exit;
    }

    if(fileObject) {
        
        fileObject->FsContext = NULL;
    }
    else {

        ntStatus = STATUS_INVALID_PARAMETER;
        goto IsoUsb_DispatchCreate_Exit;
    }

    fileObject->FsContext = ExAllocatePool(NonPagedPool,
                                           sizeof(FILE_OBJECT_CONTENT));

    if(NULL == fileObject->FsContext) {

        IsoUsb_DbgPrint(1, ("failed to alloc memory for FILE_OBJECT_CONTENT\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto IsoUsb_DispatchCreate_Exit;
    }

    fileObjectContent = (PFILE_OBJECT_CONTENT) fileObject->FsContext;
    fileObjectContent->PipeInformation = NULL;
    fileObjectContent->StreamInformation = NULL;

    if(0 != fileObject->FileName.Length) {

        i = IsoUsb_ParseStringForPipeNumber(&fileObject->FileName);

        IsoUsb_DbgPrint(3, ("create request for pipe # %X\n", i));

        if((i < 0) || 
           (i >= (LONG)(deviceExtension->UsbInterface->NumberOfPipes))) {
    
            ntStatus = STATUS_INVALID_PARAMETER;

            IsoUsb_DbgPrint(1, ("invalid pipe number\n"));
            ExFreePool(fileObject->FsContext);
            fileObject->FsContext = NULL;
            goto IsoUsb_DispatchCreate_Exit;
        }

        fileObjectContent->PipeInformation = (PVOID) &interface->Pipes[i];
    }

    ntStatus = STATUS_SUCCESS;

    InterlockedIncrement(&deviceExtension->OpenHandleCount);
        
    //
    // the device is idle if it has no open handles or pending PnP Irps
    // since we just received an open handle request, cancel idle req.
    //
    if(deviceExtension->SSEnable) {
    
        CancelSelectSuspend(deviceExtension);
    }

IsoUsb_DispatchCreate_Exit:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchCreate - ends\n"));
    
    return ntStatus;
}

NTSTATUS
IsoUsb_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for close.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    NTSTATUS             ntStatus;
    PFILE_OBJECT         fileObject;
    PDEVICE_EXTENSION    deviceExtension;
    PIO_STACK_LOCATION   irpStack;
    PFILE_OBJECT_CONTENT fileObjectContent;
    
    PAGED_CODE();

    //
    // initialize variables
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    
    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchClose - begins\n"));

    if(fileObject && fileObject->FsContext) {

        fileObjectContent = (PFILE_OBJECT_CONTENT) fileObject->FsContext;

        ASSERT(NULL == fileObjectContent->StreamInformation);

        ExFreePool(fileObjectContent);

        fileObject->FsContext = NULL;
    }

    //
    // set ntStatus to STATUS_SUCCESS 
    //
    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    InterlockedDecrement(&deviceExtension->OpenHandleCount);

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchClose - ends\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    Dispatch routine for IRP_MJ_DEVICE_CONTROL

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    ULONG              code;
    PVOID              ioBuffer;
    ULONG              inputBufferLength;
    ULONG              outputBufferLength;
    ULONG              info;
    NTSTATUS           ntStatus;
    PFILE_OBJECT       fileObject;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    info = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    code = irpStack->Parameters.DeviceIoControl.IoControlCode;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if(deviceExtension->DeviceState != Working) {

        IsoUsb_DbgPrint(1, ("Invalid device state\n"));

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = info;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return ntStatus;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchDevCtrl::"));
    IsoUsb_IoIncrement(deviceExtension);

    //
    // make sure that the selective suspend request has been completed.
    //
    if(deviceExtension->SSEnable) {

        //
        // It is true that the client driver cancelled the selective suspend
        // request in the dispatch routine for create.
        // But there is no guarantee that it has indeed been completed.
        // so wait on the NoIdleReqPendEvent and proceed only if this event
        // is signalled.
        //
        IsoUsb_DbgPrint(3, ("Waiting on the IdleReqPendEvent\n"));
        
        KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
    }

    switch(code) {

    case IOCTL_ISOUSB_RESET_PIPE:
    {
        PUSBD_PIPE_INFORMATION pipe;

        pipe = NULL;

        if(fileObject && fileObject->FsContext) {
            
            pipe = (PUSBD_PIPE_INFORMATION)
                   ((PFILE_OBJECT_CONTENT)fileObject->FsContext)->PipeInformation;
        }

        if(pipe == NULL) {

            ntStatus = STATUS_INVALID_PARAMETER;
        }
        else {
            
            ntStatus = IsoUsb_ResetPipe(DeviceObject, pipe);
        }

        break;
    }

    case IOCTL_ISOUSB_GET_CONFIG_DESCRIPTOR:
    {
        ULONG length;

        if(deviceExtension->UsbConfigurationDescriptor) {

            length = deviceExtension->UsbConfigurationDescriptor->wTotalLength;

            if(outputBufferLength >= length) {

                RtlCopyMemory(ioBuffer,
                              deviceExtension->UsbConfigurationDescriptor,
                              length);

                info = length;

                ntStatus = STATUS_SUCCESS;
            }
            else {
                
                ntStatus = STATUS_INVALID_BUFFER_SIZE;
            }
        }
        else {
            
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        break;
    }

    case IOCTL_ISOUSB_RESET_DEVICE:
        
        ntStatus = IsoUsb_ResetDevice(DeviceObject);

        break;

    case IOCTL_ISOUSB_START_ISO_STREAM:

        ntStatus = IsoUsb_StartIsoStream(DeviceObject, Irp);

        return STATUS_SUCCESS;

    case IOCTL_ISOUSB_STOP_ISO_STREAM:
    {
           
        PFILE_OBJECT_CONTENT fileObjectContent;
        
        if(fileObject && fileObject->FsContext) {

            fileObjectContent = (PFILE_OBJECT_CONTENT)
                                fileObject->FsContext;

            ntStatus = IsoUsb_StopIsoStream(
                            DeviceObject,
                            InterlockedExchangePointer(
                                &fileObjectContent->StreamInformation,
                                NULL),
                            Irp);
        }
        else {

            ntStatus = STATUS_UNSUCCESSFUL;
        }

        break;
    }

    default :

        ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        break;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = info;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchDevCtrl::"));
    IsoUsb_IoDecrement(deviceExtension);

    return ntStatus;
}

LONG
IsoUsb_ParseStringForPipeNumber(
    IN PUNICODE_STRING PipeName
    )
/*++
 
Routine Description:

    This routine parses the PipeName for the Pipe#

Arguments:

    PipeName - Unicode string for the pipe name

Return Value:

    Pipe number

--*/
{
    LONG  bufferIndex;
    ULONG uval;
    ULONG umultiplier;

    if(PipeName->Length == 0) {

        return -1;
    }

    bufferIndex = (PipeName->Length / sizeof(WCHAR)) - 1;

    while((bufferIndex > -1) && 
          ((PipeName->Buffer[bufferIndex] < (WCHAR) '0')  ||
           (PipeName->Buffer[bufferIndex] > (WCHAR) '9')))           {
        
        bufferIndex--;
    }

    if(bufferIndex > -1) {

        uval = 0;
        umultiplier = 1;

        while((bufferIndex > -1) &&
              (PipeName->Buffer[bufferIndex] >= (WCHAR) '0') &&
              (PipeName->Buffer[bufferIndex] <= (WCHAR) '9'))        {

            uval += (umultiplier *
                     (ULONG) (PipeName->Buffer[bufferIndex] - (WCHAR) '0'));
            bufferIndex--;
            umultiplier *= 10;
        }

        return uval;
    }

    return -1;
}

NTSTATUS
IsoUsb_ResetPipe(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInfo
    )
/*++
 
Routine Description:

    This routine submits an irp/urb pair synchronously
    with function code URB_FUNCTION_RESET_PIPE to reset
    the pipe

Arguments:

    DeviceObject - pointer to device object
    PipeInfo - pointer to USBD_PIPE_INFORMATION

Return Value:

    NT status value

--*/
{
    PURB              urb;
    NTSTATUS          ntStatus;
    USBD_STATUS       usbdStatus;
    PDEVICE_EXTENSION deviceExtension;

    //
    // initialize variables
    //

    urb = NULL;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_PIPE_REQUEST));

    if(urb) {

        urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        urb->UrbPipeRequest.PipeHandle = PipeInfo->PipeHandle;

        ntStatus = CallUSBD(DeviceObject, urb);

        usbdStatus = urb->UrbHeader.Status;

        ExFreePool(urb);
    }
    else {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(NT_SUCCESS(ntStatus) &&
       USBD_SUCCESS(usbdStatus)) {
    
        IsoUsb_DbgPrint(3, ("IsoUsb_ResetPipe - success\n"));
        ntStatus = STATUS_SUCCESS;
    }
    else {

        IsoUsb_DbgPrint(1, ("IsoUsb_ResetPipe - failed with "
                            "Irp status = %X and Urb status = %X\n",
                            ntStatus,
                            usbdStatus));
    }

    return ntStatus;
}

NTSTATUS
IsoUsb_ResetDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine resets the device

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    NTSTATUS ntStatus;
    ULONG    portStatus;

    IsoUsb_DbgPrint(3, ("IsoUsb_ResetDevice - begins\n"));

    ntStatus = IsoUsb_GetPortStatus(DeviceObject, &portStatus);

    if((NT_SUCCESS(ntStatus))                 &&
       (!(portStatus & USBD_PORT_ENABLED))    &&
       (portStatus & USBD_PORT_CONNECTED)) {

        ntStatus = IsoUsb_ResetParentPort(DeviceObject);
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_ResetDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_GetPortStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PULONG     PortStatus
    )
/*++
 
Routine Description:

    This routine fetches the port status value

Arguments:

    DeviceObject - pointer to device object
    PortStatus - pointer to ULONG to contain the status value

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    KEVENT             event;
    PIRP               irp;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    *PortStatus = 0;

    IsoUsb_DbgPrint(3, ("IsoUsb_GetPortStatus - begins\n"));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                    IOCTL_INTERNAL_USB_GET_PORT_STATUS,
                    deviceExtension->TopOfStackDeviceObject,
                    NULL,
                    0,
                    NULL,
                    0,
                    TRUE,
                    &event,
                    &ioStatus);

    if(NULL == irp) {

        IsoUsb_DbgPrint(1, ("memory alloc for irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);

    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = PortStatus;

    IsoUsb_DbgPrint(3, ("IsoUsb_GetPortStatus::"));
    IsoUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(STATUS_PENDING == ntStatus) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }
    else {

        ioStatus.Status = ntStatus;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_GetPortStatus::"));
    IsoUsb_IoDecrement(deviceExtension);

    ntStatus = ioStatus.Status;

    IsoUsb_DbgPrint(3, ("IsoUsb_GetPortStatus - ends\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_ResetParentPort(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine will submit an IOCTL_INTERNAL_USB_RESET_PORT,
    down the stack

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    KEVENT             event;
    PIRP               irp;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("IsoUsb_ResetParentPort - begins\n"));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                    IOCTL_INTERNAL_USB_RESET_PORT,
                    deviceExtension->TopOfStackDeviceObject,
                    NULL,
                    0,
                    NULL,
                    0,
                    TRUE,
                    &event,
                    &ioStatus);

    if(NULL == irp) {

        IsoUsb_DbgPrint(1, ("memory alloc for irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);

    ASSERT(nextStack != NULL);

    IsoUsb_DbgPrint(3, ("IsoUsb_ResetParentPort"));
    IsoUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(STATUS_PENDING == ntStatus) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }
    else {

        ioStatus.Status = ntStatus;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_ResetParentPort"));
    IsoUsb_IoDecrement(deviceExtension);

    ntStatus = ioStatus.Status;

    IsoUsb_DbgPrint(3, ("IsoUsb_ResetParentPort - ends\n"));

    return ntStatus;
}


NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine builds an idle request irp with an associated callback routine
    and a completion routine in the driver and passes the irp down the stack.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    PIRP                    irp;
    NTSTATUS                ntStatus;
    KIRQL                   oldIrql;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    PIO_STACK_LOCATION      nextStack;

    //
    // initialize variables
    //
    
    irp = NULL;
    idleCallbackInfo = NULL;

    IsoUsb_DbgPrint(3, ("SubmitIdleRequest - begins\n"));

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    if(PowerDeviceD0 != DeviceExtension->DevPower) {

        ntStatus = STATUS_POWER_STATE_INVALID;
        goto SubmitIdleRequestIrp_Exit;
    }

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(InterlockedExchange(&DeviceExtension->IdleReqPend, 1)) {

        IsoUsb_DbgPrint(1, ("Idle request pending..\n"));

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_DEVICE_BUSY;

        goto SubmitIdleRequestIrp_Exit;
    }

    //
    // clear the NoIdleReqPendEvent because we are about 
    // to submit an idle request. Since we are so early
    // to clear this event, make sure that if we fail this
    // request we set back the event.
    //
    KeClearEvent(&DeviceExtension->NoIdleReqPendEvent);

    idleCallbackInfo = ExAllocatePool(NonPagedPool, 
                                      sizeof(struct _USB_IDLE_CALLBACK_INFO));

    if(idleCallbackInfo) {

        idleCallbackInfo->IdleCallback = IdleNotificationCallback;

        idleCallbackInfo->IdleContext = (PVOID)DeviceExtension;

        ASSERT(DeviceExtension->IdleCallbackInfo == NULL);

        DeviceExtension->IdleCallbackInfo = idleCallbackInfo;
        //
        // we use IoAllocateIrp to create an irp to selectively suspend the 
        // device. This irp lies pending with the hub driver. When appropriate
        // the hub driver will invoked callback, where we power down. The completion
        // routine is invoked when we power back.
        //
        irp = IoAllocateIrp(DeviceExtension->TopOfStackDeviceObject->StackSize,
                            FALSE);

        if(irp == NULL) {

            IsoUsb_DbgPrint(1, ("cannot build idle request irp\n"));

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            ExFreePool(idleCallbackInfo);

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto SubmitIdleRequestIrp_Exit;
        }

        nextStack = IoGetNextIrpStackLocation(irp);

        nextStack->MajorFunction = 
                    IRP_MJ_INTERNAL_DEVICE_CONTROL;

        nextStack->Parameters.DeviceIoControl.IoControlCode = 
                    IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;

        nextStack->Parameters.DeviceIoControl.Type3InputBuffer =
                    idleCallbackInfo;

        nextStack->Parameters.DeviceIoControl.InputBufferLength =
                    sizeof(struct _USB_IDLE_CALLBACK_INFO);


        IoSetCompletionRoutine(irp, 
                               IdleNotificationRequestComplete,
                               DeviceExtension, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        DeviceExtension->PendingIdleIrp = irp;
        //
        // we initialize the count to 2.
        // The reason is, if the CancelSelectSuspend routine manages
        // to grab the irp from the device extension, then the last of the
        // CancelSelectSuspend routine/IdleNotificationRequestComplete routine 
        // to execute will free this irp. We need to have this schema so that
        // 1. completion routine does not attempt to touch the irp freed by 
        //    CancelSelectSuspend routine.
        // 2. CancelSelectSuspend routine doesnt wait for ever for the completion
        //    routine to complete!
        //
        DeviceExtension->FreeIdleIrpCount = 2;

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        //
        // check if the device is idle.
        // A check here ensures that a race condition did not 
        // completely reverse the call sequence of SubmitIdleRequestIrp
        // and CancelSelectiveSuspend
        //

        if(!CanDeviceSuspend(DeviceExtension) ||
           PowerDeviceD0 != DeviceExtension->DevPower) {

            //
            // device cannot suspend - abort.
            // also irps created using IoAllocateIrp 
            // needs to be deallocated.
            //
     
            IsoUsb_DbgPrint(1, ("Device is not idle\n"));

            KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

            DeviceExtension->IdleCallbackInfo = NULL;

            DeviceExtension->PendingIdleIrp = NULL;

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            if(idleCallbackInfo) {

                ExFreePool(idleCallbackInfo);
            }

            //
            // it is still safe to touch the local variable "irp" here.
            // the irp has not been passed down the stack, the irp has
            // no cancellation routine. The worse position is that the
            // CancelSelectSuspend has run after we released the spin 
            // lock above. It is still essential to free the irp.
            //

            if(irp) {
            
                IoFreeIrp(irp);
            }

            ntStatus = STATUS_UNSUCCESSFUL;

            goto SubmitIdleRequestIrp_Exit;
        }

        IsoUsb_DbgPrint(3, ("Cancel the timers\n"));

        //
        // Cancel the timer so that the DPCs are no longer fired.
        // Thus, we are making judicious usage of our resources.
        // we do not need DPCs because we already have an idle irp pending.
        // The timers are re-initialized in the completion routine.
        //
        KeCancelTimer(&DeviceExtension->Timer);

        ntStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject, irp);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(1, ("IoCallDriver failed\n"));

            goto SubmitIdleRequestIrp_Exit;
        }
    }
    else {

        IsoUsb_DbgPrint(1, ("Memory allocation for idleCallbackInfo failed\n"));

        KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                   IO_NO_INCREMENT,
                   FALSE);

        InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

SubmitIdleRequestIrp_Exit:

    IsoUsb_DbgPrint(3, ("SubmitIdleRequest - ends\n"));

    return ntStatus;
}


VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  "A pointer to a callback function in your driver is passed down the stack with
   this IOCTL, and it is this callback function that is called by USBHUB when it
   safe for your device to power down."

  "When the callback in your driver is called, all you really need to do is to
   to first ensure that a WaitWake Irp has been submitted for your device, if 
   remote wake is possible for your device and then request a SetD2 (or DeviceWake)"

Arguments:

Return Value:

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KEVENT                  irpCompletionEvent;
    PIRP_COMPLETION_CONTEXT irpContext;

    IsoUsb_DbgPrint(3, ("IdleNotificationCallback - begins\n"));

    //
    // Dont idle, if the device was just disconnected or being stopped
    // i.e. return for the following DeviceState(s)
    // NotStarted, Stopped, PendingStop, PendingRemove, SurpriseRemoved, Removed
    //

    if(DeviceExtension->DeviceState != Working) {

        return;
    }

    //
    // If there is not already a WW IRP pending, submit one now
    //
    if(DeviceExtension->WaitWakeEnable) {

        IssueWaitWake(DeviceExtension);
    }


    //
    // power down the device
    //

    irpContext = (PIRP_COMPLETION_CONTEXT) 
                 ExAllocatePool(NonPagedPool,
                                sizeof(IRP_COMPLETION_CONTEXT));

    if(!irpContext) {

        IsoUsb_DbgPrint(1, ("Failed to alloc memory for irpContext\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        //
        // increment the count. In the HoldIoRequestWorkerRoutine, the
        // count is decremented twice (one for the system Irp and the 
        // other for the device Irp. An increment here compensates for 
        // the sytem irp..The decrement corresponding to this increment 
        // is in the completion function
        //

        IsoUsb_DbgPrint(3, ("IdleNotificationCallback::"));
        IsoUsb_IoIncrement(DeviceExtension);

        powerState.DeviceState = DeviceExtension->PowerDownLevel;

        KeInitializeEvent(&irpCompletionEvent, NotificationEvent, FALSE);

        irpContext->DeviceExtension = DeviceExtension;
        irpContext->Event = &irpCompletionEvent;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpCompletionFunc,
                          irpContext, 
                          NULL);

        if(STATUS_PENDING == ntStatus) {

            IsoUsb_DbgPrint(3, ("IdleNotificationCallback::"
                           "waiting for the power irp to complete\n"));

            KeWaitForSingleObject(&irpCompletionEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
    }
    
    if(!NT_SUCCESS(ntStatus)) {

        if(irpContext) {

            ExFreePool(irpContext);
        }
    }

    IsoUsb_DbgPrint(3, ("IdleNotificationCallback - ends\n"));
}


NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KIRQL                   oldIrql;
    PIRP                    idleIrp;
    LARGE_INTEGER           dueTime;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;

    IsoUsb_DbgPrint(3, ("IdleNotificationRequestCompete - begins\n"));

    idleIrp = NULL;

    //
    // check the Irp status
    //

    ntStatus = Irp->IoStatus.Status;

    if(!NT_SUCCESS(ntStatus) && ntStatus != STATUS_NOT_SUPPORTED) {

        IsoUsb_DbgPrint(1, ("Idle irp completes with error::"));

        switch(ntStatus) {
            
        case STATUS_INVALID_DEVICE_REQUEST:

            IsoUsb_DbgPrint(1, ("STATUS_INVALID_DEVICE_REQUEST\n"));

            break;

        case STATUS_CANCELLED:

            IsoUsb_DbgPrint(1, ("STATUS_CANCELLED\n"));

            break;

        case STATUS_POWER_STATE_INVALID:

            IsoUsb_DbgPrint(1, ("STATUS_POWER_STATE_INVALID\n"));

            goto IdleNotificationRequestComplete_Exit;

        case STATUS_DEVICE_BUSY:

            IsoUsb_DbgPrint(1, ("STATUS_DEVICE_BUSY\n"));

            break;

        default:

            IsoUsb_DbgPrint(1, ("default\n"));

            break;
        }

        //
        // if in error, issue a SetD0
        //

        if(PowerDeviceD0 != DeviceExtension->DevPower) {
            IsoUsb_DbgPrint(3, ("IdleNotificationRequestComplete::"));
            IsoUsb_IoIncrement(DeviceExtension);

            powerState.DeviceState = PowerDeviceD0;

            ntStatus = PoRequestPowerIrp(
                              DeviceExtension->PhysicalDeviceObject, 
                              IRP_MN_SET_POWER, 
                              powerState, 
                              (PREQUEST_POWER_COMPLETE) PoIrpAsyncCompletionFunc, 
                              DeviceExtension, 
                              NULL);

            if(!NT_SUCCESS(ntStatus)) {
    
                IsoUsb_DbgPrint(1, ("PoRequestPowerIrp failed\n"));
            }
        }
    }

IdleNotificationRequestComplete_Exit:

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    idleCallbackInfo = DeviceExtension->IdleCallbackInfo;

    DeviceExtension->IdleCallbackInfo = NULL;

    idleIrp = (PIRP) InterlockedExchangePointer(
                                        &DeviceExtension->PendingIdleIrp,
                                        NULL);

    InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    if(idleCallbackInfo) {

        ExFreePool(idleCallbackInfo);
    }

    //
    // since we allocated the irp, we need to free it.
    // return STATUS_MORE_PROCESSING_REQUIRED so that 
    // the kernel does not touch it.
    //

    if(idleIrp) {

        IsoUsb_DbgPrint(3, ("completion routine has a valid irp and frees it\n"));

        IoFreeIrp(Irp);

        KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
    else {

        //
        // The CancelSelectiveSuspend routine has grabbed the Irp from the device 
        // extension. Now the last one to decrement the FreeIdleIrpCount should
        // free the irp.
        //
        if(0 == InterlockedDecrement(&DeviceExtension->FreeIdleIrpCount)) {

            IsoUsb_DbgPrint(3, ("completion routine frees the irp\n"));
            
            IoFreeIrp(Irp);

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }

    if(DeviceExtension->SSEnable) {

        IsoUsb_DbgPrint(3, ("Set the timer to fire DPCs\n"));

        dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

        KeSetTimerEx(&DeviceExtension->Timer, 
                     dueTime,
                     IDLE_INTERVAL,                              // 5000 ms
                     &DeviceExtension->DeferredProcCall);

        IsoUsb_DbgPrint(3, ("IdleNotificationRequestCompete - ends\n"));
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine is invoked to cancel selective suspend request.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    None.

--*/
{
    PIRP  irp;
    KIRQL oldIrql;

    irp = NULL;

    IsoUsb_DbgPrint(3, ("CancelSelectSuspend - begins\n"));

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(!CanDeviceSuspend(DeviceExtension))
    {
        IsoUsb_DbgPrint(3, ("Device is not idle\n"));
    
        irp = (PIRP) InterlockedExchangePointer(
                            &DeviceExtension->PendingIdleIrp, 
                            NULL);
    }

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    //
    // since we have a valid Irp ptr,
    // we can call IoCancelIrp on it,
    // without the fear of the irp 
    // being freed underneath us.
    //
    if(irp) {

        //
        // This routine has the irp pointer.
        // It is safe to call IoCancelIrp because we know that
        // the compleiton routine will not free this irp unless...
        // 
        
        if(IoCancelIrp(irp)) {

            IsoUsb_DbgPrint(3, ("IoCancelIrp returns TRUE\n"));
        }
        else {
            IsoUsb_DbgPrint(3, ("IoCancelIrp returns FALSE\n"));
        }

        //
        // ....we decrement the FreeIdleIrpCount from 2 to 1.
        // if completion routine runs ahead of us, then this routine 
        // decrements the FreeIdleIrpCount from 1 to 0 and hence shall
        // free the irp.
        //

        if(0 == InterlockedDecrement(&DeviceExtension->FreeIdleIrpCount)) {

            IsoUsb_DbgPrint(3, ("CancelSelectSuspend frees the irp\n"));
            
            IoFreeIrp(irp);

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }

    IsoUsb_DbgPrint(3, ("CancelSelectSuspend - ends\n"));

    return;
}

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for power irp PoRequested in IdleNotification
    RequestComplete routine.

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.

Return Value:

    None

--*/
{
    PIRP_COMPLETION_CONTEXT irpContext;
    
    //
    // initialize variables
    //
    irpContext = NULL;


    if(Context) {

        irpContext = (PIRP_COMPLETION_CONTEXT) Context;
    }

    //
    // all we do is set the event and decrement the count
    //

    if(irpContext) {

        KeSetEvent(irpContext->Event, 0, FALSE);

        IsoUsb_DbgPrint(3, ("PoIrpCompletionFunc::"));
        IsoUsb_IoDecrement(irpContext->DeviceExtension);

        ExFreePool(irpContext);
    }

    return;
}

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

  Completion routine for PoRequest wait wake irp

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.    

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    IsoUsb_DbgPrint(3, ("PoIrpAsyncCompletionFunc::"));
    IsoUsb_IoDecrement(DeviceExtension);

    return;
}

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    IsoUsb_DbgPrint(3, ("WWIrpCompletionFunc::"));
    IsoUsb_IoDecrement(DeviceExtension);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\exe\rwiso.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    RwIso.c

Abstract:

    Console test app for IsoUsb.sys driver

Environment:

    user mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1997-1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        11/17/97: created

--*/

#include <windows.h>

#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>

#include "devioctl.h"

#include <setupapi.h>
#include <basetyps.h>

#include "IsoUsr.h"

#include "usbdi.h"

#define NOISY(_x_) printf _x_ ;

char inPipe[32] = "PIPE04";     // pipe name for iso input pipe on our test board
char outPipe[32] = "PIPE05";    // pipe name for iso output pipe on our test board
char completeDeviceName[256] = "";  //generated from the GUID registered by the driver itself

BOOL fDumpUsbConfig = FALSE;    // flags set in response to console command line switches
BOOL fDumpReadData = FALSE;
BOOL fRead = FALSE;
BOOL fWrite = FALSE;

PVOID gpStreamObj;
char gbuf[256];


BOOL fIsoStreamStarted = FALSE;
HANDLE ghStreamDev = NULL;
int gMS = 10000; // default to 10 secs stream test

int gDebugLevel = 1;      // higher == more verbose, default is 1, 0 turns off all

ULONG IterationCount = 1; // count of iterations of the test we are to perform
int WriteLen = 0;         // #bytes to write
int ReadLen = 0;          // #bytes to read

void StartIsoStream( void );

void StopIsoStream( void );

// functions


HANDLE
OpenOneDevice (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
        IN               char *devName
    )
/*++
Routine Description:

    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific usb device,
    open that device and fill in all the relevant information in the given
    USB_DEVICE_DESCRIPTOR structure.

Arguments:

    HardwareDeviceInfo:  handle to info obtained from Pnp mgr via SetupDiGetClassDevs()
    DeviceInfoData:      ptr to info obtained via SetupDiEnumDeviceInterfaces()

Return Value:

    return HANDLE if the open and initialization was successfull,
        else INVLAID_HANDLE_VALUE.

--*/
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA     functionClassDeviceData = NULL;
    ULONG                                predictedLength = 0;
    ULONG                                requiredLength = 0;
        HANDLE                                                           hOut = INVALID_HANDLE_VALUE;

    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //
    SetupDiGetDeviceInterfaceDetail (
            HardwareDeviceInfo,
            DeviceInfoData,
            NULL, // probing so no output buffer yet
            0, // probing so output buffer length of zero
            &requiredLength,
            NULL); // not interested in the specific dev-node


    predictedLength = requiredLength;
    // sizeof (SP_FNCLASS_DEVICE_DATA) + 512;

    functionClassDeviceData = malloc (predictedLength);
    if(NULL == functionClassDeviceData) {
        return INVALID_HANDLE_VALUE;
    }
    functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);

    //
    // Retrieve the information from Plug and Play.
    //
    if (! SetupDiGetDeviceInterfaceDetail (
               HardwareDeviceInfo,
               DeviceInfoData,
               functionClassDeviceData,
               predictedLength,
               &requiredLength,
               NULL)) {
                free( functionClassDeviceData );
        return INVALID_HANDLE_VALUE;
    }

        strcpy( devName,functionClassDeviceData->DevicePath) ;
        printf( "Attempting to open %s\n", devName );

    hOut = CreateFile (
                  functionClassDeviceData->DevicePath,
                  GENERIC_READ | GENERIC_WRITE,
                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                  NULL, // no SECURITY_ATTRIBUTES structure
                  OPEN_EXISTING, // No special create flags
                  0, // No special attributes
                  NULL); // No template file

    if (INVALID_HANDLE_VALUE == hOut) {
                printf( "FAILED to open %s\n", devName );
    }
        free( functionClassDeviceData );
        return hOut;
}


HANDLE
OpenUsbDevice( LPGUID  pGuid, char *outNameBuf)
/*++
Routine Description:

   Do the required PnP things in order to find
   the next available proper device in the system at this time.

Arguments:

    pGuid:      ptr to GUID registered by the driver itself
    outNameBuf: the generated name for this device

Return Value:

    return HANDLE if the open and initialization was successful,
        else INVLAID_HANDLE_VALUE.
--*/
{
   ULONG NumberDevices;
   HANDLE hOut = INVALID_HANDLE_VALUE;
   HDEVINFO                 hardwareDeviceInfo;
   SP_DEVICE_INTERFACE_DATA deviceInfoData;
   ULONG                    i;
   BOOLEAN                  done;
   PUSB_DEVICE_DESCRIPTOR   usbDeviceInst;
   PUSB_DEVICE_DESCRIPTOR   *UsbDevices = &usbDeviceInst;
   PUSB_DEVICE_DESCRIPTOR   tempDevDesc;

   *UsbDevices = NULL;
   tempDevDesc = NULL;
   NumberDevices = 0;

   //
   // Open a handle to the plug and play dev node.
   // SetupDiGetClassDevs() returns a device information set that contains info on all
   // installed devices of a specified class.
   //
   hardwareDeviceInfo = SetupDiGetClassDevs (
                           pGuid,
                           NULL, // Define no enumerator (global)
                           NULL, // Define no
                           (DIGCF_PRESENT | // Only Devices present
                            DIGCF_DEVICEINTERFACE)); // Function class devices.

   //
   // Take a wild guess at the number of devices we have;
   // Be prepared to realloc and retry if there are more than we guessed
   //
   NumberDevices = 4;
   done = FALSE;
   deviceInfoData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

   i=0;
   while (!done) {
      NumberDevices *= 2;

      if (*UsbDevices) {
            tempDevDesc = 
               realloc (*UsbDevices, (NumberDevices * sizeof (USB_DEVICE_DESCRIPTOR)));
            if(tempDevDesc) {
                *UsbDevices = tempDevDesc;
                tempDevDesc = NULL;
            }
            else {
                free(*UsbDevices);
                *UsbDevices = NULL;
            }
      } else {
         *UsbDevices = calloc (NumberDevices, sizeof (USB_DEVICE_DESCRIPTOR));
      }

      if (NULL == *UsbDevices) {

         // SetupDiDestroyDeviceInfoList destroys a device information set
         // and frees all associated memory.

         SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
         return INVALID_HANDLE_VALUE;
      }

      usbDeviceInst = *UsbDevices + i;

      for (; i < NumberDevices; i++) {

         // SetupDiEnumDeviceInterfaces() returns information about device interfaces
         // exposed by one or more devices. Each call returns information about one interface;
         // the routine can be called repeatedly to get information about several interfaces
         // exposed by one or more devices.

         if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                         0, // We don't care about specific PDOs
                                                                                 pGuid,
                                         i,
                                         &deviceInfoData)) {

            hOut = OpenOneDevice (hardwareDeviceInfo, &deviceInfoData, outNameBuf);
                        if ( hOut != INVALID_HANDLE_VALUE ) {
               done = TRUE;
               break;
                        }
         } else {
            if (ERROR_NO_MORE_ITEMS == GetLastError()) {
               done = TRUE;
               break;
            }
         }
      }
   }

   NumberDevices = i;

   // SetupDiDestroyDeviceInfoList() destroys a device information set
   // and frees all associated memory.

   SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
   free ( *UsbDevices );
   return hOut;
}




BOOL
GetUsbDeviceFileName( LPGUID  pGuid, char *outNameBuf)
/*++
Routine Description:

    Given a ptr to a driver-registered GUID, give us a string with the device name
    that can be used in a CreateFile() call.
    Actually briefly opens and closes the device and sets outBuf if successfull;
    returns FALSE if not

Arguments:

    pGuid:      ptr to GUID registered by the driver itself
    outNameBuf: the generated zero-terminated name for this device

Return Value:

    TRUE on success else FALSE

--*/
{
        HANDLE hDev = OpenUsbDevice( pGuid, outNameBuf );
        if ( hDev != INVALID_HANDLE_VALUE )
        {
                CloseHandle( hDev );
                return TRUE;
        }
        return FALSE;

}

HANDLE
open_dev()
/*++
Routine Description:

    Called by dumpUsbConfig() to open an instance of our device

Arguments:

    None

Return Value:

    Device handle on success else NULL

--*/
{

        HANDLE hDEV = OpenUsbDevice( (LPGUID)&GUID_CLASS_I82930_ISO, completeDeviceName);


        if (hDEV == INVALID_HANDLE_VALUE) {
                printf("Failed to open (%s) = %d", completeDeviceName, GetLastError());
        } else {
                printf("DeviceName = (%s)\n", completeDeviceName);
    }           

        return hDEV;
}


HANDLE
open_file( char *filename)
/*++
Routine Description:

    Called by main() to open an instance of our device after obtaining its name

Arguments:

    None

Return Value:

    Device handle on success else NULL

--*/
{

        int success = 1;
        HANDLE h;

        if ( !GetUsbDeviceFileName(
                (LPGUID) &GUID_CLASS_I82930_ISO,
                completeDeviceName) )
        {
                NOISY(("Failed to GetUsbDeviceFileName - err = %d\n", GetLastError()));
                return  INVALID_HANDLE_VALUE;
        }

    strcat (completeDeviceName,
                        "\\"
                        );                      

    if((strlen(completeDeviceName) + strlen(filename)) > 255) {
        NOISY(("Failed to open handle - possibly long filename\n"));
        return INVALID_HANDLE_VALUE;
    }

    strcat (completeDeviceName,
                        filename
                        );                                      

        printf("completeDeviceName = (%s)\n", completeDeviceName);

        h = CreateFile(completeDeviceName,
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_WRITE | FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);

        if (h == INVALID_HANDLE_VALUE) {
                NOISY(("Failed to open (%s) = %d", completeDeviceName, GetLastError()));
                success = 0;
        } else {
                        NOISY(("Opened successfully.\n"));
    }           

        return h;
}

void
usage()
/*++
Routine Description:

    Called by main() to dump usage info to the console when
    the app is called with no parms or with an invalid parm

Arguments:

    None

Return Value:

    None

--*/
{
    printf("Usage for Read/Write test:\n");
    printf("-r [n] where n is number of bytes to read\n");
    printf("-w [n] where n is number of bytes to write\n");
    printf("-c [n] where n is number of iterations (default = 1)\n");
    printf("-i [s] where s is the input pipe\n");
    printf("-o [s] where s is the output pipe\n");
    printf("-v verbose -- dumps read data\n");

    printf("\nUsage for USB and Endpoint info:\n");
    printf("-u to dump USB configuration and pipe info \n");
    printf("-g [s] Run Isochronous test stream for 's' seconds \n");

}


void
parse(
    int argc,
    char *argv[] )
/*++
Routine Description:

    Called by main() to parse command line parms

Arguments:

    argc and argv that was passed to main()

Return Value:

    Sets global flags as per user function request

--*/
{
    int i;

        if ( argc < 2 ) // give usage if invoked with no parms
                usage();

    for (i=0; i<argc; i++) {
        if (argv[i][0] == '-' ||
            argv[i][0] == '/') {
            switch(argv[i][1]) {
            case 'r':
            case 'R':
                ReadLen = atoi(&argv[i+1][0]);
                                fRead = TRUE;
                i++;
                break;
            case 'w':
            case 'W':
                WriteLen = atoi(&argv[i+1][0]);
                                fWrite = TRUE;
                i++;
                break;
            case 'c':
            case 'C':
                IterationCount = atoi(&argv[i+1][0]);
                i++;
                break;
            case 'i':
            case 'I':
                strcpy(inPipe, &argv[i+1][0]);
                i++;
                break;
            case 'u':
            case 'U':
                fDumpUsbConfig = TRUE;
                                i++;
                break;
            case 'v':
            case 'V':
                fDumpReadData = TRUE;
                                i++;
                break;
                         case 'o':
             case 'O':
                strcpy(outPipe, &argv[i+1][0]);
                i++;
                break;
                         case 'g':
             case 'G':
                 gMS = 1000 * atoi(&argv[i+1][0]);
                                 StartIsoStream();
                break;
                         case 'x':
             case 'X':
                                 StopIsoStream();
                break;
            default:
                usage();
            }
        }
    }
}

BOOL
compare_buffs(char *buff1, char *buff2, int length)
/*++
Routine Description:

    Called to verify read and write buffers match for loopback test

Arguments:

    buffers to compare and length

Return Value:

    TRUE if buffers match, else FALSE

--*/
{
    int ok = 1;

        if (memcmp(buff1, buff2, length )) {

                // Edi, and Esi point to the mismatching char and ecx indicates the
                // remaining length.
                ok = 0;
        }


    return ok;
}

#define NPERLN 8

void
dump(
   UCHAR *b,
   int len
)
/*++
Routine Description:

    Called to do formatted ascii dump to console of the io buffer

Arguments:

    buffer and length

Return Value:

    none

--*/
{
    ULONG i;
        ULONG longLen = (ULONG)len / sizeof( ULONG );
        PULONG pBuf = (PULONG) b;

        // dump an ordinal ULONG for each sizeof(ULONG)'th byte
    printf("\n****** BEGIN DUMP LEN decimal %d, 0x%x\n", len,len);
    for (i=0; i<longLen; i++) {
        printf("%04X ", *pBuf++);
        if (i % NPERLN == (NPERLN - 1)) {
            printf("\n");
        }
    }
    if (i % NPERLN != 0) {
        printf("\n");
    }
    printf("\n****** END DUMP LEN decimal %d, 0x%x\n", len,len);
}

// Begin, routines for USB configuration dump (Cmdline "rwiso -u" )


char
*usbDescriptorTypeString(UCHAR bDescriptorType )
/*++
Routine Description:

    Called to get ascii string of USB descriptor

Arguments:

        PUSB_ENDPOINT_DESCRIPTOR->bDescriptorType or
        PUSB_DEVICE_DESCRIPTOR->bDescriptorType or
        PUSB_INTERFACE_DESCRIPTOR->bDescriptorType or
        PUSB_STRING_DESCRIPTOR->bDescriptorType or
        PUSB_POWER_DESCRIPTOR->bDescriptorType or
        PUSB_CONFIGURATION_DESCRIPTOR->bDescriptorType

Return Value:

    ptr to string

--*/{

        switch(bDescriptorType) {

        case USB_DEVICE_DESCRIPTOR_TYPE:
                return "USB_DEVICE_DESCRIPTOR_TYPE";

        case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                return "USB_CONFIGURATION_DESCRIPTOR_TYPE";
                

        case USB_STRING_DESCRIPTOR_TYPE:
                return "USB_STRING_DESCRIPTOR_TYPE";
                

        case USB_INTERFACE_DESCRIPTOR_TYPE:
                return "USB_INTERFACE_DESCRIPTOR_TYPE";
                

        case USB_ENDPOINT_DESCRIPTOR_TYPE:
                return "USB_ENDPOINT_DESCRIPTOR_TYPE";
                

#ifdef USB_POWER_DESCRIPTOR_TYPE // this is the older definintion which is actually obsolete
    // workaround for temporary bug in 98ddk, older USB100.h file
        case USB_POWER_DESCRIPTOR_TYPE:
                return "USB_POWER_DESCRIPTOR_TYPE";
#endif
                
#ifdef USB_RESERVED_DESCRIPTOR_TYPE  // this is the current version of USB100.h as in NT5DDK

        case USB_RESERVED_DESCRIPTOR_TYPE:
                return "USB_RESERVED_DESCRIPTOR_TYPE";

        case USB_CONFIG_POWER_DESCRIPTOR_TYPE:
                return "USB_CONFIG_POWER_DESCRIPTOR_TYPE";

        case USB_INTERFACE_POWER_DESCRIPTOR_TYPE:
                return "USB_INTERFACE_POWER_DESCRIPTOR_TYPE";
#endif // for current nt5ddk version of USB100.h
                
        default:
                return "??? UNKNOWN!!"; 
        }
}


char
*usbEndPointTypeString(UCHAR bmAttributes)
/*++
Routine Description:

    Called to get ascii string of endpt descriptor type

Arguments:

        PUSB_ENDPOINT_DESCRIPTOR->bmAttributes

Return Value:

    ptr to string

--*/
{
        UINT typ = bmAttributes & USB_ENDPOINT_TYPE_MASK;


        switch( typ) {
        case USB_ENDPOINT_TYPE_INTERRUPT:
                return "USB_ENDPOINT_TYPE_INTERRUPT";

        case USB_ENDPOINT_TYPE_BULK:
                return "USB_ENDPOINT_TYPE_BULK";        

        case USB_ENDPOINT_TYPE_ISOCHRONOUS:
                return "USB_ENDPOINT_TYPE_ISOCHRONOUS"; 
                
        case USB_ENDPOINT_TYPE_CONTROL:
                return "USB_ENDPOINT_TYPE_CONTROL";     
                
        default:
                return "??? UNKNOWN!!"; 
        }
}


char
*usbConfigAttributesString(UCHAR bmAttributes)
/*++
Routine Description:

    Called to get ascii string of USB_CONFIGURATION_DESCRIPTOR attributes

Arguments:

        PUSB_CONFIGURATION_DESCRIPTOR->bmAttributes

Return Value:

    ptr to string

--*/
{
        UINT typ = bmAttributes & USB_CONFIG_POWERED_MASK;


        switch( typ) {

        case USB_CONFIG_BUS_POWERED:
                return "USB_CONFIG_BUS_POWERED";

        case USB_CONFIG_SELF_POWERED:
                return "USB_CONFIG_SELF_POWERED";
                
        case USB_CONFIG_REMOTE_WAKEUP:
                return "USB_CONFIG_REMOTE_WAKEUP";

                
        default:
                return "??? UNKNOWN!!"; 
        }
}


void
print_USB_CONFIGURATION_DESCRIPTOR(PUSB_CONFIGURATION_DESCRIPTOR cd)
/*++
Routine Description:

    Called to do formatted ascii dump to console of a USB config descriptor

Arguments:

    ptr to USB configuration descriptor

Return Value:

    none

--*/
{
    printf("\n===================\nUSB_CONFIGURATION_DESCRIPTOR\n");

    printf(
    "bLength = 0x%x, decimal %d\n", cd->bLength, cd->bLength
    );

    printf(
    "bDescriptorType = 0x%x ( %s )\n", cd->bDescriptorType, usbDescriptorTypeString( cd->bDescriptorType )
    );

    printf(
    "wTotalLength = 0x%x, decimal %d\n", cd->wTotalLength, cd->wTotalLength
    );

    printf(
    "bNumInterfaces = 0x%x, decimal %d\n", cd->bNumInterfaces, cd->bNumInterfaces
    );

    printf(
    "bConfigurationValue = 0x%x, decimal %d\n", cd->bConfigurationValue, cd->bConfigurationValue
    );

    printf(
    "iConfiguration = 0x%x, decimal %d\n", cd->iConfiguration, cd->iConfiguration
    );

    printf(
    "bmAttributes = 0x%x ( %s )\n", cd->bmAttributes, usbConfigAttributesString( cd->bmAttributes )
    );

    printf(
    "MaxPower = 0x%x, decimal %d\n", cd->MaxPower, cd->MaxPower
    );
}


void
print_USB_INTERFACE_DESCRIPTOR(PUSB_INTERFACE_DESCRIPTOR id, UINT ix)
/*++
Routine Description:

    Called to do formatted ascii dump to console of a USB interface descriptor

Arguments:

    ptr to USB interface descriptor

Return Value:

    none

--*/
{
    printf("\n-----------------------------\nUSB_INTERFACE_DESCRIPTOR #%d\n", ix);


    printf(
    "bLength = 0x%x\n", id->bLength
    );


    printf(
    "bDescriptorType = 0x%x ( %s )\n", id->bDescriptorType, usbDescriptorTypeString( id->bDescriptorType )
    );


    printf(
    "bInterfaceNumber = 0x%x\n", id->bInterfaceNumber
    );
    printf(
    "bAlternateSetting = 0x%x\n", id->bAlternateSetting
    );
    printf(
    "bNumEndpoints = 0x%x\n", id->bNumEndpoints
    );
    printf(
    "bInterfaceClass = 0x%x\n", id->bInterfaceClass
    );
    printf(
    "bInterfaceSubClass = 0x%x\n", id->bInterfaceSubClass
    );
    printf(
    "bInterfaceProtocol = 0x%x\n", id->bInterfaceProtocol
    );
    printf(
    "bInterface = 0x%x\n", id->iInterface
    );
}


void
print_USB_ENDPOINT_DESCRIPTOR(PUSB_ENDPOINT_DESCRIPTOR ed, int i)
/*++
Routine Description:

    Called to do formatted ascii dump to console of a USB endpoint descriptor

Arguments:

    ptr to USB endpoint descriptor,
        index of this endpt in interface desc

Return Value:

    none

--*/
{
    printf(
        "------------------------------\nUSB_ENDPOINT_DESCRIPTOR for Pipe%02d\n", i
        );

    printf(
    "bLength = 0x%x\n", ed->bLength
    );

    printf(
    "bDescriptorType = 0x%x ( %s )\n", ed->bDescriptorType, usbDescriptorTypeString( ed->bDescriptorType )
    );


        if ( USB_ENDPOINT_DIRECTION_IN( ed->bEndpointAddress ) ) {
                printf(
                "bEndpointAddress= 0x%x ( INPUT )\n", ed->bEndpointAddress
                );
        } else {
                printf(
                "bEndpointAddress= 0x%x ( OUTPUT )\n", ed->bEndpointAddress
                );
        }

    printf(
    "bmAttributes= 0x%x ( %s )\n", ed->bmAttributes, usbEndPointTypeString ( ed->bmAttributes )
    );


    printf(
    "wMaxPacketSize= 0x%x, decimal %d\n", ed->wMaxPacketSize, ed->wMaxPacketSize
    );
    printf(
    "bInterval = 0x%x, decimal %d\n", ed->bInterval, ed->bInterval
    );
}

void
rw_dev( HANDLE hDEV )
/*++
Routine Description:

    Called to do formatted ascii dump to console of  USB
    configuration, interface, and endpoint descriptors
    (Cmdline "rwiso -u" )

Arguments:

    handle to device

Return Value:

    none

--*/
{
        ULONG success;
        int siz, nBytes;
        char buf[256];
    PUSB_CONFIGURATION_DESCRIPTOR cd;
    PUSB_INTERFACE_DESCRIPTOR id;
    PUSB_ENDPOINT_DESCRIPTOR ed;

        siz = sizeof(buf);

        if (hDEV == INVALID_HANDLE_VALUE) {
                NOISY(("DEV not open"));
                return;
        }
        
        success = DeviceIoControl(hDEV,
                        IOCTL_ISOUSB_GET_CONFIG_DESCRIPTOR,
                        buf,
                        siz,
                        buf,
                        siz,
                        &nBytes,
                        NULL);

        NOISY(("request complete, success = %d nBytes = %d\n", success, nBytes));
        
        if (success) {
        ULONG i;
                UINT  j, n;
        char *pch;

        pch = buf;
                n = 0;

        cd = (PUSB_CONFIGURATION_DESCRIPTOR) pch;

        print_USB_CONFIGURATION_DESCRIPTOR( cd );

        pch += cd->bLength;

        do {

            id = (PUSB_INTERFACE_DESCRIPTOR) pch;

            print_USB_INTERFACE_DESCRIPTOR(id, n++);

            pch += id->bLength;
            for (j=0; j<id->bNumEndpoints; j++) {

                ed = (PUSB_ENDPOINT_DESCRIPTOR) pch;

                print_USB_ENDPOINT_DESCRIPTOR(ed,j);

                pch += ed->bLength;
            }
            i = (ULONG)(pch - buf);
        } while (i<cd->wTotalLength);

        }
        
        return;

}


int  dumpUsbConfig()
/*++
Routine Description:

    Called to do formatted ascii dump to console of  USB
    configuration, interface, and endpoint descriptors
    (Cmdline "rwiso -u" )

Arguments:

    none

Return Value:

    none

--*/
{

        HANDLE hDEV = open_dev();

        if ( hDEV )
        {
                rw_dev( hDEV );
                CloseHandle(hDEV);
        }

        return 0;
}
//  End, routines for USB configuration and pipe info dump  (Cmdline "rwiso -u" )

// Begin, routines for Iso Streaming



void
IsoStream( HANDLE hDEV, BOOL fStop )
/*++
Routine Description:

    Called to start or stop an iso stream
    (Cmdline "RwIso -g" )

Arguments:

    handle to device

Return Value:

    none

--*/
{
        ULONG success;
        int nBytes;
        DWORD ioctl;
        char i;

        if ( fStop )
        {
                ioctl = IOCTL_ISOUSB_STOP_ISO_STREAM;
                
                for ( i = 0; i < sizeof( gbuf ); i ++ )
                        gbuf[ i ] = 0; // init outbuf to 0's to make sure read was good

                success = DeviceIoControl(hDEV,
                                ioctl,
                                &gpStreamObj, //pointer to stream object initted when stream was started
                                sizeof( PVOID),
                                gbuf, // output buffer gets back from kernel mode
                                sizeof(gbuf),
                                &nBytes,
                                NULL);

                NOISY(("DeviceIoControl STOP_ISO_STREAM complete, success = %d\n", success));
        }
        else
        {
                ioctl = IOCTL_ISOUSB_START_ISO_STREAM;
                //input is our 256-byte buffer, binary char 0-255
                for ( i = 0; i < sizeof( gbuf ); i ++ )
                        gbuf[ i ] = i;

                success = DeviceIoControl(hDEV,
                                ioctl,
                                gbuf,
                                sizeof(gbuf),
                                &gpStreamObj, // will receive pointer to stream object
                                sizeof( PVOID),
                                &nBytes,
                                NULL);

                NOISY(("DeviceIoControl START_ISO_STREAM complete, success = %d\n", success));
        }



        if (hDEV == INVALID_HANDLE_VALUE) {
                NOISY(("DEV not open"));
                return;
        }
        

        

}

void StartIsoStream( void )
{
        if ( !ghStreamDev ) {

                ghStreamDev = open_dev();

                if ( ghStreamDev != INVALID_HANDLE_VALUE ) {
                        IsoStream(  ghStreamDev , FALSE );

                        Sleep( gMS );

                        StopIsoStream();
                }
        }
}

void StopIsoStream( void )
{
        if ( ghStreamDev ) {
                IsoStream(  ghStreamDev , TRUE );
                ghStreamDev = NULL;
        }
}

// End, routines for Iso Streaming

int _cdecl main(
    int argc,
        char *argv[])
/*++
Routine Description:

    Entry point to RwIso.exe
    Parses cmdline, performs user-requested tests

Arguments:

    argc, argv  standard console  'c' app arguments

Return Value:

    Zero

--*/

{
    char *pinBuf = NULL, *poutBuf = NULL;
    ULONG nBytesRead, nBytesWrite, nBytes;
        ULONG i, j;
    int ok;
    ULONG success;
    HANDLE hRead = INVALID_HANDLE_VALUE, hWrite = INVALID_HANDLE_VALUE;
        char buf[1024];
        clock_t start, finish;
        ULONG totalBytes = 0L;
        double seconds;
        ULONG fail = 0L;

    parse(argc, argv );

        // dump USB configuation and pipe info
        if( fDumpUsbConfig ) {
                dumpUsbConfig();
        }


        // doing a read, write, or both test
        if ((fRead) || (fWrite)) {

            if (fRead) {
            //
            // open the output file
            //
                        if ( fDumpReadData ) { // round size to sizeof ULONG for readable dumping
                                while( ReadLen % sizeof( ULONG ) )
                                                ReadLen++;
                        }

            hRead = open_file( inPipe);
        
                pinBuf = malloc(ReadLen);

            }

            if (fWrite) {

                        if ( fDumpReadData ) { // round size to sizeof ULONG for readable dumping
                                while( WriteLen % sizeof( ULONG ) )
                                                WriteLen++;
                        }

                hWrite = open_file( outPipe);
                poutBuf = malloc(WriteLen);
            }


        for (i=0; i<IterationCount; i++) {

            if (fWrite && poutBuf && hWrite != INVALID_HANDLE_VALUE) {

                                PULONG pOut = (PULONG) poutBuf;
                                ULONG  numLongs = WriteLen / sizeof( ULONG );
                //
                // put some data in the output buffer
                //

                for (j=0; j<numLongs; j++) {
                    *(pOut+j) = j;
                }

                //
                // send the write
                //

                    WriteFile(hWrite,
                              poutBuf,
                              WriteLen,
                              &nBytesWrite,
                              NULL);

                    printf("<%s> W (%04.4d) : request %06.6d bytes -- %06.6d bytes written\n",
                            outPipe, i, WriteLen, nBytesWrite);
                assert(nBytesWrite == WriteLen);
                }

                if (fRead && pinBuf) {

                    success = ReadFile(hRead,
                                  pinBuf,
                              ReadLen,
                                  &nBytesRead,
                                  NULL);

                    printf("<%s> R (%04.4d) : request %06.6d bytes -- %06.6d bytes read\n",
                        inPipe, i, ReadLen, nBytesRead);

                if (fWrite) {

                    //
                    // validate the input buffer against what
                    // we sent to the 82930 (loopback test)
                    //

                    ok = compare_buffs(pinBuf, poutBuf,  nBytesRead);

                                        if( fDumpReadData ) {
                                                printf("Dumping read buffer\n");
                                                dump( pinBuf, nBytesRead );     
                                                printf("Dumping write buffer\n");
                                                dump( poutBuf, nBytesRead );

                                        }

                    assert(ok);

                                        if(ok != 1)
                                                fail++;

                    assert(ReadLen == WriteLen);
                    assert(nBytesRead == ReadLen);
                    assert(nBytesWrite == WriteLen);
                }
                }
        
        }


        if (pinBuf) {
            free(pinBuf);
        }

        if (poutBuf) {
            free(poutBuf);
        }


                // close devices if needed
                if(hRead != INVALID_HANDLE_VALUE)
                        CloseHandle(hRead);
                if(hWrite != INVALID_HANDLE_VALUE)
                        CloseHandle(hWrite);

    }
        
        StopIsoStream(); // stop iso stream if we started one

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\i82930\sys\ocrw.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    OCRW.C

Abstract:

    This source file contains the dispatch routines which handle
    opening, closing, reading, and writing to the device, i.e.:

    IRP_MJ_CREATE
    IRP_MJ_CLOSE
    IRP_MJ_READ
    IRP_MJ_WRITE

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>

#include "i82930.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, I82930_Create)
#pragma alloc_text(PAGE, I82930_Close)
#pragma alloc_text(PAGE, I82930_ReadWrite)
#pragma alloc_text(PAGE, I82930_BuildAsyncUrb)
#pragma alloc_text(PAGE, I82930_BuildIsoUrb)
#pragma alloc_text(PAGE, I82930_GetCurrentFrame)
#pragma alloc_text(PAGE, I82930_ResetPipe)
#pragma alloc_text(PAGE, I82930_AbortPipe)
#endif

//******************************************************************************
//
// I82930_Create()
//
// Dispatch routine which handles IRP_MJ_CREATE
//
//******************************************************************************

NTSTATUS
I82930_Create (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PFILE_OBJECT        fileObject;
    UCHAR               pipeIndex;
    PI82930_PIPE        pipe;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_Create\n"));

    LOGENTRY('CREA', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CREATE);

    deviceExtension = DeviceObject->DeviceExtension;

    INCREMENT_OPEN_COUNT(deviceExtension);

    if (deviceExtension->AcceptingRequests)
    {
        irpStack = IoGetCurrentIrpStackLocation(Irp);

        fileObject = irpStack->FileObject;

        if (fileObject->FileName.Length != 0)
        {
            if ((fileObject->FileName.Length ==  3*sizeof(WCHAR)) &&
                (fileObject->FileName.Buffer[0] == '\\') &&
                (fileObject->FileName.Buffer[1] >= '0' ) &&
                (fileObject->FileName.Buffer[1] <= '9' ) &&
                (fileObject->FileName.Buffer[2] >= '0' ) &&
                (fileObject->FileName.Buffer[2] <= '9' ))
            {
                pipeIndex = ((fileObject->FileName.Buffer[1] - '0') * 10 +
                             (fileObject->FileName.Buffer[2] - '0'));

                if (pipeIndex < deviceExtension->InterfaceInfo->NumberOfPipes)
                {
                    pipe = &deviceExtension->PipeList[pipeIndex];

#if 0
                    if (pipe->Opened)
                    {
                        // Pipe already open
                        //
                        DBGPRINT(2, ("Pipe already open\n"));
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                    else
#endif
                    {
                        // Good to open the pipe
                        //
                        DBGPRINT(2, ("Opened pipe %2d %08X\n",
                                     pipeIndex, pipe));

                        pipe->Opened    = TRUE;

                        fileObject->FsContext = pipe;

                        ntStatus = STATUS_SUCCESS;
                    }
                }
                else
                {
                    // Pipe index too big
                    //
                    DBGPRINT(2, ("Pipe index too big\n"));
                    ntStatus = STATUS_NO_SUCH_DEVICE;
                }
            }
            else
            {
                // Pipe name bad format
                //
                DBGPRINT(2, ("Pipe name bad format\n"));
                ntStatus = STATUS_NO_SUCH_DEVICE;
            }
        }
        else
        {
            // Open entire device, not an individual pipe
            //
            DBGPRINT(2, ("Opened device\n"));
            fileObject->FsContext = NULL;
            ntStatus = STATUS_SUCCESS;
        }
    }
    else
    {
        ntStatus = STATUS_DELETE_PENDING;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_Create %08X\n", ntStatus));

    LOGENTRY('crea', ntStatus, 0, 0);

    if (ntStatus != STATUS_SUCCESS)
    {
        DECREMENT_OPEN_COUNT(deviceExtension);
    }

    return ntStatus;
}


//******************************************************************************
//
// I82930_Close()
//
// Dispatch routine which handles IRP_MJ_CLOSE
//
//******************************************************************************

NTSTATUS
I82930_Close (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PFILE_OBJECT        fileObject;
    PI82930_PIPE        pipe;

    DBGPRINT(2, ("enter: I82930_Close\n"));

    LOGENTRY('CLOS', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CLOSE);

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    fileObject = irpStack->FileObject;

    pipe = fileObject->FsContext;

    if (pipe != NULL)
    {
        DBGPRINT(2, ("Closed pipe %2d %08X\n",
                     pipe->PipeIndex, pipe));

        pipe->Opened = FALSE;
    }
    else
    {
        DBGPRINT(2, ("Closed device\n"));
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_Close\n"));

    LOGENTRY('clos', 0, 0, 0);

    DECREMENT_OPEN_COUNT(deviceExtension);

    return STATUS_SUCCESS;
}


//******************************************************************************
//
// I82930_ReadWrite()
//
// Dispatch routine which handles IRP_MJ_READ and IRP_MJ_WRITE
//
//******************************************************************************

NTSTATUS
I82930_ReadWrite (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PIO_STACK_LOCATION  nextStack;
    PFILE_OBJECT        fileObject;
    PI82930_PIPE        pipe;
    PURB                urb;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_ReadWrite\n"));

    LOGENTRY('RW  ', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_READWRITE);

    deviceExtension = DeviceObject->DeviceExtension;

    if (!deviceExtension->AcceptingRequests)
    {
        ntStatus = STATUS_DELETE_PENDING;
        goto I82930_ReadWrite_Reject;
    }

    irpStack  = IoGetCurrentIrpStackLocation(Irp);
    nextStack = IoGetNextIrpStackLocation(Irp);

    fileObject = irpStack->FileObject;

    pipe = fileObject->FsContext;

    // Only allow Reads and Writes on individual pipes, not the entire device
    //
    if (pipe == NULL)
    {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto I82930_ReadWrite_Reject;
    }

    // Only allow Reads on IN endpoints and Writes on OUT endpoints
    //
    if ((USB_ENDPOINT_DIRECTION_OUT(pipe->PipeInfo->EndpointAddress) &&
         irpStack->MajorFunction != IRP_MJ_WRITE) ||
        (USB_ENDPOINT_DIRECTION_IN(pipe->PipeInfo->EndpointAddress) &&
         irpStack->MajorFunction != IRP_MJ_READ))
    {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto I82930_ReadWrite_Reject;
    }

    // Don't allow a Read or Write on a zero bandwidth endpoint
    //
    if (pipe->PipeInfo->MaximumPacketSize == 0)
    {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto I82930_ReadWrite_Reject;
    }

    // Build either a URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER
    // or a URB_FUNCTION_ISOCH_TRANSFER based on the PipeType
    //
    switch (pipe->PipeInfo->PipeType)
    {
        case UsbdPipeTypeBulk:
        case UsbdPipeTypeInterrupt:
            urb = I82930_BuildAsyncUrb(DeviceObject,
                                       Irp,
                                       pipe);
            break;

        case UsbdPipeTypeIsochronous:
            urb = I82930_BuildIsoUrb(DeviceObject,
                                     Irp,
                                     pipe);
            break;

        default:
            ntStatus = STATUS_INVALID_PARAMETER;
            goto I82930_ReadWrite_Reject;
    }

    if (urb == NULL)
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto I82930_ReadWrite_Reject;
    }

    // Initialize the Irp stack parameters for the next lower driver
    // to submit the URB
    //
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = urb;

    // Set a completion routine which will update the Irp->IoStatus.Information
    // with the URB TransferBufferLength and then free the URB.
    //
    IoSetCompletionRoutine(Irp,
                           I82930_ReadWrite_Complete,
                           urb,
                           TRUE,
                           TRUE,
                           TRUE);

    // Submit the URB to the next lower driver
    //
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

    goto I82930_Read_Done;

I82930_ReadWrite_Reject:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

I82930_Read_Done:

    DBGPRINT(2, ("exit:  I82930_ReadWrite %08X\n", ntStatus));

    LOGENTRY('rw  ', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_ReadWrite_Complete()
//
//******************************************************************************

NTSTATUS
I82930_ReadWrite_Complete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PURB    urb;

    urb = (PURB)Context;

    LOGENTRY('RWC1', DeviceObject, Irp, urb);
    LOGENTRY('RWC2', urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
             urb->UrbHeader.Status, 0);

    DBGPRINT(3, ("ReadWrite_Complete: Length 0x%08X, Urb Status 0x%08X, Irp Status 0x%08X\n",
                 urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
                 urb->UrbHeader.Status,
                 Irp->IoStatus.Status));

    // Propagate the pending flag back up the Irp stack
    //
    if (Irp->PendingReturned)
    {
        IoMarkIrpPending(Irp);
    }

    Irp->IoStatus.Information =
        urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

    ExFreePool(urb);

    return STATUS_SUCCESS;
}


//******************************************************************************
//
// I82930_BuildAsyncUrb()
//
// Allocates and initializes a URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER
// request URB
//
//******************************************************************************

PURB
I82930_BuildAsyncUrb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PI82930_PIPE     Pipe
    )
{
    PIO_STACK_LOCATION  irpStack;
    LARGE_INTEGER       byteOffset;
    ULONG               transferLength;
    USHORT              urbSize;
    PURB                urb;

    DBGPRINT(2, ("enter: I82930_BuildAsyncUrb\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // We will use the ByteOffset to control the USBD_SHORT_TRANSFER_OK flag
    //
    byteOffset = irpStack->Parameters.Read.ByteOffset;

    // Get the transfer length from the MDL
    //
    if (Irp->MdlAddress)
    {
        transferLength = MmGetMdlByteCount(Irp->MdlAddress);
    }
    else
    {
        transferLength = 0;
    }

    urbSize = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

    urb = ExAllocatePool(NonPagedPool, urbSize);

    if (urb)
    {
        RtlZeroMemory(urb, urbSize);

        urb->UrbHeader.Length   = urbSize;
        urb->UrbHeader.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;

        urb->UrbBulkOrInterruptTransfer.PipeHandle =
            Pipe->PipeInfo->PipeHandle;

        if (!byteOffset.HighPart)
        {
            urb->UrbBulkOrInterruptTransfer.TransferFlags =
                USBD_SHORT_TRANSFER_OK;
        }

        urb->UrbBulkOrInterruptTransfer.TransferBufferLength =
            transferLength;

        urb->UrbBulkOrInterruptTransfer.TransferBuffer =
            NULL;

        urb->UrbBulkOrInterruptTransfer.TransferBufferMDL =
            Irp->MdlAddress;

        urb->UrbBulkOrInterruptTransfer.UrbLink =
            NULL;
    }

    DBGPRINT(2, ("exit:  I82930_BuildAsyncUrb %08X\n", urb));

    return urb;
}

//******************************************************************************
//
// I82930_BuildIsoUrb()
//
// Allocates and initializes a URB_FUNCTION_ISOCH_TRANSFER request URB
//
//******************************************************************************

PURB
I82930_BuildIsoUrb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PI82930_PIPE     Pipe
    )
{
    PIO_STACK_LOCATION  irpStack;
    LARGE_INTEGER       byteOffset;
    ULONG               transferLength;
    ULONG               packetSize;
    ULONG               numPackets;
    ULONG               packetIndex;
    ULONG               urbSize;
    PURB                urb;

    DBGPRINT(2, ("enter: I82930_BuildIsoUrb\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // We will use the ByteOffset for +/- offset to current frame
    //
    byteOffset = irpStack->Parameters.Read.ByteOffset;

    // Get the transfer length from the MDL
    //
    if (Irp->MdlAddress)
    {
        transferLength = MmGetMdlByteCount(Irp->MdlAddress);
    }
    else
    {
        transferLength = 0;
    }

    // Calculate the number of Iso packets based on the transfer length
    // and the endpoint MaxPacketSize
    //
    packetSize = Pipe->PipeInfo->MaximumPacketSize;

    numPackets = transferLength / packetSize;

    if (numPackets * packetSize < transferLength)
    {
        numPackets++;
    }

    urbSize = GET_ISO_URB_SIZE(numPackets);

    urb = ExAllocatePool(NonPagedPool, urbSize);

    if (urb)
    {
        RtlZeroMemory(urb, urbSize);

        urb->UrbHeader.Length   = (USHORT)urbSize;
        urb->UrbHeader.Function = URB_FUNCTION_ISOCH_TRANSFER;

        urb->UrbBulkOrInterruptTransfer.PipeHandle =
            Pipe->PipeInfo->PipeHandle;

        urb->UrbIsochronousTransfer.TransferFlags =
            0;

        urb->UrbIsochronousTransfer.TransferBufferLength =
            transferLength;

        urb->UrbIsochronousTransfer.TransferBuffer =
            NULL;

        urb->UrbIsochronousTransfer.TransferBufferMDL =
            Irp->MdlAddress;

        urb->UrbIsochronousTransfer.UrbLink =
            NULL;

        // Use the ByteOffset for +/- offset to current frame
        //
        if (byteOffset.HighPart)
        {
            urb->UrbIsochronousTransfer.StartFrame =
                I82930_GetCurrentFrame(DeviceObject, Irp) +
                byteOffset.LowPart;
        }
        else
        {
            urb->UrbIsochronousTransfer.StartFrame =
                0;

            urb->UrbIsochronousTransfer.TransferFlags |=
                USBD_START_ISO_TRANSFER_ASAP;
        }

        urb->UrbIsochronousTransfer.NumberOfPackets =
            numPackets;

        for (packetIndex = 0; packetIndex < numPackets; packetIndex++)
        {
            urb->UrbIsochronousTransfer.IsoPacket[packetIndex].Offset
                    = packetIndex * packetSize;
        }
    }

    DBGPRINT(2, ("exit:  I82930_BuildIsoUrb %08X\n", urb));

    return urb;
}

//******************************************************************************
//
// I82930_CompletionStop()
//
// Completion Routine which just stops further completion of the Irp
//
//******************************************************************************

NTSTATUS
I82930_CompletionStop (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    return STATUS_MORE_PROCESSING_REQUIRED;
}

//******************************************************************************
//
// I82930_GetCurrentFrame()
//
// Returns the current frame on the bus to which the device is attached.
//
// The next stack frame of the Irp is used, but the Irp is not completed.
//
//******************************************************************************

ULONG
I82930_GetCurrentFrame (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION           deviceExtension;
    PIO_STACK_LOCATION          nextStack;
    NTSTATUS                    ntStatus;
    struct _URB_GET_CURRENT_FRAME_NUMBER urb;

    deviceExtension = DeviceObject->DeviceExtension;

    // Initialize the URB
    //
    urb.Hdr.Function = URB_FUNCTION_GET_CURRENT_FRAME_NUMBER;
    urb.Hdr.Length   = sizeof(urb);
    urb.FrameNumber = (ULONG)-1;

    // Set the IRP parameters to pass the URB down the stack
    //
    nextStack = IoGetNextIrpStackLocation(Irp);

    nextStack->Parameters.Others.Argument1 = &urb;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    // Since this Irp is borrowed for URB_FUNCTION_GET_CURRENT_FRAME_NUMBER
    // before it is passed down later for the real URB request after this
    // routine returns, set a completion routine which stop further completion
    // of the Irp.
    //
    IoSetCompletionRoutine(
        Irp,
        I82930_CompletionStop,
        NULL,   // Context
        TRUE,   // InvokeOnSuccess
        TRUE,   // InvokeOnError
        TRUE    // InvokeOnCancel
        );

    // Now pass the Irp down the stack
    //
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

    ASSERT(ntStatus != STATUS_PENDING);

    // Don't need to wait for completion because JD guarantees that
    // URB_FUNCTION_GET_CURRENT_FRAME_NUMBER will never return STATUS_PENDING

    return urb.FrameNumber;
}

//******************************************************************************
//
// I82930_ResetPipe()
//
// This will reset the host pipe to Data0 and should also reset the device
// endpoint to Data0 for Bulk and Interrupt pipes by issuing a Clear_Feature
// Endpoint_Stall to the device endpoint.
//
// For Iso pipes this will set the virgin state of pipe so that ASAP
// transfers begin with the current bus frame instead of the next frame
// after the last transfer occurred.
//
// Iso endpoints do not use the data toggle (all Iso packets are Data0).
// However, it may be useful to issue a Clear_Feature Endpoint_Stall to a
// device Iso endpoint.
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_ResetPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PI82930_PIPE     Pipe,
    IN BOOLEAN          IsoClearStall
    )
{
    PURB        urb;
    NTSTATUS    ntStatus;

    DBGPRINT(2, ("enter: I82930_ResetPipe\n"));

    LOGENTRY('RESP', DeviceObject, Pipe, IsoClearStall);

    // Allocate URB for RESET_PIPE request
    //
    urb = ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_PIPE_REQUEST));

    if (urb != NULL)
    {
        // Initialize RESET_PIPE request URB
        //
        urb->UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        urb->UrbPipeRequest.PipeHandle = Pipe->PipeInfo->PipeHandle;

        // Submit RESET_PIPE request URB
        //
        ntStatus = I82930_SyncSendUsbRequest(DeviceObject, urb);

        // Done with URB for RESET_PIPE request, free it
        //
        ExFreePool(urb);
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    // Issue Clear_Feature Endpoint_Stall request for Iso pipe, if desired
    //
    if (NT_SUCCESS(ntStatus) &&
        IsoClearStall &&
        (Pipe->PipeInfo->PipeType == UsbdPipeTypeIsochronous))
    {
        // Allocate URB for CONTROL_FEATURE request
        //
        urb = ExAllocatePool(NonPagedPool,
                             sizeof(struct _URB_CONTROL_FEATURE_REQUEST));

        if (urb != NULL)
        {
            // Initialize CONTROL_FEATURE request URB
            //
            urb->UrbHeader.Length   = sizeof (struct _URB_CONTROL_FEATURE_REQUEST);
            urb->UrbHeader.Function = URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT;
            urb->UrbControlFeatureRequest.UrbLink = NULL;
            urb->UrbControlFeatureRequest.FeatureSelector = USB_FEATURE_ENDPOINT_STALL;
            urb->UrbControlFeatureRequest.Index = Pipe->PipeInfo->EndpointAddress;

            // Submit CONTROL_FEATURE request URB
            //
            ntStatus = I82930_SyncSendUsbRequest(DeviceObject, urb);

            // Done with URB for CONTROL_FEATURE request, free it
            //
            ExFreePool(urb);
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    DBGPRINT(2, ("exit:  I82930_ResetPipe %08X\n", ntStatus));

    LOGENTRY('resp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_AbortPipe()
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_AbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PI82930_PIPE     Pipe
    )
{
    PURB        urb;
    NTSTATUS    ntStatus;

    DBGPRINT(2, ("enter: I82930_AbortPipe\n"));

    LOGENTRY('ABRT', DeviceObject, Pipe, 0);

    // Allocate URB for ABORT_PIPE request
    //
    urb = ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_PIPE_REQUEST));

    if (urb != NULL)
    {
        // Initialize ABORT_PIPE request URB
        //
        urb->UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
        urb->UrbPipeRequest.PipeHandle = Pipe->PipeInfo->PipeHandle;

        // Submit ABORT_PIPE request URB
        //
        ntStatus = I82930_SyncSendUsbRequest(DeviceObject, urb);

        // Done with URB for ABORT_PIPE request, free it
        //
        ExFreePool(urb);
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  I82930_AbortPipe %08X\n", ntStatus));

    LOGENTRY('abrt', ntStatus, 0, 0);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isodev.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isodev.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_DEV_H
#define _ISOUSB_DEV_H

typedef struct _FILE_OBJECT_CONTENT {

    PVOID PipeInformation;
    PVOID StreamInformation;

}FILE_OBJECT_CONTENT, *PFILE_OBJECT_CONTENT;

NTSTATUS
IsoUsb_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
IsoUsb_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
IsoUsb_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

LONG
IsoUsb_ParseStringForPipeNumber(
    IN PUNICODE_STRING PipeName
    );

NTSTATUS
IsoUsb_ResetPipe(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInfo
    );

NTSTATUS
IsoUsb_ResetDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IsoUsb_GetPortStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG PortStatus
    );

NTSTATUS
IsoUsb_ResetParentPort(
    IN IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isopnp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isopnp.c

Abstract:

    Isoch USB device driver for Intel 82930 USB test board
    Plug and Play module

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isowmi.h"
#include "isousr.h"
#include "isorwr.h"
#include "isostrm.h"

NTSTATUS
IsoUsb_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    The plug and play dispatch routines.
    Most of these requests the driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    KEVENT             startDeviceEvent;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // since the device is removed, fail the Irp.
    //

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    IsoUsb_DbgPrint(3, ("///////////////////////////////////////////\n"));
    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPnP::"));
    IsoUsb_IoIncrement(deviceExtension);

    if(irpStack->MinorFunction == IRP_MN_START_DEVICE) {

        ASSERT(deviceExtension->IdleReqPend == 0);
    }
    else {

        if(deviceExtension->SSEnable) {
            
            CancelSelectSuspend(deviceExtension);
        }
    }

    IsoUsb_DbgPrint(2, (PnPMinorFunctionString(irpStack->MinorFunction)));

    switch(irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:

        ntStatus = HandleStartDevice(DeviceObject, Irp);

        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        //
        // if we cannot stop the device, we fail the query stop irp
        //
        ntStatus = CanStopDevice(DeviceObject, Irp);

        if(NT_SUCCESS(ntStatus)) {

            ntStatus = HandleQueryStopDevice(DeviceObject, Irp);

            return ntStatus;
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        ntStatus = HandleCancelStopDevice(DeviceObject, Irp);

        break;
     
    case IRP_MN_STOP_DEVICE:

        ntStatus = HandleStopDevice(DeviceObject, Irp);

        IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPnP::IRP_MN_STOP_DEVICE::"));
        IsoUsb_IoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        //
        // if we cannot remove the device, we fail the query remove irp
        //
        ntStatus = CanRemoveDevice(DeviceObject, Irp);

        if(NT_SUCCESS(ntStatus)) {
        
            ntStatus = HandleQueryRemoveDevice(DeviceObject, Irp);

            return ntStatus;
        }
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        ntStatus = HandleCancelRemoveDevice(DeviceObject, Irp);

        break;

    case IRP_MN_SURPRISE_REMOVAL:

        ntStatus = HandleSurpriseRemoval(DeviceObject, Irp);

        IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPnP::IRP_MN_SURPRISE_REMOVAL::"));
        IsoUsb_IoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_REMOVE_DEVICE:

        ntStatus = HandleRemoveDevice(DeviceObject, Irp);

        return ntStatus;

    case IRP_MN_QUERY_CAPABILITIES:

        ntStatus = HandleQueryCapabilities(DeviceObject, Irp);

        break;

    default:

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPnP::default::"));
        IsoUsb_IoDecrement(deviceExtension);

        return ntStatus;

    } // switch

//
// complete request 
//

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

//
// decrement count
//
    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPnP::"));
    IsoUsb_IoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP              Irp
    )
/*++
 
Routine Description:

    This is the dispatch routine for IRP_MN_START_DEVICE

Arguments:

    DeviceObject - pointer to a device object.

    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            startDeviceEvent;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER     dueTime;

    IsoUsb_DbgPrint(3, ("HandleStartDevice - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    deviceExtension->UsbConfigurationDescriptor = NULL;
    deviceExtension->UsbInterface = NULL;

    //
    // We cannot touch the device (send it any non pnp irps) until a
    // start device has been passed down to the lower drivers.
    // first pass the Irp down
    //

    KeInitializeEvent(&startDeviceEvent, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&startDeviceEvent, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&startDeviceEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(1, ("Lower drivers failed this Irp\n"));
        return ntStatus;
    }

    //
    // Read the device descriptor, configuration descriptor 
    // and select the interface descriptors
    //

    ntStatus = ReadandSelectDescriptors(DeviceObject);

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(1, ("ReadandSelectDescriptors failed\n"));
        return ntStatus;
    }

    //
    // enable the symbolic links for system components to open
    // handles to the device
    //

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         TRUE);

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(1, ("IoSetDeviceInterfaceState:enable:failed\n"));
        return ntStatus;
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Working);
    deviceExtension->QueueState = AllowRequests;

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // initialize wait wake outstanding flag to false.
    // and issue a wait wake.
    
    deviceExtension->FlagWWOutstanding = 0;
    deviceExtension->FlagWWCancel = 0;
    deviceExtension->WaitWakeIrp = NULL;

    if(deviceExtension->WaitWakeEnable) {

        IssueWaitWake(deviceExtension);
    }

    ProcessQueuedRequests(deviceExtension);

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        deviceExtension->SSEnable = deviceExtension->SSRegistryEnable;

        //
        // set timer for selective suspend requests.
        //

        if(deviceExtension->SSEnable) {

            dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

            KeSetTimerEx(&deviceExtension->Timer, 
                         dueTime,
                         IDLE_INTERVAL,                              // 5000 ms
                         &deviceExtension->DeferredProcCall);

            deviceExtension->FreeIdleIrpCount = 0;
        }
    }

    if((Win2kOrBetter == deviceExtension->WdmVersion) ||
       (WinXpOrBetter == deviceExtension->WdmVersion)) {

        deviceExtension->IsDeviceHighSpeed = 0;
        GetBusInterfaceVersion(DeviceObject);
    }

    IsoUsb_DbgPrint(3, ("HandleStartDevice - ends\n"));

    return ntStatus;
}


NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine configures the USB device.
    In this routines we get the device descriptor, 
    the configuration descriptor and select the
    configuration descriptor.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NTSTATUS - NT status value.

--*/
{
    PURB                   urb;
    ULONG                  siz;
    NTSTATUS               ntStatus;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor;
    
    //
    // initialize variables
    //

    urb = NULL;
    deviceDescriptor = NULL;

    //
    // 1. Read the device descriptor
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_DEVICE_DESCRIPTOR);
        deviceDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(deviceDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_DEVICE_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    deviceDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(NT_SUCCESS(ntStatus)) {

                ASSERT(deviceDescriptor->bNumConfigurations);
                ntStatus = ConfigureDevice(DeviceObject);    
            }
                            
            ExFreePool(urb);                
            ExFreePool(deviceDescriptor);
        }
        else {

            IsoUsb_DbgPrint(1, ("Failed to allocate memory for deviceDescriptor\n"));

            ExFreePool(urb);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        IsoUsb_DbgPrint(1, ("Failed to allocate memory for urb\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
ConfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This helper routine reads the configuration descriptor
    for the device in couple of steps.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NTSTATUS - NT status value

--*/
{
    PURB                          urb;
    ULONG                         siz;
    NTSTATUS                      ntStatus;
    PDEVICE_EXTENSION             deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;



    //
    // initialize the variables
    //

    urb = NULL;
    configurationDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Read the first configuration descriptor
    // This requires two steps:
    // 1. Read the fixed sized configuration desciptor (CD)
    // 2. Read the CD with all embedded interface and endpoint descriptors
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR);
        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    configurationDescriptor,
                    NULL, 
                    sizeof(USB_CONFIGURATION_DESCRIPTOR), 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                IsoUsb_DbgPrint(1, ("UsbBuildGetDescriptorRequest failed\n"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            IsoUsb_DbgPrint(1, ("Failed to allocate mem for config Descriptor\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }

        siz = configurationDescriptor->wTotalLength;

        ExFreePool(configurationDescriptor);

        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE,
                    0, 
                    0, 
                    configurationDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                IsoUsb_DbgPrint(1,("Failed to read configuration descriptor\n"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            IsoUsb_DbgPrint(1, ("Failed to alloc mem for config Descriptor\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }
    }
    else {

        IsoUsb_DbgPrint(1, ("Failed to allocate memory for urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto ConfigureDevice_Exit;
    }

    if(configurationDescriptor) {

        //
        // save a copy of configurationDescriptor in deviceExtension
        // remember to free it later.
        //
        deviceExtension->UsbConfigurationDescriptor = configurationDescriptor;

        if(configurationDescriptor->bmAttributes & REMOTE_WAKEUP_MASK)
        {
            //
            // this configuration supports remote wakeup
            //
            deviceExtension->WaitWakeEnable = 1;
        }
        else
        {
            deviceExtension->WaitWakeEnable = 0;
        }

        ntStatus = SelectInterfaces(DeviceObject, configurationDescriptor);
    }
    else {

        deviceExtension->UsbConfigurationDescriptor = NULL;
    }

ConfigureDevice_Exit:

    if(urb) {

        ExFreePool(urb);
    }

    return ntStatus;
}

NTSTATUS
SelectInterfaces(
    IN PDEVICE_OBJECT                DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/*++
 
Routine Description:

    This helper routine selects the configuration

Arguments:

    DeviceObject - pointer to device object
    ConfigurationDescriptor - pointer to the configuration
    descriptor for the device

Return Value:

    NT status value

--*/
{
    LONG                        numberOfInterfaces, 
                                interfaceNumber, 
                                interfaceindex;
    ULONG                       i;
    PURB                        urb;
    PUCHAR                      pInf;
    NTSTATUS                    ntStatus;
    PDEVICE_EXTENSION           deviceExtension;
    PUSB_INTERFACE_DESCRIPTOR   interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY  interfaceList, 
                                tmp;
    PUSBD_INTERFACE_INFORMATION Interface;

    //
    // initialize the variables
    //

    urb = NULL;
    Interface = NULL;
    interfaceDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;
    interfaceindex = interfaceNumber = 0;

    //
    // Parse the configuration descriptor for the interface;
    //

    tmp = interfaceList =
        ExAllocatePool(
               NonPagedPool, 
               sizeof(USBD_INTERFACE_LIST_ENTRY) * (numberOfInterfaces + 1));

    if(!tmp) {

        IsoUsb_DbgPrint(1, ("Failed to allocate mem for interfaceList\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    while(interfaceNumber < numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                            ConfigurationDescriptor, 
                                            ConfigurationDescriptor,
                                            interfaceindex,
                                            0, -1, -1, -1);

        if(interfaceDescriptor) {

            interfaceList->InterfaceDescriptor = interfaceDescriptor;
            interfaceList->Interface = NULL;
            interfaceList++;
            interfaceNumber++;
        }

        interfaceindex++;
    }

    interfaceList->InterfaceDescriptor = NULL;
    interfaceList->Interface = NULL;
    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, tmp);

    if(urb) {

        Interface = &urb->UrbSelectConfiguration.Interface;

        for(i=0; i<Interface->NumberOfPipes; i++) {

            //
            // perform pipe initialization here
            // set the transfer size and any pipe flags we use
            // USBD sets the rest of the Interface struct members
            //

            Interface->Pipes[i].MaximumTransferSize = 
                                USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;
        }

        ntStatus = CallUSBD(DeviceObject, urb);

        if(NT_SUCCESS(ntStatus)) {

            //
            // save a copy of interface information in the device extension.
            //
            deviceExtension->UsbInterface = ExAllocatePool(NonPagedPool,
                                                           Interface->Length);

            if(deviceExtension->UsbInterface) {
                
                RtlCopyMemory(deviceExtension->UsbInterface,
                              Interface,
                              Interface->Length);
            }
            else {

                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                IsoUsb_DbgPrint(1, ("memory alloc for UsbInterface failed\n"));
            }

            //
            // Dump the interface to the debugger
            //

            Interface = &urb->UrbSelectConfiguration.Interface;

            IsoUsb_DbgPrint(3, ("---------\n"));
            IsoUsb_DbgPrint(3, ("NumberOfPipes 0x%x\n", 
                                 Interface->NumberOfPipes));
            IsoUsb_DbgPrint(3, ("Length 0x%x\n", 
                                 Interface->Length));
            IsoUsb_DbgPrint(3, ("Alt Setting 0x%x\n", 
                                 Interface->AlternateSetting));
            IsoUsb_DbgPrint(3, ("Interface Number 0x%x\n", 
                                 Interface->InterfaceNumber));
            IsoUsb_DbgPrint(3, ("Class, subclass, protocol 0x%x 0x%x 0x%x\n",
                                 Interface->Class,
                                 Interface->SubClass,
                                 Interface->Protocol));

            for(i=0; i<Interface->NumberOfPipes; i++) {

                IsoUsb_DbgPrint(3, ("---------\n"));
                IsoUsb_DbgPrint(3, ("PipeType 0x%x\n", 
                                     Interface->Pipes[i].PipeType));
                IsoUsb_DbgPrint(3, ("EndpointAddress 0x%x\n", 
                                     Interface->Pipes[i].EndpointAddress));
                IsoUsb_DbgPrint(3, ("MaxPacketSize 0x%x\n", 
                                    Interface->Pipes[i].MaximumPacketSize));
                IsoUsb_DbgPrint(3, ("Interval 0x%x\n", 
                                     Interface->Pipes[i].Interval));
                IsoUsb_DbgPrint(3, ("Handle 0x%x\n", 
                                     Interface->Pipes[i].PipeHandle));
                IsoUsb_DbgPrint(3, ("MaximumTransferSize 0x%x\n", 
                                    Interface->Pipes[i].MaximumTransferSize));
            }

            IsoUsb_DbgPrint(3, ("---------\n"));
        }
        else {

            IsoUsb_DbgPrint(1, ("Failed to select an interface\n"));
        }
    }
    else {
        
        IsoUsb_DbgPrint(1, ("USBD_CreateConfigurationRequestEx failed\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(tmp) {

        ExFreePool(tmp);
    }

    if(urb) {

        ExFreePool(urb);
    }

    return ntStatus;
}


NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine is invoked when the device is removed or stopped.
    This routine de-configures the usb device.

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    PURB     urb;
    ULONG    siz;
    NTSTATUS ntStatus;
    
    //
    // initialize variables
    //

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);
    urb = ExAllocatePool(NonPagedPool, siz);

    if(urb) {

        UsbBuildSelectConfigurationRequest(urb, (USHORT)siz, NULL);

        ntStatus = CallUSBD(DeviceObject, urb);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(3, ("Failed to deconfigure device\n"));
        }

        ExFreePool(urb);
    }
    else {

        IsoUsb_DbgPrint(1, ("Failed to allocate urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    )
/*++
 
Routine Description:

    This routine synchronously submits an urb down the stack.

Arguments:

    DeviceObject - pointer to device object
    Urb - USB request block

Return Value:

    NT status value

--*/
{
    PIRP               irp;
    KEVENT             event;
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize the variables
    //

    irp = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB, 
                                        deviceExtension->TopOfStackDeviceObject,
                                        NULL, 
                                        0, 
                                        NULL, 
                                        0, 
                                        TRUE, 
                                        &event, 
                                        &ioStatus);

    if(!irp) {

        IsoUsb_DbgPrint(1, ("IoBuildDeviceIoControlRequest failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->Parameters.Others.Argument1 = Urb;

    IsoUsb_DbgPrint(3, ("CallUSBD::"));
    IsoUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = ioStatus.Status;
    }
    
    IsoUsb_DbgPrint(3, ("CallUSBD::"));
    IsoUsb_IoDecrement(deviceExtension);
    return ntStatus;
}

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services the Irps of minor type IRP_MN_QUERY_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleQueryStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can stop the device, we need to set the QueueState to 
    // HoldRequests so further requests will be queued.
    //

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
    
    SET_NEW_PNP_STATE(deviceExtension, PendingStop);
    deviceExtension->QueueState = HoldRequests;
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // wait for the existing ones to be finished.
    // first, decrement this operation
    //

    IsoUsb_DbgPrint(3, ("HandleQueryStopDevice::"));
    IsoUsb_IoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("HandleQueryStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_CANCEL_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT value

--*/
{
    KIRQL             oldIrql;    
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleCancelStopDevice - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Send this IRP down and wait for it to come back.
    // Set the QueueState flag to AllowRequests, 
    // and process all the previously queued up IRPs.
    //
    // First check to see whether you have received cancel-stop
    // without first receiving a query-stop. This could happen if someone
    // above us fails a query-stop and passes down the subsequent
    // cancel-stop.
    //

    if(PendingStop == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);
            deviceExtension->QueueState = AllowRequests;
            ASSERT(deviceExtension->DeviceState == Working);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }

    }
    else {

        // spurious Irp
        ntStatus = STATUS_SUCCESS;
    }

    IsoUsb_DbgPrint(3, ("HandleCancelStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        if(deviceExtension->SSEnable) {
            //
            // Cancel the timer so that the DPCs are no longer fired.
            // we do not need DPCs because the device is stopping.
            // The timers are re-initialized while handling the start
            // device irp.
            //
            KeCancelTimer(&deviceExtension->Timer);
            //
            // after the device is stopped, it can be surprise removed.
            // we set this to 0, so that we do not attempt to cancel
            // the timer while handling surprise remove or remove irps.
            // when we get the start device request, this flag will be
            // reinitialized.
            //
            deviceExtension->SSEnable = 0;

            //
            // make sure that if a DPC was fired before we called cancel timer,
            // then the DPC and work-time have run to their completion
            //
            KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            //
            // make sure that the selective suspend request has been completed.
            //
            KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
        }
    }
    
    //
    // after the stop Irp is sent to the lower driver object, 
    // the driver must not send any more Irps down that touch 
    // the device until another Start has occurred.
    //

    if(deviceExtension->WaitWakeEnable) {
        
        CancelWaitWake(deviceExtension);
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Stopped);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // This is the right place to actually give up all the resources used
    // This might include calls to IoDisconnectInterrupt, MmUnmapIoSpace, 
    // etc.
    //

    ReleaseMemory(DeviceObject);
    
    ntStatus = DeconfigureDevice(DeviceObject);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    
    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("HandleStopDevice - ends\n"));
    
    return ntStatus;
}

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_QUERY_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleQueryRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can allow removal of the device, we should set the QueueState
    // to HoldRequests so further requests will be queued. This is required
    // so that we can process queued up requests in cancel-remove just in 
    // case somebody else in the stack fails the query-remove. 
    // 

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = HoldRequests;
    SET_NEW_PNP_STATE(deviceExtension, PendingRemove);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    IsoUsb_DbgPrint(3, ("HandleQueryRemoveDevice::"));
    IsoUsb_IoDecrement(deviceExtension);

    //
    // wait for all the requests to be completed
    //

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive,
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("HandleQueryRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_CANCEL_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleCancelRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // We need to reset the QueueState flag to ProcessRequest, 
    // since the device resume its normal activities.
    //

    //
    // First check to see whether you have received cancel-remove
    // without first receiving a query-remove. This could happen if 
    // someone above us fails a query-remove and passes down the 
    // subsequent cancel-remove.
    //

    if(PendingRemove == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);
        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            deviceExtension->QueueState = AllowRequests;
            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
            //
            // process the queued requests that arrive between 
            // QUERY_REMOVE and CANCEL_REMOVE
            //
            
            ProcessQueuedRequests(deviceExtension);
            
        }
    }
    else {

        // 
        // spurious cancel-remove
        //
        ntStatus = STATUS_SUCCESS;
    }

    IsoUsb_DbgPrint(3, ("HandleCancelRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_SURPRISE_REMOVAL

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleSurpriseRemoval - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // 1. fail pending requests
    // 2. return device and memory resources
    // 3. disable interfaces
    //

    if(deviceExtension->WaitWakeEnable) {
        
        CancelWaitWake(deviceExtension);
    }

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        if(deviceExtension->SSEnable) {
            
            KeCancelTimer(&deviceExtension->Timer);

            deviceExtension->SSEnable = 0;
            //
            // make sure that if a DPC was fired before we called cancel timer,
            // then the DPC and work-time have run to their completion
            //
            KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            //
            // make sure that the selective suspend request has been completed.
            //
            KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
        }
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = FailRequests;
    SET_NEW_PNP_STATE(deviceExtension, SurpriseRemoved);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    ProcessQueuedRequests(deviceExtension);

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         FALSE);

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
    }

    RtlFreeUnicodeString(&deviceExtension->InterfaceName);

    IsoUsb_AbortPipes(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("HandleSurpriseRemoval - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    ULONG             requestCount;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // The Plug & Play system has dictated the removal of this device.  We
    // have no choice but to detach and delete the device object.
    // (If we wanted to express an interest in preventing this removal,
    // we should have failed the query remove IRP).
    //

    if(SurpriseRemoved != deviceExtension->DeviceState) {

        //
        // we are here after QUERY_REMOVE
        //

        KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

        deviceExtension->QueueState = FailRequests;
        
        KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

        if(deviceExtension->WaitWakeEnable) {
        
            CancelWaitWake(deviceExtension);
        }

        if(WinXpOrBetter == deviceExtension->WdmVersion) {

            if(deviceExtension->SSEnable) {
                //
                // Cancel the timer so that the DPCs are no longer fired.
                // we do not need DPCs because the device has been removed
                //
                KeCancelTimer(&deviceExtension->Timer);

                deviceExtension->SSEnable = 0;

                //
                // make sure that if a DPC was fired before we called cancel timer,
                // then the DPC and work-time have run to their completion
                //
                KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                      Executive, 
                                      KernelMode, 
                                      FALSE, 
                                      NULL);

                //
                // make sure that the selective suspend request has been completed.
                //
                KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                      Executive, 
                                      KernelMode, 
                                      FALSE, 
                                      NULL);
            }
        }

        ProcessQueuedRequests(deviceExtension);

        ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                             FALSE);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
        }

        RtlFreeUnicodeString(&deviceExtension->InterfaceName);

        IsoUsb_AbortPipes(DeviceObject);
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Removed);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
    
    IsoUsb_WmiDeRegistration(deviceExtension);

    //
    // need 2 decrements
    //

    IsoUsb_DbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = IsoUsb_IoDecrement(deviceExtension);

    ASSERT(requestCount > 0);

    IsoUsb_DbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = IsoUsb_IoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->RemoveEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    ReleaseMemory(DeviceObject);

    //
    // We need to send the remove down the stack before we detach,
    // but we don't need to wait for the completion of this operation
    // (and to register a completion routine).
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    //
    // Detach the FDO from the device stack
    //
    IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
    IoDeleteDevice(DeviceObject);

    IsoUsb_DbgPrint(3, ("HandleRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_QUERY_CAPABILITIES

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value  

--*/
{
    ULONG                i;
    KEVENT               event;
    NTSTATUS             ntStatus;
    PDEVICE_EXTENSION    deviceExtension;
    PDEVICE_CAPABILITIES pdc;
    PIO_STACK_LOCATION   irpStack;

    IsoUsb_DbgPrint(3, ("HandleQueryCapabilities - begins\n"));

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    pdc = irpStack->Parameters.DeviceCapabilities.Capabilities;

    //
    // We will provide here an example of an IRP that is processed
    // both on its way down and on its way up: there might be no need for
    // a function driver process this Irp (the bus driver will do that).
    // The driver will wait for the lower drivers (the bus driver among 
    // them) to process this IRP, then it processes it again.
    //

    if(pdc->Version < 1 || pdc->Size < sizeof(DEVICE_CAPABILITIES)) {
        
        IsoUsb_DbgPrint(1, ("HandleQueryCapabilities::request failed\n"));
        ntStatus = STATUS_UNSUCCESSFUL;
        return ntStatus;
    }

    //
    // Set some values in deviceCapabilities here...
    //
    //.............................................
    //
    //
    // Prepare to pass the IRP down
    //

    //
    // Add in the SurpriseRemovalOK bit before passing it down.
    //
    pdc->SurpriseRemovalOK = TRUE;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
        
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&event, 
                           TRUE, 
                           TRUE, 
                           TRUE);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
        ntStatus = Irp->IoStatus.Status;
    }

    //
    // initialize PowerDownLevel to disabled
    //

    deviceExtension->PowerDownLevel = PowerDeviceUnspecified;

    if(NT_SUCCESS(ntStatus)) {

        deviceExtension->DeviceCapabilities = *pdc;
       
        for(i = PowerSystemSleeping1; i <= PowerSystemSleeping3; i++) {

            if(deviceExtension->DeviceCapabilities.DeviceState[i] < 
                                                            PowerDeviceD3) {

                deviceExtension->PowerDownLevel = 
                    deviceExtension->DeviceCapabilities.DeviceState[i];
            }
        }

        //
        // since its safe to surprise-remove this device, we shall
        // set the SurpriseRemoveOK flag to supress any dialog to 
        // user.
        //

        pdc->SurpriseRemovalOK = 1;
    }

    if(deviceExtension->PowerDownLevel == PowerDeviceUnspecified ||
       deviceExtension->PowerDownLevel <= PowerDeviceD0) {
    
        deviceExtension->PowerDownLevel = PowerDeviceD2;
    }

    IsoUsb_DbgPrint(3, ("HandleQueryCapabilities - ends\n"));

    return ntStatus;
}


VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
 
Routine Description:

    DPC routine triggered by the timer to check the idle state
    of the device and submit an idle request for the device.

Arguments:

    DeferredContext - context for the dpc routine.
                      DeviceObject in our case.

Return Value:

    None

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PIO_WORKITEM      item;

    IsoUsb_DbgPrint(3, ("DpcRoutine - begins\n"));

    deviceObject = (PDEVICE_OBJECT)DeferredContext;
    deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

    //
    // Clear this event since a DPC has been fired!
    //
    KeClearEvent(&deviceExtension->NoDpcWorkItemPendingEvent);

    if(CanDeviceSuspend(deviceExtension)) {

        IsoUsb_DbgPrint(3, ("Device is Idle\n"));

        item = IoAllocateWorkItem(deviceObject);

        if(item) {

            IoQueueWorkItem(item, 
                            IdleRequestWorkerRoutine,
                            DelayedWorkQueue, 
                            item);

            ntStatus = STATUS_PENDING;

        }
        else {
        
            IsoUsb_DbgPrint(3, ("Cannot alloc memory for work item\n"));
            
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            //
            // signal the NoDpcWorkItemPendingEvent.
            //
            KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }
    else {
        
        IsoUsb_DbgPrint(3, ("Idle event not signaled\n"));

        //
        // signal the NoDpcWorkItemPendingEvent.
        //
        KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }

    IsoUsb_DbgPrint(3, ("DpcRoutine - ends\n"));
}    


VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the work item fired from the DPC.
    This workitem checks the idle state of the device
    and submits an idle request.

Arguments:

    DeviceObject - pointer to device object
    Context - context for the work item.

Return Value:

    None

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_WORKITEM           workItem;

    IsoUsb_DbgPrint(3, ("IdleRequestWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    workItem = (PIO_WORKITEM) Context;

    if(CanDeviceSuspend(deviceExtension)) {

        IsoUsb_DbgPrint(3, ("Device is idle\n"));

        ntStatus = SubmitIdleRequestIrp(deviceExtension);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(1, ("SubmitIdleRequestIrp failed\n"));
        }
    }
    else {

        IsoUsb_DbgPrint(3, ("Device is not idle\n"));
    }

    IoFreeWorkItem(workItem);

    //
    // signal the NoDpcWorkItemPendingEvent.
    //
    KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
               IO_NO_INCREMENT,
               FALSE);

    IsoUsb_DbgPrint(3, ("IdleRequestsWorkerRoutine - ends\n"));
}


VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    Remove and process the entries in the queue. If this routine is called
    when processing IRP_MN_CANCEL_STOP_DEVICE, IRP_MN_CANCEL_REMOVE_DEVICE
    or IRP_MN_START_DEVICE, the requests are passed to the next lower driver.
    If the routine is called when IRP_MN_REMOVE_DEVICE is received, the IRPs
    are complete with STATUS_DELETE_PENDING

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    None

--*/
{
    KIRQL       oldIrql;
    PIRP        nextIrp,
                cancelledIrp;
    PVOID       cancelRoutine;
    LIST_ENTRY  cancelledIrpList;
    PLIST_ENTRY listEntry;

    IsoUsb_DbgPrint(3, ("ProcessQueuedRequests - begins\n"));

    //
    // initialize variables
    //

    cancelRoutine = NULL;
    InitializeListHead(&cancelledIrpList);

    //
    // 1.  dequeue the entries in the queue
    // 2.  reset the cancel routine
    // 3.  process them
    // 3a. if the device is active, send them down
    // 3b. else complete with STATUS_DELETE_PENDING
    //

    while(1) {

        KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

        if(IsListEmpty(&DeviceExtension->NewRequestsQueue)) {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
            break;
        }
    
        //
        // Remove a request from the queue
        //

        listEntry = RemoveHeadList(&DeviceExtension->NewRequestsQueue);
        nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        //
        // set the cancel routine to NULL
        //

        cancelRoutine = IoSetCancelRoutine(nextIrp, NULL);

        //
        // check if its already cancelled
        //

        if(nextIrp->Cancel) {
            if(cancelRoutine) {

                //
                // the cancel routine for this IRP hasnt been called yet
                // so queue the IRP in the cancelledIrp list and complete
                // after releasing the lock
                //
                
                InsertTailList(&cancelledIrpList, listEntry);
            }
            else {

                //
                // the cancel routine has run
                // it must be waiting to hold the queue lock
                // so initialize the IRPs listEntry
                //

                InitializeListHead(listEntry);
            }

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
        }
        else {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

            if(FailRequests == DeviceExtension->QueueState) {

                nextIrp->IoStatus.Information = 0;
                nextIrp->IoStatus.Status = STATUS_DELETE_PENDING;
                IoCompleteRequest(nextIrp, IO_NO_INCREMENT);
            }
            else {

                PIO_STACK_LOCATION irpStack;

                IsoUsb_DbgPrint(3, ("ProcessQueuedRequests::"));
                IsoUsb_IoIncrement(DeviceExtension);

                IoSkipCurrentIrpStackLocation(nextIrp);
                IoCallDriver(DeviceExtension->TopOfStackDeviceObject, nextIrp);
               
                IsoUsb_DbgPrint(3, ("ProcessQueuedRequests::"));
                IsoUsb_IoDecrement(DeviceExtension);
            }
        }
    } // while loop

    //
    // walk through the cancelledIrp list and cancel them
    //

    while(!IsListEmpty(&cancelledIrpList)) {

        PLIST_ENTRY cancelEntry = RemoveHeadList(&cancelledIrpList);
        
        cancelledIrp = CONTAINING_RECORD(cancelEntry, IRP, Tail.Overlay.ListEntry);

        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        cancelledIrp->IoStatus.Information = 0;

        IoCompleteRequest(cancelledIrp, IO_NO_INCREMENT);
    }

    IsoUsb_DbgPrint(3, ("ProcessQueuedRequests - ends\n"));

    return;
}

VOID
GetBusInterfaceVersion(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine queries the bus interface version

Arguments:

    DeviceExtension

Return Value:

    VOID

--*/
{
    PIRP                       irp;
    KEVENT                     event;
    NTSTATUS                   ntStatus;
    PDEVICE_EXTENSION          deviceExtension;
    PIO_STACK_LOCATION         nextStack;
    USB_BUS_INTERFACE_USBDI_V1 busInterfaceVer1;

    //
    // initialize vars
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("GetBusInterfaceVersion - begins\n"));

    irp = IoAllocateIrp(deviceExtension->TopOfStackDeviceObject->StackSize,
                        FALSE);

    if(NULL == irp) {

        IsoUsb_DbgPrint(1, ("Failed to alloc irp in GetBusInterfaceVersion\n"));
        return;
    }

    //
    // All pnp Irp's need the status field initialized to
    // STATUS_NOT_SUPPORTED
    //
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           (PIO_COMPLETION_ROUTINE) IrpCompletionRoutine,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack);
    nextStack->MajorFunction = IRP_MJ_PNP;
    nextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    //
    // Allocate memory for an interface of type
    // USB_BUS_INTERFACE_USBDI_V0 and have the IRP point to it:
    //
    nextStack->Parameters.QueryInterface.Interface = 
                                (PINTERFACE) &busInterfaceVer1;

    //
    // Assign the InterfaceSpecificData member of the IRP to be NULL
    //
    nextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Set the interface type to the appropriate GUID
    //
    nextStack->Parameters.QueryInterface.InterfaceType = 
                                        &USB_BUS_INTERFACE_USBDI_GUID;

    //
    // Set the size and version of interface in the IRP
    // Currently, there is only one valid version of 
    // this interface available to clients.
    //
    nextStack->Parameters.QueryInterface.Size = 
                                    sizeof(USB_BUS_INTERFACE_USBDI_V1);

    nextStack->Parameters.QueryInterface.Version = USB_BUSIF_USBDI_VERSION_1;
    
    IsoUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(DeviceObject,
                            irp);

    if(STATUS_PENDING == ntStatus) {

        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = irp->IoStatus.Status;
    }

    if(NT_SUCCESS(ntStatus)) {

        deviceExtension->IsDeviceHighSpeed = 
                busInterfaceVer1.IsDeviceHighSpeed(
                                       busInterfaceVer1.BusContext);

        IsoUsb_DbgPrint(1, ("IsDeviceHighSpeed = %x\n", 
                            deviceExtension->IsDeviceHighSpeed));
    }

    IoFreeIrp(irp);

    IsoUsb_DbgPrint(3, ("GetBusInterfaceVersion::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("GetBusInterfaceVersion - ends\n"));
}

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This routine is a completion routine.
    In this routine we set an event.

    Since the completion routine returns 
    STATUS_MORE_PROCESSING_REQUIRED, the Irps,
    which set this routine as the completion routine,
    should be marked pending.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    Context - 

Return Value:

    NT status value

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
IsoUsb_GetRegistryDword(
    IN     PWCHAR RegPath,
    IN     PWCHAR ValueName,
    IN OUT PULONG Value
    )
/*++
 
Routine Description:

    This routine reads the specified reqistry value.

Arguments:

    RegPath - registry path
    ValueName - property to be fetched from the registry
    Value - corresponding value read from the registry.

Return Value:

    NT status value

--*/
{
    ULONG                    defaultData;
    WCHAR                    buffer[MAXIMUM_FILENAME_LENGTH];
    NTSTATUS                 ntStatus;
    UNICODE_STRING           regPath;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];

    IsoUsb_DbgPrint(3, ("IsoUsb_GetRegistryDword - begins\n"));

    regPath.Length = 0;
    regPath.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR);
    regPath.Buffer = buffer;

    RtlZeroMemory(regPath.Buffer, regPath.MaximumLength);
    RtlMoveMemory(regPath.Buffer,
                  RegPath,
                  wcslen(RegPath) * sizeof(WCHAR));

    RtlZeroMemory(paramTable, sizeof(paramTable));

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = ValueName;
    paramTable[0].EntryContext = Value;
    paramTable[0].DefaultType = REG_DWORD;
    paramTable[0].DefaultData = &defaultData;
    paramTable[0].DefaultLength = sizeof(ULONG);

    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE |
                                      RTL_REGISTRY_OPTIONAL,
                                      regPath.Buffer,
                                      paramTable,
                                      NULL,
                                      NULL);

    if(NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(3, ("success Value = %X\n", *Value));
        return STATUS_SUCCESS;
    }
    else {

        *Value = 0;
        return STATUS_UNSUCCESSFUL;
    }
}

NTSTATUS
IsoUsb_AbortPipes(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine sends an irp/urb pair with
    URB_FUNCTION_ABORT_PIPE request down the stack

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    PURB                        urb;
    ULONG                       i;
    NTSTATUS                    ntStatus;
    PDEVICE_EXTENSION           deviceExtension;
    PUSBD_PIPE_INFORMATION      pipeInformation;
    PUSBD_INTERFACE_INFORMATION interfaceInfo;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    interfaceInfo = deviceExtension->UsbInterface;
    
    IsoUsb_DbgPrint(3, ("IsoUsb_AbortPipes - begins\n"));
    
    if(interfaceInfo == NULL) {

        return STATUS_SUCCESS;
    }

    for(i = 0; i < interfaceInfo->NumberOfPipes; i++) {

        urb = ExAllocatePool(NonPagedPool,
                             sizeof(struct _URB_PIPE_REQUEST));

        if(urb) {

            urb->UrbHeader.Length = sizeof(struct _URB_PIPE_REQUEST);
            urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
            urb->UrbPipeRequest.PipeHandle = 
                            interfaceInfo->Pipes[i].PipeHandle;

            ntStatus = CallUSBD(DeviceObject, urb);

            ExFreePool(urb);
        }
        else {

            IsoUsb_DbgPrint(1, ("Failed to alloc memory for urb for input pipe\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            return ntStatus;
        }
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_AbortPipes - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
IsoUsb_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for IRP_MJ_CLEANUP

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager

Return Value:

    NT status value

--*/
{
    PDEVICE_EXTENSION     deviceExtension;
    KIRQL                 oldIrql;
    LIST_ENTRY            cleanupList;
    PLIST_ENTRY           thisEntry, 
                          nextEntry, 
                          listHead;
    PIRP                  pendingIrp;
    PIO_STACK_LOCATION    pendingIrpStack, 
                          irpStack;
    NTSTATUS              ntStatus;
    PFILE_OBJECT          fileObject;
    PFILE_OBJECT_CONTENT  fileObjectContent;
    PISOUSB_STREAM_OBJECT tempStreamObject;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchClean::"));
    IsoUsb_IoIncrement(deviceExtension);

    //
    // check if any stream objects need to be cleaned
    //

    if(fileObject && fileObject->FsContext) {

        fileObjectContent = (PFILE_OBJECT_CONTENT)
                            fileObject->FsContext;

        if(fileObjectContent->StreamInformation) {

            tempStreamObject = (PISOUSB_STREAM_OBJECT)
                               InterlockedExchangePointer(
                                    &fileObjectContent->StreamInformation,
                                    NULL);
        
            if(tempStreamObject && 
               (tempStreamObject->DeviceObject == DeviceObject)) {
        
                IsoUsb_DbgPrint(3, ("clean dispatch routine"
                                    " found a stream object match\n"));
                IsoUsb_StreamObjectCleanup(tempStreamObject, deviceExtension);
            }
        }
    }

    InitializeListHead(&cleanupList);

    //
    // acquire queue lock
    //
    KeAcquireSpinLock(&deviceExtension->QueueLock, &oldIrql);

    //
    // remove all Irp's that belong to input Irp's fileobject
    //

    listHead = &deviceExtension->NewRequestsQueue;

    for(thisEntry = listHead->Flink, nextEntry = thisEntry->Flink;
       thisEntry != listHead;
       thisEntry = nextEntry, nextEntry = thisEntry->Flink) {

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrpStack = IoGetCurrentIrpStackLocation(pendingIrp);

        if(irpStack->FileObject == pendingIrpStack->FileObject) {

            RemoveEntryList(thisEntry);

            //
            // set the cancel routine to NULL
            //
            if(NULL == IoSetCancelRoutine(pendingIrp, NULL)) {

                InitializeListHead(thisEntry);
            }
            else {

                InsertTailList(&cleanupList, thisEntry);
            }
        }
    }

    //
    // Release the spin lock
    //

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // walk thru the cleanup list and cancel all the Irps
    //

    while(!IsListEmpty(&cleanupList)) {

        //
        // complete the Irp
        //
        thisEntry = RemoveHeadList(&cleanupList);

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrp->IoStatus.Information = 0;
        pendingIrp->IoStatus.Status = STATUS_CANCELLED;

        IoCompleteRequest(pendingIrp, IO_NO_INCREMENT);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchClean::"));
    IsoUsb_IoDecrement(deviceExtension);

    return STATUS_SUCCESS;
}

BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the routine where we check if the device
    can selectively suspend. 

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    TRUE - if the device can suspend
    FALSE - otherwise.

--*/
{
    IsoUsb_DbgPrint(3, ("CanDeviceSuspend\n"));

    if((DeviceExtension->OpenHandleCount == 0) &&
        (DeviceExtension->OutStandingIO == 1)) {
        
        return TRUE;
    }
    else {

        return FALSE;
    }
}

LONG
IsoUsb_IoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine bumps up the I/O count.
    This routine is typically invoked when any of the
    dispatch routines handle new irps for the driver.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    new value

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedIncrement(&DeviceExtension->OutStandingIO);

    //
    // when OutStandingIO bumps from 1 to 2, clear the StopEvent
    //

    if(result == 2) {

        KeClearEvent(&DeviceExtension->StopEvent);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    IsoUsb_DbgPrint(3, ("IsoUsb_IoIncrement::%d\n", result));

    return result;
}

LONG
IsoUsb_IoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine decrements the outstanding I/O count
    This is typically invoked after the dispatch routine
    has finished processing the irp.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    new value

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedDecrement(&DeviceExtension->OutStandingIO);

    if(result == 1) {

        KeSetEvent(&DeviceExtension->StopEvent, IO_NO_INCREMENT, FALSE);
    }

    if(result == 0) {

        ASSERT(Removed == DeviceExtension->DeviceState);

        KeSetEvent(&DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    IsoUsb_DbgPrint(3, ("IsoUsb_IoDecrement::%d\n", result));

    return result;
}

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine determines whether the device can be safely stopped. In our 
    particular case, we'll assume we can always stop the device.
    A device might fail the request if it doesn't have a queue for the
    requests it might come or if it was notified that it is in the paging
    path. 
  
Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the current IRP.

Return Value:

    STATUS_SUCCESS if the device can be safely stopped, an appropriate 
    NT Status if not.

--*/
{
   //
   // We assume we can stop the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine determines whether the device can be safely removed. In our 
    particular case, we'll assume we can always remove the device.
    A device shouldn't be removed if, for example, it has open handles or
    removing the device could result in losing data (plus the reasons 
    mentioned at CanStopDevice). The PnP manager on Windows 2000 fails 
    on its own any attempt to remove, if there any open handles to the device. 
    However on Win9x, the driver must keep count of open handles and fail 
    query_remove if there are any open handles.

Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the current IRP.
    
Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate 
    NT Status if not.

--*/
{
   //
   // We assume we can remove the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
ReleaseMemory(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine returns all the memory allocations acquired during
    device startup. 
    
Arguments:

    DeviceObject - pointer to the device object.
        
    
Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate 
    NT Status if not.

--*/
{
    //
    // Disconnect from the interrupt and unmap any I/O ports
    //
    
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if(deviceExtension->UsbConfigurationDescriptor) {

        ExFreePool(deviceExtension->UsbConfigurationDescriptor);
        deviceExtension->UsbConfigurationDescriptor = NULL;
    }

    if(deviceExtension->UsbInterface) {
        
        ExFreePool(deviceExtension->UsbInterface);
        deviceExtension->UsbInterface = NULL;
    }

    return STATUS_SUCCESS;
}

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE\n";

        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE\n";

        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE\n";

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE\n";

        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE\n";

        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE\n";

        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE\n";

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS\n";

        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE\n";

        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES\n";

        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES\n";

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT\n";

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG\n";

        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG\n";

        case IRP_MN_EJECT:
            return "IRP_MN_EJECT\n";

        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK\n";

        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID\n";

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE\n";

        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION\n";

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION\n";

        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isopnp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isopnp.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_PNP_H
#define _ISOUSB_PNP_H

#define REMOTE_WAKEUP_MASK 0x20

NTSTATUS
IsoUsb_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ConfigureDevice(
	IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SelectInterfaces(
	IN PDEVICE_OBJECT                DeviceObject,
	IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
GetBusInterfaceVersion(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    );

VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IsoUsb_GetRegistryDword(
    IN     PWCHAR RegPath,
    IN     PWCHAR ValueName,
    IN OUT PULONG Value
    );

NTSTATUS
IsoUsb_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
IsoUsb_AbortPipes(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReleaseMemory(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG
IsoUsb_IoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

LONG
IsoUsb_IoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

PCHAR
PnPMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isopwr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isopwr.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_POWER_H
#define _ISOUSB_POWER_H

typedef struct _POWER_COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           SIrp;
} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;

typedef struct _WORKER_THREAD_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           Irp;
    PIO_WORKITEM   WorkItem;
} WORKER_THREAD_CONTEXT, *PWORKER_THREAD_CONTEXT;

NTSTATUS
IsoUsb_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    );

NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject, 
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP                  Irp
    );

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isorwr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isorwr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_RWR_H
#define _ISOUSB_RWR_H

typedef struct _SUB_CONTEXT {

    PIRP SubIrp;
    PURB SubUrb;
    PMDL SubMdl;

} SUB_CONTEXT, *PSUB_CONTEXT;

typedef struct _ISOUSB_RW_CONTEXT {

    PIRP              RWIrp;
    ULONG             Lock;
    ULONG             NumXfer;
    ULONG             NumIrps;
    ULONG             IrpsPending;
    KSPIN_LOCK        SpinLock;
    PDEVICE_EXTENSION DeviceExtension;
    PSUB_CONTEXT      SubContext;

} ISOUSB_RW_CONTEXT, * PISOUSB_RW_CONTEXT;

NTSTATUS
IsoUsb_SinglePairComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

VOID
IsoUsb_CancelReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

ULONG
IsoUsb_GetCurrentFrame(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
IsoUsb_StopCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
IsoUsb_DispatchReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
PerformFullSpeedIsochTransfer(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInformation,
    IN PIRP                   Irp,
    IN ULONG                  TotalLength
    );

NTSTATUS
PerformHighSpeedIsochTransfer(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInformation,
    IN PIRP                   Irp,
    IN ULONG                  TotalLength
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isopwr.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    isopwr.c

Abstract:

    The power management related processing.

    The Power Manager uses IRPs to direct drivers to change system
    and device power levels, to respond to system wake-up events,
    and to query drivers about their devices. All power IRPs have
    the major function code IRP_MJ_POWER.

    Most function and filter drivers perform some processing for
    each power IRP, then pass the IRP down to the next lower driver
    without completing it. Eventually the IRP reaches the bus driver,
    which physically changes the power state of the device and completes
    the IRP.

    When the IRP has been completed, the I/O Manager calls any
    IoCompletion routines set by drivers as the IRP traveled
    down the device stack. Whether a driver needs to set a completion
    routine depends upon the type of IRP and the driver's individual
    requirements.

    This code is not USB specific. It is essential for every WDM driver
    to handle power irps.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isowmi.h"
#include "isousr.h"
#include "isorwr.h"
#include "isostrm.h"

NTSTATUS
IsoUsb_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    The power dispatch routine.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code

--*/
{
    NTSTATUS           ntStatus;
    PIO_STACK_LOCATION irpStack;
    PUNICODE_STRING    tagString;
    PDEVICE_EXTENSION  deviceExtension;
	
    //
    // initialize the variables
    //
	
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // We don't queue power Irps, we'll only check if the
    // device was removed, otherwise we'll take appropriate
    // action and send it to the next lower driver. In general
    // drivers should not cause long delays while handling power
    // IRPs. If a driver cannot handle a power IRP in a brief time,
    // it should return STATUS_PENDING and queue all incoming
    // IRPs until the IRP completes.
    //

    if(Removed == deviceExtension->DeviceState) {

        //
        // Even if a driver fails the IRP, it must nevertheless call
        // PoStartNextPowerIrp to inform the Power Manager that it
        // is ready to handle another power IRP.
        //

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    if(NotStarted == deviceExtension->DeviceState) {

        //
        // if the device is not started yet, pass it down
        //

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        return PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPower::"));
    IsoUsb_IoIncrement(deviceExtension);
    
    switch(irpStack->MinorFunction) {
    
    case IRP_MN_SET_POWER:

        //
        // The Power Manager sends this IRP for one of the
        // following reasons:
        // 1) To notify drivers of a change to the system power state.
        // 2) To change the power state of a device for which
        //    the Power Manager is performing idle detection.
        // A driver sends IRP_MN_SET_POWER to change the power
        // state of its device if it's a power policy owner for the
        // device.
        //
        // Mark the Irp as pending and return STATUS_PENDING if we change the 
        // nature of the irp in the completion routine (asynchroniticity).
        // In such cases, do not return the status returned by the lower driver.
        // returning STATUS_MORE_PROCESSING_REQUIRED in the completion routine 
        // transforms the nature of the irp to asynchronous irp.
        //

        IoMarkIrpPending(Irp);

        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:

            HandleSystemSetPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;

        case DevicePowerState:

            HandleDeviceSetPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;
        }

        break;

    case IRP_MN_QUERY_POWER:

        //
        // The Power Manager sends a power IRP with the minor
        // IRP code IRP_MN_QUERY_POWER to determine whether it
        // can safely change to the specified system power state
        // (S1-S5) and to allow drivers to prepare for such a change.
        // If a driver can put its device in the requested state,
        // it sets status to STATUS_SUCCESS and passes the IRP down.
        //

        IoMarkIrpPending(Irp);
    
        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:
            
            HandleSystemQueryPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;

        case DevicePowerState:

            HandleDeviceQueryPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;
        }

        break;

    case IRP_MN_WAIT_WAKE:

        //
        // The minor power IRP code IRP_MN_WAIT_WAKE provides
        // for waking a device or waking the system. Drivers
        // of devices that can wake themselves or the system
        // send IRP_MN_WAIT_WAKE. The system sends IRP_MN_WAIT_WAKE
        // only to devices that always wake the system, such as
        // the power-on switch.
        //

        IoMarkIrpPending(Irp);

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                        Irp,
                        (PIO_COMPLETION_ROUTINE)WaitWakeCompletionRoutine,
                        deviceExtension, 
                        TRUE, 
                        TRUE, 
                        TRUE);

        PoStartNextPowerIrp(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(1, ("Lower drivers failed this Irp\n"));
        }

        ntStatus = STATUS_PENDING;

        //
        // push back the count HERE and NOT in completion routine
        // a pending Wait Wake Irp should not impede stopping the device
        //

        IsoUsb_DbgPrint(3, ("IRP_MN_WAIT_WAKE::"));
        IsoUsb_IoDecrement(deviceExtension);

        break;

    case IRP_MN_POWER_SEQUENCE:

        //
        // A driver sends this IRP as an optimization to determine
        // whether its device actually entered a specific power state.
        // This IRP is optional. Power Manager cannot send this IRP.
        //

    default:

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(1, ("Lower drivers failed this Irp\n"));
        }
        
        IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPower::"));
        IsoUsb_IoDecrement(deviceExtension);

        break;
    }

    return ntStatus;
}

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine handles the irp with minor function of type IRP_MN_QUERY_POWER
    for the system power states.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager.

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    IsoUsb_DbgPrint(3, ("HandleSystemQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    IsoUsb_DbgPrint(3, ("Query for system power state S%X\n"
                        "Current system power state S%X\n",
                        systemState - 1,
                        deviceExtension->SysPower - 1));

    //
    // if querying for a lower S-state, issue a wait-wake
    //

    if((systemState > deviceExtension->SysPower) &&
       (deviceExtension->WaitWakeEnable)) {

        IssueWaitWake(deviceExtension);
    }

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("HandleSystemQueryPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_SET_POWER
    for the system power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    IsoUsb_DbgPrint(3, ("HandleSystemSetPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    IsoUsb_DbgPrint(3, ("Set request for system power state S%X\n"
                        "Current system power state S%X\n",
                        systemState - 1,
                        deviceExtension->SysPower - 1));

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("HandleSystemSetPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_QUERY_POWER
    for the device power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE deviceState;

    IsoUsb_DbgPrint(3, ("HandleDeviceQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceState = irpStack->Parameters.Power.State.DeviceState;

    IsoUsb_DbgPrint(3, ("Query for device power state D%X\n"
                        "Current device power state D%X\n",
                        deviceState - 1,
                        deviceExtension->DevPower - 1));

    if(deviceState < deviceExtension->DevPower) {

        ntStatus = STATUS_SUCCESS;
    }
    else {

        ntStatus = HoldIoRequests(DeviceObject, Irp);

        if(STATUS_PENDING == ntStatus) {

            return ntStatus;
        }
    }

    //
    // on error complete the Irp.
    // on success pass it to the lower layers
    //

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    if(!NT_SUCCESS(ntStatus)) {

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    IsoUsb_DbgPrint(3, ("HandleDeviceQueryPower::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("HandleDeviceQueryPower - ends\n"));

    return ntStatus;
}


NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the completion routine for the system power irps of minor
    function types IRP_MN_QUERY_POWER and IRP_MN_SET_POWER.
    This completion routine sends the corresponding device power irp and
    returns STATUS_MORE_PROCESSING_REQUIRED. The system irp is passed as a
    context to the device power irp completion routine and is completed in
    the device power irp completion routine.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
 	PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);


    IsoUsb_DbgPrint(3, ("SysPoCompletionRoutine - begins\n"));

    //
    // lower drivers failed this Irp
    //

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        IsoUsb_DbgPrint(3, ("SysPoCompletionRoutine::"));
        IsoUsb_IoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    //
    // ..otherwise update the cached system power state (IRP_MN_SET_POWER)
    //

    if(irpStack->MinorFunction == IRP_MN_SET_POWER) {

        DeviceExtension->SysPower = irpStack->Parameters.Power.State.SystemState;
    }

    //
    // queue device irp and return STATUS_MORE_PROCESSING_REQUIRED
    //
	
    SendDeviceIrp(DeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("SysPoCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP SIrp
    )
/*++
 
Routine Description:

    This routine is invoked from the completion routine of the system power
    irp. This routine will PoRequest a device power irp. The system irp is 
    passed as a context to the the device power irp.

Arguments:

    DeviceObject - pointer to device object
    SIrp - system power irp.

Return Value:

    None

--*/
{
    NTSTATUS                  ntStatus;
    POWER_STATE               powState;
    PDEVICE_EXTENSION         deviceExtension;
    PIO_STACK_LOCATION        irpStack;
    SYSTEM_POWER_STATE        systemState;
    DEVICE_POWER_STATE        devState;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(SIrp);
    systemState = irpStack->Parameters.Power.State.SystemState;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("SendDeviceIrp - begins\n"));

    //
    // Read out the D-IRP out of the S->D mapping array captured in QueryCap's.
    // we can choose deeper sleep states than our mapping but never choose
    // lighter ones.
    //

    devState = deviceExtension->DeviceCapabilities.DeviceState[systemState];
    powState.DeviceState = devState;
    
    powerContext = (PPOWER_COMPLETION_CONTEXT) 
                   ExAllocatePool(NonPagedPool,
                                  sizeof(POWER_COMPLETION_CONTEXT));

    if(!powerContext) {

        IsoUsb_DbgPrint(1, ("Failed to alloc memory for powerContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        powerContext->DeviceObject = DeviceObject;
        powerContext->SIrp = SIrp;
   
        //
        // in win2k PoRequestPowerIrp can take fdo or pdo.
        //

        ntStatus = PoRequestPowerIrp(
                            deviceExtension->PhysicalDeviceObject, 
                            irpStack->MinorFunction,
                            powState,
                            (PREQUEST_POWER_COMPLETE)DevPoCompletionRoutine,
                            powerContext, 
                            NULL);
    }

    if(!NT_SUCCESS(ntStatus)) {

        if(powerContext) {

            ExFreePool(powerContext);
        }

        PoStartNextPowerIrp(SIrp);

        SIrp->IoStatus.Status = ntStatus;
        SIrp->IoStatus.Information = 0;
        
        IoCompleteRequest(SIrp, IO_NO_INCREMENT);

        IsoUsb_DbgPrint(3, ("SendDeviceIrp::"));
        IsoUsb_IoDecrement(deviceExtension);

    }

    IsoUsb_DbgPrint(3, ("SendDeviceIrp - ends\n"));
}


VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject, 
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    This is the PoRequest - completion routine for the device power irp.
    This routine is responsible for completing the system power irp, 
    received as a context.

Arguments:

    DeviceObject - pointer to device object
    MinorFunction - minor function of the irp.
    PowerState - power state of the irp.
    Context - context passed to the completion routine.
    IoStatus - status of the device power irp.

Return Value:

    None

--*/
{
    PIRP                      sIrp;
    PDEVICE_EXTENSION         deviceExtension;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    powerContext = (PPOWER_COMPLETION_CONTEXT) Context;
    sIrp = powerContext->SIrp;
    deviceExtension = powerContext->DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("DevPoCompletionRoutine - begins\n"));

    //
    // copy the D-Irp status into S-Irp
    //

    sIrp->IoStatus.Status = IoStatus->Status;

    //
    // complete the system Irp
    //
    
    PoStartNextPowerIrp(sIrp);

    sIrp->IoStatus.Information = 0;

    IoCompleteRequest(sIrp, IO_NO_INCREMENT);

    //
    // cleanup
    //
    
    IsoUsb_DbgPrint(3, ("DevPoCompletionRoutine::"));
    IsoUsb_IoDecrement(deviceExtension);

    ExFreePool(powerContext);

    IsoUsb_DbgPrint(3, ("DevPoCompletionRoutine - ends\n"));

}

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_SET_POWER
    for the device power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;    
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    IsoUsb_DbgPrint(3, ("HandleDeviceSetPower - begins\n"));
	
    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    oldDevState = deviceExtension->DevPower;
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;

    IsoUsb_DbgPrint(3, ("Set request for device power state D%X\n"
                        "Current device power state D%X\n",
                        newDevState - 1,
                        deviceExtension->DevPower - 1));

    if(newDevState < oldDevState) {

        //
        // adding power
        //
        IsoUsb_DbgPrint(3, ("Adding power to the device\n"));

        //
        // send the power IRP to the next driver in the stack
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE)FinishDevPoUpIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

	}
    else {

        IsoUsb_DbgPrint(3, ("Removing power or SetD0\n"));

        //
        // newDevState >= oldDevState 
        //
        // hold I/O if transition from D0 -> DX (X = 1, 2, 3)
        // if transition from D1 or D2 to deeper sleep states, 
        // I/O queue is already on hold.
        //

        if(PowerDeviceD0 == oldDevState && newDevState > oldDevState) {

            //
            // D0 -> DX transition
            //
            ntStatus = HoldIoRequests(DeviceObject, Irp);

            if(!NT_SUCCESS(ntStatus)) {

                PoStartNextPowerIrp(Irp);

                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);

                IsoUsb_DbgPrint(3, ("HandleDeviceSetPower::"));
                IsoUsb_IoDecrement(deviceExtension);

                return ntStatus;
            }
            else {

                goto HandleDeviceSetPower_Exit;
            }

        }
        else if(PowerDeviceD0 == oldDevState && PowerDeviceD0 == newDevState) {

            //
            // D0 -> D0
            // unblock the queue which may have been blocked processing
            // query irp
            //

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
              
            deviceExtension->QueueState = AllowRequests;

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }   

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(1, ("Lower drivers failed a power Irp\n"));
        }

    }

HandleDeviceSetPower_Exit:

    IsoUsb_DbgPrint(3, ("HandleDeviceSetPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    completion routine for the device power UP irp with minor function
    IRP_MN_SET_POWER.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
                        
    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;

    IsoUsb_DbgPrint(3, ("FinishDevPoUpIrp - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        IsoUsb_DbgPrint(3, ("FinishDevPoUpIrp::"));
        IsoUsb_IoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    SetDeviceFunctional(DeviceObject, Irp, DeviceExtension);

    IsoUsb_DbgPrint(3, ("FinishDevPoUpIrp - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine processes queue of pending irps.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;
    oldDevState = DeviceExtension->DevPower;

    IsoUsb_DbgPrint(3, ("SetDeviceFunctional - begins\n"));

    //
    // update the cached state
    //
    DeviceExtension->DevPower = newDevState;

    //
    // restore appropriate amount of state to our h/w
    // this driver does not implement partial context
    // save/restore.
    //

    PoSetPowerState(DeviceObject, DevicePowerState, newState);

    if(PowerDeviceD0 == newDevState) {

    //
    // empty existing queue of all pending irps.
    //

        KeAcquireSpinLock(&DeviceExtension->DevStateLock, &oldIrql);

        DeviceExtension->QueueState = AllowRequests;
        
        KeReleaseSpinLock(&DeviceExtension->DevStateLock, oldIrql);

        ProcessQueuedRequests(DeviceExtension);
    }

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("SetDeviceFunctional::"));
    IsoUsb_IoDecrement(DeviceExtension);

    IsoUsb_DbgPrint(3, ("SetDeviceFunctional - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine is the completion routine for device power DOWN irp.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;

    IsoUsb_DbgPrint(3, ("FinishDevPoDnIrp - begins\n"));

    if(NT_SUCCESS(ntStatus) && irpStack->MinorFunction == IRP_MN_SET_POWER) {

        //
        // update the cache;
        //

        IsoUsb_DbgPrint(3, ("updating cache..\n"));

        DeviceExtension->DevPower = newState.DeviceState;

        PoSetPowerState(DeviceObject, DevicePowerState, newState);
    }

    PoStartNextPowerIrp(Irp);

    IsoUsb_DbgPrint(3, ("FinishDevPoDnIrp::"));
    IsoUsb_IoDecrement(DeviceExtension);

    IsoUsb_DbgPrint(3, ("FinishDevPoDnIrp - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine is called on query or set power DOWN irp for the device.
    This routine queues a workitem.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    NTSTATUS               ntStatus;
    PIO_WORKITEM           item;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("HoldIoRequests - begins\n"));

    deviceExtension->QueueState = HoldRequests;

    context = ExAllocatePool(NonPagedPool, sizeof(WORKER_THREAD_CONTEXT));

    if(context) {

        item = IoAllocateWorkItem(DeviceObject);

        context->Irp = Irp;
        context->DeviceObject = DeviceObject;
        context->WorkItem = item;

        if(item) {

            IoMarkIrpPending(Irp);
            
            IoQueueWorkItem(item, HoldIoRequestsWorkerRoutine,
                            DelayedWorkQueue, context);
            
            ntStatus = STATUS_PENDING;
        }
        else {

            IsoUsb_DbgPrint(3, ("Failed to allocate memory for workitem\n"));
            ExFreePool(context);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        IsoUsb_DbgPrint(1, ("Failed to alloc memory for worker thread context\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    IsoUsb_DbgPrint(3, ("HoldIoRequests - ends\n"));

    return ntStatus;
}

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This routine waits for the I/O in progress to finish and then
    sends the device power irp (query/set) down the stack.

Arguments:

    DeviceObject - pointer to device object
    Context - context passed to the work-item.

Return Value:

    None

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    IsoUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    context = (PWORKER_THREAD_CONTEXT) Context;
    irp = (PIRP) context->Irp;


    //
    // wait for I/O in progress to finish.
    // the stop event is signalled when the counter drops to 1.
    // invoke IsoUsb_IoDecrement twice: once each for the S-Irp and D-Irp.
    //
    IsoUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    IsoUsb_IoDecrement(deviceExtension);
    IsoUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    IsoUsb_IoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, Executive,
                          KernelMode, FALSE, NULL);

    //
    // Increment twice to restore the count
    //
    IsoUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    IsoUsb_IoIncrement(deviceExtension);
    IsoUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    IsoUsb_IoIncrement(deviceExtension);

    // 
    // now send the Irp down
    //

    IoCopyCurrentIrpStackLocationToNext(irp);

    IoSetCompletionRoutine(irp, (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                           deviceExtension, TRUE, TRUE, TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(1, ("Lower driver fail a power Irp\n"));
    }

    IoFreeWorkItem(context->WorkItem);
    ExFreePool((PVOID)context);

    IsoUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine - ends\n"));

}

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    Queue the Irp in the device queue

Arguments:

    DeviceExtension - pointer to device extension
    Irp - I/O request packet.

Return Value:

    NT status value

--*/
{
    KIRQL    oldIrql;
    NTSTATUS ntStatus;

    //
    // initialize variables
    //
    ntStatus = STATUS_PENDING;

    IsoUsb_DbgPrint(3, ("QueueRequests - begins\n"));

    ASSERT(HoldRequests == DeviceExtension->QueueState);

    KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

    InsertTailList(&DeviceExtension->NewRequestsQueue, 
                   &Irp->Tail.Overlay.ListEntry);

    IoMarkIrpPending(Irp);

    //
    // Set the cancel routine
    //

    IoSetCancelRoutine(Irp, CancelQueued);

    KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

    IsoUsb_DbgPrint(3, ("QueueRequests - ends\n"));

    return ntStatus;
}

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine removes the irp from the queue and completes it with
    STATUS_CANCELLED

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    KIRQL             oldIrql;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    oldIrql = Irp->CancelIrql;

    IsoUsb_DbgPrint(3, ("CancelQueued - begins\n"));

    //
    // Release the cancel spin lock
    //

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // Acquire the queue lock
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->QueueLock);

    //
    // Remove the cancelled Irp from queue and release the lock
    //
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // complete with STATUS_CANCELLED
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("CancelQueued - ends\n"));

    return;
}

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine will PoRequest a WAIT WAKE irp for the device

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value.

--*/
{
    POWER_STATE poState;
    NTSTATUS    ntStatus;

    IsoUsb_DbgPrint(3, ("IssueWaitWake - begins\n"));

    if(InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 1)) {

        return STATUS_DEVICE_BUSY;
    }

    InterlockedExchange(&DeviceExtension->FlagWWCancel, 0);

    //
    // lowest state from which this Irp will wake the system
    //

    poState.SystemState = DeviceExtension->DeviceCapabilities.SystemWake;

    ntStatus = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_WAIT_WAKE,
                                 poState, 
                                 (PREQUEST_POWER_COMPLETE) WaitWakeCallback,
                                 DeviceExtension, 
                                 &DeviceExtension->WaitWakeIrp);

    if(!NT_SUCCESS(ntStatus)) {

        InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 0);
    }

    IsoUsb_DbgPrint(3, ("IssueWaitWake - ends\n"));

    return ntStatus;
}

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine cancels the Wait Wake request.

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    None.

--*/
{
    PIRP Irp;

    IsoUsb_DbgPrint(3, ("CancelWaitWake - begins\n"));

    Irp = (PIRP) InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, 
                                            NULL);

    if(Irp) {

        IoCancelIrp(Irp);

        if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

            PoStartNextPowerIrp(Irp);

            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }    
    }

    IsoUsb_DbgPrint(3, ("CancelWaitWake - ends\n"));
}

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the IoSet completion routine for the wait wake irp.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    IsoUsb_DbgPrint(3, ("WaitWakeCompletionRoutine - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    //
    // Nullify the WaitWakeIrp pointer-the Irp is released 
    // as part of the completion process. If it's already NULL, 
    // avoid race with the CancelWaitWake routine.
    //

    if(InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, NULL)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_SUCCESS;
    }

    //
    // CancelWaitWake has run. 
    // If FlagWWCancel != 0, complete the Irp.
    // If FlagWWCancel == 0, CancelWaitWake completes it.
    //
    if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_CANCELLED;
    }

    IsoUsb_DbgPrint(3, ("WaitWakeCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    This is the PoRequest completion routine for the wait wake irp.

Arguments:

    DeviceObject - pointer to device object
    MinorFunction - irp minor function
    PowerState - power state of the irp.
    Context - context passed to the completion routine.
    IoStatus - status block.

Return Value:

    None

--*/
{
    NTSTATUS               ntStatus;
    POWER_STATE            powerState;
    PDEVICE_EXTENSION      deviceExtension;

    IsoUsb_DbgPrint(3, ("WaitWakeCallback - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) Context;

    InterlockedExchange(&deviceExtension->FlagWWOutstanding, 0);

    if(!NT_SUCCESS(IoStatus->Status)) {

        return;
    }

    //
    // wake up the device
    //

    if(deviceExtension->DevPower == PowerDeviceD0) {

        IsoUsb_DbgPrint(3, ("device already powered up...\n"));

        return;
    }

    IsoUsb_DbgPrint(3, ("WaitWakeCallback::"));
    IsoUsb_IoIncrement(deviceExtension);

    powerState.DeviceState = PowerDeviceD0;

    ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_SET_POWER, 
                                 powerState, 
                                 (PREQUEST_POWER_COMPLETE) WWIrpCompletionFunc,
                                 deviceExtension, 
                                 NULL);

    if(deviceExtension->WaitWakeEnable) {
    
        IssueWaitWake(deviceExtension);
    }

    IsoUsb_DbgPrint(3, ("WaitWakeCallback - ends\n"));

    return;
}


PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER\n";

        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER\n";

        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE\n";

        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isorwr.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isorwr.c

Abstract:

    This file has dispatch routines for read and write.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isowmi.h"
#include "isousr.h"
#include "isorwr.h"
#include "isostrm.h"

NTSTATUS
IsoUsb_DispatchReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine does some validation and 
    invokes appropriate function to perform
    Isoch transfer

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    ULONG                  totalLength;
    ULONG                  packetSize;
    NTSTATUS               ntStatus;
    PFILE_OBJECT           fileObject;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_STACK_LOCATION     irpStack;
    PFILE_OBJECT_CONTENT   fileObjectContent;
    PUSBD_PIPE_INFORMATION pipeInformation;

    //
    // initialize vars
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    totalLength = 0;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchReadWrite - begins\n"));

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchReadWrite::"));
    IsoUsb_IoIncrement(deviceExtension);

    if(deviceExtension->DeviceState != Working) {

        IsoUsb_DbgPrint(1, ("Invalid device state\n"));

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto IsoUsb_DispatchReadWrite_Exit;
    }

    //
    // make sure that the selective suspend request has been completed.
    //
    if(deviceExtension->SSEnable) {

        //
        // It is true that the client driver cancelled the selective suspend
        // request in the dispatch routine for create Irps.
        // But there is no guarantee that it has indeed completed.
        // so wait on the NoIdleReqPendEvent and proceed only if this event
        // is signalled.
        //
        IsoUsb_DbgPrint(3, ("Waiting on the IdleReqPendEvent\n"));

        
        KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
    }

    //
    // obtain the pipe information for read 
    // and write from the fileobject.
    //
    if(fileObject && fileObject->FsContext) {

        fileObjectContent = (PFILE_OBJECT_CONTENT) fileObject->FsContext;

        pipeInformation = (PUSBD_PIPE_INFORMATION)
                          fileObjectContent->PipeInformation;
    }
    else {

        IsoUsb_DbgPrint(1, ("Invalid device state\n"));

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto IsoUsb_DispatchReadWrite_Exit;
    }

    if((pipeInformation == NULL) ||
       (UsbdPipeTypeIsochronous != pipeInformation->PipeType)) {

        IsoUsb_DbgPrint(1, ("Incorrect pipe\n"));

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto IsoUsb_DispatchReadWrite_Exit;
    }

    if(Irp->MdlAddress) {

        totalLength = MmGetMdlByteCount(Irp->MdlAddress);
    }

    if(totalLength == 0) {

        IsoUsb_DbgPrint(1, ("Transfer data length = 0\n"));

        ntStatus = STATUS_SUCCESS;
        goto IsoUsb_DispatchReadWrite_Exit;
    }

    //
    // each packet can hold this much info
    //
    packetSize = pipeInformation->MaximumPacketSize;

    if(packetSize == 0) {

        IsoUsb_DbgPrint(1, ("Invalid parameter\n"));

        ntStatus = STATUS_INVALID_PARAMETER;
        goto IsoUsb_DispatchReadWrite_Exit;
    }

    //
    // atleast packet worth of data to be transferred.
    //
    if(totalLength < packetSize) {

        IsoUsb_DbgPrint(1, ("Atleast packet worth of data..\n"));

        ntStatus = STATUS_INVALID_PARAMETER;
        goto IsoUsb_DispatchReadWrite_Exit;
    }

    // perform reset. if there are some active transfers queued up
    // for this endpoint then the reset pipe will fail.
    //
    IsoUsb_ResetPipe(DeviceObject, pipeInformation);

    if(deviceExtension->IsDeviceHighSpeed) {

        ntStatus = PerformHighSpeedIsochTransfer(DeviceObject,
                                                 pipeInformation,
                                                 Irp,
                                                 totalLength);

    }
    else {

        ntStatus = PerformFullSpeedIsochTransfer(DeviceObject,
                                                 pipeInformation,
                                                 Irp,
                                                 totalLength);

    }

    return ntStatus;

IsoUsb_DispatchReadWrite_Exit:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchReadWrite::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("-------------------------------\n"));

    return ntStatus;
}

NTSTATUS
PerformHighSpeedIsochTransfer(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInformation,
    IN PIRP                   Irp,
    IN ULONG                  TotalLength
    )
/*++
 
Routine Description:

    High Speed Isoch Transfer requires packets in multiples of 8.
    (Argument: 8 micro-frames per ms frame)
    Another restriction is that each Irp/Urb pair can be associated
    with a max of 1024 packets.

    Here is one of the ways of creating Irp/Urb pairs.
    Depending on the characteristics of real-world device,
    the algorithm may be different

    This algorithm will distribute data evenly among all the packets.

    Input:
    TotalLength - no. of bytes to be transferred.

    Other parameters:
    packetSize - max size of each packet for this pipe.

    Implementation Details:
    
    Step 1:
    ASSERT(TotalLength >= 8)

    Step 2: 
    Find the exact number of packets required to transfer all of this data

    numberOfPackets = (TotalLength + packetSize - 1) / packetSize

    Step 3: 
    Number of packets in multiples of 8.

    if(0 == (numberOfPackets % 8)) {
        
        actualPackets = numberOfPackets;
    }
    else {

        actualPackets = numberOfPackets + 
                        (8 - (numberOfPackets % 8));
    }
    
    Step 4:
    Determine the min. data in each packet.

    minDataInEachPacket = TotalLength / actualPackets;

    Step 5:
    After placing min data in each packet, 
    determine how much data is left to be distributed. 
    
    dataLeftToBeDistributed = TotalLength - 
                              (minDataInEachPacket * actualPackets);

    Step 6:
    Start placing the left over data in the packets 
    (above the min data already placed)

    numberOfPacketsFilledToBrim = dataLeftToBeDistributed / 
                                  (packetSize - minDataInEachPacket);

    Step 7:
    determine if there is any more data left.

    dataLeftToBeDistributed -= (numberOfPacketsFilledToBrim * 
                                (packetSize - minDataInEachPacket));

    Step 8:
    The "dataLeftToBeDistributed" is placed in the packet at index
    "numberOfPacketsFilledToBrim"

    Algorithm at play:

    TotalLength  = 8193
    packetSize   = 8
    Step 1

    Step 2
    numberOfPackets = (8193 + 8 - 1) / 8 = 1025
    
    Step 3
    actualPackets = 1025 + 7 = 1032

    Step 4
    minDataInEachPacket = 8193 / 1032 = 7 bytes

    Step 5
    dataLeftToBeDistributed = 8193 - (7 * 1032) = 969.

    Step 6
    numberOfPacketsFilledToBrim = 969 / (8 - 7) = 969.
  
    Step 7
    dataLeftToBeDistributed = 969 - (969 * 1) = 0.
    
    Step 8
    Done :)

    Another algorithm
    Completely fill up (as far as possible) the early packets.
    Place 1 byte each in the rest of them.
    Ensure that the total number of packets is multiple of 8.

    This routine then
    1. creates a ISOUSB_RW_CONTEXT for each
       read/write to be performed.
    2. creates SUB_CONTEXT for each irp/urb pair.
       (Each irp/urb pair can transfer a max of 1024 packets.)
    3. All the irp/urb pairs are initialized
    4. The subsidiary irps (of the irp/urb pair) are passed 
       down the stack at once.
    5. The main Read/Write irp is pending

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    ULONG              i;
    ULONG              j;
    ULONG              numIrps;
    ULONG              stageSize;
    ULONG              contextSize;
    ULONG              packetSize;
    ULONG              numberOfPackets;
    ULONG              actualPackets;
    ULONG              minDataInEachPacket;
    ULONG              dataLeftToBeDistributed;
    ULONG              numberOfPacketsFilledToBrim;
    CCHAR              stackSize;
    KIRQL              oldIrql;
    PUCHAR             virtualAddress;
    BOOLEAN            read;
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    PIO_STACK_LOCATION nextStack;
    PISOUSB_RW_CONTEXT rwContext;

    //
    // initialize vars
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    read = (irpStack->MajorFunction == IRP_MJ_READ) ? TRUE : FALSE;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if(TotalLength < 8) {

        ntStatus = STATUS_INVALID_PARAMETER;
        goto PerformHighSpeedIsochTransfer_Exit;
    }

    //
    // each packet can hold this much info
    //
    packetSize = PipeInformation->MaximumPacketSize;

    numberOfPackets = (TotalLength + packetSize - 1) / packetSize;

    if(0 == (numberOfPackets % 8)) {

        actualPackets = numberOfPackets;
    }
    else {

        //
        // we need multiple of 8 packets only.
        //
        actualPackets = numberOfPackets +
                        (8 - (numberOfPackets % 8));
    }

    minDataInEachPacket = TotalLength / actualPackets;

    if(minDataInEachPacket == packetSize) {

        numberOfPacketsFilledToBrim = actualPackets;
        dataLeftToBeDistributed     = 0;

        IsoUsb_DbgPrint(1, ("TotalLength = %d\n", TotalLength));
        IsoUsb_DbgPrint(1, ("PacketSize  = %d\n", packetSize));
        IsoUsb_DbgPrint(1, ("Each of %d packets has %d bytes\n", 
                            numberOfPacketsFilledToBrim,
                            packetSize));
    }
    else {

        dataLeftToBeDistributed = TotalLength - 
                              (minDataInEachPacket * actualPackets);

        numberOfPacketsFilledToBrim = dataLeftToBeDistributed /
                                  (packetSize - minDataInEachPacket);

        dataLeftToBeDistributed -= (numberOfPacketsFilledToBrim *
                                (packetSize - minDataInEachPacket));
    

        IsoUsb_DbgPrint(1, ("TotalLength = %d\n", TotalLength));
        IsoUsb_DbgPrint(1, ("PacketSize  = %d\n", packetSize));
        IsoUsb_DbgPrint(1, ("Each of %d packets has %d bytes\n", 
                            numberOfPacketsFilledToBrim,
                            packetSize));
        if(dataLeftToBeDistributed) {

            IsoUsb_DbgPrint(1, ("One packet has %d bytes\n",
                                minDataInEachPacket + dataLeftToBeDistributed));
            IsoUsb_DbgPrint(1, ("Each of %d packets has %d bytes\n",
                                actualPackets - (numberOfPacketsFilledToBrim + 1),
                                minDataInEachPacket));
        }
        else {
            IsoUsb_DbgPrint(1, ("Each of %d packets has %d bytes\n",
                                actualPackets - numberOfPacketsFilledToBrim,
                                minDataInEachPacket));
        }
    }

    //
    // determine how many stages of transfer needs to be done.
    // in other words, how many irp/urb pairs required. 
    // this irp/urb pair is also called the subsidiary irp/urb pair
    //
    numIrps = (actualPackets + 1023) / 1024;

    IsoUsb_DbgPrint(1, ("PeformHighSpeedIsochTransfer::numIrps = %d\n", numIrps));

    //
    // for every read/write transfer
    // we create an ISOUSB_RW_CONTEXT
    //
    // initialize the read/write context
    //
    
    contextSize = sizeof(ISOUSB_RW_CONTEXT);

    rwContext = (PISOUSB_RW_CONTEXT) ExAllocatePool(NonPagedPool,
                                                    contextSize);

    if(rwContext == NULL) {

        IsoUsb_DbgPrint(1, ("Failed to alloc mem for rwContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto PerformHighSpeedIsochTransfer_Exit;
    }

    RtlZeroMemory(rwContext, contextSize);

    //
    // allocate memory for every stage context - 
    // subcontext has state information for every irp/urb pair.
    //
    rwContext->SubContext = (PSUB_CONTEXT) 
                            ExAllocatePool(NonPagedPool, 
                                           numIrps * sizeof(SUB_CONTEXT));

    if(rwContext->SubContext == NULL) {

        IsoUsb_DbgPrint(1, ("Failed to alloc mem for SubContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        ExFreePool(rwContext);
        goto PerformHighSpeedIsochTransfer_Exit;
    }

    RtlZeroMemory(rwContext->SubContext, numIrps * sizeof(SUB_CONTEXT));

    rwContext->RWIrp = Irp;
    rwContext->Lock = 2;
    rwContext->NumIrps = numIrps;
    rwContext->IrpsPending = numIrps;
    rwContext->DeviceExtension = deviceExtension;
    KeInitializeSpinLock(&rwContext->SpinLock);
    //
    // save the rwContext pointer in the tail union.
    //
    Irp->Tail.Overlay.DriverContext[0] = (PVOID) rwContext;

    stackSize = deviceExtension->TopOfStackDeviceObject->StackSize + 1;
    virtualAddress = (PUCHAR) MmGetMdlVirtualAddress(Irp->MdlAddress);

    for(i = 0; i < numIrps; i++) {
    
        PIRP  subIrp;
        PURB  subUrb;
        PMDL  subMdl;
        ULONG nPackets;
        ULONG siz;
        ULONG offset;

        //
        // for every stage of transfer we need to do the following
        // tasks
        // 1. allocate an irp
        // 2. allocate an urb
        // 3. allocate a mdl.
        //
        // create a subsidiary irp
        //
        subIrp = IoAllocateIrp(stackSize, FALSE);

        if(subIrp == NULL) {

            IsoUsb_DbgPrint(1, ("failed to alloc mem for sub context irp\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto PerformHighSpeedIsochTransfer_Free;
        }

        rwContext->SubContext[i].SubIrp = subIrp;

        if(actualPackets <= 1024) {
            
            nPackets = actualPackets;
            actualPackets = 0;
        }
        else {

            nPackets = 1024;
            actualPackets -= 1024;
        }

        IsoUsb_DbgPrint(1, ("nPackets = %d for Irp/URB pair %d\n", nPackets, i));

        ASSERT(nPackets <= 1024);

        siz = GET_ISO_URB_SIZE(nPackets);

        //
        // create a subsidiary urb.
        //

        subUrb = (PURB) ExAllocatePool(NonPagedPool, siz);

        if(subUrb == NULL) {

            IsoUsb_DbgPrint(1, ("failed to alloc mem for sub context urb\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto PerformHighSpeedIsochTransfer_Free;
        }

        rwContext->SubContext[i].SubUrb = subUrb;

        if(nPackets > numberOfPacketsFilledToBrim) {
            
            stageSize =  packetSize * numberOfPacketsFilledToBrim;
            stageSize += (minDataInEachPacket * 
                          (nPackets - numberOfPacketsFilledToBrim));
            stageSize += dataLeftToBeDistributed;
        }
        else {

            stageSize = packetSize * nPackets;
        }

        //
        // allocate a mdl.
        //
        subMdl = IoAllocateMdl((PVOID) virtualAddress, 
                               stageSize,
                               FALSE,
                               FALSE,
                               NULL);

        if(subMdl == NULL) {

            IsoUsb_DbgPrint(1, ("failed to alloc mem for sub context mdl\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto PerformHighSpeedIsochTransfer_Free;
        }

        IoBuildPartialMdl(Irp->MdlAddress,
                          subMdl,
                          (PVOID) virtualAddress,
                          stageSize);

        rwContext->SubContext[i].SubMdl = subMdl;

        virtualAddress += stageSize;
        TotalLength -= stageSize;

        //
        // Initialize the subsidiary urb
        //
        RtlZeroMemory(subUrb, siz);

        subUrb->UrbIsochronousTransfer.Hdr.Length = (USHORT) siz;
        subUrb->UrbIsochronousTransfer.Hdr.Function = URB_FUNCTION_ISOCH_TRANSFER;
        subUrb->UrbIsochronousTransfer.PipeHandle = PipeInformation->PipeHandle;

        if(read) {

            IsoUsb_DbgPrint(1, ("read\n"));
            subUrb->UrbIsochronousTransfer.TransferFlags = 
                                                     USBD_TRANSFER_DIRECTION_IN;
        }
        else {

            IsoUsb_DbgPrint(1, ("write\n"));
            subUrb->UrbIsochronousTransfer.TransferFlags =
                                                     USBD_TRANSFER_DIRECTION_OUT;
        }

        subUrb->UrbIsochronousTransfer.TransferBufferLength = stageSize;
        subUrb->UrbIsochronousTransfer.TransferBufferMDL = subMdl;
/*
        This is a way to set the start frame and NOT specify ASAP flag.

        subUrb->UrbIsochronousTransfer.StartFrame = 
                        IsoUsb_GetCurrentFrame(DeviceObject, Irp) + 
                        SOME_LATENCY;
*/
        subUrb->UrbIsochronousTransfer.TransferFlags |=
                                        USBD_START_ISO_TRANSFER_ASAP;

        subUrb->UrbIsochronousTransfer.NumberOfPackets = nPackets;
        subUrb->UrbIsochronousTransfer.UrbLink = NULL;

        //
        // set the offsets for every packet for reads/writes
        //
        if(read) {
            
            offset = 0;

            for(j = 0; j < nPackets; j++) {
            
                subUrb->UrbIsochronousTransfer.IsoPacket[j].Offset = offset;
                subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = 0;

                if(numberOfPacketsFilledToBrim) {

                    offset += packetSize;
                    numberOfPacketsFilledToBrim--;
                    stageSize -= packetSize;
                }
                else if(dataLeftToBeDistributed) {

                    offset += (minDataInEachPacket + dataLeftToBeDistributed);
                    stageSize -= (minDataInEachPacket + dataLeftToBeDistributed);
                    dataLeftToBeDistributed = 0;                    
                }
                else {

                    offset += minDataInEachPacket;
                    stageSize -= minDataInEachPacket;
                }
            }

            ASSERT(stageSize == 0);
        }
        else {

            offset = 0;

            for(j = 0; j < nPackets; j++) {

                subUrb->UrbIsochronousTransfer.IsoPacket[j].Offset = offset;

                if(numberOfPacketsFilledToBrim) {

                    subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = packetSize;
                    offset += packetSize;
                    numberOfPacketsFilledToBrim--;
                    stageSize -= packetSize;
                }
                else if(dataLeftToBeDistributed) {
                    
                    subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = 
                                        minDataInEachPacket + dataLeftToBeDistributed;
                    offset += (minDataInEachPacket + dataLeftToBeDistributed);
                    stageSize -= (minDataInEachPacket + dataLeftToBeDistributed);
                    dataLeftToBeDistributed = 0;
                    
                }
                else {
                    subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = minDataInEachPacket;
                    offset += minDataInEachPacket;
                    stageSize -= minDataInEachPacket;
                }
            }

            ASSERT(stageSize == 0);
        }

        IoSetNextIrpStackLocation(subIrp);
        nextStack = IoGetCurrentIrpStackLocation(subIrp);

        nextStack->DeviceObject = DeviceObject;
        nextStack->Parameters.Others.Argument1 = (PVOID) subUrb;
        nextStack->Parameters.Others.Argument2 = (PVOID) subMdl;

        nextStack = IoGetNextIrpStackLocation(subIrp);
        nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        nextStack->Parameters.Others.Argument1 = (PVOID) subUrb;
        nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                             IOCTL_INTERNAL_USB_SUBMIT_URB;

        IoSetCompletionRoutine(subIrp,
                               (PIO_COMPLETION_ROUTINE) IsoUsb_SinglePairComplete,
                               (PVOID) rwContext,
                               TRUE,
                               TRUE,
                               TRUE);       
    }

    //
    // while we were busy create subsidiary irp/urb pairs..
    // the main read/write irp may have been cancelled !!
    //

    KeAcquireSpinLock(&rwContext->SpinLock, &oldIrql);

    IoSetCancelRoutine(Irp, IsoUsb_CancelReadWrite);

    if(Irp->Cancel) {

        //
        // The Cancel flag for the Irp has been set. 
        //
        IsoUsb_DbgPrint(3, ("Cancel flag set\n"));

        ntStatus = STATUS_CANCELLED;

        if(IoSetCancelRoutine(Irp, NULL)) {

            //
            // But the I/O manager did not call our cancel routine.
            // we need to free the 1) irp, 2) urb and 3) mdl for every 
            // stage and complete the main Irp after releasing the lock
            //

            IsoUsb_DbgPrint(3, ("cancellation routine NOT run\n"));

            KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

            goto PerformHighSpeedIsochTransfer_Free;
        }
        else {
            
            //
            // The cancel routine will resume the moment we release the lock.
            //
            for(j = 0; j < numIrps; j++) {

                if(rwContext->SubContext[j].SubUrb) {

                    ExFreePool(rwContext->SubContext[j].SubUrb);
                    rwContext->SubContext[j].SubUrb = NULL;
                }

                if(rwContext->SubContext[j].SubMdl) {

                    IoFreeMdl(rwContext->SubContext[j].SubMdl);
                    rwContext->SubContext[j].SubMdl = NULL;
                }
            }

            IoMarkIrpPending(Irp);

            //
            // it is the job of the cancellation routine to free
            // sub-context irps, release rwContext and complete 
            // the main readwrite irp
            //
            InterlockedDecrement(&rwContext->Lock);

            KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

            return STATUS_PENDING;
        }
    }
    else {

        //
        // normal processing
        //

        IsoUsb_DbgPrint(3, ("normal processing\n"));

        IoMarkIrpPending(Irp);

        KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

        for(j = 0; j < numIrps; j++) {

            IsoUsb_DbgPrint(3, ("PerformHighSpeedIsochTransfer::"));
            IsoUsb_IoIncrement(deviceExtension);
            
            IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                         rwContext->SubContext[j].SubIrp);
        }
        return STATUS_PENDING;
    }

PerformHighSpeedIsochTransfer_Free:

    for(j = 0; j < numIrps; j++) {

        if(rwContext->SubContext[j].SubIrp) {

            IoFreeIrp(rwContext->SubContext[j].SubIrp);
            rwContext->SubContext[j].SubIrp = NULL;
        }

        if(rwContext->SubContext[j].SubUrb) {

            ExFreePool(rwContext->SubContext[j].SubUrb);
            rwContext->SubContext[j].SubUrb = NULL;
        }

        if(rwContext->SubContext[j].SubMdl) {

            IoFreeMdl(rwContext->SubContext[j].SubMdl);
            rwContext->SubContext[j].SubMdl = NULL;
        }
    }

    ExFreePool(rwContext->SubContext);
    ExFreePool(rwContext);

PerformHighSpeedIsochTransfer_Exit:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("PerformHighSpeedIsochTransfer::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("-------------------------------\n"));

    return ntStatus;
}

NTSTATUS
PerformFullSpeedIsochTransfer(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInformation,
    IN PIRP                   Irp,
    IN ULONG                  TotalLength
    )
/*++
 
Routine Description:

    This routine 
    1. creates a ISOUSB_RW_CONTEXT for every
       read/write to be performed.
    2. creates SUB_CONTEXT for each irp/urb pair.
       (Each irp/urb pair can transfer only 255 packets.)
    3. All the irp/urb pairs are initialized
    4. The subsidiary irps (of the irp/urb pair) are passed 
       down the stack at once.
    5. The main Read/Write irp is pending

Arguments:

    DeviceObject - pointer to device object
    PipeInformation - USBD_PIPE_INFORMATION
    Irp - I/O request packet
    TotalLength - no. of bytes to be transferred

Return Value:

    NT status value

--*/
{
    ULONG              i;
    ULONG              j;
    ULONG              packetSize;
    ULONG              numIrps;
    ULONG              stageSize;
    ULONG              contextSize;
    CCHAR              stackSize;
    KIRQL              oldIrql;
    PUCHAR             virtualAddress;
    BOOLEAN            read;
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    PIO_STACK_LOCATION nextStack;
    PISOUSB_RW_CONTEXT rwContext;

    //
    // initialize vars
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    read = (irpStack->MajorFunction == IRP_MJ_READ) ? TRUE : FALSE;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("PerformFullSpeedIsochTransfer - begins\n"));
/*
    if(read) {

        pipeInformation = &deviceExtension->UsbInterface->Pipes[ISOCH_IN_PIPE_INDEX];
    }
    else {

        pipeInformation = &deviceExtension->UsbInterface->Pipes[ISOCH_OUT_PIPE_INDEX];
    }
*/

    //
    // each packet can hold this much info
    //
    packetSize = PipeInformation->MaximumPacketSize;

    IsoUsb_DbgPrint(3, ("totalLength = %d\n", TotalLength));
    IsoUsb_DbgPrint(3, ("packetSize = %d\n", packetSize));

    //
    // there is an inherent limit on the number of packets
    // that can be passed down the stack with each 
    // irp/urb pair (255)
    // if the number of required packets is > 255,
    // we shall create "required-packets / 255 + 1" number 
    // of irp/urb pairs. 
    // Each irp/urb pair transfer is also called a stage transfer.
    //
    if(TotalLength > (packetSize * 255)) {

        stageSize = packetSize * 255;
    }
    else {

        stageSize = TotalLength;
    }

    IsoUsb_DbgPrint(3, ("PerformFullSpeedIsochTransfer::stageSize = %d\n", stageSize));

    //
    // determine how many stages of transfer needs to be done.
    // in other words, how many irp/urb pairs required. 
    // this irp/urb pair is also called the subsidiary irp/urb pair
    //
    numIrps = (TotalLength + stageSize - 1) / stageSize;

    IsoUsb_DbgPrint(3, ("PerformFullSpeedIsochTransfer::numIrps = %d\n", numIrps));

    //
    // for every read/write transfer
    // we create an ISOUSB_RW_CONTEXT
    //
    // initialize the read/write context
    //
    
    contextSize = sizeof(ISOUSB_RW_CONTEXT);

    rwContext = (PISOUSB_RW_CONTEXT) ExAllocatePool(NonPagedPool,
                                                    contextSize);

    if(rwContext == NULL) {

        IsoUsb_DbgPrint(1, ("Failed to alloc mem for rwContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto PerformFullSpeedIsochTransfer_Exit;
    }

    RtlZeroMemory(rwContext, contextSize);

    //
    // allocate memory for every stage context - 
    // subcontext has state information for every irp/urb pair.
    //
    rwContext->SubContext = (PSUB_CONTEXT) 
                            ExAllocatePool(NonPagedPool, 
                                           numIrps * sizeof(SUB_CONTEXT));

    if(rwContext->SubContext == NULL) {

        IsoUsb_DbgPrint(1, ("Failed to alloc mem for SubContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        ExFreePool(rwContext);
        goto PerformFullSpeedIsochTransfer_Exit;
    }

    RtlZeroMemory(rwContext->SubContext, numIrps * sizeof(SUB_CONTEXT));

    rwContext->RWIrp = Irp;
    rwContext->Lock = 2;
    rwContext->NumIrps = numIrps;
    rwContext->IrpsPending = numIrps;
    rwContext->DeviceExtension = deviceExtension;
    KeInitializeSpinLock(&rwContext->SpinLock);
    //
    // save the rwContext pointer in the tail union.
    //
    Irp->Tail.Overlay.DriverContext[0] = (PVOID) rwContext;

    stackSize = deviceExtension->TopOfStackDeviceObject->StackSize + 1;
    virtualAddress = (PUCHAR) MmGetMdlVirtualAddress(Irp->MdlAddress);

    for(i = 0; i < numIrps; i++) {
    
        PIRP  subIrp;
        PURB  subUrb;
        PMDL  subMdl;
        ULONG nPackets;
        ULONG siz;
        ULONG offset;

        //
        // for every stage of transfer we need to do the following
        // tasks
        // 1. allocate an irp
        // 2. allocate an urb
        // 3. allocate a mdl.
        //
        // create a subsidiary irp
        //
        subIrp = IoAllocateIrp(stackSize, FALSE);

        if(subIrp == NULL) {

            IsoUsb_DbgPrint(1, ("failed to alloc mem for sub context irp\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto PerformFullSpeedIsochTransfer_Free;
        }

        rwContext->SubContext[i].SubIrp = subIrp;

        nPackets = (stageSize + packetSize - 1) / packetSize;

        IsoUsb_DbgPrint(3, ("nPackets = %d for Irp/URB pair %d\n", nPackets, i));

        ASSERT(nPackets <= 255);

        siz = GET_ISO_URB_SIZE(nPackets);

        //
        // create a subsidiary urb.
        //

        subUrb = (PURB) ExAllocatePool(NonPagedPool, siz);

        if(subUrb == NULL) {

            IsoUsb_DbgPrint(1, ("failed to alloc mem for sub context urb\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto PerformFullSpeedIsochTransfer_Free;
        }

        rwContext->SubContext[i].SubUrb = subUrb;

        //
        // allocate a mdl.
        //
        subMdl = IoAllocateMdl((PVOID) virtualAddress, 
                            stageSize,
                            FALSE,
                            FALSE,
                            NULL);

        if(subMdl == NULL) {

            IsoUsb_DbgPrint(1, ("failed to alloc mem for sub context mdl\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto PerformFullSpeedIsochTransfer_Free;
        }

        IoBuildPartialMdl(Irp->MdlAddress,
                          subMdl,
                          (PVOID) virtualAddress,
                          stageSize);

        rwContext->SubContext[i].SubMdl = subMdl;

        virtualAddress += stageSize;
        TotalLength -= stageSize;

        //
        // Initialize the subsidiary urb
        //
        RtlZeroMemory(subUrb, siz);

        subUrb->UrbIsochronousTransfer.Hdr.Length = (USHORT) siz;
        subUrb->UrbIsochronousTransfer.Hdr.Function = URB_FUNCTION_ISOCH_TRANSFER;
        subUrb->UrbIsochronousTransfer.PipeHandle = PipeInformation->PipeHandle;
        if(read) {

            IsoUsb_DbgPrint(3, ("read\n"));
            subUrb->UrbIsochronousTransfer.TransferFlags = 
                                                     USBD_TRANSFER_DIRECTION_IN;
        }
        else {

            IsoUsb_DbgPrint(3, ("write\n"));
            subUrb->UrbIsochronousTransfer.TransferFlags =
                                                     USBD_TRANSFER_DIRECTION_OUT;
        }

        subUrb->UrbIsochronousTransfer.TransferBufferLength = stageSize;
        subUrb->UrbIsochronousTransfer.TransferBufferMDL = subMdl;

/*
        This is a way to set the start frame and NOT specify ASAP flag.

        subUrb->UrbIsochronousTransfer.StartFrame = 
                        IsoUsb_GetCurrentFrame(DeviceObject, Irp) + 
                        SOME_LATENCY;
*/
        // 
        // when the client driver sets the ASAP flag, it basically
        // guarantees that it will make data available to the HC
        // and that the HC should transfer it in the next transfer frame 
        // for the endpoint.(The HC maintains a next transfer frame
        // state variable for each endpoint). By resetting the pipe,
        // we make the pipe as virgin. If the data does not get to the HC
        // fast enough, the USBD_ISO_PACKET_DESCRIPTOR - Status is 
        // USBD_STATUS_BAD_START_FRAME on uhci. On ohci it is 0xC000000E.
        //

        subUrb->UrbIsochronousTransfer.TransferFlags |=
                                    USBD_START_ISO_TRANSFER_ASAP;

        subUrb->UrbIsochronousTransfer.NumberOfPackets = nPackets;
        subUrb->UrbIsochronousTransfer.UrbLink = NULL;

        //
        // set the offsets for every packet for reads/writes
        //
        if(read) {
            
            offset = 0;

            for(j = 0; j < nPackets; j++) {
            
                subUrb->UrbIsochronousTransfer.IsoPacket[j].Offset = offset;
                subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = 0;

                if(stageSize > packetSize) {

                    offset += packetSize;
                    stageSize -= packetSize;
                }
                else {

                    offset += stageSize;
                    stageSize = 0;
                }
            }
        }
        else {

            offset = 0;

            for(j = 0; j < nPackets; j++) {

                subUrb->UrbIsochronousTransfer.IsoPacket[j].Offset = offset;

                if(stageSize > packetSize) {

                    subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = packetSize;
                    offset += packetSize;
                    stageSize -= packetSize;
                }
                else {

                    subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = stageSize;
                    offset += stageSize;
                    stageSize = 0;
                    ASSERT(offset == (subUrb->UrbIsochronousTransfer.IsoPacket[j].Length + 
                                      subUrb->UrbIsochronousTransfer.IsoPacket[j].Offset));
                }
            }
        }

        IoSetNextIrpStackLocation(subIrp);
        nextStack = IoGetCurrentIrpStackLocation(subIrp);

        nextStack->DeviceObject = DeviceObject;
        nextStack->Parameters.Others.Argument1 = (PVOID) subUrb;
        nextStack->Parameters.Others.Argument2 = (PVOID) subMdl;

        nextStack = IoGetNextIrpStackLocation(subIrp);
        nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        nextStack->Parameters.Others.Argument1 = (PVOID) subUrb;
        nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                             IOCTL_INTERNAL_USB_SUBMIT_URB;

        IoSetCompletionRoutine(subIrp,
                               (PIO_COMPLETION_ROUTINE) IsoUsb_SinglePairComplete,
                               (PVOID) rwContext,
                               TRUE,
                               TRUE,
                               TRUE);

        if(TotalLength > (packetSize * 255)) {

            stageSize = packetSize * 255;
        }
        else {

            stageSize = TotalLength;
        }
    }

    //
    // while we were busy create subsidiary irp/urb pairs..
    // the main read/write irp may have been cancelled !!
    //

    KeAcquireSpinLock(&rwContext->SpinLock, &oldIrql);

    IoSetCancelRoutine(Irp, IsoUsb_CancelReadWrite);

    if(Irp->Cancel) {

        //
        // The Cancel flag for the Irp has been set. 
        //
        IsoUsb_DbgPrint(3, ("Cancel flag set\n"));

        ntStatus = STATUS_CANCELLED;

        if(IoSetCancelRoutine(Irp, NULL)) {

            //
            // But the I/O manager did not call our cancel routine.
            // we need to free the 1) irp, 2) urb and 3) mdl for every 
            // stage and complete the main Irp after releasing the lock
            //

            IsoUsb_DbgPrint(3, ("cancellation routine NOT run\n"));

            KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

            goto PerformFullSpeedIsochTransfer_Free;
        }
        else {
            
            //
            // The cancel routine will resume the moment we release the lock.
            //
            for(j = 0; j < numIrps; j++) {

                if(rwContext->SubContext[j].SubUrb) {

                    ExFreePool(rwContext->SubContext[j].SubUrb);
                    rwContext->SubContext[j].SubUrb = NULL;
                }

                if(rwContext->SubContext[j].SubMdl) {

                    IoFreeMdl(rwContext->SubContext[j].SubMdl);
                    rwContext->SubContext[j].SubMdl = NULL;
                }
            }

            IoMarkIrpPending(Irp);

            //
            // it is the job of the cancellation routine to free
            // sub-context irps, release rwContext and complete 
            // the main readwrite irp
            //
            InterlockedDecrement(&rwContext->Lock);

            KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

            return STATUS_PENDING;
        }
    }
    else {

        //
        // normal processing
        //

        IsoUsb_DbgPrint(3, ("normal processing\n"));

        IoMarkIrpPending(Irp);

        KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

        for(j = 0; j < numIrps; j++) {

            IsoUsb_DbgPrint(3, ("PerformFullSpeedIsochTransfer::"));
            IsoUsb_IoIncrement(deviceExtension);
            
            IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                         rwContext->SubContext[j].SubIrp);
        }
        return STATUS_PENDING;
    }

PerformFullSpeedIsochTransfer_Free:

    for(j = 0; j < numIrps; j++) {

        if(rwContext->SubContext[j].SubIrp) {

            IoFreeIrp(rwContext->SubContext[j].SubIrp);
            rwContext->SubContext[j].SubIrp = NULL;
        }

        if(rwContext->SubContext[j].SubUrb) {

            ExFreePool(rwContext->SubContext[j].SubUrb);
            rwContext->SubContext[j].SubUrb = NULL;
        }

        if(rwContext->SubContext[j].SubMdl) {

            IoFreeMdl(rwContext->SubContext[j].SubMdl);
            rwContext->SubContext[j].SubMdl = NULL;
        }
    }

    ExFreePool(rwContext->SubContext);
    ExFreePool(rwContext);


PerformFullSpeedIsochTransfer_Exit:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("PerformFullSpeedIsochTransfer::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("-------------------------------\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_SinglePairComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the completion routine for the subsidiary irp.

    For every irp/urb pair, we have allocated
    1. an irp
    2. an urb
    3. a mdl.

    Case 1:
    we do NOT free the irp on its completion
    we do free the urb and the mdl.

    Case 1 is executed in Block 3.

    Case 2:
    when we complete the last of the subsidiary irp,
    we check if the cancel routine for the main Irp
    has run. If not, we free all the irps, release
    the subcontext and the context and complete the
    main Irp.we also free the urb and mdl for this
    stage.

    Case 2 is executed in Block 2.

    Case 3:
    when we complete the last of the subsidiary irp,
    we check if the cancel routine for the main Irp
    has run. If yes, we atomically decrement the
    rwContext->Lock field. (the completion routine
    is in race with Cancel routine). If the count is 1, 
    the cancel routine will free all the resources.
    we do free the urb and mdl.

    it is expected of the cancellation routine to free 
    all the irps, free the subcontext and the context 
    and complete the main irp

    Case 3 is executed in Block 1b.

    Case 4:
    when we complete the last of the subsidiary irp,
    we check if the cancel routine for the main Irp
    has run. If yes, we atomically decrement the 
    rwContext->Lock field. (the completion routine
    is in race with Cancel routine). If the count is 0,
    we free the irp, subcontext and the context and
    complete the main irp. we also free the urb and
    the mdl for this particular stage.

    the reason we do not free the subsidiary irp at its
    completion is because the cancellation routine can
    run any time.

    Case 4 is executed in Block 1a.
    

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    Context - context for the completion routine

Return Value:

    NT status value

--*/
{
    PURB               urb;
    PMDL               mdl;
    PIRP               mainIrp;
    KIRQL              oldIrql;
    ULONG              i;
    ULONG              info;
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PISOUSB_RW_CONTEXT rwContext;
    PIO_STACK_LOCATION irpStack;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    urb = (PURB) irpStack->Parameters.Others.Argument1;
    mdl = (PMDL) irpStack->Parameters.Others.Argument2;
    info = 0;
    ntStatus = Irp->IoStatus.Status;
    rwContext = (PISOUSB_RW_CONTEXT) Context;
    deviceExtension = rwContext->DeviceExtension;

    IsoUsb_DbgPrint(3, ("IsoUsb_SinglePairComplete - begins\n"));

    ASSERT(rwContext);
    
    KeAcquireSpinLock(&rwContext->SpinLock, &oldIrql);

    if(NT_SUCCESS(ntStatus) &&
       USBD_SUCCESS(urb->UrbHeader.Status)) {

        rwContext->NumXfer += 
                urb->UrbIsochronousTransfer.TransferBufferLength;

        IsoUsb_DbgPrint(1, ("rwContext->NumXfer = %d\n", rwContext->NumXfer));
    }
    else {

        IsoUsb_DbgPrint(1, ("read-write irp failed with status %X\n", ntStatus));
        IsoUsb_DbgPrint(1, ("urb header status %X\n", urb->UrbHeader.Status));
    }

    for(i = 0; i < urb->UrbIsochronousTransfer.NumberOfPackets; i++) {

        IsoUsb_DbgPrint(3, ("IsoPacket[%d].Length = %X IsoPacket[%d].Status = %X\n",
                            i,
                            urb->UrbIsochronousTransfer.IsoPacket[i].Length,
                            i,
                            urb->UrbIsochronousTransfer.IsoPacket[i].Status));
    }

    if(InterlockedDecrement(&rwContext->IrpsPending) == 0) {

        IsoUsb_DbgPrint(3, ("no more irps pending\n"));

        if(NT_SUCCESS(ntStatus)) {
        
            IsoUsb_DbgPrint(1, ("urb start frame %X\n", 
                                urb->UrbIsochronousTransfer.StartFrame));
        }

        mainIrp = (PIRP) InterlockedExchangePointer(&rwContext->RWIrp, NULL);

        ASSERT(mainIrp);

        if(IoSetCancelRoutine(mainIrp, NULL) == NULL) {
            
            //
            // cancel routine has begun the race
            //
            // Block 1a.
            //
            IsoUsb_DbgPrint(3, ("cancel routine has begun the race\n"));

            if(InterlockedDecrement(&rwContext->Lock) == 0) {

                //
                // do the cleanup job ourselves
                //
                IsoUsb_DbgPrint(3, ("losers do the cleanup\n"));

                for(i = 0; i < rwContext->NumIrps; i++) {

                    IoFreeIrp(rwContext->SubContext[i].SubIrp);
                    rwContext->SubContext[i].SubIrp = NULL;
                }

                info = rwContext->NumXfer;

                KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

                ExFreePool(rwContext->SubContext);
                ExFreePool(rwContext);

                //
                // if we transferred some data, main Irp completes with success
                //

                IsoUsb_DbgPrint(1, ("Total data transferred = %X\n", info));

                IsoUsb_DbgPrint(1, ("***\n"));
                
                mainIrp->IoStatus.Status = STATUS_SUCCESS; // ntStatus;
                mainIrp->IoStatus.Information = info;
        
                IoCompleteRequest(mainIrp, IO_NO_INCREMENT);

                IsoUsb_DbgPrint(3, ("IsoUsb_SinglePairComplete::"));
                IsoUsb_IoDecrement(deviceExtension);

                IsoUsb_DbgPrint(3, ("-------------------------------\n"));

                goto IsoUsb_SinglePairComplete_Exit;
            }
            else {

                //
                // Block 1b.
                //

                IsoUsb_DbgPrint(3, ("cancel routine performs the cleanup\n"));
            }
        }
        else {

            //
            // Block 2.
            //
            IsoUsb_DbgPrint(3, ("cancel routine has NOT run\n"));

            for(i = 0; i < rwContext->NumIrps; i++) {

                IoFreeIrp(rwContext->SubContext[i].SubIrp);
                rwContext->SubContext[i].SubIrp = NULL;
            }

            info = rwContext->NumXfer;

            KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

            ExFreePool(rwContext->SubContext);
            ExFreePool(rwContext);

            //
            // if we transferred some data, main Irp completes with success
            //
            IsoUsb_DbgPrint(1, ("Total data transferred = %X\n", info));

            IsoUsb_DbgPrint(1, ("***\n"));
            
            mainIrp->IoStatus.Status = STATUS_SUCCESS; // ntStatus;
            mainIrp->IoStatus.Information = info;
        
            IoCompleteRequest(mainIrp, IO_NO_INCREMENT);

            IsoUsb_DbgPrint(3, ("IsoUsb_SinglePairComplete::"));
            IsoUsb_IoDecrement(deviceExtension);

            IsoUsb_DbgPrint(3, ("-------------------------------\n"));

            goto IsoUsb_SinglePairComplete_Exit;
        }
    }

    KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

IsoUsb_SinglePairComplete_Exit:

    //
    // Block 3.
    //

    ExFreePool(urb);
    IoFreeMdl(mdl);

    IsoUsb_DbgPrint(3, ("IsoUsb_SinglePairComplete::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("IsoUsb_SinglePairComplete - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
IsoUsb_CancelReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This is the cancellation routine for the main read/write Irp.
    The policy is as follows:

    If the cancellation routine is the last to decrement
    rwContext->Lock, then free the irps, subcontext and
    the context. Complete the main irp
    
    Otherwise, call IoCancelIrp on each of the subsidiary irp.
    It is valid to call IoCancelIrp on irps for which the 
    completion routine has executed, because, we do not free the
    irps in the completion routine.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    None

--*/
{
    PIRP               mainIrp;
    KIRQL              oldIrql;
    ULONG              i;
    ULONG              info;
    PDEVICE_EXTENSION  deviceExtension;
    PISOUSB_RW_CONTEXT rwContext;

    //
    // initialize vars
    //
    info = 0;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    IsoUsb_DbgPrint(3, ("IsoUsb_CancelReadWrite - begins\n"));

    rwContext = (PISOUSB_RW_CONTEXT) Irp->Tail.Overlay.DriverContext[0];
    ASSERT(rwContext);
    deviceExtension = rwContext->DeviceExtension;

    KeAcquireSpinLock(&rwContext->SpinLock, &oldIrql);

    if(InterlockedDecrement(&rwContext->Lock)) {

        IsoUsb_DbgPrint(3, ("about to cancel sub context irps..\n"));

        for(i = 0; i < rwContext->NumIrps; i++) {

            if(rwContext->SubContext[i].SubIrp) {

                IoCancelIrp(rwContext->SubContext[i].SubIrp);
            }
        }

        KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

        IsoUsb_DbgPrint(3, ("IsoUsb_CancelReadWrite - ends\n"));

        return;
    }
    else {

        for(i = 0; i < rwContext->NumIrps; i++) {

            IoFreeIrp(rwContext->SubContext[i].SubIrp);
            rwContext->SubContext[i].SubIrp = NULL;
        }

        mainIrp = (PIRP) InterlockedExchangePointer(&rwContext->RWIrp, NULL);

        info = rwContext->NumXfer;

        KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

        ExFreePool(rwContext->SubContext);
        ExFreePool(rwContext);

        //
        // if we transferred some data, main Irp completes with success
        //

        IsoUsb_DbgPrint(1, ("Total data transferred = %X\n", info));

        IsoUsb_DbgPrint(1, ("***\n"));

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Status = info;
/*        
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
*/
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        IsoUsb_DbgPrint(3, ("IsoUsb_CancelReadWrite::"));
        IsoUsb_IoDecrement(deviceExtension);

        IsoUsb_DbgPrint(3, ("-------------------------------\n"));

        return;
    }
}

ULONG
IsoUsb_GetCurrentFrame(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine send an irp/urb pair with
    function code URB_FUNCTION_GET_CURRENT_FRAME_NUMBER
    to fetch the current frame

Arguments:

    DeviceObject - pointer to device object
    PIRP - I/O request packet

Return Value:

    Current frame

--*/
{
    KEVENT                               event;
    PDEVICE_EXTENSION                    deviceExtension;
    PIO_STACK_LOCATION                   nextStack;
    struct _URB_GET_CURRENT_FRAME_NUMBER urb;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // initialize the urb
    //

    IsoUsb_DbgPrint(3, ("IsoUsb_GetCurrentFrame - begins\n"));

    urb.Hdr.Function = URB_FUNCTION_GET_CURRENT_FRAME_NUMBER;
    urb.Hdr.Length = sizeof(urb);
    urb.FrameNumber = (ULONG) -1;

    nextStack = IoGetNextIrpStackLocation(Irp);
    nextStack->Parameters.Others.Argument1 = (PVOID) &urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    IoSetCompletionRoutine(Irp,
                           IsoUsb_StopCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    IsoUsb_DbgPrint(3, ("IsoUsb_GetCurrentFrame::"));
    IsoUsb_IoIncrement(deviceExtension);

    IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                 Irp);

    KeWaitForSingleObject((PVOID) &event,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    IsoUsb_DbgPrint(3, ("IsoUsb_GetCurrentFrame::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("IsoUsb_GetCurrentFrame - ends\n"));

    return urb.FrameNumber;
}

NTSTATUS
IsoUsb_StopCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the completion routine for request to retrieve the frame number

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    Context - context passed to the completion routine

Return Value:

    NT status value

--*/
{
    PKEVENT event;

    IsoUsb_DbgPrint(3, ("IsoUsb_StopCompletion - begins\n"));

    event = (PKEVENT) Context;

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    IsoUsb_DbgPrint(3, ("IsoUsb_StopCompletion - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isostrm.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isostrm.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_STRM_H
#define _ISOUSB_STRM_H

#define ISOUSB_MAX_IRP                  2
#define ISOCH_IN_PIPE_INDEX             4
#define ISOCH_OUT_PIPE_INDEX            5

typedef struct _ISOUSB_STREAM_OBJECT {

    // number of pending irps for this stream
    ULONG PendingIrps;

    // event signaled when no irps pending
    KEVENT NoPendingIrpEvent;
    
    PDEVICE_OBJECT DeviceObject;

    PUSBD_PIPE_INFORMATION PipeInformation;

    struct _ISOUSB_TRANSFER_OBJECT *TransferObjectList[ISOUSB_MAX_IRP];

} ISOUSB_STREAM_OBJECT, *PISOUSB_STREAM_OBJECT;

typedef struct _ISOUSB_TRANSFER_OBJECT {

    PIRP Irp;

    PURB Urb;

    PUCHAR DataBuffer;

    //
    // statistics.
    //
    ULONG TimesRecycled;

    ULONG TotalPacketsProcessed;

    ULONG TotalBytesProcessed;

    ULONG ErrorPacketCount;

    PISOUSB_STREAM_OBJECT StreamObject;

} ISOUSB_TRANSFER_OBJECT, *PISOUSB_TRANSFER_OBJECT;


NTSTATUS
IsoUsb_StartIsoStream(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
IsoUsb_StartTransfer(
    IN PDEVICE_OBJECT        DeviceObject,
    IN PISOUSB_STREAM_OBJECT StreamObject,
    IN ULONG                 Index
    );

NTSTATUS
IsoUsb_InitializeStreamUrb(
    IN PDEVICE_OBJECT          DeviceObject,
    IN PISOUSB_TRANSFER_OBJECT TransferObject
    );

NTSTATUS
IsoUsb_IsoIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
IsoUsb_ProcessTransfer(
    IN PISOUSB_TRANSFER_OBJECT TransferObject
    );

NTSTATUS
IsoUsb_StopIsoStream(
    IN PDEVICE_OBJECT        DeviceObject,
    IN PISOUSB_STREAM_OBJECT StreamObject,
    IN PIRP                  Irp
    );

NTSTATUS
IsoUsb_StreamObjectCleanup(
    IN PISOUSB_STREAM_OBJECT StreamObject,
    IN PDEVICE_EXTENSION     DeviceExtension
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isostrm.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isostrm.c

Abstract:

    This file has routines for stream transfers.
    Stream transfers are initiated and stopped using
    the IOCTLs exposed by this driver.
    The stream transfer information is contained in 
    ISOUSB_STREAM_OBJECT structure which is securely
    placed in the FileObject. The ISOUSB_STREAM_OBJECT 
    structure has links to ISOUSB_TRANSFER_OBJECT 
    (each TRANSFER_OBJECT corresponds to the number of 
    irp/urb pair circulating).
    So if the user-mode app simply crashes or aborts or 
    does not terminate, we can cleanly abort the stream
    transfers.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isousr.h"
#include "isowmi.h"
#include "isorwr.h"
#include "isostrm.h"

NTSTATUS
IsoUsb_StartIsoStream(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine create a single stream object and
    invokes StartTransfer for ISOUSB_MAX_IRP number of 
    times.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    ULONG                  i;
    ULONG                  info;
    ULONG                  inputBufferLength;
    ULONG                  outputBufferLength;
    NTSTATUS               ntStatus;
    PFILE_OBJECT           fileObject;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_STACK_LOCATION     irpStack;
    PISOUSB_STREAM_OBJECT  streamObject;
    PUSBD_PIPE_INFORMATION pipeInformation;

    info = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    streamObject = NULL;
    pipeInformation = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    inputBufferLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    IsoUsb_DbgPrint(3, ("IsoUsb_StartIsoStream - begins\n"));

    streamObject = ExAllocatePool(NonPagedPool, 
                                  sizeof(struct _ISOUSB_STREAM_OBJECT));

    if(streamObject == NULL) {

        IsoUsb_DbgPrint(1, ("failed to alloc mem for streamObject\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto IsoUsb_StartIsoStream_Exit;
    }

    RtlZeroMemory(streamObject, sizeof(ISOUSB_STREAM_OBJECT));

    //
    // The Isoch IN pipe for the board is the 5th pipe
    //
    pipeInformation = &(deviceExtension->UsbInterface->Pipes[ISOCH_IN_PIPE_INDEX]);

    // reset the pipe
    //
    IsoUsb_ResetPipe(DeviceObject, pipeInformation);
    
    streamObject->DeviceObject = DeviceObject;
    streamObject->PipeInformation = pipeInformation;

    KeInitializeEvent(&streamObject->NoPendingIrpEvent,
                      NotificationEvent,
                      FALSE);

    for(i = 0; i < ISOUSB_MAX_IRP; i++) {

        ntStatus = IsoUsb_StartTransfer(DeviceObject,
                                        streamObject,
                                        i);

        if(!NT_SUCCESS(ntStatus)) {
         
            //
            // we continue sending transfer object irps..
            //
            
            IsoUsb_DbgPrint(1, ("IsoUsb_StartTransfer [%d] - failed\n", i));

            if(ntStatus == STATUS_INSUFFICIENT_RESOURCES) {
                
                ASSERT(streamObject->TransferObjectList[i] == NULL);
            }
        }
    }

    if(fileObject && fileObject->FsContext) {
        
        if(streamObject->PendingIrps) {

            ((PFILE_OBJECT_CONTENT)fileObject->FsContext)->StreamInformation 
                                                                = streamObject;
        }
        else {

            IsoUsb_DbgPrint(1, ("no transfer object irp sent..abort..\n"));
            ExFreePool(streamObject);
            ((PFILE_OBJECT_CONTENT)fileObject->FsContext)->StreamInformation = NULL;
        }
    }

IsoUsb_StartIsoStream_Exit:

    Irp->IoStatus.Information = info;
    Irp->IoStatus.Status = ntStatus;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_StartIsoStream::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("IsoUsb_StartIsoStream - ends\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_StartTransfer(
    IN PDEVICE_OBJECT        DeviceObject,
    IN PISOUSB_STREAM_OBJECT StreamObject,
    IN ULONG                 Index
    )
/*++
 
Routine Description:

    This routine creates a transfer object for each irp/urb pair.
    After initializing the pair, it sends the irp down the stack.

Arguments:

    DeviceObject - pointer to device object.
    StreamObject - pointer to stream object
    Index - index into the transfer object table in stream object

Return Value:

    NT status value

--*/
{
    PIRP                    irp;
    CCHAR                   stackSize;
    ULONG                   packetSize;
    ULONG                   maxXferSize;
    ULONG                   numPackets;
    NTSTATUS                ntStatus;
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      nextStack;
    PISOUSB_TRANSFER_OBJECT transferObject;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    maxXferSize = StreamObject->PipeInformation->MaximumTransferSize;
    packetSize = StreamObject->PipeInformation->MaximumPacketSize;
    numPackets = maxXferSize / packetSize;

    IsoUsb_DbgPrint(3, ("IsoUsb_StartTransfer - begins\n"));

    transferObject = ExAllocatePool(NonPagedPool,
                                    sizeof(struct _ISOUSB_TRANSFER_OBJECT));

    if(transferObject == NULL) {

        IsoUsb_DbgPrint(1, ("failed to alloc mem for transferObject\n"));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(transferObject,
                  sizeof(struct _ISOUSB_TRANSFER_OBJECT));


    transferObject->StreamObject = StreamObject;
    
    stackSize = (CCHAR) (deviceExtension->TopOfStackDeviceObject->StackSize + 1);

    irp = IoAllocateIrp(stackSize, FALSE);

    if(irp == NULL) {

        IsoUsb_DbgPrint(1, ("failed to alloc mem for irp\n"));

        ExFreePool(transferObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    transferObject->Irp = irp;

    transferObject->DataBuffer = ExAllocatePool(NonPagedPool,
                                                maxXferSize);

    if(transferObject->DataBuffer == NULL) {

        IsoUsb_DbgPrint(1, ("failed to alloc mem for DataBuffer\n"));

        ExFreePool(transferObject);
        IoFreeIrp(irp);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    transferObject->Urb = ExAllocatePool(NonPagedPool,
                                         GET_ISO_URB_SIZE(numPackets));

    if(transferObject->Urb == NULL) {

        IsoUsb_DbgPrint(1, ("failed to alloc mem for Urb\n"));

        ExFreePool(transferObject->DataBuffer);
        IoFreeIrp(irp);
        ExFreePool(transferObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IsoUsb_InitializeStreamUrb(DeviceObject, transferObject);

    StreamObject->TransferObjectList[Index] = transferObject;
    InterlockedIncrement(&StreamObject->PendingIrps);

    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->Parameters.Others.Argument1 = transferObject->Urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                   IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    IoSetCompletionRoutine(irp, 
                           IsoUsb_IsoIrp_Complete,
                           transferObject,
                           TRUE,
                           TRUE,
                           TRUE);

    IsoUsb_DbgPrint(3, ("IsoUsb_StartTransfer::"));
    IsoUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            irp);

    if(NT_SUCCESS(ntStatus)) {

        ntStatus = STATUS_SUCCESS;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_StartTransfer - ends\n"));

    return ntStatus;
}


NTSTATUS
IsoUsb_InitializeStreamUrb(
    IN PDEVICE_OBJECT          DeviceObject,
    IN PISOUSB_TRANSFER_OBJECT TransferObject
    )
/*++
 
Routine Description:

    This routine initializes the irp/urb pair in the transfer object.

Arguments:

    DeviceObject - pointer to device object
    TransferObject - pointer to transfer object

Return Value:

    NT status value

--*/
{
    PURB                  urb;
    ULONG                 i;
    ULONG                 siz;
    ULONG                 packetSize;
    ULONG                 numPackets;
    ULONG                 maxXferSize;
    PISOUSB_STREAM_OBJECT streamObject;

    urb = TransferObject->Urb;
    streamObject = TransferObject->StreamObject;
    maxXferSize = streamObject->PipeInformation->MaximumTransferSize;
    packetSize = streamObject->PipeInformation->MaximumPacketSize;
    numPackets = maxXferSize / packetSize;

    IsoUsb_DbgPrint(3, ("IsoUsb_InitializeStreamUrb - begins\n"));

    if(numPackets > 255) {

        numPackets = 255;
        maxXferSize = packetSize * numPackets;
    }

    siz = GET_ISO_URB_SIZE(numPackets);

    RtlZeroMemory(urb, siz);

    urb->UrbIsochronousTransfer.Hdr.Length = (USHORT) siz;
    urb->UrbIsochronousTransfer.Hdr.Function = URB_FUNCTION_ISOCH_TRANSFER;
    urb->UrbIsochronousTransfer.PipeHandle =
                                streamObject->PipeInformation->PipeHandle;

    urb->UrbIsochronousTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_IN;

    urb->UrbIsochronousTransfer.TransferBufferMDL = NULL;
    urb->UrbIsochronousTransfer.TransferBuffer = TransferObject->DataBuffer;
    urb->UrbIsochronousTransfer.TransferBufferLength = numPackets * packetSize;

    urb->UrbIsochronousTransfer.TransferFlags |= USBD_START_ISO_TRANSFER_ASAP;

    urb->UrbIsochronousTransfer.NumberOfPackets = numPackets;
    urb->UrbIsochronousTransfer.UrbLink = NULL;

    for(i=0; i<urb->UrbIsochronousTransfer.NumberOfPackets; i++) {

        urb->UrbIsochronousTransfer.IsoPacket[i].Offset = i * packetSize;

        //
        // For input operation, length is set to whatever the device supplies.
        //
        urb->UrbIsochronousTransfer.IsoPacket[i].Length = 0;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_InitializeStreamUrb - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
IsoUsb_IsoIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the completion routine of the irp in the irp/urb pair
    passed down the stack for stream transfers.

    If the transfer was cancelled or the device yanked out, then we
    release resources, dump the statistics and return 
    STATUS_MORE_PROCESSING_REQUIRED, so that the cleanup module can
    free the irp.

    otherwise, we reinitialize the transfers and continue recirculaiton 
    of the irps.

Arguments:

    DeviceObject - pointer to device object below us.
    Irp - I/O completion routine.
    Context - context passed to the completion routine

Return Value:

--*/
{
    NTSTATUS                ntStatus;
    PDEVICE_OBJECT          deviceObject;
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      nextStack;
    PISOUSB_STREAM_OBJECT   streamObject;
    PISOUSB_TRANSFER_OBJECT transferObject;

    transferObject = (PISOUSB_TRANSFER_OBJECT) Context;
    streamObject = transferObject->StreamObject;
    deviceObject = streamObject->DeviceObject;
    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("IsoUsb_IsoIrp_Complete - begins\n"));

    ntStatus = IsoUsb_ProcessTransfer(transferObject);

    if((ntStatus == STATUS_CANCELLED) ||
       (ntStatus == STATUS_DEVICE_NOT_CONNECTED)) {
    
        IsoUsb_DbgPrint(3, ("Isoch irp cancelled/device removed\n"));

        //
        // this is the last irp to complete with this erroneous value
        // signal an event and return STATUS_MORE_PROCESSING_REQUIRED
        //
        if(InterlockedDecrement(&streamObject->PendingIrps) == 0) {

            KeSetEvent(&streamObject->NoPendingIrpEvent,
                       1,
                       FALSE);

            IsoUsb_DbgPrint(3, ("-----------------------------\n"));
        }

        IsoUsb_DbgPrint(3, ("IsoUsb_IsoIrp_Complete::"));
        IsoUsb_IoDecrement(deviceExtension);

        transferObject->Irp = NULL;
        IoFreeIrp(Irp);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // otherwise circulate the irps.
    //

    IsoUsb_InitializeStreamUrb(deviceObject, transferObject);

    nextStack = IoGetNextIrpStackLocation(Irp);
    nextStack->Parameters.Others.Argument1 = transferObject->Urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                                IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    IoSetCompletionRoutine(Irp,
                           IsoUsb_IsoIrp_Complete,
                           transferObject,
                           TRUE,
                           TRUE,
                           TRUE);

    transferObject->TimesRecycled++;

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            Irp);

    IsoUsb_DbgPrint(3, ("IsoUsb_IsoIrp_Complete - ends\n"));
    IsoUsb_DbgPrint(3, ("-----------------------------\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
IsoUsb_ProcessTransfer(
    IN PISOUSB_TRANSFER_OBJECT TransferObject
    )
/*++
 
Routine Description:

    This routine is invoked from the completion routine to check the status
    of the irp, urb and the isochronous packets.

    updates statistics

Arguments:

    TranferObject - pointer to transfer object for the irp/urb pair which completed.

Return Value:

    NT status value

--*/
{
    PIRP        irp;
    PURB        urb;
    ULONG       i;
    NTSTATUS    ntStatus;
    USBD_STATUS usbdStatus;

    irp = TransferObject->Irp;
    urb = TransferObject->Urb;
    ntStatus = irp->IoStatus.Status;

    IsoUsb_DbgPrint(3, ("IsoUsb_ProcessTransfer - begins\n"));

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(3, ("Isoch irp failed with status = %X\n", ntStatus));
    }

    usbdStatus = urb->UrbHeader.Status;

    if(!USBD_SUCCESS(usbdStatus)) {

        IsoUsb_DbgPrint(3, ("urb failed with status = %X\n", usbdStatus));
    }

    //
    // check each of the urb packets
    //
    for(i = 0; i < urb->UrbIsochronousTransfer.NumberOfPackets; i++) {

        TransferObject->TotalPacketsProcessed++;

        usbdStatus = urb->UrbIsochronousTransfer.IsoPacket[i].Status;

        if(!USBD_SUCCESS(usbdStatus)) {

//            IsoUsb_DbgPrint(3, ("Iso packet %d failed with status = %X\n", i, usbdStatus));
            
            TransferObject->ErrorPacketCount++;
        }
        else {
            
            TransferObject->TotalBytesProcessed += urb->UrbIsochronousTransfer.IsoPacket[i].Length;
        }
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_ProcessTransfer - ends\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_StopIsoStream(
    IN PDEVICE_OBJECT        DeviceObject,
    IN PISOUSB_STREAM_OBJECT StreamObject,
    IN PIRP                  Irp
    )
/*++
 
Routine Description:

    This routine is invoked from the IOCTL to stop the stream transfers.

Arguments:

    DeviceObject - pointer to device object
    StreamObject - pointer to stream object
    Irp - pointer to Irp

Return Value:

    NT status value

--*/
{
    ULONG              i;
    KIRQL              oldIrql;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize vars
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("IsoUsb_StopIsoStream - begins\n"));

    if((StreamObject == NULL) ||
       (StreamObject->DeviceObject != DeviceObject)) {

        IsoUsb_DbgPrint(1, ("invalid streamObject\n"));
        return STATUS_INVALID_PARAMETER;
    }

    IsoUsb_StreamObjectCleanup(StreamObject, deviceExtension);

    IsoUsb_DbgPrint(3, ("IsoUsb_StopIsoStream - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
IsoUsb_StreamObjectCleanup(
    IN PISOUSB_STREAM_OBJECT StreamObject,
    IN PDEVICE_EXTENSION     DeviceExtension
    )
/*++
 
Routine Description:

    This routine is invoked either when the user-mode app passes an IOCTL to
    abort stream transfers or when the the cleanup dispatch routine is run.
    It is guaranteed to run only once for every stream transfer.

Arguments:

    StreamObject - StreamObject corresponding to stream transfer which
    needs to be aborted.

    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    ULONG                   i;
    ULONG                   timesRecycled;
    ULONG                   totalPacketsProcessed;
    ULONG                   totalBytesProcessed;
    ULONG                   errorPacketCount;
    PISOUSB_TRANSFER_OBJECT xferObject;

    //
    // initialize the variables
    //
    timesRecycled = 0;
    totalPacketsProcessed = 0;
    totalBytesProcessed = 0;
    errorPacketCount = 0;

    //
    // cancel transferobject irps/urb pair
    // safe to touch these irps because the 
    // completion routine always returns 
    // STATUS_MORE_PRCESSING_REQUIRED
    // 
    //
    for(i = 0; i < ISOUSB_MAX_IRP; i++) {

        if(StreamObject->TransferObjectList[i] &&
           StreamObject->TransferObjectList[i]->Irp) {
        
            IoCancelIrp(StreamObject->TransferObjectList[i]->Irp);
        }
    }

    //
    // wait for the transfer objects irps to complete.
    //
    KeWaitForSingleObject(&StreamObject->NoPendingIrpEvent,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    //
    // dump the statistics
    //
    for(i = 0; i < ISOUSB_MAX_IRP; i++) {

        xferObject = StreamObject->TransferObjectList[i];

        if(xferObject) {

            timesRecycled += xferObject->TimesRecycled;
            totalPacketsProcessed += xferObject->TotalPacketsProcessed;
            totalBytesProcessed += xferObject->TotalBytesProcessed;
            errorPacketCount += xferObject->ErrorPacketCount;
        }
    }

    IsoUsb_DbgPrint(3, ("TimesRecycled = %d\n", timesRecycled));
    IsoUsb_DbgPrint(3, ("TotalPacketsProcessed = %d\n", totalPacketsProcessed));
    IsoUsb_DbgPrint(3, ("TotalBytesProcessed = %d\n", totalBytesProcessed));
    IsoUsb_DbgPrint(3, ("ErrorPacketCount = %d\n", errorPacketCount));


    //
    // free all the buffers, urbs and transfer objects 
    // associated with stream object
    //
    for(i = 0; i < ISOUSB_MAX_IRP; i++) {
        
        xferObject = StreamObject->TransferObjectList[i];

        if(xferObject) { 
            
            if(xferObject->Urb) {

                ExFreePool(xferObject->Urb);
                xferObject->Urb = NULL;
            }

            if(xferObject->DataBuffer) {
    
                ExFreePool(xferObject->DataBuffer);
                xferObject->DataBuffer = NULL;
            }

            ExFreePool(xferObject);
            StreamObject->TransferObjectList[i] = NULL;
        }
    }

    ExFreePool(StreamObject);

//    IsoUsb_ResetParentPort(DeviceObject);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\selsusp\sys\makefile.inc ===
mofcomp: selSusp.bmf

selSusp.bmf: selSusp.mof
        mofcomp -B:selSusp.bmf selSusp.mof
        wmimofck selSusp.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isousb.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isousb.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include <initguid.h>
#include <wdm.h>
#include <wdmguid.h>
#include <wmistr.h>
#include <wmilib.h>
#include "usbdi.h"
#include "usbdlib.h"
#include "usbbusif.h"

#ifndef _ISOUSB_H
#define _ISOUSB_H

#define ISOTAG (ULONG) 'OsI'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
    ExAllocatePoolWithTag(type, size, ISOTAG);

#if DBG

#define IsoUsb_DbgPrint(level, _x_) \
            if((level) <= DebugLevel) { \
                DbgPrint _x_; \
            }
#else

#define IsoUsb_DbgPrint(level, _x_)

#endif

typedef struct _GLOBALS {

    UNICODE_STRING IsoUsb_RegistryPath;

} GLOBALS;

#define IDLE_INTERVAL 5000

typedef enum _DEVSTATE {

    NotStarted,         // not started
    Stopped,            // device stopped
    Working,            // started and working
    PendingStop,        // stop pending
    PendingRemove,      // remove pending
    SurpriseRemoved,    // removed by surprise
    Removed             // removed

} DEVSTATE;

typedef enum _QUEUE_STATE {

    HoldRequests,       // device is not started yet
    AllowRequests,      // device is ready to process
    FailRequests        // fail both existing and queued up requests

} QUEUE_STATE;

typedef enum _WDM_VERSION {

    WinXpOrBetter,
    Win2kOrBetter,
    WinMeOrBetter,
    Win98OrBetter

} WDM_VERSION;

#define INITIALIZE_PNP_STATE(_Data_)    \
        (_Data_)->DeviceState =  NotStarted;\
        (_Data_)->PrevDevState = NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_) \
        (_Data_)->PrevDevState =  (_Data_)->DeviceState;\
        (_Data_)->DeviceState = (_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)   \
        (_Data_)->DeviceState =   (_Data_)->PrevDevState;

#define ISOUSB_MAX_TRANSFER_SIZE    256
#define ISOUSB_TEST_BOARD_TRANSFER_BUFFER_SIZE (64 * 1024)

//
// registry path used for parameters 
// global to all instances of the driver
//

#define ISOUSB_REGISTRY_PARAMETERS_PATH  \
	L"\\REGISTRY\\Machine\\System\\CurrentControlSet\\SERVICES\\ISOUSB\\Parameters"


//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _DEVICE_EXTENSION {

    // Functional Device Object
    PDEVICE_OBJECT FunctionalDeviceObject;

    // Device object we call when submitting Urbs
    PDEVICE_OBJECT TopOfStackDeviceObject;

    // The bus driver object
    PDEVICE_OBJECT PhysicalDeviceObject;

    // Name buffer for our named Functional device object link
    // The name is generated based on the driver's class GUID
    UNICODE_STRING InterfaceName;

    // Bus drivers set the appropriate values in this structure in response
    // to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
    // alter the capabilities set by the bus driver.
    DEVICE_CAPABILITIES DeviceCapabilities;

    // Configuration Descriptor
    PUSB_CONFIGURATION_DESCRIPTOR UsbConfigurationDescriptor;

    // Interface Information structure
    PUSBD_INTERFACE_INFORMATION UsbInterface;

    // current state of device
    DEVSTATE DeviceState;

    // state prior to removal query
    DEVSTATE PrevDevState;

    // obtain and hold this lock while changing the device state,
    // the queue state and while processing the queue.
    KSPIN_LOCK DevStateLock;

    // current system power state
    SYSTEM_POWER_STATE SysPower;

    // current device power state
    DEVICE_POWER_STATE DevPower;

    // Pending I/O queue state
    QUEUE_STATE QueueState;

    // Pending I/O queue
    LIST_ENTRY NewRequestsQueue;

    // I/O Queue Lock
    KSPIN_LOCK QueueLock;

    KEVENT RemoveEvent;

    KEVENT StopEvent;
    
    ULONG OutStandingIO;

    KSPIN_LOCK IOCountLock;

    // selective suspend variables

    LONG SSEnable;

    LONG SSRegistryEnable;

    PUSB_IDLE_CALLBACK_INFO IdleCallbackInfo;
	
    PIRP PendingIdleIrp;
	
    LONG IdleReqPend;

    LONG FreeIdleIrpCount;

    KSPIN_LOCK IdleReqStateLock;

    KEVENT NoIdleReqPendEvent;

    // default power state to power down to on self-susped
    ULONG PowerDownLevel;
    
    // remote wakeup variables
    PIRP WaitWakeIrp;

    LONG FlagWWCancel;

    LONG FlagWWOutstanding;

    LONG WaitWakeEnable;

    // open handle count
    LONG OpenHandleCount;

    // selective suspend model uses timers, dpcs and work item.
    KTIMER Timer;

    KDPC DeferredProcCall;

    // This event is cleared when a DPC/Work Item is queued.
    // and signaled when the work-item completes.
    // This is essential to prevent the driver from unloading
    // while we have DPC or work-item queued up.
    KEVENT NoDpcWorkItemPendingEvent;

    // WMI information
    WMILIB_CONTEXT WmiLibInfo;

    // WDM version
    WDM_VERSION WdmVersion;

    // High speed
    ULONG IsDeviceHighSpeed;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct _IRP_COMPLETION_CONTEXT {

    PDEVICE_EXTENSION DeviceExtension;

    PKEVENT Event;

} IRP_COMPLETION_CONTEXT, *PIRP_COMPLETION_CONTEXT;

extern ULONG DebugLevel;
extern GLOBALS Globals;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isousb.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isousb.c

Abstract:

    Isoch USB device driver for Intel 82930 USB test board
	Main module

Author:

Environment:

    kernel mode only

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isowmi.h"
#include "isousr.h"
#include "isorwr.h"
#include "isostrm.h"

//
// Globals
//

ULONG   DebugLevel = 1;
GLOBALS Globals;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    );

VOID
IsoUsb_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
IsoUsb_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, IsoUsb_DriverUnload)
#pragma alloc_text(PAGE, IsoUsb_DispatchCreate)
#pragma alloc_text(PAGE, IsoUsb_DispatchClose)
#endif
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    )
/*++ 

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.    

Arguments:
    
    DriverObject - pointer to driver object 

    RegistryPath - pointer to a unicode string representing the path to driver 
                   specific key in the registry.

Return Values:

    NT status value
    
--*/
{

    NTSTATUS        ntStatus;
    PUNICODE_STRING registryPath;
    
    //
    // initialization of variables
    //
    registryPath = &Globals.IsoUsb_RegistryPath;

    //
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //
    registryPath->MaximumLength = UniRegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length        = UniRegistryPath->Length;
    registryPath->Buffer        = ExAllocatePool(PagedPool,
                                                 registryPath->MaximumLength);

    if (!registryPath->Buffer) {

        IsoUsb_DbgPrint(1, ("Failed to allocate memory for registryPath\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntry_Exit;
    } 


    RtlZeroMemory (registryPath->Buffer, 
                   registryPath->MaximumLength);
    RtlMoveMemory (registryPath->Buffer, 
                   UniRegistryPath->Buffer, 
                   UniRegistryPath->Length);

    ntStatus = STATUS_SUCCESS;

    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IsoUsb_DispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = IsoUsb_DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = IsoUsb_DispatchPnP;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = IsoUsb_DispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = IsoUsb_DispatchClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = IsoUsb_DispatchClean;
    DriverObject->MajorFunction[IRP_MJ_READ]           =
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = IsoUsb_DispatchReadWrite;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = IsoUsb_DispatchSysCtrl;
    DriverObject->DriverUnload                         = IsoUsb_DriverUnload;
    DriverObject->DriverExtension->AddDevice           = (PDRIVER_ADD_DEVICE)
                                                         IsoUsb_AddDevice;
DriverEntry_Exit:

    return ntStatus;
}

VOID
IsoUsb_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Description:

    This function will free the memory allocations in DriverEntry.

Arguments:

    DriverObject - pointer to driver object 

Return:
	
    None

--*/
{
    PUNICODE_STRING registryPath;

    IsoUsb_DbgPrint(3, ("IsoUsb_DriverUnload - begins\n"));

    registryPath = &Globals.IsoUsb_RegistryPath;

    if(registryPath->Buffer) {

        ExFreePool(registryPath->Buffer);
        registryPath->Buffer = NULL;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_DriverUnload - ends\n"));

    return;
}

NTSTATUS
IsoUsb_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Description:

Arguments:

    DriverObject - Store the pointer to the object representing us.

    PhysicalDeviceObject - Pointer to the device object created by the
                           undelying bus driver.

Return:
	
    STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    POWER_STATE       state;
    KIRQL             oldIrql;

    IsoUsb_DbgPrint(3, ("IsoUsb_AddDevice - begins\n"));

    deviceObject = NULL;

    ntStatus = IoCreateDevice(
                    DriverObject,                   // our driver object
                    sizeof(DEVICE_EXTENSION),       // extension size for us
                    NULL,                           // name for this device
                    FILE_DEVICE_UNKNOWN,
                    FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                    FALSE,                          // Not exclusive
                    &deviceObject);                 // Our device object

    if(!NT_SUCCESS(ntStatus)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //                
        IsoUsb_DbgPrint(1, ("Failed to create device object\n"));
        return ntStatus;
    }

    //
    // Initialize the device extension
    //
    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
    deviceExtension->FunctionalDeviceObject = deviceObject;
    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    deviceObject->Flags |= DO_DIRECT_IO;

    //
    // initialize the device state lock and set the device state
    //
    KeInitializeSpinLock(&deviceExtension->DevStateLock);
    INITIALIZE_PNP_STATE(deviceExtension);

    //
    //initialize OpenHandleCount
    //
    deviceExtension->OpenHandleCount = 0;

    //
    // Initialize the selective suspend variables
    //
    KeInitializeSpinLock(&deviceExtension->IdleReqStateLock);
    deviceExtension->IdleReqPend = 0;
    deviceExtension->PendingIdleIrp = NULL;

    //
    // Hold requests until the device is started
    //
    deviceExtension->QueueState = HoldRequests;

    //
    // Initialize the queue and the queue spin lock
    //
    InitializeListHead(&deviceExtension->NewRequestsQueue);
    KeInitializeSpinLock(&deviceExtension->QueueLock);

    //
    // Initialize the remove event to not-signaled.
    //

    KeInitializeEvent(&deviceExtension->RemoveEvent, 
                      SynchronizationEvent, 
                      FALSE);

    //
    // Initialize the stop event to signaled.
    // This event is signaled when the OutstandingIO becomes 1
    //

    KeInitializeEvent(&deviceExtension->StopEvent, 
                      SynchronizationEvent, 
                      TRUE);

    //
    // OutstandingIo count biased to 1.
    // Transition to 0 during remove device means IO is finished.
    // Transition to 1 means the device can be stopped
    //

    deviceExtension->OutStandingIO = 1;
    KeInitializeSpinLock(&deviceExtension->IOCountLock);

    //
    // Delegating to WMILIB
    //
    ntStatus = IsoUsb_WmiRegistration(deviceExtension);

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(1, ("IsoUsb_WmiRegistration failed with %X\n", ntStatus));
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    //
    // set the flags as underlying PDO
    //

    if(PhysicalDeviceObject->Flags & DO_POWER_PAGABLE) {

        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    //
    // Typically, the function driver for a device is its 
    // power policy owner, although for some devices another 
    // driver or system component may assume this role. 
    // Set the initial power state of the device, if known, by calling 
    // PoSetPowerState.
    // 

    deviceExtension->DevPower = PowerDeviceD0;
    deviceExtension->SysPower = PowerSystemWorking;

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState(deviceObject, DevicePowerState, state);

    //
    // attach our driver to device stack
    // The return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    deviceExtension->TopOfStackDeviceObject = 
                IoAttachDeviceToDeviceStack(deviceObject,
                                            PhysicalDeviceObject);

    if(NULL == deviceExtension->TopOfStackDeviceObject) {

        IsoUsb_WmiDeRegistration(deviceExtension);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }
        
    //
    // Register device interfaces
    //

    ntStatus = IoRegisterDeviceInterface(deviceExtension->PhysicalDeviceObject, 
                                         &GUID_CLASS_I82930_ISO, 
                                         NULL, 
                                         &deviceExtension->InterfaceName);

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_WmiDeRegistration(deviceExtension);
        IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    if(IoIsWdmVersionAvailable(1, 0x20)) {

        deviceExtension->WdmVersion = WinXpOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x10)) {

        deviceExtension->WdmVersion = Win2kOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x5)) {

        deviceExtension->WdmVersion = WinMeOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x0)) {

        deviceExtension->WdmVersion = Win98OrBetter;
    }

    deviceExtension->SSRegistryEnable = 0;
    deviceExtension->SSEnable = 0;

    //
    // Win XP only
    // check the registry flag -
    // whether the device should selectively
    // suspend when idle
    //

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        IsoUsb_GetRegistryDword(ISOUSB_REGISTRY_PARAMETERS_PATH,
                                 L"IsoUsbEnable",
                                 &deviceExtension->SSRegistryEnable);

        if(deviceExtension->SSRegistryEnable) {

            //
            // initialize DPC
            //
            KeInitializeDpc(&deviceExtension->DeferredProcCall, 
                            DpcRoutine, 
                            deviceObject);

            //
            // initialize timer
            // the DPC and the timer in conjunction, 
            // monitor the state of the device to 
            // selectively suspend the device.
            //
            KeInitializeTimerEx(&deviceExtension->Timer,
                                NotificationTimer);

            //
            // Initialize the NoDpcWorkItemPendingEvent to signaled state.
            // This event is cleared when a Dpc is fired and signaled
            // on completion of the work-item.
            //
            KeInitializeEvent(&deviceExtension->NoDpcWorkItemPendingEvent, 
                              NotificationEvent, 
                              TRUE);

            //
            // Initialize the NoIdleReqPendEvent to ensure that the idle request
            // is indeed complete before we unload the drivers.
            //
            KeInitializeEvent(&deviceExtension->NoIdleReqPendEvent,
                              NotificationEvent,
                              TRUE);
        }
    }

    //
    // Clear the DO_DEVICE_INITIALIZING flag.
    // Note: Do not clear this flag until the driver has set the
    // device power state and the power DO flags. 
    //
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    IsoUsb_DbgPrint(3, ("IsoUsb_AddDevice - ends\n"));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\makefile.inc ===
mofcomp: isousb.bmf

isousb.bmf: isousb.mof
        mofcomp -B:isousb.bmf isousb.mof
        wmimofck isousb.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isousr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isousr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_USER_H
#define _ISOUSB_USER_H

#include <initguid.h>

// {6068EB61-98E7-4c98-9E20-1F068295909A}
DEFINE_GUID(GUID_CLASS_I82930_ISO, 
0xa1155b78, 0xa32c, 0x11d1, 0x9a, 0xed, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x8);


#define ISOUSB_IOCTL_INDEX              0x0000


#define IOCTL_ISOUSB_GET_CONFIG_DESCRIPTOR  CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     ISOUSB_IOCTL_INDEX,      \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)
                                                   
#define IOCTL_ISOUSB_RESET_DEVICE           CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     ISOUSB_IOCTL_INDEX + 1,  \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)

#define IOCTL_ISOUSB_RESET_PIPE             CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     ISOUSB_IOCTL_INDEX + 2,  \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)

#define IOCTL_ISOUSB_STOP_ISO_STREAM        CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     ISOUSB_IOCTL_INDEX + 3,  \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)

#define IOCTL_ISOUSB_START_ISO_STREAM       CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     ISOUSB_IOCTL_INDEX + 4,  \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\selsusp\sys\selsusp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    selSusp.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include <initguid.h>
#include <wdm.h>
#include <wmilib.h>
#include <wmistr.h>
#include "usbdi.h"
#include "usbdlib.h"

#ifndef _SUSPEND_LOCAL_H
#define _SUSPEND_LOCAL_H

#define SSTAG (ULONG) 'SleS'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
    ExAllocatePoolWithTag(type, size, SSTAG);

#if DBG

#define SSDbgPrint(level, _x_) \
            if((level) <= DebugLevel) { \
                DbgPrint _x_; \
            }
#else

#define SSDbgPrint(level, _x_)

#endif

typedef struct _GLOBALS {

    UNICODE_STRING SSRegistryPath;

} GLOBALS;

#define IDLE_INTERVAL 5000

typedef enum _DEVSTATE {

    NotStarted,         // not started
    Stopped,            // device stopped
    Working,            // started and working
    PendingStop,        // stop pending
    PendingRemove,      // remove pending
    SurpriseRemoved,    // removed by surprise
    Removed             // removed

} DEVSTATE;

typedef enum _QUEUE_STATE {

    HoldRequests,       // device is not started yet
    AllowRequests,      // device is ready to process
    FailRequests        // fail both existing and queued up requests

} QUEUE_STATE;

typedef enum _WDM_VERSION {

    WinXpOrBetter,
    Win2kOrBetter,
    WinMeOrBetter,
    Win98OrBetter

} WDM_VERSION;

#define INITIALIZE_PNP_STATE(_Data_)    \
        (_Data_)->DeviceState =  NotStarted;\
        (_Data_)->PrevDevState = NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_) \
        (_Data_)->PrevDevState =  (_Data_)->DeviceState;\
        (_Data_)->DeviceState = (_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)   \
        (_Data_)->DeviceState =   (_Data_)->PrevDevState;

//
// registry path used for parameters 
// global to all instances of the driver
//

#define SELSUSP_REGISTRY_PARAMETERS_PATH  \
	L"\\REGISTRY\\Machine\\System\\CurrentControlSet\\SERVICES\\SELSUSP\\Parameters"

//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _DEVICE_EXTENSION {

    // Functional Device Object
    PDEVICE_OBJECT FunctionalDeviceObject;

    // Device object we call when submitting Urbs
    PDEVICE_OBJECT TopOfStackDeviceObject;

    // The bus driver object
    PDEVICE_OBJECT PhysicalDeviceObject;

    // Name buffer for our named Functional device object link
    // The name is generated based on the driver's class GUID
    UNICODE_STRING InterfaceName;

    //Bus drivers set the appropriate values in this structure in response
    //to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
    //alter the capabilities set by the bus driver.
    DEVICE_CAPABILITIES DeviceCapabilities;

    // current state of device
    DEVSTATE DeviceState;

    // state prior to removal query
    DEVSTATE PrevDevState;

    // obtain and hold this lock while changing the device state,
    // the queue state and while processing the queue.
    KSPIN_LOCK DevStateLock;

    // current system power state
    SYSTEM_POWER_STATE SysPower;

    // current device power state
    DEVICE_POWER_STATE DevPower;

    // Pending I/O queue state
    QUEUE_STATE QueueState;

    // Pending I/O queue
    LIST_ENTRY NewRequestsQueue;

    // I/O Queue Lock
    KSPIN_LOCK QueueLock;

    KEVENT RemoveEvent;

    KEVENT StopEvent;
    
    ULONG OutStandingIO;

    KSPIN_LOCK IOCountLock;

    // selective suspend variables

    LONG SSEnable;

    LONG SSRegistryEnable;

    PUSB_IDLE_CALLBACK_INFO IdleCallbackInfo;
	
    PIRP PendingIdleIrp;
	
    LONG IdleReqPend;

    LONG FreeIdleIrpCount;

    KSPIN_LOCK IdleReqStateLock;

    KEVENT NoIdleReqPendEvent;

    // default power state to power down to on self-susped
    ULONG PowerDownLevel;
    
    // remote wakeup variables
    PIRP WaitWakeIrp;

    LONG FlagWWCancel;

    LONG FlagWWOutstanding;

    LONG WaitWakeEnable;

    // open handle count
    LONG OpenHandleCount;

    // selective suspend model uses timers, dpcs and work item.
    KTIMER Timer;

    KDPC DeferredProcCall;

    // This event is cleared when a DPC/Work Item is queued.
    // and signaled when the work-item completes.
    // This is essential to prevent the driver from unloading
    // while we have DPC or work-item queued up.
    KEVENT NoDpcWorkItemPendingEvent;

    // WMI information
    WMILIB_CONTEXT WmiLibInfo;

    // WDM version
    WDM_VERSION WdmVersion;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _IRP_COMPLETION_CONTEXT {

    PDEVICE_EXTENSION DeviceExtension;

    PKEVENT Event;

} IRP_COMPLETION_CONTEXT, *PIRP_COMPLETION_CONTEXT;

extern GLOBALS Globals;
extern ULONG DebugLevel;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isowmi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isowmi.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_WMI_H
#define _ISOUSB_WMI_H

NTSTATUS
IsoUsb_WmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IsoUsb_WmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IsoUsb_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
IsoUsb_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo	    
    );

NTSTATUS
IsoUsb_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
IsoUsb_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
IsoUsb_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    );

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\isousb\sys\isowmi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    isowmi.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isowmi.h"
#include "isousr.h"
#include "isorwr.h"
#include "isostrm.h"

#define MOFRESOURCENAME L"MofResourceName"

#define WMI_ISOUSB_DRIVER_INFORMATION 0

DEFINE_GUID (ISOUSB_WMI_STD_DATA_GUID, 
0xBBA21300, 0x6DD3, 0x11d2, 0xB8, 0x44, 0x00, 0xC0, 0x4F, 0xAD, 0x51, 0x71);

WMIGUIDREGINFO IsoWmiGuidList[1] = { {

        &ISOUSB_WMI_STD_DATA_GUID, 1, 0 // driver information
    }
};

NTSTATUS
IsoUsb_WmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Registers with WMI as a data provider for this
    instance of the device

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    
    PAGED_CODE();

    DeviceExtension->WmiLibInfo.GuidCount = 
          sizeof (IsoWmiGuidList) / sizeof (WMIGUIDREGINFO);

    DeviceExtension->WmiLibInfo.GuidList           = IsoWmiGuidList;
    DeviceExtension->WmiLibInfo.QueryWmiRegInfo    = IsoUsb_QueryWmiRegInfo;
    DeviceExtension->WmiLibInfo.QueryWmiDataBlock  = IsoUsb_QueryWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataBlock    = IsoUsb_SetWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataItem     = IsoUsb_SetWmiDataItem;
    DeviceExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DeviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //
    
    ntStatus = IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                        WMIREG_ACTION_REGISTER);

    return ntStatus;
    
}

NTSTATUS
IsoUsb_WmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

     Inform WMI to remove this DeviceObject from its 
     list of providers. This function also 
     decrements the reference count of the deviceobject.

Arguments:

Return Value:

--*/
{

    PAGED_CODE();

    return IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                    WMIREG_ACTION_DEREGISTER);

}

NTSTATUS
IsoUsb_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION  disposition;
    NTSTATUS                ntStatus;
    PIO_STACK_LOCATION      irpStack;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, (WMIMinorFunctionString(irpStack->MinorFunction)));

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchSysCtrl::"));
    IsoUsb_IoIncrement(deviceExtension);

    ntStatus = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                DeviceObject, 
                                Irp,
                                &disposition);

    switch(disposition) {

        case IrpProcessed: 
        {
            //
            // This irp has been processed and may be completed or pending.
            //

            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            //

            IoCompleteRequest(Irp, IO_NO_INCREMENT);                

            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targeted
            // at a device lower in the stack.
            //

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                    Irp);

            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            //

            ASSERT(FALSE);

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                  Irp);
            break;
        }        
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchSysCtrl::"));
    IsoUsb_IoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
IsoUsb_QueryWmiRegInfo(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT ULONG           *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo	    
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    IsoUsb_DbgPrint(3, ("IsoUsb_QueryWmiRegInfo - begins\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    *RegFlags     = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.IsoUsb_RegistryPath;
    *Pdo          = deviceExtension->PhysicalDeviceObject;
    RtlInitUnicodeString(MofResourceName, MOFRESOURCENAME);

    IsoUsb_DbgPrint(3, ("IsoUsb_QueryWmiRegInfo - ends\n"));
    
    return STATUS_SUCCESS;
}

NTSTATUS
IsoUsb_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instances expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.        
            
    OutBufferSize has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             size;
    WCHAR             modelName[] = L"Aishverya\0\0";
    USHORT            modelNameLen;

    PAGED_CODE();

    IsoUsb_DbgPrint(3, ("IsoUsb_QueryWmiDataBlock - begins\n"));

    size = 0;
    modelNameLen = (wcslen(modelName) + 1) * sizeof(WCHAR);

    //
    // Only ever registers 1 instance per guid
    //

    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_ISOUSB_DRIVER_INFORMATION:

        size = sizeof(ULONG) + modelNameLen + sizeof(USHORT);

        if (OutBufferSize < size ) {

            IsoUsb_DbgPrint(3, ("OutBuffer too small\n"));

            ntStatus = STATUS_INVALID_BUFFER_SIZE;

            break;
        }

        * (PULONG) Buffer = DebugLevel;

        Buffer += sizeof(ULONG);

        //
        // put length of string ahead of string
        //

        *((PUSHORT)Buffer) = modelNameLen;

        Buffer = (PUCHAR)Buffer + sizeof(USHORT);

        RtlCopyBytes((PVOID)Buffer, (PVOID)modelName, modelNameLen);

        *InstanceLengthArray = size ;

        ntStatus = STATUS_SUCCESS;

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                size,
                                IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_QueryWmiDataBlock - ends\n"));

    return ntStatus;
}


NTSTATUS
IsoUsb_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;
    
    PAGED_CODE();

    IsoUsb_DbgPrint(3, ("IsoUsb_SetWmiDataItem - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    switch(GuidIndex) {
    
    case WMI_ISOUSB_DRIVER_INFORMATION:

        if(DataItemId == 1) {

            if(BufferSize == sizeof(ULONG)) {

                DebugLevel = *((PULONG)Buffer);

                ntStatus = STATUS_SUCCESS;

                info = sizeof(ULONG);
            }
            else {

                ntStatus = STATUS_INFO_LENGTH_MISMATCH;
            }
        }
        else {

            ntStatus = STATUS_WMI_READ_ONLY;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_SetWmiDataItem - ends\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    IsoUsb_DbgPrint(3, ("IsoUsb_SetWmiDataBlock - begins\n"));

    switch(GuidIndex) {
    
    case WMI_ISOUSB_DRIVER_INFORMATION:

        if(BufferSize == sizeof(ULONG)) {

            DebugLevel = *(PULONG) Buffer;
                    
            ntStatus = STATUS_SUCCESS;

            info = sizeof(ULONG);
        }
        else {

            ntStatus = STATUS_INFO_LENGTH_MISMATCH;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_SetWmiDataBlock - ends\n"));

    return ntStatus;
}

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
            return "IRP_MN_CHANGE_SINGLE_INSTANCE\n";

        case IRP_MN_CHANGE_SINGLE_ITEM:
            return "IRP_MN_CHANGE_SINGLE_ITEM\n";

        case IRP_MN_DISABLE_COLLECTION:
            return "IRP_MN_DISABLE_COLLECTION\n";

        case IRP_MN_DISABLE_EVENTS:
            return "IRP_MN_DISABLE_EVENTS\n";

        case IRP_MN_ENABLE_COLLECTION:
            return "IRP_MN_ENABLE_COLLECTION\n";

        case IRP_MN_ENABLE_EVENTS:
            return "IRP_MN_ENABLE_EVENTS\n";

        case IRP_MN_EXECUTE_METHOD:
            return "IRP_MN_EXECUTE_METHOD\n";

        case IRP_MN_QUERY_ALL_DATA:
            return "IRP_MN_QUERY_ALL_DATA\n";

        case IRP_MN_QUERY_SINGLE_INSTANCE:
            return "IRP_MN_QUERY_SINGLE_INSTANCE\n";

        case IRP_MN_REGINFO:
            return "IRP_MN_REGINFO\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\selsusp\sys\sspwr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSPwr.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __POWER_H
#define __POWER_H

typedef struct _POWER_COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           SIrp;
} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;

typedef struct _WORKER_THREAD_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           Irp;
    PIO_WORKITEM   WorkItem;
} WORKER_THREAD_CONTEXT, *PWORKER_THREAD_CONTEXT;

NTSTATUS
SS_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    );

NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject, 
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP                  Irp
    );

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\selsusp\sys\ssdevctr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSDevCtr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __DEV_CTRL_H
#define __DEV_CTRL_H

NTSTATUS
SS_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SS_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SS_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\selsusp\sys\ssusr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSUsr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _SEL_SUSPEND_USER_H
#define _SEL_SUSPEND_USER_H

// {6068EB61-98E7-4c98-9E20-1F068295909A}
DEFINE_GUID(GUID_GENERIC_SELECTIVE_SUSPEND, 
0x6068eb61, 0x98e7, 0x4c98, 0x9e, 0x20, 0x1f, 0x6, 0x82, 0x95, 0x90, 0x9a);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\selsusp\sys\ssdevctr.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSDevCtr.c

Abstract:

    This file contains dispatch routines 
    for create and close. This file also 
    contains routines to selectively suspend 
    the device. The selective suspend feature
    is usb specific and not hardware specific.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSDevCtr.h"
#include "sSUsr.h"
#include "sSWmi.h"

NTSTATUS
SS_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for create.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet.

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    SSDbgPrint(3, ("SS_DispatchCreate - begins\n"));
    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // set ntStatus to STATUS_SUCCESS 
    //
    ntStatus = STATUS_SUCCESS;

    //
    // increment OpenHandleCounts
    //
    InterlockedIncrement(&deviceExtension->OpenHandleCount);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // the device is idle if it has no open handles or pending PnP Irps
    // since this is create request, cancel idle req. if any
    //
    if(deviceExtension->SSEnable) {
    
        CancelSelectSuspend(deviceExtension);
    }

    SSDbgPrint(3, ("SS_DispatchCreate - ends\n"));
    
    return ntStatus;
}

NTSTATUS
SS_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for close.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    SSDbgPrint(3, ("SS_DispatchClose - begins\n"));
    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // set ntStatus to STATUS_SUCCESS 
    //
    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    InterlockedDecrement(&deviceExtension->OpenHandleCount);

    SSDbgPrint(3, ("SS_DispatchClose - ends\n"));

    return ntStatus;
}

NTSTATUS
SS_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    Dispatch routine for IRP_MJ_DEVICE_CONTROL

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    ULONG              code;
    PVOID              ioBuffer;
    ULONG              inputBufferLength;
    ULONG              outputBufferLength;
    ULONG              info;
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    code = irpStack->Parameters.DeviceIoControl.IoControlCode;
    info = 0;

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
	
    SSDbgPrint(3, ("SS_DispatchDevCtrl::"));
    SSIoIncrement(deviceExtension);

    switch(code) {

    default :

        ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        break;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = info;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("SS_DispatchDevCtrl::"));
    SSIoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine builds an idle request irp with an associated callback routine
    and a completion routine in the driver and passes the irp down the stack.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    PIRP                    irp;
    NTSTATUS                ntStatus;
    KIRQL                   oldIrql;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    PIO_STACK_LOCATION      nextStack;

    //
    // initialize variables
    //
    
    irp = NULL;
    idleCallbackInfo = NULL;

    SSDbgPrint(3, ("SubmitIdleRequestIrp - begins\n"));

    //
    // if the device is not in a D0 power state,
    // budge out..
    //
    if(PowerDeviceD0 != DeviceExtension->DevPower) {

        ntStatus = STATUS_POWER_STATE_INVALID;

        goto SubmitIdleRequestIrp_Exit;
    }

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(InterlockedExchange(&DeviceExtension->IdleReqPend, 1)) {

        SSDbgPrint(1, ("Idle request pending..\n"));

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_DEVICE_BUSY;

        goto SubmitIdleRequestIrp_Exit;
    }

    //
    // clear the NoIdleReqPendEvent because we are about 
    // to submit an idle request. Since we are so early
    // to clear this event, make sure that if we fail this
    // request we set back the event.
    //
    KeClearEvent(&DeviceExtension->NoIdleReqPendEvent);

    idleCallbackInfo = ExAllocatePool(NonPagedPool, 
                                      sizeof(struct _USB_IDLE_CALLBACK_INFO));

    if(idleCallbackInfo) {

        idleCallbackInfo->IdleCallback = IdleNotificationCallback;

        idleCallbackInfo->IdleContext = (PVOID)DeviceExtension;

        ASSERT(DeviceExtension->IdleCallbackInfo == NULL);

        DeviceExtension->IdleCallbackInfo = idleCallbackInfo;

        //
        // we use IoAllocateIrp to create an irp to selectively suspend the 
        // device. This irp lies pending with the hub driver. When appropriate
        // the hub driver will invoked callback, where we power down. The completion
        // routine is invoked when we power back.
        //
        irp = IoAllocateIrp(DeviceExtension->TopOfStackDeviceObject->StackSize,
                            FALSE);

        if(irp == NULL) {

            SSDbgPrint(1, ("cannot build idle request irp\n"));

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            ExFreePool(idleCallbackInfo);

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto SubmitIdleRequestIrp_Exit;
        }

        nextStack = IoGetNextIrpStackLocation(irp);

        nextStack->MajorFunction = 
                    IRP_MJ_INTERNAL_DEVICE_CONTROL;

        nextStack->Parameters.DeviceIoControl.IoControlCode = 
                    IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;

        nextStack->Parameters.DeviceIoControl.Type3InputBuffer =
                    idleCallbackInfo;

        nextStack->Parameters.DeviceIoControl.InputBufferLength =
                    sizeof(struct _USB_IDLE_CALLBACK_INFO);


        IoSetCompletionRoutine(irp, 
                               IdleNotificationRequestComplete,
                               DeviceExtension, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        DeviceExtension->PendingIdleIrp = irp;

        //
        // we initialize the count to 2.
        // The reason is, if the CancelSelectSuspend routine manages
        // to grab the irp from the device extension, then the last of the
        // CancelSelectSuspend routine/IdleNotificationRequestComplete routine 
        // to execute will free this irp. We need to have this schema so that
        // 1. completion routine does not attempt to touch the irp freed by 
        //    CancelSelectSuspend routine.
        // 2. CancelSelectSuspend routine doesnt wait for ever for the completion
        //    routine to complete!
        //
        DeviceExtension->FreeIdleIrpCount = 2;

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        //
        // check if the device is idle.
        // A check here ensures that a race condition did not 
        // completely reverse the call sequence of SubmitIdleRequestIrp
        // and CancelSelectiveSuspend
        //

        if(!CanDeviceSuspend(DeviceExtension) ||
           PowerDeviceD0 != DeviceExtension->DevPower) {

            //
            // device cannot suspend - abort.
            // also irps created using IoAllocateIrp 
            // needs to be deallocated.
            //
     
            SSDbgPrint(1, ("Device cannot selectively suspend - abort\n"));

            KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

            DeviceExtension->IdleCallbackInfo = NULL;

            DeviceExtension->PendingIdleIrp = NULL;

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            if(idleCallbackInfo) {

                ExFreePool(idleCallbackInfo);
            }

            //
            // it is still safe to touch the local variable "irp" here.
            // the irp has not been passed down the stack, the irp has
            // no cancellation routine. The worse position is that the
            // CancelSelectSuspend has run after we released the spin 
            // lock above. It is still essential to free the irp.
            //
            if(irp) {

                IoFreeIrp(irp);
            }

            ntStatus = STATUS_UNSUCCESSFUL;
            goto SubmitIdleRequestIrp_Exit;
        }

        SSDbgPrint(3, ("Cancelling the timer...\n"));

        //
        // Cancel the timer so that the DPCs are no longer fired.
        // Thus, we are making judicious usage of our resources.
        // we do not need DPCs because we already have an idle irp pending.
        // The timers are re-initialized in the completion routine.
        //
        KeCancelTimer(&DeviceExtension->Timer);

        SSDbgPrint(3, ("Submit an idle request at power state PowerDeviceD%X\n",
                       DeviceExtension->DevPower - 1))

        ntStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject, irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("IoCallDriver failed\n"));

            goto SubmitIdleRequestIrp_Exit;
        }
    }
    else {

        SSDbgPrint(1, ("Memory allocation for idleCallbackInfo failed\n"));

        KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                   IO_NO_INCREMENT,
                   FALSE);

        InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

SubmitIdleRequestIrp_Exit:

    SSDbgPrint(3, ("SubmitIdleRequestIrp - ends\n"));

    return ntStatus;
}


VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  "A pointer to a callback function in your driver is passed down the stack with
   this IOCTL, and it is this callback function that is called by USBHUB when it
   safe for your device to power down."

  "When the callback in your driver is called, all you really need to do is to
   to first ensure that a WaitWake Irp has been submitted for your device, if 
   remote wake is possible for your device and then request a SetD2 (or DeviceWake)"

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KEVENT                  irpCompletionEvent;
    PIRP_COMPLETION_CONTEXT irpContext;

    SSDbgPrint(3, ("IdleNotificationCallback - begins\n"));

    //
    // Dont idle, if the device was just disconnected or being stopped
    // i.e. return for the following DeviceState(s)
    // NotStarted, Stopped, PendingStop, PendingRemove, SurpriseRemoved, Removed
    //

    if(DeviceExtension->DeviceState != Working) {

        return;
    }

    //
    // If there is not already a WW IRP pending, submit one now
    //
    if(DeviceExtension->WaitWakeEnable) {

        IssueWaitWake(DeviceExtension);
    }


    //
    // power down the device
    //

    irpContext = (PIRP_COMPLETION_CONTEXT) 
                 ExAllocatePool(NonPagedPool,
                                sizeof(IRP_COMPLETION_CONTEXT));

    if(!irpContext) {

        SSDbgPrint(1, ("Failed to alloc memory for irpContext\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        //
        // increment the count. In the HoldIoRequestWorkerRoutine, the
        // count is decremented twice (one for the system Irp and the 
        // other for the device Irp. An increment here compensates for 
        // the sytem irp..The decrement corresponding to this increment 
        // is in the completion function
        //

        SSDbgPrint(3, ("IdleNotificationCallback::"));
        SSIoIncrement(DeviceExtension);

        powerState.DeviceState = DeviceExtension->PowerDownLevel;

        KeInitializeEvent(&irpCompletionEvent, NotificationEvent, FALSE);

        irpContext->DeviceExtension = DeviceExtension;
        irpContext->Event = &irpCompletionEvent;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpCompletionFunc,
                          irpContext, 
                          NULL);

        //
        // if PoRequestPowerIrp returns a failure, we will release memory below
        //

        if(STATUS_PENDING == ntStatus) {

            SSDbgPrint(3, ("IdleNotificationCallback::"
                           "waiting for the power irp to complete\n"));

            KeWaitForSingleObject(&irpCompletionEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
    }

    if(!NT_SUCCESS(ntStatus)) {

        if(irpContext) {

            ExFreePool(irpContext);
        }
    }

    SSDbgPrint(3, ("IdleNotificationCallback - ends\n"));
}


NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KIRQL                   oldIrql;
    PIRP                    idleIrp;
    LARGE_INTEGER           dueTime;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;

    SSDbgPrint(3, ("IdleNotificationRequestCompete - begins\n"));

    idleIrp = NULL;

    //
    // check the Irp status
    //
    ntStatus = Irp->IoStatus.Status;

    if(!NT_SUCCESS(ntStatus) && ntStatus != STATUS_NOT_SUPPORTED) {

        SSDbgPrint(1, ("Idle irp completes with error::"));

        switch(ntStatus) {
            
        case STATUS_INVALID_DEVICE_REQUEST:

            SSDbgPrint(1, ("STATUS_INVALID_DEVICE_REQUEST\n"));

            break;

        case STATUS_CANCELLED:

            SSDbgPrint(1, ("STATUS_CANCELLED\n"));

            break;

        case STATUS_POWER_STATE_INVALID:

            SSDbgPrint(1, ("STATUS_POWER_STATE_INVALID\n"));

            goto IdleNotificationRequestComplete_Exit;

        case STATUS_DEVICE_BUSY:

            SSDbgPrint(1, ("STATUS_DEVICE_BUSY\n"));

            break;

        default:

            SSDbgPrint(1, ("default: %X\n", ntStatus));

            break;
        }

        //
        // if the irp completes in error, request for a SetD0 only if not in D0
        //

        if(PowerDeviceD0 != DeviceExtension->DevPower) {
            SSDbgPrint(3, ("IdleNotificationRequestComplete::"));
            SSIoIncrement(DeviceExtension);

            powerState.DeviceState = PowerDeviceD0;

            ntStatus = PoRequestPowerIrp(
                              DeviceExtension->PhysicalDeviceObject, 
                              IRP_MN_SET_POWER, 
                              powerState, 
                              (PREQUEST_POWER_COMPLETE) PoIrpAsyncCompletionFunc, 
                              DeviceExtension, 
                              NULL);

            if(!NT_SUCCESS(ntStatus)) {
        
                SSDbgPrint(1, ("PoRequestPowerIrp failed\n"));
            }
        }
    }

IdleNotificationRequestComplete_Exit:

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    idleCallbackInfo = DeviceExtension->IdleCallbackInfo;

    DeviceExtension->IdleCallbackInfo = NULL;

    idleIrp = (PIRP) InterlockedExchangePointer(
                                         &DeviceExtension->PendingIdleIrp,
                                         NULL);

    InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    if(idleCallbackInfo) {

        ExFreePool(idleCallbackInfo);
    }

    //
    // since the irp was created using IoAllocateIrp, 
    // the Irp needs to be freed using IoFreeIrp.
    // Also return STATUS_MORE_PROCESSING_REQUIRED so that 
    // the kernel does not reference this in the near future.
    //

    if(idleIrp) {
        
        SSDbgPrint(3, ("the completion routine has a valid pointer to idleIrp - "
                       "free the irp\n"));

        IoFreeIrp(Irp);

        KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
    else {

        //
        // The CancelSelectiveSuspend routine has grabbed the Irp from the device 
        // extension. Now the last one to decrement the FreeIdleIrpCount should
        // free the irp.
        //
        if(0 == InterlockedDecrement(&DeviceExtension->FreeIdleIrpCount)) {

            SSDbgPrint(3, ("FreeIdleIrpCount is 0 - "
                           "free the irp\n"));
            IoFreeIrp(Irp);

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }

    if(DeviceExtension->SSEnable) {

        SSDbgPrint(3, ("Set the timer to fire DPCs\n"));

        dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

        SSDbgPrint(3, ("Setting the timer...\n"));
        KeSetTimerEx(&DeviceExtension->Timer, 
                     dueTime,
                     IDLE_INTERVAL,                              // 5000 ms
                     &DeviceExtension->DeferredProcCall);

        SSDbgPrint(3, ("IdleNotificationRequestCompete - ends\n"));
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine is invoked to cancel selective suspend request.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    None.

--*/
{
    PIRP  irp;
    KIRQL oldIrql;

    irp = NULL;

    SSDbgPrint(3, ("CancelSelectSuspend - begins\n"));

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(!CanDeviceSuspend(DeviceExtension))
    {
        SSDbgPrint(3, ("Device is not idle\n"));
    
        irp = (PIRP) InterlockedExchangePointer(
                            &DeviceExtension->PendingIdleIrp, 
                            NULL);
    }

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    //
    // since we have a valid Irp ptr,
    // we can call IoCancelIrp on it,
    // without the fear of the irp 
    // being freed underneath us.
    //

    if(irp) {

        //
        // This routine has the irp pointer.
        // It is safe to call IoCancelIrp because we know that
        // the compleiton routine will not free this irp unless...
        // 
        //
        if(IoCancelIrp(irp)) {

            SSDbgPrint(3, ("IoCancelIrp returns TRUE\n"));
        }
        else {
            SSDbgPrint(3, ("IoCancelIrp returns FALSE\n"));
        }

        //
        // ....we decrement the FreeIdleIrpCount from 2 to 1.
        // if completion routine runs ahead of us, then this routine 
        // decrements the FreeIdleIrpCount from 1 to 0 and hence shall
        // free the irp.
        //
        if(0 == InterlockedDecrement(&DeviceExtension->FreeIdleIrpCount)) {

            SSDbgPrint(3, ("FreeIdleIrpCount is 0 - "
                           "free the irp\n"));
            IoFreeIrp(irp);

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }

    SSDbgPrint(3, ("CancelSelectSuspend - ends\n"));

    return;
}

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for power irp PoRequested in 
    IdleNotificationCallback.

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.

Return Value:

    None

--*/
{
    PIRP_COMPLETION_CONTEXT irpContext;
    
    //
    // initialize variables
    //
    irpContext = NULL;

    if(Context) {

        irpContext = (PIRP_COMPLETION_CONTEXT) Context;
    }

    //
    // all we do is set the event and decrement the count
    //

    if(irpContext) {

        KeSetEvent(irpContext->Event, 0, FALSE);

        SSDbgPrint(3, ("PoIrpCompletionFunc::"));
        SSIoDecrement(irpContext->DeviceExtension);

        ExFreePool(irpContext);
    }

    return;
}

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for power irp PoRequested in IdleNotification
    RequestComplete routine.

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    SSDbgPrint(3, ("PoIrpAsyncCompletionFunc::"));
    SSIoDecrement(DeviceExtension);

    return;
}

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for PoRequest wait wake irp

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.    

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    SSDbgPrint(3, ("WWIrpCompletionFunc::"));
    SSIoDecrement(DeviceExtension);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\selsusp\sys\selsusp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    selSusp.c

Abstract:

    This module contains code for a generic client driver that can be loaded 
    for all USB devices/child interfaces.

Author:

Environment:

    kernel mode only

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSUsr.h"
#include "sSDevCtr.h"
#include "sSWmi.h"

//
// Globals
//

GLOBALS Globals;
ULONG   DebugLevel = 1;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    );

VOID
SS_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SS_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SS_DriverUnload)
#pragma alloc_text(PAGE, SS_DispatchCreate)
#pragma alloc_text(PAGE, SS_DispatchClose)
#endif
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    )
/*++ 

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.    

Arguments:
    
    DriverObject - pointer to driver object 

    RegistryPath - pointer to a unicode string representing the path to driver 
                   specific key in the registry.

Return Values:

    NT status code
    
--*/
{

    NTSTATUS        ntStatus;
    PUNICODE_STRING registryPath;
    
    //
    // initialization of variables
    //

    registryPath = &Globals.SSRegistryPath;

    //
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //

    registryPath->MaximumLength = UniRegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length        = UniRegistryPath->Length;
    registryPath->Buffer        = ExAllocatePool(PagedPool,
                                                 registryPath->MaximumLength);

    if (!registryPath->Buffer) {

        SSDbgPrint(1, ("Failed to allocate memory for registryPath\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntry_Exit;
    } 


    RtlZeroMemory (registryPath->Buffer, 
                   registryPath->MaximumLength);
    RtlMoveMemory (registryPath->Buffer, 
                   UniRegistryPath->Buffer, 
                   UniRegistryPath->Length);

    ntStatus = STATUS_SUCCESS;

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SS_DispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = SS_DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = SS_DispatchPnP;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = SS_DispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = SS_DispatchClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = SS_DispatchClean;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SS_DispatchSysCtrl;
    DriverObject->DriverUnload                         = SS_DriverUnload;
    DriverObject->DriverExtension->AddDevice           = (PDRIVER_ADD_DEVICE)
                                                         SS_AddDevice;
DriverEntry_Exit:

    return ntStatus;
}

VOID
SS_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Description:

    This function will free the memory allocations in DriverEntry.

Arguments:

    DriverObject - pointer to driver object 

Return:
	
    None

--*/
{
    PUNICODE_STRING registryPath;

    SSDbgPrint(3, ("SS_DriverUnload - begins\n"));

    registryPath = &Globals.SSRegistryPath;

    if(registryPath->Buffer) {

        ExFreePool(registryPath->Buffer);
        registryPath->Buffer = NULL;
    }

    SSDbgPrint(3, ("SS_DriverUnload - ends\n"));

    return;
}

NTSTATUS
SS_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Description:

Arguments:

    DriverObject - Store the pointer to the object representing us.

    PhysicalDeviceObject - Pointer to the device object created by the
                           undelying bus driver.

Return:
	
    STATUS_SUCCESS - if successful 
    STATUS_UNSUCCESSFUL - otherwise

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    POWER_STATE       state;
    KIRQL             oldIrql;

    SSDbgPrint(3, ("SS_AddDevice - begins\n"));

    deviceObject = NULL;

    ntStatus = IoCreateDevice(
                    DriverObject,                   // our driver object
                    sizeof(DEVICE_EXTENSION),       // extension size for us
                    NULL,                           // name for this device
                    FILE_DEVICE_UNKNOWN,
                    FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                    FALSE,                          // Not exclusive
                    &deviceObject);                 // Our device object

    if(!NT_SUCCESS(ntStatus)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //        
        SSDbgPrint(1, ("Failed to create device object\n"));
        return ntStatus;
    }

    //
    // Initialize the device extension
    //

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
    deviceExtension->FunctionalDeviceObject = deviceObject;
    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    deviceObject->Flags |= DO_BUFFERED_IO;

    //
    // initialize the device state lock and set the device state
    //

    KeInitializeSpinLock(&deviceExtension->DevStateLock);
    INITIALIZE_PNP_STATE(deviceExtension);

    //
    //initialize OpenHandleCount
    //
    deviceExtension->OpenHandleCount = 0;

    //
    // Initialize the selective suspend variables
    //
    KeInitializeSpinLock(&deviceExtension->IdleReqStateLock);
    deviceExtension->IdleReqPend = 0;
    deviceExtension->PendingIdleIrp = NULL;

    //
    // Hold requests until the device is started
    //

    deviceExtension->QueueState = HoldRequests;

    //
    // Initialize the queue and the queue spin lock
    //

    InitializeListHead(&deviceExtension->NewRequestsQueue);
    KeInitializeSpinLock(&deviceExtension->QueueLock);

    //
    // Initialize the remove event to not-signaled.
    //

    KeInitializeEvent(&deviceExtension->RemoveEvent, 
                      SynchronizationEvent, 
                      FALSE);

    //
    // Initialize the stop event to signaled.
    // This event is signaled when the OutstandingIO becomes 1
    //

    KeInitializeEvent(&deviceExtension->StopEvent, 
                      SynchronizationEvent, 
                      TRUE);

    //
    // OutstandingIo count biased to 1.
    // Transition to 0 during remove device means IO is finished.
    // Transition to 1 means the device can be stopped
    //

    deviceExtension->OutStandingIO = 1;
    KeInitializeSpinLock(&deviceExtension->IOCountLock);

    //
    // Delegating to WMILIB
    //
    ntStatus = SSWmiRegistration(deviceExtension);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("SSWmiRegistration failed with %X\n", ntStatus));
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    //
    // set the flags as underlying PDO
    //

    if(PhysicalDeviceObject->Flags & DO_POWER_PAGABLE) {

        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    //
    // Typically, the function driver for a device is its 
    // power policy owner, although for some devices another 
    // driver or system component may assume this role. 
    // Set the initial power state of the device, if known, by calling 
    // PoSetPowerState.
    // 
    deviceExtension->DevPower = PowerDeviceD0;
    deviceExtension->SysPower = PowerSystemWorking;

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState(deviceObject, DevicePowerState, state);

    //
    // attach our driver to device stack
    // The return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    deviceExtension->TopOfStackDeviceObject = 
                IoAttachDeviceToDeviceStack(deviceObject,
                                            PhysicalDeviceObject);

    if(NULL == deviceExtension->TopOfStackDeviceObject) {

        SSWmiDeRegistration(deviceExtension);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }
        
    //
    // Register device interfaces
    //

    ntStatus = IoRegisterDeviceInterface(deviceExtension->PhysicalDeviceObject, 
                                         &GUID_GENERIC_SELECTIVE_SUSPEND, 
                                         NULL, 
                                         &deviceExtension->InterfaceName);

    if(!NT_SUCCESS(ntStatus)) {

        SSWmiDeRegistration(deviceExtension);
        IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    if(IoIsWdmVersionAvailable(1, 0x20)) {

        deviceExtension->WdmVersion = WinXpOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x10)) {

        deviceExtension->WdmVersion = Win2kOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x5)) {

        deviceExtension->WdmVersion = WinMeOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x0)) {

        deviceExtension->WdmVersion = Win98OrBetter;
    }

    deviceExtension->SSRegistryEnable = 0;
    deviceExtension->SSEnable = 0;

    //
    // Win XP only
    // check the registry flag -  
    // whether the device should selectively 
    // suspend when idle
    //

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        SS_GetRegistryDword(SELSUSP_REGISTRY_PARAMETERS_PATH,
                            L"SelectSuspendEnable",
                            &deviceExtension->SSRegistryEnable);

        if(deviceExtension->SSRegistryEnable) {
    
            //
            // initialize the DPC 
            //
            KeInitializeDpc(&deviceExtension->DeferredProcCall, 
                            DpcRoutine, 
                            deviceObject);

            //
            // initialize the timer.
            // the DPC and the timer in conjunction, 
            // monitor the state of the device to 
            // selectively suspend the device.
            //
            KeInitializeTimerEx(&deviceExtension->Timer,
                                NotificationTimer);

            //
            // Initialize the NoDpcWorkItemPendingEvent to signaled state.
            // This event is cleared when a Dpc is fired and signaled
            // on completion of the work-item.
            //
            KeInitializeEvent(&deviceExtension->NoDpcWorkItemPendingEvent, 
                              NotificationEvent, 
                              TRUE);

            //  
            // Initialize the NoIdleReqPendEvent to ensure that the idle request
            // is indeed complete before we unload the drivers.
            //
            KeInitializeEvent(&deviceExtension->NoIdleReqPendEvent,
                              NotificationEvent,
                              TRUE);
        }
    }

    //
    // Clear the DO_DEVICE_INITIALIZING flag.
    // Note: Do not clear this flag until the driver has set the
    // device power state and the power DO flags. 
    //
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    SSDbgPrint(3, ("SS_AddDevice - ends\n"));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\selsusp\sys\sspnp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSPnP.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __PNP_H
#define __PNP_H

#define REMOTE_WAKEUP_MASK 0x20

NTSTATUS
SS_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ConfigureDevice(
	IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SelectInterfaces(
	IN PDEVICE_OBJECT                DeviceObject,
	IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    );

VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SS_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
SS_GetRegistryDword(
    IN     PWCHAR RegPath,
    IN     PWCHAR ValueName,
    IN OUT PULONG Value
    );

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReleaseMemory(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG
SSIoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

LONG
SSIoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

PCHAR
PnPMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\selsusp\sys\sspnp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSPnP.c

Abstract:

    This file contains code to handle the pnp irps.
    This is not USB specific but is essential for 
    every WDM driver.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSDevCtr.h"
#include "sSWmi.h"
#include "sSUsr.h"

NTSTATUS
SS_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    The plug and play dispatch routines.
    Most of these requests the driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    KEVENT             startDeviceEvent;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // since the device is removed, fail the Irp.
    //

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    SSDbgPrint(3, ("///////////////////////////////////////////\n"));
    SSDbgPrint(3, ("SS_DispatchPnP::"));
    SSIoIncrement(deviceExtension);

    if(irpStack->MinorFunction == IRP_MN_START_DEVICE) {

        ASSERT(deviceExtension->IdleReqPend == 0);
    }
    else {

        if(deviceExtension->SSEnable) {
        
            CancelSelectSuspend(deviceExtension);
        }
    }

    SSDbgPrint(2, (PnPMinorFunctionString(irpStack->MinorFunction)));

    switch(irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:

        ntStatus = HandleStartDevice(DeviceObject, Irp);

        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        //
        // if we cannot stop the device, we fail the query stop irp
        //
        ntStatus = CanStopDevice(DeviceObject, Irp);

        if(NT_SUCCESS(ntStatus)) {

            ntStatus = HandleQueryStopDevice(DeviceObject, Irp);

            return ntStatus;
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        ntStatus = HandleCancelStopDevice(DeviceObject, Irp);

        break;
     
    case IRP_MN_STOP_DEVICE:

        ntStatus = HandleStopDevice(DeviceObject, Irp);

        SSDbgPrint(3, ("SS_DispatchPnP::IRP_MN_STOP_DEVICE::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        //
        // if we cannot remove the device, we fail the query remove irp
        //
        ntStatus = CanRemoveDevice(DeviceObject, Irp);

        if(NT_SUCCESS(ntStatus)) {
            
            ntStatus = HandleQueryRemoveDevice(DeviceObject, Irp);

            return ntStatus;
        }
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        ntStatus = HandleCancelRemoveDevice(DeviceObject, Irp);

        break;

    case IRP_MN_SURPRISE_REMOVAL:

        ntStatus = HandleSurpriseRemoval(DeviceObject, Irp);

        SSDbgPrint(3, ("SS_DispatchPnP::IRP_MN_SURPRISE_REMOVAL::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_REMOVE_DEVICE:

        ntStatus = HandleRemoveDevice(DeviceObject, Irp);

        return ntStatus;

    case IRP_MN_QUERY_CAPABILITIES:

        ntStatus = HandleQueryCapabilities(DeviceObject, Irp);

        break;

    default:

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        SSDbgPrint(3, ("SS_DispatchPnP::default::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;

    } // switch

    //
    // complete request 
    //
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // decrement count
    //
    SSDbgPrint(3, ("SS_DispatchPnP::"));
    SSIoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP              Irp
    )
/*++
 
Routine Description:

    This is the dispatch routine for IRP_MN_START_DEVICE

Arguments:

    DeviceObject - pointer to a device object.

    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            startDeviceEvent;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER     dueTime;

    SSDbgPrint(3, ("HandleStartDevice - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // We cannot touch the device (send it any non pnp irps) until a
    // start device has been passed down to the lower drivers.
    // first pass the Irp down
    //

    KeInitializeEvent(&startDeviceEvent, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&startDeviceEvent, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&startDeviceEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("Lower drivers failed IRP_MN_START_DEVICE\n"));
        return ntStatus;
    }

    //
    // Read the device descriptor, configuration descriptor 
    // and select the interface descriptors
    //

    ntStatus = ReadandSelectDescriptors(DeviceObject);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("ReadandSelectDescriptors failed\n"));
        return ntStatus;
    }

    //
    // enable the symbolic links for system components to open
    // handles to the device
    //

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         TRUE);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("IoSetDeviceInterfaceState:enable:failed\n"));
        return ntStatus;
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Working);
    deviceExtension->QueueState = AllowRequests;

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // initialize wait wake variables
    // and issue a wait wake.
    
    deviceExtension->WaitWakeIrp = NULL;
    deviceExtension->FlagWWCancel = 0;
    deviceExtension->FlagWWOutstanding = 0;

    if(deviceExtension->WaitWakeEnable) {

        IssueWaitWake(deviceExtension);
    }

    ProcessQueuedRequests(deviceExtension);

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        deviceExtension->SSEnable = deviceExtension->SSRegistryEnable;

        //
        // set timer for selective suspend requests.
        //

        if(deviceExtension->SSEnable) {

            dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

            SSDbgPrint(3, ("Setting the timer...\n"));
            KeSetTimerEx(&deviceExtension->Timer, 
                         dueTime,
                         IDLE_INTERVAL,                              // 5000 ms
                         &deviceExtension->DeferredProcCall);

            deviceExtension->FreeIdleIrpCount = 0;
        }
    }

    SSDbgPrint(3, ("HandleStartDevice - ends\n"));

    return ntStatus;
}


NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine configures the USB device.
    In this routines we get the device descriptor, 
    the configuration descriptor and select the
    configuration descriptor.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NTSTATUS - NT status value.

--*/
{
    PURB                   urb;
    ULONG                  siz;
    NTSTATUS               ntStatus;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor;
    
    //
    // initialize variables
    //

    urb = NULL;
    deviceDescriptor = NULL;

    //
    // 1. Read the device descriptor
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_DEVICE_DESCRIPTOR);
        deviceDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(deviceDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_DEVICE_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    deviceDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(NT_SUCCESS(ntStatus)) {

                ASSERT(deviceDescriptor->bNumConfigurations);
                ntStatus = ConfigureDevice(DeviceObject);    
            }
            			    
            ExFreePool(urb);                
            ExFreePool(deviceDescriptor);
        }
        else {

            SSDbgPrint(1, ("Failed to allocate memory for deviceDescriptor\n"));

            ExFreePool(urb);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        SSDbgPrint(1, ("Failed to allocate memory for urb\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
ConfigureDevice(
	IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This helper routine reads the configuration descriptor
    for the device in couple of steps.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NTSTATUS - NT status value

--*/
{
    PURB                          urb;
    ULONG                         siz;
    NTSTATUS                      ntStatus;
    PDEVICE_EXTENSION             deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;

    //
    // initialize the variables
    //

    urb = NULL;
    configurationDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Read the first configuration descriptor
    // This requires two steps:
    // 1. Read the fixed sized configuration desciptor (CD)
    // 2. Read the CD with all embedded interface and endpoint descriptors
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR);
        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    configurationDescriptor,
                    NULL, 
                    sizeof(USB_CONFIGURATION_DESCRIPTOR), 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                SSDbgPrint(1, ("UsbBuildGetDescriptorRequest failed\n"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            SSDbgPrint(1, ("Failed to allocate mem for config Descriptor\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }

        siz = configurationDescriptor->wTotalLength;

        ExFreePool(configurationDescriptor);

        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE,
                    0, 
                    0, 
                    configurationDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                SSDbgPrint(1,("Failed to read configuration descriptor\n"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            SSDbgPrint(1, ("Failed to alloc mem for config Descriptor\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }
    }
    else {

        SSDbgPrint(1, ("Failed to allocate memory for urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto ConfigureDevice_Exit;
    }

    if(configurationDescriptor) {

        if(configurationDescriptor->bmAttributes & REMOTE_WAKEUP_MASK)
        {
            //
            // this configuration supports remote wakeup
            //
            deviceExtension->WaitWakeEnable = 1;
        }
        else
        {
            deviceExtension->WaitWakeEnable = 0;
        }

        ntStatus = SelectInterfaces(DeviceObject, configurationDescriptor);
    }

ConfigureDevice_Exit:

    if(urb) {

        ExFreePool(urb);
    }

    if(configurationDescriptor) {

        ExFreePool(configurationDescriptor);
    }

    return ntStatus;
}

NTSTATUS
SelectInterfaces(
    IN PDEVICE_OBJECT                DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/*++
 
Routine Description:

    This helper routine selects the configuration

Arguments:

    DeviceObject - pointer to device object
    ConfigurationDescriptor - pointer to the configuration
    descriptor for the device

Return Value:

    NT status value

--*/
{
    LONG                        numberOfInterfaces, 
                                interfaceNumber, 
                                interfaceindex;
    ULONG                       i;
    PURB                        urb;
    PUCHAR                      pInf;
    NTSTATUS                    ntStatus;
    PDEVICE_EXTENSION           deviceExtension;
    PUSB_INTERFACE_DESCRIPTOR   interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY  interfaceList, 
                                tmp;
    PUSBD_INTERFACE_INFORMATION interface;

    //
    // initialize the variables
    //

    urb = NULL;
    interface = NULL;
    interfaceDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;
    interfaceindex = interfaceNumber = 0;

    //
    // Parse the configuration descriptor for the interface;
    //

    tmp = interfaceList =
        ExAllocatePool(
               NonPagedPool, 
               sizeof(USBD_INTERFACE_LIST_ENTRY) * (numberOfInterfaces + 1));

    if(!tmp) {

        SSDbgPrint(1, ("Failed to allocate mem for interfaceList\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    while(interfaceNumber < numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                            ConfigurationDescriptor, 
                                            ConfigurationDescriptor,
                                            interfaceindex,
                                            0, -1, -1, -1);

        if(interfaceDescriptor) {

            interfaceList->InterfaceDescriptor = interfaceDescriptor;
            interfaceList->Interface = NULL;
            interfaceList++;
            interfaceNumber++;
        }

        interfaceindex++;
    }

    interfaceList->InterfaceDescriptor = NULL;
    interfaceList->Interface = NULL;
    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, tmp);

    if(urb) {

        interface = &urb->UrbSelectConfiguration.Interface;

        for(i=0; i<interface->NumberOfPipes; i++) {

            //
            // perform pipe initialization here
            // set the transfer size and any pipe flags we use
            // USBD sets the rest of the Interface struct members
            //

            interface->Pipes[i].MaximumTransferSize = 
                                USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;
        }

        ntStatus = CallUSBD(DeviceObject, urb);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Failed to select an interface\n"));
        }
    }
    else {
        
        SSDbgPrint(1, ("USBD_CreateConfigurationRequestEx failed\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(tmp) {

        ExFreePool(tmp);
    }

    if(urb) {

        ExFreePool(urb);
    }

    return ntStatus;
}


NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine is invoked when the device is removed or stopped.
    This routine de-configures the usb device.

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    PURB     urb;
    ULONG    siz;
    NTSTATUS ntStatus;
    
    //
    // initialize variables
    //

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);
    urb = ExAllocatePool(NonPagedPool, siz);

    if(urb) {

        UsbBuildSelectConfigurationRequest(urb, (USHORT)siz, NULL);

        ntStatus = CallUSBD(DeviceObject, urb);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(3, ("Failed to deconfigure device\n"));
        }

        ExFreePool(urb);
    }
    else {

        SSDbgPrint(1, ("Failed to allocate urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    )
/*++
 
Routine Description:

    This routine synchronously submits an urb down the stack.

Arguments:

    DeviceObject - pointer to device object
    Urb - USB request block

Return Value:

    NT status value

--*/
{
    PIRP               irp;
    KEVENT             event;
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize the variables
    //

    irp = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB, 
                                        deviceExtension->TopOfStackDeviceObject,
                                        NULL, 
                                        0, 
                                        NULL, 
                                        0, 
                                        TRUE, 
                                        &event, 
                                        &ioStatus);

    if(!irp) {

        SSDbgPrint(1, ("IoBuildDeviceIoControlRequest failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->Parameters.Others.Argument1 = Urb;

    SSDbgPrint(3, ("CallUSBD::"));
    SSIoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = ioStatus.Status;
    }
    
    SSDbgPrint(3, ("CallUSBD::"));
    SSIoDecrement(deviceExtension);
    return ntStatus;
}

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services the Irps of minor type IRP_MN_QUERY_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleQueryStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can stop the device, we need to set the QueueState to 
    // HoldRequests so further requests will be queued.
    //

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
    
    SET_NEW_PNP_STATE(deviceExtension, PendingStop);
    deviceExtension->QueueState = HoldRequests;
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // wait for the existing ones to be finished.
    // first, decrement this operation
    //

    SSDbgPrint(3, ("HandleQueryStopDevice::"));
    SSIoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    //
    // We must set Irp->IoStatus.Status to STATUS_SUCCESS before
    // passing it down.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleQueryStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_CANCEL_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT value

--*/
{
    KIRQL             oldIrql;    
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleCancelStopDevice - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Send this IRP down and wait for it to come back.
    // Set the QueueState flag to AllowRequests, 
    // and process all the previously queued up IRPs.
    //
    // First check to see whether you have received cancel-stop
    // without first receiving a query-stop. This could happen if someone
    // above us fails a query-stop and passes down the subsequent
    // cancel-stop.
    //

    if(PendingStop == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);
            deviceExtension->QueueState = AllowRequests;
            ASSERT(deviceExtension->DeviceState == Working);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }

    }
    else {

        // spurious Irp
        ntStatus = STATUS_SUCCESS;
    }

    SSDbgPrint(3, ("HandleCancelStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    This routine services Irp of minor type IRP_MN_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if(WinXpOrBetter == deviceExtension->WdmVersion) {
    
        if(deviceExtension->SSEnable) {

            //
            // Cancel the timer so that the DPCs are no longer fired.
            // Thus, we are making judicious usage of our resources.
            // we do not need DPCs because the device is stopping.
            // The timers are re-initialized while handling the start
            // device irp.
            //
        
            SSDbgPrint(3, ("Cancelling the timer...\n"));
            KeCancelTimer(&deviceExtension->Timer);

            //
            // after the device is stopped, it can be surprise removed.
            // we set this to 0, so that we do not attempt to cancel
            // the timer while handling surprise remove or remove irps.
            // When we get the start device request, this flag will be
            // reinitialized.
            //
            deviceExtension->SSEnable = 0;

            //
            // make sure that if a DPC was fired before we called cancel timer,
            // then the DPC and work-time have run to their completion
            //
            KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            //
            // make sure that the selective suspend request has been completed.
            //
            KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
        }
    }
    
    //
    // after the stop Irp is sent to the lower driver object, 
    // the driver must not send any more Irps down that touch 
    // the device until another Start has occurred.
    //

    if(deviceExtension->WaitWakeEnable) {
        
        CancelWaitWake(deviceExtension);
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Stopped);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // This is the right place to actually give up all the resources used
    // This might include calls to IoDisconnectInterrupt, MmUnmapIoSpace, 
    // etc.
    //
    ReleaseMemory(DeviceObject);
    
    ntStatus = DeconfigureDevice(DeviceObject);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    
    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleStopDevice - ends\n"));
    
    return ntStatus;
}

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_QUERY_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleQueryRemoveDevice - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can allow removal of the device, we should set the QueueState
    // to HoldRequests so further requests will be queued. This is required
    // so that we can process queued up requests in cancel-remove just in 
    // case somebody else in the stack fails the query-remove. 
    // 

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = HoldRequests;
    SET_NEW_PNP_STATE(deviceExtension, PendingRemove);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    SSDbgPrint(3, ("HandleQueryRemoveDevice::"));
    SSIoDecrement(deviceExtension);

    //
    // wait for all the requests to be completed
    //

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive,
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleQueryRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_CANCEL_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleCancelRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // We need to reset the QueueState flag to ProcessRequest, 
    // since the device resume its normal activities.
    //

    //
    // First check to see whether you have received cancel-remove
    // without first receiving a query-remove. This could happen if 
    // someone above us fails a query-remove and passes down the 
    // subsequent cancel-remove.
    //

    if(PendingRemove == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);
        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            deviceExtension->QueueState = AllowRequests;
            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
            //
            // process the queued requests that arrive between 
            // QUERY_REMOVE and CANCEL_REMOVE
            //
            
            ProcessQueuedRequests(deviceExtension);
            
        }
    }
    else {

        // 
        // spurious cancel-remove
        //
        ntStatus = STATUS_SUCCESS;
    }

    SSDbgPrint(3, ("HandleCancelRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_SURPRISE_REMOVAL

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleSurpriseRemoval - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // 1. fail pending requests
    // 2. return device and memory resources
    // 3. disable interfaces
    //

    if(deviceExtension->WaitWakeEnable) {
    
        CancelWaitWake(deviceExtension);
    }

    if(WinXpOrBetter == deviceExtension->WdmVersion) {
        
        if(deviceExtension->SSEnable) {

            //
            // Cancel the timer so that the DPCs are no longer fired.
            // we do not need DPCs because the device has been surprise
            // removed
            //

            SSDbgPrint(3, ("Cancelling the timer...\n"));
            KeCancelTimer(&deviceExtension->Timer);

            deviceExtension->SSEnable = 0;

            //
            // make sure that if a DPC was fired before we called cancel timer,
            // then the DPC and work-time have run to their completion
            //
            KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            //
            // make sure that the selective suspend request has been completed.
            //
            KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
        }
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = FailRequests;
    SET_NEW_PNP_STATE(deviceExtension, SurpriseRemoved);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    ProcessQueuedRequests(deviceExtension);

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         FALSE);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
    }

    RtlFreeUnicodeString(&deviceExtension->InterfaceName);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleSurpriseRemoval - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    ULONG             requestCount;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // The Plug & Play system has dictated the removal of this device.  We
    // have no choice but to detach and delete the device object.
    // (If we wanted to express an interest in preventing this removal,
    // we should have failed the query remove IRP).
    //

    if(SurpriseRemoved != deviceExtension->DeviceState) {

        //
        // we are here after QUERY_REMOVE
        //

        KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

        deviceExtension->QueueState = FailRequests;
        
        KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

        if(deviceExtension->WaitWakeEnable) {
        
            CancelWaitWake(deviceExtension);
        }

        if(WinXpOrBetter == deviceExtension->WdmVersion) {

            if(deviceExtension->SSEnable) {

                //
                // Cancel the timer so that the DPCs are no longer fired.
                // we do not need DPCs because the device has been removed
                //

                SSDbgPrint(3, ("Cancelling the timer...\n"));
                KeCancelTimer(&deviceExtension->Timer);

                deviceExtension->SSEnable = 0;

                //
                // make sure that if a DPC was fired before we called cancel timer,
                // then the DPC and work-time have run to their completion
                //
                KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                      Executive, 
                                      KernelMode, 
                                      FALSE, 
                                      NULL);

                //
                // make sure that the selective suspend request has been completed.
                //
                KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                      Executive, 
                                      KernelMode, 
                                      FALSE, 
                                      NULL);
            }
        }

        ProcessQueuedRequests(deviceExtension);

        ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                             FALSE);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
        }

        RtlFreeUnicodeString(&deviceExtension->InterfaceName);
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Removed);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
    
    SSWmiDeRegistration(deviceExtension);

    //
    // need 2 decrements
    //

    SSDbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = SSIoDecrement(deviceExtension);

    ASSERT(requestCount > 0);

    SSDbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = SSIoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->RemoveEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    ReleaseMemory(DeviceObject);

    //
    // We need to send the remove down the stack before we detach,
    // but we don't need to wait for the completion of this operation
    // (and to register a completion routine).
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    
    //
    // Detach the FDO from the device stack
    //
    IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
    IoDeleteDevice(DeviceObject);

    SSDbgPrint(3, ("HandleRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    This routine services Irp of minor type IRP_MN_QUERY_CAPABILITIES

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value  

--*/
{
    ULONG                i;
    KEVENT               event;
    NTSTATUS             ntStatus;
    PDEVICE_EXTENSION    deviceExtension;
    PDEVICE_CAPABILITIES pdc;
    PIO_STACK_LOCATION   irpStack;

    SSDbgPrint(3, ("HandleQueryCapabilities - begins\n"));

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    pdc = irpStack->Parameters.DeviceCapabilities.Capabilities;

    //
    // We will provide here an example of an IRP that is processed
    // both on its way down and on its way up: there might be no need for
    // a function driver process this Irp (the bus driver will do that).
    // The driver will wait for the lower drivers (the bus driver among 
    // them) to process this IRP, then it processes it again.
    //

    if(pdc->Version < 1 || pdc->Size < sizeof(DEVICE_CAPABILITIES)) {
        
        SSDbgPrint(1, ("HandleQueryCapabilities::request failed\n"));
        ntStatus = STATUS_UNSUCCESSFUL;
        return ntStatus;
    }

    //
    // Set some values in deviceCapabilities here...
    //
    //.............................................
    //
    //
    // Prepare to pass the IRP down
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);
        
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&event, 
                           TRUE, 
                           TRUE, 
                           TRUE);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
        ntStatus = Irp->IoStatus.Status;
    }

    //
    // initialize PowerDownLevel to disabled
    //

    deviceExtension->PowerDownLevel = PowerDeviceUnspecified;

    //
    // Lower drivers have finished their operation, so now
    // we can finish ours. 
    //

    if(NT_SUCCESS(ntStatus)) {

        deviceExtension->DeviceCapabilities = *pdc;
       
        for(i = PowerSystemSleeping1; i <= PowerSystemSleeping3; i++) {

            if(deviceExtension->DeviceCapabilities.DeviceState[i] < 
                                                            PowerDeviceD3) {

                deviceExtension->PowerDownLevel = 
                    deviceExtension->DeviceCapabilities.DeviceState[i];
            }
        }

        //
        // since its safe to surprise-remove this device, we shall
        // set the SurpriseRemoveOK flag to supress any dialog to 
        // user.
        //

        pdc->SurpriseRemovalOK = 1;

    }

    if(deviceExtension->PowerDownLevel == PowerDeviceUnspecified ||
       deviceExtension->PowerDownLevel <= PowerDeviceD0) {
    
        deviceExtension->PowerDownLevel = PowerDeviceD2;
    }

    SSDbgPrint(3, ("HandleQueryCapabilities - ends\n"));

    return ntStatus;
}


VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
 
Routine Description:

    DPC routine triggered by the timer to check the idle state
    of the device and submit an idle request for the device.

Arguments:

    DeferredContext - context for the dpc routine.
                      DeviceObject in our case.

Return Value:

    None

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PIO_WORKITEM      item;

    deviceObject = (PDEVICE_OBJECT)DeferredContext;
    deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

    SSDbgPrint(3, ("DpcRoutine - begins\n"));

    //
    // Clear this event since a DPC has been fired!
    //
    KeClearEvent(&deviceExtension->NoDpcWorkItemPendingEvent);

    if(CanDeviceSuspend(deviceExtension)) {

        SSDbgPrint(3, ("Device is Idle\n"));

        item = IoAllocateWorkItem(deviceObject);

        if(item) {

            IoQueueWorkItem(item, 
                            IdleRequestWorkerRoutine,
                            DelayedWorkQueue, 
                            item);

            ntStatus = STATUS_PENDING;

        }
        else {
        
            SSDbgPrint(3, ("Cannot alloc memory for work item\n"));
            
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            //
            // signal the NoDpcWorkItemPendingEvent.
            //
            KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }
    else {
        
        SSDbgPrint(3, ("Idle event not signaled\n"));

        //
        // signal the NoDpcWorkItemPendingEvent.
        //
        KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }

    SSDbgPrint(3, ("DpcRoutine - ends\n"));
}    


VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the work item fired from the DPC.
    This workitem checks the idle state of the device
    and submits an idle request.

Arguments:

    DeviceObject - pointer to device object
    Context - context for the work item.

Return Value:

    None

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_WORKITEM           workItem;

    SSDbgPrint(3, ("IdleRequestWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    workItem = (PIO_WORKITEM) Context;

    if(CanDeviceSuspend(deviceExtension)) {

        SSDbgPrint(3, ("Device is idle\n"));

        ntStatus = SubmitIdleRequestIrp(deviceExtension);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("SubmitIdleRequestIrp failed\n"));
        }
    }
    else {

        SSDbgPrint(3, ("Device is not idle\n"));
    }

    IoFreeWorkItem(workItem);

    //
    // signal the NoDpcWorkItemPendingEvent.
    //
    KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
               IO_NO_INCREMENT,
               FALSE);

    SSDbgPrint(3, ("IdleRequestsWorkerRoutine - ends\n"));
}


VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    Remove and process the entries in the queue. If this routine is called
    when processing IRP_MN_CANCEL_STOP_DEVICE, IRP_MN_CANCEL_REMOVE_DEVICE
    or IRP_MN_START_DEVICE, the requests are passed to the next lower driver.
    If the routine is called when IRP_MN_REMOVE_DEVICE is received, the IRPs
    are complete with STATUS_DELETE_PENDING

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    None

--*/
{
    KIRQL       oldIrql;
    PIRP        nextIrp,
                cancelledIrp;
    PVOID       cancelRoutine;
    LIST_ENTRY  cancelledIrpList;
    PLIST_ENTRY listEntry;

    SSDbgPrint(3, ("ProcessQueuedRequests - begins\n"));

    //
    // initialize variables
    //

    cancelRoutine = NULL;
    InitializeListHead(&cancelledIrpList);

    //
    // 1.  dequeue the entries in the queue
    // 2.  reset the cancel routine
    // 3.  process them
    // 3a. if the device is active, send them down
    // 3b. else complete with STATUS_DELETE_PENDING
    //

    while(1) {

        KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

        if(IsListEmpty(&DeviceExtension->NewRequestsQueue)) {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
            break;
        }
    
        //
        // Remove a request from the queue
        //

        listEntry = RemoveHeadList(&DeviceExtension->NewRequestsQueue);
        nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        //
        // set the cancel routine to NULL
        //

        cancelRoutine = IoSetCancelRoutine(nextIrp, NULL);

        //
        // check if its already cancelled
        //

        if(nextIrp->Cancel) {
            if(cancelRoutine) {

                //
                // the cancel routine for this IRP hasnt been called yet
                // so queue the IRP in the cancelledIrp list and complete
                // after releasing the lock
                //
                
                InsertTailList(&cancelledIrpList, listEntry);
            }
            else {

                //
                // the cancel routine has run
                // it must be waiting to hold the queue lock
                // so initialize the IRPs listEntry
                //

                InitializeListHead(listEntry);
            }

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
        }
        else {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

            if(FailRequests == DeviceExtension->QueueState) {

                nextIrp->IoStatus.Information = 0;
                nextIrp->IoStatus.Status = STATUS_DELETE_PENDING;
                IoCompleteRequest(nextIrp, IO_NO_INCREMENT);
            }
            else {

                PIO_STACK_LOCATION irpStack;

                SSDbgPrint(3, ("ProcessQueuedRequests::"));
                SSIoIncrement(DeviceExtension);

                IoSkipCurrentIrpStackLocation(nextIrp);
                IoCallDriver(DeviceExtension->TopOfStackDeviceObject, nextIrp);
               
                SSDbgPrint(3, ("ProcessQueuedRequests::"));
                SSIoDecrement(DeviceExtension);
            }
        }
    } // while loop

    //
    // walk through the cancelledIrp list and cancel them
    //

    while(!IsListEmpty(&cancelledIrpList)) {

        PLIST_ENTRY cancelEntry = RemoveHeadList(&cancelledIrpList);
        
        cancelledIrp = CONTAINING_RECORD(cancelEntry, 
                                         IRP, 
                                         Tail.Overlay.ListEntry);

        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        cancelledIrp->IoStatus.Information = 0;

        IoCompleteRequest(cancelledIrp, IO_NO_INCREMENT);
    }

    SSDbgPrint(3, ("ProcessQueuedRequests - ends\n"));

    return;
}


NTSTATUS
SS_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for IRP_MJ_CLEANUP

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager

Return Value:

    NT status value

--*/
{
    PDEVICE_EXTENSION  deviceExtension;
    KIRQL              oldIrql;
    LIST_ENTRY         cleanupList;
    PLIST_ENTRY        thisEntry, 
                       nextEntry, 
                       listHead;
    PIRP               pendingIrp;
    PIO_STACK_LOCATION pendingIrpStack, 
                       irpStack;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    InitializeListHead(&cleanupList);

    SSDbgPrint(3, ("SS_DispatchClean::"));
    SSIoIncrement(deviceExtension);

    //
    // acquire queue lock
    //
    KeAcquireSpinLock(&deviceExtension->QueueLock, &oldIrql);

    //
    // remove all Irp's that belong to input Irp's fileobject
    //

    listHead = &deviceExtension->NewRequestsQueue;

    for(thisEntry = listHead->Flink, nextEntry = thisEntry->Flink;
       thisEntry != listHead;
       thisEntry = nextEntry, nextEntry = thisEntry->Flink) {

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrpStack = IoGetCurrentIrpStackLocation(pendingIrp);

        if(irpStack->FileObject == pendingIrpStack->FileObject) {

            RemoveEntryList(thisEntry);

            //
            // set the cancel routine to NULL
            //
            if(NULL == IoSetCancelRoutine(pendingIrp, NULL)) {

                InitializeListHead(thisEntry);
            }
            else {

                InsertTailList(&cleanupList, thisEntry);
            }
        }
    }

    //
    // Release the spin lock
    //

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // walk thru the cleanup list and cancel all the Irps
    //

    while(!IsListEmpty(&cleanupList)) {

        //
        // complete the Irp
        //
        thisEntry = RemoveHeadList(&cleanupList);

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrp->IoStatus.Information = 0;
        pendingIrp->IoStatus.Status = STATUS_CANCELLED;

        IoCompleteRequest(pendingIrp, IO_NO_INCREMENT);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("SS_DispatchClean::"));
    SSIoDecrement(deviceExtension);

    return STATUS_SUCCESS;
}

NTSTATUS
SS_GetRegistryDword(
    IN     PWCHAR RegPath,
    IN     PWCHAR ValueName,
    IN OUT PULONG Value
    )
/*++
 
Routine Description:

    This routine reads the specified reqistry value.

Arguments:

    RegPath - registry path
    ValueName - property to be fetched from the registry
    Value - corresponding value read from the registry.

Return Value:

    NT status value

--*/
{
    ULONG                    defaultData;
    WCHAR                    buffer[MAXIMUM_FILENAME_LENGTH];
    NTSTATUS                 ntStatus;
    UNICODE_STRING           regPath;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];

    SSDbgPrint(3, ("SS_GetRegistryDword - begins\n"));

    regPath.Length = 0;
    regPath.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR);
    regPath.Buffer = buffer;

    RtlZeroMemory(regPath.Buffer, regPath.MaximumLength);
    RtlMoveMemory(regPath.Buffer,
                  RegPath,
                  wcslen(RegPath) * sizeof(WCHAR));

    RtlZeroMemory(paramTable, sizeof(paramTable));

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = ValueName;
    paramTable[0].EntryContext = Value;
    paramTable[0].DefaultType = REG_DWORD;
    paramTable[0].DefaultData = &defaultData;
    paramTable[0].DefaultLength = sizeof(ULONG);

    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE |
                                      RTL_REGISTRY_OPTIONAL,
                                      regPath.Buffer,
                                      paramTable,
                                      NULL,
                                      NULL);

    if(NT_SUCCESS(ntStatus)) {

        SSDbgPrint(3, ("success Value = %X\n", *Value));
        return STATUS_SUCCESS;
    }
    else {

        *Value = 0;
        return STATUS_UNSUCCESSFUL;
    }
}

BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the routine where we check if the device
    can selectively suspend. 

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    TRUE - if the device can suspend
    FALSE - otherwise.

--*/
{
    SSDbgPrint(3, ("CanDeviceSuspend\n"));

    if((DeviceExtension->OpenHandleCount == 0) &&
        (DeviceExtension->OutStandingIO == 1)) {
        
        return TRUE;
    }
    else {

        return FALSE;
    }
}

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This routine is a completion routine.
    In this routine we set an event.

    Since the completion routine returns 
    STATUS_MORE_PROCESSING_REQUIRED, the Irps,
    which set this routine as the completion routine,
    should be marked pending.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    Context - 

Return Value:

    NT status value

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


LONG
SSIoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine bumps up the I/O count.
    This routine is typically invoked when any of the
    dispatch routines handle new irps for the driver.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    new value

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedIncrement(&DeviceExtension->OutStandingIO);

    //
    // when OutStandingIO bumps from 1 to 2, clear the StopEvent
    //

    if(result == 2) {

        KeClearEvent(&DeviceExtension->StopEvent);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    SSDbgPrint(3, ("SSIoIncrement::%d\n", result));

    return result;
}

LONG
SSIoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine decrements the outstanding I/O count
    This is typically invoked after the dispatch routine
    has finished processing the irp.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    new value

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedDecrement(&DeviceExtension->OutStandingIO);

    if(result == 1) {

        KeSetEvent(&DeviceExtension->StopEvent, IO_NO_INCREMENT, FALSE);
    }

    if(result == 0) {

        ASSERT(Removed == DeviceExtension->DeviceState);

        KeSetEvent(&DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    SSDbgPrint(3, ("SSIoDecrement::%d\n", result));

    return result;
}

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine determines whether the device can be safely stopped. In our 
    particular case, we'll assume we can always stop the device.
    A device might fail the request if it doesn't have a queue for the
    requests it might come or if it was notified that it is in the paging
    path. 
  
Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the current IRP.

Return Value:

    STATUS_SUCCESS if the device can be safely stopped, an appropriate 
    NT Status if not.

--*/
{
   //
   // We assume we can stop the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine determines whether the device can be safely removed. In our 
    particular case, we'll assume we can always remove the device.
    A device shouldn't be removed if, for example, it has open handles or
    removing the device could result in losing data (plus the reasons 
    mentioned at CanStopDevice). The PnP manager on Windows 2000 fails 
    on its own any attempt to remove, if there any open handles to the device. 
    However on Win9x, the driver must keep count of open handles and fail 
    query_remove if there are any open handles.

Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the current IRP.
    
Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate 
    NT Status if not.

--*/
{
   //
   // We assume we can remove the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
ReleaseMemory(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine returns all the memory allocations acquired during
    device startup. 
    
Arguments:

    DeviceObject - pointer to the device object.
        
    
Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate 
    NT Status if not.

--*/
{
   //
   // Disconnect from the interrupt and unmap any I/O ports
   //

   UNREFERENCED_PARAMETER(DeviceObject);

   return STATUS_SUCCESS;
}

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE\n";

        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE\n";

        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE\n";

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE\n";

        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE\n";

        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE\n";

        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE\n";

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS\n";

        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE\n";

        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES\n";

        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES\n";

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT\n";

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG\n";

        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG\n";

        case IRP_MN_EJECT:
            return "IRP_MN_EJECT\n";

        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK\n";

        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID\n";

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE\n";

        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION\n";

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION\n";

        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\selsusp\sys\sspwr.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sSPwr.c

Abstract:

    The power management related processing.

    The Power Manager uses IRPs to direct drivers to change system
    and device power levels, to respond to system wake-up events,
    and to query drivers about their devices. All power IRPs have
    the major function code IRP_MJ_POWER.

    Most function and filter drivers perform some processing for
    each power IRP, then pass the IRP down to the next lower driver
    without completing it. Eventually the IRP reaches the bus driver,
    which physically changes the power state of the device and completes
    the IRP.

    When the IRP has been completed, the I/O Manager calls any
    IoCompletion routines set by drivers as the IRP traveled
    down the device stack. Whether a driver needs to set a completion
    routine depends upon the type of IRP and the driver's individual
    requirements.

    This code is not USB specific. It is essential for every WDM driver
    to handle power irps.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPwr.h"
#include "sSPnP.h"
#include "sSDevCtr.h"
#include "sSUsr.h"
#include "sSWmi.h"

NTSTATUS
SS_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    The power dispatch routine.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code

--*/
{
    NTSTATUS           ntStatus;
    PIO_STACK_LOCATION irpStack;
    PUNICODE_STRING    tagString;
    PDEVICE_EXTENSION  deviceExtension;
	
    //
    // initialize the variables
    //
	
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // We don't queue power Irps, we'll only check if the
    // device was removed, otherwise we'll take appropriate
    // action and send it to the next lower driver. In general
    // drivers should not cause long delays while handling power
    // IRPs. If a driver cannot handle a power IRP in a brief time,
    // it should return STATUS_PENDING and queue all incoming
    // IRPs until the IRP completes.
    //

    if(Removed == deviceExtension->DeviceState) {

        //
        // Even if a driver fails the IRP, it must nevertheless call
        // PoStartNextPowerIrp to inform the Power Manager that it
        // is ready to handle another power IRP.
        //

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    if(NotStarted == deviceExtension->DeviceState) {

        //
        // if the device is not started yet, pass it down
        //

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        return PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    SSDbgPrint(3, ("SS_DispatchPower::"));
    SSIoIncrement(deviceExtension);
    
    switch(irpStack->MinorFunction) {
    
    case IRP_MN_SET_POWER:

        //
        // The Power Manager sends this IRP for one of the
        // following reasons:
        // 1) To notify drivers of a change to the system power state.
        // 2) To change the power state of a device for which
        //    the Power Manager is performing idle detection.
        // A driver sends IRP_MN_SET_POWER to change the power
        // state of its device if it's a power policy owner for the
        // device.
        //

        //
        // Mark the Irp as pending and return STATUS_PENDING if we change the 
        // nature of the irp in the completion routine (asynchroniticity).
        // In such cases, do not return the status returned by the lower driver.
        // returning STATUS_MORE_PROCESSING_REQUIRED in the completion routine 
        // transforms the nature of the irp to asynchronous irp.
        //

        IoMarkIrpPending(Irp);

        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:

            HandleSystemSetPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;

        case DevicePowerState:

            HandleDeviceSetPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;
        }

        break;

    case IRP_MN_QUERY_POWER:

        //
        // The Power Manager sends a power IRP with the minor
        // IRP code IRP_MN_QUERY_POWER to determine whether it
        // can safely change to the specified system power state
        // (S1-S5) and to allow drivers to prepare for such a change.
        // If a driver can put its device in the requested state,
        // it sets status to STATUS_SUCCESS and passes the IRP down.
        //

        IoMarkIrpPending(Irp);
    
        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:
            
            HandleSystemQueryPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;

        case DevicePowerState:

            HandleDeviceQueryPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;
        }

        break;

    case IRP_MN_WAIT_WAKE:

        //
        // The minor power IRP code IRP_MN_WAIT_WAKE provides
        // for waking a device or waking the system. Drivers
        // of devices that can wake themselves or the system
        // send IRP_MN_WAIT_WAKE. The system sends IRP_MN_WAIT_WAKE
        // only to devices that always wake the system, such as
        // the power-on switch.
        //

        IoMarkIrpPending(Irp);

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                        Irp,
                        (PIO_COMPLETION_ROUTINE)WaitWakeCompletionRoutine,
                        deviceExtension, 
                        TRUE, 
                        TRUE, 
                        TRUE);

        PoStartNextPowerIrp(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Lower drivers failed the IRP_MN_WAIT_WAKE Irp\n"));
        }

        //
        // since we marked the Irp as pending; we should return STATUS_PENDING
        //
        ntStatus = STATUS_PENDING;

        //
        // push back the count HERE and NOT in completion routine
        // a pending Wait Wake Irp should not impede stopping the device
        //

        SSDbgPrint(3, ("IRP_MN_WAIT_WAKE::"));
        SSIoDecrement(deviceExtension);

        break;

    case IRP_MN_POWER_SEQUENCE:

        //
        // A driver sends this IRP as an optimization to determine
        // whether its device actually entered a specific power state.
        // This IRP is optional. Power Manager cannot send this IRP.
        //

    default:

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Lower drivers failed default power Irp\n"));
        }
        
        SSDbgPrint(3, ("SS_DispatchPower::"));
        SSIoDecrement(deviceExtension);

        break;
    }

    return ntStatus;
}

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine handles the irp with minor function of type IRP_MN_QUERY_POWER
    for the system power states.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager.

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    SSDbgPrint(3, ("HandleSystemQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    //
    // Fail a query for a power state incompatible with waking up the system
    //

    SSDbgPrint(3, ("Query for a system power state S%X\n"
                   "Current system power state S%X\n",
                   systemState - 1,
                   deviceExtension->SysPower - 1));

    //
    // if querying for a lower S-state, issue a wait-wake
    // also, it is mandatory to have this Irp pending below
    // before we send any of the low power irps.
    //

    if((systemState > deviceExtension->SysPower) &&
       (deviceExtension->WaitWakeEnable)) {

        IssueWaitWake(deviceExtension);
    }

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleSystemQueryPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_SET_POWER
    for the system power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    SSDbgPrint(3, ("HandleSystemSetPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    SSDbgPrint(3, ("Set request for a system power state S%X\n"
                   "Current system power state S%X\n", 
                   systemState - 1,
                   deviceExtension->SysPower - 1));

    //
    // pass the irp down the stack
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleSystemSetPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )
/*++

Routine Description:

    This routine services irps of minor type IRP_MN_QUERY_POWER
    for the device power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE deviceState;

    SSDbgPrint(3, ("HandleDeviceQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceState = irpStack->Parameters.Power.State.DeviceState;

    SSDbgPrint(3, ("Query for a device power state D%X\n"
                   "Current device power state D%X\n", 
                   deviceState - 1,
                   deviceExtension->DevPower - 1));

    if(deviceState < deviceExtension->DevPower) {

        ntStatus = STATUS_SUCCESS;
    }
    else {

        ntStatus = HoldIoRequests(DeviceObject, Irp);

        if(STATUS_PENDING == ntStatus) {

            return ntStatus;
        }
    }

    //
    // on error complete the Irp.
    // on success pass it to the lower layers
    //

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    if(!NT_SUCCESS(ntStatus)) {

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    SSDbgPrint(3, ("HandleDeviceQueryPower::"));
    SSIoDecrement(deviceExtension);

    SSDbgPrint(3, ("HandleDeviceQueryPower - ends\n"));

    return ntStatus;
}


NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the completion routine for the system power irps of minor
    function types IRP_MN_QUERY_POWER and IRP_MN_SET_POWER.
    This completion routine sends the corresponding device power irp and
    returns STATUS_MORE_PROCESSING_REQUIRED. The system irp is passed as a
    context to the device power irp completion routine and is completed in
    the device power irp completion routine.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
 	PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);


    SSDbgPrint(3, ("SysPoCompletionRoutine - begins\n"));

    //
    // lower drivers failed this Irp
    //

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        SSDbgPrint(3, ("SysPoCompletionRoutine::"));
        SSIoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    //
    // ..otherwise update the cached system power state (IRP_MN_SET_POWER)
    //

    if(irpStack->MinorFunction == IRP_MN_SET_POWER) {

        DeviceExtension->SysPower = irpStack->Parameters.Power.State.SystemState;
    }

    //
    // queue device irp and return STATUS_MORE_PROCESSING_REQUIRED
    //
	
    SendDeviceIrp(DeviceObject, Irp);

    SSDbgPrint(3, ("SysPoCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP SIrp
    )
/*++
 
Routine Description:

    This routine is invoked from the completion routine of the system power
    irp. This routine will PoRequest a device power irp. The system irp is 
    passed as a context to the the device power irp.

Arguments:

    DeviceObject - pointer to device object
    SIrp - system power irp.

Return Value:

    None

--*/
{
    NTSTATUS                  ntStatus;
    POWER_STATE               powState;
    PDEVICE_EXTENSION         deviceExtension;
    PIO_STACK_LOCATION        irpStack;
    SYSTEM_POWER_STATE        systemState;
    DEVICE_POWER_STATE        devState;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(SIrp);
    systemState = irpStack->Parameters.Power.State.SystemState;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    SSDbgPrint(3, ("SendDeviceIrp - begins\n"));

    //
    // Read out the D-IRP out of the S->D mapping array captured in QueryCap's.
    // we can choose deeper sleep states than our mapping but never choose
    // lighter ones.
    //

    devState = deviceExtension->DeviceCapabilities.DeviceState[systemState];
    powState.DeviceState = devState;
    
    powerContext = (PPOWER_COMPLETION_CONTEXT) 
                   ExAllocatePool(NonPagedPool,
                                  sizeof(POWER_COMPLETION_CONTEXT));

    if(!powerContext) {

        SSDbgPrint(1, ("Failed to alloc memory for powerContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        powerContext->DeviceObject = DeviceObject;
        powerContext->SIrp = SIrp;
   
        //
        // in win2k PoRequestPowerIrp can take fdo or pdo.
        //

        ntStatus = PoRequestPowerIrp(
                            deviceExtension->PhysicalDeviceObject, 
                            irpStack->MinorFunction,
                            powState,
                            (PREQUEST_POWER_COMPLETE)DevPoCompletionRoutine,
                            powerContext, 
                            NULL);
    }

    if(!NT_SUCCESS(ntStatus)) {

        if(powerContext) {

            ExFreePool(powerContext);
        }

        PoStartNextPowerIrp(SIrp);

        SIrp->IoStatus.Status = ntStatus;
        SIrp->IoStatus.Information = 0;
        
        IoCompleteRequest(SIrp, IO_NO_INCREMENT);

        SSDbgPrint(3, ("SendDeviceIrp::"));
        SSIoDecrement(deviceExtension);

    }

    SSDbgPrint(3, ("SendDeviceIrp - ends\n"));
}


VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject, 
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    This is the PoRequest - completion routine for the device power irp.
    This routine is responsible for completing the system power irp, 
    received as a context.

Arguments:

    DeviceObject - pointer to device object
    MinorFunction - minor function of the irp.
    PowerState - power state of the irp.
    Context - context passed to the completion routine.
    IoStatus - status of the device power irp.

Return Value:

    None

--*/
{
    PIRP                      sIrp;
    PDEVICE_EXTENSION         deviceExtension;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    powerContext = (PPOWER_COMPLETION_CONTEXT) Context;
    sIrp = powerContext->SIrp;
    deviceExtension = powerContext->DeviceObject->DeviceExtension;

    SSDbgPrint(3, ("DevPoCompletionRoutine - begins\n"));

    //
    // copy the D-Irp status into S-Irp
    //

    sIrp->IoStatus.Status = IoStatus->Status;

    //
    // complete the system Irp
    //
    
    PoStartNextPowerIrp(sIrp);

    sIrp->IoStatus.Information = 0;

    IoCompleteRequest(sIrp, IO_NO_INCREMENT);

    //
    // cleanup
    //
    
    SSDbgPrint(3, ("DevPoCompletionRoutine::"));
    SSIoDecrement(deviceExtension);

    ExFreePool(powerContext);

    SSDbgPrint(3, ("DevPoCompletionRoutine - ends\n"));

}

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_SET_POWER
    for the device power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;    
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    SSDbgPrint(3, ("HandleDeviceSetPower - begins\n"));
	
    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    oldDevState = deviceExtension->DevPower;
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;

    SSDbgPrint(3, ("Set request for a device power state D%X\n"
                   "Current device power state D%X\n", 
                   newDevState - 1,
                   deviceExtension->DevPower - 1));

    if(newDevState < oldDevState) {

        //
        // adding power
        //
        SSDbgPrint(3, ("Adding power to the device\n"));

        //
        // send the power IRP to the next driver in the stack
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE)FinishDevPoUpIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

	}
    else {

        //
        // newDevState >= oldDevState 
        //
        // hold I/O if transition from D0 -> DX (X = 1, 2, 3)
        // if transition from D1 or D2 to deeper sleep states, 
        // I/O queue is already on hold.
        //

        if(PowerDeviceD0 == oldDevState && newDevState > oldDevState) {

            //
            // D0 -> DX transition
            //

            SSDbgPrint(3, ("Removing power from the device\n"))

            ntStatus = HoldIoRequests(DeviceObject, Irp);

            if(!NT_SUCCESS(ntStatus)) {

                PoStartNextPowerIrp(Irp);

                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);

                SSDbgPrint(3, ("HandleDeviceSetPower::"));
                SSIoDecrement(deviceExtension);

                return ntStatus;
            }
            else {

                goto HandleDeviceSetPower_Exit;
            }
        }
        else if(PowerDeviceD0 == oldDevState && PowerDeviceD0 == newDevState) {

            //
            // D0 -> D0
            // unblock the queue which may have been blocked processing
            // query irp
            //
            
            SSDbgPrint(3, ("A SetD0 power request for the device\n"))

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
              
            deviceExtension->QueueState = AllowRequests;

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }   

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Lower drivers failed a power Irp\n"));
        }

    }

HandleDeviceSetPower_Exit:

    SSDbgPrint(3, ("HandleDeviceSetPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    completion routine for the device power UP irp with minor function
    IRP_MN_SET_POWER.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
                        
    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;

    SSDbgPrint(3, ("FinishDevPoUpIrp - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        SSDbgPrint(3, ("FinishDevPoUpIrp::"));
        SSIoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    SetDeviceFunctional(DeviceObject, Irp, DeviceExtension);

    SSDbgPrint(3, ("FinishDevPoUpIrp - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine processes queue of pending irps.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;
    oldDevState = DeviceExtension->DevPower;

    SSDbgPrint(3, ("SetDeviceFunctional - begins\n"));

    //
    // update the cached state
    //
    DeviceExtension->DevPower = newDevState;

    //
    // restore appropriate amount of state to our h/w
    // this driver does not implement partial context
    // save/restore.
    //

    PoSetPowerState(DeviceObject, DevicePowerState, newState);

    if(PowerDeviceD0 == newDevState) {

    //
    // empty existing queue of all pending irps.
    //

        KeAcquireSpinLock(&DeviceExtension->DevStateLock, &oldIrql);

        DeviceExtension->QueueState = AllowRequests;
        
        KeReleaseSpinLock(&DeviceExtension->DevStateLock, oldIrql);

        ProcessQueuedRequests(DeviceExtension);
    }

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("SetDeviceFunctional::"));
    SSIoDecrement(DeviceExtension);

    SSDbgPrint(3, ("SetDeviceFunctional - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine is the completion routine for device power DOWN irp.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;

    SSDbgPrint(3, ("FinishDevPoDnIrp - begins\n"));

    if(NT_SUCCESS(ntStatus) && irpStack->MinorFunction == IRP_MN_SET_POWER) {

        //
        // update the cache;
        //

        SSDbgPrint(3, ("updating cache..\n"));

        DeviceExtension->DevPower = newState.DeviceState;

        PoSetPowerState(DeviceObject, DevicePowerState, newState);
    }

    PoStartNextPowerIrp(Irp);

    SSDbgPrint(3, ("FinishDevPoDnIrp::"));
    SSIoDecrement(DeviceExtension);

    SSDbgPrint(3, ("FinishDevPoDnIrp - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine is called on query or set power DOWN irp for the device.
    This routine queues a workitem.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    NTSTATUS               ntStatus;
    PIO_WORKITEM           item;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    SSDbgPrint(3, ("HoldIoRequests - begins\n"));

    deviceExtension->QueueState = HoldRequests;

    context = ExAllocatePool(NonPagedPool, sizeof(WORKER_THREAD_CONTEXT));

    if(context) {

        item = IoAllocateWorkItem(DeviceObject);

        context->Irp = Irp;
        context->DeviceObject = DeviceObject;
        context->WorkItem = item;

        if(item) {

            IoMarkIrpPending(Irp);
            
            IoQueueWorkItem(item, HoldIoRequestsWorkerRoutine,
                            DelayedWorkQueue, context);
            
            ntStatus = STATUS_PENDING;
        }
        else {

            SSDbgPrint(3, ("Failed to allocate memory for workitem\n"));
            ExFreePool(context);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        SSDbgPrint(1, ("Failed to alloc memory for worker thread context\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    SSDbgPrint(3, ("HoldIoRequests - ends\n"));

    return ntStatus;
}

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This routine waits for the I/O in progress to finish and then
    sends the device power irp (query/set) down the stack.

Arguments:

    DeviceObject - pointer to device object
    Context - context passed to the work-item.

Return Value:

    None

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    context = (PWORKER_THREAD_CONTEXT) Context;
    irp = (PIRP) context->Irp;


    //
    // wait for I/O in progress to finish.
    // the stop event is signalled when the counter drops to 1.
    // invoke SSIoDecrement twice: once each for the S-Irp and D-Irp.
    //
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoDecrement(deviceExtension);
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, Executive,
                          KernelMode, FALSE, NULL);

    //
    // Increment twice to restore the count
    //
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoIncrement(deviceExtension);
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoIncrement(deviceExtension);

    // 
    // now send the Irp down
    //

    IoCopyCurrentIrpStackLocationToNext(irp);

    IoSetCompletionRoutine(irp, (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                           deviceExtension, TRUE, TRUE, TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("Lower driver fail a power Irp\n"));
    }

    IoFreeWorkItem(context->WorkItem);
    ExFreePool((PVOID)context);

    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine - ends\n"));

}

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    Queue the Irp in the device queue

Arguments:

    DeviceExtension - pointer to device extension
    Irp - I/O request packet.

Return Value:

    NT status value

--*/
{
    KIRQL    oldIrql;
    NTSTATUS ntStatus;

    //
    // initialize variables
    //
    ntStatus = STATUS_PENDING;

    SSDbgPrint(3, ("QueueRequests - begins\n"));

    ASSERT(HoldRequests == DeviceExtension->QueueState);

    KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

    InsertTailList(&DeviceExtension->NewRequestsQueue, 
                   &Irp->Tail.Overlay.ListEntry);

    IoMarkIrpPending(Irp);

    //
    // Set the cancel routine
    //

    IoSetCancelRoutine(Irp, CancelQueued);

    KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

    SSDbgPrint(3, ("QueueRequests - ends\n"));

    return ntStatus;
}

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine removes the irp from the queue and completes it with
    STATUS_CANCELLED

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    KIRQL             oldIrql;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    oldIrql = Irp->CancelIrql;

    SSDbgPrint(3, ("CancelQueued - begins\n"));

    //
    // Release the cancel spin lock
    //

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // Acquire the queue lock
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->QueueLock);

    //
    // Remove the cancelled Irp from queue and release the lock
    //
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // complete with STATUS_CANCELLED
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("CancelQueued - ends\n"));

    return;
}

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine will PoRequest a WAIT WAKE irp for the device

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value.

--*/
{
    POWER_STATE poState;
    NTSTATUS    ntStatus;

    SSDbgPrint(3, ("IssueWaitWake - begins\n"));

    if(InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 1)) {

        SSDbgPrint(3, ("Outstanding wait wake Irp\n"));

        return STATUS_DEVICE_BUSY;
    }

    InterlockedExchange(&DeviceExtension->FlagWWCancel, 0);

    //
    // lowest state from which this Irp will wake the system
    //

    poState.SystemState = DeviceExtension->DeviceCapabilities.SystemWake;

    ntStatus = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_WAIT_WAKE,
                                 poState, 
                                 (PREQUEST_POWER_COMPLETE) WaitWakeCallback,
                                 DeviceExtension, 
                                 &DeviceExtension->WaitWakeIrp);

    if(!NT_SUCCESS(ntStatus)) {

        InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 0);
    }

    SSDbgPrint(3, ("IssueWaitWake - ends\n"));

    return ntStatus;
}

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine cancels the Wait Wake request.

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    None.

--*/
{
    PIRP Irp;

    SSDbgPrint(3, ("CancelWaitWake - begins\n"));

    Irp = (PIRP) InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, 
                                            NULL);

    if(Irp) {

        IoCancelIrp(Irp);

        if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

            PoStartNextPowerIrp(Irp);

            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }    
    }

    SSDbgPrint(3, ("CancelWaitWake - ends\n"));
}

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the IoSet completion routine for the wait wake irp.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    SSDbgPrint(3, ("WaitWakeCompletionRoutine - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    //
    // Nullify the WaitWakeIrp pointer-the Irp is released 
    // as part of the completion process. If it's already NULL, 
    // avoid race with the CancelWaitWake routine.
    //

    if(InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, NULL)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_SUCCESS;
    }

    //
    // CancelWaitWake has run. 
    // If FlagWWCancel != 0, complete the Irp.
    // If FlagWWCancel == 0, CancelWaitWake completes it.
    //
    if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_CANCELLED;
    }

    SSDbgPrint(3, ("WaitWakeCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    This is the PoRequest completion routine for the wait wake irp.

Arguments:

    DeviceObject - pointer to device object
    MinorFunction - irp minor function
    PowerState - power state of the irp.
    Context - context passed to the completion routine.
    IoStatus - status block.

Return Value:

    None

--*/
{
    NTSTATUS               ntStatus;
    POWER_STATE            powerState;
    PDEVICE_EXTENSION      deviceExtension;

    SSDbgPrint(3, ("WaitWakeCallback - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) Context;

    InterlockedExchange(&deviceExtension->FlagWWOutstanding, 0);

    if(!NT_SUCCESS(IoStatus->Status)) {

        return;
    }

    //
    // wake up the device
    //

    if(deviceExtension->DevPower == PowerDeviceD0) {

        SSDbgPrint(3, ("device already powered up...\n"));

        return;
    }

    SSDbgPrint(3, ("WaitWakeCallback::"));
    SSIoIncrement(deviceExtension);

    powerState.DeviceState = PowerDeviceD0;

    ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_SET_POWER, 
                                 powerState, 
                                 (PREQUEST_POWER_COMPLETE) WWIrpCompletionFunc,
                                 deviceExtension, 
                                 NULL);

    if(deviceExtension->WaitWakeEnable) {
    
        IssueWaitWake(deviceExtension);
    }

    SSDbgPrint(3, ("WaitWakeCallback - ends\n"));

    return;
}


PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER\n";

        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER\n";

        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE\n";

        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\selsusp\sys\sswmi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSWmi.h

Abstract:
    
Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __WMI_H
#define __WMI_H

NTSTATUS
SSWmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SSWmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SS_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SSQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo	    
    );

NTSTATUS
SSSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
SSSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
SSQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    );

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\selsusp\sys\sswmi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sSWmi.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPwr.h"
#include "sSPnP.h"
#include "sSDevCtr.h"
#include "sSWmi.h"
#include "sSUsr.h"

#define MOFRESOURCENAME L"MofResourceName"

#define WMI_SELECT_SUSPEND_DRIVER_INFORMATION 0

DEFINE_GUID (SELECT_SUSPEND_WMI_STD_DATA_GUID, 
0xBBA21300, 0x6DD3, 0x11d2, 0xB8, 0x44, 0x00, 0xC0, 0x4F, 0xAD, 0x51, 0x71);

WMIGUIDREGINFO SSWmiGuidList[1] = { {

        &SELECT_SUSPEND_WMI_STD_DATA_GUID, 1, 0 // driver information
    }
};

NTSTATUS
SSWmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Registers with WMI as a data provider for this
    instance of the device

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    
    PAGED_CODE();

    DeviceExtension->WmiLibInfo.GuidCount = 
          sizeof (SSWmiGuidList) / sizeof (WMIGUIDREGINFO);

    DeviceExtension->WmiLibInfo.GuidList           = SSWmiGuidList;
    DeviceExtension->WmiLibInfo.QueryWmiRegInfo    = SSQueryWmiRegInfo;
    DeviceExtension->WmiLibInfo.QueryWmiDataBlock  = SSQueryWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataBlock    = SSSetWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataItem     = SSSetWmiDataItem;
    DeviceExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DeviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //
    
    ntStatus = IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                        WMIREG_ACTION_REGISTER);

    return ntStatus;
    
}

NTSTATUS
SSWmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

     Inform WMI to remove this DeviceObject from its 
     list of providers. This function also 
     decrements the reference count of the deviceobject.

Arguments:

Return Value:

--*/
{

    PAGED_CODE();

    return IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                    WMIREG_ACTION_DEREGISTER);

}

NTSTATUS
SS_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION  disposition;
    NTSTATUS                ntStatus;
    PIO_STACK_LOCATION      irpStack;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    SSDbgPrint(3, (WMIMinorFunctionString(irpStack->MinorFunction)));

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    SSDbgPrint(3, ("SS_DispatchSysCtrl::"));
    SSIoIncrement(deviceExtension);

    ntStatus = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                DeviceObject, 
                                Irp,
                                &disposition);

    switch(disposition) {

        case IrpProcessed: 
        {
            //
            // This irp has been processed and may be completed or pending.
            //

            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            //

            IoCompleteRequest(Irp, IO_NO_INCREMENT);                

            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targeted
            // at a device lower in the stack.
            //

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                    Irp);

            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            //

            ASSERT(FALSE);

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                  Irp);
            break;
        }        
    }

    SSDbgPrint(3, ("SS_DispatchSysCtrl::"));
    SSIoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
SSQueryWmiRegInfo(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT ULONG           *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo	    
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    SSDbgPrint(3, ("SSQueryWmiRegInfo - begins\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    *RegFlags     = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.SSRegistryPath;
    *Pdo          = deviceExtension->PhysicalDeviceObject;
    RtlInitUnicodeString(MofResourceName, MOFRESOURCENAME);

    SSDbgPrint(3, ("SSQueryWmiRegInfo - ends\n"));
    
    return STATUS_SUCCESS;
}

NTSTATUS
SSQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instances expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.        
            
    OutBufferSize has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             size;
    WCHAR             modelName[] = L"Aishverya\0\0";
    USHORT            modelNameLen;

    PAGED_CODE();

    SSDbgPrint(3, ("SSQueryWmiDataBlock - begins\n"));

    size = 0;
    modelNameLen = (wcslen(modelName) + 1) * sizeof(WCHAR);

    //
    // Only ever registers 1 instance per guid
    //

    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_SELECT_SUSPEND_DRIVER_INFORMATION:

        size = sizeof(ULONG) + modelNameLen + sizeof(USHORT);

        if (OutBufferSize < size ) {

            SSDbgPrint(3, ("OutBuffer too small\n"));

            ntStatus = STATUS_BUFFER_TOO_SMALL;

            break;
        }

        * (PULONG) Buffer = DebugLevel;

        Buffer += sizeof(ULONG);

        //
        // put length of string ahead of string
        //

        *((PUSHORT)Buffer) = modelNameLen;

        Buffer = (PUCHAR)Buffer + sizeof(USHORT);

        RtlCopyBytes((PVOID)Buffer, (PVOID)modelName, modelNameLen);

        *InstanceLengthArray = size ;

        ntStatus = STATUS_SUCCESS;

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                size,
                                IO_NO_INCREMENT);

    SSDbgPrint(3, ("SSQueryWmiDataBlock - ends\n"));

    return ntStatus;
}


NTSTATUS
SSSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;
    
    PAGED_CODE();

    SSDbgPrint(3, ("SSSetWmiDataItem - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    switch(GuidIndex) {
    
    case WMI_SELECT_SUSPEND_DRIVER_INFORMATION:

        if(DataItemId == 1) {

            if(BufferSize == sizeof(ULONG)) {

                DebugLevel = *((PULONG)Buffer);

                ntStatus = STATUS_SUCCESS;

                info = sizeof(ULONG);
            }
            else {

                ntStatus = STATUS_INFO_LENGTH_MISMATCH;
            }
        }
        else {

            ntStatus = STATUS_WMI_READ_ONLY;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    SSDbgPrint(3, ("SSSetWmiDataItem - ends\n"));

    return ntStatus;
}

NTSTATUS
SSSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    SSDbgPrint(3, ("SSSetWmiDataBlock - begins\n"));

    switch(GuidIndex) {
    
    case WMI_SELECT_SUSPEND_DRIVER_INFORMATION:

        if(BufferSize == sizeof(ULONG)) {

            DebugLevel = *(PULONG) Buffer;
                    
            ntStatus = STATUS_SUCCESS;

            info = sizeof(ULONG);
        }
        else {

            ntStatus = STATUS_INFO_LENGTH_MISMATCH;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    SSDbgPrint(3, ("SSSetWmiDataBlock - ends\n"));

    return ntStatus;
}

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
            return "IRP_MN_CHANGE_SINGLE_INSTANCE\n";

        case IRP_MN_CHANGE_SINGLE_ITEM:
            return "IRP_MN_CHANGE_SINGLE_ITEM\n";

        case IRP_MN_DISABLE_COLLECTION:
            return "IRP_MN_DISABLE_COLLECTION\n";

        case IRP_MN_DISABLE_EVENTS:
            return "IRP_MN_DISABLE_EVENTS\n";

        case IRP_MN_ENABLE_COLLECTION:
            return "IRP_MN_ENABLE_COLLECTION\n";

        case IRP_MN_ENABLE_EVENTS:
            return "IRP_MN_ENABLE_EVENTS\n";

        case IRP_MN_EXECUTE_METHOD:
            return "IRP_MN_EXECUTE_METHOD\n";

        case IRP_MN_QUERY_ALL_DATA:
            return "IRP_MN_QUERY_ALL_DATA\n";

        case IRP_MN_QUERY_SINGLE_INSTANCE:
            return "IRP_MN_QUERY_SINGLE_INSTANCE\n";

        case IRP_MN_REGINFO:
            return "IRP_MN_REGINFO\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbmass\ocrw.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    OCRW.C

Abstract:

    This source file contains the dispatch routines which handle
    opening, closing, reading, and writing to the device, i.e.:

    IRP_MJ_CREATE
    IRP_MJ_CLOSE
    IRP_MJ_READ
    IRP_MJ_WRITE

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <ntddk.h>
#include <usbdi.h>
#include <usbdlib.h>

#include "usbmass.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBSTOR_Create)
#pragma alloc_text(PAGE, USBSTOR_Close)
#pragma alloc_text(PAGE, USBSTOR_ReadWrite)
#endif

//******************************************************************************
//
// USBSTOR_Create()
//
// Dispatch routine which handles IRP_MJ_CREATE
//
//******************************************************************************

NTSTATUS
USBSTOR_Create (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    DBGPRINT(2, ("enter: USBSTOR_Create\n"));

    LOGENTRY('CREA', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CREATE);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit: USBSTOR_Create\n"));

    LOGENTRY('crea', 0, 0, 0);

    return STATUS_SUCCESS;
}


//******************************************************************************
//
// USBSTOR_Close()
//
// Dispatch routine which handles IRP_MJ_CLOSE
//
//******************************************************************************

NTSTATUS
USBSTOR_Close (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    DBGPRINT(2, ("enter: USBSTOR_Close\n"));

    LOGENTRY('CLOS', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CLOSE);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit: USBSTOR_Close\n"));

    LOGENTRY('clos', 0, 0, 0);

    return STATUS_SUCCESS;
}


//******************************************************************************
//
// USBSTOR_ReadWrite()
//
// Dispatch routine which handles IRP_MJ_READ and IRP_MJ_WRITE
//
//******************************************************************************

NTSTATUS
USBSTOR_ReadWrite (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: USBSTOR_ReadWrite\n"));

    LOGENTRY('RW  ', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_READWRITE);

    ntStatus = STATUS_INVALID_PARAMETER;
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit: USBSTOR_ReadWrite %08X\n", ntStatus));

    LOGENTRY('rw  ', ntStatus, 0, 0);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbmass\dbg.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    DBG.C

Abstract:

    USBSTOR driver debug utility functions

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <ntddk.h>
#include <usbdi.h>
#include <usbdlib.h>

#include "usbmass.h"

#ifdef ALLOC_PRAGMA
#if DBG
#pragma alloc_text(PAGE, USBSTOR_QueryGlobalParams)
#endif
#if DEBUG_LOG
#pragma alloc_text(PAGE, USBSTOR_LogInit)
#pragma alloc_text(PAGE, USBSTOR_LogUnInit)
#endif
#if DBG
#pragma alloc_text(PAGE, DumpDeviceDesc)
#pragma alloc_text(PAGE, DumpConfigDesc)
#pragma alloc_text(PAGE, DumpConfigurationDescriptor)
#pragma alloc_text(PAGE, DumpInterfaceDescriptor)
#pragma alloc_text(PAGE, DumpEndpointDescriptor)
#endif
#endif


//******************************************************************************
//
// G L O B A L S
//
//******************************************************************************

#if DBG || DEBUG_LOG

DRIVERGLOBALS USBSTOR_DriverGlobals =
{
#if DBG
    0,                      // DebugFlags
    0,                      // DebugLevel
#endif
    0,      // LogStart
    0,      // LogPtr
    0,      // LogEnd
    0       // LogSpinLock
};

#endif

#if DBG

//******************************************************************************
//
// USBSTOR_QueryGlobalParams()
//
//******************************************************************************

VOID
USBSTOR_QueryGlobalParams (
    )
{
    RTL_QUERY_REGISTRY_TABLE paramTable[3];

    DBGPRINT(2, ("enter: USBSTOR_QueryGlobalParams\n"));

    RtlZeroMemory (&paramTable[0], sizeof(paramTable));

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = L"DebugFlags";
    paramTable[0].EntryContext  = &USBSTOR_DriverGlobals.DebugFlags;
    paramTable[0].DefaultType   = REG_BINARY;
    paramTable[0].DefaultData   = &USBSTOR_DriverGlobals.DebugFlags;
    paramTable[0].DefaultLength = sizeof(ULONG);

    paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name          = L"DebugLevel";
    paramTable[1].EntryContext  = &USBSTOR_DriverGlobals.DebugLevel;
    paramTable[1].DefaultType   = REG_BINARY;
    paramTable[1].DefaultData   = &USBSTOR_DriverGlobals.DebugLevel;
    paramTable[1].DefaultLength = sizeof(ULONG);

    RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                           L"USBSTOR",
                           &paramTable[0],
                           NULL,           // Context
                           NULL);          // Environment

    DBGPRINT(2, ("exit: USBSTOR_QueryGlobalParams\n"));
}

#endif

#if DBG || DEBUG_LOG

//*****************************************************************************
//
// USBSTOR_LogInit()
//
//*****************************************************************************

VOID
USBSTOR_LogInit (
)
{
    KeInitializeSpinLock(&USBSTOR_DriverGlobals.LogSpinLock);

    USBSTOR_DriverGlobals.LogStart = ExAllocatePoolWithTag(NonPagedPool,
                                                           LOGSIZE,
                                                           POOL_TAG);

    if (USBSTOR_DriverGlobals.LogStart != NULL)
    {
        USBSTOR_DriverGlobals.LogEnd = USBSTOR_DriverGlobals.LogStart +
                                      LOGSIZE / sizeof(USBSTOR_LOG_ENTRY);

        USBSTOR_DriverGlobals.LogPtr = USBSTOR_DriverGlobals.LogEnd - 1;
    }
}

//*****************************************************************************
//
// USBSTOR_LogUnInit()
//
//*****************************************************************************

VOID
USBSTOR_LogUnInit (
)
{
    PUSBSTOR_LOG_ENTRY logStart;

    logStart = USBSTOR_DriverGlobals.LogStart;

    USBSTOR_DriverGlobals.LogStart = 0;

    ExFreePool(logStart);
}

//*****************************************************************************
//
// USBSTOR_LogEntry()
//
//*****************************************************************************

VOID
USBSTOR_LogEntry (
    IN ULONG     Tag,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
)
{
    KIRQL irql;

    if (USBSTOR_DriverGlobals.LogStart == NULL)
    {
        return;
    }

    KeAcquireSpinLock(&USBSTOR_DriverGlobals.LogSpinLock, &irql);

    USBSTOR_DriverGlobals.LogPtr->le_tag     = Tag;
    USBSTOR_DriverGlobals.LogPtr->le_info1   = Info1;
    USBSTOR_DriverGlobals.LogPtr->le_info2   = Info2;
    USBSTOR_DriverGlobals.LogPtr->le_info3   = Info3;

    if (USBSTOR_DriverGlobals.LogPtr > USBSTOR_DriverGlobals.LogStart)
    {
        USBSTOR_DriverGlobals.LogPtr--;
    }
    else
    {
        USBSTOR_DriverGlobals.LogPtr = USBSTOR_DriverGlobals.LogEnd - 1;
    }

    KeReleaseSpinLock(&USBSTOR_DriverGlobals.LogSpinLock, irql);
}

#endif

#if DBG

//*****************************************************************************
//
// PnPMinorFunctionString()
//
// MinorFunction - The IRP_MJ_PNP minor function
//
//*****************************************************************************

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        default:
            return "IRP_MN_?????";
    }
}

//*****************************************************************************
//
// PowerMinorFunctionString()
//
// MinorFunction - The IRP_MJ_POWER minor function
//
//*****************************************************************************

PCHAR
PowerMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE";
        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE";
        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER";
        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER";
        default:
            return "IRP_MN_?????";
    }
}

//*****************************************************************************
//
// PowerDeviceStateString()
//
// State - The DEVICE_POWER_STATE
//
//*****************************************************************************

PCHAR
PowerDeviceStateString (
    DEVICE_POWER_STATE State
)
{
    switch (State)
    {
        case PowerDeviceUnspecified:
            return "PowerDeviceUnspecified";
        case PowerDeviceD0:
            return "PowerDeviceD0";
        case PowerDeviceD1:
            return "PowerDeviceD1";
        case PowerDeviceD2:
            return "PowerDeviceD2";
        case PowerDeviceD3:
            return "PowerDeviceD3";
        case PowerDeviceMaximum:
            return "PowerDeviceMaximum";
        default:
            return "PowerDevice?????";
    }
}

//*****************************************************************************
//
// PowerSystemStateString()
//
// State - The SYSTEM_POWER_STATE
//
//*****************************************************************************

PCHAR
PowerSystemStateString (
    SYSTEM_POWER_STATE State
)
{
    switch (State)
    {
        case PowerSystemUnspecified:
            return "PowerSystemUnspecified";
        case PowerSystemWorking:
            return "PowerSystemWorking";
        case PowerSystemSleeping1:
            return "PowerSystemSleeping1";
        case PowerSystemSleeping2:
            return "PowerSystemSleeping2";
        case PowerSystemSleeping3:
            return "PowerSystemSleeping3";
        case PowerSystemHibernate:
            return "PowerSystemHibernate";
        case PowerSystemShutdown:
            return "PowerSystemShutdown";
        case PowerSystemMaximum:
            return "PowerSystemMaximum";
        default:
            return "PowerSystem?????";
    }
}

//*****************************************************************************
//
// DumpDeviceDesc()
//
// DeviceDesc - The Device Descriptor
//
//*****************************************************************************

VOID
DumpDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
)
{
    DBGPRINT(3, ("------------------\n"));
    DBGPRINT(3, ("Device Descriptor:\n"));

    DBGPRINT(3, ("bcdUSB:             0x%04X\n",
                 DeviceDesc->bcdUSB));

    DBGPRINT(3, ("bDeviceClass:         0x%02X\n",
                 DeviceDesc->bDeviceClass));

    DBGPRINT(3, ("bDeviceSubClass:      0x%02X\n",
                 DeviceDesc->bDeviceSubClass));

    DBGPRINT(3, ("bDeviceProtocol:      0x%02X\n",
                 DeviceDesc->bDeviceProtocol));

    DBGPRINT(3, ("bMaxPacketSize0:      0x%02X (%d)\n",
                 DeviceDesc->bMaxPacketSize0,
                 DeviceDesc->bMaxPacketSize0));

    DBGPRINT(3, ("idVendor:           0x%04X\n",
                 DeviceDesc->idVendor));

    DBGPRINT(3, ("idProduct:          0x%04X\n",
                 DeviceDesc->idProduct));

    DBGPRINT(3, ("bcdDevice:          0x%04X\n",
                 DeviceDesc->bcdDevice));

    DBGPRINT(3, ("iManufacturer:        0x%02X\n",
                 DeviceDesc->iManufacturer));

    DBGPRINT(3, ("iProduct:             0x%02X\n",
                 DeviceDesc->iProduct));

    DBGPRINT(3, ("iSerialNumber:        0x%02X\n",
                 DeviceDesc->iSerialNumber));

    DBGPRINT(3, ("bNumConfigurations:   0x%02X\n",
                 DeviceDesc->bNumConfigurations));

}

//*****************************************************************************
//
// DumpConfigDesc()
//
// ConfigDesc - The Configuration Descriptor, and associated Interface and
// EndpointDescriptors
//
//*****************************************************************************

VOID
DumpConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    PUCHAR                  descEnd;
    PUSB_COMMON_DESCRIPTOR  commonDesc;
    BOOLEAN                 dumpUnknown;

    descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

    commonDesc = (PUSB_COMMON_DESCRIPTOR)ConfigDesc;

    while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
           (PUCHAR)commonDesc + commonDesc->bLength <= descEnd)
    {
        dumpUnknown = FALSE;

        switch (commonDesc->bDescriptorType)
        {
            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_CONFIGURATION_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpConfigurationDescriptor((PUSB_CONFIGURATION_DESCRIPTOR)commonDesc);
                break;

            case USB_INTERFACE_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpInterfaceDescriptor((PUSB_INTERFACE_DESCRIPTOR)commonDesc);
                break;

            case USB_ENDPOINT_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_ENDPOINT_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpEndpointDescriptor((PUSB_ENDPOINT_DESCRIPTOR)commonDesc);
                break;

            default:
                dumpUnknown = TRUE;
                break;
        }

        if (dumpUnknown)
        {
            // DumpUnknownDescriptor(commonDesc);
        }

        (PUCHAR)commonDesc += commonDesc->bLength;
    }
}


//*****************************************************************************
//
// DumpConfigurationDescriptor()
//
//*****************************************************************************

VOID
DumpConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    DBGPRINT(3, ("-------------------------\n"));
    DBGPRINT(3, ("Configuration Descriptor:\n"));

    DBGPRINT(3, ("wTotalLength:       0x%04X\n",
                 ConfigDesc->wTotalLength));

    DBGPRINT(3, ("bNumInterfaces:       0x%02X\n",
                 ConfigDesc->bNumInterfaces));

    DBGPRINT(3, ("bConfigurationValue:  0x%02X\n",
                 ConfigDesc->bConfigurationValue));

    DBGPRINT(3, ("iConfiguration:       0x%02X\n",
                 ConfigDesc->iConfiguration));

    DBGPRINT(3, ("bmAttributes:         0x%02X\n",
                 ConfigDesc->bmAttributes));

    if (ConfigDesc->bmAttributes & 0x80)
    {
        DBGPRINT(3, ("  Bus Powered\n"));
    }

    if (ConfigDesc->bmAttributes & 0x40)
    {
        DBGPRINT(3, ("  Self Powered\n"));
    }

    if (ConfigDesc->bmAttributes & 0x20)
    {
        DBGPRINT(3, ("  Remote Wakeup\n"));
    }

    DBGPRINT(3, ("MaxPower:             0x%02X (%d Ma)\n",
                 ConfigDesc->MaxPower,
                 ConfigDesc->MaxPower * 2));

}

//*****************************************************************************
//
// DumpInterfaceDescriptor()
//
//*****************************************************************************

VOID
DumpInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
)
{
    DBGPRINT(3, ("---------------------\n"));
    DBGPRINT(3, ("Interface Descriptor:\n"));

    DBGPRINT(3, ("bInterfaceNumber:     0x%02X\n",
                 InterfaceDesc->bInterfaceNumber));

    DBGPRINT(3, ("bAlternateSetting:    0x%02X\n",
                 InterfaceDesc->bAlternateSetting));

    DBGPRINT(3, ("bNumEndpoints:        0x%02X\n",
                 InterfaceDesc->bNumEndpoints));

    DBGPRINT(3, ("bInterfaceClass:      0x%02X\n",
                 InterfaceDesc->bInterfaceClass));

    DBGPRINT(3, ("bInterfaceSubClass:   0x%02X\n",
                 InterfaceDesc->bInterfaceSubClass));

    DBGPRINT(3, ("bInterfaceProtocol:   0x%02X\n",
                 InterfaceDesc->bInterfaceProtocol));

    DBGPRINT(3, ("iInterface:           0x%02X\n",
                 InterfaceDesc->iInterface));

}

//*****************************************************************************
//
// DumpEndpointDescriptor()
//
//*****************************************************************************

VOID
DumpEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
)
{
    DBGPRINT(3, ("--------------------\n"));
    DBGPRINT(3, ("Endpoint Descriptor:\n"));

    DBGPRINT(3, ("bEndpointAddress:     0x%02X\n",
                 EndpointDesc->bEndpointAddress));

    switch (EndpointDesc->bmAttributes & 0x03)
    {
        case 0x00:
            DBGPRINT(3, ("Transfer Type:     Control\n"));
            break;

        case 0x01:
            DBGPRINT(3, ("Transfer Type: Isochronous\n"));
            break;

        case 0x02:
            DBGPRINT(3, ("Transfer Type:        Bulk\n"));
            break;

        case 0x03:
            DBGPRINT(3, ("Transfer Type:   Interrupt\n"));
            break;
    }

    DBGPRINT(3, ("wMaxPacketSize:     0x%04X (%d)\n",
                 EndpointDesc->wMaxPacketSize,
                 EndpointDesc->wMaxPacketSize));

    DBGPRINT(3, ("bInterval:            0x%02X\n",
                 EndpointDesc->bInterval));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbmass\dbg.h ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    DBG.H

Abstract:

    Header file for USBSTOR driver debug utility functions

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#if DBG
  #if defined(DEBUG_LOG)
    #undef DEBUG_LOG
  #endif
  #define DEBUG_LOG 1
#else
  #if !defined(DEBUG_LOG)
    #define DEBUG_LOG 0
  #endif
#endif


#if !DBG

#define DBGFBRK(flag)
#define DBGPRINT(level, _x_)

#else

#define DBGF_BRK_DRIVERENTRY            0x00000001
#define DBGF_BRK_UNLOAD                 0x00000002
#define DBGF_BRK_ADDDEVICE              0x00000004
#define DBGF_BRK_REMOVEDEVICE           0x00000008
#define DBGF_BRK_STARTDEVICE            0x00000010
#define DBGF_BRK_STOPDEVICE             0x00000020
#define DBGF_BRK_QUERYSTOPDEVICE        0x00000040
#define DBGF_BRK_CANCELSTOPDEVICE       0x00000080
#define DBGF_BRK_RESET                  0x00000100
#define DBGF_BRK_RESETPIPE              0x00000200
#define DBGF_BRK_CREATE                 0x00010000
#define DBGF_BRK_CLOSE                  0x00020000
#define DBGF_BRK_READWRITE              0x00040000
#define DBGF_BRK_IOCTL                  0x00080000
#define DBGF_BRK_SCSI                   0x00100000
#define DBGF_BRK_INVALID_REQ            0x00200000

#define DBGFBRK(flag) do { \
    if (USBSTOR_DriverGlobals.DebugFlags & flag) { \
        DbgBreakPoint(); \
    } \
} while (0)

#define DBGPRINT(level, _x_) do { \
    if (level <= USBSTOR_DriverGlobals.DebugLevel) { \
        KdPrint(("USBSTOR: ")); \
        KdPrint( _x_ ); \
    } \
} while (0)

#endif

#if !DEBUG_LOG

#define LOGINIT()
#define LOGUNINIT()
#define LOGENTRY(tag, info1, info2, info3)

#else

#define LOGSIZE 4096

#define LOGINIT() USBSTOR_LogInit()

#define LOGUNINIT() USBSTOR_LogUnInit()

#define LOGENTRY(tag, info1, info2, info3) \
   USBSTOR_LogEntry(((((tag) >> 24) & 0x000000FF) | \
                     (((tag) >>  8) & 0x0000FF00) | \
                     (((tag) <<  8) & 0x00FF0000) | \
                     (((tag) << 24) & 0xFF000000)), \
                    ((ULONG_PTR)info1),             \
                    ((ULONG_PTR)info2),             \
                    ((ULONG_PTR)info3))

#endif

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

#if DEBUG_LOG

typedef struct _USBSTOR_LOG_ENTRY {
    ULONG       le_tag;
    ULONG_PTR   le_info1;
    ULONG_PTR   le_info2;
    ULONG_PTR   le_info3;
} USBSTOR_LOG_ENTRY, *PUSBSTOR_LOG_ENTRY;

#endif

#if DBG || DEBUG_LOG

typedef struct _DRIVERGLOBALS
{
#if DBG
    ULONG               DebugFlags;     // DBGF_* Flags
    LONG                DebugLevel;     // Level of debug output
#endif
    PUSBSTOR_LOG_ENTRY  LogStart;       // Start of log buffer (older entries)
    PUSBSTOR_LOG_ENTRY  LogPtr;         // Current entry in log buffer
    PUSBSTOR_LOG_ENTRY  LogEnd;         // End of log buffer (newer entries)
    KSPIN_LOCK          LogSpinLock;    // Protects LogPtr

} DRIVERGLOBALS;

#endif

//*****************************************************************************
//
// G L O B A L S
//
//*****************************************************************************

//
// DBG.C
//

#if DBG || DEBUG_LOG

DRIVERGLOBALS USBSTOR_DriverGlobals;

#endif


//*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************

//
// DBG.C
//

#if DBG

VOID
USBSTOR_QueryGlobalParams (
    );

#endif

#if DEBUG_LOG

VOID
USBSTOR_LogInit (
);

VOID
USBSTOR_LogUnInit (
);

VOID
USBSTOR_LogEntry (
    IN ULONG     Tag,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
);

#endif

#if DBG

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
);

PCHAR
PowerMinorFunctionString (
    UCHAR MinorFunction
);

PCHAR
PowerDeviceStateString (
    DEVICE_POWER_STATE State
);

PCHAR
PowerSystemStateString (
    SYSTEM_POWER_STATE State
);

VOID
DumpDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
);

VOID
DumpConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
DumpConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
DumpInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
);

VOID
DumpEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbmass\usbmass.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    USBMASS.C

Abstract:

    This source file contains the DriverEntry() and AddDevice() entry points
    for the USBSTOR driver and the dispatch routines which handle:

    IRP_MJ_POWER
    IRP_MJ_SYSTEM_CONTROL
    IRP_MJ_PNP

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <ntddk.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <initguid.h>
#include <usbbusif.h>
#include <stdio.h>

#include "usbmass.h"

//*****************************************************************************
// L O C A L    F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************

NTSTATUS
USBSTOR_GetBusInterface (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PUSB_BUS_INTERFACE_USBDI_V1  BusInterface
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, USBSTOR_Unload)
#pragma alloc_text(PAGE, USBSTOR_AddDevice)
#pragma alloc_text(PAGE, USBSTOR_QueryFdoParams)
#pragma alloc_text(PAGE, USBSTOR_QueryGlobalFdoParams)
#pragma alloc_text(PAGE, USBSTOR_Power)
#pragma alloc_text(PAGE, USBSTOR_FdoSetPower)
#pragma alloc_text(PAGE, USBSTOR_SystemControl)
#pragma alloc_text(PAGE, USBSTOR_Pnp)
#pragma alloc_text(PAGE, USBSTOR_FdoStartDevice)
#pragma alloc_text(PAGE, USBSTOR_GetDescriptors)
#pragma alloc_text(PAGE, USBSTOR_GetStringDescriptors)
#pragma alloc_text(PAGE, USBSTOR_AdjustConfigurationDescriptor)
#pragma alloc_text(PAGE, USBSTOR_GetPipes)
#pragma alloc_text(PAGE, USBSTOR_CreateChildPDO)
#pragma alloc_text(PAGE, USBSTOR_FdoStopDevice)
#pragma alloc_text(PAGE, USBSTOR_FdoRemoveDevice)
#pragma alloc_text(PAGE, USBSTOR_FdoQueryStopRemoveDevice)
#pragma alloc_text(PAGE, USBSTOR_FdoCancelStopRemoveDevice)
#pragma alloc_text(PAGE, USBSTOR_FdoQueryDeviceRelations)
#pragma alloc_text(PAGE, USBSTOR_FdoQueryCapabilities)
#pragma alloc_text(PAGE, USBSTOR_PdoStartDevice)
#pragma alloc_text(PAGE, USBSTOR_PdoRemoveDevice)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryID)
#pragma alloc_text(PAGE, USBSTOR_PdoDeviceTypeString)
#pragma alloc_text(PAGE, USBSTOR_PdoGenericTypeString)
#pragma alloc_text(PAGE, CopyField)
#pragma alloc_text(PAGE, USBSTOR_StringArrayToMultiSz)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryDeviceId)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryHardwareIds)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryCompatibleIds)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryDeviceText)
#pragma alloc_text(PAGE, USBSTOR_PdoBusQueryInstanceId)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryDeviceRelations)
#pragma alloc_text(PAGE, USBSTOR_PdoQueryCapabilities)
#pragma alloc_text(PAGE, USBSTOR_SyncPassDownIrp)
#pragma alloc_text(PAGE, USBSTOR_SyncSendUsbRequest)
#pragma alloc_text(PAGE, USBSTOR_GetDescriptor)
#pragma alloc_text(PAGE, USBSTOR_GetMaxLun)
#pragma alloc_text(PAGE, USBSTOR_SelectConfiguration)
#pragma alloc_text(PAGE, USBSTOR_UnConfigure)
#pragma alloc_text(PAGE, USBSTOR_ResetPipe)
#pragma alloc_text(PAGE, USBSTOR_AbortPipe)
#pragma alloc_text(PAGE, USBSTOR_GetBusInterface)
#endif



//******************************************************************************
//
// DriverEntry()
//
//******************************************************************************

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{
    PAGED_CODE();

#if DBG
    // Query the registry for global parameters
    //
    USBSTOR_QueryGlobalParams();
#endif

    DBGPRINT(2, ("enter: DriverEntry\n"));

    DBGFBRK(DBGF_BRK_DRIVERENTRY);

    LOGINIT();

    //
    // Initialize the Driver Object with the driver's entry points
    //

    //
    // USBMASS.C
    //
    DriverObject->DriverUnload                          = USBSTOR_Unload;
    DriverObject->DriverExtension->AddDevice            = USBSTOR_AddDevice;

    //
    // OCRW.C
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = USBSTOR_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = USBSTOR_Close;
    DriverObject->MajorFunction[IRP_MJ_READ]            = USBSTOR_ReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]           = USBSTOR_ReadWrite;

    //
    // SCSI.C
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = USBSTOR_DeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SCSI]            = USBSTOR_Scsi;
    DriverObject->DriverStartIo                         = USBSTOR_StartIo;

    //
    // USBMASS.C
    //
    DriverObject->MajorFunction[IRP_MJ_POWER]           = USBSTOR_Power;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = USBSTOR_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = USBSTOR_Pnp;

    DBGPRINT(2, ("exit:  DriverEntry\n"));

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// USBSTOR_Unload()
//
//******************************************************************************

VOID
USBSTOR_Unload (
    IN PDRIVER_OBJECT   DriverObject
    )
{
    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_Unload\n"));

    LOGENTRY('UNLD', DriverObject, 0, 0);

    DBGFBRK(DBGF_BRK_UNLOAD);

    LOGUNINIT();

    DBGPRINT(2, ("exit:  USBSTOR_Unload\n"));
}

//******************************************************************************
//
// USBSTOR_AddDevice()
//
//******************************************************************************

NTSTATUS
USBSTOR_AddDevice (
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
{
    PDEVICE_OBJECT          deviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_AddDevice\n"));

    LOGENTRY('ADDD', DriverObject, PhysicalDeviceObject, 0);

    DBGFBRK(DBGF_BRK_ADDDEVICE);

    // Create the FDO
    //
    ntStatus = IoCreateDevice(DriverObject,
                              sizeof(FDO_DEVICE_EXTENSION),
                              NULL,
                              FILE_DEVICE_BUS_EXTENDER,
                              (FILE_AUTOGENERATED_DEVICE_NAME |
                               FILE_DEVICE_SECURE_OPEN),
                              FALSE,
                              &deviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

    // StartIo should not be called recursively and should be deferred until
    // the previous StartIo call returns to the IO manager.  This will prevent
    // a recursive stack overflow death if a device error occurs when there
    // are many requests queued on the device queue.
    //
    IoSetStartIoAttributes(deviceObject,
                           TRUE,            // DeferredStartIo
                           FALSE            // NonCancelable
                          );

    // Initialize the FDO DeviceExtension
    //
    fdoDeviceExtension = deviceObject->DeviceExtension;

    // Set all DeviceExtension pointers to NULL and all variable to zero
    //
    RtlZeroMemory(fdoDeviceExtension, sizeof(FDO_DEVICE_EXTENSION));

    // Tag this as the FDO on top of the USB PDO
    //
    fdoDeviceExtension->Type = USBSTOR_DO_TYPE_FDO;

    // Store a back point to the DeviceObject to which the DeviceExtension
    // is attached.
    //
    fdoDeviceExtension->FdoDeviceObject = deviceObject;

    // Remember our PDO
    //
    fdoDeviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;

    // Attach the FDO we created to the top of the PDO stack
    //
    fdoDeviceExtension->StackDeviceObject = IoAttachDeviceToDeviceStack(
                                                deviceObject,
                                                PhysicalDeviceObject);

    ASSERT(fdoDeviceExtension->StackDeviceObject != NULL);

    // Initialize the list of child PDOs
    //
    InitializeListHead(&fdoDeviceExtension->ChildPDOs);

    // Initialize to one in AddDevice, decrement by one in REMOVE_DEVICE
    //
    fdoDeviceExtension->PendingIoCount = 1;

    // Initialize the event which is set when OpenCount is decremented to zero.
    //
    KeInitializeEvent(&fdoDeviceExtension->RemoveEvent,
                      SynchronizationEvent,
                      FALSE);

    // Set the initial system and device power states
    //
    fdoDeviceExtension->SystemPowerState = PowerSystemWorking;
    fdoDeviceExtension->DevicePowerState = PowerDeviceD0;

    KeInitializeEvent(&fdoDeviceExtension->PowerDownEvent,
                      SynchronizationEvent,
                      FALSE);

    // Initialize the spinlock which protects the PDO DeviceFlags
    //
    KeInitializeSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock);

    KeInitializeEvent(&fdoDeviceExtension->CancelEvent,
                      SynchronizationEvent,
                      FALSE);

    // Initialize timeout timer
    //
    IoInitializeTimer(deviceObject, USBSTOR_TimerTick, NULL);

    USBSTOR_QueryFdoParams(deviceObject);

    fdoDeviceExtension->LastSenseWasReset = TRUE;

    deviceObject->Flags |=  DO_DIRECT_IO;
    deviceObject->Flags |=  DO_POWER_PAGABLE;
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    DBGPRINT(2, ("exit:  USBSTOR_AddDevice\n"));

    LOGENTRY('addd', deviceObject, fdoDeviceExtension,
             fdoDeviceExtension->StackDeviceObject);

    // Fail AddDevice if IoAttachDeviceToDeviceStack() failed.
    //
    if (fdoDeviceExtension->StackDeviceObject == NULL)
    {
        return STATUS_UNSUCCESSFUL;
    }
    else
    {
        return STATUS_SUCCESS;
    }
}

//******************************************************************************
//
// USBSTOR_QueryFdoParams()
//
// This is called at AddDevice() time when the FDO is being created to query
// device parameters from the registry.
//
//******************************************************************************

VOID
USBSTOR_QueryFdoParams (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION       fdoDeviceExtension;
    RTL_QUERY_REGISTRY_TABLE    paramTable[3];
    ULONG                       driverFlags;
    ULONG                       nonRemovable;
    HANDLE                      handle;
    NTSTATUS                    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_QueryFdoParams\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Set the default value in case the registry key does not exist.
    // Currently the flags are only used to specify the device protocol:
    // {Bulk-Only, Control/Bulk/Interrupt, Control/Bulk}
    //
    // If the driver is loaded during textmode setup then the registry key
    // will not yet exist.  That should be the only case in which the registry
    // key does not exist.  In this case DeviceProtocolUnspecified will be
    // treated as DeviceProtocolCB.  If that causes the first request to fail
    // then we will switch to DeviceProtocolBulkOnly.
    //
    driverFlags = DeviceProtocolUnspecified;

    nonRemovable = 0;

    ntStatus = IoOpenDeviceRegistryKey(
                   fdoDeviceExtension->PhysicalDeviceObject,
                   PLUGPLAY_REGKEY_DRIVER,
                   STANDARD_RIGHTS_ALL,
                   &handle);

    if (NT_SUCCESS(ntStatus))
    {
        RtlZeroMemory (&paramTable[0], sizeof(paramTable));

        paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name          = L"DriverFlags";
        paramTable[0].EntryContext  = &driverFlags;
        paramTable[0].DefaultType   = REG_BINARY;
        paramTable[0].DefaultData   = &driverFlags;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name          = L"NonRemovable";
        paramTable[1].EntryContext  = &nonRemovable;
        paramTable[1].DefaultType   = REG_BINARY;
        paramTable[1].DefaultData   = &nonRemovable;
        paramTable[1].DefaultLength = sizeof(ULONG);

        RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                               (PCWSTR)handle,
                               &paramTable[0],
                               NULL,           // Context
                               NULL);          // Environment

        ZwClose(handle);
    }

    if (driverFlags >= DeviceProtocolLast)
    {
        driverFlags = DeviceProtocolUnspecified;
    }

    fdoDeviceExtension->DriverFlags = driverFlags;

    fdoDeviceExtension->NonRemovable = nonRemovable;

    DBGPRINT(2, ("deviceFlags  %08X\n", driverFlags));

    DBGPRINT(2, ("nonRemovable %08X\n", nonRemovable));

    DBGPRINT(2, ("exit:  USBSTOR_QueryFdoParams\n"));
}

//******************************************************************************
//
// USBSTOR_QueryGlobalFdoParams()
//
// This is called at START_DEVICE time to query device parameters from
// the registry from a globabl key which is not device instance
// specific.
//
// It assumes that a valid Device Descriptor has already been retrieved
// from the device so the device idVendor and idProduct are already
// known.
//
//******************************************************************************

VOID
USBSTOR_QueryGlobalFdoParams (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION       fdoDeviceExtension;
    WCHAR                       path[] = L"usbstor\\vvvvpppp";
    USHORT                      idVendor;
    USHORT                      idProduct;
    ULONG                       i;
    static WCHAR                NibbleW[] = {'0','1','2','3','4','5','6','7',
                                             '8','9','a','b','c','d','e','f'};
    ULONG                       driverFlags;
    RTL_QUERY_REGISTRY_TABLE    paramTable[2];
    NTSTATUS                    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_QueryGlobalFdoParams\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // If we already know what the device protocol is then skip reading
    // the global setting from the registry.
    //
    if (fdoDeviceExtension->DriverFlags == DeviceProtocolUnspecified)
    {
        // Build the registry path string for the device
        //
        idVendor  = fdoDeviceExtension->DeviceDescriptor->idVendor;
        idProduct = fdoDeviceExtension->DeviceDescriptor->idProduct;

        i = sizeof("usbstor\\") - 1;

        path[i++] = NibbleW[idVendor >> 12];
        path[i++] = NibbleW[(idVendor >> 8) & 0x000f];
        path[i++] = NibbleW[(idVendor >> 4) & 0x000f];
        path[i++] = NibbleW[idVendor & 0x000f];

        path[i++] = NibbleW[idProduct >> 12];
        path[i++] = NibbleW[(idProduct >> 8) & 0x000f];
        path[i++] = NibbleW[(idProduct >> 4) & 0x000f];
        path[i++] = NibbleW[idProduct & 0x000f];

        // Set the default value
        //
        driverFlags = DeviceProtocolUnspecified;

        // Intialize the registry query table
        //
        RtlZeroMemory (&paramTable[0], sizeof(paramTable));

        paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name          = L"DriverFlags";
        paramTable[0].EntryContext  = &driverFlags;
        paramTable[0].DefaultType   = REG_BINARY;
        paramTable[0].DefaultData   = &driverFlags;
        paramTable[0].DefaultLength = sizeof(ULONG);

        ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL,
                                          path,
                                          &paramTable[0],
                                          NULL,           // Context
                                          NULL);          // Environment

        if (NT_SUCCESS(ntStatus) && driverFlags < DeviceProtocolLast)
        {
            fdoDeviceExtension->DriverFlags = driverFlags;
        }

        DBGPRINT(2, ("driverFlags  %08X\n", driverFlags));
    }
    
    DBGPRINT(2, ("exit:  USBSTOR_QueryGlobalFdoParams\n"));
}

//******************************************************************************
//
// USBSTOR_Power()
//
// Dispatch routine which handles IRP_MJ_POWER
//
//******************************************************************************

NTSTATUS
USBSTOR_Power (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: USBSTOR_Power %s %08X %08X %s\n",
                 (deviceExtension->Type == USBSTOR_DO_TYPE_FDO) ?
                 "FDO" : "PDO",
                 DeviceObject,
                 Irp,
                 PowerMinorFunctionString(irpStack->MinorFunction)));

    LOGENTRY('POWR', DeviceObject, Irp, irpStack->MinorFunction);

    if (irpStack->MinorFunction == IRP_MN_SET_POWER)
    {
        DBGPRINT(2, ("%s IRP_MN_SET_POWER %s\n",
                     (deviceExtension->Type == USBSTOR_DO_TYPE_FDO) ?
                     "FDO" : "PDO",
                     (irpStack->Parameters.Power.Type == SystemPowerState) ?
                     PowerSystemStateString(irpStack->Parameters.Power.State.SystemState) :
                     PowerDeviceStateString(irpStack->Parameters.Power.State.DeviceState)));
    }

    if (deviceExtension->Type == USBSTOR_DO_TYPE_FDO)
    {
        // This is an FDO attached to the USB PDO.
        //
        fdoDeviceExtension = (PFDO_DEVICE_EXTENSION)deviceExtension;

        if (irpStack->MinorFunction == IRP_MN_SET_POWER)
        {
            // Handle powering the FDO down and up...
            //
            ntStatus = USBSTOR_FdoSetPower(DeviceObject,
                                           Irp);
        }
        else
        {
            // No special processing for IRP_MN_QUERY_POWER, IRP_MN_WAIT_WAKE,
            // or IRP_MN_POWER_SEQUENCE at this time.  Just pass the request
            // down to the next lower driver now.
            //
            PoStartNextPowerIrp(Irp);

            IoSkipCurrentIrpStackLocation(Irp);

            ntStatus = PoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                    Irp);
        }
    }
    else
    {
        // This is a PDO enumerated by our FDO.

        if (irpStack->MinorFunction == IRP_MN_SET_POWER)
        {
            // Handle powering the PDO down and up...
            //
            ntStatus = USBSTOR_PdoSetPower(DeviceObject,
                                           Irp);
        }
        else
        {
            if (irpStack->MinorFunction == IRP_MN_QUERY_POWER)
            {
                // Always return SUCCESS for IRP_MN_QUERY_POWER for the PDO.
                //
                ntStatus = STATUS_SUCCESS;

                Irp->IoStatus.Status = ntStatus;
            }
            else
            {
                // No special processing for IRP_MN_WAIT_WAKE or
                // IRP_MN_POWER_SEQUENCE.  Just complete the request
                // now without changing the status.
                //
                ntStatus = Irp->IoStatus.Status;
            }

            PoStartNextPowerIrp(Irp);

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
    }

    DBGPRINT(2, ("exit:  USBSTOR_Power %08X\n", ntStatus));

    LOGENTRY('powr', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoSetPower()
//
// Dispatch routine which handles IRP_MJ_POWER, IRP_MN_SET_POWER for the FDO
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    POWER_STATE_TYPE        powerType;
    POWER_STATE             powerState;
    POWER_STATE             newState;
    BOOLEAN                 passRequest;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;

    powerState = irpStack->Parameters.Power.State;

    DBGPRINT(2, ("enter: USBSTOR_FdoSetPower %08X %s\n",
                 DeviceObject,
                 (powerType == SystemPowerState) ?
                 PowerSystemStateString(powerState.SystemState) :
                 PowerDeviceStateString(powerState.DeviceState)));

    LOGENTRY('FDSP', DeviceObject, Irp, irpStack->MinorFunction);

    // Pass the request down here, unless we request a device state power
    // Irp, in which case we pass the request down in our completion routine.
    //
    passRequest = TRUE;

    if (powerType == SystemPowerState)
    {
        // Remember the current system state.
        //
        fdoDeviceExtension->SystemPowerState = powerState.SystemState;

        // Map the new system state to a new device state
        //
        if (powerState.SystemState != PowerSystemWorking)
        {
            newState.DeviceState = PowerDeviceD3;
        }
        else
        {
            newState.DeviceState = PowerDeviceD0;
        }

        // If the new device state is different than the current device
        // state, request a device state power Irp.
        //
        if (fdoDeviceExtension->DevicePowerState != newState.DeviceState)
        {
            DBGPRINT(2, ("Requesting power Irp %08X %08X from %s to %s\n",
                         DeviceObject, Irp,
                         PowerDeviceStateString(fdoDeviceExtension->DevicePowerState),
                         PowerDeviceStateString(newState.DeviceState)));

            ASSERT(fdoDeviceExtension->CurrentPowerIrp == NULL);

            fdoDeviceExtension->CurrentPowerIrp = Irp;

            ntStatus = PoRequestPowerIrp(fdoDeviceExtension->PhysicalDeviceObject,
                                         IRP_MN_SET_POWER,
                                         newState,
                                         USBSTOR_FdoSetPowerCompletion,
                                         DeviceObject,
                                         NULL);

            passRequest = FALSE;
        }
    }
    else if (powerType == DevicePowerState)
    {
        POWER_STATE oldState;

        DBGPRINT(2, ("Received power Irp %08X %08X from %s to %s\n",
                     DeviceObject, Irp,
                     PowerDeviceStateString(fdoDeviceExtension->DevicePowerState),
                     PowerDeviceStateString(powerState.DeviceState)));

        // Update the current device state.
        //
        oldState.DeviceState = fdoDeviceExtension->DevicePowerState;
        fdoDeviceExtension->DevicePowerState = powerState.DeviceState;

        if (oldState.DeviceState == PowerDeviceD0 &&
            powerState.DeviceState > PowerDeviceD0)
        {
            // Powering down.  Stick this Irp in the device queue and
            // then wait.  When USBSTOR_StartIo() pulls this Irp out
            // of the device queue, we'll know that no transfer requests
            // are active at that time and then this power Irp can be
            // passed down the stack.

            ULONG zero;

            DBGPRINT(2, ("FDO Powering Down\n"));

            LOGENTRY('PWRD', DeviceObject, Irp, 0);

            zero = 0;  // Front of the queue please

            IoStartPacket(DeviceObject,
                          Irp,
                          &zero,
                          NULL);

            KeWaitForSingleObject(&fdoDeviceExtension->PowerDownEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        else if (oldState.DeviceState > PowerDeviceD0 &&
                 powerState.DeviceState == PowerDeviceD0)
        {
            DBGPRINT(2, ("PDO Powering Up\n"));

            LOGENTRY('PWRU', DeviceObject, Irp, 0);

            IoCopyCurrentIrpStackLocationToNext(Irp);

            IoSetCompletionRoutine(Irp,
                                   USBSTOR_FdoSetPowerD0Completion,
                                   NULL,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            ntStatus = PoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                    Irp);

            passRequest = FALSE;

        }
    }

    if (passRequest)
    {
        //
        // Pass the request down to the next lower driver
        //
        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                Irp);
    }

    DBGPRINT(2, ("exit:  USBSTOR_FdoSetPower %08X\n", ntStatus));

    LOGENTRY('fdsp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoSetPowerCompletion()
//
// Completion routine for PoRequestPowerIrp() in USBSTOR_FdoSetPower.
//
// The purpose of this routine is to block passing down the SystemPowerState
// Irp until the requested DevicePowerState Irp completes.
//
//******************************************************************************

VOID
USBSTOR_FdoSetPowerCompletion(
    IN PDEVICE_OBJECT   PdoDeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIRP                    irp;
    NTSTATUS                ntStatus;

    fdoDeviceObject = (PDEVICE_OBJECT)Context;

    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    ASSERT(fdoDeviceExtension->CurrentPowerIrp != NULL);

    irp = fdoDeviceExtension->CurrentPowerIrp;

    fdoDeviceExtension->CurrentPowerIrp = NULL;

#if DBG
    {
        PIO_STACK_LOCATION  irpStack;
        SYSTEM_POWER_STATE  systemState;

        irpStack = IoGetCurrentIrpStackLocation(irp);

        systemState = irpStack->Parameters.Power.State.SystemState;

        ntStatus = IoStatus->Status;

        DBGPRINT(2, ("USBSTOR_FdoSetPowerCompletion %08X %08X %s %08X\n",
                     fdoDeviceObject, irp,
                     PowerSystemStateString(systemState),
                     ntStatus));

        LOGENTRY('fspc', fdoDeviceObject, systemState, ntStatus);
    }
#endif

    // The requested DevicePowerState Irp has completed.
    // Now pass down the SystemPowerState Irp which requested the
    // DevicePowerState Irp.

    PoStartNextPowerIrp(irp);

    IoCopyCurrentIrpStackLocationToNext(irp);

    // Mark the Irp pending since USBSTOR_FdoSetPower() would have
    // originally returned STATUS_PENDING after calling PoRequestPowerIrp().
    //
    IoMarkIrpPending(irp);

    ntStatus = PoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            irp);
}

//******************************************************************************
//
// USBSTOR_FdoSetPowerD0Completion()
//
// Completion routine used by USBSTOR_FdoSetPower when passing down a
// IRP_MN_SET_POWER DevicePowerState PowerDeviceD0 Irp for the FDO.
//
// The purpose of this routine is to delay unblocking the device queue
// until after the DevicePowerState PowerDeviceD0 Irp completes.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoSetPowerD0Completion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{

    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    DEVICE_POWER_STATE      deviceState;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceState = irpStack->Parameters.Power.State.DeviceState;
    ASSERT(deviceState == PowerDeviceD0);

    ntStatus = Irp->IoStatus.Status;

    DBGPRINT(2, ("USBSTOR_FdoSetPowerD0Completion %08X %08X %s %08X\n",
                 DeviceObject, Irp,
                 PowerDeviceStateString(deviceState),
                 ntStatus));

    LOGENTRY('fs0c', DeviceObject, deviceState, ntStatus);

    // Powering up.  Unblock the device queue which was left blocked
    // after USBSTOR_StartIo() passed down the power down Irp.

    KeRaiseIrql(DISPATCH_LEVEL, &irql);
    {
        IoStartNextPacket(DeviceObject, TRUE);
    }
    KeLowerIrql(irql);

    PoStartNextPowerIrp(Irp);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoSetPower()
//
// Dispatch routine which handles IRP_MJ_POWER, IRP_MN_SET_POWER for the PDO
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    POWER_STATE_TYPE        powerType;
    POWER_STATE             powerState;
    BOOLEAN                 completeRequest;
    NTSTATUS                ntStatus;

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;

    powerState = irpStack->Parameters.Power.State;

    DBGPRINT(2, ("enter: USBSTOR_PdoSetPower %08X %s\n",
                 DeviceObject,
                 (powerType == SystemPowerState) ?
                 PowerSystemStateString(powerState.SystemState) :
                 PowerDeviceStateString(powerState.DeviceState)));

    LOGENTRY('PDSP', DeviceObject, Irp, irpStack->MinorFunction);

    // Complete the request here and now with success, unless we are powering
    // up or down and need to wait before completing the request later.
    //
    completeRequest = TRUE;
    ntStatus = STATUS_SUCCESS;

    if (powerType == SystemPowerState)
    {
        POWER_STATE newState;

        // Update the current system state.
        //
        pdoDeviceExtension->SystemPowerState = powerState.SystemState;

        // Map the new system state to a new device state
        //
        if (powerState.SystemState != PowerSystemWorking)
        {
            newState.DeviceState = PowerDeviceD3;
        }
        else
        {
            newState.DeviceState = PowerDeviceD0;
        }

        // If the new device state is different than the current device
        // state, request a device state power Irp.
        //
        if (pdoDeviceExtension->DevicePowerState != newState.DeviceState)
        {
            DBGPRINT(2, ("Requesting power Irp %08X %08X from %s to %s\n",
                         DeviceObject, Irp,
                         PowerDeviceStateString(pdoDeviceExtension->DevicePowerState),
                         PowerDeviceStateString(newState.DeviceState)));

            ASSERT(pdoDeviceExtension->CurrentPowerIrp == NULL);

            pdoDeviceExtension->CurrentPowerIrp = Irp;

            ntStatus = PoRequestPowerIrp(DeviceObject,
                                         IRP_MN_SET_POWER,
                                         newState,
                                         USBSTOR_PdoSetPowerCompletion,
                                         NULL,
                                         NULL);

            ASSERT(ntStatus == STATUS_PENDING);

            // If PoRequestPowerIrp() failed to allocate a DevicePowerState Irp
            // then we need to complete the SystemPowerState Irp now.
            //
            if (!NT_SUCCESS(ntStatus))
            {
                completeRequest = TRUE;

                pdoDeviceExtension->CurrentPowerIrp = NULL;
            }
            else
            {
                completeRequest = FALSE;
            }
        }
    }
    else if (powerType == DevicePowerState)
    {
        POWER_STATE oldState;

        DBGPRINT(2, ("Received power Irp %08X %08X from %s to %s\n",
                     DeviceObject, Irp,
                     PowerDeviceStateString(pdoDeviceExtension->DevicePowerState),
                     PowerDeviceStateString(powerState.DeviceState)));

        // Update the current device state.
        //
        oldState.DeviceState = pdoDeviceExtension->DevicePowerState;
        pdoDeviceExtension->DevicePowerState = powerState.DeviceState;

        if (oldState.DeviceState == PowerDeviceD0 &&
            powerState.DeviceState > PowerDeviceD0)
        {
            // Powering down.

            DBGPRINT(2, ("PDO Powering Down\n"));

            LOGENTRY('pwrd', DeviceObject, Irp, 0);
        }
        else if (oldState.DeviceState > PowerDeviceD0 &&
                 powerState.DeviceState == PowerDeviceD0)
        {
            // Powering up.

            DBGPRINT(2, ("PDO Powering Up\n"));

            LOGENTRY('pwru', DeviceObject, Irp, 0);
        }
    }

    if (completeRequest)
    {
        Irp->IoStatus.Status = ntStatus;

        PoStartNextPowerIrp(Irp);

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  USBSTOR_PdoSetPower %08X\n", ntStatus));

    LOGENTRY('pdsp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoSetPowerCompletion()
//
// Completion routine for PoRequestPowerIrp() in USBSTOR_PdoSetPower.
//
// The purpose of this routine is to block completing the SystemPowerState
// Irp until the requested DevicePowerState Irp completes.
//
//******************************************************************************

VOID
USBSTOR_PdoSetPowerCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PIRP                    irp;

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    ASSERT(pdoDeviceExtension->CurrentPowerIrp != NULL);

    irp = pdoDeviceExtension->CurrentPowerIrp;

    pdoDeviceExtension->CurrentPowerIrp = NULL;

#if DBG
    {
        PIO_STACK_LOCATION  irpStack;
        SYSTEM_POWER_STATE  systemState;
        NTSTATUS            ntStatus;

        irpStack = IoGetCurrentIrpStackLocation(irp);

        systemState = irpStack->Parameters.Power.State.SystemState;

        ntStatus = IoStatus->Status;

        DBGPRINT(2, ("USBSTOR_PdoSetPowerCompletion %08X %08X %s %08X\n",
                     DeviceObject, irp,
                     PowerSystemStateString(systemState),
                     ntStatus));

        LOGENTRY('pspc', DeviceObject, systemState, ntStatus);
    }
#endif

    // The requested DevicePowerState Irp has completed.
    // Now complete the SystemPowerState Irp which requested the
    // DevicePowerState Irp.

    // Mark the Irp pending since USBSTOR_PdoSetPower() would have
    // originally returned STATUS_PENDING after calling PoRequestPowerIrp().
    //
    IoMarkIrpPending(irp);

    irp->IoStatus.Status = STATUS_SUCCESS;

    PoStartNextPowerIrp(irp);

    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

//******************************************************************************
//
// USBSTOR_SystemControl()
//
// Dispatch routine which handles IRP_MJ_SYSTEM_CONTROL
//
//******************************************************************************

NTSTATUS
USBSTOR_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: USBSTOR_SystemControl %2X\n", irpStack->MinorFunction));

    LOGENTRY('SYSC', DeviceObject, Irp, irpStack->MinorFunction);

    if (deviceExtension->Type == USBSTOR_DO_TYPE_FDO)
    {
        // This is an FDO attached to the USB PDO.
        //
        fdoDeviceExtension = DeviceObject->DeviceExtension;

        switch (irpStack->MinorFunction)
        {
            //
            // XXXXX Need to handle any of these?
            //

            default:
                //
                // Pass the request down to the next lower driver
                //
                IoSkipCurrentIrpStackLocation(Irp);

                ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                        Irp);
            break;
        }
    }
    else
    {
        // This is a PDO enumerated by our FDO.

        ntStatus = Irp->IoStatus.Status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  USBSTOR_SystemControl %08X\n", ntStatus));

    LOGENTRY('sysc', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_Pnp()
//
// Dispatch routine which handles IRP_MJ_PNP
//
//******************************************************************************

NTSTATUS
USBSTOR_Pnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: USBSTOR_Pnp %s\n",
                 PnPMinorFunctionString(irpStack->MinorFunction)));

    LOGENTRY('PNP ', DeviceObject, Irp, irpStack->MinorFunction);

    if (deviceExtension->Type == USBSTOR_DO_TYPE_FDO)
    {
        // This is an FDO attached to the USB PDO.
        // We have some real work to do.
        //
        fdoDeviceExtension = DeviceObject->DeviceExtension;

        switch (irpStack->MinorFunction)
        {
            case IRP_MN_START_DEVICE:
                ntStatus = USBSTOR_FdoStartDevice(DeviceObject, Irp);
                break;

            case IRP_MN_STOP_DEVICE:
                ntStatus = USBSTOR_FdoStopDevice(DeviceObject, Irp);
                break;

            case IRP_MN_REMOVE_DEVICE:
                ntStatus = USBSTOR_FdoRemoveDevice(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_STOP_DEVICE:
            case IRP_MN_QUERY_REMOVE_DEVICE:
                ntStatus = USBSTOR_FdoQueryStopRemoveDevice(DeviceObject, Irp);
                break;

            case IRP_MN_CANCEL_STOP_DEVICE:
            case IRP_MN_CANCEL_REMOVE_DEVICE:
                ntStatus = USBSTOR_FdoCancelStopRemoveDevice(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_DEVICE_RELATIONS:
                ntStatus = USBSTOR_FdoQueryDeviceRelations(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_CAPABILITIES:
                ntStatus = USBSTOR_FdoQueryCapabilities(DeviceObject, Irp);
                break;

            case IRP_MN_SURPRISE_REMOVAL:
                //
                // The documentation says to set the status before passing the
                // Irp down the stack
                //
                Irp->IoStatus.Status = STATUS_SUCCESS;

                // nothing else special yet, just fall through to default

            default:
                //
                // Pass the request down to the next lower driver
                //
                IoSkipCurrentIrpStackLocation(Irp);

                ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                        Irp);
                break;
        }
    }
    else
    {
        // This is a PDO enumerated by our FDO.
        // We don't have too much to do.
        //
        pdoDeviceExtension = DeviceObject->DeviceExtension;
        ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

        switch (irpStack->MinorFunction)
        {
            case IRP_MN_START_DEVICE:
                ntStatus = USBSTOR_PdoStartDevice(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_ID:
                ntStatus = USBSTOR_PdoQueryID(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_DEVICE_TEXT:
                ntStatus = USBSTOR_PdoQueryDeviceText(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_DEVICE_RELATIONS:
                ntStatus = USBSTOR_PdoQueryDeviceRelations(DeviceObject, Irp);
                break;

            case IRP_MN_QUERY_CAPABILITIES:
                ntStatus = USBSTOR_PdoQueryCapabilities(DeviceObject, Irp);
                break;

            case IRP_MN_REMOVE_DEVICE:
                ntStatus = USBSTOR_PdoRemoveDevice(DeviceObject, Irp);
                break;

            case IRP_MN_SURPRISE_REMOVAL:
            case IRP_MN_STOP_DEVICE:
            case IRP_MN_QUERY_STOP_DEVICE:
            case IRP_MN_QUERY_REMOVE_DEVICE:
            case IRP_MN_CANCEL_STOP_DEVICE:
            case IRP_MN_CANCEL_REMOVE_DEVICE:

            case IRP_MN_QUERY_PNP_DEVICE_STATE:

                // We have no value add for IRP_MN_QUERY_PNP_DEVICE_STATE
                // at the moment.  At some point we might have reason to
                // return PNP_DEVICE_REMOVED or PNP_DEVICE_FAILED.


                DBGPRINT(2, ("Succeeding PnP for Child PDO %s\n",
                             PnPMinorFunctionString(irpStack->MinorFunction)));

                ntStatus = STATUS_SUCCESS;
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;


            default:

                DBGPRINT(2, ("Unhandled PnP Irp for Child PDO %s\n",
                             PnPMinorFunctionString(irpStack->MinorFunction)));

                ntStatus = Irp->IoStatus.Status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
        }
    }

    DBGPRINT(2, ("exit:  USBSTOR_Pnp %08X\n", ntStatus));

    LOGENTRY('pnp ', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoStartDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_START_DEVICE for the FDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP must be handled first by the underlying bus driver for a device
// and then by each higher driver in the device stack.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoStartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION       fdoDeviceExtension;
    USB_BUS_INTERFACE_USBDI_V1  busInterface;
    NTSTATUS                    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_FdoStartDevice\n"));

    DBGFBRK(DBGF_BRK_STARTDEVICE);

    LOGENTRY('STRT', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    // Pass IRP_MN_START_DEVICE Irp down the stack first before we do anything.
    //
    ntStatus = USBSTOR_SyncPassDownIrp(DeviceObject,
                                       Irp);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_START_DEVICE\n"));
        goto USBSTOR_FdoStartDeviceDone;
    }

    // Allocate Reset Pipe / Reset Port IoWorkItem
    //
    if (fdoDeviceExtension->IoWorkItem == NULL)
    {
        fdoDeviceExtension->IoWorkItem = IoAllocateWorkItem(DeviceObject);

        if (fdoDeviceExtension->IoWorkItem == NULL)
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto USBSTOR_FdoStartDeviceDone;
        }
    }

    // If this is the first time the device as been started, retrieve the
    // Device and Configuration Descriptors from the device.
    //
    if (fdoDeviceExtension->DeviceDescriptor == NULL)
    {
        ntStatus = USBSTOR_GetDescriptors(DeviceObject);

        if (!NT_SUCCESS(ntStatus))
        {
            goto USBSTOR_FdoStartDeviceDone;
        }

        // Query any registry parameters that are global to all
        // instances of this device.
        //
        USBSTOR_QueryGlobalFdoParams(DeviceObject);
    }

    // Now configure the device
    //
    ntStatus = USBSTOR_SelectConfiguration(DeviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Configure device failed\n"));
        goto USBSTOR_FdoStartDeviceDone;
    }

    // If the driver is loaded during textmode setup then the registry
    // value won't exist yet to indicate what type of device this is.  If
    // the Interface Descriptor indicates that the device is a Bulk-Only
    // device then believe it.
    //
    if ((fdoDeviceExtension->InterfaceDescriptor->bInterfaceClass ==
         USB_DEVICE_CLASS_STORAGE) &&
        (fdoDeviceExtension->InterfaceDescriptor->bInterfaceProtocol ==
         USBSTOR_PROTOCOL_BULK_ONLY) &&
        (fdoDeviceExtension->DriverFlags == DeviceProtocolUnspecified))
    {
        fdoDeviceExtension->DriverFlags = DeviceProtocolBulkOnly;
    }

    // Find the bulk and interrupt pipes we'll use in this configuration.
    //
    ntStatus = USBSTOR_GetPipes(DeviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        goto USBSTOR_FdoStartDeviceDone;
    }

    // Enable hacks for certain revs of the Y-E Data USB Floppy
    //
    if (fdoDeviceExtension->DeviceDescriptor->idVendor  == 0x057B &&
        fdoDeviceExtension->DeviceDescriptor->idProduct == 0x0000 &&
        fdoDeviceExtension->DeviceDescriptor->bcdDevice  < 0x0128)
    {
        SET_FLAG(fdoDeviceExtension->DeviceHackFlags, DHF_FORCE_REQUEST_SENSE);
#if 0
        SET_FLAG(fdoDeviceExtension->DeviceHackFlags, DHF_TUR_START_UNIT);
        SET_FLAG(fdoDeviceExtension->DeviceHackFlags, DHF_MEDIUM_CHANGE_RESET);
#endif
    }

    // Start timeout timer
    //
    IoStartTimer(DeviceObject);

    // Everything looks good so far, go ahead and create the list of
    // child PDOs if this is the first time we have been started and
    // the list is empty.
    //
    if (IsListEmpty(&fdoDeviceExtension->ChildPDOs))
    {
        UCHAR   maxLun;
        UCHAR   lun;

        maxLun = 0;

        // Only check devices which claim to be USB Mass Storage Class
        // Bulk-Only spec compliant for Multiple LUN support.
        //
        if ((fdoDeviceExtension->InterfaceDescriptor->bInterfaceClass ==
             USB_DEVICE_CLASS_STORAGE) &&
            (fdoDeviceExtension->InterfaceDescriptor->bInterfaceProtocol ==
             USBSTOR_PROTOCOL_BULK_ONLY))
        {
            // See if the device supports Multiple LUNs
            //
            ntStatus = USBSTOR_GetMaxLun(DeviceObject,
                                         &maxLun);

            if (NT_SUCCESS(ntStatus))
            {
                DBGPRINT(1, ("GetMaxLun returned %02x\n", maxLun));

                // We need to provide a unique InstanceID for each logical unit.
                // We use the device USB SerialNumber string as part of the
                // unique InstanceID.  Without a device USB SerialNumber string
                // we can't support multiple logical units on the device.
                //
                // The Bulk-Only USB Mass Storage class specification requires
                // a SerialNumber string so if the device does not have one it
                // is not really spec compliant anyway.
                //
                if (fdoDeviceExtension->SerialNumber == NULL)
                {
                    DBGPRINT(1, ("Multiple Lun but no SerialNumber!\n"));

                    maxLun = 0;
                }
            }
        }

        for (lun = 0; lun <= maxLun; lun++)
        {
            ntStatus = USBSTOR_CreateChildPDO(DeviceObject, lun);

            if (!NT_SUCCESS(ntStatus))
            {
                DBGPRINT(1, ("Create Child PDO %d failed\n", lun));
                goto USBSTOR_FdoStartDeviceDone;
            }
        }
    }

    if (NT_SUCCESS(USBSTOR_GetBusInterface(DeviceObject, &busInterface)))
    {
        fdoDeviceExtension->DeviceIsHighSpeed =
            busInterface.IsDeviceHighSpeed(busInterface.BusContext);

        DBGPRINT(1, ("DeviceIsHighSpeed: %s\n",
                     fdoDeviceExtension->DeviceIsHighSpeed ? "TRUE" : "FALSE"));
    }
    else
    {
        fdoDeviceExtension->DeviceIsHighSpeed = FALSE;
    }

USBSTOR_FdoStartDeviceDone:

    // Must complete request since completion routine returned
    // STATUS_MORE_PROCESSING_REQUIRED
    //
    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_FdoStartDevice %08X\n", ntStatus));

    LOGENTRY('strt', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_GetDescriptors()
//
// This routine is called at START_DEVICE time for the FDO to retrieve the
// Device and Configurations descriptors from the device and store them in
// the device extension.
//
//******************************************************************************

NTSTATUS
USBSTOR_GetDescriptors (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PUCHAR                  descriptor;
    ULONG                   descriptorLength;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_GetDescriptors\n"));

    LOGENTRY('GDSC', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    //
    // Get Device Descriptor
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_DEVICE_DESCRIPTOR_TYPE,
                                     0,  // Index
                                     0,  // LanguageId
                                     2,  // RetryCount
                                     sizeof(USB_DEVICE_DESCRIPTOR),
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Device Descriptor failed\n"));
        goto USBSTOR_GetDescriptorsDone;
    }

    ASSERT(fdoDeviceExtension->DeviceDescriptor == NULL);
    fdoDeviceExtension->DeviceDescriptor = (PUSB_DEVICE_DESCRIPTOR)descriptor;

    //
    // Get Configuration Descriptor (just the Configuration Descriptor)
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                     0,  // Index
                                     0,  // LanguageId
                                     2,  // RetryCount
                                     sizeof(USB_CONFIGURATION_DESCRIPTOR),
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Configuration Descriptor failed (1)\n"));
        goto USBSTOR_GetDescriptorsDone;
    }

    descriptorLength = ((PUSB_CONFIGURATION_DESCRIPTOR)descriptor)->wTotalLength;

    ExFreePool(descriptor);

    if (descriptorLength < sizeof(USB_CONFIGURATION_DESCRIPTOR))
    {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        DBGPRINT(1, ("Get Configuration Descriptor failed (2)\n"));
        goto USBSTOR_GetDescriptorsDone;
    }

    //
    // Get Configuration Descriptor (and Interface and Endpoint Descriptors)
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                     0,  // Index
                                     0,  // LanguageId
                                     2,  // RetryCount
                                     descriptorLength,
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Configuration Descriptor failed (3)\n"));
        goto USBSTOR_GetDescriptorsDone;
    }

    ASSERT(fdoDeviceExtension->ConfigurationDescriptor == NULL);
    fdoDeviceExtension->ConfigurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)descriptor;

    //
    // Get the Serial Number String Descriptor, if there is one
    //
    if (fdoDeviceExtension->DeviceDescriptor->iSerialNumber)
    {
        USBSTOR_GetStringDescriptors(DeviceObject);
    }

#if DBG
    DumpDeviceDesc(fdoDeviceExtension->DeviceDescriptor);
    DumpConfigDesc(fdoDeviceExtension->ConfigurationDescriptor);
#endif

USBSTOR_GetDescriptorsDone:

    DBGPRINT(2, ("exit:  USBSTOR_GetDescriptors %08X\n", ntStatus));

    LOGENTRY('gdsc', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_GetStringDescriptors()
//
// This routine is called at START_DEVICE time for the FDO to retrieve the
// Serial Number string descriptor from the device and store it in
// the device extension.
//
//******************************************************************************

USBSTOR_GetStringDescriptors (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PUCHAR                  descriptor;
    ULONG                   descriptorLength;
    USHORT                  languageId;
    ULONG                   i, numIds;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_GetStringDescriptors\n"));

    LOGENTRY('GSDC', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    //
    // Get the list of Language IDs (descriptor header only)
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     0,  // Index
                                     0,  // LanguageId
                                     2,  // RetryCount
                                     sizeof(USB_COMMON_DESCRIPTOR),
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Language IDs failed (1) %08X\n", ntStatus));
        goto USBSTOR_GetStringDescriptorsDone;
    }

    descriptorLength = ((PUSB_COMMON_DESCRIPTOR)descriptor)->bLength;

    ExFreePool(descriptor);

    if ((descriptorLength < sizeof(USB_COMMON_DESCRIPTOR) + sizeof(USHORT)) ||
        (descriptorLength & 1))
    {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        DBGPRINT(1, ("Get Language IDs failed (2) %d\n", descriptorLength));
        goto USBSTOR_GetStringDescriptorsDone;
    }

    //
    // Get the list of Language IDs (complete descriptor)
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     0,  // Index
                                     0,  // LanguageId
                                     2,  // RetryCount
                                     descriptorLength,
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Language IDs failed (3) %08X\n", ntStatus));
        goto USBSTOR_GetStringDescriptorsDone;
    }

    // Search the list of LanguageIDs for US-English (0x0409).  If we find
    // it in the list, that's the LanguageID we'll use.  Else just default
    // to the first LanguageID in the list.

    numIds = (descriptorLength - sizeof(USB_COMMON_DESCRIPTOR)) / sizeof(USHORT);

    languageId = ((PUSHORT)descriptor)[1];

    for (i = 2; i <= numIds; i++)
    {
        if (((PUSHORT)descriptor)[i] == 0x0409)
        {
            languageId = 0x0409;
            break;
        }
    }

    ExFreePool(descriptor);

    //
    // Get the Serial Number (descriptor header only)
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     fdoDeviceExtension->DeviceDescriptor->iSerialNumber,
                                     languageId,
                                     2,  // RetryCount
                                     sizeof(USB_COMMON_DESCRIPTOR),
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Serial Number failed (1) %08X\n", ntStatus));
        goto USBSTOR_GetStringDescriptorsDone;
    }

    descriptorLength = ((PUSB_COMMON_DESCRIPTOR)descriptor)->bLength;

    ExFreePool(descriptor);

    if ((descriptorLength < sizeof(USB_COMMON_DESCRIPTOR) + sizeof(USHORT)) ||
        (descriptorLength & 1))
    {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        DBGPRINT(1, ("Get Serial Number failed (2) %d\n", descriptorLength));
        goto USBSTOR_GetStringDescriptorsDone;
    }

    //
    // Get the Serial Number (complete descriptor)
    //
    ntStatus = USBSTOR_GetDescriptor(DeviceObject,
                                     USB_RECIPIENT_DEVICE,
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     fdoDeviceExtension->DeviceDescriptor->iSerialNumber,
                                     languageId,
                                     2,  // RetryCount
                                     descriptorLength,
                                     &descriptor);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Get Serial Number failed (3) %08X\n", ntStatus));
        goto USBSTOR_GetStringDescriptorsDone;
    }

    ASSERT(fdoDeviceExtension->SerialNumber == NULL);
    fdoDeviceExtension->SerialNumber = (PUSB_STRING_DESCRIPTOR)descriptor;

USBSTOR_GetStringDescriptorsDone:

    DBGPRINT(2, ("exit:  USBSTOR_GetStringDescriptors %08X %08X\n",
                 ntStatus, fdoDeviceExtension->SerialNumber));

    LOGENTRY('gdsc', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_AdjustConfigurationDescriptor()
//
// This routine is called at START_DEVICE time for the FDO to adjust the
// Configuration Descriptor, if necessary.
//
// Removes Endpoint Descriptors we won't use.  The Configuration Descriptor
// is modified in place.
//
//******************************************************************************

VOID
USBSTOR_AdjustConfigurationDescriptor (
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc,
    OUT PUSB_INTERFACE_DESCRIPTOR      *InterfaceDesc,
    OUT PLONG                           BulkInIndex,
    OUT PLONG                           BulkOutIndex,
    OUT PLONG                           InterruptInIndex
    )
{
    PFDO_DEVICE_EXTENSION       fdoDeviceExtension;
    PUCHAR                      descEnd;
    PUSB_COMMON_DESCRIPTOR      commonDesc;
    PUSB_INTERFACE_DESCRIPTOR   interfaceDesc;
    PUSB_ENDPOINT_DESCRIPTOR    endpointDesc;
    LONG                        endpointIndex;
    BOOLEAN                     removeEndpoint;

    PAGED_CODE();

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

    commonDesc = (PUSB_COMMON_DESCRIPTOR)ConfigDesc;

    interfaceDesc = NULL;

    *BulkInIndex      = -1;
    *BulkOutIndex     = -1;
    *InterruptInIndex = -1;

    endpointIndex = 0;

    while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
           (PUCHAR)commonDesc + commonDesc->bLength <= descEnd)
    {
        // Is this an Interface Descriptor?
        //
        if ((commonDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE) &&
            (commonDesc->bLength         == sizeof(USB_INTERFACE_DESCRIPTOR)))
        {
            // Only bother looking at the first Interface Descriptor
            //
            if (interfaceDesc != NULL)
            {
                break;
            }

            // Remember the first Interface Descriptor we have seen
            //
            interfaceDesc = (PUSB_INTERFACE_DESCRIPTOR)commonDesc;
        }

        // Is this an Endpoint Descriptor?
        //
        if ((commonDesc->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE) &&
            (commonDesc->bLength         == sizeof(USB_ENDPOINT_DESCRIPTOR)) &&
            (interfaceDesc != NULL))
        {
            endpointDesc = (PUSB_ENDPOINT_DESCRIPTOR)commonDesc;

#if 0
            removeEndpoint = TRUE;
#else
            // There is currently a bug in the composite parent driver
            // that doesn't handle the case where the number of
            // endpoints in an Interface Descriptor differs from the
            // Interface Descriptor originally returned by the deivce.
            // Until that bug is fixed avoid the bug by not stripping
            // out endpoints that won't be used.
            //
            removeEndpoint = FALSE;
#endif
            if (((endpointDesc->bmAttributes & USB_ENDPOINT_TYPE_MASK) ==
                 USB_ENDPOINT_TYPE_BULK) &&
                (USB_ENDPOINT_DIRECTION_IN(endpointDesc->bEndpointAddress)))
            {
                if (*BulkInIndex == -1)
                {
                    *BulkInIndex   = endpointIndex;
                    removeEndpoint = FALSE;
                }
            }
            else if (((endpointDesc->bmAttributes & USB_ENDPOINT_TYPE_MASK) ==
                 USB_ENDPOINT_TYPE_BULK) &&
                (USB_ENDPOINT_DIRECTION_OUT(endpointDesc->bEndpointAddress)))
            {
                if (*BulkOutIndex == -1)
                {
                    *BulkOutIndex  = endpointIndex;
                    removeEndpoint = FALSE;
                }
            }
            else if (((endpointDesc->bmAttributes & USB_ENDPOINT_TYPE_MASK) ==
                 USB_ENDPOINT_TYPE_INTERRUPT) &&
                (USB_ENDPOINT_DIRECTION_IN(endpointDesc->bEndpointAddress)))
            {
                // Only keep the Interrupt endpoint if we know for sure
                // that the device is a CBI device.  Don't trust the
                // bInterfaceProtocol value of the device.  Devices can lie.
                //
                if ((*InterruptInIndex == -1) &&
                    (fdoDeviceExtension->DriverFlags == DeviceProtocolCBI))
                {
                    *InterruptInIndex = endpointIndex;
                    removeEndpoint    = FALSE;
                }
            }

            if (removeEndpoint)
            {
                // Remove this endpoint, we won't use it.
                //
                DBGPRINT(1, ("Removing Endpoint addr %02X, attr %02X\n",
                             endpointDesc->bEndpointAddress,
                             endpointDesc->bmAttributes));

                RtlMoveMemory(endpointDesc,
                              endpointDesc + 1,
                              descEnd - (PUCHAR)(endpointDesc + 1));

                ConfigDesc->wTotalLength -= sizeof(USB_ENDPOINT_DESCRIPTOR);

                interfaceDesc->bNumEndpoints -= 1;

                descEnd -= sizeof(USB_ENDPOINT_DESCRIPTOR);

                continue;
            }
            else
            {
                DBGPRINT(1, ("Keeping Endpoint addr %02X, attr %02X\n",
                             endpointDesc->bEndpointAddress,
                             endpointDesc->bmAttributes));

                endpointIndex++;
            }
        }

        // Advance past this descriptor
        //
        (PUCHAR)commonDesc += commonDesc->bLength;
    }

    ASSERT(*BulkInIndex != -1);
    ASSERT(*BulkOutIndex != -1);
    ASSERT((*InterruptInIndex != -1) ==
           (fdoDeviceExtension->DriverFlags == DeviceProtocolCBI));

    *InterfaceDesc = interfaceDesc;
}

//******************************************************************************
//
// USBSTOR_GetPipes()
//
// This routine is called at START_DEVICE time find the Bulk IN, Bulk OUT,
// and Interrupt IN endpoints for the device.
//
//******************************************************************************

NTSTATUS
USBSTOR_GetPipes (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PUSBD_PIPE_INFORMATION  pipe;
    ULONG                   i;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_GetPipes\n"));

    LOGENTRY('GPIP', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    fdoDeviceExtension->BulkInPipe      = NULL;
    fdoDeviceExtension->BulkOutPipe     = NULL;
    fdoDeviceExtension->InterruptInPipe = NULL;

    // Find the Bulk IN, Bulk OUT, and Interrupt IN endpoints.
    //
    for (i=0; i<fdoDeviceExtension->InterfaceInfo->NumberOfPipes; i++)
    {
        pipe = &fdoDeviceExtension->InterfaceInfo->Pipes[i];

        if (pipe->PipeType == UsbdPipeTypeBulk)
        {
            if (USBD_PIPE_DIRECTION_IN(pipe) &&
                fdoDeviceExtension->BulkInPipe == NULL)
            {
                fdoDeviceExtension->BulkInPipe = pipe;
            }
            else if (!USBD_PIPE_DIRECTION_IN(pipe) &&
                     fdoDeviceExtension->BulkOutPipe == NULL)
            {
                fdoDeviceExtension->BulkOutPipe = pipe;
            }
        }
        else if (pipe->PipeType == UsbdPipeTypeInterrupt)
        {
            if (USBD_PIPE_DIRECTION_IN(pipe) &&
                fdoDeviceExtension->InterruptInPipe == NULL &&
                fdoDeviceExtension->DriverFlags == DeviceProtocolCBI)
            {
                fdoDeviceExtension->InterruptInPipe = pipe;
            }
        }
    }

    ntStatus = STATUS_SUCCESS;

    if (fdoDeviceExtension->BulkInPipe  == NULL)
    {
        DBGPRINT(1, ("Missing Bulk IN pipe\n"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (fdoDeviceExtension->BulkOutPipe == NULL)
    {
        DBGPRINT(1, ("Missing Bulk OUT pipe\n"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    DBGPRINT(2, ("exit:  USBSTOR_GetPipes %08X\n", ntStatus));

    LOGENTRY('gpip', ntStatus, fdoDeviceExtension->BulkInPipe,
             fdoDeviceExtension->BulkOutPipe);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_CreateChildPDO()
//
// This routine is called during START_DEVICE of the FDO to create the
// child PDO.  This is only called the first time the FDO is started,
// after the device has its USB configuration selected.
//
//******************************************************************************

NTSTATUS
USBSTOR_CreateChildPDO (
    IN PDEVICE_OBJECT   FdoDeviceObject,
    IN UCHAR            Lun
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          pdoDeviceObject;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_CreateChildPDO %d\n", Lun));

    LOGENTRY('CCPD', FdoDeviceObject, Lun, 0);

    fdoDeviceExtension = FdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Create the PDO
    //
    ntStatus = IoCreateDevice(FdoDeviceObject->DriverObject,
                              sizeof(PDO_DEVICE_EXTENSION),
                              NULL,
                              FILE_DEVICE_MASS_STORAGE,
                              (FILE_AUTOGENERATED_DEVICE_NAME |
                               FILE_DEVICE_SECURE_OPEN),
                              FALSE,
                              &pdoDeviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

    // The PDO and the FDO are effectively at the same stack level.
    // Irps directed at the PDO will sometimes be passed down with
    // IoCallDriver() to the FDO->StackDeviceObject.
    //
    pdoDeviceObject->StackSize = FdoDeviceObject->StackSize;

    // Initialize the PDO DeviceExtension
    //
    pdoDeviceExtension = pdoDeviceObject->DeviceExtension;

    // Set all DeviceExtension pointers to NULL and all variable to zero
    //
    RtlZeroMemory(pdoDeviceExtension, sizeof(PDO_DEVICE_EXTENSION));

    // Tag this as a PDO which is the child of an FDO
    //
    pdoDeviceExtension->Type = USBSTOR_DO_TYPE_PDO;

    // Point back to our own DeviceObject
    //
    pdoDeviceExtension->PdoDeviceObject = pdoDeviceObject;

    // Remember the PDO's parent FDO
    //
    pdoDeviceExtension->ParentFDO = FdoDeviceObject;

    // Set the initial system and device power states
    //
    pdoDeviceExtension->SystemPowerState = PowerSystemWorking;
    pdoDeviceExtension->DevicePowerState = PowerDeviceD0;

    // Initialize the PDO's PnP device state
    //
    pdoDeviceExtension->DeviceState = DeviceStateCreated;

    // Add the child PDO we just created to the parent's list of child PDOs
    //
    InsertTailList(&fdoDeviceExtension->ChildPDOs,
                   &pdoDeviceExtension->ListEntry);

    pdoDeviceObject->Flags |=  DO_DIRECT_IO;
    pdoDeviceObject->Flags |=  DO_POWER_PAGABLE;
    pdoDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    pdoDeviceExtension->LUN = Lun;

    // Get the Inquiry Data from the device
    //
    ntStatus = USBSTOR_GetInquiryData(pdoDeviceObject);

    // If the device is a DIRECT_ACCESS_DEVICE, see if it is a floppy
    //
    if (NT_SUCCESS(ntStatus))
    {
        PINQUIRYDATA inquiryData;

        inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

        if (inquiryData->DeviceType == DIRECT_ACCESS_DEVICE)
        {
            pdoDeviceExtension->IsFloppy = USBSTOR_IsFloppyDevice(pdoDeviceObject);
        }
    }

    DBGPRINT(2, ("exit:  USBSTOR_CreateChildPDO %08X\n", ntStatus));

    LOGENTRY('ccpd', FdoDeviceObject, pdoDeviceObject, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoStopDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_STOP_DEVICE for the FDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// The PnP Manager only sends this IRP if a prior IRP_MN_QUERY_STOP_DEVICE
// completed successfully.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
// A driver must set Irp->IoStatus.Status to STATUS_SUCCESS.  A driver must
// not fail this IRP.  If a driver cannot release the device's hardware
// resources, it can fail a query-stop IRP, but once it succeeds the query-stop
// request it must succeed the stop request.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoStopDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_FdoStopDevice\n"));

    LOGENTRY('STOP', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_STOPDEVICE);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    // Release the device resources allocated during IRP_MN_START_DEVICE
    //

    // Stop the timeout timer
    //
    IoStopTimer(DeviceObject);

    // Unconfigure the device
    //
    ntStatus = USBSTOR_UnConfigure(DeviceObject);

    // The documentation says to set the status before passing the
    // Irp down the stack
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    // Pass the IRP_MN_STOP_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            Irp);

    DBGPRINT(2, ("exit:  USBSTOR_FdoStopDevice %08X\n", ntStatus));

    LOGENTRY('stop', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE for the FDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
// A driver must set Irp->IoStatus.Status to STATUS_SUCCESS.  Drivers must not
// fail this IRP.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_FdoRemoveDevice\n"));

    LOGENTRY('REMV', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_REMOVEDEVICE);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    // Decrement by one to match the initial one in AddDevice
    //
    DECREMENT_PENDING_IO_COUNT(fdoDeviceExtension);

    LOGENTRY('rem1', DeviceObject, 0, 0);

    // Wait for all pending requests to complete
    //
    KeWaitForSingleObject(&fdoDeviceExtension->RemoveEvent,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    LOGENTRY('rem2', DeviceObject, 0, 0);

    // The child PDOs should have received REMOVE_DEVICE before the FDO.
    // Go ahead and delete them now.
    //
    while (!IsListEmpty(&fdoDeviceExtension->ChildPDOs))
    {
        PLIST_ENTRY             listEntry;
        PPDO_DEVICE_EXTENSION   pdoDeviceExtension;

        listEntry = RemoveTailList(&fdoDeviceExtension->ChildPDOs);

        pdoDeviceExtension = CONTAINING_RECORD(listEntry,
                                               PDO_DEVICE_EXTENSION,
                                               ListEntry);

        ASSERT(pdoDeviceExtension->DeviceState == DeviceStateCreated ||
               pdoDeviceExtension->DeviceState == DeviceStateRemoved);

        LOGENTRY('remc', DeviceObject, pdoDeviceExtension->PdoDeviceObject, 0);
        IoDeleteDevice(pdoDeviceExtension->PdoDeviceObject);
    }

    // Free everything that was allocated during IRP_MN_START_DEVICE
    //

    if (fdoDeviceExtension->IoWorkItem != NULL)
    {
        IoFreeWorkItem(fdoDeviceExtension->IoWorkItem);
    }

    if (fdoDeviceExtension->DeviceDescriptor != NULL)
    {
        ExFreePool(fdoDeviceExtension->DeviceDescriptor);
    }

    if (fdoDeviceExtension->ConfigurationDescriptor != NULL)
    {
        ExFreePool(fdoDeviceExtension->ConfigurationDescriptor);
    }

    if (fdoDeviceExtension->SerialNumber != NULL)
    {
        ExFreePool(fdoDeviceExtension->SerialNumber);
    }

    if (fdoDeviceExtension->InterfaceInfo != NULL)
    {
        ExFreePool(fdoDeviceExtension->InterfaceInfo);
    }

    // The documentation says to set the status before passing the Irp down
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    // Pass the IRP_MN_REMOVE_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            Irp);

    LOGENTRY('rem3', DeviceObject, 0, 0);

    // Free everything that was allocated during AddDevice
    //
    IoDetachDevice(fdoDeviceExtension->StackDeviceObject);

    IoDeleteDevice(DeviceObject);

    DBGPRINT(2, ("exit:  USBSTOR_FdoRemoveDevice %08X\n", ntStatus));

    LOGENTRY('remv', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoQueryStopRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_STOP_DEVICE and
// IRP_MN_QUERY_REMOVE_DEVICE for the FDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoQueryStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_FdoQueryStopRemoveDevice\n"));

    LOGENTRY('QSRD', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_QUERYSTOPDEVICE);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    // The documentation says to set the status before passing the Irp down
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    // Pass the IRP_MN_QUERY_STOP/REMOVE_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            Irp);

    DBGPRINT(2, ("exit:  USBSTOR_FdoQueryStopRemoveDevice %08X\n", ntStatus));

    LOGENTRY('qsrd', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoCancelStopRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_CANCEL_STOP_DEVICE and
// IRP_MN_CANCEL_REMOVE_DEVICE for the FDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP must be handled first by the underlying bus driver for a device
// and then by each higher driver in the device stack.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoCancelStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_FdoCancelStopRemoveDevice\n"));

    LOGENTRY('CSRD', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CANCELSTOPDEVICE);

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    // The documentation says to set the status before passing the Irp down
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    // Pass the IRP_MN_CANCEL_STOP/REMOVE_DEVICE Irp down the stack.
    //
    ntStatus = USBSTOR_SyncPassDownIrp(DeviceObject,
                                       Irp);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_CANCEL_STOP/REMOVE_DEVICE\n"));
        goto USBSTOR_CancelStopRemoveDeviceDone;
    }

USBSTOR_CancelStopRemoveDeviceDone:

    // Must complete request since completion routine returned
    // STATUS_MORE_PROCESSING_REQUIRED
    //
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_FdoCancelStopRemoveDevice %08X\n", ntStatus));

    LOGENTRY('csrd', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoQueryDeviceRelations()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_DEVICE_RELATIONS for the FDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoQueryDeviceRelations (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    DEVICE_RELATION_TYPE    relationType;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    fdoDeviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    relationType = irpStack->Parameters.QueryDeviceRelations.Type;

    DBGPRINT(2, ("enter: USBSTOR_FdoQueryDeviceRelations %d\n",
                 relationType));

    LOGENTRY('FQDR', DeviceObject, Irp, relationType);

    switch (relationType)
    {
        case BusRelations:

            if (!IsListEmpty(&fdoDeviceExtension->ChildPDOs))
            {
                // If we have children to return, add them to the existing
                // relation list, if there is one, else create and add them
                // to a new relation list.
                //
                // Then in either case, pass the request down the driver stack.
                //
                PDEVICE_RELATIONS   oldRelations;
                PDEVICE_RELATIONS   newRelations;
                PLIST_ENTRY         listHead;
                PLIST_ENTRY         listEntry;
                ULONG               oldCount;
                ULONG               childCount;
                ULONG               index;

                listHead = &fdoDeviceExtension->ChildPDOs;

                // How many children?
                //
                for (listEntry =  listHead->Flink,  childCount = 0;
                     listEntry != listHead;
                     listEntry =  listEntry->Flink, childCount++)
                     ;

                oldRelations = (PDEVICE_RELATIONS)Irp->IoStatus.Information;

                if (oldRelations)
                {
                    // Add our children to the existing relation list.

                    oldCount = oldRelations->Count;

                    // A DEVICE_RELATIONS structure has room for one
                    // PDEVICE_OBJECT to start with, so subtract that
                    // out of the size we allocate.
                    //
                    newRelations = ExAllocatePoolWithTag(
                                       PagedPool,
                                       sizeof(DEVICE_RELATIONS) +
                                       sizeof(PDEVICE_OBJECT) *
                                           (oldCount + childCount - 1),
                                       POOL_TAG);

                    if (newRelations)
                    {
                        // Copy the existing relation list
                        //
                        for (index = 0; index < oldCount; index++)
                        {
                            newRelations->Objects[index] =
                                oldRelations->Objects[index];
                        }
                    }

                    // Now we're done the the existing relation list, free it
                    //
                    ExFreePool(oldRelations);
                }
                else
                {
                    // Create a new relation list for our children

                    newRelations = ExAllocatePoolWithTag(
                                       PagedPool,
                                       sizeof(DEVICE_RELATIONS) +
                                       sizeof(PDEVICE_OBJECT) *
                                           (childCount - 1),
                                       POOL_TAG);

                    oldCount = 0;
                    index = 0;
                }

                if (newRelations)
                {
                    newRelations->Count = oldCount + childCount;

                    // Add our child relations at the end of the list
                    //
                    for (listEntry =  listHead->Flink;
                         listEntry != listHead;
                         listEntry =  listEntry->Flink)
                    {
                        PPDO_DEVICE_EXTENSION   pdoDeviceExtension;

                        pdoDeviceExtension = CONTAINING_RECORD(
                            listEntry,
                            PDO_DEVICE_EXTENSION,
                            ListEntry);

                        newRelations->Objects[index++] =
                            pdoDeviceExtension->PdoDeviceObject;

                        ObReferenceObject(pdoDeviceExtension->PdoDeviceObject);

                        DBGPRINT(2, ("returning ChildPDO %08X\n",
                                     pdoDeviceExtension->PdoDeviceObject));
                    }

                    ASSERT(index == oldCount + childCount);

                    ntStatus = STATUS_SUCCESS;
                    Irp->IoStatus.Status = ntStatus;
                    Irp->IoStatus.Information = (ULONG_PTR)newRelations;
                }
                else
                {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    Irp->IoStatus.Status = ntStatus;
                    Irp->IoStatus.Information = 0;
                }
            }
            else
            {
                // If we don't have a child to return, just pass the request
                // down without doing anything.
                //
                ntStatus = STATUS_SUCCESS;
            }
            break;

        case EjectionRelations:
        case PowerRelations:
        case RemovalRelations:
        case TargetDeviceRelation:
        default:
            //
            // Pass the request down the driver stack without doing anything.
            //
            ntStatus = STATUS_SUCCESS;
            break;
    }

    if (NT_SUCCESS(ntStatus))
    {
        // Pass the Irp down the driver stack if successful so far.
        //
        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                Irp);
    }
    else
    {
        // Unsuccessful, just complete the request now.
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  USBSTOR_FdoQueryDeviceRelations %08X\n", ntStatus));

    LOGENTRY('fqdr', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_FdoQueryCapabilities()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES for the FDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_FdoQueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PDEVICE_CAPABILITIES    deviceCapabilities;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    DBGPRINT(2, ("enter: USBSTOR_FdoQueryCapabilities\n"));

    LOGENTRY('FQCP', DeviceObject, Irp, 0);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceCapabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;

    // Pass IRP_MN_QUERY_CAPABILITIES Irp down the stack first before we do
    // anything.
    //
    ntStatus = USBSTOR_SyncPassDownIrp(DeviceObject,
                                       Irp);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_QUERY_CAPABILITIES\n"));
    }
    else
    {
        if (fdoDeviceExtension->NonRemovable)
        {
            deviceCapabilities->Removable = FALSE;
        }
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_FdoQueryCapabilities %08X\n", ntStatus));

    LOGENTRY('fqcp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoStartDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_START_DEVICE for the PDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoStartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoStartDevice\n"));

    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_PdoStartDevice %08X\n", ntStatus));

    LOGENTRY('pstr', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE for the PDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoRemoveDevice\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    pdoDeviceExtension->Claimed = FALSE;

    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_PdoRemoveDevice %08X\n", ntStatus));

    LOGENTRY('prmd', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoQueryID()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_ID for the PDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoQueryID (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    UNICODE_STRING          unicodeStr;
    BOOLEAN                 multiStrings;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryID\n"));

    LOGENTRY('PQID', DeviceObject, Irp, 0);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // Initialize return value to NULL
    //
    RtlInitUnicodeString(&unicodeStr, NULL);

    switch (irpStack->Parameters.QueryId.IdType)
    {
        case BusQueryDeviceID:

            ntStatus = USBSTOR_PdoQueryDeviceId(
                           DeviceObject,
                           &unicodeStr);

            multiStrings = FALSE;

            break;

        case BusQueryHardwareIDs:

            ntStatus = USBSTOR_PdoQueryHardwareIds(
                           DeviceObject,
                           &unicodeStr);

            multiStrings = TRUE;

            break;

        case BusQueryCompatibleIDs:

            ntStatus = USBSTOR_PdoQueryCompatibleIds(
                           DeviceObject,
                           &unicodeStr);

            multiStrings = TRUE;

            break;

        case BusQueryInstanceID:

            ntStatus = USBSTOR_PdoBusQueryInstanceId(
                           DeviceObject,
                           &unicodeStr);

            multiStrings = FALSE;

            break;

        default:
            ntStatus = STATUS_NOT_SUPPORTED;
            break;
    }

    if (NT_SUCCESS(ntStatus) && unicodeStr.Buffer)
    {
        PWCHAR idString;
        //
        // fix up all invalid characters
        //
        idString = unicodeStr.Buffer;

        while (*idString)
        {
            if ((*idString <= L' ')  ||
                (*idString > (WCHAR)0x7F) ||
                (*idString == L','))
            {
                *idString = L'_';
            }

            idString++;

            if ((*idString == L'\0') && multiStrings)
            {
                idString++;
            }
        }

        Irp->IoStatus.Information = (ULONG_PTR)unicodeStr.Buffer;
    }
    else
    {
        Irp->IoStatus.Information = (ULONG_PTR)NULL;
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryID %08X\n", ntStatus));

    LOGENTRY('pqid', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoDeviceTypeString()
//
// This routine returns a device type string for the PDO.
//
//******************************************************************************

PCHAR
USBSTOR_PdoDeviceTypeString (
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PINQUIRYDATA            inquiryData;

    PAGED_CODE();

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    switch (inquiryData->DeviceType)
    {
        case DIRECT_ACCESS_DEVICE:
            return pdoDeviceExtension->IsFloppy ? "SFloppy" : "Disk";

        case WRITE_ONCE_READ_MULTIPLE_DEVICE:
            return "Worm";

        case READ_ONLY_DIRECT_ACCESS_DEVICE:
            return "CdRom";

        case OPTICAL_DEVICE:
            return "Optical";

        case MEDIUM_CHANGER:
            return "Changer";

        case SEQUENTIAL_ACCESS_DEVICE:
            return "Sequential";

        default:
            return "Other";
    }
}

//******************************************************************************
//
// USBSTOR_PdoGenericTypeString()
//
// This routine returns a device type string for the PDO.
//
//******************************************************************************

PCHAR
USBSTOR_PdoGenericTypeString (
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PINQUIRYDATA            inquiryData;

    PAGED_CODE();

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    switch (inquiryData->DeviceType)
    {
        case DIRECT_ACCESS_DEVICE:
            return pdoDeviceExtension->IsFloppy ? "GenSFloppy" : "GenDisk";

        case WRITE_ONCE_READ_MULTIPLE_DEVICE:
            return "GenWorm";

        case READ_ONLY_DIRECT_ACCESS_DEVICE:
            return "GenCdRom";

        case OPTICAL_DEVICE:
            return "GenOptical";

        case MEDIUM_CHANGER:
            return "GenChanger";

        case SEQUENTIAL_ACCESS_DEVICE:
            return "GenSequential";

        default:
            return "UsbstorOther";
    }
}

//******************************************************************************
//
// CopyField()
//
// This routine will copy Count string bytes from Source to Destination.
// If it finds a nul byte in the Source it will translate that and any
// subsequent bytes into Change.  It will also replace spaces with the
// specified Change character.
//
//******************************************************************************

VOID
CopyField (
    IN PUCHAR   Destination,
    IN PUCHAR   Source,
    IN ULONG    Count,
    IN UCHAR    Change
    )
{
    ULONG   i;
    BOOLEAN pastEnd;

    PAGED_CODE();

    pastEnd = FALSE;

    for (i = 0; i < Count; i++)
    {
        if (!pastEnd)
        {
            if (Source[i] == 0)
            {
                pastEnd = TRUE;

                Destination[i] = Change;

            } else if (Source[i] == ' ')
            {
                Destination[i] = Change;
            } else
            {
                Destination[i] = Source[i];
            }
        }
        else
        {
            Destination[i] = Change;
        }
    }
    return;
}

//******************************************************************************
//
// USBSTOR_StringArrayToMultiSz()
//
// This routine will take a null terminated array of ascii strings and merge
// them together into a unicode multi-string block.
//
// This routine allocates memory for the string buffer - it is the caller's
// responsibility to free it.
//
//******************************************************************************

NTSTATUS
USBSTOR_StringArrayToMultiSz(
    PUNICODE_STRING MultiString,
    PCSTR           StringArray[]
    )
{
    ANSI_STRING     ansiEntry;
    UNICODE_STRING  unicodeEntry;
    UCHAR           i;
    NTSTATUS        ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_StringArrayToMultiSz %08X %08X\n",
                MultiString, StringArray));

    // Make sure we aren't going to leak any memory
    //
    ASSERT(MultiString->Buffer == NULL);

    RtlInitUnicodeString(MultiString, NULL);

    // First add up the sizes of the converted ascii strings to determine
    // how big the multisz will be.
    //
    for (i = 0; StringArray[i] != NULL; i++)
    {
        RtlInitAnsiString(&ansiEntry, StringArray[i]);

        MultiString->Length += (USHORT)RtlAnsiStringToUnicodeSize(&ansiEntry);
    }

    ASSERT(MultiString->Length != 0);

    // Add room for the double NULL terminator
    //
    MultiString->MaximumLength = MultiString->Length + sizeof(UNICODE_NULL);

    // Now allocate a buffer for the multisz
    //
    MultiString->Buffer = ExAllocatePoolWithTag(PagedPool,
                                                MultiString->MaximumLength,
                                                POOL_TAG);

    if (MultiString->Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(MultiString->Buffer, MultiString->MaximumLength);

    unicodeEntry = *MultiString;

    // Now convert each ascii string in the array into a unicode string
    // in the multisz
    //
    for (i = 0; StringArray[i] != NULL; i++)
    {
        RtlInitAnsiString(&ansiEntry, StringArray[i]);

        ntStatus = RtlAnsiStringToUnicodeString(&unicodeEntry,
                                                &ansiEntry,
                                                FALSE);

        // Since we're not allocating any memory the only failure possible
        // is if this function is bad

        ASSERT(NT_SUCCESS(ntStatus));

        // Push the buffer location up and reduce the maximum count
        //
        ((PSTR) unicodeEntry.Buffer) += unicodeEntry.Length + sizeof(WCHAR);
        unicodeEntry.MaximumLength   -= unicodeEntry.Length + sizeof(WCHAR);
    };

    DBGPRINT(2, ("exit:  USBSTOR_StringArrayToMultiSz\n"));

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// USBSTOR_PdoQueryDeviceId()
//
// This routine handles IRP_MN_QUERY_ID BusQueryDeviceID for the PDO.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoQueryDeviceId (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PINQUIRYDATA            inquiryData;
    UCHAR                   buffer[128];
    PUCHAR                  rawIdString;
    ANSI_STRING             ansiIdString;
    ULONG                   whichString;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryDeviceId\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    RtlZeroMemory(buffer, sizeof(buffer));

    rawIdString = USBSTOR_PdoDeviceTypeString(DeviceObject);

    sprintf(buffer, "USBSTOR\\%s", rawIdString);

    rawIdString = buffer + strlen(buffer);

    for (whichString = 0; whichString < 3; whichString++)
    {
        PUCHAR  headerString;
        PUCHAR  sourceString;
        ULONG   sourceStringLength;
        ULONG   i;

        switch (whichString)
        {
            //
            // Vendor Id
            //
            case 0:
                sourceString = inquiryData->VendorId;
                sourceStringLength = sizeof(inquiryData->VendorId);
                headerString = "Ven";
                break;

            //
            // Product Id
            //
            case 1:
                sourceString = inquiryData->ProductId;
                sourceStringLength = sizeof(inquiryData->ProductId);
                headerString = "Prod";
                break;

            //
            // Product Revision Level
            //
            case 2:
                sourceString = inquiryData->ProductRevisionLevel;
                sourceStringLength = sizeof(inquiryData->ProductRevisionLevel);
                headerString = "Rev";
                break;
        }

        //
        // Start at the end of the source string and back up until we find a
        // non-space, non-null character.
        //

        for (; sourceStringLength > 0; sourceStringLength--)
        {
            if((sourceString[sourceStringLength - 1] != ' ') &&
               (sourceString[sourceStringLength - 1] != '\0'))
            {
                break;
            }
        }

        //
        // Throw the header string into the block
        //

        sprintf(rawIdString, "&%s_", headerString);
        rawIdString += strlen(headerString) + 2;

        //
        // Spew the string into the device id
        //

        for(i = 0; i < sourceStringLength; i++)
        {
            *rawIdString = (sourceString[i] != ' ') ? (sourceString[i]) :
                                                      ('_');
            rawIdString++;
        }
    }

    RtlInitAnsiString(&ansiIdString, buffer);

    ntStatus = RtlAnsiStringToUnicodeString(UnicodeString, &ansiIdString, TRUE);

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryDeviceId %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoQueryHardwareIds()
//
// This routine handles IRP_MN_QUERY_ID BusQueryHardwareIDs for the PDO.
//
//******************************************************************************

#define NUMBER_HARDWARE_STRINGS 7

NTSTATUS
USBSTOR_PdoQueryHardwareIds (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PINQUIRYDATA            inquiryData;
    PUCHAR                  devTypeString;
    PUCHAR                  genTypeString;
    ULONG                   i;
    PSTR                    strings[NUMBER_HARDWARE_STRINGS + 1];
    UCHAR                   scratch[128];
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryHardwareIds\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    devTypeString = USBSTOR_PdoDeviceTypeString(DeviceObject);

    genTypeString = USBSTOR_PdoGenericTypeString(DeviceObject);

    ntStatus = STATUS_SUCCESS;

    RtlZeroMemory(strings, sizeof(strings));

    for (i = 0; i < NUMBER_HARDWARE_STRINGS; i++)
    {
        RtlZeroMemory(scratch, sizeof(scratch));

        // First build each string in the scratch buffer
        //
        switch (i)
        {
            //
            // Bus + Dev Type + Vendor + Product + Revision
            //
            case 0:

                sprintf(scratch, "USBSTOR\\%s", devTypeString);

                CopyField(scratch + strlen(scratch),
                          inquiryData->VendorId,
                          8,
                          '_');
                CopyField(scratch + strlen(scratch),
                          inquiryData->ProductId,
                          16,
                          '_');
                CopyField(scratch + strlen(scratch),
                          inquiryData->ProductRevisionLevel,
                          4,
                          '_');
                break;

            //
            // Bus + Dev Type + Vendor + Product
            //
            case 1:

                sprintf(scratch, "USBSTOR\\%s", devTypeString);

                CopyField(scratch + strlen(scratch),
                          inquiryData->VendorId,
                          8,
                          '_');
                CopyField(scratch + strlen(scratch),
                          inquiryData->ProductId,
                          16,
                          '_');
                break;

            //
            // Bus + Dev Type + Vendor
            //
            case 2:

                sprintf(scratch, "USBSTOR\\%s", devTypeString);

                CopyField(scratch + strlen(scratch),
                          inquiryData->VendorId,
                          8,
                          '_');
                break;

            //
            // Bus + Vendor + Product + Revision[0]
            //
            case 3:

                sprintf(scratch, "USBSTOR\\");
                //
                // Fall through to the next set.
                //

            //
            // Vendor + Product + Revision[0] (win9x)
            //
            case 4:

                CopyField(scratch + strlen(scratch),
                          inquiryData->VendorId,
                          8,
                          '_');
                CopyField(scratch + strlen(scratch),
                          inquiryData->ProductId,
                          16,
                          '_');
                CopyField(scratch + strlen(scratch),
                          inquiryData->ProductRevisionLevel,
                          1,
                          '_');
                break;


            //
            // Bus + Generic Type
            //
            case 5:

                sprintf(scratch, "USBSTOR\\%s", genTypeString);
                break;

            //
            // Generic Type
            //
            case 6:

                sprintf(scratch, "%s", genTypeString);
                break;

            default:
                ASSERT(FALSE);
                break;
        }

        // Now allocate a tmp buffer for this string and copy the scratch
        // buffer to the tmp buffer
        //
        if (strlen(scratch) != 0)
        {
            strings[i] = ExAllocatePoolWithTag(
                             PagedPool,
                             strlen(scratch) + sizeof(UCHAR),
                             POOL_TAG);

            if (strings[i] == NULL)
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            else
            {
                strcpy(strings[i], scratch);
            }
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        // Now convert the array of stings to one Unicode MultiSz
        //
        ntStatus = USBSTOR_StringArrayToMultiSz(UnicodeString, strings);
    }

    // Now free up the tmp buffers for each string
    //
    for (i = 0; i < NUMBER_HARDWARE_STRINGS; i++)
    {
        if (strings[i])
        {
            ExFreePool(strings[i]);
        }
    }

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryHardwareIds %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoQueryCompatibleIds()
//
// This routine handles IRP_MN_QUERY_ID BusQueryCompatibleIDs for the PDO.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoQueryCompatibleIds (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PINQUIRYDATA            inquiryData;
    PUCHAR                  devTypeString;
    UCHAR                   s[sizeof("USBSTOR\\DEVICE_TYPE_GOES_HERE")];
    PSTR                    strings[] = {s, "USBSTOR\\RAW", NULL};
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryCompatibleIds\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    devTypeString = USBSTOR_PdoDeviceTypeString(DeviceObject);

    sprintf(s, "USBSTOR\\%s", devTypeString);

    ntStatus = USBSTOR_StringArrayToMultiSz(UnicodeString, strings);

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryCompatibleIds %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoQueryDeviceText()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_DEVICE_TEXT for the PDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoQueryDeviceText (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PINQUIRYDATA            inquiryData;
    PIO_STACK_LOCATION      irpStack;
    DEVICE_TEXT_TYPE        textType;
    UCHAR                   ansiBuffer[256];
    ANSI_STRING             ansiText;
    UNICODE_STRING          unicodeText;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryDeviceText\n"));

    LOGENTRY('PQDT', DeviceObject, Irp, 0);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    textType = irpStack->Parameters.QueryDeviceText.DeviceTextType;

    if (textType == DeviceTextDescription)
    {
        PUCHAR  c;
        LONG    i;

        RtlZeroMemory(ansiBuffer, sizeof(ansiBuffer));

        RtlCopyMemory(ansiBuffer,
                      inquiryData->VendorId,
                      sizeof(inquiryData->VendorId));

        c = ansiBuffer;

        for (i = sizeof(inquiryData->VendorId)-1; i >= 0; i--)
        {
            if((c[i] != '\0') &&
               (c[i] != ' '))
            {
                i++;
                break;
            }
        }
        c += i;
        *c++ = ' ';

        RtlCopyMemory(c,
                      inquiryData->ProductId,
                      sizeof(inquiryData->ProductId));

        for (i = sizeof(inquiryData->ProductId)-1; i >= 0; i--)
        {
            if((c[i] != '\0') &&
               (c[i] != ' '))
            {
                i++;
                break;
            }
        }
        c += i;
        *c++ = ' ';

        sprintf(c, "USB Device");

        RtlInitAnsiString(&ansiText, ansiBuffer);

        ntStatus = RtlAnsiStringToUnicodeString(&unicodeText,
                                                &ansiText,
                                                TRUE);

        if (NT_SUCCESS(ntStatus))
        {
            Irp->IoStatus.Information = (ULONG_PTR)unicodeText.Buffer;
        }
        else
        {
            Irp->IoStatus.Information = (ULONG_PTR)NULL;
        }
    }
    else
    {
        // If a device does not provide description or location information,
        // the device's underlying bus driver completes the IRP without
        // modifying Irp->IoStatus.Status or Ipr->IoStatus.Information.
        //
        ntStatus = Irp->IoStatus.Status;
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryDeviceText %08X\n", ntStatus));

    LOGENTRY('pqdt', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoBusQueryInstanceId()
//
// This routine handles IRP_MN_QUERY_ID BusQueryInstanceID for the PDO.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoBusQueryInstanceId (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    USHORT                  length;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_PdoBusQueryInstanceId\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceExtension = pdoDeviceExtension->ParentFDO->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    if (fdoDeviceExtension->SerialNumber == NULL)
    {
        // If we set DEVICE_CAPABILITIES.UniqueID = 0 in response to a
        // IRP_MN_QUERY_CAPABILITIES, we can return a NULL ID in response
        // to a BusQueryInstanceID.
        //
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        // Return an NULL-terminated InstanceId string with the format:
        // <USB Device SerialNumberString> + '&' + <LUN value in hex>
        //
        length = fdoDeviceExtension->SerialNumber->bLength -
                 sizeof(USB_COMMON_DESCRIPTOR) +
                 3 * sizeof(WCHAR);

        UnicodeString->Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    length,
                                    POOL_TAG);

        if (UnicodeString->Buffer == NULL)
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            UnicodeString->Length = length - sizeof(WCHAR);
            UnicodeString->MaximumLength = length;

            // Copy the USB Device SerialNumberString
            //
            RtlCopyMemory(UnicodeString->Buffer,
                          &fdoDeviceExtension->SerialNumber->bString[0],
                          length - 3 * sizeof(WCHAR));

            // Append a '&'
            //
            UnicodeString->Buffer[length/sizeof(WCHAR) - 3] = (WCHAR)'&';

            // Append the LUN value in hex
            //
            if (pdoDeviceExtension->LUN <= 9)
            {
                UnicodeString->Buffer[length/sizeof(WCHAR) - 2] =
                    (WCHAR)('0' + pdoDeviceExtension->LUN);
            }
            else
            {
                UnicodeString->Buffer[length/sizeof(WCHAR) - 2] =
                    (WCHAR)('A' + pdoDeviceExtension->LUN - 0xA);
            }

            UnicodeString->Buffer[length/sizeof(WCHAR) - 1] =
                UNICODE_NULL;

            ntStatus = STATUS_SUCCESS;
        }
    }

    DBGPRINT(2, ("exit:  USBSTOR_PdoBusQueryInstanceId %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoQueryDeviceRelations()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_DEVICE_RELATIONS for the PDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoQueryDeviceRelations (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    DEVICE_RELATION_TYPE    relationType;
    PDEVICE_RELATIONS       newRelations;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    relationType = irpStack->Parameters.QueryDeviceRelations.Type;

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryDeviceRelations %d\n",
                 relationType));

    LOGENTRY('PQDR', DeviceObject, Irp, relationType);

    switch (relationType)
    {
        case TargetDeviceRelation:
            //
            // Return a relation list containing ourself.
            //
            newRelations = ExAllocatePoolWithTag(
                               PagedPool,
                               sizeof(DEVICE_RELATIONS),
                               POOL_TAG);

            if (newRelations)
            {
                newRelations->Count = 1;
                newRelations->Objects[0] = DeviceObject;

                ObReferenceObject(DeviceObject);

                ntStatus = STATUS_SUCCESS;
                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = (ULONG_PTR)newRelations;
            }
            else
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;
            }

            break;

        case BusRelations:
        case EjectionRelations:
        case PowerRelations:
        case RemovalRelations:
        default:
            //
            // Just complete the request with it's current status
            //
            ntStatus = Irp->IoStatus.Status;
            break;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryDeviceRelations %08X\n", ntStatus));

    LOGENTRY('pqdr', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_PdoQueryCapabilities()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES for the PDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
USBSTOR_PdoQueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PDEVICE_CAPABILITIES    deviceCapabilities;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceExtension = pdoDeviceExtension->ParentFDO->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    DBGPRINT(2, ("enter: USBSTOR_PdoQueryCapabilities\n"));

    LOGENTRY('PQCP', DeviceObject, Irp, 0);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceCapabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;

    // Pass IRP_MN_QUERY_CAPABILITIES Irp down the stack first before we do
    // anything.
    //
    ntStatus = USBSTOR_SyncPassDownIrp(pdoDeviceExtension->ParentFDO,
                                       Irp);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_QUERY_CAPABILITIES\n"));
    }
    else
    {
        if (fdoDeviceExtension->SerialNumber == NULL)
        {
            deviceCapabilities->UniqueID = FALSE;
        }

        deviceCapabilities->Removable = FALSE;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_PdoQueryCapabilities %08X\n", ntStatus));

    LOGENTRY('pqcp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_SyncPassDownIrp()
//
//******************************************************************************

NTSTATUS
USBSTOR_SyncPassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;
    KEVENT                  localevent;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_SyncPassDownIrp\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Copy down Irp params for the next driver
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutine(Irp,
                           USBSTOR_SyncCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel

    // Pass the Irp down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            Irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    DBGPRINT(2, ("exit:  USBSTOR_SyncPassDownIrp %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_SyncCompletionRoutine()
//
// Completion routine used by USBSTOR_SyncPassDownIrp and
// USBSTOR_SyncSendUsbRequest
//
// If the Irp is one we allocated ourself, DeviceObject is NULL.
//
//******************************************************************************

NTSTATUS
USBSTOR_SyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT kevent;

    LOGENTRY('SCR ', DeviceObject, Irp, Irp->IoStatus.Status);

    kevent = (PKEVENT)Context;

    KeSetEvent(kevent,
               IO_NO_INCREMENT,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//******************************************************************************
//
// USBSTOR_SyncSendUsbRequest()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_SyncSendUsbRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    KEVENT                  localevent;
    PIRP                    irp;
    PIO_STACK_LOCATION      nextStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(3, ("enter: USBSTOR_SyncSendUsbRequest\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Allocate the Irp
    //
    irp = IoAllocateIrp(fdoDeviceExtension->StackDeviceObject->StackSize, FALSE);

    LOGENTRY('SSUR', DeviceObject, irp, Urb);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = Urb;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutine(irp,
                           USBSTOR_SyncCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel



    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        LARGE_INTEGER timeout;

        // Specify a timeout of 5 seconds to wait for this call to complete.
        //
        timeout.QuadPart = -10000 * 5000;

        ntStatus = KeWaitForSingleObject(&localevent,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         &timeout);

        if (ntStatus == STATUS_TIMEOUT)
        {
            ntStatus = STATUS_IO_TIMEOUT;

            // Cancel the Irp we just sent.
            //
            IoCancelIrp(irp);

            // And wait until the cancel completes
            //
            KeWaitForSingleObject(&localevent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        else
        {
            ntStatus = irp->IoStatus.Status;
        }
    }

    // Done with the Irp, now free it.
    //
    IoFreeIrp(irp);

    LOGENTRY('ssur', ntStatus, Urb, Urb->UrbHeader.Status);

    DBGPRINT(3, ("exit:  USBSTOR_SyncSendUsbRequest %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_GetDescriptor()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_GetDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            DescriptorType,
    IN UCHAR            Index,
    IN USHORT           LanguageId,
    IN ULONG            RetryCount,
    IN ULONG            DescriptorLength,
    OUT PUCHAR         *Descriptor
    )
{
    USHORT      function;
    PURB        urb;
    NTSTATUS    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_GetDescriptor\n"));

    *Descriptor = NULL;

    // Set the URB function based on Recipient {Device, Interface, Endpoint}
    //
    switch (Recipient)
    {
        case USB_RECIPIENT_DEVICE:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE;
            break;
        case USB_RECIPIENT_INTERFACE:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE;
            break;
        case USB_RECIPIENT_ENDPOINT:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT;
            break;
        default:
            return STATUS_INVALID_PARAMETER;
    }

    // Allocate a descriptor buffer
    //
    *Descriptor = ExAllocatePoolWithTag(NonPagedPool,
                                        DescriptorLength,
                                        POOL_TAG);

    if (*Descriptor != NULL)
    {
        // Allocate a URB for the Get Descriptor request
        //
        urb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                    POOL_TAG);

        if (urb != NULL)
        {
            do
            {
                // Initialize the URB
                //
                urb->UrbHeader.Function = function;
                urb->UrbHeader.Length = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);
                urb->UrbControlDescriptorRequest.TransferBufferLength = DescriptorLength;
                urb->UrbControlDescriptorRequest.TransferBuffer = *Descriptor;
                urb->UrbControlDescriptorRequest.TransferBufferMDL = NULL;
                urb->UrbControlDescriptorRequest.UrbLink = NULL;
                urb->UrbControlDescriptorRequest.DescriptorType = DescriptorType;
                urb->UrbControlDescriptorRequest.Index = Index;
                urb->UrbControlDescriptorRequest.LanguageId = LanguageId;

                // Send the URB down the stack
                //
                ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject,
                                                     urb);

                if (NT_SUCCESS(ntStatus))
                {
                    // No error, make sure the length and type are correct
                    //
                    if ((DescriptorLength ==
                         urb->UrbControlDescriptorRequest.TransferBufferLength) &&
                        (DescriptorType ==
                         ((PUSB_COMMON_DESCRIPTOR)*Descriptor)->bDescriptorType))
                    {
                        // The length and type are correct, all done
                        //
                        break;
                    }
                    else
                    {
                        // No error, but the length or type is incorrect
                        //
                        ntStatus = STATUS_DEVICE_DATA_ERROR;
                    }
                }

            } while (RetryCount-- > 0);

            ExFreePool(urb);
        }
        else
        {
            // Failed to allocate the URB
            //
            ExFreePool(*Descriptor);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        // Failed to allocate the descriptor buffer
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(ntStatus))
    {
        if (*Descriptor != NULL)
        {
            ExFreePool(*Descriptor);
            *Descriptor = NULL;
        }
    }

    DBGPRINT(2, ("exit:  USBSTOR_GetDescriptor %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_GetMaxLun()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_GetMaxLun (
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PUCHAR          MaxLun
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PUCHAR                  maxLunBuf;
    ULONG                   retryCount;
    PURB                    urb;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_GetMaxLun\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Return zero unless we successfully return a non-zero value
    //
    *MaxLun = 0;

    // Allocate a URB for the Get Max LUN request, plus an extra byte at
    // the end for the transfer buffer.
    //
    urb = ExAllocatePoolWithTag(NonPagedPool,
                                sizeof(URB) + 1,
                                POOL_TAG);

    if (urb != NULL)
    {
        // Get a pointer to the transfer buffer, which is the byte immediately
        // after the end of the URB.
        //
        maxLunBuf = (PUCHAR)(urb + 1);

        retryCount = 2;

        do
        {
            // Initialize the Control Transfer URB, all fields default to zero
            //
            RtlZeroMemory(urb, sizeof(URB) + 1);

            CLASS_URB(urb).Hdr.Length = sizeof(CLASS_URB(urb));

            CLASS_URB(urb).Hdr.Function = URB_FUNCTION_CLASS_INTERFACE;

            CLASS_URB(urb).TransferFlags = USBD_TRANSFER_DIRECTION_IN;

            CLASS_URB(urb).TransferBufferLength = 1;

            CLASS_URB(urb).TransferBuffer = maxLunBuf;

            // CLASS_URB(urb).TransferBufferMDL        is already zero

            // CLASS_URB(urb).RequestTypeReservedBits  is already zero

            CLASS_URB(urb).Request = BULK_ONLY_GET_MAX_LUN;

            // CLASS_URB(urb).Value                    is already zero

            // Target the request at the proper interface on the device
            //
            CLASS_URB(urb).Index = fdoDeviceExtension->InterfaceInfo->InterfaceNumber;

            // Send the URB down the stack
            //
            ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject,
                                                  urb);

            if (NT_SUCCESS(ntStatus))
            {
                // No error, make sure the length is correct
                //
                if (CLASS_URB(urb).TransferBufferLength == 1)
                {
                    // The length is correct, return the value if it looks ok
                    //
                    if (*maxLunBuf <= BULK_ONLY_MAXIMUM_LUN)
                    {
                        *MaxLun = *maxLunBuf;
                    }
                    else
                    {
                        ntStatus = STATUS_DEVICE_DATA_ERROR;
                    }

                    break;
                }
                else
                {
                    // No error, but the length or type is incorrect
                    //
                    ntStatus = STATUS_DEVICE_DATA_ERROR;
                }
            }
            else if (USBD_STATUS(CLASS_URB(urb).Hdr.Status) ==
                     USBD_STATUS(USBD_STATUS_STALL_PID))
            {
                // Some devices which do not support the Get Max LUN request
                // get confused and will STALL a CBW on the Bulk endpoint
                // it if immediately follows the Get Max LUN request.
                //
                // It should never be necessary to send a Clear_Feature
                // Endpoint_Stall for Control EP0, but doing so appears to
                // be one way to unconfuse devices which are confused by the
                // Get Max LUN request.

                // Initialize the Control Transfer URB, all fields default to zero
                //
                RtlZeroMemory(urb, sizeof(URB));

                FEATURE_URB(urb).Hdr.Length = sizeof(FEATURE_URB(urb));

                FEATURE_URB(urb).Hdr.Function = URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT;

                FEATURE_URB(urb).FeatureSelector = USB_FEATURE_ENDPOINT_STALL;

                // FEATURE_URB(urb).Index                    is already zero

                // Send the URB down the stack
                //
                USBSTOR_SyncSendUsbRequest(DeviceObject,
                                           urb);
            }

        } while (retryCount-- > 0);

        ExFreePool(urb);
    }
    else
    {
        // Failed to allocate the URB
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  USBSTOR_GetMaxLun %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_SelectConfiguration()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_SelectConfiguration (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PURB                            urb;
    PFDO_DEVICE_EXTENSION           fdoDeviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR   configurationDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY      interfaceList;
    PUSB_INTERFACE_DESCRIPTOR       interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION     interfaceInfo;
    LONG                            i;
    LONG                            bulkInIndex;
    LONG                            bulkOutIndex;
    LONG                            interruptInIndex;
    NTSTATUS                        ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_SelectConfiguration\n"));

    LOGENTRY('SCON', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    configurationDescriptor = fdoDeviceExtension->ConfigurationDescriptor;

    // Allocate storage for an Inteface List to use as an input/output
    // parameter to USBD_CreateConfigurationRequestEx().
    //
    interfaceList = ExAllocatePoolWithTag(
                        PagedPool,
                        sizeof(USBD_INTERFACE_LIST_ENTRY) * 2,
                        POOL_TAG);

    if (interfaceList)
    {
        // Mutate configuration descriptor to suit our wishes
        //
        USBSTOR_AdjustConfigurationDescriptor(
            DeviceObject,
            fdoDeviceExtension->ConfigurationDescriptor,
            &interfaceDescriptor,
            &bulkInIndex,
            &bulkOutIndex,
            &interruptInIndex);

        // Save the Interface Descriptor pointer so we don't have
        // to parse the Configuration Descriptor again in case we
        // want to look at it.
        //
        fdoDeviceExtension->InterfaceDescriptor = interfaceDescriptor;

        if (interfaceDescriptor)
        {
            // Add the single Interface Descriptor we care about to the
            // interface list, then terminate the list.
            //
            interfaceList[0].InterfaceDescriptor = interfaceDescriptor;
            interfaceList[1].InterfaceDescriptor = NULL;

            // USBD will fail a SELECT_CONFIGURATION request if the Config
            // Descriptor bNumInterfaces does not match the number of interfaces
            // in the SELECT_CONFIGURATION request.  Since we are ignoring
            // any interfaces other than the first interface, set the Config
            // Descriptor bNumInterfaces to 1.
            //
            // This is only necessary in case this driver is loaded for an
            // entire multiple interface device and not as a single interface
            // child of the composite parent driver.
            //
            configurationDescriptor->bNumInterfaces = 1;

            // Create a SELECT_CONFIGURATION URB, turning the Interface
            // Descriptors in the interfaceList into USBD_INTERFACE_INFORMATION
            // structures in the URB.
            //
            urb = USBD_CreateConfigurationRequestEx(
                      configurationDescriptor,
                      interfaceList
                      );

            if (urb)
            {
                // Now issue the USB request to set the Configuration
                //
                ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject,
                                                     urb);

                if (NT_SUCCESS(ntStatus))
                {
                    // Save the configuration handle for this device in
                    // the Device Extension.
                    //
                    fdoDeviceExtension->ConfigurationHandle =
                        urb->UrbSelectConfiguration.ConfigurationHandle;

                    interfaceInfo = &urb->UrbSelectConfiguration.Interface;

                    // Save a copy of the interface information returned
                    // by the SELECT_CONFIGURATION request in the Device
                    // Extension.  This gives us a list of PIPE_INFORMATION
                    // structures for each pipe opened in this configuration.
                    //
                    ASSERT(fdoDeviceExtension->InterfaceInfo == NULL);

                    fdoDeviceExtension->InterfaceInfo =
                        ExAllocatePoolWithTag(NonPagedPool,
                                              interfaceInfo->Length,
                                              POOL_TAG);

                    if (fdoDeviceExtension->InterfaceInfo)
                    {
                        RtlCopyMemory(fdoDeviceExtension->InterfaceInfo,
                                      interfaceInfo,
                                      interfaceInfo->Length);
                    }
                    else
                    {
                        // Could not allocate a copy of interface information
                        //
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (NT_SUCCESS(ntStatus))
                {
                    // Reuse the SELECT_CONFIGURATION request URB as a
                    // SELECT_INTERFACE request URB and send down a request to
                    // select the default alternate interface setting that is
                    // currently in effect.  The point of this seemingly
                    // useless request is to make sure the endpoint
                    // MaximumTransferSize values are in effect.
                    //
                    // When USBHUB is loaded as a composite parent for a
                    // multiple interface device it ignores SELECT_CONFIGURATION
                    // requests from child device drivers.  In particular the
                    // MaximumTransferSize values of child driver SELECT_CONFIGURATION
                    // requests are ignored and the default 4KB value remains
                    // in effect.  The composite parent driver will respect the
                    // MaximumTransferSize values of child driver SELECT_INTERFACE
                    // requests.
                    //
                    ASSERT(GET_SELECT_INTERFACE_REQUEST_SIZE(fdoDeviceExtension->InterfaceInfo->NumberOfPipes) <
                           GET_SELECT_CONFIGURATION_REQUEST_SIZE(1, fdoDeviceExtension->InterfaceInfo->NumberOfPipes));

                    RtlZeroMemory(urb, GET_SELECT_INTERFACE_REQUEST_SIZE(fdoDeviceExtension->InterfaceInfo->NumberOfPipes));

                    urb->UrbSelectInterface.Hdr.Length =
                        (USHORT)GET_SELECT_INTERFACE_REQUEST_SIZE(fdoDeviceExtension->InterfaceInfo->NumberOfPipes);

                    urb->UrbSelectInterface.Hdr.Function =
                        URB_FUNCTION_SELECT_INTERFACE;

                    urb->UrbSelectInterface.ConfigurationHandle =
                        fdoDeviceExtension->ConfigurationHandle;

                    interfaceInfo = &urb->UrbSelectInterface.Interface;

                    RtlCopyMemory(interfaceInfo,
                                  fdoDeviceExtension->InterfaceInfo,
                                  fdoDeviceExtension->InterfaceInfo->Length);

                    // Override the USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE
                    // for all pipes.
                    //
                    for (i=0; i<(LONG)interfaceInfo->NumberOfPipes; i++)
                    {
                        if (i == bulkInIndex || i == bulkOutIndex)
                        {
                            interfaceInfo->Pipes[i].MaximumTransferSize =
                                USBSTOR_MAX_TRANSFER_SIZE;

                            DBGPRINT(1, ("Set pipe %d MaximumTransferSize to %X\n",
                                         i,
                                         interfaceInfo->Pipes[i].MaximumTransferSize));
                        }
                        else if (i == interruptInIndex)
                        {
                            interfaceInfo->Pipes[i].MaximumTransferSize =
                                sizeof(USHORT);

                            DBGPRINT(1, ("Set pipe %d MaximumTransferSize to %X\n",
                                         i,
                                         interfaceInfo->Pipes[i].MaximumTransferSize));
                        }
                    }

                    // Now issue the USB request to set the Interface
                    //
                    ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject,
                                                          urb);

                    if (NT_SUCCESS(ntStatus))
                    {
                        ASSERT(interfaceInfo->Length ==
                               fdoDeviceExtension->InterfaceInfo->Length);

                        RtlCopyMemory(fdoDeviceExtension->InterfaceInfo,
                                      interfaceInfo,
                                      fdoDeviceExtension->InterfaceInfo->Length);
                    }
                }

                // Done with the URB
                //
                ExFreePool(urb);
            }
            else
            {
                // Could not allocate urb
                //
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            // Did not parse an Interface Descriptor out of the Configuration
            // Descriptor, the Configuration Descriptor must be bad.
            //
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        // Done with the interface list
        //
        ExFreePool(interfaceList);
    }
    else
    {
        // Could not allocate Interface List
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  USBSTOR_SelectConfiguration %08X\n", ntStatus));

    LOGENTRY('scon', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_UnConfigure()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_UnConfigure (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;
    PURB                    urb;
    ULONG                   ulSize;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_UnConfigure\n"));

    LOGENTRY('UCON', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Allocate a URB for the SELECT_CONFIGURATION request.  As we are
    // unconfiguring the device, the request needs no pipe and interface
    // information structures.
    //
    ulSize = sizeof(struct _URB_SELECT_CONFIGURATION) -
             sizeof(USBD_INTERFACE_INFORMATION);

    urb = ExAllocatePoolWithTag(NonPagedPool, ulSize, POOL_TAG);

    if (urb)
    {
        // Initialize the URB.  A NULL Configuration Descriptor indicates
        // that the device should be unconfigured.
        //
        UsbBuildSelectConfigurationRequest(urb,
                                           (USHORT)ulSize,
                                           NULL);

        // Now issue the USB request to set the Configuration
        //
        ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject,
                                             urb);

        // Done with the URB now.
        //
        ExFreePool(urb);

        fdoDeviceExtension->ConfigurationHandle = 0;

        // Free the copy of the interface information that was allocated in
        // USBSTOR_SelectConfiguration().
        //
        if (fdoDeviceExtension->InterfaceInfo != NULL)
        {
            ExFreePool(fdoDeviceExtension->InterfaceInfo);

            fdoDeviceExtension->InterfaceInfo = NULL;
        }
    }
    else
    {
        // Could not allocate the URB.
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  USBSTOR_UnConfigure %08X\n", ntStatus));

    LOGENTRY('ucon', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_ResetPipe()
//
// This will reset the host pipe to Data0 and should also reset the device
// endpoint to Data0 for Bulk and Interrupt pipes by issuing a Clear_Feature
// Endpoint_Stall to the device endpoint.
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_ResetPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN USBD_PIPE_HANDLE Pipe
    )
{
    PURB        urb;
    NTSTATUS    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_ResetPipe\n"));

    LOGENTRY('RESP', DeviceObject, Pipe, 0);

    // Allocate URB for RESET_PIPE request
    //
    urb = ExAllocatePoolWithTag(NonPagedPool,
                                sizeof(struct _URB_PIPE_REQUEST),
                                POOL_TAG);

    if (urb != NULL)
    {
        // Initialize RESET_PIPE request URB
        //
        urb->UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        urb->UrbPipeRequest.PipeHandle = Pipe;

        // Submit RESET_PIPE request URB
        //
        ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject, urb);

        // Done with URB for RESET_PIPE request, free it
        //
        ExFreePool(urb);
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  USBSTOR_ResetPipe %08X\n", ntStatus));

    LOGENTRY('resp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_AbortPipe()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_AbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN USBD_PIPE_HANDLE Pipe
    )
{
    PURB        urb;
    NTSTATUS    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_AbortPipe\n"));

    LOGENTRY('ABRT', DeviceObject, Pipe, 0);

    // Allocate URB for ABORT_PIPE request
    //
    urb = ExAllocatePoolWithTag(NonPagedPool,
                                sizeof(struct _URB_PIPE_REQUEST),
                                POOL_TAG);

    if (urb != NULL)
    {
        // Initialize ABORT_PIPE request URB
        //
        urb->UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
        urb->UrbPipeRequest.PipeHandle = Pipe;

        // Submit ABORT_PIPE request URB
        //
        ntStatus = USBSTOR_SyncSendUsbRequest(DeviceObject, urb);

        // Done with URB for ABORT_PIPE request, free it
        //
        ExFreePool(urb);
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  USBSTOR_AbortPipe %08X\n", ntStatus));

    LOGENTRY('abrt', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_GetBusInterface()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
USBSTOR_GetBusInterface (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PUSB_BUS_INTERFACE_USBDI_V1  BusInterface
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIRP                    irp;
    KEVENT                  localevent;
    PIO_STACK_LOCATION      nextStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(1, ("enter: USBSTOR_GetBusInterface\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    RtlZeroMemory(BusInterface, sizeof(*BusInterface));

    // Allocate the Irp
    //
    irp = IoAllocateIrp((CCHAR)(fdoDeviceExtension->StackDeviceObject->StackSize),
                        FALSE);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the event we'll wait on.
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_PNP;

    nextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    nextStack->Parameters.QueryInterface.Interface =
        (PINTERFACE)BusInterface;

    nextStack->Parameters.QueryInterface.InterfaceSpecificData =
        NULL;

    nextStack->Parameters.QueryInterface.InterfaceType =
        &USB_BUS_INTERFACE_USBDI_GUID;

    nextStack->Parameters.QueryInterface.Size =
        sizeof(*BusInterface);

    nextStack->Parameters.QueryInterface.Version =
        USB_BUSIF_USBDI_VERSION_1;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutineEx(DeviceObject,
                             irp,
                             USBSTOR_SyncCompletionRoutine,
                             &localevent,
                             TRUE,      // InvokeOnSuccess
                             TRUE,      // InvokeOnError
                             TRUE);     // InvokeOnCancel

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED
    //
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    // Pass the Irp down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    if (NT_SUCCESS(ntStatus))
    {
        ASSERT(BusInterface->Version == USB_BUSIF_USBDI_VERSION_1);
        ASSERT(BusInterface->Size == sizeof(*BusInterface));
    }

    DBGPRINT(1, ("exit:  USBSTOR_GetBusInterface %08X\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbmass\scsi.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    SCSI.C

Abstract:

    This source file contains the dispatch routines which handle:

    IRP_MJ_DEVICE_CONTROL
    IRP_MJ_SCSI

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <ntddk.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <ntddscsi.h>
#include <ntddstor.h>

#include "usbmass.h"

//*****************************************************************************
// L O C A L    F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************

NTSTATUS
USBSTOR_QueryProperty (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_BuildDeviceDescriptor (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR   Descriptor,
    IN OUT PULONG                   DescriptorLength
    );

NTSTATUS
USBSTOR_BuildAdapterDescriptor (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR   Descriptor,
    IN OUT PULONG                   DescriptorLength
    );

NTSTATUS
USBSTOR_SendPassThrough (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             RequestIrp
    );

#if defined (_WIN64)

NTSTATUS
USBSTOR_TranslatePassThrough32To64(
    IN PSCSI_PASS_THROUGH32 SrbControl32,
    IN OUT PSCSI_PASS_THROUGH SrbControl64
    );

VOID
USBSTOR_TranslatePassThrough64To32(
    IN PSCSI_PASS_THROUGH SrbControl64,
    IN OUT PSCSI_PASS_THROUGH32 SrbControl32
    );

#endif

VOID
USBSTOR_CancelIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

//
// CBI (Control/Bulk/Interrupt) Routines
//

NTSTATUS
USBSTOR_IssueClientCdb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_ClientCdbCompletion  (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_IssueClientBulkRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_ClientBulkCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_IssueInterruptRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_InterruptDataCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_IssueRequestSenseCdb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    );

NTSTATUS
USBSTOR_RequestSenseCdbCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            AutoFlag
    );

NTSTATUS
USBSTOR_IssueRequestSenseBulkRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    );

NTSTATUS
USBSTOR_SenseDataCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            AutoFlag
    );

NTSTATUS
USBSTOR_IssueRequestSenseInterruptRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    );

NTSTATUS
USBSTOR_RequestSenseInterruptCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            AutoFlag
    );

NTSTATUS
USBSTOR_ProcessRequestSenseCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    );

VOID
USBSTOR_QueueResetPipe (
    IN PDEVICE_OBJECT   DeviceObject
    );

VOID
USBSTOR_ResetPipeWorkItem (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
    );

//
// Bulk-Only Routines
//

NTSTATUS
USBSTOR_CbwTransfer (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_CbwCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_DataTransfer (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_DataCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_CswTransfer (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_CswCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_IssueRequestSense (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
USBSTOR_BulkQueueResetPipe (
    IN PDEVICE_OBJECT   DeviceObject
    );

VOID
USBSTOR_BulkResetPipeWorkItem (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
    );

//
// CBI / Bulk-Only Common Routines
//

VOID
USBSTOR_QueueResetDevice (
    IN PDEVICE_OBJECT   DeviceObject
    );

VOID
USBSTOR_ResetDeviceWorkItem (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
    );

NTSTATUS
USBSTOR_IsDeviceConnected (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBSTOR_ResetDevice (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBSTOR_IssueInternalCdb (
    PDEVICE_OBJECT  DeviceObject,
    PVOID           DataBuffer,
    PULONG          DataTransferLength,
    PCDB            Cdb,
    UCHAR           CdbLength,
    ULONG           TimeOutValue
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBSTOR_DeviceControl)
#pragma alloc_text(PAGE, USBSTOR_QueryProperty)
#pragma alloc_text(PAGE, USBSTOR_BuildDeviceDescriptor)
#pragma alloc_text(PAGE, USBSTOR_BuildAdapterDescriptor)
#pragma alloc_text(PAGE, USBSTOR_SendPassThrough)
#if defined (_WIN64)
#pragma alloc_text(PAGE, USBSTOR_TranslatePassThrough32To64)
#pragma alloc_text(PAGE, USBSTOR_TranslatePassThrough64To32)
#endif
#pragma alloc_text(PAGE, USBSTOR_IssueInternalCdb)
#pragma alloc_text(PAGE, USBSTOR_GetInquiryData)
#pragma alloc_text(PAGE, USBSTOR_IsFloppyDevice)
#endif


//******************************************************************************
//
// USBSTOR_DeviceControl()
//
// Dispatch routine which handles IRP_MJ_DEVICE_CONTROL
//
//******************************************************************************

NTSTATUS
USBSTOR_DeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    ULONG               ioControlCode;
    NTSTATUS            ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_DeviceControl\n"));

    //LOGENTRY('IOCT', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_IOCTL);

    deviceExtension = DeviceObject->DeviceExtension;

    // Only the PDO should handle these ioctls
    //
    if (deviceExtension->Type == USBSTOR_DO_TYPE_PDO)
    {
        PFDO_DEVICE_EXTENSION   fdoDeviceExtension;

        fdoDeviceExtension = ((PPDO_DEVICE_EXTENSION)deviceExtension)->ParentFDO->DeviceExtension;
        ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

        irpStack = IoGetCurrentIrpStackLocation(Irp);

        ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

        switch (ioControlCode)
        {
            case IOCTL_STORAGE_QUERY_PROPERTY:
                ntStatus = USBSTOR_QueryProperty(DeviceObject, Irp);
                break;

            case IOCTL_SCSI_PASS_THROUGH:
            case IOCTL_SCSI_PASS_THROUGH_DIRECT:

                ntStatus = USBSTOR_SendPassThrough(DeviceObject, Irp);

                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;


            case IOCTL_SCSI_GET_ADDRESS:        // XXXXX
                DBGPRINT(2, ("IOCTL_SCSI_GET_ADDRESS\n"));
                goto IoctlNotSupported;


            case IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER:
                //
                // Pass the Irp down the stack
                //
                IoSkipCurrentIrpStackLocation(Irp);

                ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                        Irp);
                break;


            default:
IoctlNotSupported:
                // Maybe we can just ignore these.  Print debug info
                // for now so we know what IOCTLs that we've seen so
                // far that we fail.
                //
                DBGPRINT(2, ("ioControlCode not supported 0x%08X\n",
                             ioControlCode));

                DBGFBRK(DBGF_BRK_IOCTL);

                ntStatus = STATUS_NOT_SUPPORTED;
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
        }
    }
    else
    {
        ASSERT(deviceExtension->Type == USBSTOR_DO_TYPE_FDO);

        DBGPRINT(2, ("ioctl not supported for FDO\n"));

        ntStatus = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  USBSTOR_DeviceControl %08X\n", ntStatus));

    //LOGENTRY('ioct', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_QueryProperty()
//
// Dispatch routine which handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_STORAGE_QUERY_PROPERTY for the PDO
//
//******************************************************************************

NTSTATUS
USBSTOR_QueryProperty (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    PSTORAGE_PROPERTY_QUERY query;
    ULONG                   inputLength;
    ULONG                   outputLength;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_QueryProperty\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    query = Irp->AssociatedIrp.SystemBuffer;

    inputLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;

    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (inputLength < sizeof(STORAGE_PROPERTY_QUERY))
    {
        ntStatus = STATUS_INVALID_PARAMETER;    // Bad InputBufferLength
        outputLength = 0;
        goto USBSTOR_QueryPropertyDone;
    }

    switch (query->PropertyId)
    {
        case StorageDeviceProperty:

            switch (query->QueryType)
            {
                case PropertyExistsQuery:
                    ntStatus = STATUS_SUCCESS;
                    outputLength = 0;
                    break;

                case PropertyStandardQuery:
                    ntStatus = USBSTOR_BuildDeviceDescriptor(
                                   DeviceObject,
                                   Irp->AssociatedIrp.SystemBuffer,
                                   &outputLength);
                    break;

                default:
                    ntStatus = STATUS_INVALID_PARAMETER_2;  // Bad QueryType
                    outputLength = 0;
                    break;

            }
            break;

        case StorageAdapterProperty:

            switch (query->QueryType)
            {
                case PropertyExistsQuery:
                    ntStatus = STATUS_SUCCESS;
                    outputLength = 0;
                    break;

                case PropertyStandardQuery:
                    ntStatus = USBSTOR_BuildAdapterDescriptor(
                                   DeviceObject,
                                   Irp->AssociatedIrp.SystemBuffer,
                                   &outputLength);
                    break;

                default:
                    ntStatus = STATUS_INVALID_PARAMETER_2;  // Bad QueryType
                    outputLength = 0;
                    break;

            }
            break;

        default:

            ntStatus = STATUS_INVALID_PARAMETER_1;          // Bad PropertyId
            outputLength = 0;
            break;
    }

USBSTOR_QueryPropertyDone:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = outputLength;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_QueryProperty %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_BuildDeviceDescriptor()
//
//******************************************************************************

NTSTATUS
USBSTOR_BuildDeviceDescriptor (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR   Descriptor,
    IN OUT PULONG                   DescriptorLength
    )
{
    PPDO_DEVICE_EXTENSION       pdoDeviceExtension;
    PINQUIRYDATA                inquiryData;
    LONG                        inquiryLength;
    STORAGE_DEVICE_DESCRIPTOR   localDescriptor;
    PUCHAR                      currentOffset;
    LONG                        bytesRemaining;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_BuildDeviceDescriptor\n"));

    // Get a pointer to our Inquiry data
    //
    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    // inquiryLength = 5 + inquiryData->AdditionalLength;
    //
    //     if (inquiryLength > INQUIRYDATABUFFERSIZE)
    //     {
    //         inquiryLength = INQUIRYDATABUFFERSIZE;
    //     }
    //
    // Just return whatever we got from the device and leave it up to
    // whoever looks at this information to decide how much is valid.
    //
    inquiryLength = sizeof(pdoDeviceExtension->InquiryDataBuffer);

    // Zero initialize the output buffer
    //
    RtlZeroMemory(Descriptor, *DescriptorLength);


    // Build the temp local descriptor
    //
    RtlZeroMemory(&localDescriptor, sizeof(localDescriptor));

    localDescriptor.Version = sizeof(localDescriptor);

    localDescriptor.Size    = FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR,
                                           RawDeviceProperties) +
                              inquiryLength +
                              sizeof(inquiryData->VendorId) + 1 +
                              sizeof(inquiryData->ProductId) + 1 +
                              sizeof(inquiryData->ProductRevisionLevel) + 1;

    localDescriptor.DeviceType          = inquiryData->DeviceType;
    localDescriptor.DeviceTypeModifier  = inquiryData->DeviceTypeModifier;
    localDescriptor.RemovableMedia      = inquiryData->RemovableMedia;

    localDescriptor.BusType = BusTypeUsb;


    // Start copying as much data as will fit in the output buffer
    //
    currentOffset   = (PUCHAR)Descriptor;
    bytesRemaining  = *DescriptorLength;


    // First copy the temp local descriptor
    //
    RtlCopyMemory(currentOffset,
                  &localDescriptor,
                  min(bytesRemaining,
                      FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR,
                                   RawDeviceProperties)));

    bytesRemaining  -= FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR,
                                    RawDeviceProperties);

    if (bytesRemaining <= 0)
    {
        return STATUS_SUCCESS;
    }

    // This should advance us to RawDeviceProperties[0]
    //
    currentOffset   += FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR,
                                    RawDeviceProperties);

    // Next copy the Inquiry data
    //
    Descriptor->RawPropertiesLength = min(bytesRemaining, inquiryLength);

    RtlCopyMemory(currentOffset,
                  inquiryData,
                  Descriptor->RawPropertiesLength);

    bytesRemaining  -= inquiryLength;

    if (bytesRemaining <= 0)
    {
        return STATUS_SUCCESS;
    }

    currentOffset   += inquiryLength;


    // Now copy the Vendor Id
    //
    RtlCopyMemory(currentOffset,
                  inquiryData->VendorId,
                  min(bytesRemaining, sizeof(inquiryData->VendorId)));

    bytesRemaining  -= sizeof(inquiryData->VendorId) + 1; // include null

    if (bytesRemaining >= 0)
    {
        Descriptor->VendorIdOffset = (ULONG)((ULONG_PTR) currentOffset -
                                             (ULONG_PTR) Descriptor);
    }

    if (bytesRemaining <= 0)
    {
        return STATUS_SUCCESS;
    }

    currentOffset   += sizeof(inquiryData->VendorId) + 1;


    // Now copy the Product Id
    //
    RtlCopyMemory(currentOffset,
                  inquiryData->ProductId,
                  min(bytesRemaining, sizeof(inquiryData->ProductId)));

    bytesRemaining  -= sizeof(inquiryData->ProductId) + 1; // include null

    if (bytesRemaining >= 0)
    {
        Descriptor->ProductIdOffset = (ULONG)((ULONG_PTR) currentOffset -
                                              (ULONG_PTR) Descriptor);
    }

    if (bytesRemaining <= 0)
    {
        return STATUS_SUCCESS;
    }

    currentOffset   += sizeof(inquiryData->ProductId) + 1;


    // And finally copy the Product Revision Level
    //
    RtlCopyMemory(currentOffset,
                  inquiryData->ProductRevisionLevel,
                  min(bytesRemaining, sizeof(inquiryData->ProductRevisionLevel)));

    bytesRemaining  -= sizeof(inquiryData->ProductRevisionLevel) + 1; // include null

    if (bytesRemaining >= 0)
    {
        Descriptor->ProductRevisionOffset = (ULONG)((ULONG_PTR) currentOffset -
                                                    (ULONG_PTR) Descriptor);
    }

    if (bytesRemaining <= 0)
    {
        return STATUS_SUCCESS;
    }

    *DescriptorLength -= bytesRemaining;

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// USBSTOR_BuildAdapterDescriptor()
//
//******************************************************************************

NTSTATUS
USBSTOR_BuildAdapterDescriptor (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR   Descriptor,
    IN OUT PULONG                   DescriptorLength
    )
{
    PPDO_DEVICE_EXTENSION       pdoDeviceExtension;
    PFDO_DEVICE_EXTENSION       fdoDeviceExtension;
    STORAGE_ADAPTER_DESCRIPTOR  localDescriptor;
    NTSTATUS                    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_BuildAdapterDescriptor\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceExtension = pdoDeviceExtension->ParentFDO->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    localDescriptor.Version = sizeof(localDescriptor);
    localDescriptor.Size    = sizeof(localDescriptor);

    localDescriptor.MaximumTransferLength = USBSTOR_MAX_TRANSFER_SIZE;
    localDescriptor.MaximumPhysicalPages  = USBSTOR_MAX_TRANSFER_PAGES;
    localDescriptor.AlignmentMask = 0;
    localDescriptor.AdapterUsesPio = FALSE;
    localDescriptor.AdapterScansDown = FALSE;
    localDescriptor.CommandQueueing = FALSE;
    localDescriptor.AcceleratedTransfer = FALSE;

    localDescriptor.BusType = BusTypeUsb;

    localDescriptor.BusMajorVersion = fdoDeviceExtension->DeviceIsHighSpeed ?
                                      2 : 1;

    localDescriptor.BusMinorVersion = 0;

    if (*DescriptorLength > localDescriptor.Size)
    {
        *DescriptorLength = localDescriptor.Size;
    }

    RtlCopyMemory(Descriptor,
                  &localDescriptor,
                  *DescriptorLength);

    ntStatus = STATUS_SUCCESS;

    DBGPRINT(2, ("exit:  USBSTOR_BuildAdapterDescriptor %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_SendPassThrough()
//
// This routine handles IOCTL_SCSI_PASS_THROUGH requests.
// It creates an Irp/Srb which is processed normally by the port driver.
// This call is synchornous.
//
// (This routine borrowed from ATAPI.SYS)
//
//******************************************************************************

NTSTATUS
USBSTOR_SendPassThrough (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             RequestIrp
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_PASS_THROUGH      srbControl;
    PVOID                   srbBuffer;
    SCSI_REQUEST_BLOCK      srb;
    KEVENT                  event;
    LARGE_INTEGER           startingOffset;
    IO_STATUS_BLOCK         ioStatusBlock;
    ULONG                   outputLength;
    ULONG                   length;
    ULONG                   bufferOffset;
    PVOID                   buffer;
    PVOID                   endByte;
    PVOID                   senseBuffer;
    UCHAR                   majorCode;

#if defined (_WIN64)
    PSCSI_PASS_THROUGH32    srbControl32 = NULL;
    SCSI_PASS_THROUGH       srbControl64;
#endif

    NTSTATUS                status;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_SendPassThrough\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    startingOffset.QuadPart = (LONGLONG)1;

    // Get a pointer to the control block.
    //
    irpStack    = IoGetCurrentIrpStackLocation(RequestIrp);
    srbControl  = RequestIrp->AssociatedIrp.SystemBuffer;

    // Save the original srbControl to use as a buffer pointer in the
    // case where the srbControl is replaced with a 32->64 bit
    // translated version.
    //
    srbBuffer = (PVOID) srbControl;

    // Validiate the user buffer.
    //
#if defined (_WIN64)

    if (IoIs32bitProcess(RequestIrp))
    {
        if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSI_PASS_THROUGH32))
        {
            return STATUS_INVALID_PARAMETER;
        }

        srbControl32 = RequestIrp->AssociatedIrp.SystemBuffer;

        status = USBSTOR_TranslatePassThrough32To64(srbControl32, &srbControl64);

        if (!NT_SUCCESS(status))
        {
            return status;
        }

        srbControl = &srbControl64;

    }
    else
    {
#endif
        if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSI_PASS_THROUGH))
        {
            return STATUS_INVALID_PARAMETER;
        }

        if (srbControl->Length != sizeof(SCSI_PASS_THROUGH) &&
            srbControl->Length != sizeof(SCSI_PASS_THROUGH_DIRECT))
        {
            return STATUS_REVISION_MISMATCH;
        }

#if defined (_WIN64)
    }
#endif

    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    // Validate the rest of the buffer parameters.
    //
    if (srbControl->CdbLength > 16)
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (srbControl->SenseInfoLength != 0 &&
        (srbControl->Length > srbControl->SenseInfoOffset ||
        (srbControl->SenseInfoOffset + srbControl->SenseInfoLength >
        srbControl->DataBufferOffset && srbControl->DataTransferLength != 0)))
    {
        return STATUS_INVALID_PARAMETER;
    }

    majorCode = !srbControl->DataIn ? IRP_MJ_WRITE : IRP_MJ_READ;

    if (srbControl->DataTransferLength == 0)
    {
        length = 0;
        buffer = NULL;
        bufferOffset = 0;
        majorCode = IRP_MJ_FLUSH_BUFFERS;

    }
    else if ((srbControl->DataBufferOffset > outputLength) &&
             (srbControl->DataBufferOffset >
              irpStack->Parameters.DeviceIoControl.InputBufferLength))
    {
        // The data buffer offset is greater than system buffer.  Assume this
        // is a user mode address.
        //
        if ((srbControl->SenseInfoOffset + srbControl->SenseInfoLength  >
             outputLength) &&
            srbControl->SenseInfoLength)
        {
            return STATUS_INVALID_PARAMETER;
        }

        length = srbControl->DataTransferLength;
        buffer = (PCHAR) srbControl->DataBufferOffset;
        bufferOffset = 0;

        // make sure the user buffer is valid
        //
        if (RequestIrp->RequestorMode != KernelMode)
        {
            if (length)
            {
                endByte =  (PVOID)((PCHAR)buffer + length - 1);

                if (buffer >= endByte)
                {
                    return STATUS_INVALID_USER_BUFFER;
                }
            }
        }
    }
    else
    {
        if (srbControl->DataIn != SCSI_IOCTL_DATA_IN)
        {
            if (((srbControl->SenseInfoOffset + srbControl->SenseInfoLength >
                  outputLength) &&
                 srbControl->SenseInfoLength != 0) ||
                (srbControl->DataBufferOffset + srbControl->DataTransferLength >
                 irpStack->Parameters.DeviceIoControl.InputBufferLength) ||
                (srbControl->Length > srbControl->DataBufferOffset))
            {
                return STATUS_INVALID_PARAMETER;
            }
        }

        if (srbControl->DataIn)
        {
            if ((srbControl->DataBufferOffset + srbControl->DataTransferLength >
                 outputLength) ||
                (srbControl->Length > srbControl->DataBufferOffset))
            {
                return STATUS_INVALID_PARAMETER;
            }
        }

        length = (ULONG)srbControl->DataBufferOffset +
                        srbControl->DataTransferLength;

        // Buffer base is the original srbControl, not the 32->64 bit
        // translated srbControl.
        //
        buffer = (PUCHAR) srbBuffer;

        bufferOffset = (ULONG)srbControl->DataBufferOffset;
    }

    // Validate that the request isn't too large for the miniport.
    //
    if (srbControl->DataTransferLength &&
        ((ADDRESS_AND_SIZE_TO_SPAN_PAGES(
              (PUCHAR)buffer+bufferOffset,
              srbControl->DataTransferLength
              ) > USBSTOR_MAX_TRANSFER_PAGES) ||
        (USBSTOR_MAX_TRANSFER_SIZE < srbControl->DataTransferLength)))
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (srbControl->TimeOutValue == 0 ||
        srbControl->TimeOutValue > 30 * 60 * 60)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check for illegal command codes.
    //

    if (srbControl->Cdb[0] == SCSIOP_COPY ||
        srbControl->Cdb[0] == SCSIOP_COMPARE ||
        srbControl->Cdb[0] == SCSIOP_COPY_COMPARE)
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // If this request came through a normal device control rather than from
    // class driver then the device must exist and be unclaimed. Class drivers
    // will set the minor function code for the device control.  It is always
    // zero for a user request.
    //
    if (irpStack->MinorFunction == 0 &&
        pdoDeviceExtension->Claimed)
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Allocate an aligned request sense buffer.
    //
    if (srbControl->SenseInfoLength != 0)
    {
        senseBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                            srbControl->SenseInfoLength,
                                            POOL_TAG);
        if (senseBuffer == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        senseBuffer = NULL;
    }

    //
    // Initialize the notification event.
    //

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    // Build IRP for this request.
    // Note we do this synchronously for two reasons.  If it was done
    // asynchonously then the completion code would have to make a special
    // check to deallocate the buffer.  Second if a completion routine were
    // used then an addation stack locate would be needed.
    //

    try
    {
        irp = IoBuildSynchronousFsdRequest(
                    majorCode,
                    DeviceObject,
                    buffer,
                    length,
                    &startingOffset,
                    &event,
                    &ioStatusBlock);

    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        // An exception was incurred while attempting to probe the
        // caller's parameters.  Dereference the file object and return
        // an appropriate error status code.
        //
        if (senseBuffer != NULL)
        {
            ExFreePool(senseBuffer);
        }

        return GetExceptionCode();
    }

    if (irp == NULL)
    {
        if (senseBuffer != NULL)
        {
            ExFreePool(senseBuffer);
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    // Set major code.
    //
    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    // Fill in SRB fields.
    //
    irpStack->Parameters.Others.Argument1 = &srb;

    // Zero out the srb.
    //
    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    // Fill in the srb.
    //
    srb.Length = SCSI_REQUEST_BLOCK_SIZE;
    srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb.SrbStatus = SRB_STATUS_PENDING;
    srb.CdbLength = srbControl->CdbLength;
    srb.SenseInfoBufferLength = srbControl->SenseInfoLength;

    switch (srbControl->DataIn)
    {
        case SCSI_IOCTL_DATA_OUT:
            if (srbControl->DataTransferLength)
            {
                srb.SrbFlags = SRB_FLAGS_DATA_OUT;
            }
            break;

        case SCSI_IOCTL_DATA_IN:
            if (srbControl->DataTransferLength)
            {
                srb.SrbFlags = SRB_FLAGS_DATA_IN;
            }
            break;

        default:
            srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT;
            break;
    }

    if (srbControl->DataTransferLength == 0)
    {
        srb.SrbFlags = 0;
    }
    else
    {
        // Flush the data buffer for output. This will insure that the data is
        // written back to memory.
        //
        KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);
    }

    srb.DataTransferLength = srbControl->DataTransferLength;
    srb.TimeOutValue = srbControl->TimeOutValue;
    srb.DataBuffer = (PCHAR) buffer + bufferOffset;
    srb.SenseInfoBuffer = senseBuffer;
    srb.OriginalRequest = irp;
    RtlCopyMemory(srb.Cdb, srbControl->Cdb, srbControl->CdbLength);

    // Call port driver to handle this request.
    //
    status = IoCallDriver(DeviceObject, irp);

    // Wait for request to complete.
    //
    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
    }
    else
    {
        ioStatusBlock.Status = status;
    }

    // Copy the returned values from the srb to the control structure.
    //
    srbControl->ScsiStatus = srb.ScsiStatus;

    if (srb.SrbStatus  & SRB_STATUS_AUTOSENSE_VALID)
    {
        // Set the status to success so that the data is returned.
        //
        ioStatusBlock.Status = STATUS_SUCCESS;
        srbControl->SenseInfoLength = srb.SenseInfoBufferLength;

        // Copy the sense data to the system buffer.
        //
        RtlCopyMemory((PUCHAR) srbBuffer + srbControl->SenseInfoOffset,
                      senseBuffer,
                      srb.SenseInfoBufferLength);
    }
    else
    {
        srbControl->SenseInfoLength = 0;
    }


    // Free the sense buffer.
    //
    if (senseBuffer != NULL)
    {
        ExFreePool(senseBuffer);
    }

    // If the srb status is buffer underrun then set the status to success.
    // This insures that the data will be returned to the caller.
    //
    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN)
    {
        ioStatusBlock.Status = STATUS_SUCCESS;
    }

    srbControl->DataTransferLength = srb.DataTransferLength;

    // Set the information length
    //
    if (!srbControl->DataIn || bufferOffset == 0)
    {

        RequestIrp->IoStatus.Information = srbControl->SenseInfoOffset +
                                           srbControl->SenseInfoLength;
    }
    else
    {
        RequestIrp->IoStatus.Information = srbControl->DataBufferOffset +
                                           srbControl->DataTransferLength;
    }

#if defined (_WIN64)
    if (srbControl32 != NULL)
    {
        USBSTOR_TranslatePassThrough64To32(srbControl, srbControl32);
    }
#endif

    RequestIrp->IoStatus.Status = ioStatusBlock.Status;

    DBGPRINT(2, ("exit:  USBSTOR_SendPassThrough %08X\n",
                 ioStatusBlock.Status));

    return ioStatusBlock.Status;
}


#if defined (_WIN64)

//******************************************************************************
//
// USBSTOR_TranslatePassThrough32To64()
//
// Translates a SCSI_PASS_THROUGH32 request from a 32-bit client into
// the equivalent 64-bit version.
//
//******************************************************************************

NTSTATUS
USBSTOR_TranslatePassThrough32To64(
    IN PSCSI_PASS_THROUGH32 SrbControl32,
    IN OUT PSCSI_PASS_THROUGH SrbControl64
    )
{
    if (SrbControl32->Length != sizeof(SCSI_PASS_THROUGH32) &&
        SrbControl32->Length != sizeof(SCSI_PASS_THROUGH_DIRECT32)) {
        return(STATUS_REVISION_MISMATCH);
    }

    //
    // Copy the first set of fields out of the 32-bit structure.  These
    // fields all line up between the 32 & 64 bit versions.
    //
    // Note that we do NOT adjust the length in the srbControl.  This is to
    // allow the calling routine to compare the length of the actual
    // control area against the offsets embedded within.  If we adjusted the
    // length then requests with the sense area backed against the control
    // area would be rejected because the 64-bit control area is 4 bytes
    // longer.
    //

    RtlCopyMemory(SrbControl64,
                  SrbControl32,
                  FIELD_OFFSET(SCSI_PASS_THROUGH, DataBufferOffset));

    //
    // Copy over the CDB.
    //

    RtlCopyMemory(SrbControl64->Cdb,
                  SrbControl32->Cdb,
                  16*sizeof(UCHAR)
                  );

    //
    // copy the fields that follow the ULONG_PTR
    //

    SrbControl64->DataBufferOffset = (ULONG_PTR) SrbControl32->DataBufferOffset;
    SrbControl64->SenseInfoOffset = SrbControl32->SenseInfoOffset;

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// USBSTOR_TranslatePassThrough64To32()
//
// Inverse of USBSTOR_TranslatePassThrough32To64() to translate the
// results back to a 32-bit client.
//
//******************************************************************************

VOID
USBSTOR_TranslatePassThrough64To32(
    IN PSCSI_PASS_THROUGH SrbControl64,
    IN OUT PSCSI_PASS_THROUGH32 SrbControl32
    )
{
    //
    // Copy back the fields through the data offsets.
    //

    RtlCopyMemory(SrbControl32,
                  SrbControl64,
                  FIELD_OFFSET(SCSI_PASS_THROUGH, DataBufferOffset));
    return;
}

#endif



//******************************************************************************
//
// IsRequestValid()
//
// Validates IRP_MJ_SCSI SRB_FUNCTION_EXECUTE_SCSI requests against
// assumptions made later when processing the Srb.
//
//******************************************************************************

BOOLEAN
IsRequestValid (
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    BOOLEAN                 result;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // Default return value unless a problem is found.
    //
    result = TRUE;

    // Note: SRB_FLAGS_UNSPECIFIED_DIRECTION is defined as
    //  (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)

    if ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) == 0) {

        // Neither SRB_FLAGS_DATA_IN nor SRB_FLAGS_DATA_IN is set.
        // A transfer buffer should not be specified.

        if (srb->DataTransferLength ||
            srb->DataBuffer ||
            Irp->MdlAddress) {

            result = FALSE;
        }

    } else if ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) ==
               SRB_FLAGS_UNSPECIFIED_DIRECTION) {

        // Both SRB_FLAGS_DATA_IN and SRB_FLAGS_DATA_IN are set.
        // We don't currently have a way to resolve this.

        result = FALSE;

    } else {

        // Either SRB_FLAGS_DATA_IN or SRB_FLAGS_DATA_IN is set.
        // A transfer buffer should be specified.

        if (!srb->DataTransferLength ||
            srb->DataTransferLength > USBSTOR_MAX_TRANSFER_SIZE ||
            //!srb->DataBuffer ||
            !Irp->MdlAddress) {

            result = FALSE;
        }
    }

    if (!result) {

        DBGPRINT(1, ("SrbFlags %08X, DataTransferLength %08X, "
                     "DataBuffer %08X, MdlAddress %08X\n",
                     srb->SrbFlags,
                     srb->DataTransferLength,
                     srb->DataBuffer,
                     Irp->MdlAddress));

        DBGPRINT(1, ("Irp %08X, Srb %08X\n",
                     Irp, srb));

        DBGFBRK(DBGF_BRK_INVALID_REQ);
    }

    return result;
}

//******************************************************************************
//
// USBSTOR_Scsi()
//
// Dispatch routine which handles IRP_MJ_SCSI
//
//******************************************************************************

NTSTATUS
USBSTOR_Scsi (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_Scsi\n"));

    DBGFBRK(DBGF_BRK_SCSI);

    deviceExtension = DeviceObject->DeviceExtension;

    // Only the PDO should handle IRP_MJ_SCSI
    //
    if (deviceExtension->Type == USBSTOR_DO_TYPE_PDO)
    {
        pdoDeviceExtension = DeviceObject->DeviceExtension;

        irpStack = IoGetCurrentIrpStackLocation(Irp);

        srb = irpStack->Parameters.Scsi.Srb;

        LOGENTRY('SCSI', DeviceObject, Irp, srb->Function);

        switch (srb->Function)
        {
            case SRB_FUNCTION_EXECUTE_SCSI:

                DBGPRINT(3, ("SRB_FUNCTION_EXECUTE_SCSI\n"));

                // XXXXX check STOP / REMOVE flags

                // XXXXX check SRB_FLAGS_BYPASS_LOCKED_QUEUE flag

                if (IsRequestValid(Irp))
                {
                    srb->SrbStatus = SRB_STATUS_PENDING;

                    IoMarkIrpPending(Irp);

                    IoStartPacket(pdoDeviceExtension->ParentFDO,
                                  Irp,
                                  &srb->QueueSortKey,
                                  USBSTOR_CancelIo);

                    ntStatus = STATUS_PENDING;
                }
                else
                {
                    ntStatus = STATUS_INVALID_PARAMETER;
                }
                break;


            case SRB_FUNCTION_FLUSH:

                DBGPRINT(2, ("SRB_FUNCTION_FLUSH\n"));

                ntStatus = STATUS_SUCCESS;
                srb->SrbStatus = SRB_STATUS_SUCCESS;
                break;

            case SRB_FUNCTION_CLAIM_DEVICE:

                DBGPRINT(2, ("SRB_FUNCTION_CLAIM_DEVICE\n"));

                //KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                //                  &irql);
                {
                    if (pdoDeviceExtension->Claimed)
                    {
                        ntStatus = STATUS_DEVICE_BUSY;
                        srb->SrbStatus = SRB_STATUS_BUSY;
                    }
                    else
                    {
                        pdoDeviceExtension->Claimed = TRUE;
                        srb->DataBuffer = DeviceObject;
                        ntStatus = STATUS_SUCCESS;
                        srb->SrbStatus = SRB_STATUS_SUCCESS;
                    }
                }
                //KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                //                  irql);
                break;

            case SRB_FUNCTION_RELEASE_DEVICE:

                DBGPRINT(2, ("SRB_FUNCTION_RELEASE_DEVICE\n"));

                //KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                //                  &irql);
                {
                    pdoDeviceExtension->Claimed = FALSE;
                }
                //KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                //                  irql);

                ntStatus = STATUS_SUCCESS;
                srb->SrbStatus = SRB_STATUS_SUCCESS;
                break;

            default:

                DBGPRINT(2, ("Unhandled SRB function %d\n", srb->Function));

                ntStatus = STATUS_NOT_SUPPORTED;
                srb->SrbStatus = SRB_STATUS_ERROR;
                break;
        }
    }
    else
    {
        ASSERT(deviceExtension->Type == USBSTOR_DO_TYPE_FDO);

        DBGPRINT(2, ("IRP_MJ_SCSI not supported for FDO\n"));

        ntStatus = STATUS_NOT_SUPPORTED;
    }

    if (ntStatus != STATUS_PENDING)
    {
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(3, ("exit:  USBSTOR_Scsi %08X\n", ntStatus));

    LOGENTRY('scsi', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_TranslateCDBSubmit()
//
// Called by USBSTOR_StartIo() before a request is started.
//
//******************************************************************************

VOID
USBSTOR_TranslateCDBSubmit (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PSCSI_REQUEST_BLOCK  Srb
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PCDB                    cdb;

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    if (fdoDeviceExtension->InterfaceDescriptor->bInterfaceSubClass ==
        USBSTOR_SUBCLASS_SCSI_PASSTHROUGH)
    {
        return;
    }

    // Save the original CDB
    //
    cdb = (PCDB)Srb->Cdb;

    RtlCopyMemory(fdoDeviceExtension->OriginalCDB, cdb, 16);

    // Make sure the CDB is padded with zero bytes.
    //
    if (Srb->CdbLength < 16)
    {
        RtlZeroMemory(&Srb->Cdb[Srb->CdbLength],
                      16 - Srb->CdbLength);

    }
    Srb->CdbLength = 12;

    switch (Srb->Cdb[0])
    {
        // Send a SCSIOP_START_STOP_UNIT request instead of a
        // SCSIOP_TEST_UNIT_READY request for selected buggy
        // devices which don't otherwise update their internal
        // geometry information when the media changes.
        //
        case SCSIOP_TEST_UNIT_READY:

            if (TEST_FLAG(fdoDeviceExtension->DeviceHackFlags,
                          DHF_TUR_START_UNIT))
            {
                // Zero the new CDB
                //
                RtlZeroMemory(cdb, 16);

                cdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
                cdb->START_STOP.Start = 1;
            }
            break;

        // Convert 6-byte Mode Sense to 10-byte Mode Sense
        //
        case SCSIOP_MODE_SENSE:
        {
            UCHAR PageCode;
            UCHAR Length;

            // Extract the relevant params from original CDB
            //
            PageCode = cdb->MODE_SENSE.PageCode;
            Length   = cdb->MODE_SENSE.AllocationLength;

            // Zero the new CDB
            //
            RtlZeroMemory(cdb, 16);

            // Insert the relevant params into the translated CDB
            //
            cdb->MODE_SENSE10.OperationCode         = SCSIOP_MODE_SENSE10;
            cdb->MODE_SENSE10.PageCode              = PageCode;
            cdb->MODE_SENSE10.AllocationLength[1]   = Length;
        }
        break;

        // Convert 6-byte Mode Select to 10-byte Mode Select
        //
        case SCSIOP_MODE_SELECT:
        {
            UCHAR SPBit;
            UCHAR Length;

            // Extract the relevant params from original CDB
            //
            SPBit   = cdb->MODE_SELECT.SPBit;
            Length  = cdb->MODE_SELECT.ParameterListLength;

            // Zero the new CDB
            //
            RtlZeroMemory(cdb, 16);

            // Insert the relevant params into the translated CDB
            //
            cdb->MODE_SELECT10.OperationCode            = SCSIOP_MODE_SELECT10;
            cdb->MODE_SELECT10.SPBit                    = SPBit;
            cdb->MODE_SELECT10.PFBit                    = 1;
            cdb->MODE_SELECT10.ParameterListLength[1]   = Length;
        }
        break;
    }
}

//******************************************************************************
//
// USBSTOR_TranslateSrbStatus()
//
// This routine translates an srb status into an ntstatus.
//
//******************************************************************************

NTSTATUS
USBSTOR_TranslateSrbStatus(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    switch (SRB_STATUS(Srb->SrbStatus)) {
    case SRB_STATUS_INVALID_LUN:
    case SRB_STATUS_INVALID_TARGET_ID:
    case SRB_STATUS_NO_DEVICE:
    case SRB_STATUS_NO_HBA:
        return(STATUS_DEVICE_DOES_NOT_EXIST);
    case SRB_STATUS_COMMAND_TIMEOUT:
    case SRB_STATUS_BUS_RESET:
    case SRB_STATUS_TIMEOUT:
        return(STATUS_IO_TIMEOUT);
    case SRB_STATUS_SELECTION_TIMEOUT:
        return(STATUS_DEVICE_NOT_CONNECTED);
    case SRB_STATUS_BAD_FUNCTION:
    case SRB_STATUS_BAD_SRB_BLOCK_LENGTH:
        return(STATUS_INVALID_DEVICE_REQUEST);
    case SRB_STATUS_DATA_OVERRUN:
        return(STATUS_BUFFER_OVERFLOW);
    default:
        return(STATUS_IO_DEVICE_ERROR);
    }

    return(STATUS_IO_DEVICE_ERROR);
}

//******************************************************************************
//
// USBSTOR_TranslateCDBComplete()
//
// Called everywhere a request is completed.
//
//******************************************************************************

VOID
USBSTOR_TranslateCDBComplete (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PSCSI_REQUEST_BLOCK  Srb
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PCDB                    cdb;

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    if (fdoDeviceExtension->InterfaceDescriptor->bInterfaceSubClass ==
        USBSTOR_SUBCLASS_SCSI_PASSTHROUGH)
    {
#if DBG
        if ((Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
            (Srb->SenseInfoBufferLength >= 14))
        {
            PSENSE_DATA senseData;

            senseData = (PSENSE_DATA)Srb->SenseInfoBuffer;

            DBGPRINT(1, ("OP: %02X SenseKey %02X ASC %02X ASCQ %02X\n",
                         Srb->Cdb[0],
                         senseData->SenseKey,
                         senseData->AdditionalSenseCode,
                         senseData->AdditionalSenseCodeQualifier));
        }
#endif
        if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS)
        {
            Irp->IoStatus.Status = USBSTOR_TranslateSrbStatus(Srb);
        }

        return;
    }

    if (Srb->Cdb[0] != fdoDeviceExtension->OriginalCDB[0])
    {
        cdb = (PCDB)Srb->Cdb;

        switch (Srb->Cdb[0])
        {
            // Convert 10-byte Mode Sense back to 6-byte Mode Sense
            //
            case SCSIOP_MODE_SENSE10:
            {
                if ((SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_SUCCESS ||
                     SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) &&
                    Srb->DataTransferLength >= sizeof(MODE_PARAMETER_HEADER10))
                {
                    PMODE_PARAMETER_HEADER   hdr6;
                    PMODE_PARAMETER_HEADER10 hdr10;

                    hdr6  = (PMODE_PARAMETER_HEADER)  Srb->DataBuffer;
                    hdr10 = (PMODE_PARAMETER_HEADER10)Srb->DataBuffer;

                    // Convert the 10-byte header to a 6-byte header
                    //
                    hdr6->ModeDataLength = hdr10->ModeDataLength[1];

                    hdr6->MediumType = hdr10->MediumType;

                    hdr6->DeviceSpecificParameter =
                        hdr10->DeviceSpecificParameter;

                    hdr6->BlockDescriptorLength =
                        hdr10->BlockDescriptorLength[1];

                    // Advance past headers
                    //
                    hdr6++;
                    hdr10++;

                    // Copy everything past the 10-byte header
                    //
                    RtlMoveMemory(hdr6,
                                  hdr10,
                                  (Srb->DataTransferLength -
                                   sizeof(MODE_PARAMETER_HEADER10)));

                    // Adjust the return size to account for the smaller header
                    //
                    Srb->DataTransferLength -= (sizeof(MODE_PARAMETER_HEADER10) -
                                                sizeof(MODE_PARAMETER_HEADER));

                    // Since we just shrunk Srb->DataTransferLength, don't
                    // we have SRB_STATUS_DATA_OVERRUN by definition???
                    //
                    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)
                    {
                        Srb->SrbStatus = SRB_STATUS_DATA_OVERRUN |
                                         SRB_STATUS_AUTOSENSE_VALID;
                    }
                    else
                    {
                        Srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
                    }
                }
            }
            break;
        }

        // Restore the original CDB
        //
        RtlCopyMemory(cdb, fdoDeviceExtension->OriginalCDB, 16);
    }

#if DBG
    if ((Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
        (Srb->SenseInfoBufferLength >= 14))
    {
        PSENSE_DATA senseData;

        senseData = (PSENSE_DATA)Srb->SenseInfoBuffer;

        DBGPRINT(1, ("OP: %02X SenseKey %02X ASC %02X ASCQ %02X\n",
                     Srb->Cdb[0],
                     senseData->SenseKey,
                     senseData->AdditionalSenseCode,
                     senseData->AdditionalSenseCodeQualifier));
    }
#endif

    if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS)
    {
        Irp->IoStatus.Status = USBSTOR_TranslateSrbStatus(Srb);
    }
}

//******************************************************************************
//
// USBSTOR_CancelIo()
//
// This routine runs at DPC level (until the cancel spinlock is released).
//
//******************************************************************************

VOID
USBSTOR_CancelIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    if (DeviceObject->CurrentIrp == Irp)
    {
        IoReleaseCancelSpinLock(Irp->CancelIrql);

        LOGENTRY('CAN1', DeviceObject, Irp, 0);

        DBGPRINT(1, ("USBSTOR_CancelIo cancelling CurrentIrp\n"));
    }
    else if (KeRemoveEntryDeviceQueue(&DeviceObject->DeviceQueue,
                                      &Irp->Tail.Overlay.DeviceQueueEntry))
    {
        IoReleaseCancelSpinLock(Irp->CancelIrql);

        LOGENTRY('CAN2', DeviceObject, Irp, 0);

        DBGPRINT(1, ("USBSTOR_CancelIo cancelling queued Irp\n"));

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else
    {
        IoReleaseCancelSpinLock(Irp->CancelIrql);
    }
}

//******************************************************************************
//
// USBSTOR_StartIo()
//
// This routine handles IRP_MJ_SCSI, SRB_FUNCTION_EXECUTE_SCSI requests from
// the device the queue.
//
// This routine runs at DPC level.
//
//******************************************************************************

VOID
USBSTOR_StartIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    BOOLEAN                 startNext;
    BOOLEAN                 deviceDisconnected;
    BOOLEAN                 persistentError;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    LOGENTRY('STIO', DeviceObject, Irp, 0);

    DBGPRINT(3, ("enter: USBSTOR_StartIo %08X %08X\n",
                 DeviceObject, Irp));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // Check to see if this is a power down Irp.
    //
    if (irpStack->MajorFunction == IRP_MJ_POWER)
    {
        // This is a power down Irp.  Now that we know that no transfer
        // requests are in progress, pass down the power Irp.

        ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
        ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);
        ASSERT(irpStack->Parameters.Power.State.DeviceState !=
               PowerDeviceD0);

        DBGPRINT(2, ("FDO Power Down Passing Down %08X %08X\n",
                     DeviceObject, Irp));

        LOGENTRY('FPDC', DeviceObject, Irp, 0);

        //
        // Signal that it is time to pass the request down to the next
        // lower driver
        //
        KeSetEvent(&fdoDeviceExtension->PowerDownEvent,
                   IO_NO_INCREMENT,
                   0);

        // Leave the device queue blocked now by simply not calling
        // IoStartNextPacket().  When we want to start the device queue
        // again, simply call IoStartNextPacket().

        return;
    }

    // If the Irp is not IRP_MJ_POWER it better be IRP_MJ_SCSI
    //
    ASSERT(irpStack->MajorFunction == IRP_MJ_SCSI);

    // Check to see if the current Irp was cancelled.
    //
    IoAcquireCancelSpinLock(&irql);
    IoSetCancelRoutine(Irp, NULL);

    if (Irp->Cancel)
    {
        // The current Irp was cancelled.  Complete the request now, and start
        // the next request, unless a reset is still in progress in which case
        // the next request will be started when the reset completes.
        //
        KeAcquireSpinLockAtDpcLevel(&fdoDeviceExtension->ExtensionDataSpinLock);
        {
            startNext = !TEST_FLAG(fdoDeviceExtension->DeviceFlags,
                                   DF_RESET_IN_PROGRESS);
        }
        KeReleaseSpinLockFromDpcLevel(&fdoDeviceExtension->ExtensionDataSpinLock);

        IoReleaseCancelSpinLock(irql);

        LOGENTRY('CAN3', DeviceObject, Irp, 0);

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        if (startNext)
        {
            IoStartNextPacket(DeviceObject, TRUE);
        }

        return;
    }

    // The current Irp was not cancelled.  It is no longer cancelable.
    //
    IoReleaseCancelSpinLock(irql);

    // Get our Irp parameters
    //
    srb = irpStack->Parameters.Scsi.Srb;
    fdoDeviceExtension->OriginalSrb = srb;

    deviceDisconnected = FALSE;
    persistentError = FALSE;

    KeAcquireSpinLockAtDpcLevel(&fdoDeviceExtension->ExtensionDataSpinLock);
    {
        if (TEST_FLAG(fdoDeviceExtension->DeviceFlags, DF_DEVICE_DISCONNECTED))
        {
            deviceDisconnected = TRUE;
        }
        else
        {
            fdoDeviceExtension->SrbTimeout = srb->TimeOutValue;

            if (TEST_FLAG(fdoDeviceExtension->DeviceFlags, DF_PERSISTENT_ERROR))
            {
                persistentError = TRUE;

                CLEAR_FLAG(fdoDeviceExtension->DeviceFlags, DF_PERSISTENT_ERROR);
            }
        }
    }
    KeReleaseSpinLockFromDpcLevel(&fdoDeviceExtension->ExtensionDataSpinLock);


    if (deviceDisconnected)
    {
        LOGENTRY('siod', DeviceObject, Irp, 0);

        // The device is disconnected, fail this request immediately and start
        // the next request.
        //
        srb->SrbStatus = SRB_STATUS_NO_DEVICE;
        srb->DataTransferLength = 0;

        ntStatus = STATUS_DEVICE_DOES_NOT_EXIST;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        IoStartNextPacket(DeviceObject, TRUE);
    }
    else
    {
        // Translate the CDB if necessary
        //
        USBSTOR_TranslateCDBSubmit(DeviceObject, Irp, srb);

        DBGPRINT(3, ("CDB OP 0x%02X, Length %d\n", srb->Cdb[0], srb->CdbLength));

        if (fdoDeviceExtension->DriverFlags == DeviceProtocolBulkOnly)
        {
            ntStatus = USBSTOR_CbwTransfer(DeviceObject,
                                           Irp);
        }
        else
        {
            if (persistentError && (srb->Cdb[0] != SCSIOP_REQUEST_SENSE))
            {
                // There was a persistent error during the last request which
                // was not cleared with an AutoSense, and this request is not
                // a Request Sense, so first clear the persistent error with a
                // Request Sense before issuing this request.
                //
                ntStatus = USBSTOR_IssueRequestSenseCdb(DeviceObject,
                                                        Irp,
                                                        NON_AUTO_SENSE);
            }
            else
            {
                // Normal case, just issue the real request.
                //
                ntStatus = USBSTOR_IssueClientCdb(DeviceObject,
                                                  Irp);
            }
        }
    }

    DBGPRINT(3, ("exit:  USBSTOR_StartIo %08X\n", ntStatus));

    return;
}

//******************************************************************************
//
// USBSTOR_CheckRequestTimeOut()
//
// Returns TRUE if the request timed out and the request should be completed.
//
//******************************************************************************

BOOLEAN
USBSTOR_CheckRequestTimeOut (
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PSCSI_REQUEST_BLOCK Srb,
    OUT PNTSTATUS           NtStatus
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    BOOLEAN                 resetStarted;
    KIRQL                   irql;
    PIO_STACK_LOCATION      irpStack;

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Check to see if a reset was started while this request was in progress.
    //
    resetStarted = FALSE;

    KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
    {
        CLEAR_FLAG(fdoDeviceExtension->DeviceFlags, DF_SRB_IN_PROGRESS);

        if (TEST_FLAG(fdoDeviceExtension->DeviceFlags, DF_RESET_IN_PROGRESS))
        {
            LOGENTRY('CRT1', DeviceObject, Irp, Srb);

            resetStarted = TRUE;
        }
    }
    KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);

    // If a timeout reset has been started, then complete this request with
    // a timeout error.  Well, don't actually complete the request just yet.
    // Signal the cancel completion event and let USBSTOR_ResetDeviceWorkItem()
    // complete the request.  This allows USBSTOR_ResetDeviceWorkItem() to
    // cancel the request without worrying about the request completing and
    // disappearing out from underneath it.
    //
    if (resetStarted)
    {
        irpStack = IoGetCurrentIrpStackLocation(Irp);

        Srb = fdoDeviceExtension->OriginalSrb;
        irpStack->Parameters.Scsi.Srb = Srb;

        Irp->IoStatus.Status = STATUS_IO_TIMEOUT;
        Irp->IoStatus.Information = 0;
        Srb->SrbStatus = SRB_STATUS_TIMEOUT;

        USBSTOR_TranslateCDBComplete(DeviceObject, Irp, Srb);

        *NtStatus = STATUS_MORE_PROCESSING_REQUIRED;

        KeSetEvent(&fdoDeviceExtension->CancelEvent,
                   IO_NO_INCREMENT,
                   FALSE);

        return TRUE;
    }
    else
    {
        fdoDeviceExtension->PendingIrp = NULL;

        return FALSE;
    }
}

//******************************************************************************
//
// USBSTOR_IssueControlRequest()
//
// This routine is called by USBSTOR_IssueClientCdb() and
// USBSTOR_IssueRequestSenseCdb()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Intializes the Control transfer Urb and sends it down the stack:
//
// bmRequestType = 0x21, Class specific, host to device transfer, to
//                       recipient interface
// bRequest      = 0x00, Accept Device Specific Command
// wValue        = 0x00, Not Used
// wIndex        = bInterfaceNumber
// wLength       = length of device specific command block
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueControlRequest (
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp,
    IN ULONG                    TransferBufferLength,
    IN PVOID                    TransferBuffer,
    IN PIO_COMPLETION_ROUTINE   CompletionRoutine,
    IN PVOID                    Context
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      nextStack;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *controlUrb;

    DBGPRINT(3, ("enter: USBSTOR_IssueControlRequest\n"));

    LOGENTRY('ICTR', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Control/Bulk/Interrupt Transfer URB in our
    // Device Extension
    //
    controlUrb = &fdoDeviceExtension->Urb.ControlUrb;

    // Initialize the Control Transfer URB, all fields default to zero
    //
    RtlZeroMemory(controlUrb, sizeof(*controlUrb));

    controlUrb->Hdr.Length = sizeof(*controlUrb);

    controlUrb->Hdr.Function = URB_FUNCTION_CLASS_INTERFACE;

    // controlUrb->TransferFlags            is already zero

    controlUrb->TransferBufferLength = TransferBufferLength;

    controlUrb->TransferBuffer = TransferBuffer;

    // controlUrb->TransferBufferMDL        is already zero

    // controlUrb->RequestTypeReservedBits  is already zero

    // controlUrb->Request                  is already zero

    // controlUrb->Value                    is already zero

    // Target the request at the proper interface on the device
    //
    controlUrb->Index = fdoDeviceExtension->InterfaceInfo->InterfaceNumber;

    // Set the Irp parameters for the lower driver
    //
    nextStack = IoGetNextIrpStackLocation(Irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = controlUrb;

    // Set the completion routine, which will handle the next phase of the Srb
    //
    IoSetCompletionRoutine(Irp,
                           CompletionRoutine,
                           Context,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel


    KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
    {
        fdoDeviceExtension->PendingIrp = Irp;

        SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_SRB_IN_PROGRESS);
    }
    KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);


    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            Irp);

    DBGPRINT(3, ("exit:  USBSTOR_IssueControlRequest %08X\n", ntStatus));

    LOGENTRY('ictr', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_IssueBulkOrInterruptRequest()
//
// This routine is called by USBSTOR_IssueClientBulkRequest(),
// USBSTOR_IssueInterruptRequest() and USBSTOR_IssueRequestSenseBulkRequest().
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Initializes the Bulk or Interrupt transfer Urb and sends it down the stack
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueBulkOrInterruptRequest (
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp,
    IN USBD_PIPE_HANDLE         PipeHandle,
    IN ULONG                    TransferFlags,
    IN ULONG                    TransferBufferLength,
    IN PVOID                    TransferBuffer,
    IN PMDL                     TransferBufferMDL,
    IN PIO_COMPLETION_ROUTINE   CompletionRoutine,
    IN PVOID                    Context
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      nextStack;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkIntrUrb;

    DBGPRINT(3, ("enter: USBSTOR_IssueBulkOrInterruptRequest\n"));

    LOGENTRY('IBIR', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk/Interrupt Transfer URB in our Device Extension
    //
    bulkIntrUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Initialize the Bulk/Interrupt Transfer URB, all fields default to zero
    //
    RtlZeroMemory(bulkIntrUrb, sizeof(*bulkIntrUrb));

    bulkIntrUrb->Hdr.Length = sizeof(*bulkIntrUrb);

    bulkIntrUrb->Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;

    bulkIntrUrb->PipeHandle = PipeHandle;

    bulkIntrUrb->TransferFlags = TransferFlags;

    bulkIntrUrb->TransferBufferLength = TransferBufferLength;

    bulkIntrUrb->TransferBuffer = TransferBuffer;

    bulkIntrUrb->TransferBufferMDL = TransferBufferMDL;

    // Set the Irp parameters for the lower driver
    //
    nextStack = IoGetNextIrpStackLocation(Irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = bulkIntrUrb;

    // Set the completion routine, which will handle the next phase of the Srb
    //
    IoSetCompletionRoutine(Irp,
                           CompletionRoutine,
                           Context,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel


    KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
    {
        fdoDeviceExtension->PendingIrp = Irp;

        SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_SRB_IN_PROGRESS);
    }
    KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);

    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            Irp);

    DBGPRINT(3, ("exit:  USBSTOR_IssueBulkOrInterruptRequest %08X\n", ntStatus));

    LOGENTRY('ibir', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//
// CBI (Control/Bulk/Interrupt) Routines
//

//
// Phase 1, CDB Control transfer
//

//******************************************************************************
//
// USBSTOR_IssueClientCdb()
//
// This routine is called by USBSTOR_StartIo().
//
// It runs at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to write the Srb->Cdb out the control endpoint.
//
// Sets USBSTOR_ClientCdbCompletion() as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueClientCdb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_IssueClientCdb\n"));

    LOGENTRY('ICDB', DeviceObject, Irp, 0);

    // Get the client Srb
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    ntStatus = USBSTOR_IssueControlRequest(
                   DeviceObject,
                   Irp,
                   srb->CdbLength,              // TransferBufferLength
                   srb->Cdb,                    // TransferBuffer
                   USBSTOR_ClientCdbCompletion, // CompletionRoutine
                   NULL);                       // Context

    DBGPRINT(3, ("exit:  USBSTOR_IssueClientCdb %08X\n", ntStatus));

    LOGENTRY('icdb', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_ClientCdbCompletion()
//
// Completion routine used by USBSTOR_IssueClientCdb()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the CDB USB transfer failed due to a STALL and AutoSense is not
// disabled, do not complete the request yet and start a Request Sense by
// calling USBSTOR_IssueRequestSenseCdb(AUTO_SENSE).
//
// Else if the CDB USB transfer failed due to a STALL and AutoSense is
// disabled, mark a persistant error and complete the request.
//
// Else if the CDB USB transfer failed due to some other reason, complete the
// request and start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the CDB USB transfer succeeded and the Srb has a transfer buffer,
// do not complete the request yet and start the bulk data transfer by calling
// USBSTOR_IssueClientBulkRequest().
//
// Else if the CDB USB transfer succeeded and the Srb has no transfer buffer,
// do not complete the request yet and start the command completion interrupt
// data transfer by calling USBSTOR_IssueInterruptRequest().
//
//******************************************************************************

NTSTATUS
USBSTOR_ClientCdbCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *controlUrb;

    DBGPRINT(3, ("enter: USBSTOR_ClientCdbCompletion\n"));

    LOGENTRY('CDBC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Control Transfer URB in our Device Extension
    //
    controlUrb = &fdoDeviceExtension->Urb.ControlUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('cdb1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_ClientCdbCompletion: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The CDB Control Transfer was not successful.  Look at how the
        // the transfer failed to figure out how to recover.
        //

        LOGENTRY('cdb2', Irp->IoStatus.Status, controlUrb->Hdr.Status, 0);

        DBGPRINT(1, ("CDB transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, controlUrb->Hdr.Status));

        if (USBD_STATUS(controlUrb->Hdr.Status) ==
            USBD_STATUS(USBD_STATUS_STALL_PID))
        {
            // The device STALLed the Control Transfer

            srb->SrbStatus = SRB_STATUS_ERROR;
            srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
            srb->DataTransferLength = 0;

            if (!(srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) &&
                (srb->SenseInfoBufferLength != 0) &&
                (srb->SenseInfoBuffer != NULL))
            {
                LOGENTRY('cdb3', fdoDeviceObject, Irp, srb);

                // AutoSense is not disabled so do not complete the request yet
                // and issue a Request Sense.  This request will be completed
                // and the next request started when the AutoSense Request
                // Sense completes later.
                //
                ntStatus = USBSTOR_IssueRequestSenseCdb(fdoDeviceObject,
                                                        Irp,
                                                        AUTO_SENSE);

                return STATUS_MORE_PROCESSING_REQUIRED;
            }
            else
            {
                LOGENTRY('cdb4', fdoDeviceObject, Irp, srb);

                // AutoSense is disabled so mark a persistent error and complete
                // this request now.  Also start the next request now.
                //
                ntStatus = STATUS_IO_DEVICE_ERROR;
                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;

                KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                                  &irql);
                {
                    SET_FLAG(fdoDeviceExtension->DeviceFlags,
                             DF_PERSISTENT_ERROR);
                }
                KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                                  irql);

                USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

                KeRaiseIrql(DISPATCH_LEVEL, &irql);
                {
                    IoStartNextPacket(fdoDeviceObject, TRUE);
                }
                KeLowerIrql(irql);

                return ntStatus;
            }
        }
        else
        {
            LOGENTRY('cdb5', fdoDeviceObject, Irp, srb);

            // Else some other strange error has occured.  Maybe the device is
            // unplugged, or maybe the device port was disabled, or maybe the
            // request was cancelled.
            //
            // Complete this request now and then reset the device.  The next
            // request will be started when the reset completes.
            //
            ntStatus = STATUS_IO_DEVICE_ERROR;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_BUS_RESET;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetDevice(fdoDeviceObject);

            DBGPRINT(1, ("USBSTOR_ClientCdbCompletion: xfer error completion\n"));

            return ntStatus;
        }
    }

    // The CDB Control Transfer was successful.  Start the next phase, either
    // the Data Bulk Transfer or Command Completion Interrupt Transfer, and do
    // not complete the request yet (unless there is no Bulk Transfer and the
    // Interrupt Transfer is not supported).
    //
    if (Irp->MdlAddress != NULL)
    {
        LOGENTRY('cdb6', fdoDeviceObject, Irp, srb);

        ASSERT(srb->DataTransferLength != 0);

        // The Srb has a transfer buffer, start the Data Bulk Transfer.
        //
        ntStatus = USBSTOR_IssueClientBulkRequest(fdoDeviceObject,
                                                  Irp);

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_ERROR;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetDevice(fdoDeviceObject);
        }
    }
    else
    {
        ASSERT(srb->DataTransferLength == 0);

        // The Srb has no transfer buffer.  If the Command Completion
        // Interrupt Transfer is supported, start the Command Completion
        // Interrupt Transfer, else just complete the request now and
        // start the next request.
        //
        if (fdoDeviceExtension->InterruptInPipe)
        {
            LOGENTRY('cdb7', fdoDeviceObject, Irp, srb);

            srb->SrbStatus = SRB_STATUS_SUCCESS;

            ntStatus = USBSTOR_IssueInterruptRequest(fdoDeviceObject,
                                                     Irp);

            ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            LOGENTRY('cdb8', fdoDeviceObject, Irp, srb);

            ntStatus = STATUS_SUCCESS;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_SUCCESS;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            KeRaiseIrql(DISPATCH_LEVEL, &irql);
            {
                IoStartNextPacket(fdoDeviceObject, TRUE);
            }
            KeLowerIrql(irql);
        }
    }

    DBGPRINT(3, ("exit:  USBSTOR_ClientCdbCompletion %08X\n", ntStatus));

    return ntStatus;
}

//
// Phase 2, Data Bulk transfer
//

//******************************************************************************
//
// USBSTOR_IssueClientBulkRequest()
//
// This routine is called by USBSTOR_ClientCdbCompletion().
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to read or write the Srb->DataBuffer data In or Out
// the Bulk endpoint.
//
// Sets USBSTOR_ClientBulkCompletionRoutine() as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueClientBulkRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    PMDL                    mdl;
    PVOID                   mdlVa;
    USBD_PIPE_HANDLE        pipeHandle;
    ULONG                   transferFlags;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_IssueClientBulkRequest\n"));

    LOGENTRY('ICBK', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // Bulk IN or Bulk OUT?
    //
    if ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) == SRB_FLAGS_DATA_IN)
    {
        pipeHandle = fdoDeviceExtension->BulkInPipe->PipeHandle;
        transferFlags = USBD_SHORT_TRANSFER_OK;
    }
    else if ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) == SRB_FLAGS_DATA_OUT)
    {
        pipeHandle = fdoDeviceExtension->BulkOutPipe->PipeHandle;
        transferFlags = 0;
    }
    else
    {
        // Something is wrong if we end up here.
        //
        ASSERT((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) &&
               ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) !=
                SRB_FLAGS_UNSPECIFIED_DIRECTION));

        return STATUS_INVALID_PARAMETER;
    }

    // Check to see if this request is part of a split request.
    //
    mdlVa = MmGetMdlVirtualAddress(Irp->MdlAddress);

    if (mdlVa == (PVOID)srb->DataBuffer)
    {
        // Not part of a split request, use original MDL
        //
        mdl = Irp->MdlAddress;
    }
    else
    {
        // Part of a split request, allocate new partial MDL
        //
        mdl = IoAllocateMdl(srb->DataBuffer,
                            srb->DataTransferLength,
                            FALSE,
                            FALSE,
                            NULL);
        if (mdl == NULL)
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            IoBuildPartialMdl(Irp->MdlAddress,
                              mdl,
                              srb->DataBuffer,
                              srb->DataTransferLength);
        }
    }

    if (mdl != NULL)
    {
        ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                       DeviceObject,
                       Irp,
                       pipeHandle,                          // PipeHandle
                       transferFlags,                       // TransferFlags
                       srb->DataTransferLength,             // TransferBufferLen
                       NULL,                                // TransferBuffer
                       mdl,                                 // TransferBufferMDL
                       USBSTOR_ClientBulkCompletionRoutine, // CompletionRoutine
                       NULL);                               // Context

        // Just return STATUS_SUCCESS at this point.  If there is an error,
        // USBSTOR_ClientBulkCompletionRoutine() will handle it, not the caller
        // of USBSTOR_IssueClientBulkRequest().
        //
        ntStatus = STATUS_SUCCESS;
    }

    DBGPRINT(3, ("exit:  USBSTOR_IssueClientBulkRequest %08X\n", ntStatus));

    LOGENTRY('icbk', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_ClientBulkCompletionRoutine()
//
// Completion routine used by USBSTOR_IssueClientBulkRequest
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the Bulk USB transfer failed due to a STALL and AutoSense is not
// disabled, do not complete the request yet and start a pipe reset by calling
// USBSTOR_QueueResetPipe().
//
// Else if the Bulk USB transfer failed due to a STALL and AutoSense is
// disabled, mark a persistant error and complete the request.
//
// Else if the Bulk USB transfer failed due to some other reason, complete the
// request and start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the Bulk USB transfer succeeded, start the command completion
// interrupt data transfer by calling USBSTOR_IssueInterruptRequest().
//
//******************************************************************************

NTSTATUS
USBSTOR_ClientBulkCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkUrb;

    DBGPRINT(3, ("enter: USBSTOR_ClientBulkCompletionRoutine\n"));

    LOGENTRY('CBKC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk Transfer URB in our Device Extension
    //
    bulkUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    if (bulkUrb->TransferBufferMDL != Irp->MdlAddress)
    {
        IoFreeMdl(bulkUrb->TransferBufferMDL);
    }

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('cbk1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_ClientBulkCompletionRoutine: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The Data Bulk Transfer was not successful.  Look at how the
        // the transfer failed to figure out how to recover.
        //

        LOGENTRY('cbk2', Irp->IoStatus.Status, bulkUrb->Hdr.Status, 0);

        DBGPRINT(1, ("Client Bulk transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, bulkUrb->Hdr.Status));

        if (USBD_STATUS(bulkUrb->Hdr.Status) ==
            USBD_STATUS(USBD_STATUS_STALL_PID))
        {
            // The device STALLed the Bulk Transfer

            srb->SrbStatus = SRB_STATUS_ERROR;
            srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
            srb->DataTransferLength = bulkUrb->TransferBufferLength;

            if (!(srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) &&
                (srb->SenseInfoBufferLength != 0) &&
                (srb->SenseInfoBuffer != NULL))
            {
                LOGENTRY('cbk3', fdoDeviceObject, Irp, srb);

                // AutoSense is not disabled so do not complete the request
                // yet.  Queue a bulk pipe reset.  After the bulk pipe reset
                // completes, a Request Sense will be issued.  This request
                // will be completed and the next request started when the
                // AutoSense Request Sense completes later.
                //
                USBSTOR_QueueResetPipe(fdoDeviceObject);

                return STATUS_MORE_PROCESSING_REQUIRED;
            }
            else
            {
                LOGENTRY('cbk4', fdoDeviceObject, Irp, srb);

                // AutoSense is disabled so mark a persistent error and
                // complete the request, but also queue a bulk pipe reset.
                //
                // The next request will be started when the bulk pipe
                // reset completes.
                //
                ntStatus = STATUS_IO_DEVICE_ERROR;
                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;

                KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                                  &irql);
                {
                    SET_FLAG(fdoDeviceExtension->DeviceFlags,
                             DF_PERSISTENT_ERROR);
                }
                KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                                  irql);

                USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

                USBSTOR_QueueResetPipe(fdoDeviceObject);

                return ntStatus;
            }
        }
        else
        {
            LOGENTRY('cbk5', fdoDeviceObject, Irp, srb);

            // Else some other strange error has occured.  Maybe the device is
            // unplugged, or maybe the device port was disabled, or maybe the
            // request was cancelled.
            //
            // Complete this request now and then reset the device.  The next
            // request will be started when the reset completes.
            //
            ntStatus = STATUS_IO_DEVICE_ERROR;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_BUS_RESET;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetDevice(fdoDeviceObject);

            DBGPRINT(1, ("USBSTOR_ClientBulkCompletionRoutine: xfer error completion\n"));

            return ntStatus;
        }
    }

    // Check for overrun
    //
    if (bulkUrb->TransferBufferLength < srb->DataTransferLength)
    {
        srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
    }
    else
    {
        srb->SrbStatus = SRB_STATUS_SUCCESS;
    }

    // Update the the Srb data transfer length based on the actual bulk
    // transfer length.
    //
    srb->DataTransferLength = bulkUrb->TransferBufferLength;

    // Client data Bulk Transfer successful completion.  If the Command
    // Completion Interrupt Transfer is supported, start the Command Completion
    // Interrupt Transfer, else just complete the request now and start the
    // next request.
    //
    if (fdoDeviceExtension->InterruptInPipe)
    {
        LOGENTRY('cbk6', fdoDeviceObject, Irp, bulkUrb->TransferBufferLength);

        ntStatus = USBSTOR_IssueInterruptRequest(fdoDeviceObject,
                                                 Irp);

        ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
    }
    else
    {
        LOGENTRY('cbk7', fdoDeviceObject, Irp, bulkUrb->TransferBufferLength);

        ntStatus = STATUS_SUCCESS;
        Irp->IoStatus.Status = ntStatus;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        Irp->IoStatus.Information = srb->DataTransferLength;

        KeRaiseIrql(DISPATCH_LEVEL, &irql);
        {
            IoStartNextPacket(fdoDeviceObject, TRUE);
        }
        KeLowerIrql(irql);
    }

    DBGPRINT(3, ("exit:  USBSTOR_ClientBulkCompletionRoutine %08X\n", ntStatus));

    return ntStatus;
}

//
// Phase 3, Command completion Interrupt transfer
//

//******************************************************************************
//
// USBSTOR_IssueInterruptRequest()
//
// This routine is called by USBSTOR_ClientCdbCompletion() and
// USBSTOR_ClientBulkCompletionRoutine()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to read the command completion interrupt data In
// the Interrupt endpoint.
//
// Sets USBSTOR_InterruptDataCompletionRoutine() as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueInterruptRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    USBD_PIPE_HANDLE        pipeHandle;
    ULONG                   transferBufferLength;
    PVOID                   transferBuffer;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_IssueInterruptRequest\n"));

    LOGENTRY('IINT', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    pipeHandle = fdoDeviceExtension->InterruptInPipe->PipeHandle;

    transferBufferLength = sizeof(fdoDeviceExtension->Cbi.InterruptData);

    transferBuffer = &fdoDeviceExtension->Cbi.InterruptData;

    ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                   DeviceObject,
                   Irp,
                   pipeHandle,                              // PipeHandle
                   0,                                       // TransferFlags
                   transferBufferLength,                    // TransferBufferLength
                   transferBuffer,                          // TransferBuffer
                   NULL,                                    // TransferBufferMDL
                   USBSTOR_InterruptDataCompletionRoutine,  // CompletionRoutine
                   NULL);                                   // Context

    DBGPRINT(3, ("exit:  USBSTOR_IssueInterruptRequest %08X\n", ntStatus));

    LOGENTRY('iint', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_InterruptDataCompletionRoutine()
//
// Completion routine used by USBSTOR_IssueInterruptRequest()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the Interrupt USB transfer failed due to any reason, complete the
// request and start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the Interrupt USB transfer succeeded but the completion data is
// non-zero and AutoSense is not disabled, do not complete the request yet and
// start a Request Sense by calling USBSTOR_IssueRequestSenseCdb(AUTO).
//
// Else if the Interrupt USB transfer succeeded but the completion data is
// non-zero and AutoSense is disabled, mark a persistant error and complete
// the request.
//
// Else if the Interrupt USB transfer succeeded and the completion data is
// zero, complete the request.
//
//******************************************************************************

NTSTATUS
USBSTOR_InterruptDataCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *intrUrb;

    DBGPRINT(3, ("enter: USBSTOR_InterruptDataCompletionRoutine\n"));

    LOGENTRY('IDCR', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Interrupt Transfer URB in our Device Extension
    //
    intrUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('idc1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_InterruptDataCompletionRoutine: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The Interrupt CDB USB transfer failed.  Complete this request
        // now and then reset the device.  The next request will be started
        // when the reset completes.
        //
        LOGENTRY('idc2', Irp->IoStatus.Status, intrUrb->Hdr.Status, 0);

        DBGPRINT(1, ("Interrupt transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, intrUrb->Hdr.Status));

        ntStatus = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        srb->SrbStatus = SRB_STATUS_BUS_RESET;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(fdoDeviceObject);

        DBGPRINT(1, ("USBSTOR_InterruptDataCompletionRoutine: xfer error completion\n"));

        return ntStatus;
    }

    if ((fdoDeviceExtension->Cbi.InterruptData != 0) &&
        (srb->Cdb[0] != SCSIOP_INQUIRY) &&
        (srb->Cdb[0] != SCSIOP_REQUEST_SENSE))
    {
        // Command completion interrupt data indicates an error.  Either don't
        // complete the request yet and start an AutoSense, or complete the
        // request now and indicate a persistent error.
        //
        srb->SrbStatus = SRB_STATUS_ERROR;
        srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
        srb->DataTransferLength = 0; // XXXXX Leave as set by bulk completion???

        if (!(srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) &&
            (srb->SenseInfoBufferLength != 0) &&
            (srb->SenseInfoBuffer != NULL))
        {
            LOGENTRY('idc3', fdoDeviceObject, Irp, srb);

            // AutoSense is not disabled so do not complete the request
            // yet.  Queue a bulk pipe reset.  After the bulk pipe reset
            // completes, a Request Sense will be issued.  This request
            // will be completed and the next request started when the
            // AutoSense Request Sense completes later.
            //
            USBSTOR_QueueResetPipe(fdoDeviceObject);

            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            LOGENTRY('idc4', fdoDeviceObject, Irp, srb);

            // AutoSense is disabled so mark a persistent error and
            // complete the request, but also queue a bulk pipe reset.
            //
            // The next request will be started when the bulk pipe
            // reset completes.
            //
            ntStatus = STATUS_IO_DEVICE_ERROR;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;

            KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
            {
                SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_PERSISTENT_ERROR);
            }
            KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetPipe(fdoDeviceObject);

            return ntStatus;
        }
    }

    // Hack for Y-E Data USB Floppy.  Occasionally it will return interrupt
    // data with the wrong data toggle.  The interrupt data with the wrong
    // toggle is silently ignored, which results in a request timeout.
    // Forcing a Request Sense command between the completion of one command
    // and the start of the next appears to be one way to work around this.
    //
    if (TEST_FLAG(fdoDeviceExtension->DeviceHackFlags, DHF_FORCE_REQUEST_SENSE))
    {
        KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
        {
            SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_PERSISTENT_ERROR);
        }
        KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);
    }

    // The Interrupt USB transfer succeeded and the completion data is zero,
    // complete this request now.  Also start the next request now.

    ntStatus = STATUS_SUCCESS;
    Irp->IoStatus.Status = ntStatus;

    ASSERT(srb->SrbStatus != SRB_STATUS_PENDING);

    USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

    Irp->IoStatus.Information = srb->DataTransferLength;

    LOGENTRY('idc5', fdoDeviceObject, Irp, srb);

    KeRaiseIrql(DISPATCH_LEVEL, &irql);
    {
        IoStartNextPacket(fdoDeviceObject, TRUE);
    }
    KeLowerIrql(irql);

    DBGPRINT(3, ("exit:  USBSTOR_InterruptDataCompletionRoutine %08X\n", ntStatus));

    return ntStatus;
}

//
// Phase 4, Request Sense CDB Control transfer
//

//******************************************************************************
//
// USBSTOR_IssueRequestSenseCdb()
//
// This routine can be called by USBSTOR_StartIo, USBSTOR_ClientCdbCompletion(),
// USBSTOR_InterruptDataCompletionRoutine(), and by USBSTOR_ResetPipeWorkItem().
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to write a Request Sense CDB out the control endpoint.
//
// Sets USBSTOR_RequestSenseCdbCompletion(AutoFlag) as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueRequestSenseCdb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    ULONG                   transferBufferLength;
    PVOID                   transferBuffer;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_IssueRequestSenseCdb\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get the client Srb
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // The Control Transfer data buffer is our own Request Sense Cdb
    //
    RtlZeroMemory(fdoDeviceExtension->Cbi.RequestSenseCDB,
                  sizeof(fdoDeviceExtension->Cbi.RequestSenseCDB));

    fdoDeviceExtension->Cbi.RequestSenseCDB[0] = SCSIOP_REQUEST_SENSE;

    transferBufferLength = sizeof(fdoDeviceExtension->Cbi.RequestSenseCDB);

    transferBuffer = fdoDeviceExtension->Cbi.RequestSenseCDB;

    // If this is an AutoSense, we'll use the client Srb Sense Info Buffer,
    // else we are doing this Request Sense to clear a persistent error and
    // we'll use our own sense info buffer.
    //
    if (AutoFlag == AUTO_SENSE)
    {
        fdoDeviceExtension->Cbi.RequestSenseCDB[4] =
            srb->SenseInfoBufferLength;
    }
    else
    {
        fdoDeviceExtension->Cbi.RequestSenseCDB[4] =
            sizeof(fdoDeviceExtension->Cbi.SenseData);
    }

    ntStatus = USBSTOR_IssueControlRequest(
                   DeviceObject,
                   Irp,
                   transferBufferLength,                // TransferBufferLength
                   transferBuffer,                      // TransferBuffer
                   USBSTOR_RequestSenseCdbCompletion,   // CompletionRoutine
                   (PVOID)AutoFlag);                    // Context

    DBGPRINT(3, ("exit:  USBSTOR_IssueRequestSenseCdb %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_RequestSenseCdbCompletion()
//
// Completion routine used by USBSTOR_IssueRequestSenseCdb
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the Request Sense CDB USB transfer failed, complete the request and
// start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the Request Sense CDB USB transfer succeeded, do not complete the
// request yet and start the Request Sense Bulk USB data transfer by calling
// USBSTOR_IssueRequestSenseBulkRequest(AutoFlag)
//
//******************************************************************************

NTSTATUS
USBSTOR_RequestSenseCdbCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            AutoFlag
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *controlUrb;

    DBGPRINT(3, ("enter: USBSTOR_RequestSenseCdbCompletion\n"));

    LOGENTRY('RSCC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Control/Bulk/Interrupt Transfer URB in our Device
    // Extension
    //
    controlUrb = &fdoDeviceExtension->Urb.ControlUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('rsc1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_RequestSenseCdbCompletion: timeout completion\n"));
        return ntStatus;
    }


    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        LOGENTRY('rsc2', Irp->IoStatus.Status, controlUrb->Hdr.Status, 0);

        DBGPRINT(1, ("Request Sense CDB transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, controlUrb->Hdr.Status));

        // The Request Sense CDB USB transfer failed.  Complete this request
        // now and then reset the device.  The next request will be started
        // when the reset completes.
        //
        ntStatus = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        srb->SrbStatus = SRB_STATUS_BUS_RESET;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(fdoDeviceObject);

        DBGPRINT(1, ("USBSTOR_RequestSenseCdbCompletion: xfer error completion\n"));

        return ntStatus;
    }

    LOGENTRY('rsc3', Irp->IoStatus.Status, controlUrb->Hdr.Status, 0);

    // The Request Sense CDB USB transfer succeeded, do not complete the request
    // yet and start the Request Sense Bulk USB data transfer.
    //
    ntStatus = USBSTOR_IssueRequestSenseBulkRequest(fdoDeviceObject,
                                                    Irp,
                                                    (ULONG_PTR)AutoFlag);

    DBGPRINT(3, ("exit:  USBSTOR_RequestSenseCdbCompletion %08X\n", ntStatus));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//
// Phase 5, Request Sense Bulk transfer
//

//******************************************************************************
//
// USBSTOR_IssueRequestSenseBulkRequest()
//
// This routine is called by USBSTOR_RequestSenseCdbCompletion().
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to read the Requese Sense data in the bulk endpoint.
//
// If AutoFlag==AUTO, transfer buffer = Srb->SenseInfoBuffer.
//
// Else if AutoFlag==NON_AUTO, transfer buffer = bit bucket
//
// Sets USBSTOR_SenseDataCompletionRoutine(AutoFlag) as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueRequestSenseBulkRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    USBD_PIPE_HANDLE        pipeHandle;
    ULONG                   transferBufferLength;
    PVOID                   transferBuffer;
    NTSTATUS                ntStatus;

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    pipeHandle = fdoDeviceExtension->BulkInPipe->PipeHandle;

    // If this is an AutoSense, we'll use the client Srb Sense Info Buffer,
    // else we are doing this Request Sense to clear a persistent error and
    // we'll use our own sense info buffer.
    //
    if (AutoFlag == AUTO_SENSE)
    {
        transferBufferLength = srb->SenseInfoBufferLength;
        transferBuffer = srb->SenseInfoBuffer;
    }
    else
    {
        transferBufferLength = sizeof(fdoDeviceExtension->Cbi.SenseData);
        transferBuffer = &fdoDeviceExtension->Cbi.SenseData;
    }

    RtlZeroMemory(&fdoDeviceExtension->Cbi.SenseData,
                  sizeof(fdoDeviceExtension->Cbi.SenseData));

    ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                   DeviceObject,
                   Irp,
                   pipeHandle,                          // PipeHandle
                   USBD_SHORT_TRANSFER_OK,              // TransferFlags
                   transferBufferLength,                // TransferBufferLength
                   transferBuffer,                      // TransferBuffer
                   NULL,                                // TransferBufferMDL
                   USBSTOR_SenseDataCompletionRoutine,  // CompletionRoutine
                   (PVOID)AutoFlag);                    // Context

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_SenseDataCompletionRoutine()
//
// Completion routine used by USBSTOR_IssueRequestSenseBulkRequest()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the Request Sense Bulk USB transfer failed due to any reason,
// complete the request and start a reset by queuing a call to
// USBSTOR_ResetDeviceWorkItem().
//
// Else if the Request Sense Bulk USB transfer succeeded and the device
// does support the command completion interrupt, start the command completion
// interrupt transfer by calling USBSTOR_IssueRequestSenseInterruptRequest().
//
// Else if the Request Sense Bulk USB transfer succeeded and the device
// does not support the command completion interrupt, complete the request
// by calling USBSTOR_ProcessRequestSenseCompletion().
//
//******************************************************************************

NTSTATUS
USBSTOR_SenseDataCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            AutoFlag
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkUrb;

    DBGPRINT(3, ("enter: USBSTOR_SenseDataCompletionRoutine\n"));

    LOGENTRY('SDCR', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk Transfer URB in our Device Extension
    //
    bulkUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('sdc1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_SenseDataCompletionRoutine: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        LOGENTRY('sdc2', Irp->IoStatus.Status, bulkUrb->Hdr.Status, 0);

        DBGPRINT(1, ("BULK sense data transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, bulkUrb->Hdr.Status));

        // The Request Sense Bulk USB transfer failed.  Complete this request
        // now and then reset the device.  The next request will be started
        // when the reset completes.
        //
        ntStatus = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        srb->SrbStatus = SRB_STATUS_BUS_RESET;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(fdoDeviceObject);

        DBGPRINT(1, ("USBSTOR_SenseDataCompletionRoutine: xfer error completion\n"));

        return ntStatus;
    }

    // The Request Sense Bulk transfer completed successfully.

    LOGENTRY('sdc3', Irp->IoStatus.Status, bulkUrb->Hdr.Status,
             bulkUrb->TransferBufferLength);

    // Save the sense data so we can look at it after the command
    // completion interrupt transfer completes.
    //
    if ((ULONG_PTR)AutoFlag == AUTO_SENSE)
    {
        RtlCopyMemory(&fdoDeviceExtension->Cbi.SenseData,
                      bulkUrb->TransferBuffer,
                      min(bulkUrb->TransferBufferLength,
                          sizeof(fdoDeviceExtension->Cbi.SenseData)));

        // Update the SRB with the length of the sense data that was
        // actually returned.
        //
        srb->SenseInfoBufferLength = (UCHAR)bulkUrb->TransferBufferLength;
    }

    DBGPRINT(2, ("Sense Data: 0x%02X 0x%02X 0x%02X\n",
                 fdoDeviceExtension->Cbi.SenseData.SenseKey,
                 fdoDeviceExtension->Cbi.SenseData.AdditionalSenseCode,
                 fdoDeviceExtension->Cbi.SenseData.AdditionalSenseCodeQualifier));

    if (fdoDeviceExtension->InterruptInPipe)
    {
        // Command completion interrupt supported.  Do not complete the
        // request yet.  Start the Request Sense command completion interrupt
        // transfer.
        //
        ntStatus = USBSTOR_IssueRequestSenseInterruptRequest(
                       fdoDeviceObject,
                       Irp,
                       (ULONG_PTR)AutoFlag);

        ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
    }
    else
    {
        // Command completion interrupt not supported.  Complete the request
        // now.
        //
        ntStatus = USBSTOR_ProcessRequestSenseCompletion(
                       fdoDeviceObject,
                       Irp,
                       (ULONG_PTR)AutoFlag);
    }

    DBGPRINT(3, ("exit:  USBSTOR_SenseDataCompletionRoutine %08X\n", ntStatus));

    return ntStatus;
}

//
// Phase 6, Request Sense Command completion Interrupt transfer
//

//******************************************************************************
//
// USBSTOR_IssueRequestSenseInterruptRequest()
//
// This routine is called USBSTOR_SenseDataCompletionRoutine()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to read the command completion interrupt data In
// the Interrupt endpoint.
//
// Sets USBSTOR_RequestSenseInterruptCompletionRoutine() as the completion
// routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueRequestSenseInterruptRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    USBD_PIPE_HANDLE        pipeHandle;
    ULONG                   transferBufferLength;
    PVOID                   transferBuffer;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_IssueRequestSenseInterruptRequest\n"));

    LOGENTRY('IRSI', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    pipeHandle = fdoDeviceExtension->InterruptInPipe->PipeHandle;

    transferBufferLength = sizeof(fdoDeviceExtension->Cbi.InterruptData);

    transferBuffer = &fdoDeviceExtension->Cbi.InterruptData;

    ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                   DeviceObject,
                   Irp,
                   pipeHandle,                              // PipeHandle
                   0,                                       // TransferFlags
                   transferBufferLength,                    // TransferBufferLength
                   transferBuffer,                          // TransferBuffer
                   NULL,                                    // TransferBufferMDL
                   USBSTOR_RequestSenseInterruptCompletionRoutine,  // CompletionRoutine
                   (PVOID)AutoFlag);                        // Context

    DBGPRINT(3, ("exit:  USBSTOR_IssueRequestSenseInterruptRequest %08X\n",
                 ntStatus));

    LOGENTRY('irsi', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_RequestSenseInterruptCompletionRoutine()
//
// Completion routine used by USBSTOR_IssueRequestSenseInterruptRequest()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the Interrupt USB transfer failed due to any reason, complete the
// request and start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the Interrupt USB transfer succeeded but the completion data is
// non-zero and AutoSense is not disabled, do not complete the request yet and
// start a Request Sense by calling USBSTOR_IssueRequestSenseCdb(AUTO).
//
// Else if the Interrupt USB transfer succeeded, ignore the interrupt data
// and complete the request by calling USBSTOR_ProcessRequestSenseCompletion().
//
//******************************************************************************

NTSTATUS
USBSTOR_RequestSenseInterruptCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            AutoFlag
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *intrUrb;

    DBGPRINT(3, ("enter: USBSTOR_RequestSenseInterruptCompletionRoutine\n"));

    LOGENTRY('RSIC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Interrupt Transfer URB in our Device Extension
    //
    intrUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('rsi1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_RequestSenseInterruptCompletionRoutine: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The command completion Interrupt USB transfer failed.  Complete
        // this request now and then reset the device.  The next request will
        // be started when the reset completes.
        //
        LOGENTRY('rsi2', Irp->IoStatus.Status, intrUrb->Hdr.Status, 0);

        DBGPRINT(1, ("Interrupt transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, intrUrb->Hdr.Status));

        ntStatus = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        srb->SrbStatus = SRB_STATUS_BUS_RESET;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(fdoDeviceObject);

        DBGPRINT(1, ("USBSTOR_RequestSenseInterruptCompletionRoutine: xfer error completion\n"));

        return ntStatus;
    }

    // Request Sense Command Completion Interrupt tranfer completed successfully.

    LOGENTRY('rsi3', Irp->IoStatus.Status, intrUrb->Hdr.Status,
             intrUrb->TransferBufferLength);

    ntStatus = USBSTOR_ProcessRequestSenseCompletion(
                   fdoDeviceObject,
                   Irp,
                   (ULONG_PTR)AutoFlag);

    DBGPRINT(3, ("exit:  USBSTOR_RequestSenseInterruptCompletionRoutine %08X\n", ntStatus));

    return ntStatus;
}


//******************************************************************************
//
// USBSTOR_ProcessRequestSenseCompletion()
//
// This routine handles completion for USBSTOR_SenseDataCompletionRoutine()
// and USBSTOR_RequestSenseInterruptCompletionRoutine().  It basically just
// handles a couple of special cases.
//
// This routine may run at DPC level.
//
//******************************************************************************

NTSTATUS
USBSTOR_ProcessRequestSenseCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    LOGENTRY('PRSC', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    if (AutoFlag == NON_AUTO_SENSE)
    {
        LOGENTRY('prs1', DeviceObject, Irp, srb);

        if ((fdoDeviceExtension->Cbi.SenseData.SenseKey ==
             SCSI_SENSE_UNIT_ATTENTION)
            &&
            (fdoDeviceExtension->Cbi.SenseData.AdditionalSenseCode ==
             SCSI_ADSENSE_BUS_RESET))
        {
            fdoDeviceExtension->LastSenseWasReset = TRUE;
        }

        // Just cleared the persistent error from the previous request,
        // now issue the real request.
        //
        ntStatus = USBSTOR_IssueClientCdb(DeviceObject,
                                          Irp);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    // SrbStatus and DataTransferLength were already set in
    // USBSTOR_ClientCdbCompletion(), USBSTOR_ClientBulkCompletionRoutine(), or in
    // or USBSTOR_InterruptDataCompletionRoutine() before we got here.
    //
    srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;

    USBSTOR_TranslateCDBComplete(DeviceObject, Irp, srb);

    Irp->IoStatus.Information = srb->DataTransferLength;

    ntStatus = Irp->IoStatus.Status;

    // Disgusting hack for Y-E Data USB Floppy.  On Medium Changed it doesn't
    // automatically update the Write Protect status that you get back in
    // the Mode Parameter Header on a Mode Sense.  Supposedly a Start Unit
    // request after a Medium Changed should cause it to update the Write
    // Protect status, but that does not seem to be the case.  A good old
    // bus reset gets its attention though and updates the Write Protect
    // status.  Don't do this if the last status was a Bus Reset or that
    // will cause a loop.
    //
    if ((fdoDeviceExtension->Cbi.SenseData.SenseKey ==
         SCSI_SENSE_UNIT_ATTENTION)
        &&
        (fdoDeviceExtension->Cbi.SenseData.AdditionalSenseCode ==
         SCSI_ADSENSE_MEDIUM_CHANGED)
        &&
        !fdoDeviceExtension->LastSenseWasReset
        &&
        TEST_FLAG(fdoDeviceExtension->DeviceHackFlags, DHF_MEDIUM_CHANGE_RESET))
    {
        LOGENTRY('prs2', DeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(DeviceObject);
    }
    else
    {
        if ((fdoDeviceExtension->Cbi.SenseData.SenseKey ==
             SCSI_SENSE_UNIT_ATTENTION)
            &&
            (fdoDeviceExtension->Cbi.SenseData.AdditionalSenseCode ==
             SCSI_ADSENSE_BUS_RESET))
        {
            LOGENTRY('prs3', DeviceObject, Irp, srb);

            fdoDeviceExtension->LastSenseWasReset = TRUE;
        }
        else
        {
            LOGENTRY('prs4', DeviceObject, Irp, srb);

            fdoDeviceExtension->LastSenseWasReset = FALSE;
        }

        KeRaiseIrql(DISPATCH_LEVEL, &irql);
        {
            IoStartNextPacket(DeviceObject, TRUE);
        }
        KeLowerIrql(irql);
    }

    return ntStatus;
}


//******************************************************************************
//
// USBSTOR_QueueResetPipe()
//
// Called by USBSTOR_BulkCompletionRoutine() to clear the STALL on the bulk
// endpoints.
//
//******************************************************************************

VOID
USBSTOR_QueueResetPipe (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;

    LOGENTRY('QRSP', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    INCREMENT_PENDING_IO_COUNT(fdoDeviceExtension);

    IoQueueWorkItem(fdoDeviceExtension->IoWorkItem,
                    USBSTOR_ResetPipeWorkItem,
                    CriticalWorkQueue,
                    NULL);
}

//******************************************************************************
//
// USBSTOR_ResetPipeWorkItem()
//
// WorkItem routine used by USBSTOR_ResetPipe()
//
// This routine runs at PASSIVE level.
//
// Basic idea:
//
// Issue a Reset Pipe request to clear the Bulk endpoint STALL and reset
// the data toggle to Data0.
//
// If AutoSense is not disabled, do not complete the request yet and start
// a Request Sense by calling USBSTOR_IssueRequestSenseCdb(AUTO).
//
// Else if AutoSense is disabled, complete the request.
//
//******************************************************************************

VOID
USBSTOR_ResetPipeWorkItem (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    BOOLEAN                 persistentError;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    LOGENTRY('RSPW', DeviceObject, 0, 0);

    DBGPRINT(2, ("enter: USBSTOR_ResetPipeWorkItem\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Reset the Bulk Endpoint.  This clears the endpoint halt on the
    // host side, resets the host side data toggle to Data0, and issues
    // the Clear_Feature Endpoint_Stall request to the device.
    //
    ntStatus = USBSTOR_ResetPipe((PDEVICE_OBJECT)DeviceObject,
                                 fdoDeviceExtension->BulkInPipe->PipeHandle);

    ntStatus = USBSTOR_ResetPipe((PDEVICE_OBJECT)DeviceObject,
                                 fdoDeviceExtension->BulkOutPipe->PipeHandle);

    persistentError = FALSE;

    KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
    {
        if (TEST_FLAG(fdoDeviceExtension->DeviceFlags, DF_PERSISTENT_ERROR))
        {
            persistentError = TRUE;
        }
    }
    KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);

    if (persistentError)
    {
        // We are not doing an AutoSense, start the next packet.
        //
        KeRaiseIrql(DISPATCH_LEVEL, &irql);
        {
            IoStartNextPacket(DeviceObject, TRUE);
        }
        KeLowerIrql(irql);
    }
    else
    {
        // We are doing an AutoSense, send the REQUEST_SENSE Cdb to the device.
        //
        ntStatus = USBSTOR_IssueRequestSenseCdb(
                       (PDEVICE_OBJECT)DeviceObject,
                       ((PDEVICE_OBJECT)DeviceObject)->CurrentIrp,
                       AUTO_SENSE);
    }

    DBGPRINT(2, ("exit:  USBSTOR_ResetPipeWorkItem\n"));

    DECREMENT_PENDING_IO_COUNT(fdoDeviceExtension);
}

//
// Bulk-Only Routines
//

//
// Phase 1, CBW Transfer
//

//******************************************************************************
//
// USBSTOR_CbwTransfer()
//
// This routine is called by USBSTOR_StartIo().
//
// It runs at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to write the Srb->Cdb wrapped inside a CBW out
// the Bulk OUT endpoint.
//
// Sets USBSTOR_CbwCompletion() as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_CbwTransfer (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    PCBW                    cbw;
    USBD_PIPE_HANDLE        pipeHandle;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_CbwTransfer\n"));

    LOGENTRY('ICBW', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    fdoDeviceExtension->BulkOnly.StallCount = 0;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // Get the PDO extension from the PDO which was saved in the current
    // stack location when the Irp was originally sent to the PDO.
    //
    pdoDeviceExtension = irpStack->DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    LOGENTRY('icbl', DeviceObject, irpStack->DeviceObject,
             pdoDeviceExtension->LUN);

    // Get the client Srb
    //
    srb = irpStack->Parameters.Scsi.Srb;

    // Initialize the Command Block Wrapper
    //
    cbw = &fdoDeviceExtension->BulkOnly.CbwCsw.Cbw;

    cbw->dCBWSignature = CBW_SIGNATURE;

    cbw->dCBWTag = PtrToUlong(Irp);

    cbw->dCBWDataTransferLength = srb->DataTransferLength;

    cbw->bCBWFlags = (srb->SrbFlags & SRB_FLAGS_DATA_IN) ?
                     CBW_FLAGS_DATA_IN : CBW_FLAGS_DATA_OUT;

    cbw->bCBWLUN = pdoDeviceExtension->LUN;

    cbw->bCDBLength = srb->CdbLength;

    RtlCopyMemory(cbw->CBWCDB, srb->Cdb, 16);

    pipeHandle = fdoDeviceExtension->BulkOutPipe->PipeHandle;

    ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                   DeviceObject,
                   Irp,
                   pipeHandle,              // PipeHandle
                   0,                       // TransferFlags
                   sizeof(CBW),             // TransferBufferLength
                   cbw,                     // TransferBuffer
                   NULL,                    // TransferBufferMDL
                   USBSTOR_CbwCompletion,   // CompletionRoutine
                   NULL);                   // Context

    DBGPRINT(3, ("exit:  USBSTOR_CbwTransfer %08X\n", ntStatus));

    LOGENTRY('icbw', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_CbwCompletion()
//
// Completion routine used by USBSTOR_CbwTransfer()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the CBW USB transfer failed due to any reason, complete the
// request and start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the CBW USB transfer succeeded and the Srb has a transfer buffer,
// do not complete the request yet and start the bulk data transfer by calling
// USBSTOR_DataTransfer().
//
// Else if the CBW USB transfer succeeded and the Srb has no transfer buffer,
// do not complete the request yet and start the CSW bulk transfer by calling
// USBSTOR_CswTransfer().
//
//******************************************************************************

NTSTATUS
USBSTOR_CbwCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkUrb;

    DBGPRINT(3, ("enter: USBSTOR_CbwCompletion\n"));

    LOGENTRY('CBWC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk Transfer URB in our Device Extension
    //
    bulkUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('cbw1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_CbwCompletion: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The CBW Bulk Transfer was not successful.
        //
        LOGENTRY('cbw2', Irp->IoStatus.Status, bulkUrb->Hdr.Status, 0);

        DBGPRINT(1, ("CBW transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, bulkUrb->Hdr.Status));

        srb = fdoDeviceExtension->OriginalSrb;
        irpStack->Parameters.Scsi.Srb = srb;

        // Complete this request now and then reset the device.  The next
        // request will be started when the reset completes.
        //
        ntStatus = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        srb->SrbStatus = SRB_STATUS_BUS_RESET;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(fdoDeviceObject);

        DBGPRINT(1, ("USBSTOR_CbwCompletion: xfer error completion\n"));

        return ntStatus;
    }

    // The CBW Bulk Transfer was successful.  Start the next phase, either
    // the Data Bulk Transfer or CSW Bulk Transfer, and do not complete the
    // request yet.
    //
    if (Irp->MdlAddress != NULL ||
        srb != fdoDeviceExtension->OriginalSrb)
    {
        // The Srb has a transfer buffer, start the Data Bulk Transfer.
        //
        LOGENTRY('cbw3', fdoDeviceObject, Irp, srb);

        ASSERT(srb->DataTransferLength != 0);

        ntStatus = USBSTOR_DataTransfer(fdoDeviceObject,
                                        Irp);

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            srb = fdoDeviceExtension->OriginalSrb;
            irpStack->Parameters.Scsi.Srb = srb;

            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_ERROR;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetDevice(fdoDeviceObject);
        }
    }
    else
    {
        // The Srb has no transfer buffer.  Start the CSW Bulk Transfer.
        //
        LOGENTRY('cbw4', fdoDeviceObject, Irp, srb);

        ASSERT(srb->DataTransferLength == 0);

        srb->SrbStatus = SRB_STATUS_SUCCESS;

        ntStatus = USBSTOR_CswTransfer(fdoDeviceObject,
                                       Irp);

        ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
    }

    DBGPRINT(3, ("exit:  USBSTOR_CbwCompletion %08X\n", ntStatus));

    return ntStatus;
}

//
// Phase 2, Data Transfer
//

//******************************************************************************
//
// USBSTOR_DataTransfer()
//
// This routine is called by USBSTOR_ClientCdbCompletion().
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to read or write the Srb->DataBuffer data In or Out
// the Bulk endpoint.
//
// Sets USBSTOR_DataCompletion() as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_DataTransfer (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    PMDL                    mdl;
    PVOID                   mdlVa;
    PVOID                   transferBuffer;
    USBD_PIPE_HANDLE        pipeHandle;
    ULONG                   transferFlags;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_DataTransfer\n"));

    LOGENTRY('IBKD', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // Bulk IN or Bulk OUT?
    //
    if ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) == SRB_FLAGS_DATA_IN)
    {
        pipeHandle = fdoDeviceExtension->BulkInPipe->PipeHandle;
        transferFlags = USBD_SHORT_TRANSFER_OK;
    }
    else if ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) == SRB_FLAGS_DATA_OUT)
    {
        pipeHandle = fdoDeviceExtension->BulkOutPipe->PipeHandle;
        transferFlags = 0;
    }
    else
    {
        // Something is wrong if we end up here.
        //
        ASSERT((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) &&
               ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) !=
                SRB_FLAGS_UNSPECIFIED_DIRECTION));

        return STATUS_INVALID_PARAMETER;
    }

    mdl = NULL;
    transferBuffer = NULL;

    if (srb == fdoDeviceExtension->OriginalSrb)
    {
        // Check to see if this request is part of a split request.
        //
        mdlVa = MmGetMdlVirtualAddress(Irp->MdlAddress);

        if (mdlVa == (PVOID)srb->DataBuffer)
        {
            // Not part of a split request, use original MDL
            //
            mdl = Irp->MdlAddress;
        }
        else
        {
            // Part of a split request, allocate new partial MDL
            //
            mdl = IoAllocateMdl(srb->DataBuffer,
                                srb->DataTransferLength,
                                FALSE,
                                FALSE,
                                NULL);
            if (mdl == NULL)
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                IoBuildPartialMdl(Irp->MdlAddress,
                                  mdl,
                                  srb->DataBuffer,
                                  srb->DataTransferLength);
            }
        }
    }
    else
    {
        transferBuffer = srb->DataBuffer;

        // If (srb != fdoDeviceExtension->OriginalSrb) then
        // srb->DataBuffer should equal OriginalSrb->SenseInfoBuffer,
        // which should not be NULL if we end up here.
        //
        ASSERT(transferBuffer);

        if (!transferBuffer) {
            // just in case
            ntStatus = STATUS_INVALID_PARAMETER;
        }
    }

    if (mdl != NULL || transferBuffer != NULL)
    {
        ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                       DeviceObject,
                       Irp,
                       pipeHandle,              // PipeHandle
                       transferFlags,           // TransferFlags
                       srb->DataTransferLength, // TransferBufferLength
                       transferBuffer,          // TransferBuffer
                       mdl,                     // TransferBufferMDL
                       USBSTOR_DataCompletion,  // CompletionRoutine
                       NULL);                   // Context

        // Just return STATUS_SUCCESS at this point.  If there is an error,
        // USBSTOR_DataCompletion() will handle it, not the caller of
        // USBSTOR_DataTransfer().
        //
        ntStatus = STATUS_SUCCESS;
    }

    DBGPRINT(3, ("exit:  USBSTOR_DataTransfer %08X\n", ntStatus));

    LOGENTRY('ibkd', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_DataCompletion()
//
// Completion routine used by USBSTOR_DataTransfer
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the Bulk USB transfer failed due to a STALL do not complete the
// request yet and start a pipe reset by calling USBSTOR_BulkQueueResetPipe().
//
// Else if the Bulk USB transfer failed due to some other reason, complete the
// request and start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the Bulk USB transfer succeeded, start CSW transfer by calling
// USBSTOR_CswTransfer().
//
//******************************************************************************

NTSTATUS
USBSTOR_DataCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkUrb;

    DBGPRINT(3, ("enter: USBSTOR_DataCompletion\n"));

    LOGENTRY('BKDC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk Transfer URB in our Device Extension
    //
    bulkUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    if (srb == fdoDeviceExtension->OriginalSrb &&
        bulkUrb->TransferBufferMDL != Irp->MdlAddress)
    {
        IoFreeMdl(bulkUrb->TransferBufferMDL);
    }

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('bkd1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_DataCompletion: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The Data Bulk Transfer was not successful.  Look at how the
        // the transfer failed to figure out how to recover.
        //

        LOGENTRY('bkd2', Irp->IoStatus.Status, bulkUrb->Hdr.Status, 0);

        DBGPRINT(1, ("Data transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, bulkUrb->Hdr.Status));

        if (USBD_STATUS(bulkUrb->Hdr.Status) ==
            USBD_STATUS(USBD_STATUS_STALL_PID))
        {
            // The device STALLed the Data Bulk Transfer
            //
            fdoDeviceExtension->BulkOnly.StallCount++;

            // A STALL during the Data Bulk Transfer does not necessarily
            // indicate an error.  Accept the data that was actually
            // transferred.  If a STALL was seen it must have been seen
            // before the requested amount of data was transferred.
            //
            ASSERT(bulkUrb->TransferBufferLength < srb->DataTransferLength);
            srb->DataTransferLength = bulkUrb->TransferBufferLength;
            srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;

            LOGENTRY('bkd3', fdoDeviceObject, Irp, srb);

            // Queue a bulk pipe reset.  After the bulk pipe reset
            // completes, a CSW transfer will be started.
            //
            USBSTOR_BulkQueueResetPipe(fdoDeviceObject);

            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            LOGENTRY('bkd4', fdoDeviceObject, Irp, srb);

            // Else some other strange error has occured.  Maybe the device is
            // unplugged, or maybe the device port was disabled, or maybe the
            // request was cancelled.
            //
            // Complete this request now and then reset the device.  The next
            // request will be started when the reset completes.
            //
            srb = fdoDeviceExtension->OriginalSrb;
            irpStack->Parameters.Scsi.Srb = srb;

            ntStatus = STATUS_IO_DEVICE_ERROR;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_BUS_RESET;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetDevice(fdoDeviceObject);

            DBGPRINT(1, ("USBSTOR_DataCompletion: xfer error completion\n"));

            return ntStatus;
        }
    }

    // Check for overrun
    //
    if (bulkUrb->TransferBufferLength < srb->DataTransferLength)
    {
        srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
    }
    else
    {
        srb->SrbStatus = SRB_STATUS_SUCCESS;
    }

    // Update the the Srb data transfer length based on the actual bulk
    // transfer length.
    //
    srb->DataTransferLength = bulkUrb->TransferBufferLength;

    // Client data Bulk Transfer successful completion.  Start the CSW transfer.
    //
    LOGENTRY('bkd5', fdoDeviceObject, Irp, bulkUrb->TransferBufferLength);

    ntStatus = USBSTOR_CswTransfer(fdoDeviceObject,
                                   Irp);

    ntStatus = STATUS_MORE_PROCESSING_REQUIRED;

    DBGPRINT(3, ("exit:  USBSTOR_DataCompletion %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_CswTransfer()
//
// This routine is called by USBSTOR_CbwCompletion() and
// USBSTOR_DataCompletion()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to read the CSW in the Bulk IN endpoint.
//
// Sets USBSTOR_CswCompletion() as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_CswTransfer (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PCSW                    csw;
    USBD_PIPE_HANDLE        pipeHandle;
    ULONG                   transferFlags;
    ULONG                   transferBufferLength;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_CswTransfer\n"));

    LOGENTRY('ICSW', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    csw = &fdoDeviceExtension->BulkOnly.CbwCsw.Csw;

    pipeHandle = fdoDeviceExtension->BulkInPipe->PipeHandle;

    // Workaround for USB 2.0 controller Data Toggle / Babble bug
    //
    if (fdoDeviceExtension->BulkInPipe->MaximumPacketSize ==
        sizeof(fdoDeviceExtension->BulkOnly.CbwCsw.MaxPacketSize))

    {
        transferFlags = USBD_SHORT_TRANSFER_OK;

        transferBufferLength =
            sizeof(fdoDeviceExtension->BulkOnly.CbwCsw.MaxPacketSize);
    }
    else
    {
        transferFlags = 0;

        transferBufferLength = sizeof(CSW);
    }

    ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                   DeviceObject,
                   Irp,
                   pipeHandle,                  // PipeHandle
                   transferFlags,               // TransferFlags
                   transferBufferLength,        // TransferBufferLength
                   csw,                         // TransferBuffer
                   NULL,                        // TransferBufferMDL
                   USBSTOR_CswCompletion,       // CompletionRoutine
                   NULL);                       // Context

    DBGPRINT(3, ("exit:  USBSTOR_CswTransfer %08X\n", ntStatus));

    LOGENTRY('icsw', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_CswCompletion()
//
// Completion routine used by USBSTOR_CswTransfer()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
//******************************************************************************

NTSTATUS
USBSTOR_CswCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    PCSW                    csw;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkUrb;

    DBGPRINT(3, ("enter: USBSTOR_CswCompletion\n"));

    LOGENTRY('CSWC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk Transfer URB in our Device Extension
    //
    bulkUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    csw = &fdoDeviceExtension->BulkOnly.CbwCsw.Csw;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('csw1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_CswCompletion: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The Data Bulk Transfer was not successful.  Look at how the
        // the transfer failed to figure out how to recover.
        //

        LOGENTRY('csw2', Irp->IoStatus.Status, bulkUrb->Hdr.Status, 0);

        DBGPRINT(1, ("CSW transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, bulkUrb->Hdr.Status));

        if (USBD_STATUS(bulkUrb->Hdr.Status) ==
            USBD_STATUS(USBD_STATUS_STALL_PID) &&
            fdoDeviceExtension->BulkOnly.StallCount < 2)
        {
            // The device STALLed the CSW Bulk Transfer
            //
            fdoDeviceExtension->BulkOnly.StallCount++;

            LOGENTRY('csw3', fdoDeviceObject, Irp, srb);

            // Queue a bulk pipe reset.  After the bulk pipe reset
            // completes, a CSW transfer will be started.
            //
            USBSTOR_BulkQueueResetPipe(fdoDeviceObject);

            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            LOGENTRY('csw4', fdoDeviceObject, Irp, srb);

            // Else some other strange error has occured.  Maybe the device is
            // unplugged, or maybe the device port was disabled, or maybe the
            // request was cancelled.
            //
            // Complete this request now and then reset the device.  The next
            // request will be started when the reset completes.
            //
            srb = fdoDeviceExtension->OriginalSrb;
            irpStack->Parameters.Scsi.Srb = srb;

            ntStatus = STATUS_IO_DEVICE_ERROR;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_BUS_RESET;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetDevice(fdoDeviceObject);

            DBGPRINT(1, ("USBSTOR_DataCompletion: xfer error completion\n"));

            return ntStatus;
        }
    }

    if (csw->bCSWStatus == CSW_STATUS_GOOD)
    {
        // Complete this request now.  Also start the next request now.
        //

        // SrbStatus should have been set in USBSTOR_DataCompletion()
        //
        ASSERT(srb->SrbStatus != SRB_STATUS_PENDING);

        if (srb != fdoDeviceExtension->OriginalSrb)
        {
            // Update the original SRB with the length of the sense data that
            // was actually returned.
            //
            fdoDeviceExtension->OriginalSrb->SenseInfoBufferLength =
                (UCHAR)srb->DataTransferLength;

            srb = fdoDeviceExtension->OriginalSrb;
            irpStack->Parameters.Scsi.Srb = srb;

            srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        }

        ntStatus = STATUS_SUCCESS;
        Irp->IoStatus.Status = ntStatus;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        Irp->IoStatus.Information = srb->DataTransferLength;

        LOGENTRY('csw5', fdoDeviceObject, Irp, srb);

        KeRaiseIrql(DISPATCH_LEVEL, &irql);
        {
            IoStartNextPacket(fdoDeviceObject, TRUE);
        }
        KeLowerIrql(irql);
    }
    else if (csw->bCSWStatus == CSW_STATUS_FAILED &&
             srb == fdoDeviceExtension->OriginalSrb)
    {
        LOGENTRY('csw6', fdoDeviceObject, Irp, srb);

        srb->SrbStatus = SRB_STATUS_ERROR;
        srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
        srb->DataTransferLength = 0; // XXXXX Leave as set by bulk completion???

        if (!(srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) &&
            (srb->SenseInfoBufferLength != 0) &&
            (srb->SenseInfoBuffer != NULL))
        {
            // Start the Request Sense thing
            //
            ntStatus = USBSTOR_IssueRequestSense(fdoDeviceObject,
                                                 Irp);

            ntStatus = STATUS_MORE_PROCESSING_REQUIRED;

        }
        else
        {
            ntStatus = STATUS_IO_DEVICE_ERROR; // XXXXX
            Irp->IoStatus.Status = ntStatus; // XXXXX
            Irp->IoStatus.Information = 0; // XXXXX

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            KeRaiseIrql(DISPATCH_LEVEL, &irql);
            {
                IoStartNextPacket(fdoDeviceObject, TRUE);
            }
            KeLowerIrql(irql);
        }
    }
    else
    {
        LOGENTRY('csw7', fdoDeviceObject, Irp, srb);

        // PHASE ERROR or Unknown Status
        //
        // Complete this request now and then reset the device.  The next
        // request will be started when the reset completes.
        //
        srb = fdoDeviceExtension->OriginalSrb;
        irpStack->Parameters.Scsi.Srb = srb;

        ntStatus = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        srb->SrbStatus = SRB_STATUS_BUS_RESET;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(fdoDeviceObject);
    }

    DBGPRINT(3, ("exit:  USBSTOR_CswCompletion %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_IssueRequestSense()
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueRequestSense (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_IssueRequestSense\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get the current Srb
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // Get a pointer to the internal Srb.
    //
    srb = &fdoDeviceExtension->BulkOnly.InternalSrb;

    irpStack->Parameters.Scsi.Srb = srb;


    // Initialize SRB & CDB to all ZERO
    //
    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    // Initialize SRB
    //
    srb->Length     = sizeof(SCSI_REQUEST_BLOCK);
    srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
    srb->CdbLength  = 12;
    srb->SrbFlags   = SRB_FLAGS_DATA_IN |
                      SRB_FLAGS_DISABLE_AUTOSENSE;

    srb->DataTransferLength = fdoDeviceExtension->OriginalSrb->SenseInfoBufferLength;
    srb->DataBuffer         = fdoDeviceExtension->OriginalSrb->SenseInfoBuffer;

    // Initialize CDB
    //
    srb->Cdb[0] = SCSIOP_REQUEST_SENSE;
    srb->Cdb[4] = fdoDeviceExtension->OriginalSrb->SenseInfoBufferLength;

    ntStatus = USBSTOR_CbwTransfer(DeviceObject,
                                   Irp);

    return ntStatus;

    DBGPRINT(3, ("exit:  USBSTOR_IssueRequestSense %08X\n", ntStatus));
}

//******************************************************************************
//
// USBSTOR_BulkQueueResetPipe()
//
// Called by USBSTOR_DataCompletion() and USBSTOR_CswCompletion() to clear the
// STALL on the bulk endpoints.
//
//******************************************************************************

VOID
USBSTOR_BulkQueueResetPipe (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;

    LOGENTRY('QRSP', DeviceObject, 0, 0);

    DBGFBRK(DBGF_BRK_RESETPIPE);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    INCREMENT_PENDING_IO_COUNT(fdoDeviceExtension);

    IoQueueWorkItem(fdoDeviceExtension->IoWorkItem,
                    USBSTOR_BulkResetPipeWorkItem,
                    CriticalWorkQueue,
                    NULL);
}

//******************************************************************************
//
// USBSTOR_BulkResetPipeWorkItem()
//
// WorkItem routine used by USBSTOR_BulkQueueResetPipe()
//
// This routine runs at PASSIVE level.
//
// Basic idea:
//
// Issue a Reset Pipe request to clear the Bulk endpoint STALL and reset
// the data toggle to Data0.
//
// Then start the CSW transfer.
//
//******************************************************************************

VOID
USBSTOR_BulkResetPipeWorkItem (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkUrb;

    LOGENTRY('RSPW', DeviceObject, 0, 0);

    DBGPRINT(2, ("enter: USBSTOR_BulkResetPipeWorkItem\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk Transfer URB in our Device Extension.
    // We'll pull the appropriate Bulk Endpoint pipe handle out of the URB.
    //
    // NOTE: This assumes that the URB in our Device Extension has
    // not been touched since USBSTOR_DataCompletion() or
    // USBSTOR_CswCompletion() called USBSTOR_BulkQueueResetPipe().
    //
    bulkUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Reset the Bulk Endpoint.  This clears the endpoint halt on the
    // host side, resets the host side data toggle to Data0, and issues
    // the Clear_Feature Endpoint_Stall request to the device.
    //
    ntStatus = USBSTOR_ResetPipe((PDEVICE_OBJECT)DeviceObject,
                                 bulkUrb->PipeHandle);

    ntStatus = USBSTOR_CswTransfer(
                   (PDEVICE_OBJECT)DeviceObject,
                   ((PDEVICE_OBJECT)DeviceObject)->CurrentIrp);


    DBGPRINT(2, ("exit:  USBSTOR_BulkResetPipeWorkItem\n"));

    DECREMENT_PENDING_IO_COUNT(fdoDeviceExtension);
}

//
// CBI / Bulk-Only Common Routines
//

//******************************************************************************
//
// USBSTOR_TimerTick()
//
// Called once per second at DISPATCH_LEVEL after the device has been started.
// Checks to see if there is an active Srb which has timed out, and if so,
// kicks off the reset recovery process.
//
//******************************************************************************

VOID
USBSTOR_TimerTick (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          NotUsed
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    BOOLEAN                 reset;

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    reset = FALSE;

    KeAcquireSpinLockAtDpcLevel(&fdoDeviceExtension->ExtensionDataSpinLock);
    {
        if (!TEST_FLAG(fdoDeviceExtension->DeviceFlags, DF_RESET_IN_PROGRESS) &&
             TEST_FLAG(fdoDeviceExtension->DeviceFlags, DF_SRB_IN_PROGRESS))
        {
            // There is no reset in progress and there is an Srb in progress.
            // Decrement the timeout of the Srb.  If it reaches zero, then we
            // will reset the device.
            //
            if (--fdoDeviceExtension->SrbTimeout == 0)
            {
                SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_RESET_IN_PROGRESS);

                reset = TRUE;
            }
        }
    }
    KeReleaseSpinLockFromDpcLevel(&fdoDeviceExtension->ExtensionDataSpinLock);

    if (reset)
    {
        LOGENTRY('TIMR', DeviceObject, 0, 0);

        DBGPRINT(2, ("queuing USBSTOR_ResetDeviceWorkItem\n"));

        //  Queue WorkItem to reset the device
        //
        INCREMENT_PENDING_IO_COUNT(fdoDeviceExtension);

        IoQueueWorkItem(fdoDeviceExtension->IoWorkItem,
                        USBSTOR_ResetDeviceWorkItem,
                        CriticalWorkQueue,
                        NULL);
    }
}

//******************************************************************************
//
// USBSTOR_QueueResetDevice()
//
//******************************************************************************

VOID
USBSTOR_QueueResetDevice (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    KIRQL                   irql;

    LOGENTRY('QRSD', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
    {
        SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_RESET_IN_PROGRESS);
    }
    KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);

    //  Queue WorkItem to reset the device
    //
    INCREMENT_PENDING_IO_COUNT(fdoDeviceExtension);

    IoQueueWorkItem(fdoDeviceExtension->IoWorkItem,
                    USBSTOR_ResetDeviceWorkItem,
                    CriticalWorkQueue,
                    NULL);
}

//******************************************************************************
//
// USBSTOR_ResetDeviceWorkItem()
//
// Work item which runs at PASSIVE_LEVEL in the context of a system thread.
// This routine first checks to see if the device is still attached, and if
// it is, the device is reset.
//
//******************************************************************************

VOID
USBSTOR_ResetDeviceWorkItem (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    KIRQL                   irql;
    ULONG                   retryCount;
    NTSTATUS                ntStatus;

    LOGENTRY('RSDW', DeviceObject, 0, 0);

    DBGFBRK(DBGF_BRK_RESET);

    DBGPRINT(2, ("enter: USBSTOR_ResetDeviceWorkItem\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // If the we timed out a request and it is still pending, cancel
    // it and then wait for the cancel to finish, and then complete
    // the request.
    //
    if (fdoDeviceExtension->PendingIrp)
    {
        LOGENTRY('rsd1', DeviceObject, fdoDeviceExtension->PendingIrp, 0);

        IoCancelIrp(fdoDeviceExtension->PendingIrp);

        LOGENTRY('rsd2', DeviceObject, fdoDeviceExtension->PendingIrp, 0);

        KeWaitForSingleObject(&fdoDeviceExtension->CancelEvent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        LOGENTRY('rsd3', DeviceObject, fdoDeviceExtension->PendingIrp, 0);

        // Some storage drivers (e.g. CDROM.SYS) assume that requests complete
        // at DISPATCH_LEVEL.
        //
        KeRaiseIrql(DISPATCH_LEVEL, &irql);
        {
            IoCompleteRequest(fdoDeviceExtension->PendingIrp, IO_NO_INCREMENT);
        }
        KeLowerIrql(irql);

        fdoDeviceExtension->PendingIrp = NULL;
    }

    // Try the reset up to 3 times
    //
    for (retryCount = 0; retryCount < 3; retryCount++)
    {
        //
        // First figure out if the device is still connected.
        //
        ntStatus = USBSTOR_IsDeviceConnected(DeviceObject);

        if (!NT_SUCCESS(ntStatus))
        {
            // Give up if the device is no longer connected.
            break;
        }

        //
        // The device is still connected, now reset the device.
        //
        DBGPRINT(1, ("Reseting Device %d\n", retryCount));

        ntStatus = USBSTOR_ResetDevice(DeviceObject);

        if (NT_SUCCESS(ntStatus))
        {
            // Reset was successful!
            break;
        }
    }

    KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
    {
        CLEAR_FLAG(fdoDeviceExtension->DeviceFlags, DF_RESET_IN_PROGRESS);

        // If the reset failed, then abandon all hope and mark the device as
        // disconnected.
        //
        if (!NT_SUCCESS(ntStatus))
        {
            SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_DEVICE_DISCONNECTED);
        }
    }
    KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);

    // A request has failed in a bad way or timed out if we are reseting the
    // device.  If the protocol was not specified then the default protocol
    // was DeviceProtocolCB.  Let's try DeviceProtocolBulkOnly now and see if
    // we have any better luck.  (Note that if a DeviceProtocolCB device fails
    // the first request in a bad way then will we retry the first request as
    // a DeviceProtocolBulkOnly device, which will then also fail and we will
    // not recover from that situation).
    //
    if (fdoDeviceExtension->DriverFlags == DeviceProtocolUnspecified)
    {
        DBGPRINT(1, ("Setting Unspecified device to BulkOnly\n"));

        fdoDeviceExtension->DriverFlags = DeviceProtocolBulkOnly;
    }

    KeRaiseIrql(DISPATCH_LEVEL, &irql);
    {
        IoStartNextPacket(DeviceObject, TRUE);
    }
    KeLowerIrql(irql);

    DECREMENT_PENDING_IO_COUNT(fdoDeviceExtension);

    DBGPRINT(2, ("exit:  USBSTOR_ResetDeviceWorkItem %08X\n", ntStatus));
}

//******************************************************************************
//
// USBSTOR_IsDeviceConnected()
//
// This routine checks to see if the device is still attached.
//
// This routine runs at PASSIVE level.
//
//******************************************************************************

NTSTATUS
USBSTOR_IsDeviceConnected (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIRP                    irp;
    KEVENT                  localevent;
    PIO_STACK_LOCATION      nextStack;
    ULONG                   portStatus;
    NTSTATUS                ntStatus;

    DBGPRINT(1, ("enter: USBSTOR_IsDeviceConnected\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Allocate the Irp
    //
    irp = IoAllocateIrp((CCHAR)(fdoDeviceExtension->StackDeviceObject->StackSize),
                        FALSE);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the event we'll wait on.
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_GET_PORT_STATUS;

    nextStack->Parameters.Others.Argument1 = &portStatus;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutineEx(DeviceObject,
                             irp,
                             USBSTOR_SyncCompletionRoutine,
                             &localevent,
                             TRUE,      // InvokeOnSuccess
                             TRUE,      // InvokeOnError
                             TRUE);     // InvokeOnCancel

    // Pass the Irp down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    if (NT_SUCCESS(ntStatus) && !(portStatus & USBD_PORT_CONNECTED))
    {
        ntStatus = STATUS_DEVICE_DOES_NOT_EXIST;
    }

    DBGPRINT(1, ("exit:  USBSTOR_IsDeviceConnected %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_ResetDevice()
//
// This routine resets the device (actually it resets the port to which the
// device is attached).
//
// This routine runs at PASSIVE level.
//
//******************************************************************************

NTSTATUS
USBSTOR_ResetDevice (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIRP                    irp;
    KEVENT                  localevent;
    PIO_STACK_LOCATION      nextStack;
    ULONG                   portStatus;
    NTSTATUS                ntStatus;

    DBGPRINT(1, ("enter: USBSTOR_ResetDevice\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Allocate the Irp
    //
    irp = IoAllocateIrp((CCHAR)(fdoDeviceExtension->StackDeviceObject->StackSize),
                        FALSE);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the event we'll wait on.
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_RESET_PORT;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutineEx(DeviceObject,
                             irp,
                             USBSTOR_SyncCompletionRoutine,
                             &localevent,
                             TRUE,      // InvokeOnSuccess
                             TRUE,      // InvokeOnError
                             TRUE);     // InvokeOnCancel

    fdoDeviceExtension->DeviceResetCount++;

    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    DBGPRINT(1, ("exit:  USBSTOR_ResetDevice %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_IssueInternalCdb()
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueInternalCdb (
    PDEVICE_OBJECT  DeviceObject,
    PVOID           DataBuffer,
    PULONG          DataTransferLength,
    PCDB            Cdb,
    UCHAR           CdbLength,
    ULONG           TimeOutValue
    )
{
    PIRP                    irp;
    PIO_STACK_LOCATION      nextStack;
    PSCSI_REQUEST_BLOCK     srb;
    PSENSE_DATA             senseInfoBuffer;
    PMDL                    mdl;
    ULONG                   retryCount;
    KEVENT                  localevent;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_IssueInternalCdb\n"));

    // Initialize these so we can bail early if an allocation fails
    //
    ntStatus        = STATUS_INSUFFICIENT_RESOURCES;
    irp             = NULL;
    srb             = NULL;
    senseInfoBuffer = NULL;
    mdl             = NULL;

    // Allocate the Srb
    //
    srb = ExAllocatePoolWithTag(NonPagedPool, sizeof(SCSI_REQUEST_BLOCK),
                                POOL_TAG);

    if (srb == NULL)
    {
        goto USBSTOR_GetInquiryData_Exit;
    }

    // Allocate the sense buffer
    //
    senseInfoBuffer = ExAllocatePoolWithTag(NonPagedPool, SENSE_BUFFER_SIZE,
                                            POOL_TAG);

    if (senseInfoBuffer == NULL)
    {
        goto USBSTOR_GetInquiryData_Exit;
    }


    // Try the request up to 3 times
    //
    for (retryCount = 0; retryCount < 3; retryCount++)
    {
        // Allocate an Irp including a stack location for a completion routine
        //
        irp = IoAllocateIrp((CCHAR)(DeviceObject->StackSize), FALSE);

        if (irp == NULL)
        {
            break;
        }

        nextStack = IoGetNextIrpStackLocation(irp);
        nextStack->MajorFunction = IRP_MJ_SCSI;
        nextStack->Parameters.Scsi.Srb = srb;

        // (Re)Initialize the Srb
        //
        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK)); // SRB & CDB all ZERO

        srb->Length     = sizeof(SCSI_REQUEST_BLOCK);
        srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
        srb->CdbLength  = CdbLength;
        srb->SrbFlags   = SRB_FLAGS_DATA_IN;

        srb->SenseInfoBufferLength  = SENSE_BUFFER_SIZE;
        srb->SenseInfoBuffer        = senseInfoBuffer;

        srb->DataTransferLength     = *DataTransferLength;
        srb->DataBuffer             = DataBuffer;

        srb->TimeOutValue = TimeOutValue;

        // (Re)Initialize the Cdb
        //
        RtlCopyMemory(srb->Cdb, Cdb, CdbLength);

        // Initialize the MDL (first time only)
        //
        if (retryCount == 0)
        {
            mdl = IoAllocateMdl(DataBuffer,
                                *DataTransferLength,
                                FALSE,
                                FALSE,
                                NULL);

            if (!mdl)
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto USBSTOR_GetInquiryData_Exit;
            }

            MmBuildMdlForNonPagedPool(mdl);
        }

        irp->MdlAddress = mdl;


        // Initialize the event we'll wait on
        //
        KeInitializeEvent(&localevent,
                          SynchronizationEvent,
                          FALSE);

        // Set the completion routine, which will signal the event
        //
        IoSetCompletionRoutine(irp,
                               USBSTOR_SyncCompletionRoutine,
                               &localevent,
                               TRUE,    // InvokeOnSuccess
                               TRUE,    // InvokeOnError
                               TRUE);   // InvokeOnCancel

        // Pass the Irp & Srb down the stack
        //
        ntStatus = IoCallDriver(DeviceObject, irp);

        // If the request is pending, block until it completes
        //
        if (ntStatus == STATUS_PENDING)
        {
            KeWaitForSingleObject(&localevent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            // Get final completion status
            //
            ntStatus = irp->IoStatus.Status;
        }

        DBGPRINT(2, ("USBSTOR_IssueInternalCdb %d %08X %08X\n",
                     retryCount, ntStatus, srb->SrbStatus));

        if ((SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) ||
            (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN))
        {
            ntStatus = STATUS_SUCCESS;
            *DataTransferLength = srb->DataTransferLength;
            break;
        }
        else
        {
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        // Free the Irp.  A new one will be allocated the next time around.
        //
        IoFreeIrp(irp);
        irp = NULL;
    }

USBSTOR_GetInquiryData_Exit:

    if (mdl != NULL)
    {
        IoFreeMdl(mdl);
    }

    if (senseInfoBuffer != NULL)
    {
        ExFreePool(senseInfoBuffer);
    }

    if (srb != NULL)
    {
        ExFreePool(srb);
    }

    if (irp != NULL)
    {
        IoFreeIrp(irp);
    }

    DBGPRINT(2, ("exit:  USBSTOR_IssueInternalCdb %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_GetInquiryData()
//
//******************************************************************************

NTSTATUS
USBSTOR_GetInquiryData (
    PDEVICE_OBJECT  DeviceObject
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PVOID                   dataBuffer;
    ULONG                   dataTransferLength;
    CDB                     cdb;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_GetInquiryData\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    dataBuffer = pdoDeviceExtension->InquiryDataBuffer;
    dataTransferLength = sizeof(pdoDeviceExtension->InquiryDataBuffer);

    RtlZeroMemory(&cdb, sizeof(CDB));

    cdb.CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;
    cdb.CDB6INQUIRY.AllocationLength = (UCHAR)dataTransferLength;

    ntStatus = USBSTOR_IssueInternalCdb(DeviceObject,
                                        dataBuffer,
                                        &dataTransferLength,
                                        &cdb,
                                        sizeof(cdb.CDB6INQUIRY),
                                        20);

    if (NT_SUCCESS(ntStatus) &&
        fdoDeviceExtension->DriverFlags == DeviceProtocolUnspecified)
    {
        // The Inquiry request is the first request we send to the device.  If
        // the first request was successful and the protocol was not specified,
        // set it to the default protocol, which is DeviceProtocolCB.
        //
        DBGPRINT(1, ("Setting Unspecified device to CB\n"));

        fdoDeviceExtension->DriverFlags = DeviceProtocolCB;
    }

    DBGPRINT(2, ("exit:  USBSTOR_GetInquiryData %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_IsFloppyDevice()
//
// This routine issues a SCSIOP_READ_FORMATTED_CAPACITY request and looks
// at the returned Format Capacity Descriptor list to see if the device
// supports any of the known floppy capacities.  If the device does support
// a known floppy capacity, it is assumed that the device is a floppy.
//
//******************************************************************************

typedef struct _FORMATTED_CAPACITY
{
    ULONG   NumberOfBlocks;
    ULONG   BlockLength;
} FORMATTED_CAPACITY, *PFORMATTED_CAPACITY;

FORMATTED_CAPACITY FloppyCapacities[] =
{
    // Blocks    BlockLen      H   T  B/S S/T
    {0x00000500, 0x000200}, // 2  80  512   8    640 KB  F5_640_512
    {0x000005A0, 0x000200}, // 2  80  512   9    720 KB  F3_720_512
    {0x00000960, 0x000200}, // 2  80  512  15   1.20 MB  F3_1Pt2_512   (Toshiba)
    {0x000004D0, 0x000400}, // 2  77 1024   8   1.23 MB  F3_1Pt23_1024 (NEC)
    {0x00000B40, 0x000200}, // 2  80  512  18   1.44 MB  F3_1Pt44_512
    {0x0003C300, 0x000200}, // 8 963  512  32    120 MB  F3_120M_512
    {0x000600A4, 0x000200}  //13 890  512  34    200 MB  HiFD
};

#define FLOPPY_CAPACITIES (sizeof(FloppyCapacities)/sizeof(FloppyCapacities[0]))

BOOLEAN
USBSTOR_IsFloppyDevice (
    PDEVICE_OBJECT  DeviceObject
    )
{
    PPDO_DEVICE_EXTENSION               pdoDeviceExtension;
    BOOLEAN                             isFloppy;
    struct _READ_FORMATTED_CAPACITIES   cdb;
    PFORMATTED_CAPACITY_LIST            capList;
    PVOID                               dataBuffer;
    ULONG                               dataTransferLength;
    NTSTATUS                            ntStatus;

    PAGED_CODE();

    DBGPRINT(1, ("enter: USBSTOR_IsFloppyDevice\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    isFloppy = FALSE;

    // Allocate a transfer buffer for the SCSIOP_READ_FORMATTED_CAPACITY request
    // The length of the returned descriptor array is limited to a byte field
    // in the capacity list header.
    //
    dataTransferLength = sizeof(FORMATTED_CAPACITY_LIST) +
                         31 * sizeof(FORMATTED_CAPACITY_DESCRIPTOR);

    ASSERT(dataTransferLength < 0x100);

    dataBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                       dataTransferLength,
                                       POOL_TAG);

    if (dataBuffer)
    {
        RtlZeroMemory(dataBuffer, dataTransferLength);

        RtlZeroMemory(&cdb, sizeof(cdb));

        cdb.OperationCode = SCSIOP_READ_FORMATTED_CAPACITY;
        cdb.AllocationLength[1] = (UCHAR)dataTransferLength;

        capList = (PFORMATTED_CAPACITY_LIST)dataBuffer;

        ntStatus = USBSTOR_IssueInternalCdb(DeviceObject,
                                            dataBuffer,
                                            &dataTransferLength,
                                            (PCDB)&cdb,
                                            sizeof(cdb),
                                            20);

        DBGPRINT(1, ("%08X %08X %02X\n",
                     ntStatus, dataTransferLength, capList->CapacityListLength));

        if (NT_SUCCESS(ntStatus) &&
            dataTransferLength >= sizeof(FORMATTED_CAPACITY_LIST) &&
            capList->CapacityListLength &&
            capList->CapacityListLength % sizeof(FORMATTED_CAPACITY_DESCRIPTOR) == 0)
        {
            ULONG   NumberOfBlocks;
            ULONG   BlockLength;
            ULONG   i, j, count;

            // Subtract the size of the Capacity List Header to get
            // just the size of the Capacity List Descriptor array.
            //
            dataTransferLength -= sizeof(FORMATTED_CAPACITY_LIST);

            // Only look at the Capacity List Descriptors that were
            // actually returned.
            //
            if (dataTransferLength < capList->CapacityListLength)
            {
                count = dataTransferLength /
                        sizeof(FORMATTED_CAPACITY_DESCRIPTOR);
            }
            else
            {
                count = capList->CapacityListLength /
                        sizeof(FORMATTED_CAPACITY_DESCRIPTOR);
            }

            for (i=0; i<count; i++)
            {
                NumberOfBlocks = (capList->Descriptors[i].NumberOfBlocks[0] << 24) +
                                 (capList->Descriptors[i].NumberOfBlocks[1] << 16) +
                                 (capList->Descriptors[i].NumberOfBlocks[2] <<  8) +
                                  capList->Descriptors[i].NumberOfBlocks[3];

                BlockLength = (capList->Descriptors[i].BlockLength[0] << 16) +
                              (capList->Descriptors[i].BlockLength[1] <<  8) +
                               capList->Descriptors[i].BlockLength[2];

                DBGPRINT(1, ("Capacity[%d] %08X %06X %d%d\n",
                             i,
                             NumberOfBlocks,
                             BlockLength,
                             capList->Descriptors[i].Valid,
                             capList->Descriptors[i].Maximum));

                for (j=0; j<FLOPPY_CAPACITIES; j++)
                {
                    if (NumberOfBlocks == FloppyCapacities[j].NumberOfBlocks &&
                        BlockLength    == FloppyCapacities[j].BlockLength)
                    {
                        isFloppy = TRUE;
                    }
                }

            }
        }

        ExFreePool(dataBuffer);
    }

    DBGPRINT(1, ("exit:  USBSTOR_IsFloppyDevice %d\n", isFloppy));

    return isFloppy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbmass\usbmass.h ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    USBMASS.H

Abstract:

    Header file for USBSTOR driver

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <scsi.h>
#include "dbg.h"

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))


#define CLASS_URB(urb)      urb->UrbControlVendorClassRequest
#define FEATURE_URB(urb)    urb->UrbControlFeatureRequest


#define USBSTOR_MAX_TRANSFER_SIZE   0x00010000
#define USBSTOR_MAX_TRANSFER_PAGES  ((USBSTOR_MAX_TRANSFER_SIZE/PAGE_SIZE)+1)


// Interface Descriptor values
//
#define USBSTOR_SUBCLASS_RBC                0x01
#define USBSTOR_SUBCLASS_SFF8020i           0x02
#define USBSTOR_SUBCLASS_QIC157             0x03
#define USBSTOR_SUBCLASS_SFF8070i_UFI       0x04
#define USBSTOR_SUBCLASS_SFF8070i           0x05
#define USBSTOR_SUBCLASS_SCSI_PASSTHROUGH   0x06

#define USBSTOR_PROTOCOL_BULK_ONLY          0x50



#define USBSTOR_DO_TYPE_FDO     '!ODF'
#define USBSTOR_DO_TYPE_PDO     '!ODP'

#define USB_RECIPIENT_DEVICE    0
#define USB_RECIPIENT_INTERFACE 1
#define USB_RECIPIENT_ENDPOINT  2
#define USB_RECIPIENT_OTHER     3

// Bulk-Only class-specific bRequest codes
//
#define BULK_ONLY_MASS_STORAGE_RESET        0xFF
#define BULK_ONLY_GET_MAX_LUN               0xFE

// Maximum value that can be returned by BULK_ONLY_GET_MAX_LUN request
//
#define BULK_ONLY_MAXIMUM_LUN               0x0F


#define POOL_TAG                'SAMU'

#define INCREMENT_PENDING_IO_COUNT(deviceExtension) \
    InterlockedIncrement(&((deviceExtension)->PendingIoCount))

#define DECREMENT_PENDING_IO_COUNT(deviceExtension) do { \
    if (InterlockedDecrement(&((deviceExtension)->PendingIoCount)) == 0) { \
        KeSetEvent(&((deviceExtension)->RemoveEvent), \
                   IO_NO_INCREMENT, \
                   0); \
    } \
} while (0)


#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))


// PDEVICE_EXTENSION->DeviceFlags state flags
//
#define DF_SRB_IN_PROGRESS          0x00000002
#define DF_PERSISTENT_ERROR         0x00000004
#define DF_RESET_IN_PROGRESS        0x00000008
#define DF_DEVICE_DISCONNECTED      0x00000010


// PDEVICE_EXTENSION->DeviceHackFlags flags

// Force a Request Sense command between the completion of one command
// and the start of the next command.
//
#define DHF_FORCE_REQUEST_SENSE     0x00000001

// Reset the device when a Medium Changed AdditionalSenseCode is returned.
//
#define DHF_MEDIUM_CHANGE_RESET     0x00000002

// Turn SCSIOP_TEST_UNIT_READY requests into SCSIOP_START_STOP_UNIT requests.
//
#define DHF_TUR_START_UNIT          0x00000004


// Indicates that a Request Sense is being performed when the Srb has
// a SenseInfoBuffer and AutoSense is not disabled.
//
#define AUTO_SENSE                  0

// Indicates that a Request Sense is being performed when the Srb has
// no SenseInfoBuffer or AutoSense is disabled.  In this case the Request
// Sense is being performed to clear the "persistent error" condition
// in the wacky CBI spec.  (See also the DF_PERSISTENT_ERROR flag).
//
#define NON_AUTO_SENSE              1



// Command Block Wrapper Signature 'USBC'
//
#define CBW_SIGNATURE               0x43425355

#define CBW_FLAGS_DATA_IN           0x80
#define CBW_FLAGS_DATA_OUT          0x00

// Command Status Wrapper Signature 'USBS'
//
#define CSW_SIGNATURE               0x53425355

#define CSW_STATUS_GOOD             0x00
#define CSW_STATUS_FAILED           0x01
#define CSW_STATUS_PHASE_ERROR      0x02


//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef enum _DEVICE_STATE
{
    DeviceStateCreated = 1,     // After IoCreateDevice
    DeviceStateStarted,         // After START_DEVICE
    DeviceStateStopPending,     // After QUERY_STOP
    DeviceStateStopped,         // After STOP_DEVICE
    DeviceStateRemovePending,   // After QUERY_REMOVE
    DeviceStateSurpriseRemove,  // After SURPRISE_REMOVAL
    DeviceStateRemoved          // After REMOVE_DEVICE

} DEVICE_STATE;


typedef enum _DEVICE_PROTOCOL
{
    // This value indicates that the value was not set in the registry.
    // This should only happen on upgrades before the value started being
    // set by the .INF?
    //
    DeviceProtocolUnspecified = 0,

    // This value indicates that the device uses the Bulk-Only specification
    //
    DeviceProtocolBulkOnly,

    // This value indicates that the device uses the Control/Bulk/Interrupt
    // specification and that command completion Interrupt transfers are
    // supported after every request.
    //
    DeviceProtocolCBI,

    // This value indicates that the device uses the Control/Bulk/Interrupt
    // specification and that command completion Interrupt transfers are not
    // supported at all, or not supported after every request.  The Interrupt
    // endpoint will never be used by the driver for this type of device.
    //
    DeviceProtocolCB,

    // Anything >= this value is bogus
    //
    DeviceProtocolLast

} DEVICE_PROTOCOL;


#pragma pack (push, 1)

// Command Block Wrapper
//
typedef struct _CBW
{
    ULONG   dCBWSignature;

    ULONG   dCBWTag;

    ULONG   dCBWDataTransferLength;

    UCHAR   bCBWFlags;

    UCHAR   bCBWLUN;

    UCHAR   bCDBLength;

    UCHAR   CBWCDB[16];

} CBW, *PCBW;


// Command Status Wrapper
//
typedef struct _CSW
{
    ULONG   dCSWSignature;

    ULONG   dCSWTag;

    ULONG   dCSWDataResidue;

    UCHAR   bCSWStatus;

} CSW, *PCSW;

#pragma pack (pop)


// Device Extension header that is common to both FDO and PDO Device Extensions
//
typedef struct _DEVICE_EXTENSION
{
    // Either USBSTOR_DO_TYPE_FDO or USBSTOR_DO_TYPE_PDO
    //
    ULONG                           Type;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


// Device Extension for the FDO we attach on top of the USB enumerated PDO.
//
typedef struct _FDO_DEVICE_EXTENSION
{
    // USBSTOR_DO_TYPE_FDO
    //
    ULONG                           Type;

    // Back pointer to FDO Device Object to which this Device Extension
    // is attached.
    //
    PDEVICE_OBJECT                  FdoDeviceObject;

    // PDO passed to USBSTOR_AddDevice
    //
    PDEVICE_OBJECT                  PhysicalDeviceObject;

    // Our FDO is attached to this device object
    //
    PDEVICE_OBJECT                  StackDeviceObject;

    // List of child PDOs that we enumerate
    //
    LIST_ENTRY                      ChildPDOs;

    // Device Descriptor retrieved from the device
    //
    PUSB_DEVICE_DESCRIPTOR          DeviceDescriptor;

    // Configuration Descriptor retrieved from the device
    //
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigurationDescriptor;

    // Interface Descriptor contained within above Configuration Descriptor
    //
    PUSB_INTERFACE_DESCRIPTOR       InterfaceDescriptor;

    // Serial Number String Descriptor
    //
    PUSB_STRING_DESCRIPTOR          SerialNumber;

    // ConfigurationHandle returned from URB_FUNCTION_SELECT_CONFIGURATION
    //
    USBD_CONFIGURATION_HANDLE       ConfigurationHandle;

    // Interface info returned from URB_FUNCTION_SELECT_CONFIGURATION
    //
    PUSBD_INTERFACE_INFORMATION     InterfaceInfo;

    // Pointers back into InterfaceInfo for Bulk IN, Bulk OUT, and
    // Interrupt IN pipes.
    //
    PUSBD_PIPE_INFORMATION          BulkInPipe;

    PUSBD_PIPE_INFORMATION          BulkOutPipe;

    PUSBD_PIPE_INFORMATION          InterruptInPipe;

    // Initialized to one in AddDevice.
    // Incremented by one for each pending request.
    // Decremented by one for each pending request.
    // Decremented by one in REMOVE_DEVICE.
    //
    ULONG                           PendingIoCount;

    // Set when PendingIoCount is decremented to zero
    //
    KEVENT                          RemoveEvent;

    // DriverFlags read from regisry
    //
    ULONG                           DriverFlags;

    // NonRemovable read from regisry
    //
    ULONG                           NonRemovable;

    // Various DF_xxxx flags
    //
    ULONG                           DeviceFlags;

    // Various DHF_xxxx flags
    //
    ULONG                           DeviceHackFlags;

    // SpinLock which protects DeviceFlags
    //
    KSPIN_LOCK                      ExtensionDataSpinLock;

    // Current system power state
    //
    SYSTEM_POWER_STATE              SystemPowerState;

    // Current device power state
    //
    DEVICE_POWER_STATE              DevicePowerState;

    // Current power Irp, set by USBSTOR_FdoSetPower(), used by
    // USBSTOR_FdoSetPowerCompletion().
    //
    PIRP                            CurrentPowerIrp;

    // Set when the DevicePowerState >PowerDeviceD0 Irp is ready to be passed
    // down the stack.
    //
    KEVENT                          PowerDownEvent;

    ULONG                           SrbTimeout;

    PIRP                            PendingIrp;

    KEVENT                          CancelEvent;

    // Work Item used to issue Reset Pipe / Reset Port requests at PASSIVE_LEVEL
    //
    PIO_WORKITEM                    IoWorkItem;

    // URB used for ADSC Control Transfer and associated Bulk Transfer.
    // ADSC requests are serialized through StartIo so no need to protect
    // access to this single URB.
    //
    union
    {
        struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST ControlUrb;
        struct _URB_BULK_OR_INTERRUPT_TRANSFER      BulkIntrUrb;
    } Urb;

    // Original Srb saved here by USBSTOR_StartIo()
    //
    PSCSI_REQUEST_BLOCK             OriginalSrb;

    // Original CDB saved here by USBSTOR_TranslateCDB()
    //
    UCHAR                           OriginalCDB[16];

    union
    {
        // Fields used only for Control/Bulk/Interrupt devices
        //
        struct _CONTROL_BULK_INT
        {
            // Commmand completion interrupt data transferred here
            //
            USHORT                  InterruptData;

            // CDB for issuing a Request Sense when there is an error
            //
            UCHAR                   RequestSenseCDB[12];

            // Buffer for receiving Request Sense sense data when the Srb
            // doesn't have a sense buffer.
            //
            SENSE_DATA              SenseData;

        } Cbi;

        // Fields used only for Bulk Only devices
        //
        struct _BULK_ONLY
        {
            union
            {
                // Command Block Wrapper
                //
                CBW                 Cbw;

                // Command Status Wrapper
                //
                CSW                 Csw;

                // Workaround for USB 2.0 controller Data Toggle / Babble bug
                //
                UCHAR               MaxPacketSize[512];

            } CbwCsw;

            // How many times a STALL is seen trying to retrieve CSW
            //
            ULONG                   StallCount;

            // Srb used by USBSTOR_IssueRequestSense()
            //
            SCSI_REQUEST_BLOCK      InternalSrb;

        } BulkOnly;
    };

    ULONG                           DeviceResetCount;

    BOOLEAN                         LastSenseWasReset;

    BOOLEAN                         DeviceIsHighSpeed;

} FDO_DEVICE_EXTENSION, *PFDO_DEVICE_EXTENSION;

// Device Extension for the PDO we we enumerate as a child of the FDO
// attached on top of the USB enumerated PDO.
//
typedef struct _PDO_DEVICE_EXTENSION
{
    // USBSTOR_DO_TYPE_PDO
    //
    ULONG                           Type;

    // Back pointer to PDO Device Object to which this Device Extension
    // is attached.
    //
    PDEVICE_OBJECT                  PdoDeviceObject;

    // Parent FDO that enumerated us
    //
    PDEVICE_OBJECT                  ParentFDO;

    // List of child PDOs enumerated from parent FDO
    //
    LIST_ENTRY                      ListEntry;

    // PnP Device State
    //
    DEVICE_STATE                    DeviceState;

    // Current system power state
    //
    SYSTEM_POWER_STATE              SystemPowerState;

    // Current device power state
    //
    DEVICE_POWER_STATE              DevicePowerState;

    // Current power Irp, set by USBSTOR_PdoSetPower(), used by
    // USBSTOR_PdoSetPowerCompletion().
    //
    PIRP                            CurrentPowerIrp;

    BOOLEAN                         Claimed;

    BOOLEAN                         IsFloppy;

    // LUN value which is used in bCBWLUN
    //
    UCHAR                           LUN;

    // Data returned by an Inquiry command.  We are only interested in the
    // first 36 bytes, not the whole 96 bytes.
    //
    UCHAR                           InquiryDataBuffer[INQUIRYDATABUFFERSIZE];

} PDO_DEVICE_EXTENSION, *PPDO_DEVICE_EXTENSION;

//*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************

//
// USBMASS.C
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

VOID
USBSTOR_Unload (
    IN PDRIVER_OBJECT   DriverObject
    );

NTSTATUS
USBSTOR_AddDevice (
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );

VOID
USBSTOR_QueryFdoParams (
    IN PDEVICE_OBJECT   DeviceObject
    );

VOID
USBSTOR_QueryGlobalFdoParams (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBSTOR_Power (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
USBSTOR_FdoSetPowerCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
USBSTOR_FdoSetPowerD0Completion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_PdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
USBSTOR_PdoSetPowerCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
USBSTOR_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_Pnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoStartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_GetDescriptors (
    IN PDEVICE_OBJECT   DeviceObject
    );

USBSTOR_GetStringDescriptors (
    IN PDEVICE_OBJECT   DeviceObject
    );

VOID
USBSTOR_AdjustConfigurationDescriptor (
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc,
    OUT PUSB_INTERFACE_DESCRIPTOR      *InterfaceDesc,
    OUT PLONG                           BulkInIndex,
    OUT PLONG                           BulkOutIndex,
    OUT PLONG                           InterruptInIndex
    );

NTSTATUS
USBSTOR_GetPipes (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBSTOR_CreateChildPDO (
    IN PDEVICE_OBJECT   FdoDeviceObject,
    IN UCHAR            Lun
    );

NTSTATUS
USBSTOR_FdoStopDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoQueryStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoCancelStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoQueryDeviceRelations (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoQueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_PdoStartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_PdoRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_PdoQueryID (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

PCHAR
USBSTOR_PdoDeviceTypeString (
    IN  PDEVICE_OBJECT  DeviceObject
    );

PCHAR
USBSTOR_PdoGenericTypeString (
    IN  PDEVICE_OBJECT  DeviceObject
    );

VOID
CopyField (
    IN PUCHAR   Destination,
    IN PUCHAR   Source,
    IN ULONG    Count,
    IN UCHAR    Change
    );

NTSTATUS
USBSTOR_StringArrayToMultiSz(
    PUNICODE_STRING MultiString,
    PCSTR           StringArray[]
    );

NTSTATUS
USBSTOR_PdoQueryDeviceId (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
USBSTOR_PdoQueryHardwareIds (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
USBSTOR_PdoQueryCompatibleIds (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
USBSTOR_PdoQueryDeviceText (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_PdoBusQueryInstanceId (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
USBSTOR_PdoQueryDeviceRelations (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_PdoQueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_SyncPassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_SyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
USBSTOR_SyncSendUsbRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    );

NTSTATUS
USBSTOR_GetDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            DescriptorType,
    IN UCHAR            Index,
    IN USHORT           LanguageId,
    IN ULONG            RetryCount,
    IN ULONG            DescriptorLength,
    OUT PUCHAR         *Descriptor
    );

NTSTATUS
USBSTOR_GetMaxLun (
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PUCHAR          MaxLun
    );

NTSTATUS
USBSTOR_SelectConfiguration (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBSTOR_UnConfigure (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBSTOR_ResetPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN USBD_PIPE_HANDLE Pipe
    );

NTSTATUS
USBSTOR_AbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN USBD_PIPE_HANDLE Pipe
    );


//
// OCRW.C
//

NTSTATUS
USBSTOR_Create (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_Close (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_ReadWrite (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

//
// SCSI.C
//

NTSTATUS
USBSTOR_DeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_Scsi (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
USBSTOR_StartIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
USBSTOR_TimerTick (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          NotUsed
    );

NTSTATUS
USBSTOR_GetInquiryData (
    IN PDEVICE_OBJECT   DeviceObject
    );

BOOLEAN
USBSTOR_IsFloppyDevice (
    PDEVICE_OBJECT  DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\debugwdm.c ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

	DEBUGWDM.C

Abstract:

	Debug and diagnostic routines for WDM driver 

Environment:

	Kernel mode only

Notes:

	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
	KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
	PURPOSE.

	Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

	12/23/97 : created

Author:

	Tom Green

****************************************************************************/


#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "serioctl.h"
#include "utils.h"
#include "debugwdm.h"

// memory allocation stats
LOCAL  ULONG				MemoryAllocated		= 0L;
LOCAL  ULONG				MemAllocFailCnt		= 0L;
LOCAL  ULONG				MemAllocCnt			= 0L;
LOCAL  ULONG				MemFreeFailCnt		= 0L;
LOCAL  ULONG				MemFreeCnt			= 0L;
LOCAL  ULONG				MaxMemAllocated		= 0L;

// signature to write at end of allocated memory block
#define MEM_ALLOC_SIGNATURE	(ULONG) 'CLLA'

// signature to write at end of freed memory block
#define MEM_FREE_SIGNATURE	(ULONG) 'EERF'


#ifdef PROFILING_ENABLED

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE,Debug_OpenWDMDebug)
#pragma alloc_text(PAGE,Debug_CloseWDMDebug)
#pragma alloc_text(PAGE,Debug_SizeIRPHistoryTable)
#pragma alloc_text(PAGE,Debug_SizeDebugPathHist)
#pragma alloc_text(PAGE,Debug_SizeErrorLog)
#pragma alloc_text(PAGE,Debug_ExtractAttachedDevices)
#pragma alloc_text(PAGE,Debug_GetDriverInfo)
#pragma alloc_text(PAGE,Debug_ExtractIRPHist)
#pragma alloc_text(PAGE,Debug_ExtractPathHist)
#pragma alloc_text(PAGE,Debug_ExtractErrorLog)
#pragma alloc_text(PAGE,Debug_DumpDriverLog)
#pragma alloc_text(PAGE,Debug_TranslateStatus)
#pragma alloc_text(PAGE,Debug_TranslateIoctl)

#endif // ALLOC_PRAGMA



// data structures, macros, and data that the outside world doesn't need to know about

// amount of data to save from IRP buffer
#define IRP_DATA_SIZE		0x04

// size for temporary string formatting buffers
#define TMP_STR_BUFF_SIZE	0x100

// initial number of entries in tables and logs
#define DEFAULT_LOG_SIZE	64L


// data structures for debug stuff

// entry for IRP history table for IRPs going in and out
typedef struct IRPHistory
{
	LARGE_INTEGER			TimeStamp;
	PDEVICE_OBJECT			DeviceObject;
	PIRP					Irp;
	ULONG					MajorFunction;
	ULONG					IrpByteCount;
	UCHAR					IrpData[IRP_DATA_SIZE];
	UCHAR					IrpDataCount;
} IRPHist, *PIRPHist;

// entry for execution tracing
typedef struct PATHHistory
{
	LARGE_INTEGER			TimeStamp;
	PCHAR					Path;
} PATHHist, *PPATHHist;

// entry for error log
typedef struct ERRORLog
{
	LARGE_INTEGER			TimeStamp;
	NTSTATUS				Status;
} ERRLog, *PERRLog;

// this is for translating a code into an ASCII string
typedef struct Code2Ascii
{
	NTSTATUS				Code;
	PCHAR					Str;
} Code2Ascii;


// local data for debug file

// IRP history table components
LOCAL  PIRPHist				IRPHistoryTable		= NULL;
LOCAL  ULONG				IRPHistoryIndex		= 0L;
GLOBAL ULONG				IRPHistorySize		= 0L;

// Debug path storage
LOCAL  PPATHHist	 		DebugPathHist		= NULL;
LOCAL  ULONG		 		DebugPathIndex		= 0L;
GLOBAL ULONG		 		DebugPathSize		= 0L;

// Error log components
LOCAL  PERRLog		 		ErrorLog			= NULL;
LOCAL  ULONG				ErrorLogIndex		= 0L;
GLOBAL ULONG				ErrorLogSize		= 0L;

// this is for translating NT status codes into ASCII strings
LOCAL  Code2Ascii NTErrors[] =
{
	STATUS_SUCCESS,									"STATUS_SUCCESS",
	STATUS_PENDING,									"STATUS_PENDING",
	STATUS_TIMEOUT,									"STATUS_TIMEOUT",
	STATUS_DEVICE_BUSY,								"STATUS_DEVICE_BUSY",
	STATUS_INSUFFICIENT_RESOURCES,					"STATUS_INSUFFICIENT_RESOURCES",
	STATUS_INVALID_DEVICE_REQUEST,					"STATUS_INVALID_DEVICE_REQUEST",
	STATUS_DEVICE_NOT_READY,						"STATUS_DEVICE_NOT_READY",
	STATUS_INVALID_BUFFER_SIZE,						"STATUS_INVALID_BUFFER_SIZE",
	STATUS_INVALID_PARAMETER,						"STATUS_INVALID_PARAMETER",
	STATUS_INVALID_HANDLE,							"STATUS_INVALID_HANDLE",
	STATUS_OBJECT_PATH_NOT_FOUND,					"STATUS_OBJECT_PATH_NOT_FOUND",
	STATUS_BUFFER_TOO_SMALL,						"STATUS_BUFFER_TOO_SMALL",
	STATUS_NOT_SUPPORTED,							"STATUS_NOT_SUPPORTED",
	STATUS_DEVICE_DATA_ERROR,						"STATUS_DEVICE_DATA_ERROR",
	STATUS_CANCELLED,								"STATUS_CANCELLED",
	STATUS_OBJECT_NAME_INVALID,						"STATUS_OBJECT_NAME_INVALID",
	STATUS_OBJECT_NAME_NOT_FOUND,					"STATUS_OBJECT_NAME_NOT_FOUND"
};

LOCAL  ULONG				NumNTErrs = sizeof(NTErrors) / sizeof(Code2Ascii);
LOCAL  CHAR					UnknownStatus[80];

// this is for translating IOCTL codes into ASCII strings
LOCAL  Code2Ascii IoctlCodes[] =
{
	IRP_MJ_CREATE,						"CREATE",
	IRP_MJ_CREATE_NAMED_PIPE,			"CNPIPE",
	IRP_MJ_CLOSE,						"CLOSE ",
	IRP_MJ_READ,						"READ  ",
	IRP_MJ_WRITE,						"WRITE ",
	IRP_MJ_QUERY_INFORMATION,			"QRYINF",
	IRP_MJ_SET_INFORMATION,				"SETINF",
	IRP_MJ_QUERY_EA,					"QRYEA ",
	IRP_MJ_SET_EA,						"SETEA ",
	IRP_MJ_FLUSH_BUFFERS,				"FLSBUF",
	IRP_MJ_QUERY_VOLUME_INFORMATION,	"QRYVOL",
	IRP_MJ_SET_VOLUME_INFORMATION,		"SETVOL",
	IRP_MJ_DIRECTORY_CONTROL,			"DIRCTL",
	IRP_MJ_FILE_SYSTEM_CONTROL,			"SYSCTL",
	IRP_MJ_DEVICE_CONTROL,				"DEVCTL",
	IRP_MJ_INTERNAL_DEVICE_CONTROL,		"INDVCT",
	IRP_MJ_SHUTDOWN,					"SHTDWN",
	IRP_MJ_LOCK_CONTROL,				"LOKCTL",
	IRP_MJ_CLEANUP,						"CLNUP ",
	IRP_MJ_CREATE_MAILSLOT,				"MAILSL",
	IRP_MJ_QUERY_SECURITY,				"QRYSEC",
	IRP_MJ_SET_SECURITY,				"SETSEC",
	IRP_MJ_SYSTEM_CONTROL,              "SYSCTL",
	IRP_MJ_DEVICE_CHANGE,				"DEVCHG",
	IRP_MJ_QUERY_QUOTA,					"QRYQUO",
	IRP_MJ_SET_QUOTA,					"SETQUO",
	IRP_MJ_POWER,						"POWER ",
	IRP_MJ_PNP,							"PNP   ",
	IRP_MJ_MAXIMUM_FUNCTION,			"MAXFNC"
};

LOCAL ULONG					NumIoctl = sizeof(IoctlCodes) / sizeof(Code2Ascii);
LOCAL CHAR					UnknownIoctl[80];


/************************************************************************/
/*						Debug_OpenWDMDebug								*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Allocate resources and init history tables and logs.				*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  VOID																*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	NTSTATUS															*/
/*																		*/
/************************************************************************/
NTSTATUS
Debug_OpenWDMDebug(VOID)
{
	NTSTATUS		NtStatus = STATUS_SUCCESS;

	PAGED_CODE();

	// allocate tables and logs
	NtStatus = Debug_SizeIRPHistoryTable(DEFAULT_LOG_SIZE);
	if(!NT_SUCCESS(NtStatus))
	{
		Debug_CloseWDMDebug();
		return NtStatus;
	}

	NtStatus = Debug_SizeDebugPathHist(DEFAULT_LOG_SIZE);
	if(!NT_SUCCESS(NtStatus))
	{
		Debug_CloseWDMDebug();
		return NtStatus;
	}

	NtStatus = Debug_SizeErrorLog(DEFAULT_LOG_SIZE);
	if(!NT_SUCCESS(NtStatus))
	{
		Debug_CloseWDMDebug();
		return NtStatus;
	}
	
	return NtStatus;	
} // Debug_OpenWDMDebug


/************************************************************************/
/*						Debug_CloseWDMDebug								*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Free up resources used for history tables and logs.					*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  VOID																*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID																*/
/*																		*/
/************************************************************************/
VOID
Debug_CloseWDMDebug(VOID)
{
	PAGED_CODE();

	if(DebugPathHist)
	{
		DEBUG_MEMFREE(DebugPathHist);
		DebugPathHist	= NULL;
		DebugPathSize	= 0L;
	}

	if(IRPHistoryTable)
	{
		DEBUG_MEMFREE(IRPHistoryTable);
		IRPHistoryTable	= NULL;
		IRPHistorySize	= 0L;
	}

	if(ErrorLog)
	{
		DEBUG_MEMFREE(ErrorLog);
		ErrorLog		= NULL;
		ErrorLogSize	= 0L;
	}

    Debug_CheckAllocations();

	// see if we have a leak
	DEBUG_ASSERT("Memory Allocation Leak", MemAllocCnt == MemFreeCnt);
} // Debug_CloseWDMDebug


/************************************************************************/
/*						Debug_SizeIRPHistoryTable						*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Allocate IRP history table											*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  Size - number of entries in table									*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	NTSTATUS															*/
/*																		*/
/************************************************************************/
NTSTATUS
Debug_SizeIRPHistoryTable(IN ULONG Size)
{
	NTSTATUS		NtStatus = STATUS_SUCCESS;

	PAGED_CODE();

	// see if they are trying to set the same size
	if(Size == IRPHistorySize)
		return NtStatus;

	// get rid of old history table if we got one
	if(IRPHistoryTable)
		DEBUG_MEMFREE(IRPHistoryTable);

	IRPHistoryTable	= NULL;
	IRPHistoryIndex	= 0L;
	IRPHistorySize	= 0L;

	if(Size != 0L)
	{
		IRPHistoryTable = DEBUG_MEMALLOC(NonPagedPool, sizeof(IRPHist) * Size);
		if(IRPHistoryTable == NULL)
			NtStatus = STATUS_INSUFFICIENT_RESOURCES;
		else
		{
			RtlZeroMemory(IRPHistoryTable, sizeof(IRPHist) * Size);
			IRPHistorySize = Size;
		}
	}

	return NtStatus;
} // Debug_SizeIRPHistoryTable


/************************************************************************/
/*						Debug_SizeDebugPathHist							*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Allocate path history												*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  Size - number of entries in history									*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	NTSTATUS															*/
/*																		*/
/************************************************************************/
NTSTATUS
Debug_SizeDebugPathHist(IN ULONG Size)
{
	NTSTATUS		NtStatus = STATUS_SUCCESS;

	PAGED_CODE();

	// see if they are trying to set the same size
	if(Size == DebugPathSize)
		return NtStatus;

	// get rid of old path history if we got one
	if(DebugPathHist)
		DEBUG_MEMFREE(DebugPathHist);

	DebugPathHist	= NULL;
	DebugPathIndex	= 0L;
	DebugPathSize	= 0L;

	if(Size != 0L)
	{
		DebugPathHist = DEBUG_MEMALLOC(NonPagedPool, sizeof(PATHHist) * Size);
		if(DebugPathHist == NULL)
			NtStatus = STATUS_INSUFFICIENT_RESOURCES;
		else
		{
			RtlZeroMemory(DebugPathHist, sizeof(PATHHist) * Size);
			DebugPathSize = Size;
		}
	}

	return NtStatus;
} // Debug_SizeDebugPathHist


/************************************************************************/
/*						Debug_SizeErrorLog								*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Allocate error log													*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  Size - number of entries in error log								*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	NTSTATUS															*/
/*																		*/
/************************************************************************/
NTSTATUS
Debug_SizeErrorLog(IN ULONG Size)
{
	NTSTATUS		NtStatus = STATUS_SUCCESS;

	PAGED_CODE();

	// see if they are trying to set the same size
	if(Size == ErrorLogSize)
		return NtStatus;

	// get rid of old error log if we got one
	if(ErrorLog)
		DEBUG_MEMFREE(ErrorLog);
	ErrorLog		= NULL;
	ErrorLogIndex	= 0L;
	ErrorLogSize	= 0L;

	if(Size != 0L)
	{
		ErrorLog = DEBUG_MEMALLOC(NonPagedPool, sizeof(ERRLog) * Size);
		// make sure we actually allocated some memory
		if(ErrorLog == NULL)
			NtStatus = STATUS_INSUFFICIENT_RESOURCES;
		else
		{
			RtlZeroMemory(ErrorLog, sizeof(ERRLog) * Size);
			ErrorLogSize = Size;
		}
	}

	return NtStatus;
} // Debug_SizeErrorLog


/************************************************************************/
/*						Debug_LogIrpHist								*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Logs IRP history. These are timestamped and put in a				*/
/*  circular buffer for extraction later.								*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  DeviceObject  - pointer to device object.							*/
/*  Irp           - pointer to IRP.										*/
/*  MajorFunction - major function of IRP.								*/
/*  IoBuffer      - buffer for data passed in and out of driver.		*/
/*  BufferLen     - length of data buffer.								*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID																*/
/*																		*/
/************************************************************************/
VOID
Debug_LogIrpHist(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
				 IN ULONG MajorFunction, IN PVOID IoBuffer, IN ULONG BufferLen)
{
	PIRPHist IrpHist;
	
	// get pointer to current entry in IRP history table
	IrpHist = &IRPHistoryTable[IRPHistoryIndex++];
	
	// point to the next entry in the IRP history table
	IRPHistoryIndex %= IRPHistorySize;

	// get time stamp
	IrpHist->TimeStamp = KeQueryPerformanceCounter(NULL);

	// save IRP, device object, major function and first 8 bytes of data in buffer
	IrpHist->DeviceObject = DeviceObject;
	IrpHist->Irp = Irp;
	IrpHist->MajorFunction = MajorFunction;

	// copy any data if we have it
	IrpHist->IrpByteCount = BufferLen;
	IrpHist->IrpDataCount = (UCHAR) min(IRP_DATA_SIZE, BufferLen);
	if(BufferLen)
		*(ULONG *) IrpHist->IrpData = *(ULONG *) IoBuffer;
} // Debug_LogIrpHist


/************************************************************************/
/*						Debug_LogPath									*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Logs execution path through code. These are timestamped and put		*/
/*  in a circular buffer for extraction later. Kernel print routines 	*/
/*  are also called.													*/
/*																		*/
/*  DANGER DANGER Will Robinson - the argument to this must be a 		*/
/*  const char pointer,													*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  Path - Pointer to const char array that contains description of	*/
/*          of path.													*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID																*/
/*																		*/
/************************************************************************/
VOID
Debug_LogPath(IN CHAR *Path)
{
	PPATHHist	PHist;

	// get pointer to current entry in path history
	PHist = &DebugPathHist[DebugPathIndex++];

	// point to the next entry in path trace
	DebugPathIndex %= DebugPathSize;

	// get time stamp
	PHist->TimeStamp = KeQueryPerformanceCounter(NULL);

	// save path string
	PHist->Path = Path;

	// now call kernel print routines
	DEBUG_TRACE2(("%s\n", Path));
} // Debug_LogPath


/************************************************************************/
/*						Debug_LogError									*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Logs NTSTATUS type errors. These are timestamped and put in a		*/
/*  circular buffer for extraction later.								*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  NtStatus - NTSTATUS error to log.									*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID																*/
/*																		*/
/************************************************************************/
VOID
Debug_LogError(IN NTSTATUS NtStatus)
{
	PERRLog	ErrLog;

	// no error, so don't log
	if(NtStatus == STATUS_SUCCESS)
		return;

	// get pointer to current entry in error log
	ErrLog = &ErrorLog[ErrorLogIndex++];

	// point to the next entry in error log
	ErrorLogIndex %= ErrorLogSize;

	// get time stamp
	ErrLog->TimeStamp = KeQueryPerformanceCounter(NULL);

	// save status
	ErrLog->Status = NtStatus;
} // Debug_LogError


/************************************************************************/
/*						Debug_Trap										*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Trap. Causes execution to halt after logging message.				*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  TrapCause - pointer to char array that contains description			*/
/*				 of cause of trap.										*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID																*/
/*																		*/
/************************************************************************/
VOID
Debug_Trap(IN PCHAR TrapCause)
{
	// log the path
	DEBUG_LOG_PATH("Debug_Trap: ");

	DEBUG_LOG_PATH(TrapCause);

	// kernel debugger print
	DEBUG_TRACE3(("Debug_Trap: "));

	DEBUG_TRACE3(("%s\n",TrapCause));

	// halt execution
	DEBUG_TRAP();
} // Debug_TRAP


/************************************************************************/
/*						Debug_Assert									*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Assertion routine.													*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  This should not be called directly. Use DEBUG_ASSERT macro.			*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID																*/
/*																		*/
/************************************************************************/
VOID
Debug_Assert(IN PVOID FailedAssertion, IN PVOID FileName, IN ULONG LineNumber,
			 IN PCHAR Message)
{
#if DBG
	// just call the assert routine
    RtlAssert(FailedAssertion, FileName, LineNumber, Message);
#else
	DEBUG_TRAP();
#endif
} // Debug_Assert



/************************************************************************/
/*						Debug_ExtractAttachedDevices					*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Formats and places attached device info into a buffer.				*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	DriverObject  - pointer to driver object.							*/
/*																		*/
/*	Buffer        - pointer to buffer to fill with IRP history.			*/
/*  BuffSize      - size of Buffer.										*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	ULONG - number of bytes written in buffer.							*/
/*																		*/
/************************************************************************/
ULONG
Debug_ExtractAttachedDevices(IN PDRIVER_OBJECT DriverObject, OUT PCHAR Buffer, IN ULONG BuffSize)
{
	PCHAR				StrBuff;
	PDEVICE_EXTENSION	DeviceExtension;
	PDEVICE_OBJECT		DeviceObject;
	BOOLEAN				Dev = FALSE;

	PAGED_CODE();

	// make sure we have a pointer and a number of bytes
	if(Buffer == NULL || BuffSize == 0L)
		return 0L;

	// allocate buffer for formatting strings
	StrBuff = DEBUG_MEMALLOC(NonPagedPool, TMP_STR_BUFF_SIZE);

	if(StrBuff == NULL)
		return 0L;

	// title
	sprintf(StrBuff, "\n\n\nAttached Devices\n\n");

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);

	// columns	
	sprintf(StrBuff, "Device              Device Obj  IRPs Complete   Byte Count\n\n");

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);

	// get the first device object
	DeviceObject = DriverObject->DeviceObject;

	// march through linked list of devices
	while(DeviceObject)
	{
		// found at least one device
		Dev = TRUE;

		// Get a pointer to the device extension
		DeviceExtension = DeviceObject->DeviceExtension;
		sprintf(StrBuff, "%-17s   0x%p  0x%08X      0x%08X%08X\n", &DeviceExtension->LinkName[12],
				DeviceObject, DeviceExtension->IRPCount,
				DeviceExtension->ByteCount.HighPart,
				DeviceExtension->ByteCount.LowPart);

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);

		DeviceObject = DeviceObject->NextDevice;
	}

	// if we don't have any devices, say so, but this should never happen (I think)
	if(!Dev)
	{
		sprintf(StrBuff, "No attached devices\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);
	}

	DEBUG_MEMFREE(StrBuff);
	return strlen(Buffer);
} // Debug_ExtractAttachedDevices

/************************************************************************/
/*						Debug_GetDriverInfo								*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Formats and places driver info into a buffer.						*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	Buffer        - pointer to buffer to fill with IRP history.			*/
/*  BuffSize      - size of Buffer.										*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	ULONG - number of bytes written in buffer.							*/
/*																		*/
/************************************************************************/
ULONG
Debug_GetDriverInfo(OUT PCHAR Buffer, IN ULONG BuffSize)
{
	PCHAR				StrBuff;

	PAGED_CODE();

	// make sure we have a pointer and a number of bytes
	if(Buffer == NULL || BuffSize == 0L)
		return 0L;

	// allocate buffer for formatting strings
	StrBuff = DEBUG_MEMALLOC(NonPagedPool, TMP_STR_BUFF_SIZE);

	if(StrBuff == NULL)
		return 0L;

	// driver name and version
	sprintf(StrBuff, "\n\n\nDriver:	 %s\n\nVersion: %s\n\n", DriverName, DriverVersion);

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);

	DEBUG_MEMFREE(StrBuff);
	return strlen(Buffer);	
} // Debug_GetDriverInfo


/************************************************************************/
/*						Debug_ExtractIRPHist							*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Formats and places IRP history info into a buffer.					*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	Buffer   - pointer to buffer to fill with IRP history.				*/
/*  BuffSize - size of Buffer.											*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	ULONG - number of bytes written in buffer.							*/
/*																		*/
/************************************************************************/
ULONG
Debug_ExtractIRPHist(OUT PCHAR Buffer, IN ULONG BuffSize)
{
	ULONG		Index, Size;
	PIRPHist	IrpHist;
	PCHAR		StrBuff;
	BOOLEAN		Hist = FALSE;
	
	PAGED_CODE();

	// make sure we have a pointer and a number of bytes
	if(Buffer == NULL || BuffSize == 0L)
		return 0L;

	// allocate buffer for formatting strings
	StrBuff = DEBUG_MEMALLOC(NonPagedPool, TMP_STR_BUFF_SIZE);

	if(StrBuff == NULL)
		return 0L;

	// title
	sprintf(StrBuff, "\n\n\nIRP History\n\n");

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);

	// see if error log is on
	if(IRPHistorySize == 0L)
	{
		sprintf(StrBuff, "IRP History is disabled\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);
	}
	else
	{
		// columns	
		sprintf(StrBuff, "Time Stamp          Device Obj  IRP         Func    Byte Count  Data\n\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);

		Index = IRPHistoryIndex;

		for(Size = 0; Size < IRPHistorySize; Size++)
		{
			// get pointer to current entry in IRP history table
			IrpHist = &IRPHistoryTable[Index++];

			// parse timestamp and IRP history and write to buffer
			if(IrpHist->TimeStamp.LowPart)
			{
				UCHAR	DataCount;
				CHAR	DataBuff[10];

				// we have at least one entry
				Hist = TRUE;

				sprintf(StrBuff, "0x%08X%08X  0x%p  0x%p  %s  0x%08X  ",
						IrpHist->TimeStamp.HighPart, IrpHist->TimeStamp.LowPart,
						IrpHist->DeviceObject, IrpHist->Irp,
						Debug_TranslateIoctl(IrpHist->MajorFunction),
						IrpHist->IrpByteCount);


				// add data bytes if we got them
				for(DataCount = 0; DataCount < IrpHist->IrpDataCount; DataCount++)
				{
					sprintf(DataBuff, "%02x ", IrpHist->IrpData[DataCount]);
					strcat(StrBuff, DataBuff);
				}

				sprintf(DataBuff, "\n");

				strcat(StrBuff, DataBuff);

				// make sure it fits in buffer
				if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
					strcat(Buffer, StrBuff);
			}
		
			// point to the next entry in the IRP history table
			Index %= IRPHistorySize;
		}

		// if we don't have history, say so, but this should never happen (I think)
		if(!Hist)
		{
			sprintf(StrBuff, "No IRP history\n");

			// make sure it fits in buffer
			if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
				strcat(Buffer, StrBuff);
		}
	}

	DEBUG_MEMFREE(StrBuff);
	return strlen(Buffer);
} // Debug_ExtractIRPHist


/************************************************************************/
/*						Debug_ExtractPathHist							*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Formats and places path history info into buffer.					*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	Buffer   - pointer to buffer to fill with path history.				*/
/*  BuffSize - size of Buffer.											*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	ULONG - number of bytes written in buffer.							*/
/*																		*/
/************************************************************************/
ULONG
Debug_ExtractPathHist(OUT PCHAR Buffer, IN ULONG BuffSize)
{
	ULONG		Index, Size;
	PPATHHist	PHist;
	PCHAR		StrBuff;
	BOOLEAN		Hist = FALSE;
	
	PAGED_CODE();

	// make sure we have a pointer and a number of bytes
	if(Buffer == NULL || BuffSize == 0L)
		return 0L;

	// allocate buffer for formatting strings
	StrBuff = DEBUG_MEMALLOC(NonPagedPool, TMP_STR_BUFF_SIZE);

	if(StrBuff == NULL)
		return 0L;

	// title
	sprintf(StrBuff, "\n\n\nExecution Path History\n\n");

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);
		
	// see if path history is on
	if(DebugPathSize == 0L)
	{
		sprintf(StrBuff, "Path History is disabled\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);
	}
	else
	{
		// columns	
		sprintf(StrBuff, "Time Stamp          Path\n\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);
		
		Index = DebugPathIndex;

		for(Size = 0; Size < DebugPathSize; Size++)
		{
			// get pointer to current entry in path history
			PHist = &DebugPathHist[Index++];

			// parse timestamp and path and write to buffer. Check for NULL entries
			if(PHist->TimeStamp.LowPart)
			{
				// at least we have one entry
				Hist = TRUE;
			
				sprintf(StrBuff, "0x%08X%08X  %s\n", PHist->TimeStamp.HighPart, 
						PHist->TimeStamp.LowPart, PHist->Path);

				// make sure it fits in buffer
				if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
					strcat(Buffer, StrBuff);
			}
		
			// point to the next entry in path trace
			Index %= DebugPathSize;
		}

		// if we don't have history, say so, but this should never happen (I think)
		if(!Hist)
		{
			sprintf(StrBuff, "No execution path history\n");

			// make sure it fits in buffer
			if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
				strcat(Buffer, StrBuff);
		}
	}

	DEBUG_MEMFREE(StrBuff);
	return strlen(Buffer);
} // Debug_ExtractPathHist


/************************************************************************/
/*						Debug_ExtractErrorLog							*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Formats and places error log info into buffer.						*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	Buffer   - pointer to buffer to fill with IRP history.				*/
/*  BuffSize - size of Buffer.											*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	ULONG - number of bytes written in buffer.							*/
/*																		*/
/************************************************************************/
ULONG
Debug_ExtractErrorLog(OUT PCHAR Buffer, IN ULONG BuffSize)
{
	ULONG		Index, Size;
	PERRLog		ErrLog;
	PCHAR		StrBuff;
	BOOLEAN		Errors = FALSE;
	
	PAGED_CODE();

	// make sure we have a pointer and a number of bytes
	if(Buffer == NULL || BuffSize == 0L)
		return 0L;

	// allocate buffer for formatting strings
	StrBuff = DEBUG_MEMALLOC(NonPagedPool, TMP_STR_BUFF_SIZE);

	if(StrBuff == NULL)
		return 0L;

	// title
	sprintf(StrBuff, "\n\n\nError Log\n\n");

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);
		
	// see if error log is on
	if(ErrorLogSize == 0L)
	{
		sprintf(StrBuff, "Error Log is disabled\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);
	}
	else
	{
		// columns	
		sprintf(StrBuff, "Time Stamp          Error\n\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);
		
		Index = ErrorLogIndex;

		for(Size = 0; Size < ErrorLogSize; Size++)
		{
			// get pointer to current entry in error log
			ErrLog = &ErrorLog[Index++];

			// parse timestamp and error and write to buffer
			if(ErrLog->TimeStamp.LowPart)
			{
				// we have at least one error
				Errors = TRUE;
			
				sprintf(StrBuff, "0x%08X%08X  %s\n", ErrLog->TimeStamp.HighPart, 
						ErrLog->TimeStamp.LowPart, Debug_TranslateStatus(ErrLog->Status));

				// make sure it fits in buffer
				if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
					strcat(Buffer, StrBuff);
			}
		
			// point at next entry
			Index %= ErrorLogSize;
		}

		// if we don't have errors, say so
		if(!Errors)
		{
			sprintf(StrBuff, "No errors in log\n");

			// make sure it fits in buffer
			if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
				strcat(Buffer, StrBuff);
		}
	}

	DEBUG_MEMFREE(StrBuff);
	return strlen(Buffer);
} // Debug_ExtractErrorLog


/************************************************************************/
/*						Debug_DumpDriverLog								*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Dumps all history and logging to buffer.							*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  DeviceObject - pointer to device object.							*/
/*																		*/
/*	Buffer        - pointer to buffer to fill with IRP history.			*/
/*  BuffSize      - size of pBuffer.									*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	ULONG - number of bytes written in buffer.							*/
/*																		*/
/************************************************************************/
ULONG
Debug_DumpDriverLog(IN PDEVICE_OBJECT DeviceObject, OUT PCHAR Buffer, IN ULONG BuffSize)
{
	PCHAR		StrBuff;

	PAGED_CODE();

	// make sure we have a pointer and a number of bytes
	if(Buffer == NULL || BuffSize == 0L)
		return 0L;

	// allocate buffer for formatting strings
	StrBuff = DEBUG_MEMALLOC(NonPagedPool, TMP_STR_BUFF_SIZE);

	if(StrBuff == NULL)
		return 0L;

	// driver name and version, memory allocated
	sprintf(StrBuff, "\n\n\nDriver:	 %s\n\nVersion: %s\n\nMemory Allocated:          0x%08X\nMaximum Memory Allocated:  0x%08X\n",
			DriverName, DriverVersion, MemoryAllocated, MaxMemAllocated);

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);
		
	// memory allocation stats
	sprintf(StrBuff, "MemAlloc Count:            0x%08X\nMemFree Count:             0x%08X\nMemAlloc Fail Count:       0x%08X\nMemFree Fail Count:        0x%08X\n",
			MemAllocCnt, MemFreeCnt, MemAllocFailCnt, MemFreeFailCnt);

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);
		
	// get attached devices
	Debug_ExtractAttachedDevices(DeviceObject->DriverObject, Buffer, BuffSize);

	// get IRP history
	Debug_ExtractIRPHist(Buffer, BuffSize);

	// get execution path history
	Debug_ExtractPathHist(Buffer, BuffSize);

	// get error log
	Debug_ExtractErrorLog(Buffer, BuffSize);

	DEBUG_MEMFREE(StrBuff);
	return strlen(Buffer);
} // Debug_DumpDriverLog


/************************************************************************/
/*						Debug_TranslateStatus							*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Translates NTSTATUS into ASCII string.								*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  NtStatus - NTSTATUS code.											*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	PCHAR - pointer to error string.									*/
/*																		*/
/************************************************************************/
PCHAR
Debug_TranslateStatus(IN NTSTATUS NtStatus)
{
	ULONG	Err;

	PAGED_CODE();

	for(Err = 0; Err < NumNTErrs; Err++)
	{
		if(NtStatus == NTErrors[Err].Code)
			return NTErrors[Err].Str;
	}

	// fell through, not an error we handle
	sprintf(UnknownStatus, "Unknown error 0x%08X", NtStatus);

	return UnknownStatus;
} // Debug_TranslateStatus


/************************************************************************/
/*						Debug_TranslateIoctl							*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Translates IOCTL into ASCII string.									*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  Ioctl - ioctl code.													*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	PCHAR - pointer to error string.									*/
/*																		*/
/************************************************************************/
PCHAR
Debug_TranslateIoctl(IN LONG Ioctl)
{
	ULONG	Index;

	PAGED_CODE();

	// it's kind of repetitive to search at this point, but just in case
	// they change the actual IOCTLs we will be covered
	for(Index = 0; Index < NumIoctl; Index++)
	{
		if(Ioctl == IoctlCodes[Index].Code)
			return IoctlCodes[Index].Str;
	}

	// fell through, not an error we handle
	sprintf(UnknownIoctl, "0x%04X", Ioctl);

	return UnknownIoctl;
} // Debug_TranslateIoctl

#endif // PROFILING_ENABLED

VOID
Debug_CheckAllocations(VOID)
{
	DEBUG_TRACE1(("MemoryAllocated = 0x%08X\n", MemoryAllocated));
	DEBUG_TRACE1(("MemAllocCnt = 0x%08X   MemFreeCnt = 0x%08X\n",
				  MemAllocCnt, MemFreeCnt));
} // Debug_CheckAllocations

/************************************************************************/
/*						Debug_MemAlloc									*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Allocates block of memory. Stores length of block and a				*/
/*  signature ULONG for keeping track of amount of memory allocated		*/
/*  and checking for bogus calls to Debug_MemFree. The signature		*/
/*  can also be used to determine if someone has written past the		*/
/*	end of the block.													*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	PoolType      - Pool to allocate memory from.						*/
/*  NumberOfBytes - Number of bytes to allocate.						*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	PVOID - pointer to allocated memory.								*/
/*																		*/
/************************************************************************/
PVOID
Debug_MemAlloc(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
{
#ifdef _WIN64

	return ExAllocatePool(PoolType, NumberOfBytes);

#else
	PULONG	Mem;

	// allocate memory plus a little extra for our own use
	Mem = ExAllocatePool(PoolType, NumberOfBytes + (2 * sizeof(ULONG)));

	// see if we actually allocated any memory
	if(Mem)
	{
		// keep track of how much we allocated
		MemoryAllocated += NumberOfBytes;

		// see if we have a new maximum
		if(MemoryAllocated > MaxMemAllocated)
			MaxMemAllocated = MemoryAllocated;

		// store number of bytes allocated at start of memory allocated
		*Mem++ = NumberOfBytes;

		// now we are pointing at the memory allocated for caller
		// put signature word at end

		// get new pointer that points to end of buffer - ULONG
		Mem = (PULONG) (((PUCHAR) Mem) + NumberOfBytes);

		// write signature
		*Mem = MEM_ALLOC_SIGNATURE;

		// get back pointer to return to caller
		Mem = (PULONG) (((PUCHAR) Mem) - NumberOfBytes);

		// log stats
		MemAllocCnt++;
	}
	else
		// failed, log stats
		MemAllocFailCnt++;

	return (PVOID) Mem;

#endif

} // Debug_MemAlloc


/************************************************************************/
/*						Debug_MemFree									*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Frees memory allocated in call to Debug_MemAlloc. Checks for		*/
/*  signature ULONG at the end of allocated memory to make sure			*/
/*  this is a valid block to free.										*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	Mem - pointer to allocated block to free							*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID. Traps if it is an invalid block.								*/
/*																		*/
/************************************************************************/
VOID
Debug_MemFree(IN PVOID Mem)
{
#ifdef _WIN64

	ExFreePool(Mem);

#else
	PULONG	Tmp = (PULONG) Mem;
	ULONG	BuffSize;
	
	// point at size ULONG at start of buffer, and address to free
	Tmp--;

	// get the size of memory allocated by caller
	BuffSize = *Tmp;

	// point at signature and make sure it's O.K.
	((PCHAR) Mem) += BuffSize;

	if(*((PULONG) Mem) == MEM_ALLOC_SIGNATURE)
	{
		// let's go ahead and get rid of signature in case we get called
		// with this pointer again and memory is still paged in
		*((PULONG) Mem) = MEM_FREE_SIGNATURE;
		
		// adjust amount of memory allocated
		MemoryAllocated -= BuffSize;
		// free real pointer
		ExFreePool(Tmp);

		// log stats
		MemFreeCnt++;
	}
	else
	{
		// not a real allocated block, or someone wrote past the end
		MemFreeFailCnt++;
		DEBUG_TRAP();
	}
#endif
} // Debug_MemFree
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\debugwdm.h ===
/****************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

	DEBUGWDM.H

Abstract:

	This header file is for debug and diagnostics for a WDM driver

Environment:

	Kernel mode and user mode

Notes:

	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
	KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
	PURPOSE.

	Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

Revision History:

	12/23/97 : created

Author:

	Tom Green

****************************************************************************/

#ifndef __DEBUGWDM_H__
#define __DEBUGWDM_H__


// this makes it easy to hide static vars, make visible for debug
#if DBG
#define LOCAL
#define GLOBAL
#else
#define LOCAL	static
#define GLOBAL
#endif

#ifdef POOL_TAGGING
#undef  ExAllocatePool
#define ExAllocatePool(type, size) ExAllocatePoolWithTag(type, size, 'CBSU')
#endif

#if DBG

#define DEBUG_TRACE1(_x_)								{	\
						if(Usbser_Debug_Trace_Level >= 1)	\
						{									\
							DbgPrint _x_ ;					\
						}									\
														}
#define DEBUG_TRACE2(_x_)								{	\
						if(Usbser_Debug_Trace_Level >= 2)	\
						{									\
							DbgPrint("%s: ",DriverName);	\
							DbgPrint _x_ ;					\
						}									\
														}
#define DEBUG_TRACE3(_x_)								{	\
						if(Usbser_Debug_Trace_Level >= 3)	\
						{									\
							DbgPrint("%s: ",DriverName);	\
							DbgPrint _x_ ;					\
						}									\
														}

#define DEBUG_TRAP()		DbgBreakPoint()

#else

#define DEBUG_TRACE1(_x_)
#define DEBUG_TRACE2(_x_)
#define DEBUG_TRACE3(_x_)

#define DEBUG_TRAP()		DbgBreakPoint()

#endif // DBG




// these macros are for logging things, avoid subroutine call
// if they are disabled (number of entries = 0)

#ifdef PROFILING_ENABLED

// need these for creating macros for speed in logging and history

extern GLOBAL ULONG					IRPHistorySize;
extern GLOBAL ULONG		 			DebugPathSize;
extern GLOBAL ULONG					ErrorLogSize;

#define DEBUG_LOG_IRP_HIST(dobj, pirp, majfunc, buff, bufflen)	{	\
	if(IRPHistorySize)												\
		Debug_LogIrpHist(dobj, pirp, majfunc, buff, bufflen);		\
																}

#define DEBUG_LOG_PATH(path)									{	\
	if(DebugPathSize)												\
		Debug_LogPath(path);										\
																}

#define DEBUG_LOG_ERROR(status)									{	\
	if(ErrorLogSize)												\
		Debug_LogError(status);										\
																}


#define DEBUG_ASSERT(msg, exp)									{	\
    if(!(exp))														\
        Debug_Assert(#exp, __FILE__, __LINE__, msg);				\
																}

#define DEBUG_OPEN			Debug_OpenWDMDebug

#define DEBUG_CLOSE			Debug_CloseWDMDebug

#define DEBUG_MEMALLOC		Debug_MemAlloc

#define DEBUG_MEMFREE		Debug_MemFree

#define DEBUG_CHECKMEM      Debug_CheckAllocations


// prototypes

NTSTATUS
Debug_OpenWDMDebug(VOID);

VOID
Debug_CloseWDMDebug(VOID);

NTSTATUS
Debug_SizeIRPHistoryTable(IN ULONG Size);

NTSTATUS
Debug_SizeDebugPathHist(IN ULONG Size);

NTSTATUS
Debug_SizeErrorLog(ULONG Size);

VOID
Debug_LogIrpHist(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
				 IN ULONG MajorFunction, IN PVOID IoBuffer, IN ULONG BufferLen);

VOID
Debug_LogPath(IN PCHAR Path);

VOID
Debug_LogError(IN NTSTATUS NtStatus);

VOID
Debug_Trap(IN PCHAR TrapCause);

VOID
Debug_Assert(IN PVOID FailedAssertion, IN PVOID FileName, IN ULONG LineNumber,
			 IN PCHAR Message);

ULONG
Debug_ExtractAttachedDevices(IN PDRIVER_OBJECT DriverObject, OUT PCHAR Buffer, IN ULONG BuffSize);

ULONG
Debug_GetDriverInfo(OUT PCHAR Buffer, IN ULONG BuffSize);

ULONG
Debug_ExtractIRPHist(OUT PCHAR Buffer, IN ULONG BuffSize);

ULONG
Debug_ExtractPathHist(OUT PCHAR Buffer, IN ULONG BuffSize);

ULONG
Debug_ExtractErrorLog(OUT PCHAR Buffer, IN ULONG BuffSize);

ULONG
Debug_DumpDriverLog(IN PDEVICE_OBJECT DeviceObject, OUT PCHAR Buffer, IN ULONG BuffSize);

PCHAR
Debug_TranslateStatus(IN NTSTATUS NtStatus);

PCHAR
Debug_TranslateIoctl(IN LONG Ioctl);

#else

VOID
Debug_CheckAllocations(VOID);

PVOID
Debug_MemAlloc(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);

VOID
Debug_MemFree(IN PVOID pMem);

#define DEBUG_LOG_IRP_HIST(dobj, pirp, majfunc, buff, bufflen)

#define DEBUG_LOG_PATH(path)

#define DEBUG_LOG_ERROR(status)

#define DEBUG_ASSERT(msg, exp)

#define DEBUG_OPEN()				STATUS_SUCCESS

#define DEBUG_CLOSE()

#define DEBUG_MEMALLOC		Debug_MemAlloc

#define DEBUG_MEMFREE		Debug_MemFree

#define DEBUG_CHECKMEM      Debug_CheckAllocations


#endif // PROFILING_ENABLED


#endif // __DEBUGWDM_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\read.c ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

        READ.C

Abstract:

        Routines that perform read functionality

Environment:

        kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        9/25/98 : created

Authors:

        Louis J. Giliberto, Jr.


****************************************************************************/

#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "utils.h"
#include "debugwdm.h"

//
// PAGEUSBS is keyed off of UsbSer_Read, so UsbSer_Read must
// remain in PAGEUSBS for things to work properly
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEUSBS, UsbSerCancelCurrentRead)
#pragma alloc_text(PAGEUSBS, UsbSer_Read)
#pragma alloc_text(PAGEUSBS, UsbSerStartRead)
#pragma alloc_text(PAGEUSBS, UsbSerGrabReadFromRx)
#pragma alloc_text(PAGEUSBS, UsbSerReadTimeout)
#pragma alloc_text(PAGEUSBS, UsbSerIntervalReadTimeout)

#endif // ALLOC_PRAGMA


/************************************************************************/
/*                                              UsbSer_Read             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Process the IRPs sent to this device for Read calls             */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_Read(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
        NTSTATUS                        NtStatus =  STATUS_SUCCESS;
        PIO_STACK_LOCATION      IrpStack;
        PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;

        USBSER_LOCKED_PAGED_CODE();

        DEBUG_LOG_PATH("enter UsbSer_Read");
        UsbSerSerialDump(USBSERTRACERD, (">UsbSer_Read(%08X)\n", Irp));

        // set return values to something known
        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        DEBUG_TRACE2(("Read (%08X)\n", IrpStack->Parameters.Read.Length));

        UsbSerSerialDump(USBSERTRACE, ("UsbSer_Read Irp: %08X (%08X)\n", Irp,
                          IrpStack->Parameters.Read.Length));

        // make entry in IRP history table
        DEBUG_LOG_IRP_HIST(DeviceObject, Irp, IrpStack->MajorFunction,
                                           Irp->AssociatedIrp.SystemBuffer,
                                           IrpStack->Parameters.Read.Length);

        if (IrpStack->Parameters.Read.Length != 0) {
           NtStatus = UsbSerStartOrQueue(DeviceExtension, Irp,
                                     &DeviceExtension->ReadQueue,
                                     &DeviceExtension->CurrentReadIrp,
                                     UsbSerStartRead);
        } else {
           Irp->IoStatus.Status = NtStatus = STATUS_SUCCESS;
           Irp->IoStatus.Information = 0;


           CompleteIO(DeviceObject, Irp, IrpStack->MajorFunction,
                      Irp->AssociatedIrp.SystemBuffer,
                      Irp->IoStatus.Information);
        }

        // log an error if we got one
        DEBUG_LOG_ERROR(NtStatus);
        DEBUG_LOG_PATH("exit  UsbSer_Read");
        DEBUG_TRACE3(("status (%08X)\n", NtStatus));
        UsbSerSerialDump(USBSERTRACERD, ("<UsbSer_Read %08X\n", NtStatus));

        return NtStatus;
} // UsbSer_Read



NTSTATUS
UsbSerStartRead(IN PDEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This routine processes the active read request by initializing any timers,
   doing the initial submission to the read state machine, etc.

Arguments:

    PDevExt - Pointer to the device extension for the device to start a read on

Return Value:

    NTSTATUS

--*/
{
   NTSTATUS firstStatus = STATUS_SUCCESS;
   BOOLEAN setFirstStatus = FALSE;
   ULONG charsRead;
   KIRQL oldIrql;
   KIRQL controlIrql;
   PIRP newIrp;
   PIRP pReadIrp;
   ULONG readLen;
   ULONG multiplierVal;
   ULONG constantVal;
   BOOLEAN useTotalTimer;
   BOOLEAN returnWithWhatsPresent;
   BOOLEAN os2ssreturn;
   BOOLEAN crunchDownToOne;
   BOOLEAN useIntervalTimer;
   SERIAL_TIMEOUTS timeoutsForIrp;
   LARGE_INTEGER totalTime;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("Enter UsbSerStartRead");
   UsbSerSerialDump(USBSERTRACERD, (">UsbSerStartRead\n"));


   do {
      pReadIrp = PDevExt->CurrentReadIrp;
      readLen = IoGetCurrentIrpStackLocation(pReadIrp)->Parameters.Read.Length;


      PDevExt->NumberNeededForRead = readLen;

      DEBUG_TRACE3(("Start Reading %08X\n", PDevExt->NumberNeededForRead));

      useTotalTimer = FALSE;
      returnWithWhatsPresent = FALSE;
      os2ssreturn = FALSE;
      crunchDownToOne = FALSE;
      useIntervalTimer = FALSE;

      //
      // Always initialize the timer objects so that the
      // completion code can tell when it attempts to
      // cancel the timers whether the timers had ever
      // been Set.
      //

      ACQUIRE_SPINLOCK(PDevExt, &PDevExt->ControlLock, &controlIrql);
      timeoutsForIrp = PDevExt->Timeouts;
      PDevExt->CountOnLastRead = 0;
      RELEASE_SPINLOCK(PDevExt, &PDevExt->ControlLock, controlIrql);

      //
      // Calculate the interval timeout for the read
      //

      if (timeoutsForIrp.ReadIntervalTimeout
          && (timeoutsForIrp.ReadIntervalTimeout != MAXULONG)) {
         useIntervalTimer = TRUE;

         PDevExt->IntervalTime.QuadPart
         = UInt32x32To64(timeoutsForIrp.ReadIntervalTimeout, 10000);

         if (PDevExt->IntervalTime.QuadPart
             >= PDevExt->CutOverAmount.QuadPart) {
            PDevExt->IntervalTimeToUse = &PDevExt->LongIntervalAmount;
         } else {
            PDevExt->IntervalTimeToUse = &PDevExt->ShortIntervalAmount;
         }
      }


      if (timeoutsForIrp.ReadIntervalTimeout == MAXULONG) {
         //
         // We need to do special return quickly stuff here.
         //
         // 1) If both constant and multiplier are
         //    0 then we return immediately with whatever
         //    we've got, even if it was zero.
         //
         // 2) If constant and multiplier are not MAXULONG
         //    then return immediately if any characters
         //    are present, but if nothing is there, then
         //    use the timeouts as specified.
         //
         // 3) If multiplier is MAXULONG then do as in
         //    "2" but return when the first character
         //    arrives.
         //

         if (!timeoutsForIrp.ReadTotalTimeoutConstant
             && !timeoutsForIrp.ReadTotalTimeoutMultiplier) {
            returnWithWhatsPresent = TRUE;
         } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                    && (timeoutsForIrp.ReadTotalTimeoutMultiplier
                        != MAXULONG)) {
            useTotalTimer = TRUE;
            os2ssreturn = TRUE;
            multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
            constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
         } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                    && (timeoutsForIrp.ReadTotalTimeoutMultiplier
                        == MAXULONG)) {
            useTotalTimer = TRUE;
            os2ssreturn = TRUE;
            crunchDownToOne = TRUE;
            multiplierVal = 0;
            constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
         }
      } else {
         //
         // If both the multiplier and the constant are
         // zero then don't do any total timeout processing.
         //

         if (timeoutsForIrp.ReadTotalTimeoutMultiplier
             || timeoutsForIrp.ReadTotalTimeoutConstant) {
            //
            // We have some timer values to calculate
            //

            useTotalTimer = TRUE;
            multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
            constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
         }
      }


      if (useTotalTimer) {
         totalTime.QuadPart
         = ((LONGLONG)(UInt32x32To64(PDevExt->NumberNeededForRead,
                                     multiplierVal) + constantVal)) * -10000;
      }


      if (PDevExt->CharsInReadBuff) {
         charsRead
         = GetData(PDevExt, ((PUCHAR)(pReadIrp->AssociatedIrp.SystemBuffer))
                   + readLen - PDevExt->NumberNeededForRead,
                   PDevExt->NumberNeededForRead,
                   &pReadIrp->IoStatus.Information);
      } else {
         charsRead = 0;
      }


      //
      // See if this read is complete
      //

      if (returnWithWhatsPresent || (PDevExt->NumberNeededForRead == 0)
          || (os2ssreturn && pReadIrp->IoStatus.Information)) {

#if DBG
if (UsbSerSerialDebugLevel & USBSERDUMPRD) {
      ULONG i;
      ULONG count;

      if (PDevExt->CurrentReadIrp->IoStatus.Status == STATUS_SUCCESS) {
         count = (ULONG)PDevExt->CurrentReadIrp->IoStatus.Information;
      } else {
         count = 0;

      }
      DbgPrint("RD3: A(%08X) G(%08X) I(%08X)\n",
               IoGetCurrentIrpStackLocation(PDevExt->CurrentReadIrp)
               ->Parameters.Read.Length, count, PDevExt->CurrentReadIrp);

      for (i = 0; i < count; i++) {
         DbgPrint("%02x ", *(((PUCHAR)PDevExt->CurrentReadIrp
                              ->AssociatedIrp.SystemBuffer) + i) & 0xFF);
      }

      if (i == 0) {
         DbgPrint("NULL (%08X)\n", PDevExt->CurrentReadIrp
                  ->IoStatus.Status);
      }

      DbgPrint("\n\n");
   }
#endif
         //
         // Update the amount of chars left in the ring buffer
         //

         pReadIrp->IoStatus.Status = STATUS_SUCCESS;

         if (!setFirstStatus) {
            firstStatus = STATUS_SUCCESS;
            setFirstStatus = TRUE;
         }
      } else {
         //
         // The irp may be given to the buffering routine
         //

         USBSER_INIT_REFERENCE(pReadIrp);

         ACQUIRE_CANCEL_SPINLOCK(PDevExt, &oldIrql);

         //
         // Check to see if it needs to be cancelled
         //

         if (pReadIrp->Cancel) {
            RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

            pReadIrp->IoStatus.Status = STATUS_CANCELLED;
            pReadIrp->IoStatus.Information = 0;

            if (!setFirstStatus) {
               setFirstStatus = TRUE;
               firstStatus = STATUS_CANCELLED;
            }

            UsbSerGetNextIrp(&PDevExt->CurrentReadIrp, &PDevExt->ReadQueue,
                             &newIrp, TRUE, PDevExt);
            continue;

         } else {

            //
            // If we are supposed to crunch the read down to
            // one character, then update the read length
            // in the irp and truncate the number needed for
            // read down to one.  Note that if we are doing
            // this crunching, then the information must be
            // zero (or we would have completed above) and
            // the number needed for the read must still be
            /// equal to the read length.
            //

            if (crunchDownToOne) {
               PDevExt->NumberNeededForRead = 1;
               IoGetCurrentIrpStackLocation(pReadIrp)->Parameters.Read.Length
               = 1;
            }

            USBSER_SET_REFERENCE(pReadIrp, USBSER_REF_RXBUFFER);
            USBSER_SET_REFERENCE(pReadIrp, USBSER_REF_CANCEL);

            if (useTotalTimer) {
               USBSER_SET_REFERENCE(pReadIrp, USBSER_REF_TOTAL_TIMER);
               KeSetTimer(&PDevExt->ReadRequestTotalTimer, totalTime,
                          &PDevExt->TotalReadTimeoutDpc);
            }

            if (useIntervalTimer) {
               USBSER_SET_REFERENCE(pReadIrp, USBSER_REF_INT_TIMER);
               KeQuerySystemTime(&PDevExt->LastReadTime);

               KeSetTimer(&PDevExt->ReadRequestIntervalTimer,
                          *PDevExt->IntervalTimeToUse,
                          &PDevExt->IntervalReadTimeoutDpc);
            }

            //
            // Mark IRP as cancellable
            //

            IoSetCancelRoutine(pReadIrp, UsbSerCancelCurrentRead);

            IoMarkIrpPending(pReadIrp);

            RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

            if (!setFirstStatus) {
               firstStatus = STATUS_PENDING;
            }
         }
         DEBUG_LOG_PATH("Exit UsbSerStartRead (1)\n");
         UsbSerSerialDump(USBSERTRACERD, ("<UsbSerStartRead (1) %08X\n",
                                        firstStatus));
         return firstStatus;
      }

      UsbSerGetNextIrp(&PDevExt->CurrentReadIrp, &PDevExt->ReadQueue,
                       &newIrp, TRUE, PDevExt);
   } while (newIrp != NULL);


   DEBUG_LOG_PATH("Exit UsbSerStartRead (2)\n");
   UsbSerSerialDump(USBSERTRACERD, ("<UsbSerStartRead (2) %08X\n",
                    firstStatus));
   return firstStatus;
}


BOOLEAN
UsbSerGrabReadFromRx(IN PVOID Context)
/*++

Routine Description:

    This routine is used to grab (if possible) the irp from the
    read callback mechanism.  If it finds that the rx still owns the irp it
    grabs the irp away and also decrements the reference count on the irp since
    it no longer belongs to the rx routine.

    NOTE: This routine assumes that it is called with the cancel spin
          lock and/or control lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)Context;

    USBSER_ALWAYS_LOCKED_CODE();

    UsbSerSerialDump(USBSERTRACERD, ("Enter UsbSerGrabReadFromRx\n"));


    USBSER_CLEAR_REFERENCE(pDevExt->CurrentReadIrp, USBSER_REF_RXBUFFER);

    UsbSerSerialDump(USBSERTRACERD, ("Exit UsbSerGrabReadFromRx\n"));

    return FALSE;
}


VOID
UsbSerCancelCurrentRead(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)
/*++

Routine Description:

    This routine is used to cancel the current read.

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/
{

    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

    USBSER_ALWAYS_LOCKED_CODE();

    UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerCancelCurrentRead(%08X)\n",
                                      PIrp));

    //
    // We set this to indicate to the interval timer
    // that the read has encountered a cancel.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pDevExt->CountOnLastRead = SERIAL_COMPLETE_READ_CANCEL;


    //
    // HACKHACK
    //

    UsbSerGrabReadFromRx(pDevExt);

    UsbSerTryToCompleteCurrent(pDevExt, PIrp->CancelIrql, STATUS_CANCELLED,
                               &pDevExt->CurrentReadIrp, &pDevExt->ReadQueue,
                               &pDevExt->ReadRequestIntervalTimer,
                               &pDevExt->ReadRequestTotalTimer,
                               UsbSerStartRead, UsbSerGetNextIrp,
                               USBSER_REF_CANCEL, TRUE);
    UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerCancelCurrentRead\n"));

}


VOID
UsbSerReadTimeout(IN PKDPC PDpc, IN PVOID DeferredContext,
                  IN PVOID SystemContext1, IN PVOID SystemContext2)

/*++

Routine Description:

    This routine is used to complete a read because its total
    timer has expired.

Arguments:

    PDpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION pDevExt = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    USBSER_ALWAYS_LOCKED_CODE();

    UsbSerSerialDump(USBSERTRACETM, (">UsbSerReadTimeout\n"));

    ACQUIRE_CANCEL_SPINLOCK(pDevExt, &oldIrql);

    //
    // We set this to indicate to the interval timer
    // that the read has completed due to total timeout.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pDevExt->CountOnLastRead = SERIAL_COMPLETE_READ_TOTAL;

    //
    // HACKHACK
    //

    UsbSerGrabReadFromRx(pDevExt);

    UsbSerTryToCompleteCurrent(pDevExt, oldIrql, STATUS_TIMEOUT,
                               &pDevExt->CurrentReadIrp, &pDevExt->ReadQueue,
                               &pDevExt->ReadRequestIntervalTimer,
                               &pDevExt->ReadRequestTotalTimer, UsbSerStartRead,
                               UsbSerGetNextIrp, USBSER_REF_TOTAL_TIMER, TRUE);

    UsbSerSerialDump(USBSERTRACETM, ("<UsbSerReadTimeout\n"));
}


VOID
UsbSerIntervalReadTimeout(IN PKDPC PDpc, IN PVOID DeferredContext,
                          IN PVOID SystemContext1, IN PVOID SystemContext2)

/*++

Routine Description:

    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last the last time this routine was invoked (This dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is
    read.

Arguments:

    PDpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

   PDEVICE_EXTENSION pDevExt = DeferredContext;
   KIRQL oldIrql;
   KIRQL oldControlIrql;

   UNREFERENCED_PARAMETER(SystemContext1);
   UNREFERENCED_PARAMETER(SystemContext2);

   USBSER_ALWAYS_LOCKED_CODE();

   UsbSerSerialDump(USBSERTRACETM, (">UsbSerIntervalReadTimeout "));

   ACQUIRE_CANCEL_SPINLOCK(pDevExt, &oldIrql);


   if (pDevExt->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL) {
      UsbSerSerialDump(USBSERTRACETM, ("SERIAL_COMPLETE_READ_TOTAL\n"));

      //
      // This value is only set by the total
      // timer to indicate that it has fired.
      // If so, then we should simply try to complete.
      //

      //
      // HACKHACK
      //
      ACQUIRE_SPINLOCK(pDevExt, &pDevExt->ControlLock, &oldControlIrql);
      UsbSerGrabReadFromRx(pDevExt);
      pDevExt->CountOnLastRead = 0;
      RELEASE_SPINLOCK(pDevExt, &pDevExt->ControlLock, oldControlIrql);

      UsbSerTryToCompleteCurrent(pDevExt, oldIrql, STATUS_TIMEOUT,
                                 &pDevExt->CurrentReadIrp, &pDevExt->ReadQueue,
                                 &pDevExt->ReadRequestIntervalTimer,
                                 &pDevExt->ReadRequestTotalTimer,
                                 UsbSerStartRead, UsbSerGetNextIrp,
                                 USBSER_REF_INT_TIMER, TRUE);

   } else if (pDevExt->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE) {
      UsbSerSerialDump(USBSERTRACETM, ("SERIAL_COMPLETE_READ_COMPLETE\n"));

      //
      // This value is only set by the regular
      // completion routine.
      //
      // If so, then we should simply try to complete.
      //

      //
      // HACKHACK
      //


      ACQUIRE_SPINLOCK(pDevExt, &pDevExt->ControlLock, &oldControlIrql);
      UsbSerGrabReadFromRx(pDevExt);
      pDevExt->CountOnLastRead = 0;
      RELEASE_SPINLOCK(pDevExt, &pDevExt->ControlLock, oldControlIrql);

      UsbSerTryToCompleteCurrent(pDevExt, oldIrql, STATUS_SUCCESS,
                                &pDevExt->CurrentReadIrp, &pDevExt->ReadQueue,
                                &pDevExt->ReadRequestIntervalTimer,
                                &pDevExt->ReadRequestTotalTimer,
                                UsbSerStartRead, UsbSerGetNextIrp,
                                USBSER_REF_INT_TIMER, TRUE);

   } else if (pDevExt->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL) {
      UsbSerSerialDump(USBSERTRACETM, ("SERIAL_COMPLETE_READ_CANCEL\n"));

      //
      // This value is only set by the cancel
      // read routine.
      //
      // If so, then we should simply try to complete.
      //


      //
      // HACKHACK
      //

      ACQUIRE_SPINLOCK(pDevExt, &pDevExt->ControlLock, &oldControlIrql);
      UsbSerGrabReadFromRx(pDevExt);
      pDevExt->CountOnLastRead = 0;
      RELEASE_SPINLOCK(pDevExt, &pDevExt->ControlLock, oldControlIrql);

      UsbSerTryToCompleteCurrent(pDevExt, oldIrql, STATUS_CANCELLED,
                                &pDevExt->CurrentReadIrp, &pDevExt->ReadQueue,
                                &pDevExt->ReadRequestIntervalTimer,
                                &pDevExt->ReadRequestTotalTimer,
                                UsbSerStartRead, UsbSerGetNextIrp,
                                USBSER_REF_INT_TIMER, TRUE);

   } else if (pDevExt->CountOnLastRead || pDevExt->ReadByIsr) {
      //
      // Something has happened since we last came here.  We
      // check to see if the ISR has read in any more characters.
      // If it did then we should update the isr's read count
      // and resubmit the timer.
      //

      if (pDevExt->ReadByIsr) {
         UsbSerSerialDump(USBSERTRACETM, ("ReadByIsr\n"));

         pDevExt->CountOnLastRead = pDevExt->ReadByIsr;
         pDevExt->ReadByIsr = 0;

         //
         // Save off the "last" time something was read.
         // As we come back to this routine we will compare
         // the current time to the "last" time.  If the
         // difference is ever larger then the interval
         // requested by the user, then time out the request.
         //

         KeQuerySystemTime(&pDevExt->LastReadTime);

         KeSetTimer(&pDevExt->ReadRequestIntervalTimer,
                    *pDevExt->IntervalTimeToUse,
                    &pDevExt->IntervalReadTimeoutDpc);

         RELEASE_CANCEL_SPINLOCK(pDevExt, oldIrql);

      } else {
         //
         // Take the difference between the current time
         // and the last time we had characters and
         // see if it is greater then the interval time.
         // if it is, then time out the request.  Otherwise
         // go away again for a while.
         //

         //
         // No characters read in the interval time.  Kill
         // this read.
         //

         LARGE_INTEGER currentTime;

         UsbSerSerialDump(USBSERTRACETM, ("TIMEOUT\n"));

         KeQuerySystemTime(&currentTime);

         if ((currentTime.QuadPart - pDevExt->LastReadTime.QuadPart) >=
             pDevExt->IntervalTime.QuadPart) {

            pDevExt->CountOnLastRead = pDevExt->ReadByIsr = 0;

            //
            // HACKHACK
            //

            ACQUIRE_SPINLOCK(pDevExt, &pDevExt->ControlLock, &oldControlIrql);
            UsbSerGrabReadFromRx(pDevExt);
            RELEASE_SPINLOCK(pDevExt, &pDevExt->ControlLock, oldControlIrql);

            UsbSerTryToCompleteCurrent(pDevExt, oldIrql, STATUS_TIMEOUT,
                                       &pDevExt->CurrentReadIrp,
                                       &pDevExt->ReadQueue,
                                       &pDevExt->ReadRequestIntervalTimer,
                                       &pDevExt->ReadRequestTotalTimer,
                                       UsbSerStartRead, UsbSerGetNextIrp,
                                       USBSER_REF_INT_TIMER, TRUE);

         } else {
            KeSetTimer(&pDevExt->ReadRequestIntervalTimer,
                       *pDevExt->IntervalTimeToUse,
                       &pDevExt->IntervalReadTimeoutDpc);

            RELEASE_CANCEL_SPINLOCK(pDevExt, oldIrql);
         }
      }
   } else {
      //
      // Timer doesn't really start until the first character.
      // So we should simply resubmit ourselves.
      //

      UsbSerSerialDump(USBSERTRACETM, ("-\n"));

      KeSetTimer(&pDevExt->ReadRequestIntervalTimer,
                 *pDevExt->IntervalTimeToUse, &pDevExt->IntervalReadTimeoutDpc);

      RELEASE_CANCEL_SPINLOCK(pDevExt, oldIrql);
   }

   UsbSerSerialDump(USBSERTRACETM, ("<UsbSerIntervalReadTimeout\n"));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\serioctl.h ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

   SERIOCTL.H

Abstract:

   Header file for routines to handle serial IOCTLs for Legacy USB Modem Driver

Environment:

   kernel mode only

Notes:

   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
   KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
   PURPOSE.

   Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

   12/27/97 : created

Authors:

   Tom Green


****************************************************************************/


#ifndef __SERIOCTL_H__
#define __SERIOCTL_H__


// prototypes

NTSTATUS
SetBaudRate(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj);

NTSTATUS
GetBaudRate(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj);

NTSTATUS
SetLineControl(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj);

NTSTATUS
GetLineControl(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj);

NTSTATUS
SetTimeouts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetTimeouts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
SetChars(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetChars(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
SetClrDtr(IN PDEVICE_OBJECT PDevObj, IN BOOLEAN Set);

NTSTATUS
ResetDevice(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj);

NTSTATUS
SetRts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
ClrRts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
SetBreak(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj, IN USHORT Time);

NTSTATUS
SetQueueSize(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetWaitMask(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
SetWaitMask(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
WaitOnMask(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
ImmediateChar(IN PIRP Irp, IN PDEVICE_OBJECT DeviceObject);

NTSTATUS
Purge(IN PDEVICE_OBJECT PDevObj, IN PIRP Irp,
      IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetHandflow(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
SetHandflow(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetModemStatus(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetDtrRts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetCommStatus(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetProperties(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
LsrmstInsert(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
ConfigSize(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
GetStats(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
ClearStats(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension);

VOID
SerialGetProperties(IN PDEVICE_EXTENSION DeviceExtension,
               IN PSERIAL_COMMPROP Properties);

NTSTATUS
GetLineControlAndBaud(IN PDEVICE_OBJECT PDevObj);

NTSTATUS
SetLineControlAndBaud(IN PDEVICE_OBJECT PDevObj);

NTSTATUS
NotifyCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);

#endif // __SERIOCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\serioctl.c ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

        SERIOCTL.C

Abstract:

        Routines to handle serial IOCTLs for Legacy USB Modem Driver.

Environment:

        kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        12/27/97 : created

Authors:

        Tom Green


****************************************************************************/


#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "serioctl.h"
#include "utils.h"
#include "usbserpw.h"
#include "debugwdm.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEUSBS, SetBaudRate)
#pragma alloc_text(PAGEUSBS, GetBaudRate)
#pragma alloc_text(PAGEUSBS, SetLineControl)
#pragma alloc_text(PAGEUSBS, GetLineControl)
#pragma alloc_text(PAGEUSBS, SetTimeouts)
#pragma alloc_text(PAGEUSBS, GetTimeouts)
#pragma alloc_text(PAGEUSBS, SetChars)
#pragma alloc_text(PAGEUSBS, GetChars)
#pragma alloc_text(PAGEUSBS, SetClrDtr)
#pragma alloc_text(PAGEUSBS, ResetDevice)
#pragma alloc_text(PAGEUSBS, SetRts)
#pragma alloc_text(PAGEUSBS, ClrRts)
#pragma alloc_text(PAGEUSBS, SetBreak)
#pragma alloc_text(PAGEUSBS, SetQueueSize)
#pragma alloc_text(PAGEUSBS, GetWaitMask)
#pragma alloc_text(PAGEUSBS, SetWaitMask)
#pragma alloc_text(PAGEUSBS, WaitOnMask)
#pragma alloc_text(PAGEUSBS, ImmediateChar)
#pragma alloc_text(PAGEUSBS, Purge)
#pragma alloc_text(PAGEUSBS, GetHandflow)
#pragma alloc_text(PAGEUSBS, SetHandflow)
#pragma alloc_text(PAGEUSBS, GetModemStatus)
#pragma alloc_text(PAGEUSBS, GetDtrRts)
#pragma alloc_text(PAGEUSBS, GetCommStatus)
#pragma alloc_text(PAGEUSBS, GetProperties)
#pragma alloc_text(PAGEUSBS, LsrmstInsert)
#pragma alloc_text(PAGEUSBS, ConfigSize)
#pragma alloc_text(PAGEUSBS, GetStats)
#pragma alloc_text(PAGEUSBS, ClearStats)
#pragma alloc_text(PAGEUSBS, SerialGetProperties)
#endif // ALLOC_PRAGMA


LOCAL UCHAR StopBits[] =
{
        STOP_BIT_1,                     // USB_COMM_STOPBITS_10
        STOP_BITS_1_5,                  // USB_COMM_STOPBITS_15
        STOP_BITS_2                     // USB_COMM_STOPBITS_20
};

LOCAL UCHAR ParityType[] =
{
        NO_PARITY,                      // USB_COMM_PARITY_NONE
        ODD_PARITY,                     // USB_COMM_PARITY_ODD
        EVEN_PARITY,                    // USB_COMM_PARITY_EVEN
        MARK_PARITY,                    // USB_COMM_PARITY_MARK
        SPACE_PARITY                    // USB_COMM_PARITY_SPACE
};



/************************************************************************/
/* SetBaudRate                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_BAUD_RATE                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      PDevObj         - pointer to device object                      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetBaudRate(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj)
{
   PSERIAL_BAUD_RATE   Br = (PSERIAL_BAUD_RATE) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION  IrpStack;
   KIRQL               OldIrql;
   PDEVICE_EXTENSION   DeviceExtension = PDevObj->DeviceExtension;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter SetBaudRate");
   UsbSerSerialDump(USBSERTRACEIOC, (">SetBaudRate(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength
       < sizeof(SERIAL_BAUD_RATE)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
      DeviceExtension->CurrentBaud = Br->BaudRate;
      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      DEBUG_TRACE3(("BaudRate (%08X)\n", Br->BaudRate));

      NtStatus = SetLineControlAndBaud(PDevObj);

   }

   DEBUG_LOG_PATH("exit  SetBaudRate");
   UsbSerSerialDump(USBSERTRACEIOC, ("<SetBaudRate %08X\n", NtStatus));

   return NtStatus;
} // SetBaudRate


/************************************************************************/
/* GetBaudRate                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_BAUD_RATE                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      PDevObj         - pointer to device object                      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetBaudRate(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj)
{
   PSERIAL_BAUD_RATE   Br = (PSERIAL_BAUD_RATE) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   KIRQL               OldIrql;
   PIO_STACK_LOCATION  IrpStack;
   PDEVICE_EXTENSION   DeviceExtension = PDevObj->DeviceExtension;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter GetBaudRate");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetBaudRate(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(SERIAL_BAUD_RATE)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      GetLineControlAndBaud(PDevObj);

      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      Br->BaudRate = DeviceExtension->CurrentBaud;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      Irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);
   }

   DEBUG_LOG_PATH("exit  GetBaudRate");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetBaudRate %08X\n", NtStatus));

   return NtStatus;
} // GetBaudRate


/************************************************************************/
/* SetLineControl                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_LINE_CONTROL                            */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      PDevObj         - pointer to device object                      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetLineControl(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj)
{
   PSERIAL_LINE_CONTROL    LineControl
      = (PSERIAL_LINE_CONTROL) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   KIRQL                   OldIrql;
   PIO_STACK_LOCATION      IrpStack;
   PDEVICE_EXTENSION       DeviceExtension = PDevObj->DeviceExtension;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter SetLineControl");
   UsbSerSerialDump(USBSERTRACEIOC, (">SetLineControl(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength
       < sizeof(SERIAL_LINE_CONTROL)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      DeviceExtension->LineControl = *LineControl;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      // set line control for USB modem
      NtStatus = SetLineControlAndBaud(PDevObj);
   }

   DEBUG_LOG_PATH("exit  SetLineControl");
   UsbSerSerialDump(USBSERTRACEIOC, ("<SetLineControl %08X\n", NtStatus));

   return NtStatus;
} // SetLineControl


/************************************************************************/
/* GetLineControl                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_LINE_CONTROL                            */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      PDevObj         - pointer to device object                      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetLineControl(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj)
{
        PSERIAL_LINE_CONTROL    LineControl =
           (PSERIAL_LINE_CONTROL) Irp->AssociatedIrp.SystemBuffer;
        NTSTATUS                NtStatus = STATUS_SUCCESS;
        KIRQL                   OldIrql;
        PIO_STACK_LOCATION      IrpStack;
        PDEVICE_EXTENSION       DeviceExtension = PDevObj->DeviceExtension;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter GetLineControl");
        UsbSerSerialDump(USBSERTRACEIOC, (">GetLineControl(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.OutputBufferLength
           < sizeof(SERIAL_LINE_CONTROL))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
                GetLineControlAndBaud(PDevObj);

                ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                *LineControl = DeviceExtension->LineControl;

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

                Irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);
        }

        DEBUG_LOG_PATH("exit  GetLineControl");
        UsbSerSerialDump(USBSERTRACEIOC, ("<GetLineControl %08X\n", NtStatus));

        return NtStatus;
} // GetLineControl



/************************************************************************/
/* SetTimeouts                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_TIMEOUTS                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetTimeouts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        PSERIAL_TIMEOUTS        Timeouts =
           (PSERIAL_TIMEOUTS) Irp->AssociatedIrp.SystemBuffer;
        NTSTATUS               NtStatus = STATUS_SUCCESS;
        KIRQL                  OldIrql;
        PIO_STACK_LOCATION      IrpStack;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter SetTimeouts");
        UsbSerSerialDump(USBSERTRACEIOC | USBSERTRACETM,
                         (">SetTimeouts(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.InputBufferLength
           < sizeof(SERIAL_TIMEOUTS))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
                ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                DeviceExtension->Timeouts = *Timeouts;

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
        }

        DEBUG_LOG_PATH("exit  SetTimeouts");
        UsbSerSerialDump(USBSERTRACEIOC | USBSERTRACETM, ("<SetTimeouts %08X\n",
                                                           NtStatus));

        return NtStatus;
} // SetTimeouts


/************************************************************************/
/* GetTimeouts                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_TIMEOUTS                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetTimeouts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        PSERIAL_TIMEOUTS        Timeouts =
           (PSERIAL_TIMEOUTS) Irp->AssociatedIrp.SystemBuffer;
        NTSTATUS                NtStatus = STATUS_SUCCESS;
        KIRQL                   OldIrql;
        PIO_STACK_LOCATION      IrpStack;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter GetTimeouts");
        UsbSerSerialDump(USBSERTRACEIOC | USBSERTRACETM,
                         (">GetTimeouts(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.OutputBufferLength
           < sizeof(SERIAL_TIMEOUTS))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
                ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                *Timeouts = DeviceExtension->Timeouts;

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

                Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);
        }

        DEBUG_LOG_PATH("exit  GetTimeouts");
        UsbSerSerialDump(USBSERTRACEIOC | USBSERTRACETM, ("<GetTimeouts %08X\n",
                                                           NtStatus));

        return NtStatus;
} // GetTimeouts


/************************************************************************/
/* SetChars                                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_CHARS                                   */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetChars(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        PSERIAL_CHARS           SpecialChars =
           (PSERIAL_CHARS) Irp->AssociatedIrp.SystemBuffer;
        NTSTATUS                NtStatus = STATUS_SUCCESS;
        KIRQL                   OldIrql;
        PIO_STACK_LOCATION      IrpStack;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter SetChars");
        UsbSerSerialDump(USBSERTRACEIOC, (">SetChars(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.InputBufferLength
           < sizeof(SERIAL_CHARS))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
                ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                DeviceExtension->SpecialChars = *SpecialChars;

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
        }

        DEBUG_LOG_PATH("exit  SetChars");
        UsbSerSerialDump(USBSERTRACEIOC, ("<SetChars %08X\n"));

        return NtStatus;
} // SetChars


/************************************************************************/
/* GetChars                                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_CHARS                                   */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetChars(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        PSERIAL_CHARS           SpecialChars =
           (PSERIAL_CHARS) Irp->AssociatedIrp.SystemBuffer;
        NTSTATUS                NtStatus = STATUS_SUCCESS;
        KIRQL                   OldIrql;
        PIO_STACK_LOCATION      IrpStack;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter GetChars");
        UsbSerSerialDump(USBSERTRACEIOC, (">GetChars(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.OutputBufferLength
           < sizeof(SERIAL_CHARS))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
                ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                *SpecialChars = DeviceExtension->SpecialChars;

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

                Irp->IoStatus.Information = sizeof(SERIAL_CHARS);
        }

        DEBUG_LOG_PATH("exit  GetChars");
        UsbSerSerialDump(USBSERTRACEIOC, ("<GetChars %08X\n", NtStatus));

        return NtStatus;
} // GetChars


/************************************************************************/
/* SetClrDtr                                                            */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_DTR and IOCTL_SERIAL_CLR_DTR            */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      PDevObj  - pointer to device object                             */
/*      Set - TRUE if setting DTR, FALSE if clearing DTR                */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetClrDtr(IN PDEVICE_OBJECT PDevObj, IN BOOLEAN Set)
{
        NTSTATUS                        NtStatus = STATUS_SUCCESS;
        KIRQL                           OldIrql;
        USHORT                          State = 0;
        PDEVICE_EXTENSION            DeviceExtension = PDevObj->DeviceExtension;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter SetClrDtr");
        UsbSerSerialDump(USBSERTRACEIOC, (">SetClrDtr\n"));

        ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

        if(DeviceExtension->DTRRTSState & SERIAL_RTS_STATE)
           State |= USB_COMM_RTS;

        if (Set) {
           DeviceExtension->DTRRTSState |= SERIAL_DTR_STATE;
           State |= USB_COMM_DTR;
        } else {
           DeviceExtension->DTRRTSState &= ~SERIAL_DTR_STATE;
        }

        RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

        if(DeviceExtension->DTRRTSState & SERIAL_RTS_STATE)
           State |= USB_COMM_RTS;

        NtStatus = ClassVendorCommand(PDevObj, USB_COMM_SET_CONTROL_LINE_STATE,
                                      State, DeviceExtension->CommInterface,
                                      NULL, NULL, FALSE, USBSER_CLASS_COMMAND);

        if(!NT_SUCCESS(NtStatus)) {
           ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
           DeviceExtension->DTRRTSState &= ~SERIAL_DTR_STATE;
           RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
        }

        DEBUG_LOG_PATH("exit  SetClrDtr");
        UsbSerSerialDump(USBSERTRACEIOC, ("<SetClrDtr %08X\n", NtStatus));

        return NtStatus;
} // SetClrDtr


/************************************************************************/
/* ResetDevice                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_RESET_DEVICE                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      PDevObj         - pointer to device object                      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ResetDevice(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj)
{
        NTSTATUS                        NtStatus = STATUS_SUCCESS;
        KIRQL                           OldIrql;
        PDEVICE_EXTENSION            DeviceExtension = PDevObj->DeviceExtension;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter ResetDevice");
        UsbSerSerialDump(USBSERTRACEIOC, (">ResetDevice(%08X)\n", Irp));

        // get line control and baud rate info
        GetLineControlAndBaud(PDevObj);

        ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

        // do device extension device specific stuff here
        DeviceExtension->SupportedBauds = SERIAL_BAUD_300 | SERIAL_BAUD_600
           | SERIAL_BAUD_1200 | SERIAL_BAUD_2400 | SERIAL_BAUD_4800
           | SERIAL_BAUD_9600 | SERIAL_BAUD_19200 | SERIAL_BAUD_38400
           | SERIAL_BAUD_57600  | SERIAL_BAUD_115200;

        RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

        DEBUG_LOG_PATH("exit  ResetDevice");
        UsbSerSerialDump(USBSERTRACEIOC, ("<ResetDevice %08X\n"));

        return NtStatus;
} // ResetDevice


/************************************************************************/
/* SetRts                                                               */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_RTS                                     */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetRts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        NTSTATUS                        NtStatus = STATUS_SUCCESS;
        KIRQL                           OldIrql;
        USHORT                          State = 0;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter SetRts");
        UsbSerSerialDump(USBSERTRACEIOC, (">SetRts(%08X)\n", Irp));

        ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
        DeviceExtension->DTRRTSState |= SERIAL_RTS_STATE;
        RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

        DEBUG_LOG_PATH("exit  SetRts");
        UsbSerSerialDump(USBSERTRACEIOC, ("<SetRts %08X\n", NtStatus));

        return NtStatus;
} // SetRts


/************************************************************************/
/* ClrRts                                                               */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_CLR_RTS                                     */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ClrRts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        NTSTATUS                        NtStatus = STATUS_SUCCESS;
        KIRQL                           OldIrql;
        USHORT                          State = 0;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter ClrRts");
        UsbSerSerialDump(USBSERTRACEIOC, (">ClrRts(%08X)\n", Irp));

        ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
        DeviceExtension->DTRRTSState &= ~SERIAL_RTS_STATE;
        RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

        DEBUG_LOG_PATH("exit  ClrRts");
        UsbSerSerialDump(USBSERTRACEIOC, ("<ClrRts %08X\n", NtStatus));

        return NtStatus;
} // ClrRts


/************************************************************************/
/* SetBreak                                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_BREAK_ON & IOCTL_SERIAL_SET_BREAK_OFF   */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      PDevObj         - pointer to device object                      */
/*      Time            - time to assert break in ms                    */
/*                        (0xFFFF - on / 0x0000 - off)                  */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetBreak(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj, USHORT Time)
{
        NTSTATUS                        NtStatus = STATUS_SUCCESS;
        PDEVICE_EXTENSION            DeviceExtension = PDevObj->DeviceExtension;

        USBSER_LOCKED_PAGED_CODE();

        DEBUG_LOG_PATH("enter SetBreak");
        UsbSerSerialDump(USBSERTRACEIOC, (">SetBreak(%08X)\n", Irp));

        NtStatus = ClassVendorCommand(PDevObj, USB_COMM_SEND_BREAK, Time,
                                      DeviceExtension->CommInterface, NULL,
                                      NULL, FALSE, USBSER_CLASS_COMMAND);

        DEBUG_LOG_PATH("exit  SetBreak");
        UsbSerSerialDump(USBSERTRACEIOC, ("<SetBreak %08X\n", NtStatus));

        return NtStatus;
} // SetBreak


/************************************************************************/
/* SetQueueSize                                                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_QUEUE_SIZE                              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetQueueSize(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        NTSTATUS           NtStatus = STATUS_SUCCESS;
        PIO_STACK_LOCATION IrpStack;
        PULONG             QueueSize = (PULONG) Irp->AssociatedIrp.SystemBuffer;

        DEBUG_LOG_PATH("enter SetQueueSize");
        UsbSerSerialDump(USBSERTRACEIOC, (">SetQueueSize(%08X)\n", Irp));

        USBSER_LOCKED_PAGED_CODE();

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.InputBufferLength
           < sizeof(ULONG))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
         DEBUG_TRACE1(("SetQueueSize (%08X)\n", *QueueSize));
                // we will go ahead and save this, but we don't care.
//                DeviceExtension->RxQueueSize = *QueueSize;
        }

        DEBUG_LOG_PATH("exit  SetQueueSize");
        UsbSerSerialDump(USBSERTRACEIOC, ("<SetQueueSize %08X\n", NtStatus));

        return NtStatus;
} // SetQueueSize


/************************************************************************/
/* GetWaitMask                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_WAIT_MASK                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetWaitMask(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        PULONG              WaitMask = (PULONG) Irp->AssociatedIrp.SystemBuffer;
        NTSTATUS            NtStatus = STATUS_SUCCESS;
        KIRQL               OldIrql;
        PIO_STACK_LOCATION  IrpStack;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter GetWaitMask");
        UsbSerSerialDump(USBSERTRACEIOC, (">GetWaitMask(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.OutputBufferLength
           < sizeof(ULONG))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
                ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                *WaitMask = DeviceExtension->IsrWaitMask;

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

                Irp->IoStatus.Information = sizeof(ULONG);
        }

        DEBUG_LOG_PATH("exit  GetWaitMask");
        UsbSerSerialDump(USBSERTRACEIOC, ("<GetWaitMask %08X\n"));

        return NtStatus;
} // GetWaitMask


/************************************************************************/
/* SetWaitMask                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_WAIT_MASK                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetWaitMask(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PULONG                  WaitMask = (PULONG) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   KIRQL                   OldIrql;
   PIO_STACK_LOCATION      IrpStack;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter SetWaitMask");
   UsbSerSerialDump(USBSERTRACEIOC, (">SetWaitMask(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      // make sure it's a valid request
      if (*WaitMask & ~(       SERIAL_EV_RXCHAR   |
                               SERIAL_EV_RXFLAG   |
                               SERIAL_EV_TXEMPTY  |
                               SERIAL_EV_CTS      |
                               SERIAL_EV_DSR      |
                               SERIAL_EV_RLSD     |
                               SERIAL_EV_BREAK    |
                               SERIAL_EV_ERR      |
                               SERIAL_EV_RING     |
                               SERIAL_EV_PERR     |
                               SERIAL_EV_RX80FULL |
                               SERIAL_EV_EVENT1   |
                               SERIAL_EV_EVENT2)) {
         NtStatus = STATUS_INVALID_PARAMETER;
      } else {
         UsbSerCompletePendingWaitMasks(DeviceExtension);

         ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

         DeviceExtension->HistoryMask = 0;

         DeviceExtension->IsrWaitMask = *WaitMask;

         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

         DEBUG_TRACE3(("SetWaitMask (%08X)\n", *WaitMask));
      }
   }

   DEBUG_LOG_PATH("exit  SetWaitMask");
   UsbSerSerialDump(USBSERTRACEIOC, ("<SetWaitMask %08X\n", NtStatus));

   return NtStatus;
} // SetWaitMask


/************************************************************************/
/* WaitOnMask                                                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_WAIT_ON_MASK                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
WaitOnMask(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PULONG              WaitMask = (PULONG) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   KIRQL               OldIrql;
   PIO_STACK_LOCATION  IrpStack;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter WaitOnMask");
   UsbSerSerialDump(USBSERTRACEIOC, (">WaitOnMask(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(ULONG)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {

      // if we have an event to report, just go ahead and return it
      if (DeviceExtension->HistoryMask) {
         ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

         *WaitMask = DeviceExtension->HistoryMask;
         DeviceExtension->HistoryMask = 0;

         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

         Irp->IoStatus.Information = sizeof(ULONG);

         UsbSerSerialDump(USBSERCOMPEV,
                          ("Completing maskirp(3) %08x\n",
                           *WaitMask));

         DEBUG_TRACE3(("Signal Event (%08X)\n", *WaitMask));
      } else {
         KIRQL cancelIrql;

         ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &cancelIrql);
         ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

         // just in case something comes in, we'll do a while loop
         while (DeviceExtension->CurrentMaskIrp) {
            PIRP pOldIrp;

            DEBUG_TRACE3(("Completing previous mask\n"));

            pOldIrp = DeviceExtension->CurrentMaskIrp;
            DeviceExtension->CurrentMaskIrp = NULL;

            pOldIrp->IoStatus.Status = STATUS_SUCCESS;
            IoSetCancelRoutine(pOldIrp, NULL);

            *WaitMask = 0;

            UsbSerSerialDump(USBSERCOMPEV,
                             ("Completing maskirp(4)\n"));

            //
            // Release locks, complete request, then
            // reacquire the locks
            //


            RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock,
                              OldIrql);

            RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);

            IoCompleteRequest(pOldIrp, IO_SERIAL_INCREMENT);

            ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &cancelIrql);
            ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock,
                              &OldIrql);
         }


         //
         // Check to see if it needs to be cancelled
         //

         if (Irp->Cancel) {

            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;
            RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

            RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);
         } else {
            IoSetCancelRoutine(Irp, UsbSerCancelWaitOnMask);
            NtStatus = Irp->IoStatus.Status = STATUS_PENDING;

            DeviceExtension->CurrentMaskIrp = Irp;

            IoMarkIrpPending(Irp);

         	RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

         	RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);
         	

         }

      }

   }

   DEBUG_LOG_PATH("exit  WaitOnMask");
   UsbSerSerialDump(USBSERTRACEIOC, ("<WaitOnMask %08X\n", NtStatus));

   return NtStatus;
} // WaitOnMask


/************************************************************************/
/* ImmediateChar                                                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_IMMEDIATE_CHAR                              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceObject    - pointer to device object                      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ImmediateChar(IN PIRP Irp, IN PDEVICE_OBJECT DeviceObject)
{
   PUCHAR                  Char = (PUCHAR) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION      IrpStack;

   USBSER_LOCKED_PAGED_CODE();

   DEBUG_LOG_PATH("enter ImmediateChar");
   UsbSerSerialDump(USBSERTRACEIOC, (">ImmediateChar(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      //
      // We just treat this as a write since we have no internal
      // data buffer.
      //

      IrpStack->Parameters.Write.Length = sizeof(UCHAR);

      NtStatus = UsbSer_Write(DeviceObject, Irp);
   }

   DEBUG_LOG_PATH("exit  ImmediateChar");
   UsbSerSerialDump(USBSERTRACEIOC, ("<ImmediateChar, %08X\n", NtStatus));

   return NtStatus;
} // ImmediateChar


/************************************************************************/
/* Purge                                                                */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_PURGE                                       */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
Purge(IN PDEVICE_OBJECT PDevObj, IN PIRP Irp,
      IN PDEVICE_EXTENSION DeviceExtension)
{
   ULONG                   Mask = *((PULONG) Irp->AssociatedIrp.SystemBuffer);
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION      IrpStack;
   KIRQL                   OldIrql;
   ULONG                   Count;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter Purge");
   UsbSerSerialDump(USBSERTRACEIOC, (">Purge(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      // make sure purge request is valid
      if ((!Mask) || (Mask & ( ~(      SERIAL_PURGE_TXABORT |
                                       SERIAL_PURGE_RXABORT |
                                       SERIAL_PURGE_TXCLEAR |
                                       SERIAL_PURGE_RXCLEAR)))) {
         NtStatus = STATUS_INVALID_PARAMETER;
      } else {
         if (Mask & SERIAL_PURGE_RXCLEAR) {
            ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

            Count = DeviceExtension->CharsInReadBuff;

            DeviceExtension->CharsInReadBuff        = 0;
            DeviceExtension->CurrentReadBuffPtr     = 0;

            RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

			if(Count)
			{
	            RestartRead(DeviceExtension);
	        }
         }

         if (Mask & SERIAL_PURGE_RXABORT) {
            UsbSerKillAllReadsOrWrites(PDevObj, &DeviceExtension->ReadQueue,
                                       &DeviceExtension->CurrentReadIrp);
         }

         if (Mask & SERIAL_PURGE_TXABORT) {
            //
            // DO NOTHING because USB owns the request.  However, it may
            // prove in practice that we will have to cancel the IRPs on behalf
            // of the caller.
         }
      }
   }

   DEBUG_LOG_PATH("exit  Purge");
   UsbSerSerialDump(USBSERTRACEIOC, ("<Purge %08X\n", NtStatus));

   return NtStatus;
} // Purge


/************************************************************************/
/* GetHandflow                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_HANDFLOW                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetHandflow(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PSERIAL_HANDFLOW    HandFlow
      = (PSERIAL_HANDFLOW) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   KIRQL               OldIrql;
   PIO_STACK_LOCATION  IrpStack;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter GetHandflow");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetHandFlow(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(SERIAL_HANDFLOW)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      *HandFlow = DeviceExtension->HandFlow;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      Irp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);
   }

   DEBUG_LOG_PATH("exit  GetHandflow");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetHandFlow %08X\n", NtStatus));

   return NtStatus;
} // GetHandflow


/************************************************************************/
/* SetHandflow                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_HANDFLOW                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetHandflow(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PSERIAL_HANDFLOW    HandFlow
      = (PSERIAL_HANDFLOW) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   KIRQL               OldIrql;
   PIO_STACK_LOCATION  IrpStack;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter SetHandflow");
   UsbSerSerialDump(USBSERTRACEIOC, (">SetHandFlow(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength
       < sizeof(SERIAL_HANDFLOW)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      DeviceExtension->HandFlow = *HandFlow;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      DEBUG_TRACE3(("ControlHandShake (%08X)\n",
                    DeviceExtension->HandFlow.ControlHandShake));

   }

   DEBUG_LOG_PATH("exit  SetHandflow");
   UsbSerSerialDump(USBSERTRACEIOC, ("<SetHandFlow %08X\n", NtStatus));

   return NtStatus;
} // SetHandflow

/************************************************************************/
/* GetModemStatus                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_MODEMSTATUS                             */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetModemStatus(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PULONG              ModemStatus = (PULONG) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION  IrpStack;
   KIRQL               OldIrql;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter GetModemStatus");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetModemStatus(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(ULONG)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {

      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      *ModemStatus = DeviceExtension->FakeModemStatus;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      Irp->IoStatus.Information = sizeof(ULONG);

      DEBUG_TRACE3(("ModemStatus (%08X)\n", *ModemStatus));
   }

   DEBUG_LOG_PATH("exit  GetModemStatus");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetModemStatus %08X\n", NtStatus));

   return NtStatus;
} // GetModemStatus


/************************************************************************/
/* GetDtrRts                                                            */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_DTRRTS                                  */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
   GetDtrRts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PULONG              ModemControl = (PULONG) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION  IrpStack;
   KIRQL               OldIrql;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter GetDtrRts");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetDtrRts(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(ULONG)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {

      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      *ModemControl = DeviceExtension->DTRRTSState;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      Irp->IoStatus.Information = sizeof(ULONG);
   }

   DEBUG_LOG_PATH("exit  GetDtrRts");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetDtrRts %08X\n", NtStatus));

   return NtStatus;
} // GetDtrRts


/************************************************************************/
/* GetCommStatus                                                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_COMMSTATUS                              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
   GetCommStatus(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PSERIAL_STATUS      SerialStatus
      = (PSERIAL_STATUS) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   KIRQL               OldIrql;
   PIO_STACK_LOCATION  IrpStack;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter GetCommStatus");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetCommStatus(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(SERIAL_STATUS)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      if (NT_SUCCESS(NtStatus)) {
         RtlZeroMemory(SerialStatus, sizeof(SERIAL_STATUS));

         ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
         SerialStatus->AmountInInQueue   = DeviceExtension->CharsInReadBuff;
         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

       DEBUG_TRACE2(("AmountInInQueue (%08X)\n", SerialStatus->AmountInInQueue));

         SerialStatus->Errors            = 0;
         SerialStatus->EofReceived       = FALSE;
         SerialStatus->AmountInOutQueue  = 0;
         SerialStatus->WaitForImmediate  = 0;
         SerialStatus->HoldReasons       = 0;

         Irp->IoStatus.Information = sizeof(SERIAL_STATUS);
      }
   }

   DEBUG_LOG_PATH("exit  GetCommStatus");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetCommStatus %08X\n", NtStatus));

   return NtStatus;
} // GetCommStatus


/************************************************************************/
/* GetProperties                                                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_PROPERTIES                              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetProperties(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION      IrpStack;

   USBSER_LOCKED_PAGED_CODE();

   DEBUG_LOG_PATH("enter GetProperties");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetProperties(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(SERIAL_COMMPROP)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      SerialGetProperties(DeviceExtension,
                          (PSERIAL_COMMPROP)Irp->AssociatedIrp.SystemBuffer);

      Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
   }

   DEBUG_LOG_PATH("exit  GetProperties");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetProperties %08X\n", NtStatus));

   return NtStatus;
} // GetProperties


/************************************************************************/
/* LsrmstInsert                                                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_LSRMST_INSERT                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
LsrmstInsert(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        USBSER_LOCKED_PAGED_CODE();

        DEBUG_LOG_PATH("enter LsrmstInsert");

        UsbSerSerialDump(USBSERTRACEIOC, (">LsrmstInsert(%08X)\n", Irp));

        UsbSerSerialDump(USBSERTRACEIOC, ("<LsrmstInsert (%08X)\n",
                                          STATUS_NOT_SUPPORTED));

        return STATUS_NOT_SUPPORTED;

} // LsrmstInsert


/************************************************************************/
/* ConfigSize                                                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_CONFIG_SIZE                                 */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ConfigSize(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PULONG               ConfigSize = (PULONG) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS             NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION   IrpStack;

   USBSER_LOCKED_PAGED_CODE();

   DEBUG_LOG_PATH("enter ConfigSize");
   UsbSerSerialDump(USBSERTRACEIOC, (">ConfigSize(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(ULONG)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      *ConfigSize = 0;

      Irp->IoStatus.Information = sizeof(ULONG);
   }

   DEBUG_LOG_PATH("exit  ConfigSize");
   UsbSerSerialDump(USBSERTRACEIOC, ("<ConfigSize %08X\n", NtStatus));

   return NtStatus;
} // ConfigSize


/************************************************************************/
/* GetStats                                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_STATS                                   */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetStats(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PSERIALPERF_STATS   Stats
      = (PSERIALPERF_STATS) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   KIRQL               OldIrql;
   PIO_STACK_LOCATION  IrpStack;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter GetStats");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetStats(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(SERIALPERF_STATS)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      *Stats = DeviceExtension->PerfStats;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      Irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
   }

   DEBUG_LOG_PATH("exit  GetStats");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetStats %08X\n", NtStatus));

   return NtStatus;
} // GetStats


/************************************************************************/
/* ClearStats                                                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_CLEAR_STATS                                 */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ClearStats(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        NTSTATUS                        NtStatus = STATUS_SUCCESS;
        KIRQL                           OldIrql;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter ClearStats");
        UsbSerSerialDump(USBSERTRACEIOC, (">ClearStats(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

        RtlZeroMemory(&DeviceExtension->PerfStats,
                                  sizeof(SERIALPERF_STATS));

        RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

        DEBUG_LOG_PATH("exit  ClearStats");
        UsbSerSerialDump(USBSERTRACEIOC, ("<ClearStats %08X\n", NtStatus));

        return NtStatus;
} // ClearStats


/************************************************************************/
/* SerialGetProperties                                                  */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Get serial device properties                                    */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to device extension                   */
/*      Properties      - pointer to device properties to fill in       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
SerialGetProperties(IN PDEVICE_EXTENSION DeviceExtension,
                    IN PSERIAL_COMMPROP Properties)
{
   KIRQL OldIrql;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter SerialGetProperties");
   UsbSerSerialDump(USBSERTRACEIOC, (">SerialGetProperties\n"));



   RtlZeroMemory(Properties, sizeof(SERIAL_COMMPROP));

   Properties->PacketLength   = sizeof(SERIAL_COMMPROP);
   Properties->PacketVersion  = 2;
   Properties->ServiceMask    = SERIAL_SP_SERIALCOMM;
   Properties->MaxTxQueue     = 0;
   Properties->MaxRxQueue     = 0;
   Properties->MaxBaud        = SERIAL_BAUD_USER;
   Properties->ProvSubType    = SERIAL_SP_MODEM;

   Properties->ProvCapabilities = SERIAL_PCF_DTRDSR | SERIAL_PCF_CD
      | SERIAL_PCF_PARITY_CHECK | SERIAL_PCF_TOTALTIMEOUTS
      | SERIAL_PCF_INTTIMEOUTS;

   Properties->SettableParams = SERIAL_SP_PARITY | SERIAL_SP_BAUD
      | SERIAL_SP_DATABITS | SERIAL_SP_STOPBITS | SERIAL_SP_HANDSHAKING
      | SERIAL_SP_PARITY_CHECK | SERIAL_SP_CARRIER_DETECT;


   Properties->SettableData  = SERIAL_DATABITS_7 | SERIAL_DATABITS_8;

   Properties->SettableStopParity  = SERIAL_STOPBITS_10 | SERIAL_PARITY_NONE
      | SERIAL_PARITY_ODD  | SERIAL_PARITY_EVEN | SERIAL_PARITY_MARK
      | SERIAL_PARITY_SPACE;

   Properties->CurrentTxQueue = 0;

   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   Properties->CurrentRxQueue = DeviceExtension->RxQueueSize;
   Properties->SettableBaud   = DeviceExtension->SupportedBauds;

   RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

   DEBUG_LOG_PATH("exit  SerialGetProperties");
   UsbSerSerialDump(USBSERTRACEIOC, ("<SerialGetProperties\n"));

} // SerialGetProperties


/************************************************************************/
/* GetLineControlAndBaud                                                */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      CDC command to get line control settings and baud               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      PDevObj - pointer to device object                              */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
   GetLineControlAndBaud(IN PDEVICE_OBJECT PDevObj)
{
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   USB_COMM_LINE_CODING    LineCoding;
   ULONG                   Size = sizeof(LineCoding);
   KIRQL                   OldIrql;
   PDEVICE_EXTENSION       DeviceExtension = PDevObj->DeviceExtension;

   DEBUG_LOG_PATH("enter GetLineControlAndBaud");

   NtStatus = ClassVendorCommand(PDevObj, USB_COMM_GET_LINE_CODING, 0,
                                 DeviceExtension->CommInterface,
                                 &LineCoding, &Size, TRUE,
                                 USBSER_CLASS_COMMAND);

   if (NT_SUCCESS(NtStatus)) {
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      DeviceExtension->CurrentBaud = LineCoding.DTERate;
      DeviceExtension->LineControl.StopBits = StopBits[LineCoding.CharFormat];
      DeviceExtension->LineControl.Parity = ParityType[LineCoding.ParityType];
      DeviceExtension->LineControl.WordLength = LineCoding.DataBits;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      DEBUG_TRACE3(("Baud (%08X)  StopBits (%08X)  DataBits (%08X)\n",
                    LineCoding.DTERate, LineCoding.CharFormat,
                    LineCoding.DataBits));
   }

   DEBUG_LOG_PATH("exit  GetLineControlAndBaud");

   return NtStatus;
} // GetLineControlAndBaud


/************************************************************************/
/* SetLineControlAndBaud                                                */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      CDC command to set line control and baud                        */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      PDevObj - pointer to device object                              */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
   SetLineControlAndBaud(IN PDEVICE_OBJECT PDevObj)
{
   NTSTATUS                        NtStatus = STATUS_SUCCESS;
   USB_COMM_LINE_CODING            LineCoding;
   ULONG                           Size = sizeof(LineCoding);
   PSERIAL_LINE_CONTROL            LineControl;
   KIRQL                           OldIrql;
   PDEVICE_EXTENSION               DeviceExtension = PDevObj->DeviceExtension;

   DEBUG_LOG_PATH("enter SetLineControlAndBaud");

   // get pointer to line control in extension
   LineControl = &DeviceExtension->LineControl;

   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   // set up the line coding data structure
   LineCoding.DTERate  = DeviceExtension->CurrentBaud;
   LineCoding.DataBits = LineControl->WordLength;

   switch (DeviceExtension->LineControl.StopBits) {
   case STOP_BIT_1:
      LineCoding.CharFormat   = USB_COMM_STOPBITS_10;
      break;
   case STOP_BITS_1_5:
      LineCoding.CharFormat   = USB_COMM_STOPBITS_15;
      break;
   case STOP_BITS_2:
      LineCoding.CharFormat   = USB_COMM_STOPBITS_20;
      break;
   default:
      NtStatus = STATUS_INVALID_PARAMETER;
      break;
   }

   switch (DeviceExtension->LineControl.Parity) {
   case NO_PARITY:
      LineCoding.ParityType   = USB_COMM_PARITY_NONE;
      break;
   case ODD_PARITY:
      LineCoding.ParityType   = USB_COMM_PARITY_ODD;
      break;
   case EVEN_PARITY:
      LineCoding.ParityType   = USB_COMM_PARITY_EVEN;
      break;

   case MARK_PARITY:
      LineCoding.ParityType   = USB_COMM_PARITY_MARK;
      break;
   case SPACE_PARITY:
      LineCoding.ParityType   = USB_COMM_PARITY_SPACE;
      break;
   default:
      NtStatus = STATUS_INVALID_PARAMETER;
      break;
   }

   RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

   // the request must be valid, so send it down to the device
   if (NT_SUCCESS(NtStatus)) {
      NtStatus = ClassVendorCommand(PDevObj, USB_COMM_SET_LINE_CODING, 0,
                                    DeviceExtension->CommInterface,
                                    &LineCoding, &Size, FALSE,
                                    USBSER_CLASS_COMMAND);
   }

   // let's go ahead and just grab this info again in case of an error
   GetLineControlAndBaud(PDevObj);

   DEBUG_LOG_PATH("exit  SetLineControlAndBaud");

   return NtStatus;
} // SetLineControlAndBaud


/************************************************************************/
/* NotifyCompletion                                                     */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Notify completion routine.                                      */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to Irp                                   */
/*      Context      - pointer to driver defined context                */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
NotifyCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
   PDEVICE_EXTENSION          DeviceExtension = (PDEVICE_EXTENSION) Context;
   PURB                       Urb;
   ULONG                      Count;
   KIRQL                      OldIrql;
   KIRQL                      cancelIrql;
   PUSB_COMM_SERIAL_STATUS    SerialState;
   USHORT                     ModemStatus;
   USHORT                     OldModemStatus;
   PIRP                       CurrentMaskIrp = NULL;
   BOOLEAN					  startRead = FALSE;

   DEBUG_LOG_PATH("enter NotifyCompletion");

   Urb = DeviceExtension->NotifyUrb;

   Count = Urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   SerialState = (PUSB_COMM_SERIAL_STATUS) DeviceExtension->NotificationBuff;

   // see if it is our notification
   if (SerialState->Notification == USB_COMM_SERIAL_STATE
       && Count == sizeof(USB_COMM_SERIAL_STATUS)) {
      OldModemStatus = DeviceExtension->FakeModemStatus;

      // cobble up a fake modem status
      DeviceExtension->FakeModemStatus = SERIAL_MSR_CTS;
      DeviceExtension->FakeLineStatus  = 0;
      DeviceExtension->HistoryMask     = 0;


      ModemStatus = SerialState->SerialState;
      DeviceExtension->FakeLineStatus = 0;

      DEBUG_TRACE1(("CDC Serial State (%08X)\n", ModemStatus));

      if (ModemStatus & USB_COMM_DSR)
         DeviceExtension->FakeModemStatus        |= SERIAL_MSR_DSR;

      if (ModemStatus & USB_COMM_DCD)
         DeviceExtension->FakeModemStatus        |= SERIAL_MSR_DCD;

      if (ModemStatus & USB_COMM_RING)
         DeviceExtension->FakeModemStatus        |= SERIAL_MSR_RI;

      // let's see what has changed in the status register
      ModemStatus = OldModemStatus ^ DeviceExtension->FakeModemStatus;

      if (ModemStatus & SERIAL_MSR_DSR)
         DeviceExtension->HistoryMask            |= SERIAL_EV_DSR;

      if (ModemStatus & SERIAL_MSR_DCD)
         DeviceExtension->HistoryMask            |= SERIAL_EV_RLSD;

      if (ModemStatus & SERIAL_MSR_RI)
         DeviceExtension->HistoryMask            |= SERIAL_EV_RING;

      // see if we have any events we are waiting for
      DeviceExtension->HistoryMask &= DeviceExtension->IsrWaitMask;

      // update perf stats if we had any errors
      if (ModemStatus & USB_COMM_FRAMING_ERROR) {
         DeviceExtension->PerfStats.FrameErrorCount++;
         DeviceExtension->FakeLineStatus |= SERIAL_LSR_FE;
      }

      if (ModemStatus & USB_COMM_OVERRUN) {
         DeviceExtension->PerfStats.BufferOverrunErrorCount++;
         DeviceExtension->FakeLineStatus |= SERIAL_LSR_OE;
      }

      if (ModemStatus & USB_COMM_PARITY_ERROR) {
         DeviceExtension->PerfStats.ParityErrorCount++;
         DeviceExtension->FakeLineStatus |= SERIAL_LSR_PE;
      }

      if (ModemStatus & USB_COMM_BREAK) {
         DeviceExtension->FakeLineStatus |= SERIAL_LSR_BI;
      }

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &cancelIrql);
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      // let's see if we have any events to signal
      CurrentMaskIrp = DeviceExtension->CurrentMaskIrp;

      if (CurrentMaskIrp && DeviceExtension->HistoryMask) {
         *(PULONG) (CurrentMaskIrp->AssociatedIrp.SystemBuffer) =
            DeviceExtension->HistoryMask;

         CurrentMaskIrp->IoStatus.Status         = STATUS_SUCCESS;
         CurrentMaskIrp->IoStatus.Information    = sizeof(ULONG);

         DeviceExtension->CurrentMaskIrp         = NULL;

      } 
      else 
      {
         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
         RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);
      }
      DEBUG_TRACE1(("Modem Status (%08X)\n", DeviceExtension->FakeModemStatus));
   }
   else
   {
     RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
   }



   // complete the queued IRP if needed
   if (CurrentMaskIrp && DeviceExtension->HistoryMask
       && Irp->IoStatus.Status == STATUS_SUCCESS) 
   {
      
      //
      // We should still be holding cancel spin lock because
      // of above if()


      UsbSerSerialDump(USBSERCOMPEV, ("Completing maskirp (4) %08X\n",
                                      DeviceExtension->HistoryMask));

      DeviceExtension->HistoryMask = 0;

      IoSetCancelRoutine(CurrentMaskIrp, NULL);

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
      RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);

      IoCompleteRequest(CurrentMaskIrp, IO_NO_INCREMENT);
      
   } 
 
   // check for Irp cancelled or error
   if(Irp->IoStatus.Status == STATUS_CANCELLED) 
   {
      goto NotifyCompletionErr;
   }
   else if(!NT_SUCCESS(Irp->IoStatus.Status)) 
   {
      UsbSerFetchBooleanLocked(&DeviceExtension->AcceptingRequests,
                               FALSE, &DeviceExtension->ControlLock);
      goto NotifyCompletionErr;
   }


   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   // kick off another notification request if we still need to
   if (DeviceExtension->AcceptingRequests
       && (DeviceExtension->CurrentDevicePowerState == PowerDeviceD0)) 
   {
	  // see if we have a work item queued already
      if(DeviceExtension->IoWorkItem == NULL)
      {
      	  startRead = TRUE;
      	  
	  	  // kick off another read
      	  DeviceExtension->IoWorkItem = IoAllocateWorkItem(DeviceExtension->PhysDeviceObject);
      }

      if(startRead && DeviceExtension->IoWorkItem)
      {

         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      	 IoQueueWorkItem(DeviceExtension->IoWorkItem,
                         USBSER_RestartNotifyReadWorkItem,
                         CriticalWorkQueue,
                         DeviceExtension);
      }
	  else 
	  {
      	RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
   	  }

   } else {
      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
   }

NotifyCompletionErr:;

   //
   // Notify everyone if this is the last IRP and we aren't starting another read
   //

   if((InterlockedDecrement(&DeviceExtension->PendingNotifyCount) == 0)) 
   {
      UsbSerSerialDump(USBSERTRACERD, ("Notify pipe is empty\n"));
      
      if(!startRead)
      {
	      KeSetEvent(&DeviceExtension->PendingNotifyEvent, IO_NO_INCREMENT, FALSE);
	  }
   }


   DEBUG_LOG_PATH("exit  NotifyCompletion");

   return STATUS_MORE_PROCESSING_REQUIRED;
} // NotifyCompletion



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\usbcomm.h ===
/****************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

	USBCOMM.H

Abstract:

	USB Communication Class Header File

Environment:

	Kernel mode & user mode

Notes:

	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
	KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
	PURPOSE.

	Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

Revision History:

	12/23/97 : created

Author:

	Tom Green

****************************************************************************/


#ifndef   __USBCOMM_H__
#define   __USBCOMM_H__

#include <pshpack1.h>


// USB Communication Class Code
#define USB_COMM_COMMUNICATION_CLASS_CODE		0x0002

// USB Communication Class Code
#define USB_COMM_DATA_CLASS_CODE				0x000A

// USB Communication Class SubClass Codes
#define USB_COMM_SUBCLASS_RESERVED				0x0000
#define USB_COMM_SUBCLASS_DIRECT_LINE_CONTROL	0x0001
#define USB_COMM_SUBCLASS_ABSTRACT_CONTROL		0x0002
#define USB_COMM_SUBCLASS_TELEPHONE_CONTROL		0x0003

// USB Communication Class Control Protocol Codes
#define USB_COMM_PROTOCOL_RESERVED				0x0000
#define USB_COMM_PROTOCOL_V25TER				0x0001

// Direct Line Control Model defines
#define USB_COMM_SET_AUX_LINE_STATE				0x0010
#define USB_COMM_SET_HOOK_STATE					0x0011
#define USB_COMM_PULSE_SETUP					0x0012
#define USB_COMM_SEND_PULSE						0x0013
#define USB_COMM_SET_PULSE_TIME					0x0014
#define USB_COMM_RING_AUX_JACK					0x0015

// Direct Line Control Model Notification defines
#define USB_COMM_AUX_JACK_HOOK_STATE			0x0008
#define USB_COMM_RING_DETECT					0x0009


// Abstract Control Model defines
#define USB_COMM_SEND_ENCAPSULATED_COMMAND		0x0000
#define USB_COMM_GET_ENCAPSULATED_RESPONSE		0x0001
#define USB_COMM_SET_COMM_FEATURE				0x0002
#define USB_COMM_GET_COMM_FEATURE				0x0003
#define USB_COMM_CLEAR_COMM_FEATURE				0x0004
#define USB_COMM_SET_LINE_CODING				0x0020
#define USB_COMM_GET_LINE_CODING				0x0021
#define USB_COMM_SET_CONTROL_LINE_STATE			0x0022
#define USB_COMM_SEND_BREAK						0x0023

// Abstract Control Model Notification defines
#define USB_COMM_NETWORK_CONNECTION				0x0000
#define USB_COMM_RESPONSE_AVAILABLE				0x0001
#define USB_COMM_SERIAL_STATE					0x0020


// Telephone Control Model defines
#define USB_COMM_SET_RINGER_PARMS				0x0030
#define USB_COMM_GET_RINGER_PARMS				0x0031
#define USB_COMM_SET_OPERATION_PARMS			0x0032
#define USB_COMM_GET_OPERATION_PARMS			0x0033
#define USB_COMM_SET_LINE_PARMS					0x0034
#define USB_COMM_GET_LINE_PARMS					0x0035
#define USB_COMM_DIAL_DIGITS					0x0036

// Telephone Control Model Notification defines
#define USB_COMM_CALL_STATE_CHANGE				0x0028
#define USB_COMM_LINE_STATE_CHANGE				0x0029


// Descriptor type for Functional Descriptors
#define	USB_COMM_CS_INTERFACE					0x0024
#define USB_COMM_CS_ENDPOINT					0x0025


// Communication Feature Selector Codes
#define USB_COMM_ABSTRACT_STATE					0x0001
#define USB_COMM_COUNTRY_SETTING				0x0002

// POTS Relay Configuration Values
#define USB_COMM_ON_HOOK						0x0000
#define USB_COMM_OFF_HOOK						0x0001
#define USB_COMM_SNOOPING						0x0002


// Operation Mode Values
#define USB_COMM_SIMPLE_MODE					0x0000
#define USB_COMM_STANDALONE_MODE				0x0001
#define USB_COMM_COMPUTER_CENTRIC_MODE			0x0002


// Line State Change Values for SET_LINE_PARMS
#define USB_COMM_DROP_ACTIVE_CALL				0x0000
#define USB_COMM_START_NEW_CALL					0x0001
#define USB_COMM_APPLY_RINGING					0x0002
#define USB_COMM_REMOVE_RINGING					0x0003
#define USB_COMM_SWITCH_TO_SPECIFIC_CALL		0x0004


// Call State Values for GET_LINE_PARMS
#define USB_COMM_CALL_IDLE						0x0000
#define USB_COMM_TYPICAL_DIAL_TONE				0x0001
#define USB_COMM_INTERRUPTED_DIAL_TONE			0x0002
#define USB_COMM_DIALING_IN_PROGRESS			0x0003
#define USB_COMM_RINGBACK						0x0004
#define USB_COMM_CONNECTED						0x0005
#define USB_COMM_INCOMING_CALL					0x0006


// Call State Change values for CALL_STATE_CHANGE
#define USB_COMM_CALL_RESERVED					0x0000
#define USB_COMM_CALL_CALL_HAS_BECOME_IDLE		0x0001
#define USB_COMM_CALL_DIALING					0x0002
#define USB_COMM_CALL_RINGBACK					0x0003
#define USB_COMM_CALL_CONNECTED					0x0004
#define USB_COMM_CALL_INCOMING_CALL				0x0005


// Line State Change Values for LINE_STATE_CHANGE
#define USB_COMM_LINE_LINE_HAS_BECOME_IDLE		0x0000
#define USB_COMM_LINE_LINE_HOLD_POSITION		0x0001
#define USB_COMM_LINE_HOOK_SWITCH_OFF			0x0002
#define USB_COMM_LINE_HOOK_SWITCH_ON			0x0003

// Line Coding Stop Bits
#define USB_COMM_STOPBITS_10					0x0000
#define USB_COMM_STOPBITS_15					0x0001
#define USB_COMM_STOPBITS_20					0x0002

// Line Coding Parity Type
#define USB_COMM_PARITY_NONE					0x0000
#define USB_COMM_PARITY_ODD						0x0001
#define USB_COMM_PARITY_EVEN					0x0002
#define USB_COMM_PARITY_MARK					0x0003
#define USB_COMM_PARITY_SPACE					0x0004


// Control Line State
#define USB_COMM_DTR							0x0001
#define USB_COMM_RTS							0x0002

// Serial State Notification bits
#define USB_COMM_DCD							0x0001
#define USB_COMM_DSR							0x0002
#define USB_COMM_BREAK							0x0004
#define USB_COMM_RING							0x0008
#define USB_COMM_FRAMING_ERROR					0x0010
#define USB_COMM_PARITY_ERROR					0x0020
#define USB_COMM_OVERRUN						0x0040



// Call Management Functional Descriptor

typedef struct _USB_COMM_CALL_MANAGEMENT_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
	UCHAR		DataInterface;
} USB_COMM_CALL_MANAGEMENT_FUNC_DESCR, *PUSB_COMM_CALL_MANAGEMENT_FUNC_DESCR;


// Abstract Control Management Functional Descriptor

typedef struct _USB_COMM_ABSTRACT_CONTROL_MANAGEMENT_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_ABSTRACT_CONTROL_MANAGEMENT_FUNC_DESCR, *PUSB_COMM_ABSTRACT_CONTROL_MANAGEMENT_FUNC_DESCR;


// Direct Line Management Functional Descriptor

typedef struct _USB_COMM_DIRECT_LINE_MANAGEMENT_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_DIRECT_LINE_MANAGEMENT_FUNC_DESCR, *PUSB_COMM_DIRECT_LINE_MANAGEMENT_FUNC_DESCR;


// Telephone Ringer Functional Descriptor

typedef struct _USB_COMM_TELEPHONE_RINGER_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		RingerVolSteps;
	UCHAR		NumRingerPatterns;
} USB_COMM_TELEPHONE_RINGER_FUNC_DESCR, *PUSB_COMM_TELEPHONE_RINGER_FUNC_DESCR;


// Telephone Operational Modes Functional Descriptor

typedef struct _USB_COMM_TELEPHONE_OPERATIONAL_MODES_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_TELEPHONE_OPERATIONAL_MODES_FUNC_DESCR, *PUSB_COMM_TELEPHONE_OPERATIONAL_MODES_FUNC_DESCR;


// Telephone Call and Line State Reporting Capabilities Descriptor

typedef struct _USB_COMM_TELEPHONE_CALL_LINE_STATE_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_TELEPHONE_CALL_LINE_STATE_DESCR, *PUSB_COMM_TELEPHONE_CALL_LINE_STATE_DESCR;


// Union Functional Descriptor

typedef struct _USB_COMM_UNION_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		MasterInterface;
	UCHAR		SlaveInterface;
} USB_COMM_UNION_FUNC_DESCR, *PUSB_COMM_UNION_FUNC_DESCR;


// Country Selection Functional Descriptor

typedef struct _USB_COMM_COUNTRY_SELECTION_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		CountryCodeRelDate;
	UCHAR		CountryCode;
} USB_COMM_COUNTRY_SELECTION_FUNC_DESCR, *PUSB_COMM_COUNTRY_SELECTION_FUNC_DESCR;


// Class Specific Interface Descriptor

typedef struct _USB_COMM_CLASS_SPECIFIC_INTERFACE_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		CDC;
} USB_COMM_CLASS_SPECIFIC_INTERFACE_DESCR, *PUSB_COMM_CLASS_SPECIFIC_INTERFACE_DESCR;


// Line Coding for GET_LINE_CODING and SET_LINE_CODING

typedef struct _USB_COMM_LINE_CODING
{
	ULONG		DTERate;
	UCHAR		CharFormat;
	UCHAR		ParityType;
	UCHAR		DataBits;
} USB_COMM_LINE_CODING, *PUSB_COMM_LINE_CODING;

// Line Status Information for GET_LINE_PARMS

typedef struct _USB_COMM_LINE_STATUS
{
	USHORT		Length;
	ULONG		RingerBitmap;
	ULONG		LineState;
	ULONG		CallState;
} USB_COMM_LINE_STATUS, *PUSB_COMM_LINE_STATUS;

// Serial Status Notification

typedef struct _USB_COMM_SERIAL_STATUS
{
	UCHAR		RequestType;
	UCHAR		Notification;
	USHORT		Value;
	USHORT		Index;
	USHORT		Length;
	USHORT		SerialState;
} USB_COMM_SERIAL_STATUS, *PUSB_COMM_SERIAL_STATUS;


#include <poppack.h>

#endif /*  __USBCOMM_H__ */    

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\usbser.c ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

        USBSER.C

Abstract:

        Main entry points for Legacy USB Modem Driver.
        All driver entry points here are called at

        IRQL = PASSIVE_LEVEL

Environment:

        kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        12/23/97 : created

Authors:

        Tom Green


****************************************************************************/

#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "usbserpw.h"
#include "serioctl.h"
#include "utils.h"
#include "debugwdm.h"

#ifdef ALLOC_PRAGMA

//
// INIT - only needed during init and then can be disposed
// PAGEUBS0 - always paged / never locked
// PAGEUSBS - must be locked when a device is open, else paged
//
//
// INIT is used for DriverEntry() specific code
//
// PAGEUBS0 is used for code that is not often called and has nothing
// to do with I/O performance.  An example, IRP_MJ_PNP/IRP_MN_START_DEVICE
// support functions
//
// PAGEUSBS is used for code that needs to be locked after an open for both
// performance and IRQL reasons.
//

#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGEUSBS0, UsbSer_Unload)
#pragma alloc_text(PAGEUSBS0, UsbSer_PnPAddDevice)
#pragma alloc_text(PAGEUSBS0, UsbSer_PnP)
#pragma alloc_text(PAGEUSBS0, UsbSerMajorNotSupported)

#ifdef WMI_SUPPORT
#pragma alloc_text(PAGEUSBS0, UsbSerSystemControlDispatch)
#pragma alloc_text(PAGEUSBS0, UsbSerTossWMIRequest)
#pragma alloc_text(PAGEUSBS0, UsbSerSetWmiDataItem)
#pragma alloc_text(PAGEUSBS0, UsbSerSetWmiDataBlock)
#pragma alloc_text(PAGEUSBS0, UsbSerQueryWmiDataBlock)
#pragma alloc_text(PAGEUSBS0, UsbSerQueryWmiRegInfo)
#else
#pragma alloc_text(PAGEUSBS0, UsbSer_SystemControl)
#endif

//
// PAGEUSBS is keyed off of UsbSer_Read, so UsbSer_Read must
// remain in PAGEUSBS for things to work properly
//

#pragma alloc_text(PAGEUSBS, UsbSer_Cleanup)
#pragma alloc_text(PAGEUSBS, UsbSer_Dispatch)
#pragma alloc_text(PAGEUSBS, UsbSer_Create)
#pragma alloc_text(PAGEUSBS, UsbSer_Close)

#endif // ALLOC_PRAGMA

UNICODE_STRING GlobalRegistryPath;

#ifdef WMI_SUPPORT

#define SERIAL_WMI_GUID_LIST_SIZE 1

#define WMI_SERIAL_PORT_NAME_INFORMATION 0

GUID SerialPortNameGuid = SERIAL_PORT_WMI_NAME_GUID;

WMIGUIDREGINFO SerialWmiGuidList[SERIAL_WMI_GUID_LIST_SIZE] =
{
    { &SerialPortNameGuid, 1, 0 }
};

#endif

/************************************************************************/
/* DriverEntry                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/* Installable driver initialization entry point.                       */
/* This entry point is called directly by the I/O system.               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DriverObject - pointer to the driver object                     */
/*                                                                      */
/*      RegistryPath - pointer to a unicode string representing the     */
/*                     path to driver-specific key in the registry      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
   NTSTATUS                NtStatus;

   PVOID lockPtr = MmLockPagableCodeSection(UsbSer_Read);

   PAGED_CODE();

   // setup debug trace level
#if 0
   Usbser_Debug_Trace_Level = 0;
#else
   Usbser_Debug_Trace_Level = 0;
#endif

   //
   // Serial portion

#if DBG
   UsbSerSerialDebugLevel = 0x00000000;
   PAGEUSBSER_Count = 0;
#else
   UsbSerSerialDebugLevel = 0;
#endif

   PAGEUSBSER_Handle = lockPtr;
   PAGEUSBSER_Function = UsbSer_Read;

   // Create dispatch points for device control, create, close, etc.

   DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
      UsbSer_Dispatch;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = UsbSer_Dispatch;
   DriverObject->MajorFunction[IRP_MJ_CREATE]          = UsbSer_Create;
   DriverObject->MajorFunction[IRP_MJ_CLOSE]           = UsbSer_Close;
   DriverObject->MajorFunction[IRP_MJ_WRITE]           = UsbSer_Write;
   DriverObject->MajorFunction[IRP_MJ_READ]            = UsbSer_Read;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP]         = UsbSer_Cleanup;
   DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]
                                                      = UsbSerMajorNotSupported;
   DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]
                                                      = UsbSerMajorNotSupported;
#ifdef WMI_SUPPORT
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = UsbSerSystemControlDispatch;
#else
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = UsbSer_SystemControl;
#endif

   DriverObject->MajorFunction[IRP_MJ_PNP]            = UsbSer_PnP;
   DriverObject->MajorFunction[IRP_MJ_POWER]          = UsbSer_ProcessPowerIrp;
   DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]  = UsbSerFlush;
   DriverObject->DriverExtension->AddDevice           = UsbSer_PnPAddDevice;
   DriverObject->DriverUnload                         = UsbSer_Unload;

   KeInitializeSpinLock(&GlobalSpinLock);

   GlobalRegistryPath.MaximumLength = RegistryPath->MaximumLength;
   GlobalRegistryPath.Length = RegistryPath->Length;
   GlobalRegistryPath.Buffer
      = DEBUG_MEMALLOC(PagedPool, GlobalRegistryPath.MaximumLength);

   if (GlobalRegistryPath.Buffer == NULL) 
   {
      MmUnlockPagableImageSection(lockPtr);
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(GlobalRegistryPath.Buffer,
                 GlobalRegistryPath.MaximumLength);
   RtlMoveMemory(GlobalRegistryPath.Buffer,
                 RegistryPath->Buffer, RegistryPath->Length);


   // initialize diagnostic stuff (history, tracing, error logging)

   strcpy(DriverName, "USBSER");
   strcpy(DriverVersion, "0.99");

   NtStatus = DEBUG_OPEN();

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  DriverEntry");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));

   //
   // Unlock pageable text
   //

   MmUnlockPagableImageSection(lockPtr);

   return NtStatus;
} // DriverEntry


/************************************************************************/
/* UsbSer_Dispatch                                                      */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Process the IRPs sent to this device. In this case IOCTLs and   */
/*  PNP IOCTLs                                                          */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
   NTSTATUS                NtStatus;
   PIO_STACK_LOCATION      IrpStack;
   PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
   PVOID                   IoBuffer;
   ULONG                   InputBufferLength;
   ULONG                   OutputBufferLength;
   ULONG                   IoControlCode;
   BOOLEAN                 NeedCompletion = TRUE;
   KIRQL oldIrql;

   USBSER_LOCKED_PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSer_Dispatch");

   // set return values to something known
   NtStatus = Irp->IoStatus.Status         = STATUS_SUCCESS;
   Irp->IoStatus.Information                       = 0;


   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &oldIrql);

   if (DeviceExtension->CurrentDevicePowerState != PowerDeviceD0) {
      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, oldIrql);

      NtStatus = Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);

      goto UsbSer_DispatchErr;
   }

   RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, oldIrql);

   // Get a pointer to the current location in the Irp. This is where
   // the function codes and parameters are located.
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   // Get the pointer to the input/output buffer and it's length
   IoBuffer                   = Irp->AssociatedIrp.SystemBuffer;
   InputBufferLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
   OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

   // make entry in IRP history table
   DEBUG_LOG_IRP_HIST(DeviceObject, Irp, IrpStack->MajorFunction, IoBuffer,
                      InputBufferLength);

   switch (IrpStack->MajorFunction) {
   case IRP_MJ_DEVICE_CONTROL:

      DEBUG_LOG_PATH("IRP_MJ_DEVICE_CONTROL");

      IoControlCode = IrpStack->Parameters.DeviceIoControl.IoControlCode;

      switch (IoControlCode) {
#ifdef PROFILING_ENABLED
      case GET_DRIVER_LOG:
         DEBUG_LOG_PATH("GET_DRIVER_LOG");

         // make sure we have a buffer length and a buffer
         if (!OutputBufferLength || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else {
            // make sure buffer contains null terminator
            ((PCHAR) IoBuffer)[0] = '\0';
            Irp->IoStatus.Information = Debug_DumpDriverLog(DeviceObject,
                                                            IoBuffer,
                                                            OutputBufferLength);
         }
         break;

      case GET_IRP_HIST:
         DEBUG_LOG_PATH("GET_IRP_HIST");

         // make sure we have a buffer length and a buffer
         if (!OutputBufferLength || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else {
            // make sure buffer contains null terminator
            ((PCHAR) IoBuffer)[0] = '\0';
            Irp->IoStatus.Information
               = Debug_ExtractIRPHist(IoBuffer, OutputBufferLength);
         }

         break;

      case GET_PATH_HIST:
         DEBUG_LOG_PATH("GET_PATH_HIST");

         // make sure we have a buffer length and a buffer
         if (!OutputBufferLength || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else {
            // make sure buffer contains null terminator
            ((PCHAR) IoBuffer)[0] = '\0';
            Irp->IoStatus.Information
               = Debug_ExtractPathHist(IoBuffer, OutputBufferLength);
         }

         break;

      case GET_ERROR_LOG:
         DEBUG_LOG_PATH("GET_ERROR_LOG");

         // make sure we have a buffer length and a buffer
         if (!OutputBufferLength || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else {
            // make sure buffer contains null terminator
            ((PCHAR) IoBuffer)[0] = '\0';
            Irp->IoStatus.Information
               = Debug_ExtractErrorLog(IoBuffer, OutputBufferLength);
         }

         break;

      case GET_ATTACHED_DEVICES:
         DEBUG_LOG_PATH("GET_ATTACHED_DEVICES");

         // make sure we have a buffer length and a buffer
         if (!OutputBufferLength || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else {
            // make sure buffer contains null terminator
            ((PCHAR) IoBuffer)[0] = '\0';
            Irp->IoStatus.Information
               = Debug_ExtractAttachedDevices(DeviceObject->DriverObject,
                                              IoBuffer, OutputBufferLength);
         }

         break;

      case GET_DRIVER_INFO:
         DEBUG_LOG_PATH("GET_DRIVER_INFO");

         // make sure we have a buffer length and a buffer
         if (!OutputBufferLength || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else {
            // make sure buffer contains null terminator
            ((PCHAR) IoBuffer)[0] = '\0';
            Irp->IoStatus.Information
               = Debug_GetDriverInfo(IoBuffer, OutputBufferLength);
         }

         break;

      case SET_IRP_HIST_SIZE:
         DEBUG_LOG_PATH("SET_IRP_HIST_SIZE");

         // make sure we have a correct buffer length and a buffer
         if (InputBufferLength != sizeof(ULONG) || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else
            NtStatus = Debug_SizeIRPHistoryTable(*((ULONG *) IoBuffer));
         break;

      case SET_PATH_HIST_SIZE:
         DEBUG_LOG_PATH("SET_PATH_HIST_SIZE");

         // make sure we have a correct buffer length and a buffer
         if (InputBufferLength != sizeof(ULONG) || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else
            NtStatus = Debug_SizeDebugPathHist(*((ULONG *) IoBuffer));
         break;

      case SET_ERROR_LOG_SIZE:
         DEBUG_LOG_PATH("SET_ERROR_LOG_SIZE");

         // make sure we have a correct buffer length and a buffer
         if (InputBufferLength != sizeof(long) || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else
            NtStatus = Debug_SizeErrorLog(*((ULONG *) IoBuffer));
         break;
#endif // PROFILING_ENABLED
      case ENABLE_PERF_TIMING:
         DEBUG_LOG_PATH("ENABLE_PERF_TIMING");

         // enable perf timing
         DeviceExtension->PerfTimerEnabled = TRUE;

         // reset BytesXfered, ElapsedTime and TimerStart
         DeviceExtension->BytesXfered   = RtlConvertUlongToLargeInteger(0L);
         DeviceExtension->ElapsedTime   = RtlConvertUlongToLargeInteger(0L);
         DeviceExtension->TimerStart    = RtlConvertUlongToLargeInteger(0L);

         break;

      case DISABLE_PERF_TIMING:
         DEBUG_LOG_PATH("DISABLE_PERF_TIMING");

         // disable perf timing
         DeviceExtension->PerfTimerEnabled = FALSE;
         break;

      case GET_PERF_DATA:
         DEBUG_LOG_PATH("GET_PERF_DATA");
         // make sure we have enough space to return perf info
         if (OutputBufferLength < sizeof(PERF_INFO) || !IoBuffer)
            NtStatus = Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
         else {
            PPERF_INFO      Perf = (PPERF_INFO) IoBuffer;

            Perf->PerfModeEnabled           = DeviceExtension->PerfTimerEnabled;
            Perf->BytesPerSecond            = BytesPerSecond(DeviceExtension);
            Irp->IoStatus.Information       = sizeof(PERF_INFO);
         }
         break;

      case SET_DEBUG_TRACE_LEVEL:
         // make sure we have a correct buffer length and a buffer
         if (InputBufferLength != sizeof(long) || !IoBuffer)
            NtStatus = STATUS_BUFFER_TOO_SMALL;
         else
            Usbser_Debug_Trace_Level = *((ULONG *) IoBuffer);
         break;

         // handle IOCTLs for a "serial" device
      case IOCTL_SERIAL_SET_BAUD_RATE:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_BAUD_RATE");
         NtStatus = SetBaudRate(Irp, DeviceObject);
         break;
      case IOCTL_SERIAL_GET_BAUD_RATE:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_BAUD_RATE");
         NtStatus = GetBaudRate(Irp, DeviceObject);
         break;
      case IOCTL_SERIAL_SET_LINE_CONTROL:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_LINE_CONTROL");
         NtStatus = SetLineControl(Irp, DeviceObject);
         break;
      case IOCTL_SERIAL_GET_LINE_CONTROL:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_LINE_CONTROL");
         NtStatus = GetLineControl(Irp, DeviceObject);
         break;
      case IOCTL_SERIAL_SET_TIMEOUTS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_TIMEOUTS");
         NtStatus = SetTimeouts(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_TIMEOUTS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_TIMEOUTS");
         NtStatus = GetTimeouts(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_SET_CHARS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_CHARS");
         NtStatus = SetChars(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_CHARS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_CHARS");
         NtStatus = GetChars(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_SET_DTR:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_DTR");
         NtStatus = SetClrDtr(DeviceObject, TRUE);
         break;
      case IOCTL_SERIAL_CLR_DTR:
         DEBUG_LOG_PATH("IOCTL_SERIAL_CLR_DTR");
         NtStatus = SetClrDtr(DeviceObject, FALSE);
         break;
      case IOCTL_SERIAL_RESET_DEVICE:
         DEBUG_LOG_PATH("IOCTL_SERIAL_RESET_DEVICE");
         NtStatus = ResetDevice(Irp, DeviceObject);
         break;
      case IOCTL_SERIAL_SET_RTS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_RTS");
         NtStatus = SetRts(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_CLR_RTS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_CLR_RTS");
         NtStatus = ClrRts(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_SET_BREAK_ON:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_BREAK_ON");
         NtStatus = SetBreak(Irp, DeviceObject, 0xFFFF);
         break;
      case IOCTL_SERIAL_SET_BREAK_OFF:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_BREAK_OFF");
         NtStatus = SetBreak(Irp, DeviceObject, 0);
         break;
      case IOCTL_SERIAL_SET_QUEUE_SIZE:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_QUEUE_SIZE");
         NtStatus = SetQueueSize(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_WAIT_MASK:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_WAIT_MASK");
         NtStatus = GetWaitMask(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_SET_WAIT_MASK:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_WAIT_MASK");
         NtStatus = SetWaitMask(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_WAIT_ON_MASK:
         DEBUG_LOG_PATH("IOCTL_SERIAL_WAIT_ON_MASK");
         NtStatus = WaitOnMask(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_IMMEDIATE_CHAR:
         DEBUG_LOG_PATH("IOCTL_SERIAL_IMMEDIATE_CHAR");

         NeedCompletion = FALSE;

         NtStatus = ImmediateChar(Irp, DeviceObject);

         if(NtStatus == STATUS_BUFFER_TOO_SMALL)
            NeedCompletion = TRUE;

         break;
      case IOCTL_SERIAL_PURGE:
         DEBUG_LOG_PATH("IOCTL_SERIAL_PURGE");
         NtStatus = Purge(DeviceObject, Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_HANDFLOW:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_HANDFLOW");
         NtStatus = GetHandflow(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_SET_HANDFLOW:
         DEBUG_LOG_PATH("IOCTL_SERIAL_SET_HANDFLOW");
         NtStatus = SetHandflow(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_MODEMSTATUS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_MODEMSTATUS");
         NtStatus = GetModemStatus(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_DTRRTS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_DTRRTS");
         NtStatus = GetDtrRts(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_COMMSTATUS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_COMMSTATUS");
         NtStatus = GetCommStatus(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_PROPERTIES:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_PROPERTIES");
         NtStatus = GetProperties(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_LSRMST_INSERT:
         DEBUG_LOG_PATH("IOCTL_SERIAL_LSRMST_INSERT");
         NtStatus = LsrmstInsert(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_CONFIG_SIZE:
         DEBUG_LOG_PATH("IOCTL_SERIAL_CONFIG_SIZE");
         NtStatus = ConfigSize(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_GET_STATS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_GET_STATS");
         NtStatus = GetStats(Irp, DeviceExtension);
         break;
      case IOCTL_SERIAL_CLEAR_STATS:
         DEBUG_LOG_PATH("IOCTL_SERIAL_CLEAR_STATS");
         NtStatus = ClearStats(Irp, DeviceExtension);
         break;

      default:
         NtStatus = STATUS_INVALID_PARAMETER;
      }
      break;

      // breaking out here will complete the Irp

   case IRP_MJ_INTERNAL_DEVICE_CONTROL:
      DEBUG_TRACE1(("IRP_MJ_INTERNAL_DEVICE_CONTROL\n"));

      switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) 
      {
      case IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE:
         DEBUG_TRACE1(("IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE\n"));

         DeviceExtension->SendWaitWake = TRUE;
         NtStatus = STATUS_SUCCESS;
         break;

      case IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE:

         DEBUG_TRACE1(("IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE\n"));
         DeviceExtension->SendWaitWake = FALSE;

         if (DeviceExtension->PendingWakeIrp != NULL) {
            IoCancelIrp(DeviceExtension->PendingWakeIrp);
         }

         NtStatus = STATUS_SUCCESS;
         break;

      default:

         // pass through to driver below

         DEBUG_LOG_PATH("IRP_MJ_INTERNAL_DEVICE_CONTROL");

         // since I dont have a completion routine use
         // IoCopyCurrentIrp

         IoCopyCurrentIrpStackLocationToNext(Irp);
         IoMarkIrpPending(Irp);
         NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject,
                                 Irp);

         DEBUG_TRACE3(("Passed PnP Irp down, NtStatus = %08X\n",
                       NtStatus));

         NeedCompletion = FALSE;
         break;
      }

   default:
      DEBUG_LOG_PATH("MAJOR IOCTL not handled");
      Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
      break;
   }


   if (NeedCompletion && NtStatus != STATUS_PENDING) {
      Irp->IoStatus.Status = NtStatus;

      CompleteIO(DeviceObject, Irp, IrpStack->MajorFunction,
                 IoBuffer, Irp->IoStatus.Information);
   }

UsbSer_DispatchErr:;

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  UsbSer_Dispatch");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));
   return NtStatus;
} // UsbSer_Dispatch


/************************************************************************/
/* UsbSer_Create                                                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Process the IRPs sent to this device for Create calls           */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_Create(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
   NTSTATUS                NtStatus;
   PIO_STACK_LOCATION      IrpStack;
   PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
   PVOID                   IoBuffer;
   ULONG                   InputBufferLength;
   KIRQL                   OldIrql;

   USBSER_LOCKED_PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSer_Create");

   DEBUG_TRACE1(("Open\n"));

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSer_Create(%08X)\n", Irp));

   // wakeup device from previous idle
   // UsbSerFdoRequestWake(DeviceExtension);

   // set return values to something known
   NtStatus = Irp->IoStatus.Status = STATUS_SUCCESS;
   Irp->IoStatus.Information       = 0;

   // Get a pointer to the current location in the Irp. This is where
   // the function codes and parameters are located.
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   // Get the pointer to the input/output buffer and it's length
   IoBuffer           = Irp->AssociatedIrp.SystemBuffer;
   InputBufferLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

   // make entry in IRP history table
   DEBUG_LOG_IRP_HIST(DeviceObject, Irp, IrpStack->MajorFunction, IoBuffer, 0);

   //
   // Serial devices do not allow multiple concurrent opens
   //

   if (InterlockedIncrement(&DeviceExtension->OpenCnt) != 1) {
      InterlockedDecrement(&DeviceExtension->OpenCnt);
      NtStatus = Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
      goto UsbSer_CreateErr;
   }

   //
   // Before we do anything, let's make sure they aren't trying
   // to create a directory.
   //

   if (IrpStack->Parameters.Create.Options & FILE_DIRECTORY_FILE) {
      InterlockedDecrement(&DeviceExtension->OpenCnt);
      NtStatus = Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
      Irp->IoStatus.Information = 0;
      goto UsbSer_CreateErr;
   }

   //
   // Lock down our code pages
   //

   PAGEUSBSER_Handle = UsbSerLockPagableCodeSection(UsbSer_Read);

   ASSERT(DeviceExtension->IsDevice);

   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   DeviceExtension->IsrWaitMask = 0;
   DeviceExtension->EscapeChar  = 0;

   RtlZeroMemory(&DeviceExtension->PerfStats, sizeof(SERIALPERF_STATS));

   //
   // Purge the RX buffer
   //

   DeviceExtension->CharsInReadBuff = 0;
   DeviceExtension->CurrentReadBuffPtr = 0;
   DeviceExtension->HistoryMask = 0;
   DeviceExtension->EscapeChar = 0;

   DeviceExtension->SendWaitWake = FALSE;

   RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

   //
   // Restart the read
   //

   RestartRead(DeviceExtension);

   UsbSer_CreateErr:;

   CompleteIO(DeviceObject, Irp, IrpStack->MajorFunction,
              IoBuffer, Irp->IoStatus.Information);

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  UsbSer_Create");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));
   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSer_Create %08X\n", NtStatus));

   return NtStatus;
} // UsbSer_Create


/************************************************************************/
/* UsbSer_Close                                                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Process the IRPs sent to this device for Close calls            */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_Close(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
   NTSTATUS                NtStatus;
   PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION      IrpStack;
   PVOID                   IoBuffer;
   ULONG                   InputBufferLength;
   ULONG                   openCount;


   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSer_Close");

   DEBUG_TRACE1(("Close\n"));

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSer_Close(%08X)\n", Irp));

   // set return values to something known
   NtStatus = Irp->IoStatus.Status         = STATUS_SUCCESS;
   Irp->IoStatus.Information                       = 0;

   // Get a pointer to the current location in the Irp. This is where
   // the function codes and parameters are located.
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   // Get the pointer to the input/output buffer and it's length
   IoBuffer           = Irp->AssociatedIrp.SystemBuffer;
   InputBufferLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

   // clear DTR, this is what the serial driver does
   SetClrDtr(DeviceObject, FALSE);

   //
   // Stop waiting for wakeup
   //

   DeviceExtension->SendWaitWake = FALSE;

   if (DeviceExtension->PendingWakeIrp != NULL) {
      IoCancelIrp(DeviceExtension->PendingWakeIrp);
   }

   // make entry in IRP history table
   DEBUG_LOG_IRP_HIST(DeviceObject, Irp, IrpStack->MajorFunction, IoBuffer, 0);

   ASSERT(DeviceExtension->IsDevice);

   openCount = InterlockedDecrement(&DeviceExtension->OpenCnt);

   ASSERT(openCount == 0);

   CompleteIO(DeviceObject, Irp, IrpStack->MajorFunction,
              IoBuffer, Irp->IoStatus.Information);

   // try and idle the modem
   // UsbSerFdoSubmitIdleRequestIrp(DeviceExtension);

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  UsbSer_Close");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));

   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSer_Close %08X\n", NtStatus));

   UsbSerUnlockPagableImageSection(PAGEUSBSER_Handle);

   return NtStatus;
} // UsbSer_Close


/************************************************************************/
/* UsbSer_Unload                                                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Process unloading driver                                        */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DriverObject - pointer to a driver object                       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
UsbSer_Unload(IN PDRIVER_OBJECT DriverObject)
{
        PAGED_CODE();

        DEBUG_LOG_PATH("enter UsbSer_Unload");

        // release global resources here
   		if(GlobalRegistryPath.Buffer != NULL) 
   		{
      		DEBUG_MEMFREE(GlobalRegistryPath.Buffer);
      		GlobalRegistryPath.Buffer = NULL;
   		}

        // shut down debugging and release resources
        DEBUG_CLOSE();

        DEBUG_LOG_PATH("exit  UsbSer_Unload");
} // UsbSer_Unload


/************************************************************************/
/* UsbSer_PnPAddDevice                                                  */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Attach new device to driver                                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DriverObject         - pointer to the driver object             */
/*                                                                      */
/*      PhysicalDeviceObject - pointer to the bus device object         */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_PnPAddDevice(IN PDRIVER_OBJECT DriverObject,
                    IN PDEVICE_OBJECT PhysicalDeviceObject)
{
   NTSTATUS             NtStatus;
   PDEVICE_OBJECT       DeviceObject = NULL;
   PDEVICE_EXTENSION    DeviceExtension;
   ULONG  Index;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSer_PnPAddDevice");


   NtStatus = CreateDeviceObject(DriverObject, &DeviceObject, DriverName);

   // make sure we have both a created device object and physical
   if ((DeviceObject != NULL)  && (PhysicalDeviceObject != NULL)) {
      DeviceExtension = DeviceObject->DeviceExtension;

      // Attach to the PDO
      DeviceExtension->StackDeviceObject =
         IoAttachDeviceToDeviceStack(DeviceObject, PhysicalDeviceObject);

      DEBUG_TRACE3(("StackDeviceObject (%08X)\n",
                    DeviceExtension->StackDeviceObject));

      // if we don't have a stack device object to attach to, bong it
      if (!DeviceExtension->StackDeviceObject) {
         IoDeleteDevice(DeviceObject);
         NtStatus = STATUS_NO_SUCH_DEVICE;
      } else {
         // do some device extension house keeping
         DeviceExtension->PerfTimerEnabled = FALSE;
         DeviceExtension->PhysDeviceObject = PhysicalDeviceObject;
         DeviceExtension->BytesXfered      = RtlConvertUlongToLargeInteger(0L);
         DeviceExtension->ElapsedTime      = RtlConvertUlongToLargeInteger(0L);
         DeviceExtension->TimerStart       = RtlConvertUlongToLargeInteger(0L);
         DeviceExtension->CurrentDevicePowerState = PowerDeviceD0;

         // init selective suspend stuff
         DeviceExtension->PendingIdleIrp   = NULL;
         DeviceExtension->IdleCallbackInfo = NULL;

         DeviceObject->StackSize = DeviceExtension->StackDeviceObject->StackSize
             + 1;

         // we support buffered io for read/write
         DeviceObject->Flags |= DO_BUFFERED_IO;

         // power mangement
         DeviceObject->Flags |= DO_POWER_PAGABLE;

         // we are done initializing the device object, so say so
         DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

         // get device capabilities
         UsbSerQueryCapabilities(DeviceExtension->StackDeviceObject,
                                 &DeviceExtension->DeviceCapabilities);

         // We want to determine what level to auto-powerdown to; This is the
         // lowest sleeping level that is LESS than D3;
         // If all are set to D3, auto powerdown/powerup will be disabled.

         // init to disabled
         DeviceExtension->PowerDownLevel = PowerDeviceUnspecified;

         for (Index = PowerSystemSleeping1; Index <= PowerSystemSleeping3;
              Index++) {

            if (DeviceExtension->DeviceCapabilities.DeviceState[Index]
                < PowerDeviceD3)
               DeviceExtension->PowerDownLevel
               = DeviceExtension->DeviceCapabilities.DeviceState[Index];
         }

#ifdef WMI_SUPPORT

         //
         // Register for WMI
         //

         DeviceExtension->WmiLibInfo.GuidCount = sizeof(SerialWmiGuidList) /
                                              sizeof(WMIGUIDREGINFO);
         DeviceExtension->WmiLibInfo.GuidList = SerialWmiGuidList;

         DeviceExtension->WmiLibInfo.QueryWmiRegInfo = UsbSerQueryWmiRegInfo;
         DeviceExtension->WmiLibInfo.QueryWmiDataBlock = UsbSerQueryWmiDataBlock;
         DeviceExtension->WmiLibInfo.SetWmiDataBlock = UsbSerSetWmiDataBlock;
         DeviceExtension->WmiLibInfo.SetWmiDataItem = UsbSerSetWmiDataItem;
         DeviceExtension->WmiLibInfo.ExecuteWmiMethod = NULL;
         DeviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

         IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_REGISTER);
#endif

      }
   }

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus); // init to disabled
   DEBUG_LOG_PATH("exit  UsbSer_PnPAddDevice");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));

   return NtStatus;
} // UsbSer_PnPAddDevice


/************************************************************************/
/* UsbSer_PnP                                                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      This routine will receive the various Plug N Play messages.  It */
/*      is here that we start our device, stop it, etc.                 */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_PnP(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{

   NTSTATUS                NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION      IrpStack;
   PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
   PVOID                   IoBuffer;
   ULONG                   InputBufferLength;
   BOOLEAN                 PassDown = TRUE;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSer_PnP");

   // Get a pointer to the current location in the Irp. This is where
   // the function codes and parameters are located.
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   // Get the pointer to the input/output buffer and it's length
   IoBuffer           = Irp->AssociatedIrp.SystemBuffer;
   InputBufferLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

   // make entry in IRP history table
   DEBUG_LOG_IRP_HIST(DeviceObject, Irp, IrpStack->MajorFunction, IoBuffer,
                      InputBufferLength);

   switch (IrpStack->MinorFunction) {

   case IRP_MN_START_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_START_DEVICE");

      NtStatus = StartDevice(DeviceObject, Irp);

      // passed Irp to driver below and completed in start device routine
      PassDown = FALSE;

      break;

   case IRP_MN_QUERY_REMOVE_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_QUERY_REMOVE_DEVICE");
      break;

   case IRP_MN_REMOVE_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_REMOVE_DEVICE");

#ifdef WMI_SUPPORT
      IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_DEREGISTER);
#endif

      NtStatus = RemoveDevice(DeviceObject, Irp);

      PassDown = FALSE;

      break;

   case IRP_MN_CANCEL_REMOVE_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_CANCEL_REMOVE_DEVICE");

      break;

   case IRP_MN_STOP_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_STOP_DEVICE");

      NtStatus = StopDevice(DeviceObject, Irp);

      break;


   case IRP_MN_QUERY_STOP_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_QUERY_STOP_DEVICE");
      break;

   case IRP_MN_CANCEL_STOP_DEVICE:
      DEBUG_LOG_PATH("IRP_MN_CANCEL_STOP_DEVICE");
      break;

   case IRP_MN_QUERY_DEVICE_RELATIONS:
      DEBUG_LOG_PATH("IRP_MN_QUERY_DEVICE_RELATIONS");
      break;

   case IRP_MN_QUERY_INTERFACE:
      DEBUG_LOG_PATH("IRP_MN_QUERY_INTERFACE");
      break;

   case IRP_MN_QUERY_CAPABILITIES:
      DEBUG_TRACE2(("IRP_MN_QUERY_CAPABILITIES\n"));
      {
         PKEVENT pQueryCapsEvent;
         PDEVICE_CAPABILITIES pDevCaps;

         pQueryCapsEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT));

         if (pQueryCapsEvent == NULL) {
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
         }


         KeInitializeEvent(pQueryCapsEvent, SynchronizationEvent, FALSE);

         IoCopyCurrentIrpStackLocationToNext(Irp);

         IoSetCompletionRoutine(Irp, UsbSerSyncCompletion, pQueryCapsEvent,
                                TRUE, TRUE, TRUE);

         NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, Irp);


         //
         // Wait for lower drivers to be done with the Irp
         //

         if (NtStatus == STATUS_PENDING) {
            KeWaitForSingleObject(pQueryCapsEvent, Executive, KernelMode,
                                  FALSE, NULL);
         }

         ExFreePool(pQueryCapsEvent);

         NtStatus = Irp->IoStatus.Status;

         if (IrpStack->Parameters.DeviceCapabilities.Capabilities == NULL) {
            goto errQueryCaps;
         }

         //
         // Save off their power capabilities
         //

         IrpStack = IoGetCurrentIrpStackLocation(Irp);

         pDevCaps = IrpStack->Parameters.DeviceCapabilities.Capabilities;

         pDevCaps->SurpriseRemovalOK   = TRUE;

         DeviceExtension->SystemWake = pDevCaps->SystemWake;
         DeviceExtension->DeviceWake = pDevCaps->DeviceWake;

         UsbSerSerialDump(USBSERTRACEPW,
                          ("IRP_MN_QUERY_CAPS: SystemWake %08X "
                           "DeviceWake %08X\n", DeviceExtension->SystemWake,
                           DeviceExtension->DeviceWake));

         errQueryCaps:;

         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         return NtStatus;
      }

   case IRP_MN_QUERY_RESOURCES:
      DEBUG_LOG_PATH("IRP_MN_QUERY_RESOURCES");
      break;

   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
      DEBUG_LOG_PATH("IRP_MN_QUERY_RESOURCE_REQUIREMENTS");
      break;

   case IRP_MN_QUERY_DEVICE_TEXT:
      DEBUG_LOG_PATH("IRP_MN_QUERY_DEVICE_TEXT");
      break;

   case IRP_MN_READ_CONFIG:
      DEBUG_LOG_PATH("IRP_MN_READ_CONFIG");
      break;

   case IRP_MN_WRITE_CONFIG:
      DEBUG_LOG_PATH("IRP_MN_WRITE_CONFIG");
      break;

   case IRP_MN_EJECT:
      DEBUG_LOG_PATH("IRP_MN_EJECT");
      break;

   case IRP_MN_SET_LOCK:
      DEBUG_LOG_PATH("IRP_MN_SET_LOCK");
      break;

   case IRP_MN_QUERY_ID:
      DEBUG_LOG_PATH("IRP_MN_QUERY_ID");
      break;

   case IRP_MN_QUERY_PNP_DEVICE_STATE:
      DEBUG_LOG_PATH("IRP_MN_QUERY_PNP_DEVICE_STATE");
      break;

   case IRP_MN_QUERY_BUS_INFORMATION:
      DEBUG_LOG_PATH("IRP_MN_QUERY_BUS_INFORMATION");
      break;

   case IRP_MN_SURPRISE_REMOVAL:
   {
      PIRP      CurrentMaskIrp;
      KIRQL     CancelIrql;

      DEBUG_TRACE2(("IRP_MN_SURPRISE_REMOVAL\n"));

      ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &CancelIrql);

	  // surprise removal, so stop accepting requests
	  UsbSerFetchBooleanLocked(&DeviceExtension->AcceptingRequests,
                               FALSE, &DeviceExtension->ControlLock);

      // let's see if we have any events to signal
      CurrentMaskIrp = DeviceExtension->CurrentMaskIrp;

      // complete the queued IRP if needed
      if(CurrentMaskIrp)
      {
         // indicate to upper layers that CD dropped if needed
         if((DeviceExtension->IsrWaitMask & SERIAL_EV_RLSD) &&
             (DeviceExtension->FakeModemStatus & SERIAL_MSR_DCD))
         {

            DEBUG_TRACE2(("Sending up a CD dropped event\n"));
            
            DeviceExtension->FakeModemStatus        &= ~SERIAL_MSR_DCD;
            DeviceExtension->HistoryMask            |= SERIAL_EV_RLSD;

            CurrentMaskIrp->IoStatus.Status         = STATUS_SUCCESS;
            CurrentMaskIrp->IoStatus.Information    = sizeof(ULONG);

            DeviceExtension->CurrentMaskIrp         = NULL;

            *(PULONG) (CurrentMaskIrp->AssociatedIrp.SystemBuffer) =
                DeviceExtension->HistoryMask;

            DeviceExtension->HistoryMask = 0;

            IoSetCancelRoutine(CurrentMaskIrp, NULL);
            RELEASE_CANCEL_SPINLOCK(DeviceExtension, CancelIrql);

            IoCompleteRequest(CurrentMaskIrp, IO_NO_INCREMENT);


         }
         else
         {
            RELEASE_CANCEL_SPINLOCK(DeviceExtension, CancelIrql);
         }

      }
      else
      {
         RELEASE_CANCEL_SPINLOCK(DeviceExtension, CancelIrql);
      }


      Irp->IoStatus.Status = STATUS_SUCCESS;
      break;
   }
   default:
      DEBUG_LOG_PATH("PnP IOCTL not handled");
      DEBUG_TRACE3(("IOCTL (%08X)\n", IrpStack->MinorFunction));
      break;

   }       // case of IRP_MJ_PNP

   // All PNP POWER messages get passed to StackDeviceObject.

   if (PassDown) {
      DEBUG_TRACE3(("Passing PnP Irp down, status (%08X)\n", NtStatus));

      IoCopyCurrentIrpStackLocationToNext(Irp);

      DEBUG_LOG_PATH("Passing PnP Irp down stack");
      NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, Irp);
   }

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  UsbSer_PnP");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));

   return NtStatus;
} // UsbSer_PnP


#ifndef WMI_SUPPORT
/************************************************************************/
/* UsbSer_SystemControl                                                 */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      This routine will receive the various system control messages.  */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_SystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION      IrpStack;
   PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
   PVOID                   IoBuffer;
   ULONG                   InputBufferLength;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSer_SystemControl");

   // Get a pointer to the current location in the Irp. This is where
   // the function codes and parameters are located.
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   // Get the pointer to the input/output buffer and it's length
   IoBuffer           = Irp->AssociatedIrp.SystemBuffer;
   InputBufferLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

   // make entry in IRP history table
   DEBUG_LOG_IRP_HIST(DeviceObject, Irp, IrpStack->MajorFunction, IoBuffer,
                      InputBufferLength);


   // All System Control messages get passed to StackDeviceObject.

   IoCopyCurrentIrpStackLocationToNext(Irp);
   NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, Irp);

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  UsbSer_SystemControl");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));

   return NtStatus;
} // UsbSer_SystemControl

#endif

/************************************************************************/
/* UsbSer_Cleanup                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSer_Cleanup(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
        NTSTATUS                NtStatus = STATUS_SUCCESS;

        USBSER_LOCKED_PAGED_CODE();

        DEBUG_LOG_PATH("enter UsbSer_Cleanup");
        UsbSerSerialDump(USBSERTRACEOTH, (">UsbSer_Cleanup(%08X)\n", Irp));

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        UsbSerKillPendingIrps(DeviceObject);

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        // log an error if we got one
        DEBUG_LOG_ERROR(NtStatus);
        DEBUG_LOG_PATH("exit  UsbSer_Cleanup");
        DEBUG_TRACE3(("status (%08X)\n", NtStatus));
        UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSer_Cleanup %08X\n", NtStatus));

        return NtStatus;
} // UsbSer_Cleanup


/************************************************************************/
/* UsbSerMajorNotSupported                                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*      Standard routine to return STATUS_NOT_SUPPORTED for IRP_MJ      */
/*      calls we don't handle.                                          */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSerMajorNotSupported(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
        PAGED_CODE();

        DEBUG_LOG_PATH("enter UsbSerMajorNotSupported");
        DEBUG_TRACE3(("Major (%08X)\n",
                     IoGetCurrentIrpStackLocation(Irp)->MajorFunction));

        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        // log an error if we got one
        DEBUG_LOG_ERROR(STATUS_NOT_SUPPORTED);
        DEBUG_LOG_PATH("exit  UsbSerMajorNotSupported");
        DEBUG_TRACE3(("status (%08X)\n", STATUS_NOT_SUPPORTED));

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_NOT_SUPPORTED;
} // UsbSerMajorNotSupported


#ifdef WMI_SUPPORT

NTSTATUS
UsbSerSystemControlDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;
    PDEVICE_EXTENSION pDevExt
      = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    PAGED_CODE();

    status = WmiSystemControl(   &pDevExt->WmiLibInfo,
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            IoSkipCurrentIrpStackLocation(Irp);

            status = IoCallDriver(pDevExt->StackDeviceObject, Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(pDevExt->StackDeviceObject, Irp);
            break;
        }        
    }
    
    return(status);

}



//
// WMI System Call back functions
//



NTSTATUS
UsbSerTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex)
{
   PDEVICE_EXTENSION pDevExt;
   NTSTATUS status;

   PAGED_CODE();

   pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;

   switch (GuidIndex) 
   {

   case WMI_SERIAL_PORT_NAME_INFORMATION:
      status = STATUS_INVALID_DEVICE_REQUEST;
      break;

   default:
      status = STATUS_WMI_GUID_NOT_FOUND;
      break;
   }

   status = WmiCompleteRequest(PDevObj, PIrp,
                                 status, 0, IO_NO_INCREMENT);

   return status;
}


NTSTATUS
UsbSerSetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, IN ULONG InstanceIndex,
                     IN ULONG DataItemId,
                     IN ULONG BufferSize, IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    PBuffer has the new values for the data item


Return Value:

    status

--*/
{
   PAGED_CODE();

   //
   // Toss this request -- we don't support anything for it
   //

   return UsbSerTossWMIRequest(PDevObj, PIrp, GuidIndex);
}


NTSTATUS
UsbSerSetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                      IN ULONG GuidIndex, IN ULONG InstanceIndex,
                      IN ULONG BufferSize,
                      IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    PBuffer has the new values for the data block


Return Value:

    status

--*/
{
   PAGED_CODE();

   //
   // Toss this request -- we don't support anything for it
   //

   return UsbSerTossWMIRequest(PDevObj, PIrp, GuidIndex);
}


NTSTATUS
UsbSerQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                        IN ULONG GuidIndex, 
                        IN ULONG InstanceIndex,
                        IN ULONG InstanceCount,
                        IN OUT PULONG InstanceLengthArray,
                        IN ULONG OutBufferSize,
                        OUT PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on has the maximum size available to write the data
        block.

    PBuffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG size = 0;
    PDEVICE_EXTENSION pDevExt
       = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;

    PAGED_CODE();

    switch (GuidIndex) {
    case WMI_SERIAL_PORT_NAME_INFORMATION:
       size = pDevExt->WmiIdentifier.Length;

       if (OutBufferSize < (size + sizeof(USHORT))) {
            size += sizeof(USHORT);
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

       if (pDevExt->WmiIdentifier.Buffer == NULL) {
           status = STATUS_INSUFFICIENT_RESOURCES;
           break;
        }

        //
        // First, copy the string over containing our identifier
        //

        *(USHORT *)PBuffer = (USHORT)size;
        (UCHAR *)PBuffer += sizeof(USHORT);

        RtlCopyMemory(PBuffer, pDevExt->WmiIdentifier.Buffer, size);

        //
        // Increment total size to include the WORD containing our len
        //

        size += sizeof(USHORT);
        *InstanceLengthArray = size;
                
        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest( PDevObj, PIrp,
                                  status, size, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
UsbSerQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                      OUT PUNICODE_STRING PInstanceName,
                      OUT PUNICODE_STRING *PRegistryPath,
                      OUT PUNICODE_STRING MofResourceName,
                      OUT PDEVICE_OBJECT *Pdo)
                                                  
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered. 
            
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.               

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is 
        required
                
    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
   PDEVICE_EXTENSION pDevExt
       = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;
   
   PAGED_CODE();

   *PRegFlags = WMIREG_FLAG_INSTANCE_PDO;
   *PRegistryPath = &GlobalRegistryPath;
   *Pdo = pDevExt->PhysDeviceObject;

   return STATUS_SUCCESS;
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\usbser.h ===
/****************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

        USBSER.H

Abstract:

        This header file is used for the Legacy USB Modem Driver

Environment:

        Kernel mode & user mode

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

Revision History:

        12/23/97 : created

Author:

        Tom Green

****************************************************************************/

#ifndef __USBSER_H__
#define __USBSER_H__

#ifdef DRIVER

// Various definitions
#define NAME_MAX                        80

#define MILLISECONDS_TIMEOUT(x) ((ULONGLONG) ((-x) * 10000))

#define NOTIFICATION_BUFF_SIZE  10

#define MAXIMUM_TRANSFER_SIZE           (8 * 1024)
#define RX_BUFF_SIZE             		(16 * 1024)
#define USB_RX_BUFF_SIZE				(RX_BUFF_SIZE / 4)
#define LOW_WATER_MARK					(USB_RX_BUFF_SIZE * 3)

#define DEVICE_STATE_UNKNOWN            0x0000
#define DEVICE_STATE_STARTED            0x0001
#define DEVICE_STATE_STOPPED            0x0002
#define DEVICE_STATE_REMOVED            0x0003

// device capabilities
#define DEVICE_CAP_VERSION              0x0001
#define DEVICE_CAP_UNUSED_PARAM         ((ULONG) -1)

// these describe bits in the modem status register
#define SERIAL_MSR_DCTS                 0x0001
#define SERIAL_MSR_DDSR                 0x0002
#define SERIAL_MSR_TERI                 0x0004
#define SERIAL_MSR_DDCD                 0x0008
#define SERIAL_MSR_CTS                  0x0010
#define SERIAL_MSR_DSR                  0x0020
#define SERIAL_MSR_RI                   0x0040
#define SERIAL_MSR_DCD                  0x0080

//
// These masks define access to the line status register.  The line
// status register contains information about the status of data
// transfer.  The first five bits deal with receive data and the
// last two bits deal with transmission.  An interrupt is generated
// whenever bits 1 through 4 in this register are set.
//

//
// This bit is the data ready indicator.  It is set to indicate that
// a complete character has been received.  This bit is cleared whenever
// the receive buffer register has been read.
//
#define SERIAL_LSR_DR       0x01

//
// This is the overrun indicator.  It is set to indicate that the receive
// buffer register was not read befor a new character was transferred
// into the buffer.  This bit is cleared when this register is read.
//
#define SERIAL_LSR_OE       0x02

//
// This is the parity error indicator.  It is set whenever the hardware
// detects that the incoming serial data unit does not have the correct
// parity as defined by the parity select in the line control register.
// This bit is cleared by reading this register.
//
#define SERIAL_LSR_PE       0x04

//
// This is the framing error indicator.  It is set whenever the hardware
// detects that the incoming serial data unit does not have a valid
// stop bit.  This bit is cleared by reading this register.
//
#define SERIAL_LSR_FE       0x08

//
// This is the break interrupt indicator.  It is set whenever the data
// line is held to logic 0 for more than the amount of time it takes
// to send one serial data unit.  This bit is cleared whenever the
// this register is read.
//
#define SERIAL_LSR_BI       0x10

//
// This is the transmit holding register empty indicator.  It is set
// to indicate that the hardware is ready to accept another character
// for transmission.  This bit is cleared whenever a character is
// written to the transmit holding register.
//
#define SERIAL_LSR_THRE     0x20

//
// This bit is the transmitter empty indicator.  It is set whenever the
// transmit holding buffer is empty and the transmit shift register
// (a non-software accessable register that is used to actually put
// the data out on the wire) is empty.  Basically this means that all
// data has been sent.  It is cleared whenever the transmit holding or
// the shift registers contain data.
//
#define SERIAL_LSR_TEMT     0x40

//
// This bit indicates that there is at least one error in the fifo.
// The bit will not be turned off until there are no more errors
// in the fifo.
//
#define SERIAL_LSR_FIFOERR  0x80



//
// Serial naming values
//

//
// Maximum length for symbolic link
//

#define SYMBOLIC_NAME_LENGTH    128

//
// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.

#define DEFAULT_DIRECTORY               L"DosDevices"

//
// Where in the DeviceMap section of the registry serial port entries
// should appear
//

#define SERIAL_DEVICE_MAP               L"SERIALCOMM"


// performance info for modem driver
typedef struct _PERF_INFO
{
        BOOLEAN                         PerfModeEnabled;
    ULONG                               BytesPerSecond;
} PERF_INFO, *PPERF_INFO;


#define SANITY_CHECK                    ((ULONG) 'ENAS')

#else

#include <winioctl.h>

#endif

// IOCTL info, needs to be visible for application

#define USBSER_IOCTL_INDEX      0x0800


#define GET_DRIVER_LOG          CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 0,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define GET_IRP_HIST            CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 1,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define GET_PATH_HIST           CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 2,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define GET_ERROR_LOG           CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 3,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define GET_ATTACHED_DEVICES    CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 4,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define SET_IRP_HIST_SIZE       CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 5,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define SET_PATH_HIST_SIZE      CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 6,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define SET_ERROR_LOG_SIZE      CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 7,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define GET_DRIVER_INFO         CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 8,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)


#define ENABLE_PERF_TIMING      CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 9,        \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define DISABLE_PERF_TIMING     CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 10,       \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define GET_PERF_DATA           CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 11,       \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#define SET_DEBUG_TRACE_LEVEL   CTL_CODE(FILE_DEVICE_UNKNOWN,           \
                                         USBSER_IOCTL_INDEX + 12,       \
                                         METHOD_BUFFERED,               \
                                         FILE_ANY_ACCESS)

#ifdef DRIVER

// info about the driver, initialized in DriverEntry routine
CHAR        DriverName[10];
CHAR        DriverVersion[10];
ULONG       Usbser_Debug_Trace_Level;
ULONG       UsbSerSerialDebugLevel;
KSPIN_LOCK  GlobalSpinLock;

//
// Count of how many times the paged code has been locked
//

ULONG       PAGEUSBSER_Count;

//
// Handle to the locked paged code
//

PVOID       PAGEUSBSER_Handle;

//
// Pointer to funcion
//

PVOID       PAGEUSBSER_Function;

typedef struct _READ_CONTEXT
{
        PURB                            Urb;
        PDEVICE_OBJECT                  DeviceObject;
        PIRP                            Irp;
} READ_CONTEXT, *PREAD_CONTEXT;

// device extension for driver instance, used to store needed data

typedef struct _DEVICE_EXTENSION
{
        PDEVICE_OBJECT                  PhysDeviceObject;       // physical device object
        PDEVICE_OBJECT                  StackDeviceObject;      // stack device object
        CHAR                            LinkName[NAME_MAX];     // string name of symbolic link
        PUSB_DEVICE_DESCRIPTOR          DeviceDescriptor;       // device descriptor for device
        USBD_CONFIGURATION_HANDLE       ConfigurationHandle;    // configuration of USB device
        USBD_PIPE_HANDLE                DataInPipe;             // pipe for reading data
        USBD_PIPE_HANDLE                DataOutPipe;            // pipe for writing data
        USBD_PIPE_HANDLE                NotificationPipe;       // pipe for getting notifications from the device
        ULONG                           IRPCount;               // number of IRPs that passed through this device object
        LARGE_INTEGER                   ByteCount;              // number of bytes of data passed through this device object
        ULONG                           Instance;               // instance of device
        BOOLEAN                         IsDevice;               // is this a device or "global" device object
        BOOLEAN                         PerfTimerEnabled;       // enable perf timing
        LARGE_INTEGER                   BytesXfered;            // byte count for perf
        LARGE_INTEGER                   ElapsedTime;            // elapsed time for perf
        LARGE_INTEGER                   TimerStart;             // timer start for perf
        DEVICE_CAPABILITIES             DeviceCapabilities;
        ULONG                           PowerDownLevel;
        DEVICE_POWER_STATE              CurrentDevicePowerState;
        PIRP                            PowerIrp;
        BOOLEAN                         SelfPowerIrp;
        KEVENT                          SelfRequestedPowerIrpEvent;

        //
        // Nota Bene:  Locking hierarchy is acquire ControlLock *then*
        //             acquire CancelSpinLock.  We don't want to stall other
        //             drivers waiting for the cancel spin lock
        //

        KSPIN_LOCK                      ControlLock;            // protect extension
        ULONG                           CurrentBaud;            // current baud rate
        SERIAL_TIMEOUTS                 Timeouts;               // timeout controls for device
        ULONG                           IsrWaitMask;            // determine if occurence of events should be noticed
        SERIAL_LINE_CONTROL             LineControl;            // current value of line control reg
        SERIAL_HANDFLOW                 HandFlow;               // Handshake and control flow settings
        SERIALPERF_STATS                PerfStats;              // performance stats
        SERIAL_CHARS                    SpecialChars;           // special characters
        ULONG                           DTRRTSState;            // keep track of the current state of these lines
        ULONG                           SupportedBauds;         // "named" baud rates for device
        UCHAR                           EscapeChar;             // for LsrmstInsert IOCTL
        USHORT                          FakeModemStatus;        // looks like status register on modem
        USHORT                          FakeLineStatus;         // looks like line status register
        USHORT                          RxMaxPacketSize;        // max packet size fo the in data pipe
        PIRP                            NotifyIrp;              // Irp for notify reads
        PURB                            NotifyUrb;              // Urb for notify Irp
        PIRP                            ReadIrp;                // Irp for read requests
        PURB                            ReadUrb;                // Urb for read requests
        KEVENT                          ReadEvent;              // used to cancel a read Irp
        ULONG                           CharsInReadBuff;        // current number of characters buffered
        ULONG                           CurrentReadBuffPtr;     // pointer into read buffer
        BOOLEAN                         AcceptingRequests;      // is the device stopped or removed
        PIRP                            CurrentMaskIrp;         // current set or wait mask Irp
        ULONG                           HistoryMask;            // store mask events here
        ULONG                           OpenCnt;                // number of create calls on device
        PUCHAR                          NotificationBuff;       // buffer for notifications
        PUCHAR                          ReadBuff;               // circular buffer for read requests
        PUCHAR							USBReadBuff;			// buffer to get data from device
        UCHAR                           CommInterface;          // index of communications interface
        ULONG                           RxQueueSize;            // fake read buffer size
        ULONG                           ReadInterlock;          // state machine for starting reads from completion routine
        BOOLEAN                         ReadInProgress;
        ULONG                           DeviceState;            // current state of enumeration

        //
        // True if a symbolic link has been created and should be
        // removed upon deletion.
        //

        BOOLEAN                         CreatedSymbolicLink;

        //
        // Symbolic link name -- e.g., \\DosDevices\COMx
        //

        UNICODE_STRING                  SymbolicLinkName;

        //
        // Dos Name -- e.g., COMx
        //

        UNICODE_STRING                  DosName;

        //
        // Device Name -- e.g., \\Devices\UsbSerx
        //

        UNICODE_STRING                  DeviceName;

        //
        // Current Read Irp which is pending
        //

        PIRP                            CurrentReadIrp;

        //
        // Current Write Irp which is pending
        //

        PIRP                            CurrentWriteIrp;

        //
        // Read queue
        //

        LIST_ENTRY                      ReadQueue;

        //
        // This value holds the number of characters desired for a
        // particular read.  It is initially set by read length in the
        // IRP.  It is decremented each time more characters are placed
        // into the "users" buffer buy the code that reads characters
        // out of the typeahead buffer into the users buffer.  If the
        // typeahead buffer is exhausted by the read, and the reads buffer
        // is given to the isr to fill, this value is becomes meaningless.
        //

        ULONG                           NumberNeededForRead;

        //
        // Timer for timeout on total read request
        //

        KTIMER                          ReadRequestTotalTimer;

        //
        // Timer for timeout on the interval
        //

        KTIMER                          ReadRequestIntervalTimer;

        //
        // This is the kernal timer structure used to handle
        // total time request timing.
        //

        KTIMER                          WriteRequestTotalTimer;

        //
        // This value is set by the read code to hold the time value
        // used for read interval timing.  We keep it in the extension
        // so that the interval timer dpc routine determine if the
        // interval time has passed for the IO.
        //

        LARGE_INTEGER                   IntervalTime;

        //
        // This holds the value that we use to determine if we should use
        // the long interval delay or the short interval delay.
        //

        LARGE_INTEGER                   CutOverAmount;

        //
        // This holds the system time when we last time we had
        // checked that we had actually read characters.  Used
        // for interval timing.
        //

        LARGE_INTEGER                   LastReadTime;

        //
        // This points the the delta time that we should use to
        // delay for interval timing.
        //

        PLARGE_INTEGER                  IntervalTimeToUse;

        //
        // These two values hold the "constant" time that we should use
        // to delay for the read interval time.
        //

        LARGE_INTEGER                   ShortIntervalAmount;
        LARGE_INTEGER                   LongIntervalAmount;

        //
        // This dpc is fired off if the timer for the total timeout
        // for the read expires.  It will execute a dpc routine that
        // will cause the current read to complete.
        //
        //

        KDPC                            TotalReadTimeoutDpc;

        //
        // This dpc is fired off if the timer for the interval timeout
        // expires.  If no more characters have been read then the
        // dpc routine will cause the read to complete.  However, if
        // more characters have been read then the dpc routine will
        // resubmit the timer.
        //

        KDPC                            IntervalReadTimeoutDpc;

        //
        // This dpc is fired off if the timer for the total timeout
        // for the write expires.  It will execute a dpc routine that
        // will cause the current write to complete.
        //
        //

        KDPC                            TotalWriteTimeoutDpc;

        //
        // This keeps a total of the number of characters that
        // are in all of the "write" irps that the driver knows
        // about.  It is only accessed with the cancel spinlock
        // held.
        //

        ULONG                           TotalCharsQueued;

        //
        // This holds a count of the number of characters read
        // the last time the interval timer dpc fired.  It
        // is a long (rather than a ulong) since the other read
        // completion routines use negative values to indicate
        // to the interval timer that it should complete the read
        // if the interval timer DPC was lurking in some DPC queue when
        // some other way to complete occurs.
        //

        LONG                            CountOnLastRead;

        //
        // This is a count of the number of characters read by the
        // isr routine.  It is *ONLY* written at isr level.  We can
        // read it at dispatch level.
        //

        ULONG                           ReadByIsr;

        //
        // If non-NULL, means this write timed out and we should correct the
        // return value in the completion routine.
        //

        PIRP                            TimedOutWrite;

        //
        // If TRUE, that means we need to insert LSRMST
        //

        BOOLEAN                         EscapeSeen;


        //
        // Holds data that needs to be pushed such as LSRMST data
        //

        LIST_ENTRY                      ImmediateReadQueue;

        //
        // Pending wait-wake irp
        //

        PIRP                            PendingWakeIrp;

        //
        // True if WaitWake needs to be sent down before a powerdown
        //

        BOOLEAN                         SendWaitWake;

        //
        // SystemWake from devcaps
        //

        SYSTEM_POWER_STATE              SystemWake;

        //
        // DeviceWake from devcaps
        //

        DEVICE_POWER_STATE              DeviceWake;

        //
        // Count of Writes pending in the lower USB levels
        //

        ULONG                           PendingWriteCount;

        //
        // Counters and events to drain USB requests
        //

        KEVENT                          PendingDataInEvent;
        KEVENT                          PendingDataOutEvent;
        KEVENT                          PendingNotifyEvent;
        KEVENT                          PendingFlushEvent;

        ULONG                           PendingDataInCount;
        ULONG                           PendingDataOutCount;
        ULONG                           PendingNotifyCount;
        ULONG                           SanityCheck;

      	// selective suspend support
      	PIRP                        	PendingIdleIrp;
      	PUSB_IDLE_CALLBACK_INFO       	IdleCallbackInfo;
    	PIO_WORKITEM 					IoWorkItem;
    	IO_STATUS_BLOCK                 StatusBlock;

#ifdef SPINLOCK_TRACKING
      	LONG							CancelSpinLockCount;
      	LONG							SpinLockCount;
      	LONG							WaitingOnCancelSpinLock;
      	LONG							WaitingOnSpinLock;
#endif

#ifdef WMI_SUPPORT
      //
      // WMI Information
      //

      WMILIB_CONTEXT WmiLibInfo;

      //
      // Name to use as WMI identifier
      //

      UNICODE_STRING WmiIdentifier;

#endif

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _USBSER_IMMEDIATE_READ_PACKET {
   //
   // List of packets
   //

   LIST_ENTRY ImmediateReadQueue;

   //
   // Length of data
   //

   ULONG BufferLen;

   //
   //  Buffer itself, leave last in struct
   //

   UCHAR Buffer;



} USBSER_IMMEDIATE_READ_PACKET, *PUSBSER_IMMEDIATE_READ_PACKET;

typedef struct _USBSER_WRITE_PACKET {
   //
   // Device extension for this write
   //

   PDEVICE_EXTENSION DeviceExtension;

   //
   // Irp this packet belongs with
   //

   PIRP Irp;

   //
   // Write timer
   //

   KTIMER WriteTimer;

   //
   // Timeout value
   //

   LARGE_INTEGER WriteTimeout;

   //
   // TimerDPC
   //

   KDPC TimerDPC;

   //
   // Status
   //

   NTSTATUS Status;

   //
   // Urb for this write  N.B.: size is variable, so leave last
   //

   URB Urb;
} USBSER_WRITE_PACKET, *PUSBSER_WRITE_PACKET;


typedef NTSTATUS (*PUSBSER_START_ROUTINE)(IN PDEVICE_EXTENSION);
typedef VOID (*PUSBSER_GET_NEXT_ROUTINE) (IN PIRP *CurrentOpIrp,
                                          IN PLIST_ENTRY QueueToProcess,
                                          OUT PIRP *NewIrp,
                                          IN BOOLEAN CompleteCurrent,
                                          PDEVICE_EXTENSION Extension);

NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);

NTSTATUS
UsbSer_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_Create(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_Close(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_Write(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_Read(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

VOID
UsbSer_Unload(IN PDRIVER_OBJECT DriverObject);

NTSTATUS
UsbSer_PnPAddDevice(IN PDRIVER_OBJECT DriverObject,
                                        IN PDEVICE_OBJECT PhysicalDeviceObject);

NTSTATUS
UsbSer_PnP(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_Power(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_SystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_Cleanup(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSerMajorNotSupported(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSerStartOrQueue(IN PDEVICE_EXTENSION PDevExt, IN PIRP PIrp,
                   IN PLIST_ENTRY PQueue, IN PIRP *PPCurrentIrp,
                   IN PUSBSER_START_ROUTINE Starter);

VOID
UsbSerCancelQueued(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
UsbSerStartRead(IN PDEVICE_EXTENSION PDevExt);


VOID
UsbSerCancelCurrentRead(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

BOOLEAN
UsbSerGrabReadFromRx(IN PVOID Context);

VOID
UsbSerTryToCompleteCurrent(IN PDEVICE_EXTENSION PDevExt,
                           IN KIRQL IrqlForRelease, IN NTSTATUS StatusToUse,
                           IN PIRP *PpCurrentOpIrp,
                           IN PLIST_ENTRY PQueue OPTIONAL,
                           IN PKTIMER PIntervalTimer OPTIONAL,
                           IN PKTIMER PTotalTimer OPTIONAL,
                           IN PUSBSER_START_ROUTINE Starter OPTIONAL,
                           IN PUSBSER_GET_NEXT_ROUTINE PGetNextIrp OPTIONAL,
                           IN LONG RefType, IN BOOLEAN Complete);

VOID
UsbSerReadTimeout(IN PKDPC PDpc, IN PVOID DeferredContext,
                  IN PVOID SystemContext1, IN PVOID SystemContext2);

VOID
UsbSerIntervalReadTimeout(IN PKDPC PDpc, IN PVOID DeferredContext,
                          IN PVOID SystemContext1, IN PVOID SystemContext2);

VOID
UsbSerKillPendingIrps(PDEVICE_OBJECT PDevObj);

VOID
UsbSerCompletePendingWaitMasks(IN PDEVICE_EXTENSION DeviceExtension);


VOID
UsbSerKillAllReadsOrWrites(IN PDEVICE_OBJECT PDevObj,
                           IN PLIST_ENTRY PQueueToClean,
                           IN PIRP *PpCurrentOpIrp);

VOID
UsbSerRestoreModemSettings(PDEVICE_OBJECT PDevObj);

VOID
UsbSerProcessEmptyTransmit(IN PDEVICE_EXTENSION PDevExt);

VOID
UsbSerWriteTimeout(IN PKDPC Dpc, IN PVOID DeferredContext,
                   IN PVOID SystemContext1, IN PVOID SystemContext2);

NTSTATUS
UsbSerGiveWriteToUsb(IN PDEVICE_EXTENSION PDevExt, IN PIRP PIrp,
                     IN LARGE_INTEGER TotalTime);

VOID
UsbSerCancelWaitOnMask(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
UsbSerWriteComplete(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                    IN PUSBSER_WRITE_PACKET PPacket);

NTSTATUS
UsbSerFlush(IN PDEVICE_OBJECT PDevObj, PIRP PIrp);

NTSTATUS
UsbSerTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex);

NTSTATUS
UsbSerSystemControlDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
UsbSerSetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, IN ULONG InstanceIndex,
                     IN ULONG DataItemId,
                     IN ULONG BufferSize, IN PUCHAR PBuffer);

NTSTATUS
UsbSerSetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                      IN ULONG GuidIndex, IN ULONG InstanceIndex,
                      IN ULONG BufferSize,
                      IN PUCHAR PBuffer);

NTSTATUS
UsbSerQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                        IN ULONG GuidIndex,
                        IN ULONG InstanceIndex,
                        IN ULONG InstanceCount,
                        IN OUT PULONG InstanceLengthArray,
                        IN ULONG OutBufferSize,
                        OUT PUCHAR PBuffer);

NTSTATUS
UsbSerQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                      OUT PUNICODE_STRING PInstanceName,
                      OUT PUNICODE_STRING *PRegistryPath,
                      OUT PUNICODE_STRING MofResourceName,
                      OUT PDEVICE_OBJECT *Pdo);


//
// The following three macros are used to initialize, set
// and clear references in IRPs that are used by
// this driver.  The reference is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//

#define USBSER_REF_RXBUFFER    (0x00000001)
#define USBSER_REF_CANCEL      (0x00000002)
#define USBSER_REF_TOTAL_TIMER (0x00000004)
#define USBSER_REF_INT_TIMER   (0x00000008)

#ifdef SPINLOCK_TRACKING

#define ACQUIRE_CANCEL_SPINLOCK(DEVEXT, IRQL)					\
{																\
	ASSERT(DEVEXT->SpinLockCount == 0);							\
	DEVEXT->WaitingOnCancelSpinLock++; 							\
	IoAcquireCancelSpinLock(IRQL);								\
	DEVEXT->CancelSpinLockCount++;								\
	DEVEXT->WaitingOnCancelSpinLock--; 							\
	ASSERT(DEVEXT->CancelSpinLockCount == 1);					\
}

#define RELEASE_CANCEL_SPINLOCK(DEVEXT, IRQL)					\
{																\
	DEVEXT->CancelSpinLockCount--;								\
	ASSERT(DEVEXT->CancelSpinLockCount == 0);					\
	IoReleaseCancelSpinLock(IRQL);								\
}

#define ACQUIRE_SPINLOCK(DEVEXT, LOCK, IRQL)					\
{																\
	DEVEXT->WaitingOnSpinLock++; 								\
	KeAcquireSpinLock(LOCK, IRQL);					    		\
	DEVEXT->SpinLockCount++;									\
	DEVEXT->WaitingOnSpinLock--; 								\
	ASSERT(DEVEXT->SpinLockCount == 1);							\
}

#define RELEASE_SPINLOCK(DEVEXT, LOCK, IRQL)					\
{																\
	DEVEXT->SpinLockCount--;									\
	ASSERT(DEVEXT->SpinLockCount == 0);							\
	KeReleaseSpinLock(LOCK, IRQL);					    		\
}

#else

#define ACQUIRE_CANCEL_SPINLOCK(DEVEXT, IRQL) 	IoAcquireCancelSpinLock(IRQL)
#define RELEASE_CANCEL_SPINLOCK(DEVEXT, IRQL) 	IoReleaseCancelSpinLock(IRQL)
#define ACQUIRE_SPINLOCK(DEVEXT, LOCK, IRQL)	KeAcquireSpinLock(LOCK, IRQL)
#define RELEASE_SPINLOCK(DEVEXT, LOCK, IRQL)	KeReleaseSpinLock(LOCK, IRQL)

#endif


#define USBSER_INIT_REFERENCE(Irp) { \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define USBSER_SET_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PUINT_PTR _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       *_arg4 |= _refType; \
   } while (0)

#define USBSER_CLEAR_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PUINT_PTR _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       *_arg4 &= ~_refType; \
   } while (0)

#define USBSER_REFERENCE_COUNT(Irp) \
    ((UINT_PTR)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))


//
// These values are used by the routines that can be used
// to complete a read (other than interval timeout) to indicate
// to the interval timeout that it should complete.
//
#define SERIAL_COMPLETE_READ_CANCEL ((LONG)-1)
#define SERIAL_COMPLETE_READ_TOTAL ((LONG)-2)
#define SERIAL_COMPLETE_READ_COMPLETE ((LONG)-3)

#if DBG

#define USBSERDUMPRD    ((ULONG)0x00000001)
#define USBSERDUMPWR    ((ULONG)0x00000002)
#define USBSERCOMPEV    ((ULONG)0x00000004)

#define USBSERTRACETM   ((ULONG)0x00100000)
#define USBSERTRACECN   ((ULONG)0x00200000)
#define USBSERTRACEPW   ((ULONG)0x00400000)
#define USBSERTRACERD   ((ULONG)0x01000000)
#define USBSERTRACEWR   ((ULONG)0x02000000)
#define USBSERTRACEIOC  ((ULONG)0x04000000)
#define USBSERTRACEOTH  ((ULONG)0x08000000)

#define USBSERBUGCHECK  ((ULONG)0x80000000)

#define USBSERTRACE     ((ULONG)0x0F700000)
#define USBSERDBGALL    ((ULONG)0xFFFFFFFF)

extern ULONG UsbSerSerialDebugLevel;

#define UsbSerSerialDump(LEVEL, STRING) \
   do { \
      ULONG _level = (LEVEL); \
      if (UsbSerSerialDebugLevel & _level) { \
         DbgPrint("UsbSer: "); \
         DbgPrint STRING; \
      } \
      if (_level == USBSERBUGCHECK) { \
         ASSERT(FALSE); \
      } \
   } while (0)
#else

#define UsbSerSerialDump(LEVEL,STRING) do {;} while (0)

#endif // DBG

#define USBSER_VENDOR_COMMAND 0
#define USBSER_CLASS_COMMAND  1

#endif  // DRIVER


#endif // __USBSER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\utils.h ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

   UTILS.H

Abstract:

   Header file for routines that don't fit anywhere else.

Environment:

   kernel mode only

Notes:

   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
   KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
   PURPOSE.

   Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

   12/23/97 : created

Authors:

   Tom Green


****************************************************************************/


#ifndef __UTILS_H__
#define __UTILS_H__

// state machine defines for restarting reads from completion routines
#define START_READ         0x0001
#define IMMEDIATE_READ     0x0002
#define END_READ        0x0003

//
// State machine defines for LSRMST insertion
//

#define USBSER_ESCSTATE_DATA        1
#define USBSER_ESCSTATE_NODATA      2
#define USBSER_ESCSTATE_LINESTATUS  3

NTSTATUS
UsbSerGetRegistryKeyValue(IN HANDLE Handle, IN PWCHAR PKeyNameString,
                    IN ULONG KeyNameStringLength, IN PVOID PData,
                    IN ULONG DataLength);

VOID
UsbSerUndoExternalNaming(IN PDEVICE_EXTENSION PDevExt);

NTSTATUS
UsbSerDoExternalNaming(IN PDEVICE_EXTENSION PDevExt);

NTSTATUS
StartDevice(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
StopDevice(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
RemoveDevice(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
CreateDeviceObject(IN PDRIVER_OBJECT DriverObject,
               IN PDEVICE_OBJECT *DeviceObject,
               IN PCHAR DeviceName);

VOID
CompleteIO(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
         IN ULONG MajorFunction, IN PVOID IoBuffer,
         IN ULONG_PTR BufferLen);

NTSTATUS
DeleteObjectAndLink(IN PDEVICE_OBJECT DeviceObject);

VOID
StartPerfTimer(IN OUT PDEVICE_EXTENSION DeviceExtension);

VOID
StopPerfTimer(IN OUT PDEVICE_EXTENSION DeviceExtension,
            IN ULONG BytesXfered);

ULONG
BytesPerSecond(IN OUT PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
CallUSBD(IN PDEVICE_OBJECT DeviceObject, IN PURB Urb);

NTSTATUS
CallUSBD_SyncCompletionRoutine(IN PDEVICE_OBJECT   DeviceObject,
    						   IN PIRP             Irp,
    						   IN PVOID            Context);

NTSTATUS
GetDeviceDescriptor(IN PDEVICE_OBJECT DeviceObject);

NTSTATUS
ConfigureDevice(IN PDEVICE_OBJECT DeviceObject);

NTSTATUS
SelectInterface(IN PDEVICE_OBJECT DeviceObject,
            IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor);

PURB
BuildRequest(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
          IN USBD_PIPE_HANDLE PipeHandle, IN BOOLEAN Read);

VOID
BuildReadRequest(PURB Urb, PUCHAR Buffer, ULONG Length,
             IN USBD_PIPE_HANDLE PipeHandle, IN BOOLEAN Read);

NTSTATUS
ClassVendorCommand(IN PDEVICE_OBJECT DeviceObject, IN UCHAR Request,
                   IN USHORT Value, IN USHORT Index, IN PVOID Buffer,
                   IN OUT PULONG BufferLen, IN BOOLEAN Read, IN ULONG ComType);

VOID
CancelPendingWaitMasks(IN PDEVICE_EXTENSION DeviceExtension);

VOID
CancelPendingNotifyOrRead(IN PDEVICE_EXTENSION DeviceExtension,
                          IN BOOLEAN Notify);

VOID
StartRead(IN PDEVICE_EXTENSION DeviceExtension);

VOID
RestartRead(IN PDEVICE_EXTENSION DeviceExtension);

VOID
StartNotifyRead(IN PDEVICE_EXTENSION DeviceExtension);

VOID
RestartNotifyRead(IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
ReadCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);

ULONG
GetData(IN PDEVICE_EXTENSION DeviceExtension, IN PCHAR Buffer,
        IN ULONG BufferLen, IN OUT PULONG_PTR NewCount);

VOID
PutData(IN PDEVICE_EXTENSION DeviceExtension, IN ULONG BufferLen);

VOID
CheckForQueuedReads(IN PDEVICE_EXTENSION DeviceExtension);

NTSTATUS
UsbSerSyncCompletion(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN PKEVENT PUsbSerSyncEvent);

VOID
UsbSerFetchBooleanLocked(PBOOLEAN PDest, BOOLEAN Src,
                         PKSPIN_LOCK PSpinLock);

VOID
UsbSerFetchPVoidLocked(PVOID *PDest, PVOID Src, PKSPIN_LOCK PSpinLock);


VOID
UsbSerRundownIrpRefs(IN PIRP *PpCurrentOpIrp, IN PKTIMER IntervalTimer OPTIONAL,
                     IN PKTIMER TotalTimer OPTIONAL,
                     IN PDEVICE_EXTENSION PDevExt);

VOID
UsbSerGetNextIrp(IN PIRP *PpCurrentOpIrp, IN PLIST_ENTRY PQueueToProcess,
                 OUT PIRP *PpNextIrp, IN BOOLEAN CompleteCurrent,
                 IN PDEVICE_EXTENSION PDevExt);

NTSTATUS
UsbSerAbortPipes(IN PDEVICE_OBJECT PDevObj);

VOID
USBSER_RestartNotifyReadWorkItem(IN PDEVICE_OBJECT DeviceObject, IN PDEVICE_EXTENSION DeviceExtension);


#if DBG
PVOID
UsbSerLockPagableCodeSection(PVOID SecFunc);

#define UsbSerLockPagableSectionByHandle(_secHandle) \
{ \
    MmLockPagableSectionByHandle((_secHandle)); \
    InterlockedIncrement(&PAGEUSBSER_Count); \
}

#define UsbSerUnlockPagableImageSection(_secHandle) \
{ \
   InterlockedDecrement(&PAGEUSBSER_Count); \
   MmUnlockPagableImageSection(_secHandle); \
}

//
// Use if code can be called non-locked at lower irql
//

#define USBSER_LOCKED_PAGED_CODE() \
    if ((KeGetCurrentIrql() > APC_LEVEL)  \
    && (PAGEUSBSER_Count == 0)) { \
    KdPrint(("USBSER: Pageable code called at IRQL %d without lock \n", \
             KeGetCurrentIrql())); \
        ASSERT(FALSE); \
        }

//
// Use if code must always be locked; e.g., the function grabs a spinlock
//

#define USBSER_ALWAYS_LOCKED_CODE() \
    if (PAGEUSBSER_Count == 0) { \
      KdPrint(("USBSER: Pagable code raises IRQL called without lock\n")); \
      ASSERT(FALSE); \
    }

#define UsbSerAcquireSpinLock(_pLock, _pIrql) \
{ \
    ASSERTMSG(PAGEUSBSER_Count, "USBSER: Acquire spinlock without paging lock\n")); \
    KeAcquireSpinLock((_pLock), (_pIrql)); \
}

#define UsbSerReleaseSpinLock(_pLock, Irql) \
{ \
    ASSERTMSG(PAGEUSBSER_Count, "USBSER: Release spinlock and paging unlocked\n")); \
    KeReleaseSpinLock((_pLock), (_pIrql)); \
}

#else

#define UsbSerLockPagableCodeSection(_secFunc) \
   MmLockPagableCodeSection((_secFunc))

#define UsbSerLockPagableSectionByHandle(_secHandle) \
{ \
   MmLockPagableSectionByHandle((_secHandle)); \
}

#define UsbSerUnlockPagableImageSection(_secHandle) \
{ \
   MmUnlockPagableImageSection(_secHandle); \
}

#define USBSER_LOCKED_PAGED_CODE()

#define USBSER_ALWAYS_LOCKED_CODE()

#define UsbSerAcquireSpinLock(_pLock, _pIrql) \
   KeAcquireSpinLock((_pLock), (_pIrql))

#define UsbSerReleaseSpinLock(_pLock, Irql) \
   KeReleaseSpinLock((_pLock), (_pIrql))


#endif // DBG
#endif // __UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\usbserpw.h ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

   USBSERPW.H

Abstract:

   Header file for Power Management

Environment:

   kernel mode only

Notes:

   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
   KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
   PURPOSE.

   Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

   10/29/98 : created

Authors:

   Tom Green

   
****************************************************************************/


#ifndef __USBSERPW_H__
#define __USBSERPW_H__

NTSTATUS
UsbSer_ProcessPowerIrp(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
UsbSer_PoRequestCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction,
                           IN POWER_STATE PowerState, IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus);


NTSTATUS
UsbSer_PowerIrp_Complete(IN PDEVICE_OBJECT NullDeviceObject, IN PIRP Irp, IN PVOID Context);

NTSTATUS
UsbSer_SelfSuspendOrActivate(IN PDEVICE_OBJECT DeviceObject, IN BOOLEAN Suspend);

NTSTATUS
UsbSer_SelfRequestPowerIrp(IN PDEVICE_OBJECT DeviceObject, IN POWER_STATE PowerState);

NTSTATUS
UsbSer_PoSelfRequestCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction, IN POWER_STATE PowerState,
                               IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus);

BOOLEAN
UsbSer_SetDevicePowerState(IN PDEVICE_OBJECT DeviceObject, IN DEVICE_POWER_STATE DeviceState);

NTSTATUS
UsbSerQueryCapabilities(IN PDEVICE_OBJECT DeviceObject, IN PDEVICE_CAPABILITIES DeviceCapabilities);

NTSTATUS
UsbSerIrpCompletionRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);

NTSTATUS
UsbSerWaitWakeIrpCompletionRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);


NTSTATUS
UsbSerSendWaitWake(PDEVICE_EXTENSION DeviceExtension);

VOID
UsbSerFdoIdleNotificationCallback(IN PDEVICE_EXTENSION DevExt);

NTSTATUS
UsbSerFdoIdleNotificationRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_EXTENSION DevExt
    );

NTSTATUS
UsbSerFdoSubmitIdleRequestIrp(IN PDEVICE_EXTENSION DevExt);

VOID
UsbSerFdoRequestWake(IN PDEVICE_EXTENSION DevExt);


#endif // __USBSERPW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\usbserpw.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    USBSERPW.C

Abstract:

    Power Management module


Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1997-1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

    10/29/98 : created

Authors:

        Tom Green

--*/


#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "usbserpw.h"
#include "serioctl.h"
#include "utils.h"
#include "debugwdm.h"

//
// Power code is not pagable since we do not set DO_POWER_PAGABLE
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEUSBS, UsbSerSendWaitWake)
#endif // ALLOC_PRAGMA

/*++

Routine Description:

    This routine handles completion of the waitwake IRP.

Arguments:

    DeviceObject - Pointer to the device object for this device

    MinorFunction - Minor function previously supplied to PoRequestPowerIrp

    PowerState - PowerState previously supplied to PoRequestPowerIrp

    Context - a pointer to the device extension

    IoStatus - current/final status of the waitwake IRP

Return Value:

    The function value is the final status of attempting to process the
    waitwake.


--*/
NTSTATUS
UsbSerWakeCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction,
                     IN POWER_STATE PowerState, IN PVOID Context,
                     IN PIO_STATUS_BLOCK IoStatus)
{
   NTSTATUS             Status;
   PDEVICE_EXTENSION    DeviceExtension = (PDEVICE_EXTENSION)Context;
   POWER_STATE          NewPowerState;

   DEBUG_TRACE1(("UsbSerWakeCompletion\n"));

   DEBUG_TRACE1(("Status (%08X)\n", IoStatus->Status));

   Status = IoStatus->Status;

   if(NT_SUCCESS(Status))
   {
      //
      // A wakeup has occurred -- powerup our stack
      //

      DEBUG_TRACE1(("Powerup Device\n"));

      NewPowerState.DeviceState = PowerDeviceD0;

      PoRequestPowerIrp(DeviceExtension->PhysDeviceObject,
                        IRP_MN_SET_POWER, NewPowerState,
                        NULL, NULL, NULL);

   }

   DeviceExtension->PendingWakeIrp = NULL;

   return Status;
} // UsbSerWakeCompletion


/*++

Routine Description:

    This routine causes a waitwake IRP to be sent

Arguments:

    DeviceExtension - Pointer to the device extension for this device

Return Value:

    STATUS_INVALID_DEVICE_STATE if one is already pending, else result
    of call to PoRequestPowerIrp.


--*/
NTSTATUS
UsbSerSendWaitWake(PDEVICE_EXTENSION DeviceExtension)
{
   NTSTATUS     Status;
   PIRP         Irp;
   POWER_STATE  PowerState;

   USBSER_LOCKED_PAGED_CODE();

   DEBUG_TRACE1(("UsbSerSendWaitWake\n"));

   //
   // Make sure one isn't pending already -- usbser will only handle one at
   // a time.
   //

   if(DeviceExtension->PendingWakeIrp != NULL)
   {
      return STATUS_INVALID_DEVICE_STATE;
   }

   //
   // Make sure we are capable of waking the machine
   //

   if(DeviceExtension->SystemWake <= PowerSystemWorking)
   {
      return STATUS_INVALID_DEVICE_STATE;
   }

   if(DeviceExtension->DeviceWake == PowerDeviceUnspecified)
   {
      return STATUS_INVALID_DEVICE_STATE;
   }

   //
   // Send IRP to request wait wake
   //
   //

   DEBUG_TRACE1(("Request Wait Wake\n"));

   PowerState.SystemState = DeviceExtension->SystemWake;

   Status = PoRequestPowerIrp(DeviceExtension->PhysDeviceObject, IRP_MN_WAIT_WAKE,
                              PowerState, UsbSerWakeCompletion, DeviceExtension, &Irp);

   if(Status == STATUS_PENDING)
   {
      Status = STATUS_SUCCESS;
      DeviceExtension->PendingWakeIrp = Irp;
   }

   return Status;
} // UsbSerSendWaitWake


/*++

Routine Description:

    This is our FDO's dispatch table function for IRP_MJ_POWER.
    It processes the Power IRPs sent to the PDO for this device.

    For every power IRP, drivers must call PoStartNextPowerIrp and use PoCallDriver
    to pass the IRP all the way down the driver stack to the underlying PDO.


Arguments:

    DeviceObject - pointer to our device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
NTSTATUS
UsbSer_ProcessPowerIrp(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PIO_STACK_LOCATION      IrpStack;
    NTSTATUS                Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       DeviceExtension;
    BOOLEAN                 GoingToD0 = FALSE;
    POWER_STATE             SysPowerState, DesiredDevicePowerState;

    DEBUG_LOG_PATH("enter UsbSer_ProcessPowerIrp");

    DEBUG_TRACE1(("UsbSer_ProcessPowerIrp\n"));

    DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    switch(IrpStack->MinorFunction)
    {
        case IRP_MN_WAIT_WAKE:
            DEBUG_TRACE1(("IRP_MN_WAIT_WAKE\n"));

            // A driver sends IRP_MN_WAIT_WAKE to indicate that the system should
            // wait for its device to signal a wake event. The exact nature of the event
            // is device-dependent.
            // Drivers send this IRP for two reasons:
            // 1) To allow a device to wake the system
            // 2) To wake a device that has been put into a sleep state to save power
            //    but still must be able to communicate with its driver under certain circumstances.
            // When a wake event occurs, the driver completes the IRP and returns
            // STATUS_SUCCESS. If the device is sleeping when the event occurs,
            // the driver must first wake up the device before completing the IRP.
            // In a completion routine, the driver calls PoRequestPowerIrp to send a
            // PowerDeviceD0 request. When the device has powered up, the driver can
            //  handle the IRP_MN_WAIT_WAKE request.

            // DeviceCapabilities.DeviceWake specifies the lowest device power state (least powered)
            // from which the device can signal a wake event
            DeviceExtension->PowerDownLevel = DeviceExtension->DeviceWake;

            DEBUG_TRACE1(("CurrentDevicePowerState (%08X)  DeviceWakeup (%08X)\n",
                          DeviceExtension->CurrentDevicePowerState,
                          DeviceExtension->DeviceWake));

            if((PowerDeviceD0 == DeviceExtension->CurrentDevicePowerState) ||
              (DeviceExtension->DeviceWake > DeviceExtension->CurrentDevicePowerState))
            {
                //
                //    STATUS_INVALID_DEVICE_STATE is returned if the device in the PowerD0 state
                //    or a state below which it can support waking, or if the SystemWake state
                //    is below a state which can be supported. A pending IRP_MN_WAIT_WAKE will complete
                //    with this error if the device's state is changed to be incompatible with the wake
                //    request.

                //  If a driver fails this IRP, it should complete the IRP immediately without
                //  passing the IRP to the next-lower driver.
                Status = STATUS_INVALID_DEVICE_STATE;
                Irp->IoStatus.Status = Status;
                PoStartNextPowerIrp(Irp);
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
                return Status;
            }

            // If not failing outright, pass this on to our PDO for further handling
            IoCopyCurrentIrpStackLocationToNext(Irp);

            // Set a completion routine so it can signal our event when
            // the PDO is done with the Irp
            IoSetCompletionRoutine(Irp,
                                   UsbSerWaitWakeIrpCompletionRoutine,
                                   DeviceObject,// pass the event to the completion routine as the Context
                                   TRUE,        // invoke on success
                                   TRUE,        // invoke on error
                                   TRUE);       // invoke on cancellation

            DEBUG_TRACE1(("Send down wait wake\n"));

            PoStartNextPowerIrp(Irp);
            Status = PoCallDriver(DeviceExtension->StackDeviceObject,
                                  Irp);

            Status = STATUS_PENDING;

            break;

        case IRP_MN_SET_POWER:
        {

            DEBUG_TRACE1(("IRP_MN_SET_POWER\n"));

            // The system power policy manager sends this IRP to set the system power state.
            // A device power policy manager sends this IRP to set the device power state for a device.

            // Set Irp->IoStatus.Status to STATUS_SUCCESS to indicate that the device
            // has entered the requested state. Drivers cannot fail this IRP.

            switch(IrpStack->Parameters.Power.Type)
            {
                case SystemPowerState:
                    DEBUG_TRACE1(("SystemPowerState\n"));

                    // Get input system power state
                    SysPowerState.SystemState = IrpStack->Parameters.Power.State.SystemState;

                    DEBUG_TRACE1(("SystemState (%08X)\n", SysPowerState.SystemState));

#if DBG
                    {
                        ULONG Index;

                        for(Index = 0; Index < 8; Index++)
                        {
                            DEBUG_TRACE1(("DeviceState[%08X] (%08X)\n", Index,
                                           DeviceExtension->DeviceCapabilities.DeviceState[Index]));
                        }

                        DEBUG_TRACE1(("DeviceWake (%08X)\n", DeviceExtension->DeviceCapabilities.DeviceWake));
                        DEBUG_TRACE1(("SystemWake (%08X)\n", DeviceExtension->DeviceCapabilities.SystemWake));
                            
                        
                    }
#endif
                    // If system is in working state always set our device to D0
                    //  regardless of the wait state or system-to-device state power map
                    if(SysPowerState.SystemState == PowerSystemWorking)
                    {
                      DEBUG_TRACE1(("Setting to D0\n"));
                      DesiredDevicePowerState.DeviceState = PowerDeviceD0;
                    }
                    else
                    {
                        // set to corresponding system state if IRP_MN_WAIT_WAKE pending
                        if(DeviceExtension->SendWaitWake)
                        {
                            // got a WAIT_WAKE IRP pending?

                            DEBUG_TRACE1(("We want to send a wait wake Irp\n"));
                            
                            // Find the device power state equivalent to the given system state.
                            // We get this info from the DEVICE_CAPABILITIES struct in our device
                            // extension (initialized in UsbSer_PnPAddDevice() )
                            DesiredDevicePowerState.DeviceState =
                                DeviceExtension->DeviceCapabilities.DeviceState[SysPowerState.SystemState];

                        }
                        else
                        {
                            DEBUG_TRACE1(("No wait wake Irp to send\n"));

                            // if no wait pending and the system's not in working state, just turn off
                            DesiredDevicePowerState.DeviceState = PowerDeviceD3;

                        }
                    }

                    DEBUG_TRACE1(("DesiredDevicePowerState (%08X)\n", DesiredDevicePowerState.DeviceState));

                    //
                    // We've determined the desired device state; are we already in this state?
                    //

                    if(DesiredDevicePowerState.DeviceState !=
                        DeviceExtension->CurrentDevicePowerState)
                    {

                        // No, request that we be put into this state
                        // by requesting a new Power Irp from the Pnp manager
                        DeviceExtension->PowerIrp = Irp;
                        Status = PoRequestPowerIrp(DeviceExtension->PhysDeviceObject,
                                                   IRP_MN_SET_POWER,
                                                   DesiredDevicePowerState,
                                                   UsbSer_PoRequestCompletion,
                                                   DeviceObject,
                                                   NULL);

                    }
                    else
                    {
                        // Yes, just pass it on to PDO (Physical Device Object)
                        IoCopyCurrentIrpStackLocationToNext(Irp);
                        PoStartNextPowerIrp(Irp);
                        Status = PoCallDriver(DeviceExtension->StackDeviceObject,
                                              Irp);

                    }
                    break;

                case DevicePowerState:

                    DEBUG_TRACE1(("DevicePowerState\n"));

                    // For requests to D1, D2, or D3 ( sleep or off states ),
                    // sets deviceExtension->CurrentDevicePowerState to DeviceState immediately.
                    // This enables any code checking state to consider us as sleeping or off
                    // already, as this will imminently become our state.

                    // For requests to DeviceState D0 ( fully on ), sets fGoingToD0 flag TRUE
                    // to flag that we must set a completion routine and update
                    // deviceExtension->CurrentDevicePowerState there.
                    // In the case of powering up to fully on, we really want to make sure
                    // the process is completed before updating our CurrentDevicePowerState,
                    // so no IO will be attempted or accepted before we're really ready.


                    GoingToD0 = UsbSer_SetDevicePowerState(DeviceObject,
                                                           IrpStack->Parameters.Power.State.DeviceState);

                    IoCopyCurrentIrpStackLocationToNext(Irp);

                    if(GoingToD0)
                    {
                        IoSetCompletionRoutine(Irp,
                                               UsbSer_PowerIrp_Complete,
                                               DeviceObject,
                                               TRUE,            // invoke on success
                                               TRUE,            // invoke on error
                                               TRUE);           // invoke on cancellation of the Irp
                    }

                    PoStartNextPowerIrp(Irp);
                    Status = PoCallDriver(DeviceExtension->StackDeviceObject,
                                          Irp);

                    break;
                } /* case irpStack->Parameters.Power.Type */

            }
            break; /* IRP_MN_SET_POWER */

        case IRP_MN_QUERY_POWER:
            DEBUG_TRACE1(("IRP_MN_QUERY_POWER\n"));
            //
            // A power policy manager sends this IRP to determine whether it can change
            // the system or device power state, typically to go to sleep.
            //

            if(DeviceExtension->SendWaitWake)
            {
                if(IrpStack->Parameters.Power.Type == SystemPowerState
                   && DeviceExtension->DeviceCapabilities.DeviceState[IrpStack->Parameters.Power.State.SystemState]
                   > DeviceExtension->DeviceWake)
                {
                    Status = Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
                    PoStartNextPowerIrp(Irp);
                    IoCompleteRequest(Irp, IO_NO_INCREMENT);
                    break;
                }
            }
            else
            {
                IoCopyCurrentIrpStackLocationToNext(Irp);
                PoStartNextPowerIrp(Irp);
                Status = PoCallDriver(DeviceExtension->StackDeviceObject,
                                      Irp);
                break;
            }

            // fall through to default

        default:

            //
            // All unhandled power messages are passed on to the PDO
            //

            IoCopyCurrentIrpStackLocationToNext(Irp);
            PoStartNextPowerIrp(Irp);
            Status = PoCallDriver(DeviceExtension->StackDeviceObject, Irp);

    } /* IrpStack->MinorFunction */

    DEBUG_LOG_PATH("exit  UsbSer_ProcessPowerIrp");

    return Status;
} // UsbSer_ProcessPowerIrp


/*++

Routine Description:

        This is the completion routine set in a call to PoRequestPowerIrp()
        that was made in BulkUsb_ProcessPowerIrp() in response to receiving
        an IRP_MN_SET_POWER of type 'SystemPowerState' when the device was
        not in a compatible device power state. In this case, a pointer to
        the IRP_MN_SET_POWER Irp is saved into the FDO device extension
        (deviceExtension->PowerIrp), and then a call must be
        made to PoRequestPowerIrp() to put the device into a proper power state,
        and this routine is set as the completion routine.

    We decrement our pending io count and pass the saved IRP_MN_SET_POWER Irp
        on to the next driver

Arguments:

    DeviceObject - Pointer to the device object for the class device.
        Note that we must get our own device object from the Context

    Context - Driver defined context, in this case our own functional device object ( FDO )

Return Value:

    The function value is the final status from the operation.

--*/
NTSTATUS
UsbSer_PoRequestCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction,
                           IN POWER_STATE PowerState, IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus)
{
    PIRP                Irp;
    PDEVICE_EXTENSION   DeviceExtension;
    PDEVICE_OBJECT      ContextDeviceObject = Context;
    NTSTATUS            Status;

    DEBUG_LOG_PATH("enter UsbSer_PoRequestCompletion");

    DEBUG_TRACE1(("UsbSer_PoRequestCompletion\n"));

    DeviceExtension = ContextDeviceObject->DeviceExtension;

    // Get the Irp we saved for later processing in Usbser_ProcessPowerIrp()
    // when we decided to request the Power Irp that this routine
    // is the completion routine for.
    Irp = DeviceExtension->PowerIrp;

    // We will return the status set by the PDO for the power request we're completing
    Status = IoStatus->Status;

    // we must pass down to the next driver in the stack
    IoCopyCurrentIrpStackLocationToNext(Irp);

    // Calling PoStartNextPowerIrp() indicates that the driver is finished
    // with the previous power IRP, if any, and is ready to handle the next power IRP.
    // It must be called for every power IRP.Although power IRPs are completed only once,
    // typically by the lowest-level driver for a device, PoStartNextPowerIrp must be called
    // for every stack location. Drivers must call PoStartNextPowerIrp while the current IRP
    // stack location points to the current driver. Therefore, this routine must be called
    // before IoCompleteRequest, IoSkipCurrentStackLocation, and PoCallDriver.

    PoStartNextPowerIrp(Irp);

    // PoCallDriver is used to pass any power IRPs to the PDO instead of IoCallDriver.
    // When passing a power IRP down to a lower-level driver, the caller should use
    // IoSkipCurrentIrpStackLocation or IoCopyCurrentIrpStackLocationToNext to copy the IRP to
    // the next stack location, then call PoCallDriver. Use IoCopyCurrentIrpStackLocationToNext
    // if processing the IRP requires setting a completion routine, or IoSkipCurrentStackLocation
    // if no completion routine is needed.

    PoCallDriver(DeviceExtension->StackDeviceObject,
                 Irp);

    DeviceExtension->PowerIrp = NULL;

    DEBUG_LOG_PATH("exit  UsbSer_PoRequestCompletion");

    return Status;
} // UsbSer_PoRequestCompletion




/*++

Routine Description:

    This routine is called when An IRP_MN_SET_POWER of type 'DevicePowerState'
    has been received by Usbser_ProcessPowerIrp(), and that routine has  determined
        1) the request is for full powerup ( to PowerDeviceD0 ), and
        2) We are not already in that state
    A call is then made to PoRequestPowerIrp() with this routine set as the completion routine.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
NTSTATUS
UsbSer_PowerIrp_Complete(IN PDEVICE_OBJECT NullDeviceObject, IN PIRP Irp, IN PVOID Context)
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PDEVICE_OBJECT      DeviceObject;
    PIO_STACK_LOCATION  IrpStack;
    PDEVICE_EXTENSION   DeviceExtension;
    KIRQL               OldIrql;

    DEBUG_LOG_PATH("enter UsbSer_PowerIrp_Complete");

    DEBUG_TRACE1(("UsbSer_PowerIrp_Complete\n"));

    DeviceObject = (PDEVICE_OBJECT) Context;

    DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //  If the lower driver returned PENDING, mark our stack location as pending also.
    if(Irp->PendingReturned)
    {
        IoMarkIrpPending(Irp);
    }

    IrpStack = IoGetCurrentIrpStackLocation (Irp);


    // Now that we know we've let the lower drivers do what was needed to power up,
    // we can set our device extension flags accordingly

    ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

    DeviceExtension->CurrentDevicePowerState = PowerDeviceD0;
    DeviceExtension->AcceptingRequests		 = TRUE;

    RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

    //
    // Restart the read and notify which we stopped when we powered down
    //

    RestartRead(DeviceExtension);
    RestartNotifyRead(DeviceExtension);

    UsbSerRestoreModemSettings(DeviceObject);

    Irp->IoStatus.Status = Status;

    DEBUG_LOG_PATH("exit  UsbSer_PowerIrp_Complete");

    return Status;
} // UsbSer_PowerIrp_Complete



/*++

Routine Description:

        Called on Usbser_PnPAddDevice() to power down until needed (i.e., till a pipe is actually opened).
        Called on Usbser_Create() to power up device to D0 before opening 1st pipe.
        Called on Usbser_Close() to power down device if this is the last pipe.

Arguments:

    DeviceObject - Pointer to the device object

    Suspend; TRUE to Suspend, FALSE to acivate.


Return Value:

    If the operation is not attemtped, SUCCESS is returned.
    If the operation is attemtped, the value is the final status from the operation.

--*/
NTSTATUS
UsbSer_SelfSuspendOrActivate(IN PDEVICE_OBJECT DeviceObject, IN BOOLEAN Suspend)
{
    NTSTATUS            Status = STATUS_SUCCESS;
    POWER_STATE         PowerState;
    PDEVICE_EXTENSION   DeviceExtension;

    DEBUG_LOG_PATH("enter UsbSer_SelfSuspendOrActivate");

    DEBUG_TRACE1(("UsbSer_SelfSuspendOrActivate\n"));

    DeviceExtension = DeviceObject->DeviceExtension;

    // Can't accept request if:
    //  1) device is removed,
    //  2) has never been started,
    //  3) is stopped,
    //  4) has a remove request pending,
    //  5) has a stop device pending
    if(!DeviceExtension->AcceptingRequests)
    {
        Status = STATUS_DELETE_PENDING;

        return Status;
    }


    // don't do anything if any System-generated Device Pnp irps are pending
    if(NULL != DeviceExtension->PowerIrp )
    {
        return Status;
    }

    // don't do anything if any self-generated Device Pnp irps are pending
    if(DeviceExtension->SelfPowerIrp )
    {
        return Status;
    }

    // dont do anything if registry CurrentControlSet\Services\BulkUsb\Parameters\PowerDownLevel
    //  has been set to  zero, PowerDeviceD0 ( 1 ), or a bogus high value
    if((DeviceExtension->PowerDownLevel == PowerDeviceD0) ||
        (DeviceExtension->PowerDownLevel == PowerDeviceUnspecified)  ||
        (DeviceExtension->PowerDownLevel >= PowerDeviceMaximum))
    {
        return Status;
    }

    if(Suspend)
        PowerState.DeviceState = DeviceExtension->PowerDownLevel;
    else
        PowerState.DeviceState = PowerDeviceD0;  // power up all the way; we're probably just about to do some IO

    Status = UsbSer_SelfRequestPowerIrp(DeviceObject, PowerState);

    DEBUG_LOG_PATH("exit  UsbSer_SelfSuspendOrActivate");

    return Status;
} // UsbSer_SelfSuspendOrActivate


/*++

Routine Description:

    This routine is called by UsbSer_SelfSuspendOrActivate() to
    actually make the system request for a powerdown/up to PowerState.
    It first checks to see if we are already in Powerstate and immediately
    returns  SUCCESS with no further processing if so


Arguments:

    DeviceObject - Pointer to the device object

    PowerState. power state requested, e.g PowerDeviceD0.


Return Value:

    The function value is the final status from the operation.

--*/
NTSTATUS
UsbSer_SelfRequestPowerIrp(IN PDEVICE_OBJECT DeviceObject, IN POWER_STATE PowerState)
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIRP                Irp = NULL;

    DEBUG_LOG_PATH("enter UsbSer_SelfRequestPowerIrp");

    DEBUG_TRACE1(("UsbSer_SelfRequestPowerIrp\n"));

    DeviceExtension =  DeviceObject->DeviceExtension;

    if(DeviceExtension->CurrentDevicePowerState == PowerState.DeviceState)
        return STATUS_SUCCESS;  // nothing to do


    // flag we're handling a self-generated power irp
    DeviceExtension->SelfPowerIrp = TRUE;

    // actually request the Irp
    Status = PoRequestPowerIrp(DeviceExtension->PhysDeviceObject,
                               IRP_MN_SET_POWER,
                               PowerState,
                               UsbSer_PoSelfRequestCompletion,
                               DeviceObject,
                               NULL);


    if(Status == STATUS_PENDING)
    {
        // status pending is the return code we wanted

        // We only need to wait for completion if we're powering up
        if((ULONG) PowerState.DeviceState < DeviceExtension->PowerDownLevel)
        {
            NTSTATUS WaitStatus;

            WaitStatus = KeWaitForSingleObject(&DeviceExtension->SelfRequestedPowerIrpEvent,
                                               Suspended,
                                               KernelMode,
                                               FALSE,
                                               NULL);

        }

        Status = STATUS_SUCCESS;

        DeviceExtension->SelfPowerIrp = FALSE;

    }
    else
    {
        // The return status was not STATUS_PENDING; any other codes must be considered in error here;
        //  i.e., it is not possible to get a STATUS_SUCCESS  or any other non-error return from this call;
    }

    DEBUG_LOG_PATH("exit  UsbSer_SelfRequestPowerIrp");

    return Status;
} // UsbSer_SelfRequestPowerIrp



/*++

Routine Description:

    This routine is called when the driver completes a self-originated power IRP
        that was generated by a call to BulkUsb_SelfSuspendOrActivate().
    We power down whenever the last pipe is closed and power up when the first pipe is opened.

    For power-up , we set an event in our FDO extension to signal this IRP done
    so the power request can be treated as a synchronous call.
    We need to know the device is powered up before opening the first pipe, for example.
    For power-down, we do not set the event, as no caller waits for powerdown complete.

Arguments:

    DeviceObject - Pointer to the device object for the class device. ( Physical Device Object )

    Context - Driver defined context, in this case our FDO ( functional device object )

Return Value:

    The function value is the final status from the operation.

--*/
NTSTATUS
UsbSer_PoSelfRequestCompletion(IN PDEVICE_OBJECT DeviceObject, IN UCHAR MinorFunction, IN POWER_STATE          PowerState,
                               IN PVOID Context, IN PIO_STATUS_BLOCK IoStatus)
{
    PDEVICE_OBJECT      ContextDeviceObject = Context;
    PDEVICE_EXTENSION   DeviceExtension = ContextDeviceObject->DeviceExtension;
    NTSTATUS            Status = IoStatus->Status;

    DEBUG_LOG_PATH("enter UsbSer_PoSelfRequestCompletion");

    DEBUG_TRACE1(("UsbSer_PoSelfRequestCompletion\n"));

    // We only need to set the event if we're powering up;
    // No caller waits on power down complete
    if((ULONG) PowerState.DeviceState < DeviceExtension->PowerDownLevel)
    {

        // Trigger Self-requested power irp completed event;
        // The caller is waiting for completion
        KeSetEvent(&DeviceExtension->SelfRequestedPowerIrpEvent, 1, FALSE);
    }

    DEBUG_LOG_PATH("exit  UsbSer_PoSelfRequestCompletion");

    return Status;
} // UsbSer_PoSelfRequestCompletion


/*++

Routine Description:

    This routine is called when An IRP_MN_SET_POWER of type 'DevicePowerState'
    has been received by Usbser_ProcessPowerIrp().


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    DeviceState - Device specific power state to set the device in to.


Return Value:

    For requests to DeviceState D0 ( fully on ), returns TRUE to signal caller
    that we must set a completion routine and finish there.

--*/
BOOLEAN
UsbSer_SetDevicePowerState(IN PDEVICE_OBJECT DeviceObject, IN DEVICE_POWER_STATE DeviceState)
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    BOOLEAN             Res = FALSE;
    KIRQL               OldIrql;
    POWER_STATE         State;

    DEBUG_LOG_PATH("enter UsbSer_SetDevicePowerState");

    DEBUG_TRACE1(("UsbSer_SetDevicePowerState\n"));

    DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    State.DeviceState = DeviceState;

    switch(DeviceState)
    {
        case PowerDeviceD3:
            DEBUG_TRACE1(("PowerDeviceD3\n"));

            //
            // Device will be going OFF,
            //

            ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
            DeviceExtension->CurrentDevicePowerState = DeviceState;
            RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

            UsbSerAbortPipes(DeviceObject);

            break;

        case PowerDeviceD1:
            DEBUG_TRACE1(("PowerDeviceD1\n"));
        case PowerDeviceD2:
            DEBUG_TRACE1(("PowerDeviceD2\n"));
            //
            // power states D1, D2 translate to USB suspend

            ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
            DeviceExtension->CurrentDevicePowerState = DeviceState;
            RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

            UsbSerAbortPipes(DeviceObject);

            if(DeviceExtension->SendWaitWake && DeviceState <= DeviceExtension->DeviceWake)
            {
                UsbSerSendWaitWake(DeviceExtension);
            }

            break;

        case PowerDeviceD0:
            DEBUG_TRACE1(("PowerDevice0\n"));


            // We'll need to finish the rest in the completion routine;
            // signal caller we're going to D0 and will need to set a completion routine
            Res = TRUE;

            // Caller will pass on to PDO ( Physical Device object )
            break;

        default:
            break;
    }

    PoSetPowerState(DeviceObject, DevicePowerState, State);

    DEBUG_LOG_PATH("exit  UsbSer_SetDevicePowerState");

    return Res;
} // UsbSer_SetDevicePowerState



NTSTATUS
UsbSerQueryCapabilities(IN PDEVICE_OBJECT DeviceObject, IN PDEVICE_CAPABILITIES DeviceCapabilities)
{
    PIO_STACK_LOCATION  NextStack;
    PIRP                Irp;
    NTSTATUS            NtStatus;
    KEVENT              Event;

    DEBUG_LOG_PATH("enter UsbSerQueryCapabilities");

    DEBUG_TRACE1(("UsbSerQueryCapabilities\n"));

    // Build an IRP for us to generate an internal query request to the PDO
    Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if(!Irp)
        return STATUS_INSUFFICIENT_RESOURCES;


    NextStack = IoGetNextIrpStackLocation(Irp);

    NextStack->MajorFunction= IRP_MJ_PNP;
    NextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;


    // init an event to tell us when the completion routine's been called
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    // Set a completion routine so it can signal our event when
    //  the next lower driver is done with the Irp
    IoSetCompletionRoutine(Irp,
                           UsbSerIrpCompletionRoutine,
                           &Event,  // pass the event as Context to completion routine
                           TRUE,    // invoke on success
                           TRUE,    // invoke on error
                           TRUE);   // invoke on cancellation of the Irp


    // init Irp and query struct
    Irp->IoStatus.Status                    = STATUS_NOT_SUPPORTED;

    RtlZeroMemory(DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));

    DeviceCapabilities->Version             = DEVICE_CAP_VERSION;
    DeviceCapabilities->Size                = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Address             = DEVICE_CAP_UNUSED_PARAM;
    DeviceCapabilities->UINumber            = DEVICE_CAP_UNUSED_PARAM;
    DeviceCapabilities->SurpriseRemovalOK   = TRUE;
    
    // set our pointer to the DEVICE_CAPABILITIES struct
    NextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    NtStatus = IoCallDriver(DeviceObject, Irp);

    if(NtStatus == STATUS_PENDING)
    {
       // wait for irp to complete

       KeWaitForSingleObject(
            &Event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);
    }

    IoFreeIrp(Irp);

    DEBUG_LOG_PATH("exit  UsbSerQueryCapabilities");

    return NtStatus;
} // UsbSerQueryCapabilities




NTSTATUS
UsbSerIrpCompletionRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PKEVENT Event = Context;

    DEBUG_LOG_PATH("enter UsbSerIrpCompletionRoutine");

    DEBUG_TRACE1(("UsbSerIrpCompletionRoutine\n"));

    // Set the input event
    KeSetEvent(Event,
               1,       // Priority increment  for waiting thread.
               FALSE);  // Flag this call is not immediately followed by wait.

    DEBUG_LOG_PATH("exit  UsbSerIrpCompletionRoutine");

    return STATUS_MORE_PROCESSING_REQUIRED;
} // UsbSerIrpCompletionRoutine

NTSTATUS
UsbSerWaitWakeIrpCompletionRoutine(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
    PDEVICE_OBJECT      DevObj = Context;
    PDEVICE_EXTENSION   DevExt = DevObj->DeviceExtension;
    NTSTATUS            Status;

    DEBUG_LOG_PATH("enter UsbSerWaitWakeIrpCompletionRoutine");

    DEBUG_TRACE1(("UsbSerWaitWakeIrpCompletionRoutine\n"));

    DEBUG_TRACE1(("Status (%08X)\n", Irp->IoStatus.Status));

    DEBUG_TRACE1(("Tell device to wake up\n"));

    // // now tell the device to actually wake up
    // UsbSer_SelfSuspendOrActivate(DevObj, FALSE);

    Status = Irp->IoStatus.Status;

    PoStartNextPowerIrp(Irp);
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DEBUG_LOG_PATH("exit  UsbSerWaitWakeIrpCompletionRoutine");

    return STATUS_MORE_PROCESSING_REQUIRED;
} // UsbSerWaitWakeIrpCompletionRoutine



VOID
UsbSerFdoIdleNotificationCallback(IN PDEVICE_EXTENSION DevExt)
/*++

Routine Description:

    Called when it is time to idle out USB Modem


--*/
{
    POWER_STATE 	powerState;
    NTSTATUS 		ntStatus;

    DEBUG_TRACE1(("USB Modem (%08X) going idle\n", DevExt));

    if(DevExt->DeviceState == DEVICE_STATE_STOPPED || DevExt->OpenCnt) 
    {

        // Don't idle this modem if it is being stopped, or someone opened it

        DEBUG_TRACE1(("USB Modem (%08X) being stopped, abort idle\n", DevExt));
        return;
    }


    powerState.DeviceState = DevExt->DeviceWake;

	// request new device power state, wait wake Irp will be posted on request
    PoRequestPowerIrp(DevExt->PhysDeviceObject,
                      IRP_MN_SET_POWER,
                      powerState,
                      NULL,
                      NULL,
                      NULL);

} // UsbSerFdoIdleNotificationCallback


NTSTATUS
UsbSerFdoIdleNotificationRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_EXTENSION DevExt
    )
/*++

Routine Description:

    Completion routine for the Idle request IRP for the USB Modem device

--*/
{
    NTSTATUS 					ntStatus;
    PUSB_IDLE_CALLBACK_INFO 	idleCallbackInfo;

    //
    // DeviceObject is NULL because we sent the irp
    //
    UNREFERENCED_PARAMETER(DeviceObject);

    DEBUG_TRACE1(("Idle notification IRP for USB Modem (%08X) completed (%08X)\n",
            DevExt, Irp->IoStatus.Status));

	// save completion status in device extension
    idleCallbackInfo 			= DevExt->IdleCallbackInfo;
    DevExt->IdleCallbackInfo 	= NULL;
    DevExt->PendingIdleIrp 		= NULL;

	// free up callback info
    if(idleCallbackInfo) 
    {
        DEBUG_MEMFREE(idleCallbackInfo);
    }

    ntStatus = Irp->IoStatus.Status;

    return ntStatus;
} // UsbSerFdoIdleNotificationRequestComplete


NTSTATUS
UsbSerFdoSubmitIdleRequestIrp(IN PDEVICE_EXTENSION DevExt)
/*++

Routine Description:

    Called when all handles to the USB modem are closed. This function allocates 
    an idle request IOCTL IRP and passes it to the parent's PDO.

--*/
{
    PIRP 					irp = NULL;
    NTSTATUS 				ntStatus = STATUS_SUCCESS;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo = NULL;

    DEBUG_TRACE1(("UsbSerFdoSubmitIdleRequestIrp (%08X)\n", DevExt));

    // if we have an Irp pending, or we are already idled, don't bother to send another
    if(DevExt->PendingIdleIrp || DevExt->CurrentDevicePowerState == DevExt->DeviceWake)
        return ntStatus;

    idleCallbackInfo = DEBUG_MEMALLOC(NonPagedPool,
        							  sizeof(struct _USB_IDLE_CALLBACK_INFO));

    if (idleCallbackInfo) 
    {

        idleCallbackInfo->IdleCallback 	= UsbSerFdoIdleNotificationCallback;
        idleCallbackInfo->IdleContext 	= (PVOID)DevExt;

        DevExt->IdleCallbackInfo = idleCallbackInfo;

        irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION,
                DevExt->PhysDeviceObject,
                idleCallbackInfo,
                sizeof(struct _USB_IDLE_CALLBACK_INFO),
                NULL,
                0,
                TRUE, /* INTERNAL */
                NULL,
                &DevExt->StatusBlock);

        if (irp == NULL) 
        {
        
            DEBUG_MEMFREE(idleCallbackInfo);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoSetCompletionRoutine(irp,
                               UsbSerFdoIdleNotificationRequestComplete,
                               DevExt,
                               TRUE,
                               TRUE,
                               TRUE);

        ntStatus = IoCallDriver(DevExt->PhysDeviceObject, irp);

        if(ntStatus == STATUS_PENDING) 
        {
            DEBUG_TRACE1(("USB Modem (%08X) Idle Irp Pending\n", DevExt));
            
            // Successfully posted an Idle IRP.

            DevExt->PendingIdleIrp 	= irp;
        }
    }

    return ntStatus;
} // UsbSerFdoSubmitIdleRequestIrp

VOID
UsbSerFdoRequestWake(IN PDEVICE_EXTENSION DevExt)
/*++

Routine Description:

	Called when we want to wake up the device after an idle request

--*/
{
    POWER_STATE 	powerState;

    DEBUG_TRACE1(("USB Modem (%08X) waking up\n", DevExt));

    if(DevExt->DeviceState == DEVICE_STATE_STOPPED || DevExt->CurrentDevicePowerState == PowerDeviceD0)
    {

        // Don't wake this modem if it is stopped, or already at D0

        DEBUG_TRACE1(("USB Modem (%08X) abort wake\n", DevExt));
        return;
    }


    powerState.DeviceState = PowerDeviceD0;

	// request new device power state, wake up the device
    PoRequestPowerIrp(DevExt->PhysDeviceObject,
                      IRP_MN_SET_POWER,
                      powerState,
                      NULL,
                      NULL,
                      NULL);

} // UsbSerFdoRequestWake




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\write.c ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

        WRITE.C

Abstract:

        Routines that perform write functionality

Environment:

        kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        9/25/98 : created

Authors:

        Louis J. Giliberto, Jr.


****************************************************************************/


#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "utils.h"
#include "debugwdm.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEUSBS, UsbSer_Write)
#pragma alloc_text(PAGEUSBS, UsbSerGiveWriteToUsb)
#endif // ALLOC_PRAGMA


NTSTATUS
UsbSerFlush(IN PDEVICE_OBJECT PDevObj, PIRP PIrp)
{
   NTSTATUS status = STATUS_SUCCESS;
   PDEVICE_EXTENSION pDevExt;
   ULONG pendingIrps;

   UsbSerSerialDump(USBSERTRACEWR, (">UsbSerFlush(%08X)\n", PIrp));

   pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;

   //
   // All we will do is wait until the write pipe has nothing pending.
   // We do this by checking the outstanding count, and if it hits 1 or 0,
   // then the completion routine will set an event we are waiting for.
   //

   InterlockedIncrement(&pDevExt->PendingDataOutCount);

   pendingIrps = InterlockedDecrement(&pDevExt->PendingDataOutCount);

   if ((pendingIrps) && (pendingIrps != 1)) {
      //
      // Wait for flush
      //

      KeWaitForSingleObject(&pDevExt->PendingFlushEvent, Executive,
                            KernelMode, FALSE, NULL);
   } else {
      if (pendingIrps == 0) {
         //
         // We need to wake others since our decrement caused the event
         //

         KeSetEvent(&pDevExt->PendingDataOutEvent, IO_NO_INCREMENT, FALSE);
      }
   }

   PIrp->IoStatus.Status = STATUS_SUCCESS;

   IoCompleteRequest(PIrp, IO_NO_INCREMENT);

   UsbSerSerialDump(USBSERTRACEWR, ("<UsbSerFlush %08X \n", STATUS_SUCCESS));

   return STATUS_SUCCESS;
}



NTSTATUS
UsbSer_Write(IN PDEVICE_OBJECT PDevObj, PIRP PIrp)
/*++

Routine Description:

   Process the IRPs sent to this device for writing.

Arguments:

    PDevObj - Pointer to the device object for the device written to
    PIrp    - Pointer to the write IRP.

Return Value:

    NTSTATUS

--*/
{
   KIRQL oldIrql;
   LARGE_INTEGER totalTime;
   SERIAL_TIMEOUTS timeouts;
   NTSTATUS status;
   PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   USBSER_ALWAYS_LOCKED_CODE();

   UsbSerSerialDump(USBSERTRACEWR, (">UsbSer_Write(%08X)\n", PIrp));

   PIrp->IoStatus.Information = 0L;
   totalTime.QuadPart = (LONGLONG)0;

   //
   // Quick check for a zero length write.  If it is zero length
   // then we are already done!
   //

   if (pIrpSp->Parameters.Write.Length == 0) {
      status = PIrp->IoStatus.Status = STATUS_SUCCESS;
      IoCompleteRequest(PIrp, IO_NO_INCREMENT);
      goto UsbSer_WriteExit;
   }


   //
   // Make sure the device is accepting request and then...
   // Calculate the timeout value needed for the
   // request.  Note that the values stored in the
   // timeout record are in milliseconds.  Note that
   // if the timeout values are zero then we won't start
   // the timer.
   //

   ACQUIRE_SPINLOCK(pDevExt, &pDevExt->ControlLock, &oldIrql);

   if (pDevExt->CurrentDevicePowerState != PowerDeviceD0) {
      RELEASE_SPINLOCK(pDevExt, &pDevExt->ControlLock, oldIrql);
      status = PIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
      IoCompleteRequest(PIrp, IO_NO_INCREMENT);
      goto UsbSer_WriteExit;
   }

   timeouts = pDevExt->Timeouts;
   RELEASE_SPINLOCK(pDevExt, &pDevExt->ControlLock, oldIrql);

   if (timeouts.WriteTotalTimeoutConstant
       || timeouts.WriteTotalTimeoutMultiplier) {

      //
      // We have some timer values to calculate.
      //


      totalTime.QuadPart
         = ((LONGLONG)((UInt32x32To64((pIrpSp->MajorFunction == IRP_MJ_WRITE)
                                      ? (pIrpSp->Parameters.Write.Length)
                                      : 1,
                                      timeouts.WriteTotalTimeoutMultiplier)
                        + timeouts.WriteTotalTimeoutConstant))) * -10000;

   }

   //
   // The Irp may be going to the write routine shortly.  Now
   // is a good time to init its ref counts.
   //

   USBSER_INIT_REFERENCE(PIrp);

   //
   // We need to see if this Irp should be cancelled.
   //

   ACQUIRE_CANCEL_SPINLOCK(pDevExt, &oldIrql);

   if (PIrp->Cancel) {
      RELEASE_CANCEL_SPINLOCK(pDevExt, oldIrql);
      status = PIrp->IoStatus.Status = STATUS_CANCELLED;
   } else {
//       IoMarkIrpPending(PIrp);
//       status = STATUS_PENDING;

      //
      // We give the IRP to the USB subsystem -- he will need
      // to know how to cancel it himself
      //

      IoSetCancelRoutine(PIrp, NULL);
      RELEASE_CANCEL_SPINLOCK(pDevExt, oldIrql);

      status = UsbSerGiveWriteToUsb(pDevExt, PIrp, totalTime);
   }

UsbSer_WriteExit:;

   UsbSerSerialDump(USBSERTRACEWR, ("<UsbSer_Write %08X\n", status));

   return status;
}


NTSTATUS
UsbSerWriteComplete(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                    IN PUSBSER_WRITE_PACKET PPacket)
/*++

Routine Description:

    This routine is the completion routine for all write requests.
    When a write completes, we go through here in order to free up
    the URB.

Arguments:

    PDevObj - Pointer to device object

    PIrp - Irp we are completing

    PUrb - Urb which will be freed


Return Value:

    NTSTATUS -- as stored in the Irp.

--*/
{
   NTSTATUS status;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   KIRQL cancelIrql;
   PURB pUrb = &PPacket->Urb;
   PDEVICE_EXTENSION pDevExt = PPacket->DeviceExtension;
   ULONG curCount;

   UsbSerSerialDump(USBSERTRACEWR, (">UsbSerWriteComplete(%08X)\n", PIrp));

   status = PIrp->IoStatus.Status;

   if (status == STATUS_SUCCESS) {

        // see if we are reusing an IOCTL IRP
        if(pIrpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL)
        {
            PIrp->IoStatus.Information = 0L;
        }
        else
        {
            PIrp->IoStatus.Information
                = pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;
            pIrpStack->Parameters.Write.Length = (ULONG)PIrp->IoStatus.Information;
        }

   } else if (status == STATUS_CANCELLED) {
      //
      // If it comes back as cancelled, it may really have timed out. We
      // can tell by looking at the packet attached to it.
      //

      if (PPacket->Status) {
         status = PIrp->IoStatus.Status = PPacket->Status;
         UsbSerSerialDump(USBSERTRACEWR, ("Modified Write Status %08X\n",
                                          PIrp->IoStatus.Status));
      }
   }

   //
   // Cancel the write timer
   //

   if (PPacket->WriteTimeout.QuadPart != 0) {
      KeCancelTimer(&PPacket->WriteTimer);
   }

   DEBUG_MEMFREE(PPacket);

   //
   // Reset the pend if necessary
   //

   if (PIrp->PendingReturned) {
      IoMarkIrpPending(PIrp);
   }

   //
   // See if we should mark the transmit as empty
   //

   if (InterlockedDecrement(&pDevExt->PendingWriteCount) == 0) {
      UsbSerProcessEmptyTransmit(pDevExt);
   }

   //
   // Notify everyone if this is the last IRP
   //

   curCount = InterlockedDecrement(&pDevExt->PendingDataOutCount);

   if ((curCount == 0) || (curCount == 1)) {
      UsbSerSerialDump(USBSERTRACEWR, ("DataOut Pipe is flushed\n"));
      KeSetEvent(&pDevExt->PendingFlushEvent, IO_NO_INCREMENT, FALSE);

      if (curCount == 0) {
         UsbSerSerialDump(USBSERTRACEWR, ("DataOut Pipe is empty\n"));
         KeSetEvent(&pDevExt->PendingDataOutEvent, IO_NO_INCREMENT, FALSE);
      }
   }

   //
   // Finish off this IRP
   //


   ACQUIRE_CANCEL_SPINLOCK(pDevExt, &cancelIrql);

   UsbSerTryToCompleteCurrent(pDevExt, cancelIrql, status,
                              &PIrp, NULL, NULL,
                              &pDevExt->WriteRequestTotalTimer, NULL,
                              NULL, USBSER_REF_RXBUFFER, FALSE);


   UsbSerSerialDump(USBSERTRACEWR, ("<UsbSerWriteComplete %08X\n", status));
   return status;
}



NTSTATUS
UsbSerGiveWriteToUsb(IN PDEVICE_EXTENSION PDevExt, IN PIRP PIrp,
                     IN LARGE_INTEGER TotalTime)
/*++

Routine Description:

    This function passes a write IRP down to USB to perform the write
    to the device.

Arguments:

    PDevExt   - Pointer to device extension

    PIrp      - Write IRP

    TotalTime - Timeout value for total timer


Return Value:

    NTSTATUS

--*/
{
   NTSTATUS status;
   PURB pTxUrb;
   PIO_STACK_LOCATION pIrpSp;
   KIRQL cancelIrql;
   PUSBSER_WRITE_PACKET pWrPacket;

   USBSER_ALWAYS_LOCKED_CODE();

   UsbSerSerialDump(USBSERTRACEWR, (">UsbSerGiveWriteToUsb(%08X)\n",
                                    PIrp));

   USBSER_SET_REFERENCE(PIrp, USBSER_REF_RXBUFFER);


   pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   //
   // Allocate memory for URB / Write packet
   //

   pWrPacket = DEBUG_MEMALLOC(NonPagedPool, sizeof(USBSER_WRITE_PACKET));

   if (pWrPacket == NULL) {
      status = PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

      ACQUIRE_CANCEL_SPINLOCK(PDevExt, &cancelIrql);

      UsbSerTryToCompleteCurrent(PDevExt, cancelIrql, status, &PIrp,
                                 NULL,
                                 &PDevExt->WriteRequestTotalTimer, NULL, NULL,
                                 NULL, USBSER_REF_RXBUFFER, TRUE);

      return status;
   }

   RtlZeroMemory(pWrPacket, sizeof(USBSER_WRITE_PACKET));

   pTxUrb = &pWrPacket->Urb;
   pWrPacket->DeviceExtension = PDevExt;
   pWrPacket->Irp = PIrp;
   pWrPacket->WriteTimeout = TotalTime;

   if (TotalTime.QuadPart != 0) {
      KeInitializeTimer(&pWrPacket->WriteTimer);
      KeInitializeDpc(&pWrPacket->TimerDPC, UsbSerWriteTimeout, pWrPacket);
      KeSetTimer(&pWrPacket->WriteTimer, TotalTime, &pWrPacket->TimerDPC);
   }

   //
   // Build USB write request
   //

   BuildReadRequest(pTxUrb, PIrp->AssociatedIrp.SystemBuffer,
                    pIrpSp->Parameters.Write.Length, PDevExt->DataOutPipe,
                    FALSE);

#if DBG
   if (UsbSerSerialDebugLevel & USBSERDUMPWR) {
      ULONG i;

      DbgPrint("WR: ");

      for (i = 0; i < pIrpSp->Parameters.Write.Length; i++) {
         DbgPrint("%02x ", *(((PUCHAR)PIrp->AssociatedIrp.SystemBuffer) + i) & 0xFF);
      }

      DbgPrint("\n\n");
   }
#endif

   //
   // Set Irp up for a submit Urb IOCTL
   //

   IoCopyCurrentIrpStackLocationToNext(PIrp);

   pIrpSp = IoGetNextIrpStackLocation(PIrp);

   pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
   pIrpSp->Parameters.Others.Argument1 = pTxUrb;
   pIrpSp->Parameters.DeviceIoControl.IoControlCode
      = IOCTL_INTERNAL_USB_SUBMIT_URB;

   IoSetCompletionRoutine(PIrp, UsbSerWriteComplete, pWrPacket, TRUE, TRUE,
                          TRUE);

   //
   // Increment the pending write count
   //

   InterlockedIncrement(&PDevExt->PendingWriteCount);
   InterlockedIncrement(&PDevExt->PendingDataOutCount);

   //
   // Send IRP down
   //

   status = IoCallDriver(PDevExt->StackDeviceObject, PIrp);


#if 0

   // this is done in the completion routine, so we don't need to do it here

   if (!NT_SUCCESS(status)) {
      ULONG outCount;

      if (InterlockedDecrement(&PDevExt->PendingWriteCount) == 0) {
         UsbSerProcessEmptyTransmit(PDevExt);
      }

      outCount = InterlockedDecrement(&PDevExt->PendingDataOutCount);

      if ((outCount == 0) || (outCount == 1)) {
         KeSetEvent(&PDevExt->PendingFlushEvent, IO_NO_INCREMENT, FALSE);

         if (outCount == 0) {
            KeSetEvent(&PDevExt->PendingDataOutEvent, IO_NO_INCREMENT, FALSE);
         }
      }
   }

#endif

   UsbSerSerialDump(USBSERTRACEWR, ("<UsbSerGiveWriteToUsb %08X\n", status));

   return status;
}


VOID
UsbSerWriteTimeout(IN PKDPC PDpc, IN PVOID DeferredContext,
                   IN PVOID SystemContext1, IN PVOID SystemContext2)
/*++

Routine Description:

    This function is called when the write timeout timer expires.

Arguments:

    PDpc             - Unused

    DeferredContext  - Actually the write packet

    SystemContext1   - Unused

    SystemContext2   - Unused


Return Value:

    VOID

--*/
{
   PUSBSER_WRITE_PACKET pPacket = (PUSBSER_WRITE_PACKET)DeferredContext;

   UNREFERENCED_PARAMETER(PDpc);
   UNREFERENCED_PARAMETER(SystemContext1);
   UNREFERENCED_PARAMETER(SystemContext2);

   UsbSerSerialDump(USBSERTRACETM, (">UsbSerWriteTimeout\n"));

   if (IoCancelIrp(pPacket->Irp)) {
      pPacket->Status = STATUS_TIMEOUT;
   }

   UsbSerSerialDump(USBSERTRACETM, ("<UsbSerWriteTimeout\n"));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\usbser\utils.c ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

        UTILS.C

Abstract:

        Routines that don't fit anywhere else.

Environment:

        kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        12/23/97 : created

Authors:

        Tom Green


****************************************************************************/

#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "usbserpw.h"
#include "serioctl.h"
#include "utils.h"
#include "debugwdm.h"


#ifdef ALLOC_PRAGMA

#if DBG
#pragma alloc_text(PAGEUBS0, UsbSerLockPagableCodeSection)
#endif

#pragma alloc_text(PAGEUBS0, UsbSerGetRegistryKeyValue)
#pragma alloc_text(PAGEUBS0, UsbSerUndoExternalNaming)
#pragma alloc_text(PAGEUBS0, UsbSerDoExternalNaming)

#pragma alloc_text(PAGEUBS0, StopDevice)
#pragma alloc_text(PAGEUBS0, StartPerfTimer)
#pragma alloc_text(PAGEUBS0, StopPerfTimer)
#pragma alloc_text(PAGEUBS0, BytesPerSecond)
#pragma alloc_text(PAGEUBS0, CallUSBD)
#pragma alloc_text(PAGEUBS0, ConfigureDevice)
#pragma alloc_text(PAGEUBS0, BuildRequest)
// #pragma alloc_text(PAGEUBS0, BuildReadRequest) -- called from restartnotify
#pragma alloc_text(PAGEUBS0, ClassVendorCommand)
#pragma alloc_text(PAGEUBS0, StartRead)
#pragma alloc_text(PAGEUBS0, StartNotifyRead)
#pragma alloc_text(PAGEUBS0, UsbSerRestoreModemSettings)
#pragma alloc_text(PAGEUBS0, StartDevice)
#pragma alloc_text(PAGEUBS0, DeleteObjectAndLink)
#pragma alloc_text(PAGEUBS0, RemoveDevice)

// #pragma alloc_text(PAGEUSBS, CancelPendingWaitMasks) -- called from STOP
#pragma alloc_text(PAGEUSBS, UsbSerTryToCompleteCurrent)
#pragma alloc_text(PAGEUSBS, UsbSerGetNextIrp)
#pragma alloc_text(PAGEUSBS, UsbSerStartOrQueue)
#pragma alloc_text(PAGEUSBS, UsbSerCancelQueued)
#pragma alloc_text(PAGEUSBS, UsbSerKillAllReadsOrWrites)
#pragma alloc_text(PAGEUSBS, UsbSerKillPendingIrps)
#pragma alloc_text(PAGEUSBS, UsbSerCompletePendingWaitMasks)
#pragma alloc_text(PAGEUSBS, UsbSerProcessEmptyTransmit)
#pragma alloc_text(PAGEUSBS, UsbSerCancelWaitOnMask)
#endif // ALLOC_PRAGMA

// we will support 256 devices, keep track of open slots here
#define NUM_DEVICE_SLOTS                256


LOCAL BOOLEAN           Slots[NUM_DEVICE_SLOTS];
LOCAL ULONG             NumDevices;
LOCAL PDEVICE_OBJECT    GlobDeviceObject;

USHORT               RxBuffSize = RX_BUFF_SIZE;


/************************************************************************/
/* UsbSerGetRegistryValues                                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Gets values from the registry                                       */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*  Handle            Handle to the opened registry key                 */
/*                                                                      */
/*  PKeyNameString      ANSI string to the desired key                  */
/*                                                                      */
/*  KeyNameStringLength Length of the KeyNameString                     */
/*                                                                      */
/*  PData              Buffer to place the key value in                 */
/*                                                                      */
/*  DataLength    Length of the data buffer                             */
/*                                                                      */
/*  PDevExt - pointer to the device extension                           */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*   STATUS_SUCCESS if all works, otherwise status of system call that  */
/*   went wrong.                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSerGetRegistryKeyValue(IN HANDLE Handle, IN PWCHAR PKeyNameString,
                          IN ULONG KeyNameStringLength, IN PVOID PData,
                          IN ULONG DataLength)
{
   UNICODE_STRING keyName;
   ULONG length;
   PKEY_VALUE_FULL_INFORMATION pFullInfo;
   NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSerGetRegistryKeyValue");
   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerGetRegistryKeyValue\n"));

   RtlInitUnicodeString(&keyName, PKeyNameString);

   length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength
                                + DataLength;

   pFullInfo = DEBUG_MEMALLOC(PagedPool, length);

   if (pFullInfo) {
                status = ZwQueryValueKey(Handle, &keyName,
                                         KeyValueFullInformation, pFullInfo,
                                         length, &length);

                if (NT_SUCCESS(status)) {
                        //
                        // If there is enough room in the data buffer,
                        // copy the output
                        //

                        if (DataLength >= pFullInfo->DataLength) {
                                RtlCopyMemory(PData, ((PUCHAR)pFullInfo)
                                              + pFullInfo->DataOffset,
                                              pFullInfo->DataLength);
                        }
                }

                DEBUG_MEMFREE(pFullInfo);
        }

   DEBUG_LOG_ERROR(status);
   DEBUG_LOG_PATH("exit  UsbSerGetRegistryKeyValue");
   DEBUG_TRACE3(("status (%08X)\n", status));
   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerGetRegistryKeyValue %08X\n",
                                     status));

        return status;
} // UsbSerGetRegistryKeyValue


/************************************************************************/
/* UsbSerUndoExternalNaming                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/* Remove any and all external namespace interfaces we exposed          */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*   PDevExt - pointer to the device extension                          */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*   VOID                                                               */
/*                                                                      */
/************************************************************************/
VOID
UsbSerUndoExternalNaming(IN PDEVICE_EXTENSION PDevExt)
{

   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSerUndoExternalNaming");
   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerUndoExternalNaming\n"));

   if (PDevExt->SymbolicLinkName.Buffer && PDevExt->CreatedSymbolicLink) {
      IoDeleteSymbolicLink(&PDevExt->SymbolicLinkName);
   }

   if (PDevExt->SymbolicLinkName.Buffer != NULL) {
      DEBUG_MEMFREE(PDevExt->SymbolicLinkName.Buffer);
      RtlInitUnicodeString(&PDevExt->SymbolicLinkName, NULL);
   }

   if (PDevExt->DosName.Buffer != NULL) {
      DEBUG_MEMFREE(PDevExt->DosName.Buffer);
      RtlInitUnicodeString(&PDevExt->DosName, NULL);
   }

   if (PDevExt->DeviceName.Buffer != NULL) {
      RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, SERIAL_DEVICE_MAP,
                             PDevExt->DeviceName.Buffer);
      DEBUG_MEMFREE(PDevExt->DeviceName.Buffer);
      RtlInitUnicodeString(&PDevExt->DeviceName, NULL);
   }

#ifdef WMI_SUPPORT
   if (PDevExt->WmiIdentifier.Buffer)
   {
      DEBUG_MEMFREE(PDevExt->WmiIdentifier.Buffer);
      PDevExt->WmiIdentifier.MaximumLength
         = PDevExt->WmiIdentifier.Length = 0;
      PDevExt->WmiIdentifier.Buffer = NULL;
   }
#endif

   DEBUG_LOG_PATH("exit  UsbSerUndoExternalNaming");
   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerUndoExternalNaming\n"));
} // UsbSerUndoExternalNaming


/************************************************************************/
/*  UsbSerDoExternalNaming                                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/* Exposes interfaces in external namespace                             */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      PDevExt - pointer to the device extension                       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
UsbSerDoExternalNaming(IN PDEVICE_EXTENSION PDevExt)
{
   NTSTATUS status;
   HANDLE keyHandle;
   WCHAR *pRegName = NULL;
   UNICODE_STRING linkName;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter UsbSerDoExternalNaming");
   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerDoExternalNaming\n"));

   RtlZeroMemory(&linkName, sizeof(UNICODE_STRING));
   linkName.MaximumLength = SYMBOLIC_NAME_LENGTH * sizeof(WCHAR);
   linkName.Buffer = DEBUG_MEMALLOC(PagedPool, linkName.MaximumLength
                                    + sizeof(WCHAR));

   if (linkName.Buffer == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto UsbSerDoExternalNamingError;
   }

   RtlZeroMemory(linkName.Buffer, linkName.MaximumLength + sizeof(WCHAR));

   pRegName = DEBUG_MEMALLOC(PagedPool, SYMBOLIC_NAME_LENGTH * sizeof(WCHAR)
                             + sizeof(WCHAR));

   if (pRegName == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto UsbSerDoExternalNamingError;
   }

   status = IoOpenDeviceRegistryKey(PDevExt->PhysDeviceObject,
                                    PLUGPLAY_REGKEY_DEVICE,
                                    STANDARD_RIGHTS_READ, &keyHandle);

   if (status != STATUS_SUCCESS) {
      goto UsbSerDoExternalNamingError;
   }

   status = UsbSerGetRegistryKeyValue(keyHandle, L"PortName", sizeof(L"PortName"),
                                      pRegName, SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));

   if (status != STATUS_SUCCESS) {
      status = UsbSerGetRegistryKeyValue(keyHandle, L"Identifier",
                                         sizeof(L"Identifier"), pRegName,
                                         SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));
      if (status != STATUS_SUCCESS) {
         ZwClose(keyHandle);
         goto UsbSerDoExternalNamingError;
      }
   }

   ZwClose(keyHandle);

#ifdef WMI_SUPPORT
   {
   ULONG bufLen;

   bufLen = wcslen(pRegName) * sizeof(WCHAR) + sizeof(UNICODE_NULL);

   PDevExt->WmiIdentifier.Buffer = DEBUG_MEMALLOC(PagedPool, bufLen);

   if (PDevExt->WmiIdentifier.Buffer == NULL)
   {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto UsbSerDoExternalNamingError;
   }


   RtlZeroMemory(PDevExt->WmiIdentifier.Buffer, bufLen);

   PDevExt->WmiIdentifier.Length = 0;
   PDevExt->WmiIdentifier.MaximumLength = (USHORT)bufLen - sizeof(WCHAR);
   RtlAppendUnicodeToString(&PDevExt->WmiIdentifier, pRegName);

   }
#endif

   //
   // Create the "\\DosDevices\\<symbolicname>" string
   //

   RtlAppendUnicodeToString(&linkName, L"\\");
   RtlAppendUnicodeToString(&linkName, DEFAULT_DIRECTORY);
   RtlAppendUnicodeToString(&linkName, L"\\");
   RtlAppendUnicodeToString(&linkName, pRegName);

   //
   // Allocate pool and save the symbolic link name in the device extension
   //
   PDevExt->SymbolicLinkName.MaximumLength = linkName.Length + sizeof(WCHAR);
   PDevExt->SymbolicLinkName.Buffer
      = DEBUG_MEMALLOC(PagedPool, PDevExt->SymbolicLinkName.MaximumLength);

   if (PDevExt->SymbolicLinkName.Buffer == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto UsbSerDoExternalNamingError;
   }

   RtlZeroMemory(PDevExt->SymbolicLinkName.Buffer,
                 PDevExt->SymbolicLinkName.MaximumLength);

   RtlAppendUnicodeStringToString(&PDevExt->SymbolicLinkName, &linkName);

   status = IoCreateSymbolicLink(&PDevExt->SymbolicLinkName,
                                 &PDevExt->DeviceName);

   if (status != STATUS_SUCCESS) {
      goto UsbSerDoExternalNamingError;
   }

   PDevExt->CreatedSymbolicLink = TRUE;

   PDevExt->DosName.Buffer = DEBUG_MEMALLOC(PagedPool, 64 + sizeof(WCHAR));

   if (PDevExt->DosName.Buffer == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto UsbSerDoExternalNamingError;
   }

   PDevExt->DosName.MaximumLength = 64 + sizeof(WCHAR);
   PDevExt->DosName.Length = 0;

   RtlZeroMemory(PDevExt->DosName.Buffer, PDevExt->DosName.MaximumLength);

   RtlAppendUnicodeToString(&PDevExt->DosName, pRegName);
   RtlZeroMemory(((PUCHAR)(&PDevExt->DosName.Buffer[0]))
                 + PDevExt->DosName.Length, sizeof(WCHAR));

   status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP, L"SERIALCOMM",
                                  PDevExt->DeviceName.Buffer, REG_SZ,
                                  PDevExt->DosName.Buffer,
                                  PDevExt->DosName.Length + sizeof(WCHAR));

   if (status != STATUS_SUCCESS) {
      goto UsbSerDoExternalNamingError;
   }

UsbSerDoExternalNamingError:;

   //
   // Clean up error conditions
   //

   if (status != STATUS_SUCCESS) {
      if (PDevExt->DosName.Buffer != NULL) {
         DEBUG_MEMFREE(PDevExt->DosName.Buffer);
         PDevExt->DosName.Buffer = NULL;
      }

      if (PDevExt->CreatedSymbolicLink ==  TRUE) {
         IoDeleteSymbolicLink(&PDevExt->SymbolicLinkName);
         PDevExt->CreatedSymbolicLink = FALSE;
      }

      if (PDevExt->SymbolicLinkName.Buffer != NULL) {
         DEBUG_MEMFREE(PDevExt->SymbolicLinkName.Buffer);
         PDevExt->SymbolicLinkName.Buffer = NULL;
      }

      if (PDevExt->DeviceName.Buffer != NULL) {
         RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, SERIAL_DEVICE_MAP,
                                PDevExt->DeviceName.Buffer);
      }
   }

   //
   // Always clean up our temp buffers.
   //

   if (linkName.Buffer != NULL) {
      DEBUG_MEMFREE(linkName.Buffer);
   }

   if (pRegName != NULL) {
      DEBUG_MEMFREE(pRegName);
   }

   DEBUG_LOG_ERROR(status);
   DEBUG_LOG_PATH("exit  UsbSerDoExternalNaming");
   DEBUG_TRACE3(("status (%08X)\n", status));
   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerDoExternalNaming %08X\n", status));

   return status;

} // UsbSerDoExternalNaming



NTSTATUS
UsbSerAbortPipes(IN PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

   Called as part of sudden device removal handling.
    Cancels any pending transfers for all open pipes.

Arguments:

    Ptrs to our FDO

Return Value:

    NT status code

--*/
{
   NTSTATUS ntStatus = STATUS_SUCCESS;
   PURB pUrb;
   PDEVICE_EXTENSION pDevExt;
   ULONG pendingIrps;

   DEBUG_TRACE1(("UsbSerAbortPipes\n"));

   UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD,
                    (">UsbSerAbortPipes (%08X)\n", PDevObj));

   pDevExt = PDevObj->DeviceExtension;
   pUrb = DEBUG_MEMALLOC(NonPagedPool, sizeof(struct _URB_PIPE_REQUEST));

   if (pUrb != NULL) 
   {

      pUrb->UrbHeader.Length = (USHORT)sizeof(struct _URB_PIPE_REQUEST);
      pUrb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
      pUrb->UrbPipeRequest.PipeHandle = pDevExt->DataInPipe;

      ntStatus = CallUSBD(PDevObj, pUrb);

      if (ntStatus != STATUS_SUCCESS) {
         goto UsbSerAbortPipesErr;
      }

      //
      // Wait for all the read IRPS to drain
      //

      UsbSerSerialDump(USBSERTRACERD, ("DataInCountw %08X @ %08X\n",
                                       pDevExt->PendingDataInCount,
                                       &pDevExt->PendingDataInCount));

      //
      // Decrement for initial value
      //

      pendingIrps = InterlockedDecrement(&pDevExt->PendingDataInCount);

      if (pendingIrps) {
         DEBUG_TRACE1(("Abort DataIn Pipe\n"));
         UsbSerSerialDump(USBSERTRACEOTH, ("Waiting for DataIn Pipe\n"));
         KeWaitForSingleObject(&pDevExt->PendingDataInEvent, Executive,
                               KernelMode, FALSE, NULL);
      }

      //
      // Reset counter
      //

      InterlockedIncrement(&pDevExt->PendingDataInCount);

      UsbSerSerialDump(USBSERTRACERD, ("DataInCountx %08X @ %08X\n",
                                       pDevExt->PendingDataInCount,
                                       &pDevExt->PendingDataInCount));

      pUrb->UrbHeader.Length = (USHORT)sizeof(struct _URB_PIPE_REQUEST);
      pUrb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
      pUrb->UrbPipeRequest.PipeHandle = pDevExt->DataOutPipe;

      ntStatus = CallUSBD(PDevObj, pUrb);

      if (ntStatus != STATUS_SUCCESS) {
         goto UsbSerAbortPipesErr;
      }

      //
      // Wait for all the write irps to drain
      //

      //
      // Decrement for initial value
      //

      pendingIrps = InterlockedDecrement(&pDevExt->PendingDataOutCount);

      if (pendingIrps) {
         UsbSerSerialDump(USBSERTRACEOTH, ("Waiting for DataOut Pipe\n"));
         KeWaitForSingleObject(&pDevExt->PendingDataOutEvent, Executive,
                               KernelMode, FALSE, NULL);
      }

      //
      // Reset counter
      //

      InterlockedIncrement(&pDevExt->PendingDataOutCount);


      pUrb->UrbHeader.Length = (USHORT)sizeof(struct _URB_PIPE_REQUEST);
      pUrb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
      pUrb->UrbPipeRequest.PipeHandle = pDevExt->NotificationPipe;

      ntStatus = CallUSBD(PDevObj, pUrb);

      //
      // Wait for all the notify irps to drain
      //

      //
      // Decrement for initial value
      //

      pendingIrps = InterlockedDecrement(&pDevExt->PendingNotifyCount);

      if (pendingIrps) {
         UsbSerSerialDump(USBSERTRACEOTH, ("Waiting for Notify Pipe\n"));
         KeWaitForSingleObject(&pDevExt->PendingNotifyEvent, Executive,
                               KernelMode, FALSE, NULL);
      }

      //      //
      // Die my darling, die.
      //

      // IoCancelIrp(pDevExt->NotifyIrp);



      // Reset counter
      //

      InterlockedIncrement(&pDevExt->PendingNotifyCount);

UsbSerAbortPipesErr:;

      DEBUG_MEMFREE(pUrb);

   } else {
      ntStatus = STATUS_INSUFFICIENT_RESOURCES;
   }

   UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD,
                    ("<UsbSerAbortPipes %08X\n", ntStatus));

    return ntStatus;
}



/************************************************************************/
/* StartDevice                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Take care of processing needed to start device.                 */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
StartDevice(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
        PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
        NTSTATUS                NtStatus = STATUS_SUCCESS;
        KEVENT                  Event;
        PVOID                   pPagingHandle;

        PAGED_CODE();

        DEBUG_LOG_PATH("enter StartDevice");

        DEBUG_TRACE1(("StartDevice\n"));

        // pass this down to the USB stack first
        KeInitializeEvent(&Event, NotificationEvent, FALSE);

        //
        // Initialize our DPC's
        //

        KeInitializeDpc(&DeviceExtension->TotalReadTimeoutDpc,
                        UsbSerReadTimeout, DeviceExtension);
        KeInitializeDpc(&DeviceExtension->IntervalReadTimeoutDpc,
                        UsbSerIntervalReadTimeout, DeviceExtension);
        KeInitializeDpc(&DeviceExtension->TotalWriteTimeoutDpc,
                        UsbSerWriteTimeout, DeviceExtension);

        //
        // Initialize timers
        //

        KeInitializeTimer(&DeviceExtension->WriteRequestTotalTimer);
        KeInitializeTimer(&DeviceExtension->ReadRequestTotalTimer);
        KeInitializeTimer(&DeviceExtension->ReadRequestIntervalTimer);

        //
        // Store values into the extension for interval timing.
        //

        //
        // If the interval timer is less than a second then come
        // in with a short "polling" loop.
        //
        // For large (> then 2 seconds) use a 1 second poller.
        //

        DeviceExtension->ShortIntervalAmount.QuadPart  = -1;
        DeviceExtension->LongIntervalAmount.QuadPart   = -10000000;
        DeviceExtension->CutOverAmount.QuadPart        = 200000000;



        KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, UsbSerSyncCompletion, &Event, TRUE, TRUE,
                               TRUE);

        NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, Irp);

        // wait for Irp to complete if status is pending
        if(NtStatus == STATUS_PENDING)
        {
                KeWaitForSingleObject(&Event, Suspended, KernelMode, FALSE,
                                      NULL);
        }

        NtStatus = Irp->IoStatus.Status;

        if (!NT_SUCCESS(NtStatus)) {
           goto ExitStartDevice;
        }

        NtStatus = GetDeviceDescriptor(DeviceObject);

        if (!NT_SUCCESS(NtStatus)) {
           goto ExitStartDevice;
        }

        NtStatus = ConfigureDevice(DeviceObject);

        if (!NT_SUCCESS(NtStatus)) {
           goto ExitStartDevice;
        }

        //
        // Page in and lock necessary code
        //
        pPagingHandle = UsbSerLockPagableCodeSection(PAGEUSBSER_Function);

        // reset device
        ResetDevice(NULL, DeviceObject);

        // init stuff in device extension

        DeviceExtension->HandFlow.ControlHandShake      = 0;
        DeviceExtension->HandFlow.FlowReplace           = SERIAL_RTS_CONTROL;
        DeviceExtension->AcceptingRequests              = TRUE;

        InitializeListHead(&DeviceExtension->ReadQueue);
        InitializeListHead(&DeviceExtension->ImmediateReadQueue);

        UsbSerDoExternalNaming(DeviceExtension);

        // clear DTR and RTS
        SetClrDtr(DeviceObject, FALSE);
        ClrRts(NULL, DeviceExtension);

        // kick off a read
        StartRead(DeviceExtension);

        // kick off a notification read
        StartNotifyRead(DeviceExtension);

        UsbSerUnlockPagableImageSection(pPagingHandle);

ExitStartDevice:;

        if(NT_SUCCESS(NtStatus))
        {
            DeviceExtension->DeviceState = DEVICE_STATE_STARTED;

            // try and idle the modem
            // UsbSerFdoSubmitIdleRequestIrp(DeviceExtension);
        }

        Irp->IoStatus.Status = NtStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        DEBUG_LOG_PATH("exit  StartDevice");

        return NtStatus;
} // StartDevice


/************************************************************************/
/* StopDevice                                                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Take care of processing needed to stop device.                  */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
StopDevice(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   Size;
    PURB                    Urb;

    PAGED_CODE();

    DEBUG_LOG_PATH("enter StopDevice");

    DEBUG_TRACE1(("StopDevice\n"));

    UsbSerFetchBooleanLocked(&DeviceExtension->AcceptingRequests,
                             FALSE, &DeviceExtension->ControlLock);

    CancelPendingWaitMasks(DeviceExtension);

    if(DeviceExtension->DeviceState == DEVICE_STATE_STARTED)
    {
        DEBUG_TRACE1(("AbortPipes\n"));
        UsbSerAbortPipes(DeviceObject);
    }

    DeviceExtension->DeviceState = DEVICE_STATE_STOPPED;

    if(DeviceExtension->PendingIdleIrp)
    {
        IoCancelIrp(DeviceExtension->PendingIdleIrp);
    }

    Size = sizeof(struct _URB_SELECT_CONFIGURATION);

    Urb = DEBUG_MEMALLOC(NonPagedPool, Size);

    if(Urb)
    {

        UsbBuildSelectConfigurationRequest(Urb, (USHORT) Size, NULL);

        NtStatus = CallUSBD(DeviceObject, Urb);

        DEBUG_TRACE3(("Device Configuration Closed status = (%08X)  "
                      "USB status = (%08X)\n", NtStatus,
                      Urb->UrbHeader.Status));

        DEBUG_MEMFREE(Urb);
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DEBUG_LOG_PATH("exit  StopDevice");

    return NtStatus;
} // StopDevice


/************************************************************************/
/* RemoveDevice                                                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Take care of processing needed to remove device.                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to an I/O Request Packet                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
RemoveDevice(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{

        PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
        NTSTATUS                NtStatus = STATUS_SUCCESS;
        PVOID                   pPagingHandle;

        PAGED_CODE();

        DEBUG_LOG_PATH("enter RemoveDevice");

        DEBUG_TRACE1(("RemoveDevice\n"));

        //
        // Page in and lock necessary code
        //

        pPagingHandle = UsbSerLockPagableCodeSection(PAGEUSBSER_Function);

        UsbSerFetchBooleanLocked(&DeviceExtension->AcceptingRequests,
                                 FALSE, &DeviceExtension->ControlLock);

        CancelPendingWaitMasks(DeviceExtension);

        //
        // Cancel all pending USB transactions
        //

        if(DeviceExtension->DeviceState == DEVICE_STATE_STARTED)
        {
            DEBUG_TRACE1(("AbortPipes\n"));
            UsbSerAbortPipes(DeviceObject);
        }

        //
        // Once we set accepting requests to false, we shouldn't
        // have any more contention here -- if we do, we're dead
        // because we're freeing memory out from under our feet.
        //

        DEBUG_TRACE1(("Freeing Allocated Memory\n"));

        // free allocated notify URB
        if(DeviceExtension->NotifyUrb)
        {
                DEBUG_MEMFREE(DeviceExtension->NotifyUrb);
                DeviceExtension->NotifyUrb = NULL;
        }

        // free allocated Read URB
        if(DeviceExtension->ReadUrb)
        {
                DEBUG_MEMFREE(DeviceExtension->ReadUrb);
                DeviceExtension->ReadUrb = NULL;
        }

        // free allocated device descriptor
        if(DeviceExtension->DeviceDescriptor)
        {
                DEBUG_MEMFREE(DeviceExtension->DeviceDescriptor);
                DeviceExtension->DeviceDescriptor = NULL;
        }

        // free up read buffer
        if(DeviceExtension->ReadBuff)
        {
                DEBUG_MEMFREE(DeviceExtension->ReadBuff);
                DeviceExtension->ReadBuff = NULL;
        }

        if(DeviceExtension->USBReadBuff)
        {
                DEBUG_MEMFREE(DeviceExtension->USBReadBuff);
                DeviceExtension->USBReadBuff = NULL;
        }

        // free up notification buffer
        if(DeviceExtension->NotificationBuff)
        {
                DEBUG_MEMFREE(DeviceExtension->NotificationBuff);
                DeviceExtension->NotificationBuff = NULL;
        }

        DEBUG_TRACE1(("Undo Serial Name\n"));

        UsbSerUndoExternalNaming(DeviceExtension);

        //
        // Pass this down to the next driver

        IoCopyCurrentIrpStackLocationToNext(Irp);

        NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, Irp);

        DEBUG_TRACE1(("Detach Device\n"));

        // detach device from stack
        IoDetachDevice(DeviceExtension->StackDeviceObject);

        DEBUG_TRACE1(("DevExt (%08X)  DevExt Size (%08X)\n", DeviceExtension, sizeof(DEVICE_EXTENSION)));

        DEBUG_TRACE1(("Delete Object and Link\n"));

        // delete device object and symbolic link
        DeleteObjectAndLink(DeviceObject);

        DEBUG_TRACE1(("Done Removing Device\n"));

        DEBUG_LOG_PATH("exit  RemoveDevice");

        UsbSerUnlockPagableImageSection(pPagingHandle);

        DeviceExtension->DeviceState = DEVICE_STATE_STOPPED;

        return NtStatus;
} // RemoveDevice


/************************************************************************/
/* CreateDeviceObject                                                   */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Take care of processing needed to create device obeject for     */
/*      device.                                                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DriverObject - pointer to a driver object                       */
/*      DeviceObject - pointer to a device object pointer               */
/*      DeviceName   - pointer to a base name of device                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
CreateDeviceObject(IN PDRIVER_OBJECT DriverObject,
                   IN PDEVICE_OBJECT *DeviceObject,
                   IN PCHAR DeviceName)
{
   ANSI_STRING             DevName;
   ANSI_STRING             LinkName;
   NTSTATUS                NtStatus;
   UNICODE_STRING          DeviceNameUnicodeString;
   UNICODE_STRING          LinkNameUnicodeString;
   PDEVICE_EXTENSION       DeviceExtension;
   CHAR                    DeviceLinkBuffer[NAME_MAX];
   CHAR                    DeviceNameBuffer[NAME_MAX];
   ULONG                   DeviceInstance;
   ULONG                   bufferLen;
   KIRQL                   OldIrql;

   DEBUG_LOG_PATH("enter CreateDeviceObject");

   DEBUG_TRACE1(("CreateDeviceObject\n"));

   KeAcquireSpinLock(&GlobalSpinLock, &OldIrql);

   // let's get an instance
   for (DeviceInstance = 0; DeviceInstance < NUM_DEVICE_SLOTS;
        DeviceInstance++) {
      if (Slots[DeviceInstance] == FALSE)
         break;
   }

   KeReleaseSpinLock(&GlobalSpinLock, OldIrql);

   // check if we didn't have any empty slots
   if (DeviceInstance == NUM_DEVICE_SLOTS)
      NtStatus = STATUS_INVALID_DEVICE_REQUEST;
   else {
      // complete names of links and devices
      sprintf(DeviceLinkBuffer, "%s%s%03d", "\\DosDevices\\", DeviceName,
              DeviceInstance);
      sprintf(DeviceNameBuffer, "%s%s%03d", "\\Device\\", DeviceName,
              DeviceInstance);

      // init ANSI string with our link and device names
      RtlInitAnsiString(&DevName, DeviceNameBuffer);
      RtlInitAnsiString(&LinkName, DeviceLinkBuffer);

      DeviceNameUnicodeString.Length = 0;
      DeviceNameUnicodeString.Buffer = NULL;

      LinkNameUnicodeString.Length = 0;
      LinkNameUnicodeString.Buffer = NULL;

      *DeviceObject = NULL;

      // convert to UNICODE string
      NtStatus = RtlAnsiStringToUnicodeString(&DeviceNameUnicodeString,
                                              &DevName, TRUE);

      if(NT_SUCCESS(NtStatus))
      {
          NtStatus = RtlAnsiStringToUnicodeString(&LinkNameUnicodeString,
                                                  &LinkName, TRUE);

          if(NT_SUCCESS(NtStatus))
          {
              DEBUG_TRACE3(("Create Device (%s)\n", DeviceNameBuffer));

              // create the device object
              NtStatus = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION),
                                        &DeviceNameUnicodeString,
                                        FILE_DEVICE_MODEM, 0, TRUE,
                                        DeviceObject);
          } else {
             goto CreateDeviceObjectError;
          }
      } else {
         goto CreateDeviceObjectError;
      }

      // created the device object O.K., create symbolic links,
      // attach device object, and fill in the device extension

      if (NT_SUCCESS(NtStatus)) {
         // create symbolic links

         DEBUG_TRACE3(("Create SymLink (%s)\n", DeviceLinkBuffer));


         NtStatus = IoCreateUnprotectedSymbolicLink(&LinkNameUnicodeString,
                                                    &DeviceNameUnicodeString);

         if (NtStatus != STATUS_SUCCESS) {
            goto CreateDeviceObjectError;
         }

         // get pointer to device extension
         DeviceExtension = (PDEVICE_EXTENSION) (*DeviceObject)->DeviceExtension;

         // let's zero out device extension
         RtlZeroMemory(DeviceExtension, sizeof(DEVICE_EXTENSION));

         // save our strings

         // save link name
         strcpy(DeviceExtension->LinkName, DeviceLinkBuffer);

         bufferLen = RtlAnsiStringToUnicodeSize(&DevName);

         DeviceExtension->DeviceName.Length = 0;
         DeviceExtension->DeviceName.MaximumLength = (USHORT)bufferLen;

         DeviceExtension->DeviceName.Buffer = DEBUG_MEMALLOC(PagedPool,
                                                             bufferLen);

         if (DeviceExtension->DeviceName.Buffer == NULL) {
            //
            // Skip out.  We have worse problems than missing
            // the name.
            //

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto CreateDeviceObjectError;
         } else {
            RtlAnsiStringToUnicodeString(&DeviceExtension->DeviceName, &DevName,
                                          FALSE);


            // save physical device object
            DeviceExtension->PhysDeviceObject  = *DeviceObject;
            DeviceExtension->Instance          = DeviceInstance;

            // initialize spinlocks
            KeInitializeSpinLock(&DeviceExtension->ControlLock);

            // mark this device slot as in use and increment number
            // of devices
            KeAcquireSpinLock(&GlobalSpinLock, &OldIrql);

            Slots[DeviceInstance]     = TRUE;
            NumDevices++;

            KeReleaseSpinLock(&GlobalSpinLock, OldIrql);

            DeviceExtension->IsDevice = TRUE;

            KeInitializeEvent(&DeviceExtension->PendingDataInEvent,
                              SynchronizationEvent, FALSE);
            KeInitializeEvent(&DeviceExtension->PendingDataOutEvent,
                              SynchronizationEvent, FALSE);
            KeInitializeEvent(&DeviceExtension->PendingNotifyEvent,
                              SynchronizationEvent, FALSE);
            KeInitializeEvent(&DeviceExtension->PendingFlushEvent,
                              SynchronizationEvent, FALSE);

            DeviceExtension->PendingDataInCount = 1;
            DeviceExtension->PendingDataOutCount = 1;
            DeviceExtension->PendingNotifyCount = 1;
            DeviceExtension->SanityCheck = SANITY_CHECK;

         }
      }

CreateDeviceObjectError:;
      // free Unicode strings
      RtlFreeUnicodeString(&DeviceNameUnicodeString);
      RtlFreeUnicodeString(&LinkNameUnicodeString);

      //
      // Delete the devobj if there was an error
      //

      if (NtStatus != STATUS_SUCCESS) {
         if (*DeviceObject) {
            IoDeleteDevice(*DeviceObject);
            *DeviceObject = NULL;
         }
      }
   }

   // log an error if we got one
   DEBUG_LOG_ERROR(NtStatus);
   DEBUG_LOG_PATH("exit  CreateDeviceObject");
   DEBUG_TRACE3(("status (%08X)\n", NtStatus));

   return NtStatus;
} // CreateDeviceObject


/************************************************************************/
/* CompleteIO                                                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Complete IO request and log IRP                                     */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*  DeviceObject  - pointer to device object.                           */
/*  Irp           - pointer to IRP.                                     */
/*  MajorFunction - major function of IRP.                              */
/*  IoBuffer      - buffer for data passed in and out of driver.        */
/*  BufferLen     - length of buffer                                    */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
CompleteIO(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN ULONG MajorFunction,
           IN PVOID IoBuffer, IN ULONG_PTR BufferLen)
{
   PDEVICE_EXTENSION DeviceExtension;

   DEBUG_LOG_PATH("enter CompleteIO");

   // get pointer to device extension
   DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

   // log IRP count and bytes processed in device extension
   DeviceExtension->IRPCount++;
   DeviceExtension->ByteCount
      = RtlLargeIntegerAdd(DeviceExtension->ByteCount,
                           RtlConvertUlongToLargeInteger((ULONG)Irp->IoStatus
                                                         .Information));

   // make entry in IRP history table
   DEBUG_LOG_IRP_HIST(DeviceObject, Irp, MajorFunction, IoBuffer,
                      (ULONG)BufferLen);

   // if we got here, must want to complete request on IRP
   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   DEBUG_LOG_PATH("exit  CompleteIO");
} // CompleteIO


/************************************************************************/
/* DeleteObjectAndLink                                                  */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Deletes a device object and associated symbolic link                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*  DeviceObject - pointer to device object.                            */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
DeleteObjectAndLink(IN PDEVICE_OBJECT DeviceObject)
{
        PDEVICE_EXTENSION       DeviceExtension;
        UNICODE_STRING          DeviceLinkUnicodeString;
        ANSI_STRING             DeviceLinkAnsiString;
        NTSTATUS                NtStatus;

        PAGED_CODE();

        DEBUG_LOG_PATH("enter DeleteObjectAndLink");

        DEBUG_TRACE1(("DeleteObjectAndLink\n"));

        // get pointer to device extension, we will get the symbolic link name
        // here
        DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

        // get rid of the symbolic link
        RtlInitAnsiString(&DeviceLinkAnsiString, DeviceExtension->LinkName);
        NtStatus = RtlAnsiStringToUnicodeString(&DeviceLinkUnicodeString,
                                                &DeviceLinkAnsiString, TRUE);

        DEBUG_TRACE1(("Delete Symbolic Link\n"));

        IoDeleteSymbolicLink(&DeviceLinkUnicodeString);

        // clear out slot and decrement number of devices
        if(DeviceExtension->Instance < NUM_DEVICE_SLOTS)
        {
                UsbSerFetchBooleanLocked(&Slots[DeviceExtension->Instance],
                                         FALSE, &GlobalSpinLock);
                NumDevices--;

                if(!NumDevices)
                    DEBUG_CHECKMEM();
        }

        DEBUG_TRACE1(("Delete Device Object\n"));

        if(DeviceExtension->SanityCheck != SANITY_CHECK)
        {
            DEBUG_TRACE1(("Device Extension Scrozzled\n"));
        }

        // wait to do this till here as this triggers unload routine
        IoDeleteDevice(DeviceObject);

        DEBUG_TRACE1(("Done Deleting Device Object and Link\n"));

        DEBUG_LOG_PATH("exit  DeleteObjectAndLink");

        return NtStatus;
} // DeleteObjectAndLink


/************************************************************************/
/* StartPerfTimer                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Start perf timer for measuring bytes/second throughput              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*  DeviceExtension - pointer to device extension for device            */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
StartPerfTimer(IN OUT PDEVICE_EXTENSION DeviceExtension)
{
   PAGED_CODE();

        // set up perf stuff if perf timing enabled
        if(DeviceExtension && DeviceExtension->PerfTimerEnabled)
        {
                // get current perf counter
                DeviceExtension->TimerStart = KeQueryPerformanceCounter(NULL);
        }
} // StartPerfTimer


/************************************************************************/
/* StopPerfTimer                                                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Stop perf timer for measuring bytes/second throughput               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*  DeviceExtension - pointer to device extension for device            */
/*  BytesXfered     - number of bytes tranferred this iteration         */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
StopPerfTimer(IN OUT PDEVICE_EXTENSION DeviceExtension,
              IN ULONG BytesXfered)
{
        LARGE_INTEGER   BytesThisTransfer;
        LARGE_INTEGER   CurrentTime;
        LARGE_INTEGER   TimeThisTransfer;

        PAGED_CODE();

        if(DeviceExtension && DeviceExtension->PerfTimerEnabled)
        {
                // get updated time
                CurrentTime = KeQueryPerformanceCounter(NULL);

                // stop perf timing with system timer
                BytesThisTransfer = RtlConvertUlongToLargeInteger(BytesXfered);

                DeviceExtension->BytesXfered
                   = RtlLargeIntegerAdd(DeviceExtension->BytesXfered,
                                        BytesThisTransfer);

                // now add the time it took to elapsed time
                TimeThisTransfer
                   = RtlLargeIntegerSubtract(CurrentTime,
                                             DeviceExtension->TimerStart);

                DeviceExtension->ElapsedTime
                   = RtlLargeIntegerAdd(DeviceExtension->ElapsedTime,
                                        TimeThisTransfer);
        }

} // StopPerfTimer


/************************************************************************/
/* BytesPerSecond                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*  Start perf timer for measuring bytes/second throughput              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*  DeviceExtension - pointer to device extension for device            */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      ULONG - bytes/second for device                                 */
/*                                                                      */
/************************************************************************/
ULONG
BytesPerSecond(IN OUT PDEVICE_EXTENSION DeviceExtension)
{
        ULONG                   Remainder;
        LARGE_INTEGER   Result;
        LARGE_INTEGER   TicksPerSecond;

        PAGED_CODE();

        // get ticks per second from perf counter
        KeQueryPerformanceCounter(&TicksPerSecond);

        // scale the bytes xfered
        Result = RtlExtendedIntegerMultiply(DeviceExtension->BytesXfered,
                                            TicksPerSecond.LowPart);

        // Don't divide by 0
        DeviceExtension->ElapsedTime.LowPart
           = (DeviceExtension->ElapsedTime.LowPart == 0L) ? 1 :
           DeviceExtension->ElapsedTime.LowPart;

        // lets get stats here
        Result
           = RtlExtendedLargeIntegerDivide(Result,
                                           DeviceExtension->ElapsedTime.LowPart,
                                           &Remainder);

        return Result.LowPart;
} // BytesPerSecond


/************************************************************************/
/* CallUSBD                                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Call USB bus driver.                                            */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Urb          - pointer to URB                                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
CallUSBD(IN PDEVICE_OBJECT DeviceObject, IN PURB Urb)
{
   NTSTATUS             NtStatus = STATUS_SUCCESS;
   PDEVICE_EXTENSION    DeviceExtension = DeviceObject->DeviceExtension;
   PIRP                 Irp;
   KEVENT               Event;
   PIO_STACK_LOCATION   NextStack;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter CallUSBD");

   // issue a synchronous request
   KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

   Irp = IoAllocateIrp(DeviceExtension->StackDeviceObject->StackSize, FALSE);

   if (Irp == NULL)
   {
     return STATUS_INSUFFICIENT_RESOURCES;
   }

    // Set the Irp parameters
    NextStack = IoGetNextIrpStackLocation(Irp);

    NextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    NextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    NextStack->Parameters.Others.Argument1 = Urb;

    // Set the completion routine, which will signal the event
    IoSetCompletionRoutine(Irp,
                           CallUSBD_SyncCompletionRoutine,
                           &Event,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel

   DEBUG_LOG_PATH("Calling USB driver stack");

   NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, Irp);

   DEBUG_LOG_PATH("Returned from calling USB driver stack");

   // block on pending request
   if(NtStatus == STATUS_PENDING)
   {
        LARGE_INTEGER timeout;

        // Specify a timeout of 30 seconds to wait for this call to complete.
        //
        timeout.QuadPart = -10000 * 30000;

        NtStatus = KeWaitForSingleObject(&Event,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         &timeout);

        if(NtStatus == STATUS_TIMEOUT)
        {
            NtStatus = STATUS_IO_TIMEOUT;

            // Cancel the Irp we just sent.
            //
            IoCancelIrp(Irp);

            // And wait until the cancel completes
            //
            KeWaitForSingleObject(&Event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        else
        {
            NtStatus = Irp->IoStatus.Status;
        }
   }

   IoFreeIrp(Irp);

   DEBUG_LOG_PATH("exit  CallUSBD");

   return NtStatus;
} // CallUSBD

/************************************************************************/
/* CallUSBD_SyncCompletionRoutine                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Completion routine for USB sync request.                        */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
CallUSBD_SyncCompletionRoutine(IN PDEVICE_OBJECT   DeviceObject,
                        IN PIRP             Irp,
                        IN PVOID            Context)
{
    PKEVENT kevent;

    kevent = (PKEVENT) Context;

    KeSetEvent(kevent, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
} // CallUSBD_SyncCompletionRoutine


/************************************************************************/
/* GetDeviceDescriptor                                                  */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Get device descriptor for USB device.                           */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetDeviceDescriptor(IN PDEVICE_OBJECT DeviceObject)
{
   PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
   NTSTATUS                NtStatus;
   PUSB_DEVICE_DESCRIPTOR  DeviceDescriptor;
   PURB                    Urb;
   ULONG                   Size;
   ULONG                   UrbCDRSize;
   KIRQL                   OldIrql;

   DEBUG_LOG_PATH("enter GetDeviceDescriptor");

   UrbCDRSize = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);

   Urb = DEBUG_MEMALLOC(NonPagedPool, UrbCDRSize);

   if (Urb) {
      Size = sizeof(USB_DEVICE_DESCRIPTOR);

      DeviceDescriptor = DEBUG_MEMALLOC(NonPagedPool, Size);

      if (DeviceDescriptor) {

         UsbBuildGetDescriptorRequest(Urb, (USHORT)UrbCDRSize,
                                      USB_DEVICE_DESCRIPTOR_TYPE, 0, 0,
                                      DeviceDescriptor, NULL, Size, NULL);

         NtStatus = CallUSBD(DeviceObject, Urb);

         if (NT_SUCCESS(NtStatus)) {
            DEBUG_TRACE3(("Device Descriptor  (%08X)\n", DeviceDescriptor));
            DEBUG_TRACE3(("Length             (%08X)\n",
                          Urb->UrbControlDescriptorRequest
                          .TransferBufferLength));
            DEBUG_TRACE3(("Device Descriptor:\n"));
            DEBUG_TRACE3(("-------------------------\n"));
            DEBUG_TRACE3(("bLength            (%08X)\n",
                          DeviceDescriptor->bLength));
            DEBUG_TRACE3(("bDescriptorType    (%08X)\n",
                          DeviceDescriptor->bDescriptorType));
            DEBUG_TRACE3(("bcdUSB             (%08X)\n",
                          DeviceDescriptor->bcdUSB));
            DEBUG_TRACE3(("bDeviceClass       (%08X)\n",
                          DeviceDescriptor->bDeviceClass));
            DEBUG_TRACE3(("bDeviceSubClass    (%08X)\n",
                          DeviceDescriptor->bDeviceSubClass));
            DEBUG_TRACE3(("bDeviceProtocol    (%08X)\n",
                          DeviceDescriptor->bDeviceProtocol));
            DEBUG_TRACE3(("bMaxPacketSize0    (%08X)\n",
                          DeviceDescriptor->bMaxPacketSize0));
            DEBUG_TRACE3(("idVendor           (%08X)\n",
                          DeviceDescriptor->idVendor));
            DEBUG_TRACE3(("idProduct          (%08X)\n",
                          DeviceDescriptor->idProduct));
            DEBUG_TRACE3(("bcdDevice          (%08X)\n",
                          DeviceDescriptor->bcdDevice));
            DEBUG_TRACE3(("iManufacturer      (%08X)\n",
                          DeviceDescriptor->iManufacturer));
            DEBUG_TRACE3(("iProduct           (%08X)\n",
                          DeviceDescriptor->iProduct));
            DEBUG_TRACE3(("iSerialNumber      (%08X)\n",
                          DeviceDescriptor->iSerialNumber));
            DEBUG_TRACE3(("bNumConfigurations (%08X)\n",
                          DeviceDescriptor->bNumConfigurations));
         }
      } else {
         NtStatus = STATUS_INSUFFICIENT_RESOURCES;
      }

      // save the device descriptor
      if (NT_SUCCESS(NtStatus)) {
         PVOID pOldDesc = NULL;

         ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

         if (DeviceExtension->DeviceDescriptor) {
            pOldDesc = DeviceExtension->DeviceDescriptor;
         }
         DeviceExtension->DeviceDescriptor = DeviceDescriptor;

         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

         if (pOldDesc != NULL) {
            DEBUG_MEMFREE(pOldDesc);
         }
      } else if (DeviceDescriptor) {
         DEBUG_MEMFREE(DeviceDescriptor);
      }

      DEBUG_MEMFREE(Urb);

   } else {
      NtStatus = STATUS_INSUFFICIENT_RESOURCES;
   }

   DEBUG_LOG_PATH("exit  GetDeviceDescriptor");

   return NtStatus;
} // GetDeviceDescriptor


/************************************************************************/
/* ConfigureDevice                                                      */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Initializes USB device and selects configuration.               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ConfigureDevice(IN PDEVICE_OBJECT DeviceObject)
{
   PDEVICE_EXTENSION                DeviceExtension
                                       = DeviceObject->DeviceExtension;
   NTSTATUS                         NtStatus;
   PURB                             Urb;
   ULONG                            Size;
   ULONG                            UrbCDRSize;
   PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor;
   ULONG                            NumConfigs;
   UCHAR                            Config;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter ConfigureDevice");

   UrbCDRSize = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);

   // first configure the device
   Urb = DEBUG_MEMALLOC(NonPagedPool, UrbCDRSize);

   if (Urb) {

      // there may be problems with the 82930 chip, so make this buffer bigger
      // to prevent choking
      Size = sizeof(USB_CONFIGURATION_DESCRIPTOR) + 256;

      // get the number of configurations
      NumConfigs = DeviceExtension->DeviceDescriptor->bNumConfigurations;

      // run through all of the configurations looking for a CDC device
      for (Config = 0; Config < NumConfigs; Config++) {

         // we will probably only do this once, maybe twice
         while (TRUE) {

            ConfigurationDescriptor = DEBUG_MEMALLOC(NonPagedPool, Size);

            if (ConfigurationDescriptor) {
               UsbBuildGetDescriptorRequest(Urb, (USHORT)UrbCDRSize,
                                            USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                            Config, 0, ConfigurationDescriptor,
                                            NULL, Size, NULL);

               NtStatus = CallUSBD(DeviceObject, Urb);

               DEBUG_TRACE3(("Configuration Descriptor (%08X)   "
                             "Length (%08X)\n", ConfigurationDescriptor,
                             Urb->UrbControlDescriptorRequest
                             .TransferBufferLength));
            } else {
               NtStatus = STATUS_INSUFFICIENT_RESOURCES;
               break;
            }

            // see if we got enough data, we may get an error in URB because of
            // buffer overrun
            if (Urb->UrbControlDescriptorRequest.TransferBufferLength>0 &&
                ConfigurationDescriptor->wTotalLength > Size) {
               // size of data exceeds current buffer size, so allocate correct
               // size
               Size = ConfigurationDescriptor->wTotalLength;
               DEBUG_MEMFREE(ConfigurationDescriptor);
               ConfigurationDescriptor = NULL;
            } else {
               break;
            }
         }

         if (NT_SUCCESS(NtStatus)) {
            NtStatus = SelectInterface(DeviceObject, ConfigurationDescriptor);
            DEBUG_MEMFREE(ConfigurationDescriptor);
            ConfigurationDescriptor = NULL;
         }
         else
         {
            DEBUG_MEMFREE(ConfigurationDescriptor);
            ConfigurationDescriptor = NULL;
         }


         // found a config we like
         if (NT_SUCCESS(NtStatus))
            break;
      }

      DEBUG_MEMFREE(Urb);
   } else {
      NtStatus = STATUS_INSUFFICIENT_RESOURCES;
   }


   DEBUG_LOG_PATH("exit  ConfigureDevice");

   return NtStatus;
} // ConfigureDevice


/************************************************************************/
/* SelectInterface                                                      */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Select interface for USB device.                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject             - pointer to a device object           */
/*      ConfigurationDescriptor  - pointer to config descriptor         */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SelectInterface(IN PDEVICE_OBJECT DeviceObject,
                IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor)
{
   PDEVICE_EXTENSION             DeviceExtension
                                    = DeviceObject->DeviceExtension;
   NTSTATUS                      NtStatus;
   PURB                          Urb;
   USHORT                        Size;
   ULONG                         Index;
   PUSBD_INTERFACE_INFORMATION   Interfaces[2];
   PUSBD_INTERFACE_INFORMATION   Interface;
   PUSB_INTERFACE_DESCRIPTOR     InterfaceDescriptor[2];
   UCHAR                         AlternateSetting, InterfaceNumber;
   ULONG                         Pipe;
   KIRQL                         OldIrql;
   PUCHAR                        Temp;
   BOOLEAN                       FoundCommDevice = FALSE;

   DEBUG_LOG_PATH("enter SelectInterface");

   Urb = USBD_CreateConfigurationRequest(ConfigurationDescriptor, &Size);

   if (Urb) {
      Temp = (PUCHAR) &Urb->UrbSelectConfiguration.Interface;

      for (InterfaceNumber = 0;
           InterfaceNumber < ConfigurationDescriptor->bNumInterfaces;
           InterfaceNumber++) {
         AlternateSetting        = 0;

         InterfaceDescriptor[InterfaceNumber] =
            USBD_ParseConfigurationDescriptor(ConfigurationDescriptor,
                                              InterfaceNumber,
                                              AlternateSetting);

         Interfaces[InterfaceNumber] = (PUSBD_INTERFACE_INFORMATION) Temp;

         Interfaces[InterfaceNumber]->Length
            = GET_USBD_INTERFACE_SIZE(InterfaceDescriptor[InterfaceNumber]
                                      ->bNumEndpoints);
         Interfaces[InterfaceNumber]->InterfaceNumber
            = InterfaceDescriptor[InterfaceNumber]->bInterfaceNumber;
         Interfaces[InterfaceNumber]->AlternateSetting
            = InterfaceDescriptor[InterfaceNumber]->bAlternateSetting;

         for (Index = 0; Index < Interfaces[InterfaceNumber]->NumberOfPipes;
              Index++)
         {
                PUSBD_PIPE_INFORMATION          PipeInformation;

            PipeInformation = &Interfaces[InterfaceNumber]->Pipes[Index];

            if (USB_ENDPOINT_DIRECTION_IN(PipeInformation->EndpointAddress))
            {
               // check for data in pipe
               if (PipeInformation->PipeType == USB_ENDPOINT_TYPE_BULK)
               {
                    // set bulk pipe in max transfer size
                    PipeInformation->MaximumTransferSize
                                = USB_RX_BUFF_SIZE;
               }
            }
            else if (USB_ENDPOINT_DIRECTION_OUT(PipeInformation->EndpointAddress))
            {
               // check for data out pipe
               if (PipeInformation->PipeType == USB_ENDPOINT_TYPE_BULK)
               {

                    // set bulk pipe out max transfer size
                    PipeInformation->MaximumTransferSize
                                = MAXIMUM_TRANSFER_SIZE;
               }
            }
         }

         Temp += Interfaces[InterfaceNumber]->Length;
      }


      UsbBuildSelectConfigurationRequest(Urb, Size, ConfigurationDescriptor);

      NtStatus = CallUSBD(DeviceObject, Urb);

      if (NtStatus != STATUS_SUCCESS) {
         ExFreePool(Urb);
         goto ExitSelectInterface;
      }

      DEBUG_TRACE3(("Select Config Status (%08X)\n", NtStatus));

      DeviceExtension->ConfigurationHandle
         = Urb->UrbSelectConfiguration.ConfigurationHandle;

      for (InterfaceNumber = 0;
           InterfaceNumber < ConfigurationDescriptor->bNumInterfaces;
           InterfaceNumber++) {

         Interface = Interfaces[InterfaceNumber];

         DEBUG_TRACE3(("---------\n"));
         DEBUG_TRACE3(("NumberOfPipes     (%08X)\n", Interface->NumberOfPipes));
         DEBUG_TRACE3(("Length            (%08X)\n", Interface->Length));
         DEBUG_TRACE3(("Alt Setting       (%08X)\n",
                       Interface->AlternateSetting));
         DEBUG_TRACE3(("Interface Number  (%08X)\n",
                       Interface->InterfaceNumber));
         DEBUG_TRACE3(("Class (%08X)  SubClass (%08X)  Protocol (%08X)\n",
                       Interface->Class,
                       Interface->SubClass,
                       Interface->Protocol));

         if (Interface->Class == USB_COMM_COMMUNICATION_CLASS_CODE) {
            FoundCommDevice = TRUE;
            DeviceExtension->CommInterface = Interface->InterfaceNumber;
         }

         for (Pipe = 0; Pipe < Interface->NumberOfPipes; Pipe++) {
            PUSBD_PIPE_INFORMATION          PipeInformation;

            PipeInformation = &Interface->Pipes[Pipe];

            DEBUG_TRACE3(("---------\n"));
            DEBUG_TRACE3(("PipeType            (%08X)\n",
                          PipeInformation->PipeType));
            DEBUG_TRACE3(("EndpointAddress     (%08X)\n",
                          PipeInformation->EndpointAddress));
            DEBUG_TRACE3(("MaxPacketSize       (%08X)\n",
                          PipeInformation->MaximumPacketSize));
            DEBUG_TRACE3(("Interval            (%08X)\n",
                          PipeInformation->Interval));
            DEBUG_TRACE3(("Handle              (%08X)\n",
                          PipeInformation->PipeHandle));
            DEBUG_TRACE3(("MaximumTransferSize (%08X)\n",
                          PipeInformation->MaximumTransferSize));

            // now lets save pipe handles in device extension
            if (USB_ENDPOINT_DIRECTION_IN(PipeInformation->EndpointAddress)) {
               // check for data in pipe
               if (PipeInformation->PipeType == USB_ENDPOINT_TYPE_BULK) {
                  PVOID pOldNotBuff = NULL;
                  PVOID pOldReadBuff = NULL;
				  PVOID pOldUSBReadBuff = NULL;
				  PVOID pNewNotBuff = NULL;
                  PVOID pNewReadBuff = NULL;
                  PVOID pNewUSBReadBuff = NULL;

                  DeviceExtension->RxMaxPacketSize = RxBuffSize;

                  if (DeviceExtension->RxMaxPacketSize != 0) {
                     pNewReadBuff = DEBUG_MEMALLOC(NonPagedPool,
                                                   DeviceExtension->RxMaxPacketSize);
                  }

                  pNewNotBuff = DEBUG_MEMALLOC(NonPagedPool,
                                               NOTIFICATION_BUFF_SIZE);

                  pNewUSBReadBuff = DEBUG_MEMALLOC(NonPagedPool,
                                                   USB_RX_BUFF_SIZE);

                  ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                  DeviceExtension->DataInPipe = PipeInformation->PipeHandle;

                  if (DeviceExtension->NotificationBuff)
                     pOldNotBuff = DeviceExtension->NotificationBuff;

                  if (DeviceExtension->ReadBuff)
                     pOldReadBuff = DeviceExtension->ReadBuff;

                  if (DeviceExtension->USBReadBuff)
                     pOldUSBReadBuff = DeviceExtension->USBReadBuff;

                  DeviceExtension->RxQueueSize
                     = DeviceExtension->RxMaxPacketSize;
                  DeviceExtension->CharsInReadBuff                = 0;
                  DeviceExtension->CurrentReadBuffPtr             = 0;

                  DeviceExtension->ReadBuff = pNewReadBuff;

                  DeviceExtension->USBReadBuff = pNewUSBReadBuff;

                  DeviceExtension->NotificationBuff = pNewNotBuff;

                  RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

                  if (pOldNotBuff != NULL) {
                     DEBUG_MEMFREE(pOldNotBuff);
                  }

                  if (pOldReadBuff != NULL) {
                     DEBUG_MEMFREE(pOldReadBuff);
                  }

                  if (pOldUSBReadBuff != NULL) {
                     DEBUG_MEMFREE(pOldUSBReadBuff);
                  }
               }
               // check for notification pipe
               else if (PipeInformation->PipeType
                        == USB_ENDPOINT_TYPE_INTERRUPT)
                  DeviceExtension->NotificationPipe
                  = PipeInformation->PipeHandle;
            } else {
               // check for data out pipe
               if (PipeInformation->PipeType == USB_ENDPOINT_TYPE_BULK)
                  DeviceExtension->DataOutPipe = PipeInformation->PipeHandle;
            }
         }

         DEBUG_TRACE3(("Data Out (%08X)  Data In (%08X)  Notification (%08X)\n",
                       DeviceExtension->DataOutPipe,
                       DeviceExtension->DataInPipe,
                       DeviceExtension->NotificationPipe));

      }
      ExFreePool(Urb);
   } else {
      NtStatus = STATUS_INSUFFICIENT_RESOURCES;
   }

   if (!FoundCommDevice)
      NtStatus = STATUS_NO_SUCH_DEVICE;

ExitSelectInterface:;

   DEBUG_LOG_PATH("exit  SelectInterface");

   return NtStatus;
} // SelectInterface


/************************************************************************/
/* BuildRequest                                                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Build a Urb for a USB request                                   */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to Irp                                   */
/*      PipeHandle   - USB pipe handle                                  */
/*      Read         - transfer direction                               */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      Pointer to URB                                                  */
/*                                                                      */
/************************************************************************/
PURB
BuildRequest(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
             IN USBD_PIPE_HANDLE PipeHandle, IN BOOLEAN Read)
{
   ULONG                   Size;
   ULONG                   Length;
   PURB                    Urb;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter BuildRequest");

   // length of buffer
   Length = MmGetMdlByteCount(Irp->MdlAddress);

   // allocate and zero Urb
   Size = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
   Urb = DEBUG_MEMALLOC(NonPagedPool, Size);

   if (Urb) {
      RtlZeroMemory(Urb, Size);

      Urb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT) Size;
      Urb->UrbBulkOrInterruptTransfer.Hdr.Function =
         URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
      Urb->UrbBulkOrInterruptTransfer.PipeHandle = PipeHandle;
      Urb->UrbBulkOrInterruptTransfer.TransferFlags =
         Read ? USBD_TRANSFER_DIRECTION_IN : 0;

      // use an MDL
      Urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = Irp->MdlAddress;
      Urb->UrbBulkOrInterruptTransfer.TransferBufferLength = Length;

      // short packet is not treated as an error.
      Urb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;

      // no linkage for now
      Urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
   }

   DEBUG_LOG_PATH("exit  BuildRequest");

   return Urb;
} // BuildRequest


/************************************************************************/
/* BuildReadRequest                                                     */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Build a Urb for a USB read request                              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Urb          - pointer to URB                                   */
/*      Buffer       - pointer to data buffer                           */
/*      Length       - length of data buffer                            */
/*      PipeHandle   - USB pipe handle                                  */
/*      Read         - transfer direction                               */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
BuildReadRequest(PURB Urb, PUCHAR Buffer, ULONG Length,
                 IN USBD_PIPE_HANDLE PipeHandle, IN BOOLEAN Read)
{
        ULONG           Size;

//        PAGED_CODE();

        DEBUG_LOG_PATH("enter BuildReadRequest");

        Size = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

        // zero Urb
        RtlZeroMemory(Urb, Size);

        Urb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT) Size;
        Urb->UrbBulkOrInterruptTransfer.Hdr.Function =
                                URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
        Urb->UrbBulkOrInterruptTransfer.PipeHandle = PipeHandle;
        Urb->UrbBulkOrInterruptTransfer.TransferFlags =
                                Read ? USBD_TRANSFER_DIRECTION_IN : 0;

        // we are using a tranfsfer buffer instead of an MDL
        Urb->UrbBulkOrInterruptTransfer.TransferBuffer = Buffer;
        Urb->UrbBulkOrInterruptTransfer.TransferBufferLength = Length;
        Urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;

        // short packet is not treated as an error.
        Urb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;

        // no linkage for now
        Urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

        DEBUG_LOG_PATH("exit  BuildReadRequest");

} // BuildReadRequest


/************************************************************************/
/* ClassVendorCommand                                                   */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Issue class or vendor specific command                          */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Request      - request field of class/vendor specific command   */
/*      Value        - value field of class/vendor specific command     */
/*      Index        - index field of class/vendor specific command     */
/*      Buffer       - pointer to data buffer                           */
/*      BufferLen    - data buffer length                               */
/*      Read         - data direction flag                              */
/*      Class        - True if Class Command, else vendor command       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ClassVendorCommand(IN PDEVICE_OBJECT DeviceObject, IN UCHAR Request,
                   IN USHORT Value, IN USHORT Index, IN PVOID Buffer,
                   IN OUT PULONG BufferLen, IN BOOLEAN Read, IN ULONG ComType)
{
   NTSTATUS NtStatus;
   PURB     Urb;
   ULONG    Size;
   ULONG    Length;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter VendorCommand");

   // length of buffer passed in
   Length = BufferLen ? *BufferLen : 0;

   Size = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);

   // allocate memory for the Urb
   Urb = DEBUG_MEMALLOC(NonPagedPool, Size);

   if (Urb) {
      UsbBuildVendorRequest(Urb, ComType == USBSER_CLASS_COMMAND
                            ? URB_FUNCTION_CLASS_INTERFACE
                            : URB_FUNCTION_VENDOR_DEVICE, (USHORT) Size,
                            Read ? USBD_TRANSFER_DIRECTION_IN
                            : USBD_TRANSFER_DIRECTION_OUT, 0, Request, Value,
                            Index, Buffer, NULL, Length, NULL);

      NtStatus = CallUSBD(DeviceObject, Urb);

      // get length of buffer
      if (BufferLen)
         *BufferLen = Urb->UrbControlVendorClassRequest.TransferBufferLength;

      DEBUG_MEMFREE(Urb);
   } else {
      NtStatus = STATUS_INSUFFICIENT_RESOURCES;
   }


   DEBUG_LOG_PATH("exit  VendorCommand");

   return NtStatus;
} // ClassVendorCommand


/************************************************************************/
/* CancelPendingWaitMasks                                               */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Cancels any wait masks in progress.                             */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to a device extension                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
CancelPendingWaitMasks(IN PDEVICE_EXTENSION DeviceExtension)
{
        KIRQL                                   OldIrql;
        PIRP                                    CurrentMaskIrp;

        DEBUG_LOG_PATH("enter CancelPendingWaitMasks");
        UsbSerSerialDump(USBSERTRACEOTH, (">CancelPendingWaitMasks\n"));

        ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

        CurrentMaskIrp = DeviceExtension->CurrentMaskIrp;

        // mark current pending wait mask as cancelled
        if(CurrentMaskIrp)
        {
                DeviceExtension->CurrentMaskIrp         = NULL;


                CurrentMaskIrp->IoStatus.Status         = STATUS_CANCELLED;
                CurrentMaskIrp->IoStatus.Information    = 0;
                IoSetCancelRoutine(CurrentMaskIrp, NULL);

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

                IoCompleteRequest(CurrentMaskIrp, IO_NO_INCREMENT);
                DEBUG_TRACE1(("CancelPendingWaitMask\n"));
        } else {
           RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
        }

        DEBUG_LOG_PATH("exit  CancelPendingWaitMasks");
        UsbSerSerialDump(USBSERTRACEOTH, ("<CancelPendingWaitMasks\n"));

} // CancelPendingWaitMasks




/************************************************************************/
/* StartRead                                                            */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Kick off a read.                                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to a device extension                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
StartRead(IN PDEVICE_EXTENSION DeviceExtension)
{
   PIRP                                    ReadIrp;
   PURB                                    ReadUrb;
   CCHAR                                   StackSize;
   ULONG                                   Size;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter StartRead");
   UsbSerSerialDump(USBSERTRACERD, (">StartRead\n"));

   // get stack size for Irp and allocate one that we will use to keep
   // read requests going
   StackSize = (CCHAR)(DeviceExtension->StackDeviceObject->StackSize + 1);

   ReadIrp = IoAllocateIrp(StackSize, FALSE);

   if (ReadIrp) {
      // get size of Urb and allocate
      Size = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

      ReadUrb = DEBUG_MEMALLOC(NonPagedPool, Size);

      if (ReadUrb) {

         KeInitializeEvent(&DeviceExtension->ReadEvent, NotificationEvent,
                           FALSE);

         // save these to be freed when not needed

         UsbSerFetchPVoidLocked(&DeviceExtension->ReadIrp, ReadIrp,
                                &DeviceExtension->ControlLock);

         UsbSerFetchPVoidLocked(&DeviceExtension->ReadUrb, ReadUrb,
                                &DeviceExtension->ControlLock);

         RestartRead(DeviceExtension);
      }
   }

   UsbSerSerialDump(USBSERTRACERD, ("<StartRead\n"));
   DEBUG_LOG_PATH("exit  StartRead");
} // StartRead


/************************************************************************/
/* RestartRead                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Restart read request.                                           */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to a device extension                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
RestartRead(IN PDEVICE_EXTENSION DeviceExtension)
{
   PIRP                 ReadIrp;
   PURB                 ReadUrb;
   PIO_STACK_LOCATION   NextStack;
   BOOLEAN              StartAnotherRead;
   KIRQL                OldIrql;
   NTSTATUS             NtStatus;

   DEBUG_LOG_PATH("enter RestartRead");
   UsbSerSerialDump(USBSERTRACERD, (">RestartRead\n"));

   do
   {
   		StartAnotherRead = FALSE;
   
   		ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   		if(!DeviceExtension->ReadInProgress && DeviceExtension->CharsInReadBuff <= LOW_WATER_MARK
       	   && DeviceExtension->AcceptingRequests) 
   		{
      		StartAnotherRead = TRUE;
      		DeviceExtension->ReadInProgress = TRUE;
	  		DeviceExtension->ReadInterlock = START_READ;
   		}

   		RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

   		if(StartAnotherRead) 
   		{
      		ReadIrp = DeviceExtension->ReadIrp;
      		ReadUrb = DeviceExtension->ReadUrb;

      		BuildReadRequest(ReadUrb, DeviceExtension->USBReadBuff,
                       	 	 USB_RX_BUFF_SIZE,
                       	 	 DeviceExtension->DataInPipe, TRUE);

      		// set Irp up for a submit Urb IOCTL
      		NextStack = IoGetNextIrpStackLocation(ReadIrp);
      		NextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
      		NextStack->Parameters.Others.Argument1 = ReadUrb;
      		NextStack->Parameters.DeviceIoControl.IoControlCode
         		= IOCTL_INTERNAL_USB_SUBMIT_URB;

      		// completion routine will take care of updating buffers and counters
      		IoSetCompletionRoutine(ReadIrp,ReadCompletion, DeviceExtension, TRUE,
                               	   TRUE, TRUE);

      		DEBUG_TRACE1(("StartRead\n"));

      		InterlockedIncrement(&DeviceExtension->PendingDataInCount);
       		UsbSerSerialDump(USBSERTRACERD, ("DataInCounty %08X @ %08X\n",
                         	 DeviceExtension->PendingDataInCount,
                         	 &DeviceExtension->PendingDataInCount));

      		NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, ReadIrp);

      		DEBUG_TRACE1(("Read Status (%08X)\n", NtStatus));

      		if(!NT_SUCCESS(NtStatus)) 
      		{
         		if(InterlockedDecrement(&DeviceExtension->PendingDataInCount) == 0) 
         		{
            		KeSetEvent(&DeviceExtension->PendingDataInEvent, IO_NO_INCREMENT,
                       	   	   FALSE);
             		UsbSerSerialDump(USBSERTRACERD, ("DataInCountz %08X @ %08X\n",
                                 	 DeviceExtension->PendingDataInCount,
                                 	 &DeviceExtension->PendingDataInCount));
         		}
      		}

      		ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      		if(DeviceExtension->ReadInterlock == IMMEDIATE_READ)
      		{
      			StartAnotherRead = TRUE;
      		}
      		else
      		{
      			StartAnotherRead = FALSE;
      		}

	  		DeviceExtension->ReadInterlock = END_READ;

      		RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      	}
   }while(StartAnotherRead)

   DEBUG_LOG_PATH("exit  RestartRead");
   UsbSerSerialDump(USBSERTRACERD, ("<RestartRead\n"));
} // RestartRead


/************************************************************************/
/* StartNotifyRead                                                      */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Kick off a notify read.                                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to a device extension                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
StartNotifyRead(IN PDEVICE_EXTENSION DeviceExtension)
{
   PIRP     NotifyIrp;
   PURB     NotifyUrb;
   CCHAR    StackSize;
   ULONG    Size;

   PAGED_CODE();

   DEBUG_LOG_PATH("enter StartNotifyRead");
   UsbSerSerialDump(USBSERTRACERD, (">StartNotifyRead\n"));

   // get stack size for Irp and allocate one that we will use to keep
   // notification requests going
   StackSize = (CCHAR)(DeviceExtension->StackDeviceObject->StackSize + 1);

   NotifyIrp = IoAllocateIrp(StackSize, FALSE);

   if (NotifyIrp) {
      // get size of Urb and allocate
      Size = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

      NotifyUrb = DEBUG_MEMALLOC(NonPagedPool, Size);

      if (NotifyUrb) {
                  // save these to be freed when not needed
         UsbSerFetchPVoidLocked(&DeviceExtension->NotifyIrp, NotifyIrp,
                                &DeviceExtension->ControlLock);
         UsbSerFetchPVoidLocked(&DeviceExtension->NotifyUrb, NotifyUrb,
                                 &DeviceExtension->ControlLock);

         RestartNotifyRead(DeviceExtension);
      }
   }

   DEBUG_LOG_PATH("exit  StartNotifyRead");
   UsbSerSerialDump(USBSERTRACERD, ("<StartNotifyRead\n"));
} // StartNotifyRead


/************************************************************************/
/* RestartNotifyRead                                                    */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Kick off a notify read.                                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to a device extension                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
RestartNotifyRead(IN PDEVICE_EXTENSION DeviceExtension)
{
   PIRP                                    NotifyIrp;
   PURB                                    NotifyUrb;
   PIO_STACK_LOCATION              NextStack;
   NTSTATUS                                NtStatus;


   DEBUG_LOG_PATH("enter RestartNotifyRead");
   UsbSerSerialDump(USBSERTRACERD, (">RestartNotifyRead\n"));

   NotifyUrb = DeviceExtension->NotifyUrb;
   NotifyIrp = DeviceExtension->NotifyIrp;

   if(DeviceExtension->AcceptingRequests) 
   {
      BuildReadRequest(NotifyUrb, DeviceExtension->NotificationBuff,
                       NOTIFICATION_BUFF_SIZE,
                       DeviceExtension->NotificationPipe, TRUE);

      // set Irp up for a submit Urb IOCTL
      NextStack = IoGetNextIrpStackLocation(NotifyIrp);
      NextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
      NextStack->Parameters.Others.Argument1 = NotifyUrb;
      NextStack->Parameters.DeviceIoControl.IoControlCode
         = IOCTL_INTERNAL_USB_SUBMIT_URB;

      // completion routine will take care of updating buffers and counters
      IoSetCompletionRoutine(NotifyIrp, NotifyCompletion, DeviceExtension,
                             TRUE, TRUE, TRUE);

      DEBUG_TRACE1(("Start NotifyRead\n"));

      InterlockedIncrement(&DeviceExtension->PendingNotifyCount);

      NtStatus = IoCallDriver(DeviceExtension->StackDeviceObject, NotifyIrp);

      if (!NT_SUCCESS(NtStatus)) 
      {
         if (InterlockedDecrement(&DeviceExtension->PendingNotifyCount) == 0) 
         {
            KeSetEvent(&DeviceExtension->PendingNotifyEvent, IO_NO_INCREMENT, FALSE);
         }
      }

      DEBUG_TRACE1(("Status (%08X)\n", NtStatus));
   }

   DEBUG_LOG_PATH("exit  RestartNotifyRead");
   UsbSerSerialDump(USBSERTRACERD, ("<RestartNotifyRead\n"));
} // RestartNotifyRead


/************************************************************************/
/* ReadCompletion                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Read completion routine.                                        */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to Irp                                   */
/*      Context      - pointer to driver defined context                */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ReadCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
   PDEVICE_EXTENSION    DeviceExtension = (PDEVICE_EXTENSION) Context;
   PURB                 Urb;
   ULONG                Count;
   KIRQL                OldIrql;
   
   DEBUG_LOG_PATH("enter ReadCompletion");

   UsbSerSerialDump(USBSERTRACERD, (">ReadCompletion(%08X)\n", Irp));

   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   Urb = DeviceExtension->ReadUrb;

   Count = Urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

   if (NT_SUCCESS(Irp->IoStatus.Status)
       && (DeviceExtension->CurrentDevicePowerState == PowerDeviceD0)) 
   {

      DeviceExtension->HistoryMask |= SERIAL_EV_RXCHAR | SERIAL_EV_RX80FULL;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      //
      // Scan for RXFLAG char if needed
      //

      if(DeviceExtension->IsrWaitMask & SERIAL_EV_RXFLAG) 
      {
         ULONG i;

         for(i = 0; i < Count; i++) 
         {
            if(*((PUCHAR)(DeviceExtension->USBReadBuff + i))
                == DeviceExtension->SpecialChars.EventChar) 
            {
               DeviceExtension->HistoryMask |= SERIAL_EV_RXFLAG;
               break;
            }
         }
      }

	  PutData(DeviceExtension, Count);

      // got some data, let's see if we can satisfy any queued reads
      CheckForQueuedReads(DeviceExtension);

      DEBUG_TRACE1(("ReadCompletion (%08X)\n", DeviceExtension->CharsInReadBuff));

      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      DeviceExtension->ReadInProgress = FALSE;

      if(DeviceExtension->ReadInterlock == END_READ)
      {

		 DeviceExtension->ReadInterlock = IMMEDIATE_READ;
         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
		 RestartRead(DeviceExtension);
      }
      else
      {
		 DeviceExtension->ReadInterlock = IMMEDIATE_READ;
         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
      }

   }
   else 
   {
      //
      // the device is not accepting requests, so signal anyone who
      // cancelled this or is waiting for it to stop
      //
	  DeviceExtension->ReadInterlock = IMMEDIATE_READ;

      DeviceExtension->ReadInProgress = FALSE;

      DeviceExtension->AcceptingRequests = FALSE;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
      KeSetEvent(&DeviceExtension->ReadEvent, 1, FALSE);

      DEBUG_TRACE1(("RC Irp Status (%08X)\n", Irp->IoStatus.Status));
   }


   //
   // Notify everyone if this is the last IRP
   //

   if (InterlockedDecrement(&DeviceExtension->PendingDataInCount) == 0) 
   {
   
      UsbSerSerialDump(USBSERTRACEOTH, ("DataIn pipe is empty\n"));
      KeSetEvent(&DeviceExtension->PendingDataInEvent, IO_NO_INCREMENT, FALSE);
   }

   UsbSerSerialDump(USBSERTRACERD, ("DataInCount %08X @ %08X\n",
                                    DeviceExtension->PendingDataInCount,
                                    &DeviceExtension->PendingDataInCount));


   DEBUG_LOG_PATH("exit  ReadCompletion");
   UsbSerSerialDump(USBSERTRACERD, ("<ReadCompletion\n"));

   return STATUS_MORE_PROCESSING_REQUIRED;
} // ReadCompletion


/************************************************************************/
/* GetData                                                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Get data from circular buffer.                                  */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to device extension                   */
/*      Buffer          - pointer to buffer                             */
/*      BufferLen       - size of buffer                                */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      ULONG                                                           */
/*                                                                      */
/************************************************************************/
ULONG
GetData(IN PDEVICE_EXTENSION DeviceExtension, IN PCHAR Buffer,
        IN ULONG BufferLen, IN OUT PULONG_PTR NewCount)
{
   ULONG count;
   KIRQL OldIrql;

   DEBUG_LOG_PATH("enter GetData");

   UsbSerSerialDump(USBSERTRACERD, (">GetData\n"));

   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   BufferLen = min(DeviceExtension->CharsInReadBuff, BufferLen);

   if(BufferLen) 
   {

	  count = min(BufferLen, (DeviceExtension->RxMaxPacketSize - DeviceExtension->CurrentReadBuffPtr));

      memcpy(Buffer,
             &DeviceExtension->ReadBuff[DeviceExtension->CurrentReadBuffPtr],
             count);

	  Buffer 								+= count;
      DeviceExtension->CurrentReadBuffPtr 	+= count;
      DeviceExtension->CharsInReadBuff 		-= count;
      DeviceExtension->NumberNeededForRead 	-= count;
      BufferLen								-= count;
      *NewCount += count;

      // if there is still something left in the buffer, then we wrapped
      if(BufferLen)
      {
      		memcpy(Buffer, DeviceExtension->ReadBuff, BufferLen);
        	DeviceExtension->CurrentReadBuffPtr 	= BufferLen;
        	DeviceExtension->CharsInReadBuff 		-= BufferLen;
        	DeviceExtension->NumberNeededForRead 	-= BufferLen;
        	*NewCount 								+= BufferLen;
      }
		
   }

   DEBUG_TRACE2(("Count (%08X)  CharsInReadBuff (%08X)\n", count, DeviceExtension->CharsInReadBuff));

#if DBG
   if (UsbSerSerialDebugLevel & USBSERDUMPRD) {
      ULONG i;

      DbgPrint("RD: ");

      for (i = 0; i < count; i++) {
         DbgPrint("%02x ", Buffer[i] & 0xFF);
      }

      DbgPrint("\n\n");
   }
#endif

   RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

   RestartRead(DeviceExtension);

   DEBUG_LOG_PATH("exit  GetData");
   UsbSerSerialDump(USBSERTRACERD, ("<GetData\n"));

   return count;
} // GetData

/************************************************************************/
/* PutData                                                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Put data in circular buffer.                                    */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to device extension                   */
/*      BufferLen       - size of buffer                                */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
PutData(IN PDEVICE_EXTENSION DeviceExtension, IN ULONG BufferLen)
{
   KIRQL OldIrql;
   ULONG count;
   ULONG BuffPtr;

   if(BufferLen)
   {
       ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

	   // get current pointer into circular buffer
	   BuffPtr = (DeviceExtension->CharsInReadBuff +  DeviceExtension->CurrentReadBuffPtr) % 
	   			  DeviceExtension->RxMaxPacketSize;

	   // figure out amount to copy into read buffer, in case we would right past end of buffer
	   count = min(BufferLen, (DeviceExtension->RxMaxPacketSize - BuffPtr));

	   memcpy(&DeviceExtension->ReadBuff[BuffPtr], 
	          DeviceExtension->USBReadBuff, count);

	   // update counters 
	   BufferLen 							-= count;
	   DeviceExtension->CharsInReadBuff     += count;
	   DeviceExtension->ReadByIsr 			+= count;
   

	   // if there is still something left in the buffer, then we wrapped
	   if(BufferLen)
	   {
	        // count still holds the amount copied from buffer on first copy
	        // and BufferLen holds the amount remaining to copy
	   		memcpy(DeviceExtension->ReadBuff, 
	          	   &DeviceExtension->USBReadBuff[count], BufferLen);
          	   
	   		DeviceExtension->CharsInReadBuff	+= BufferLen;
	   		DeviceExtension->ReadByIsr 			+= BufferLen;
	   }

       RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
	}
} // PutData



VOID
UsbSerRundownIrpRefs(IN PIRP *PpCurrentOpIrp, IN PKTIMER IntervalTimer OPTIONAL,
                     IN PKTIMER TotalTimer OPTIONAL,
                     IN PDEVICE_EXTENSION PDevExt)

/*++

Routine Description:

    This routine runs through the various items that *could*
    have a reference to the current read/write.  It try's to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.

    NOTE: This routine assumes that it is called with the cancel
          spin lock held.

Arguments:

    PpCurrentOpIrp - Pointer to a pointer to current irp for the
                   particular operation.

    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.

    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.

    PDevExt - Pointer to device extension

Return Value:

    None.

--*/


{
//   PAGED_CODE();

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerRundownIrpRefs(%08X)\n",
                                     *PpCurrentOpIrp));

    //
    // This routine is called with the cancel spin lock held
    // so we know only one thread of execution can be in here
    // at one time.
    //

    //
    // First we see if there is still a cancel routine.  If
    // so then we can decrement the count by one.
    //

    if ((*PpCurrentOpIrp)->CancelRoutine) {

        USBSER_CLEAR_REFERENCE(*PpCurrentOpIrp, USBSER_REF_CANCEL);

        IoSetCancelRoutine(*PpCurrentOpIrp, NULL);

    }

    if (IntervalTimer) {

        //
        // Try to cancel the operations interval timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an interval timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if (KeCancelTimer(IntervalTimer)) {
            USBSER_CLEAR_REFERENCE(*PpCurrentOpIrp, USBSER_REF_INT_TIMER);
        }
    }

    if (TotalTimer) {

        //
        // Try to cancel the operations total timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an total timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //        //
        // If we have an escape char event pending, we can't overstuff,
        // so subtract one from the length
        //


        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if (KeCancelTimer(TotalTimer)) {
            USBSER_CLEAR_REFERENCE(*PpCurrentOpIrp, USBSER_REF_TOTAL_TIMER);
        }
    }

//    USBSER_CLEAR_REFERENCE(*PpCurrentOpIrp, USBSER_REF_RXBUFFER);

    UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerRundownIrpRefs\n"));
}


VOID
UsbSerTryToCompleteCurrent(IN PDEVICE_EXTENSION PDevExt,
                           IN KIRQL IrqlForRelease, IN NTSTATUS StatusToUse,
                           IN PIRP *PpCurrentOpIrp,
                           IN PLIST_ENTRY PQueue OPTIONAL,
                           IN PKTIMER PIntervalTimer OPTIONAL,
                           IN PKTIMER PTotalTimer OPTIONAL,
                           IN PUSBSER_START_ROUTINE Starter OPTIONAL,
                           IN PUSBSER_GET_NEXT_ROUTINE PGetNextIrp OPTIONAL,
                           IN LONG RefType,
                           IN BOOLEAN Complete)

/*++

Routine Description:

    This routine attempts to kill all of the reasons there are
    references on the current read/write.  If everything can be killed
    it will complete this read/write and try to start another.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Extension - Simply a pointer to the device extension.

    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.

    IrqlForRelease - This routine is called with the cancel spinlock held.
                     This is the irql that was current when the cancel
                     spinlock was acquired.

    StatusToUse - The irp's status field will be set to this value, if
                  this routine can complete the irp.


Return Value:

    None.

--*/

{
   USBSER_ALWAYS_LOCKED_CODE();

   UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD | USBSERTRACEWR,
                    (">UsbSerTryToCompleteCurrent(%08X)\n", *PpCurrentOpIrp));
    //
    // We can decrement the reference to "remove" the fact
    // that the caller no longer will be accessing this irp.
    //

    USBSER_CLEAR_REFERENCE(*PpCurrentOpIrp, RefType);

    //
    // Try to run down all other references to this irp.
    //

    UsbSerRundownIrpRefs(PpCurrentOpIrp, PIntervalTimer, PTotalTimer, PDevExt);

    //
    // See if the ref count is zero after trying to kill everybody else.
    //

    if (!USBSER_REFERENCE_COUNT(*PpCurrentOpIrp)) {

        PIRP pNewIrp;


        //
        // The ref count was zero so we should complete this
        // request.
        //
        // The following call will also cause the current irp to be
        // completed.
        //

        (*PpCurrentOpIrp)->IoStatus.Status = StatusToUse;

        if (StatusToUse == STATUS_CANCELLED) {

            (*PpCurrentOpIrp)->IoStatus.Information = 0;

        }

        if (PGetNextIrp) {

            RELEASE_CANCEL_SPINLOCK(PDevExt, IrqlForRelease);

            (*PGetNextIrp)(PpCurrentOpIrp, PQueue, &pNewIrp, Complete, PDevExt);


            if (pNewIrp) {

                Starter(PDevExt);
            }

        } else {

            PIRP pOldIrp = *PpCurrentOpIrp;

            //
            // There was no get next routine.  We will simply complete
            // the irp.  We should make sure that we null out the
            // pointer to the pointer to this irp.
            //

            *PpCurrentOpIrp = NULL;

            RELEASE_CANCEL_SPINLOCK(PDevExt, IrqlForRelease);

            if (Complete) {
               IoCompleteRequest(pOldIrp, IO_SERIAL_INCREMENT);
            }

        }

    } else {

        RELEASE_CANCEL_SPINLOCK(PDevExt, IrqlForRelease);

        UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD | USBSERTRACEWR,
            ("Current IRP still has reference of %08X\n",
            ((UINT_PTR)((IoGetCurrentIrpStackLocation((*PpCurrentOpIrp))->
                         Parameters.Others.Argument4)))));
    }

    UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD | USBSERTRACEWR,
                     ("<UsbSerTryToCompleteCurrent\n"));
}


/************************************************************************/
/* CheckForQueuedReads                                                  */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      See if we have any queued reads that we can satisfy.            */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
CheckForQueuedReads(IN PDEVICE_EXTENSION DeviceExtension)
{
   ULONG charsRead = 0;
   PULONG pWaitMask;
   KIRQL  oldIrql;

   //
   // May be paged if we do counter
   //

   DEBUG_LOG_PATH("enter CheckForQueuedReads");
   UsbSerSerialDump(USBSERTRACERD, (">CheckForQueuedReads\n"));

   ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &oldIrql);

   if ((DeviceExtension->CurrentReadIrp != NULL)
       && (USBSER_REFERENCE_COUNT(DeviceExtension->CurrentReadIrp)
           & USBSER_REF_RXBUFFER))
   {
           
      RELEASE_CANCEL_SPINLOCK(DeviceExtension, oldIrql);

      DEBUG_TRACE3(("Reading 0x%x\n", DeviceExtension->NumberNeededForRead));

      charsRead
         = GetData(DeviceExtension,
                              ((PUCHAR)(DeviceExtension->CurrentReadIrp
                                        ->AssociatedIrp.SystemBuffer))
                              + (IoGetCurrentIrpStackLocation(DeviceExtension
                                                              ->CurrentReadIrp))
                              ->Parameters.Read.Length
                              - DeviceExtension->NumberNeededForRead,
                              DeviceExtension->NumberNeededForRead,
                   &DeviceExtension->CurrentReadIrp->IoStatus.Information);

      ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &oldIrql);

      //
      // See if this read is complete
      //

      if (DeviceExtension->NumberNeededForRead == 0) {
         DEBUG_TRACE3(("USBSER: Completing read\n"));

         if(DeviceExtension->CurrentReadIrp)
         {
            DeviceExtension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;
         }

         //
         // Mark the read as completed and try to service the next one
         //


         DeviceExtension->CountOnLastRead = SERIAL_COMPLETE_READ_COMPLETE;

#if DBG
   if (UsbSerSerialDebugLevel & USBSERDUMPRD) {
      ULONG i;
      ULONG count;

      if (DeviceExtension->CurrentReadIrp->IoStatus.Status == STATUS_SUCCESS) {
         count = (ULONG)DeviceExtension->CurrentReadIrp->IoStatus.Information;
      } else {
         count = 0;

      }
      DbgPrint("RD2: A(%08X) G(%08X) I(%08X)\n",
               IoGetCurrentIrpStackLocation(DeviceExtension->CurrentReadIrp)
               ->Parameters.Read.Length, count, DeviceExtension->CurrentReadIrp);

      for (i = 0; i < count; i++) {
         DbgPrint("%02x ", *(((PUCHAR)DeviceExtension->CurrentReadIrp
                              ->AssociatedIrp.SystemBuffer) + i) & 0xFF);
      }

      if (i == 0) {
         DbgPrint("NULL (%08X)\n", DeviceExtension->CurrentReadIrp
                  ->IoStatus.Status);
      }

      DbgPrint("\n\n");
   }
#endif

      
         UsbSerTryToCompleteCurrent(DeviceExtension, oldIrql, STATUS_SUCCESS,
                                    &DeviceExtension->CurrentReadIrp,
                                    &DeviceExtension->ReadQueue,
                                    &DeviceExtension->ReadRequestIntervalTimer,
                                    &DeviceExtension->ReadRequestTotalTimer,
                                    UsbSerStartRead, UsbSerGetNextIrp,
                                    USBSER_REF_RXBUFFER,
                                    TRUE);
                                    
         ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &oldIrql);
      }
   } 

   if (DeviceExtension->IsrWaitMask & SERIAL_EV_RXCHAR) {
      DeviceExtension->HistoryMask |= SERIAL_EV_RXCHAR;
   }

   if (DeviceExtension->CurrentMaskIrp != NULL) {
      pWaitMask = (PULONG)DeviceExtension->CurrentMaskIrp->
         AssociatedIrp.SystemBuffer;

      //
      // Process events
      //

      if (DeviceExtension->IsrWaitMask & DeviceExtension->HistoryMask) {
         PIRP pMaskIrp;

         DEBUG_TRACE3(("Completing events\n"));

         *pWaitMask = DeviceExtension->HistoryMask;
         DeviceExtension->HistoryMask = 0;
         pMaskIrp = DeviceExtension->CurrentMaskIrp;

         pMaskIrp->IoStatus.Information = sizeof(ULONG);
         pMaskIrp->IoStatus.Status = STATUS_SUCCESS;
         DeviceExtension->CurrentMaskIrp = NULL;
         IoSetCancelRoutine(pMaskIrp, NULL);

         RELEASE_CANCEL_SPINLOCK(DeviceExtension, oldIrql);


         IoCompleteRequest(pMaskIrp, IO_SERIAL_INCREMENT);

      }
      else
      {
         RELEASE_CANCEL_SPINLOCK(DeviceExtension, oldIrql);
      }
   }
   else
   {
      RELEASE_CANCEL_SPINLOCK(DeviceExtension, oldIrql);
   }
   

   DEBUG_LOG_PATH("exit  CheckForQueuedReads");

   UsbSerSerialDump(USBSERTRACERD, ("<CheckForQueuedReads\n"));
} // CheckForQueuedReads


VOID
UsbSerGetNextIrp(IN PIRP *PpCurrentOpIrp, IN PLIST_ENTRY PQueueToProcess,
                 OUT PIRP *PpNextIrp, IN BOOLEAN CompleteCurrent,
                 IN PDEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This function gets the next IRP off a queue, marks it as current,
    and possibly completes the current IRP.

Arguments:

    PpCurrentOpIrp    - A pointer to the pointer to the current IRP.
    PQueueToProcess  - A pointer to the queue to get the next IRP from.
    PpNextIrp         - A pointer to the pointer to the next IRP to process.
    CompleteCurrent  - TRUE if we should complete the IRP that is current at
                       the time we are called.
    PDevExt          - A pointer to the device extension.

Return Value:

    NTSTATUS

--*/
{
   KIRQL oldIrql;
   PIRP pOldIrp;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("Enter UsbSerGetNextIrp");
   UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD | USBSERTRACEWR,
                    (">UsbSerGetNextIrp(%08)\n", *PpCurrentOpIrp));

   ACQUIRE_CANCEL_SPINLOCK(PDevExt, &oldIrql);

   pOldIrp = *PpCurrentOpIrp;

#if DBG
   if (pOldIrp != NULL) {
      if (CompleteCurrent) {
         ASSERT(pOldIrp->CancelRoutine == NULL);
      }
   }
#endif

   //
   // Check to see if there is a new irp to start up
   //

   if (!IsListEmpty(PQueueToProcess)) {
      PLIST_ENTRY pHeadOfList;

      pHeadOfList = RemoveHeadList(PQueueToProcess);

      *PpCurrentOpIrp = CONTAINING_RECORD(pHeadOfList, IRP,
                                         Tail.Overlay.ListEntry);

      IoSetCancelRoutine(*PpCurrentOpIrp, NULL);
   } else {
      *PpCurrentOpIrp = NULL;
   }

   *PpNextIrp = *PpCurrentOpIrp;

   RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

   //
   // Complete the current one if so requested
   //

   if (CompleteCurrent) {
      if (pOldIrp != NULL) {
         IoCompleteRequest(pOldIrp, IO_SERIAL_INCREMENT);
      }
   }

   DEBUG_LOG_PATH("Exit UsbSerGetNextIrp");
   UsbSerSerialDump(USBSERTRACEOTH | USBSERTRACERD | USBSERTRACEWR,
                    ("<UsbSerGetNextIrp\n"));
}


NTSTATUS
UsbSerStartOrQueue(IN PDEVICE_EXTENSION PDevExt, IN PIRP PIrp,
                   IN PLIST_ENTRY PQueue, IN PIRP *PPCurrentIrp,
                   IN PUSBSER_START_ROUTINE Starter)
/*++

Routine Description:

    This function is used to either start processing an I/O request or to
    queue it on the appropriate queue if a request is already pending or
    requests may not be started.

Arguments:

    PDevExt       - A pointer to the DeviceExtension.
    PIrp          - A pointer to the IRP that is being started or queued.
    PQueue        - A pointer to the queue to place the IRP on if necessary.
    PPCurrentIrp  - A pointer to the pointer to the currently active I/O IRP.
    Starter       - Function to call if we decide to start this IRP.


Return Value:

    NTSTATUS

--*/
{
   KIRQL oldIrql;
   NTSTATUS status;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("Enter UsbSerStartOrQueue");

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerStartOrQueue(%08X)\n", PIrp));

   ACQUIRE_CANCEL_SPINLOCK(PDevExt, &oldIrql);

   if (IsListEmpty(PQueue) && (*PPCurrentIrp == NULL)) {
      //
      // Nothing pending -- start the new irp
      //

      *PPCurrentIrp = PIrp;
      RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

      status = Starter(PDevExt);

      DEBUG_LOG_PATH("Exit UsbSerStartOrQueue(1)");
      UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerStartOrQueue(1) %08X\n",
                                        status));
      return status;
   }

   //
   // We're queueing the irp, so we need a cancel routine -- make sure
   // the irp hasn't already been cancelled.
   //

   if (PIrp->Cancel) {
      //
      // The IRP was apparently cancelled.  Complete it.
      //

      RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

      PIrp->IoStatus.Status = STATUS_CANCELLED;

      IoCompleteRequest(PIrp, IO_NO_INCREMENT);

      DEBUG_LOG_PATH("Exit UsbSerStartOrQueue(2)");
      UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerStartOrQueue(2) %08X\n",
                                        STATUS_CANCELLED));
      return STATUS_CANCELLED;
   }

   //
   // Mark as pending, attach our cancel routine
   //

   PIrp->IoStatus.Status = STATUS_PENDING;
   IoMarkIrpPending(PIrp);

   InsertTailList(PQueue, &PIrp->Tail.Overlay.ListEntry);
   IoSetCancelRoutine(PIrp, UsbSerCancelQueued);

   RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

   DEBUG_LOG_PATH("Exit UsbSerStartOrQueue(3)");
   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerStartOrQueue(3) %08X\n",
                                     STATUS_PENDING));
   return STATUS_PENDING;
}


VOID
UsbSerCancelQueued(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)
/*++

Routine Description:

    This function is used as a cancel routine for queued irps.  Basically
    for us this means read IRPs.

Arguments:

    PDevObj - A pointer to the serial device object.

    PIrp    - A pointer to the IRP that is being cancelled

Return Value:

    VOID

--*/
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("Enter UsbSerCancelQueued");

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerCancelQueued(%08X)\n", PIrp));

   //
   // The irp was cancelled -- remove it from the queue
   //

   PIrp->IoStatus.Status = STATUS_CANCELLED;
   PIrp->IoStatus.Information = 0;

   RemoveEntryList(&PIrp->Tail.Overlay.ListEntry);

   RELEASE_CANCEL_SPINLOCK(pDevExt, PIrp->CancelIrql);

   IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

   DEBUG_LOG_PATH("Exit UsbSerCancelQueued");
   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerCancelQueued\n"));
}


VOID
UsbSerKillAllReadsOrWrites(IN PDEVICE_OBJECT PDevObj,
                           IN PLIST_ENTRY PQueueToClean,
                           IN PIRP *PpCurrentOpIrp)

/*++

Routine Description:

    This function is used to cancel all queued and the current irps
    for reads or for writes.

Arguments:

    PDevObj - A pointer to the serial device object.

    PQueueToClean - A pointer to the queue which we're going to clean out.

    PpCurrentOpIrp - Pointer to a pointer to the current irp.

Return Value:

    None.

--*/

{

    KIRQL cancelIrql;
    PDRIVER_CANCEL cancelRoutine;
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

    USBSER_ALWAYS_LOCKED_CODE();

    UsbSerSerialDump(USBSERTRACERD | USBSERTRACEWR,
                     (">UsbSerKillAllReadsOrWrites(%08X)\n", *PpCurrentOpIrp));
    //
    // We acquire the cancel spin lock.  This will prevent the
    // irps from moving around.
    //

    ACQUIRE_CANCEL_SPINLOCK(pDevExt, &cancelIrql);

    //
    // Clean the list from back to front.
    //

    while (!IsListEmpty(PQueueToClean)) {

        PIRP pCurrentLastIrp = CONTAINING_RECORD(PQueueToClean->Blink, IRP,
                                                 Tail.Overlay.ListEntry);

        RemoveEntryList(PQueueToClean->Blink);

        cancelRoutine = pCurrentLastIrp->CancelRoutine;
        pCurrentLastIrp->CancelIrql = cancelIrql;
        pCurrentLastIrp->CancelRoutine = NULL;
        pCurrentLastIrp->Cancel = TRUE;

        cancelRoutine(PDevObj, pCurrentLastIrp);

        ACQUIRE_CANCEL_SPINLOCK(pDevExt, &cancelIrql);

    }

    //
    // The queue is clean.  Now go after the current if
    // it's there.
    //

    if (*PpCurrentOpIrp) {


        cancelRoutine = (*PpCurrentOpIrp)->CancelRoutine;
        (*PpCurrentOpIrp)->Cancel = TRUE;

        //
        // If the current irp is not in a cancelable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancelable state then the following will kill it.
        //

        if (cancelRoutine) {

            (*PpCurrentOpIrp)->CancelRoutine = NULL;
            (*PpCurrentOpIrp)->CancelIrql = cancelIrql;

            //
            // This irp is already in a cancelable state.  We simply
            // mark it as canceled and call the cancel routine for
            // it.
            //

            cancelRoutine(PDevObj, *PpCurrentOpIrp);

        } else {

            RELEASE_CANCEL_SPINLOCK(pDevExt, cancelIrql);

        }

    } else {

        RELEASE_CANCEL_SPINLOCK(pDevExt, cancelIrql);

    }

    UsbSerSerialDump(USBSERTRACERD | USBSERTRACEWR,
                     ("<UsbSerKillAllReadsOrWrites\n"));
}


VOID
UsbSerKillPendingIrps(PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

   Kill all IRPs queued in our driver

Arguments:

   PDevObj - a pointer to the device object

Return Value:

    VOID

--*/
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   KIRQL cancelIrql;

   USBSER_ALWAYS_LOCKED_CODE();

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerKillPendingIrps\n"));

   //
   // Kill all reads; we do not queue writes
   //

   UsbSerKillAllReadsOrWrites(PDevObj, &pDevExt->ReadQueue,
                              &pDevExt->CurrentReadIrp);

   //
   // Get rid of any pending waitmasks
   //

   ACQUIRE_CANCEL_SPINLOCK(pDevExt, &cancelIrql);

   if (pDevExt->CurrentMaskIrp != NULL) {
      PDRIVER_CANCEL cancelRoutine;

      cancelRoutine = pDevExt->CurrentMaskIrp->CancelRoutine;
      pDevExt->CurrentMaskIrp->Cancel = TRUE;

      ASSERT(cancelRoutine);

      if (cancelRoutine) {
         pDevExt->CurrentMaskIrp->CancelRoutine = NULL;
         pDevExt->CurrentMaskIrp->CancelIrql = cancelIrql;

         cancelRoutine(PDevObj, pDevExt->CurrentMaskIrp);
      } else {
         RELEASE_CANCEL_SPINLOCK(pDevExt, cancelIrql);
      }

   }else {
         RELEASE_CANCEL_SPINLOCK(pDevExt, cancelIrql);
   }

   //
   // Cancel any pending wait-wake irps
   //

   if (pDevExt->PendingWakeIrp != NULL) {
      IoCancelIrp(pDevExt->PendingWakeIrp);
      pDevExt->PendingWakeIrp = NULL;
   }


   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerKillPendingIrps\n"));
}


/************************************************************************/
/* CompletePendingWaitMasks                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Completes any wait masks in progress with no events set.        */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to a device extension                 */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
UsbSerCompletePendingWaitMasks(IN PDEVICE_EXTENSION DeviceExtension)
{
   KIRQL OldIrql;
   PIRP CurrentMaskIrp;
   KIRQL cancelIrql;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter CompletePendingWaitMasks");

   UsbSerSerialDump(USBSERTRACEOTH, (">CompletePendingWaitMasks\n"));

   ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &cancelIrql);
   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   CurrentMaskIrp = DeviceExtension->CurrentMaskIrp;

   if (CurrentMaskIrp) {

      CurrentMaskIrp->IoStatus.Status         = STATUS_SUCCESS;
      CurrentMaskIrp->IoStatus.Information    = sizeof(ULONG);
      *((PULONG)CurrentMaskIrp->AssociatedIrp.SystemBuffer) = 0;

      DeviceExtension->CurrentMaskIrp         = NULL;

      IoSetCancelRoutine(CurrentMaskIrp, NULL);

   }

   // complete the queued IRP if needed
   if (CurrentMaskIrp) {
      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
      RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);

      IoCompleteRequest(CurrentMaskIrp, IO_NO_INCREMENT);
      DEBUG_TRACE1(("CompletePendingWaitMask\n"));
   }
   else
   {
      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
      RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);
   }

   DEBUG_LOG_PATH("exit  CompletePendingWaitMasks");
   UsbSerSerialDump(USBSERTRACEOTH, ("<CompletePendingWaitMasks\n"));
} // CancelPendingWaitMasks


VOID
UsbSerRestoreModemSettings(PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

   Restores the modem's settings upon a powerup.

Arguments:

   PDevExt - a pointer to the device extension

Return Value:

    VOID

--*/
{
   PAGED_CODE();

   (void)SetLineControlAndBaud(PDevObj);
}


VOID
UsbSerProcessEmptyTransmit(IN PDEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This function is called whenever our tx queue is empty in order
    to set the proper events, etc.

Arguments:

    PDevExt - Pointer to DeviceExtension for the device

Return Value:

    VOID

--*/
{
   KIRQL oldIrql;
   PULONG pWaitMask;

   USBSER_ALWAYS_LOCKED_CODE();

   //
   // Set the event if needed
   //

   PDevExt->HistoryMask |= SERIAL_EV_TXEMPTY;

   if (PDevExt->IsrWaitMask & SERIAL_EV_TXEMPTY) {
      PIRP pMaskIrp;

      DEBUG_TRACE3(("Completing events\n"));

      ACQUIRE_CANCEL_SPINLOCK(PDevExt, &oldIrql);

      if (PDevExt->CurrentMaskIrp != NULL) {
         pWaitMask = (PULONG)PDevExt->CurrentMaskIrp->
                     AssociatedIrp.SystemBuffer;

         *pWaitMask = PDevExt->HistoryMask;
         PDevExt->HistoryMask = 0;
         pMaskIrp = PDevExt->CurrentMaskIrp;

         pMaskIrp->IoStatus.Information = sizeof(ULONG);
         pMaskIrp->IoStatus.Status = STATUS_SUCCESS;
         PDevExt->CurrentMaskIrp = NULL;

         IoSetCancelRoutine(pMaskIrp, NULL);

         RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);

         IoCompleteRequest(pMaskIrp, IO_SERIAL_INCREMENT);
      } else {
         RELEASE_CANCEL_SPINLOCK(PDevExt, oldIrql);
      }

   }
}


VOID
UsbSerCancelWaitOnMask(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)
/*++

Routine Description:

    This function is used as a cancel routine for WaitOnMask IRPs.

Arguments:

    PDevObj - Pointer to Device Object
    PIrp    - Pointer to IRP that is being canceled; must be the same as
              the current mask IRP.

Return Value:

    VOID

--*/
{
   PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;

   USBSER_ALWAYS_LOCKED_CODE();

   UsbSerSerialDump(USBSERTRACEOTH, (">UsbSerCancelWaitOnMask(%08X)\n", PIrp));

   ASSERT(pDevExt->CurrentMaskIrp == PIrp);

   PIrp->IoStatus.Status = STATUS_CANCELLED;
   PIrp->IoStatus.Information = 0;

   pDevExt->CurrentMaskIrp = NULL;
   RELEASE_CANCEL_SPINLOCK(pDevExt, PIrp->CancelIrql);
   IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

   UsbSerSerialDump(USBSERTRACEOTH, ("<UsbSerCancelWaitOnMask(%08X)"));
}


NTSTATUS
UsbSerSyncCompletion(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN PKEVENT PUsbSerSyncEvent)
/*++

Routine Description:

    This function is used to signal an event.  It is used as a completion
    routine.

Arguments:

    PDevObj - Pointer to Device Object
    PIrp - Pointer to IRP that is being completed
    PUsbSerSyncEvent - Pointer to event that we should set

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
   KeSetEvent(PUsbSerSyncEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}


#if DBG
PVOID
UsbSerLockPagableCodeSection(PVOID SecFunc)
/*++

Routine Description:

    This function is used to lockdown code pages and increment a lock counter
    for debugging.

Arguments:

    SecFunc - Function in code section to be locked down.

Return Value:

    PVOID - Handle for locked down section.

--*/
{  PVOID handle;

   PAGED_CODE();

   handle = MmLockPagableCodeSection(SecFunc);

   // can this be paged?
   InterlockedIncrement(&PAGEUSBSER_Count);

   return handle;
}
#endif




VOID
UsbSerFetchBooleanLocked(PBOOLEAN PDest, BOOLEAN Src, PKSPIN_LOCK PSpinLock)
/*++

Routine Description:

    This function is used to assign a BOOLEAN value with spinlock protection.

Arguments:

    PDest - A pointer to Lval.

    Src - Rval.

    PSpinLock - Pointer to the spin lock we should hold.

Return Value:

    None.

--*/
{
  KIRQL tmpIrql;

  KeAcquireSpinLock(PSpinLock, &tmpIrql);
  *PDest = Src;
  KeReleaseSpinLock(PSpinLock, tmpIrql);
}


VOID
UsbSerFetchPVoidLocked(PVOID *PDest, PVOID Src, PKSPIN_LOCK PSpinLock)
/*++

Routine Description:

    This function is used to assign a PVOID value with spinlock protection.

Arguments:

    PDest - A pointer to Lval.

    Src - Rval.

    PSpinLock - Pointer to the spin lock we should hold.

Return Value:

    None.

--*/
{
  KIRQL tmpIrql;

  KeAcquireSpinLock(PSpinLock, &tmpIrql);
  *PDest = Src;
  KeReleaseSpinLock(PSpinLock, tmpIrql);
}

/*++

Routine Description:

    Work item to kick off another notify read

Arguments:

    DeviceObject - pointer to the device object

    DeviceExtension - context for this call

Return Value:

    None.

--*/

VOID
USBSER_RestartNotifyReadWorkItem(IN PDEVICE_OBJECT DeviceObject, IN PDEVICE_EXTENSION DeviceExtension)
{
    KIRQL 			oldIrql;
    PIO_WORKITEM 	ioWorkItem;

    ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &oldIrql);

	ioWorkItem = DeviceExtension->IoWorkItem;

	DeviceExtension->IoWorkItem = NULL;

    RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, oldIrql);

    IoFreeWorkItem(ioWorkItem);

	RestartNotifyRead(DeviceExtension);
} // USBER_RestartNotifyReadWorkItem



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\valueadd\local.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    VALIDATE.H

Abstract:

    This module contains the PRIVATE (driver-only) definitions for the
    code that implements the validate lower level filter driver.

Environment:

    Kernel mode

Revision History:

    Feb-97 : created by Kenneth Ray

--*/


#ifndef _VALUEADD_LOCAL_H
#define _VALUEADD_LOCAL_H

#include "usb100.h"
#include "usbdi.h"
#include "usbdlib.h"

#define HIDV_POOL_TAG (ULONG) 'ulaV'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, HIDV_POOL_TAG);
// ExAllocatePool is only called in the descript.c and hidparse.c code.
// all other modules are linked into the user DLL.  They cannot allocate any
// memory.


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect

#if DBG
#define VA_KdPrint(_x_) \
               DbgPrint ("USB_VA: "); \
               DbgPrint _x_;

#define TRAP() DbgBreakPoint()

#else
#define VA_KdPrint(_x_)
#define TRAP()

#endif

#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#define MAX(a,b) (((a) < (b)) ? (b) : (a))

//
// A device extension for the controling device object
//
typedef struct _VA_CONTROL_DATA
{
    LIST_ENTRY          UsbDevices; // A list of the Device device extensions
    ULONG               NumUsbDevices;
    KSPIN_LOCK          Spin; // a sync spin lock for this data.
} VA_CONTROL_DATA, *PVA_CONTROL_DATA;


//
// A device extension for the device object placed into the attachment
// chain.
//

typedef struct _VA_USB_DATA
{
    BOOLEAN             Started; // This device has been started
    BOOLEAN             Removed; // This device has been removed
    UCHAR               Reseved2[2];

    PDEVICE_OBJECT      Self; // a back pointer to the actual DeviceObject
    PDEVICE_OBJECT      PDO; // The PDO to which this filter is attached.
    PDEVICE_OBJECT      TopOfStack; // The top of the device stack just
                                    // beneath this filter device object.
    ULONG               PrintMask;

    LIST_ENTRY          List; // A link point for a list of hid device extensions

    KEVENT              StartEvent; // an event to sync the start IRP.
    KEVENT              RemoveEvent; // an event to synch outstandIO to zero
    ULONG               OutstandingIO; // 1 biased count of reasons why
                                       // this object should stick around

    USB_DEVICE_DESCRIPTOR   DeviceDesc;
    WCHAR                   FriendlyName;

}  VA_USB_DATA, *PVA_USB_DATA;

struct _VA_GLOBALS {
    PDEVICE_OBJECT          ControlObject;
};

extern struct _VA_GLOBALS Global;


//
// Print Masks
//

#define VA_PRINT_COMMAND        0x00000001
#define VA_PRINT_CONTROL        0x00000002
#define VA_PRINT_TRANSFER       0x00000004
#define VA_PRINT_DESCRIPTOR     0x00000008
#define VA_PRINT_FEATURE        0x00000010
#define VA_PRINT_FUNCTION       0x00000020

#define VA_PRINT_BEFORE         0x10000000
#define VA_PRINT_AFTER          0x20000000
#define VA_PRINT_ALL            0x000000FF


NTSTATUS
VA_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_Pass (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_Ioctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_Read (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_Write (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
VA_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );


VOID
VA_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
VA_StartDevice (
    IN PVA_USB_DATA     UsbData,
    IN PIRP             Irp
    );


VOID
VA_StopDevice (
    IN PVA_USB_DATA HidDevice,
    IN BOOLEAN      TouchTheHardware
    );


NTSTATUS
VA_CallUSBD(
    IN PVA_USB_DATA     UsbData,
    IN PURB             Urb,
    IN PIRP             Pirp
    );

NTSTATUS
VA_FilterURB (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\valueadd\usb.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    usb.c

Abstract: USB lower filter driver

Author:

    Kenneth D. Ray

Environment:

    Kernel mode

Revision History:


--*/

#include <wdm.h>
#include "valueadd.h"
#include "local.h"
#include "usbdi.h"
#include "usbdlib.h"

VOID
VA_PrintURB (
    IN PURB     Urb,
    IN ULONG    PrintMask
    );

NTSTATUS
VA_FilterURB_Comp (
    IN PDEVICE_OBJECT   Device,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
VA_FilterURB (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The default dispatch routine.  If this filter does not recognize the
    IRP, then it should send it down, unmodified.
    No completion routine is required.

    As we have NO idea which function we are happily passing on, we can make
    NO assumptions about whether or not it will be called at raised IRQL.
    For this reason, this function must be in put into non-paged pool
    (aka the default location).

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PVA_USB_DATA        usbData;
    NTSTATUS            status;
    PIO_STACK_LOCATION  stack;
    PURB                urb;

    stack = IoGetCurrentIrpStackLocation (Irp);
    usbData = (PVA_USB_DATA) DeviceObject->DeviceExtension;

    ASSERT (IRP_MJ_INTERNAL_DEVICE_CONTROL == stack->MajorFunction);

    if(DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }

    //
    // This IRP was sent to the filter driver.
    // Since we do not know what to do with the IRP, we should pass
    // it on along down the stack.
    //

    InterlockedIncrement (&usbData->OutstandingIO);
    if (usbData->Removed) {
        status = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else {

        switch (stack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_INTERNAL_USB_SUBMIT_URB:

            urb = stack->Parameters.Others.Argument1;

            if (VA_PRINT_BEFORE & usbData->PrintMask) {
                VA_PrintURB (urb, usbData->PrintMask);
            }

            if (VA_PRINT_AFTER & usbData->PrintMask) {

                //
                // Copy the stack arguments
                //

                IoCopyCurrentIrpStackLocationToNext (Irp);

                //
                // Hook the IRP so that we might print after
                //
                IoSetCompletionRoutine (Irp,
                                        VA_FilterURB_Comp,
                                        usbData,
                                        TRUE,
                                        TRUE,
                                        TRUE);


            } else {
                //
                // Send the IRP on unchanged.
                //
                IoSkipCurrentIrpStackLocation (Irp);
            }

            status = IoCallDriver (usbData->TopOfStack, Irp);
            break;

        default:
            //
            // Send the IRP on unchanged.
            //
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (usbData->TopOfStack, Irp);
            break;
        }

    }

    if (0 == InterlockedDecrement (&usbData->OutstandingIO)) {
        KeSetEvent (&usbData->RemoveEvent, 0, FALSE);
    }
    return status;
}

NTSTATUS
VA_FilterURB_Comp (
    IN PDEVICE_OBJECT   Device,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PVA_USB_DATA        usbData;
    PURB                urb;

    UNREFERENCED_PARAMETER (Device);
    urb = IoGetCurrentIrpStackLocation(Irp)->Parameters.Others.Argument1;

    usbData = (PVA_USB_DATA) Context;

    VA_PrintURB (urb, usbData->PrintMask);

    return STATUS_SUCCESS;
}

VOID
VA_PrintURB (
    IN PURB     Urb,
    IN ULONG    PrintMask
    )
/*++

Routine Description:
    Print to the debugger the given Urb

--*/
{
    BOOLEAN     again   = TRUE;
    ULONG       i;

#define HEADER(URB) \
        VA_KdPrint (("URB: Len (%x) Status (%x) Dev Handle (%x) Flags (%x)\n",\
                    URB->UrbHeader.Length, \
                    URB->UrbHeader.Status, \
                    URB->UrbHeader.UsbdDeviceHandle, \
                    URB->UrbHeader.UsbdFlags))

    while (Urb && again) {
        again = FALSE;

        switch (Urb->UrbHeader.Function) {
        case URB_FUNCTION_SELECT_INTERFACE:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Select Interface: ConfigHandle (%x) Interface (%x)\n",
                             Urb->UrbSelectInterface.ConfigurationHandle,
                             Urb->UrbSelectInterface.Interface));
            }
            break;

        case URB_FUNCTION_SELECT_CONFIGURATION:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Select Config: Config Desc (%x) Hand (%x) Int (%x)\n",
                             Urb->UrbSelectConfiguration.ConfigurationDescriptor,
                             Urb->UrbSelectConfiguration.ConfigurationHandle,
                             Urb->UrbSelectConfiguration.Interface));
            }
            break;

        case URB_FUNCTION_ABORT_PIPE:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Abort Pipe: (%x)\n",
                             Urb->UrbPipeRequest.PipeHandle));
            }
            break;

        case URB_FUNCTION_RESET_PIPE:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Reset Pipe: (%x)\n",
                             Urb->UrbPipeRequest.PipeHandle));
            }
            break;

        case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Frame Length Control \n"));
            }
            break;

        case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Release Frame Length Control \n"));
            }
            break;

        case URB_FUNCTION_GET_FRAME_LENGTH:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Frame Length (%x) Num (%x) \n",
                             Urb->UrbGetFrameLength.FrameLength,
                             Urb->UrbGetFrameLength.FrameNumber));
            }
            break;

        case URB_FUNCTION_SET_FRAME_LENGTH:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Set Frame Length Delta (0x%x) \n",
                             Urb->UrbSetFrameLength.FrameLengthDelta));
            }
            break;

        case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Current Frame Number (%x) \n",
                             Urb->UrbGetCurrentFrameNumber.FrameNumber));
            }
            break;

        case URB_FUNCTION_CONTROL_TRANSFER:
            if (PrintMask & VA_PRINT_CONTROL) {
                HEADER(Urb);
                VA_KdPrint (("Control Xfer: Pipe (%x) Flags (%x) "
                             "Len (%x) Buffer (%x) MDL (%x) HCA (%x) "
                             "SetupPacket: %02.02x %02.02x %02.02x %02.02x "
                             "%02.02x %02.02x %02.02x %02.02x\n",
                             Urb->UrbControlTransfer.PipeHandle,
                             Urb->UrbControlTransfer.TransferFlags,
                             Urb->UrbControlTransfer.TransferBufferLength,
                             Urb->UrbControlTransfer.TransferBuffer,
                             Urb->UrbControlTransfer.TransferBufferMDL,
                             &Urb->UrbControlTransfer.hca,
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[0],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[1],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[2],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[3],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[4],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[5],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[6],
                             (ULONG) Urb->UrbControlTransfer.SetupPacket[7]));
            }
            Urb = Urb->UrbControlTransfer.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
            if (PrintMask & VA_PRINT_TRANSFER) {
                HEADER(Urb);
                VA_KdPrint (("Bulk | Interrupt Xfer: Pipe (%x) Flags (%x) "
                             "Len (%x) Buffer (%x) MDL (%x) HCA (%x)\n",
                             Urb->UrbBulkOrInterruptTransfer.PipeHandle,
                             Urb->UrbBulkOrInterruptTransfer.TransferFlags,
                             Urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
                             Urb->UrbBulkOrInterruptTransfer.TransferBuffer,
                             Urb->UrbBulkOrInterruptTransfer.TransferBufferMDL,
                             &Urb->UrbControlTransfer.hca));
            }
            Urb = Urb->UrbBulkOrInterruptTransfer.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_ISOCH_TRANSFER:
            if (PrintMask & VA_PRINT_TRANSFER) {
                PUSBD_ISO_PACKET_DESCRIPTOR  packet;

                HEADER(Urb);
                VA_KdPrint (("Isoch Xfer: Pipe (%x) Flags (%x) "
                             "Len (%x) Buffer (%x) MDL (%x) HCA (%x) "
                             "StartFrame (%x) NumPkts (%x) ErrorCount (%x)\n",
                             Urb->UrbIsochronousTransfer.PipeHandle,
                             Urb->UrbIsochronousTransfer.TransferFlags,
                             Urb->UrbIsochronousTransfer.TransferBufferLength,
                             Urb->UrbIsochronousTransfer.TransferBuffer,
                             Urb->UrbIsochronousTransfer.TransferBufferMDL,
                             &Urb->UrbIsochronousTransfer.hca,
                             Urb->UrbIsochronousTransfer.StartFrame,
                             Urb->UrbIsochronousTransfer.NumberOfPackets,
                             Urb->UrbIsochronousTransfer.ErrorCount));

                for (i = 0, packet = &Urb->UrbIsochronousTransfer.IsoPacket[0];
                     i < Urb->UrbIsochronousTransfer.NumberOfPackets;
                     i++, packet++) {

                    VA_KdPrint (("Offset: (%x), Length (%x), Status (%x)\n",
                                 packet->Offset,
                                 packet->Length,
                                 packet->Status));
                }
            }
            break;

        case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
            if (PrintMask & VA_PRINT_DESCRIPTOR) {
                HEADER(Urb);
                VA_KdPrint (("Device Desc: Length (%x) Buffer (%x) MDL (%x) "
                             "Index (%x) Type (%x) Lang (%x) HCA (%x)\n",
                             Urb->UrbControlDescriptorRequest.TransferBufferLength,
                             Urb->UrbControlDescriptorRequest.TransferBuffer,
                             Urb->UrbControlDescriptorRequest.TransferBufferMDL,
                             Urb->UrbControlDescriptorRequest.Index,
                             Urb->UrbControlDescriptorRequest.DescriptorType,
                             Urb->UrbControlDescriptorRequest.LanguageId,
                             &Urb->UrbControlDescriptorRequest.hca));
            }
            Urb = Urb->UrbControlDescriptorRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
            if (PrintMask & VA_PRINT_DESCRIPTOR) {
                VA_KdPrint (("Endpoint Desc: Length (%x) Buffer (%x) MDL (%x) "
                             "Index (%x) Type (%x) Lang (%x) HCA (%x)\n",
                             Urb->UrbControlDescriptorRequest.TransferBufferLength,
                             Urb->UrbControlDescriptorRequest.TransferBuffer,
                             Urb->UrbControlDescriptorRequest.TransferBufferMDL,
                             Urb->UrbControlDescriptorRequest.Index,
                             Urb->UrbControlDescriptorRequest.DescriptorType,
                             Urb->UrbControlDescriptorRequest.LanguageId,
                             &Urb->UrbControlDescriptorRequest.hca));
            }
            Urb = Urb->UrbControlDescriptorRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
            if (PrintMask & VA_PRINT_DESCRIPTOR) {
                HEADER(Urb);
                VA_KdPrint (("Interface Desc: Length (%x) Buffer (%x) MDL (%x) "
                             "Index (%x) Type (%x) Lang (%x) HCA (%x)\n",
                             Urb->UrbControlDescriptorRequest.TransferBufferLength,
                             Urb->UrbControlDescriptorRequest.TransferBuffer,
                             Urb->UrbControlDescriptorRequest.TransferBufferMDL,
                             Urb->UrbControlDescriptorRequest.Index,
                             Urb->UrbControlDescriptorRequest.DescriptorType,
                             Urb->UrbControlDescriptorRequest.LanguageId,
                             &Urb->UrbControlDescriptorRequest.hca));
            }
            Urb = Urb->UrbBulkOrInterruptTransfer.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
            if (PrintMask & VA_PRINT_DESCRIPTOR) {
                HEADER(Urb);
                VA_KdPrint (("SET Device Desc: Length (%x) Buffer (%x) MDL (%x) "
                             "Index (%x) Type (%x) Lang (%x) HCA (%x)\n",
                             Urb->UrbControlDescriptorRequest.TransferBufferLength,
                             Urb->UrbControlDescriptorRequest.TransferBuffer,
                             Urb->UrbControlDescriptorRequest.TransferBufferMDL,
                             Urb->UrbControlDescriptorRequest.Index,
                             Urb->UrbControlDescriptorRequest.DescriptorType,
                             Urb->UrbControlDescriptorRequest.LanguageId,
                             &Urb->UrbControlDescriptorRequest.hca));
            }
            Urb = Urb->UrbControlDescriptorRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
            if (PrintMask & VA_PRINT_DESCRIPTOR) {
                HEADER(Urb);
                VA_KdPrint (("SET End Desc: Length (%x) Buffer (%x) MDL (%x) "
                             "Index (%x) Type (%x) Lang (%x) HCA (%x)\n",
                             Urb->UrbControlDescriptorRequest.TransferBufferLength,
                             Urb->UrbControlDescriptorRequest.TransferBuffer,
                             Urb->UrbControlDescriptorRequest.TransferBufferMDL,
                             Urb->UrbControlDescriptorRequest.Index,
                             Urb->UrbControlDescriptorRequest.DescriptorType,
                             Urb->UrbControlDescriptorRequest.LanguageId,
                             &Urb->UrbControlDescriptorRequest.hca));
            }
            Urb = Urb->UrbControlDescriptorRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
            if (PrintMask & VA_PRINT_DESCRIPTOR) {
                HEADER(Urb);
                VA_KdPrint (("SET Intrfc Desc: Len (%x) Buffer (%x) MDL (%x) "
                             "Index (%x) Type (%x) Lang (%x) HCA (%x)\n",
                             Urb->UrbControlDescriptorRequest.TransferBufferLength,
                             Urb->UrbControlDescriptorRequest.TransferBuffer,
                             Urb->UrbControlDescriptorRequest.TransferBufferMDL,
                             Urb->UrbControlDescriptorRequest.Index,
                             Urb->UrbControlDescriptorRequest.DescriptorType,
                             Urb->UrbControlDescriptorRequest.LanguageId,
                             &Urb->UrbControlDescriptorRequest.hca));
            }
            Urb = Urb->UrbControlDescriptorRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Set Dev Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Set Interface Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Set Endpoint Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_SET_FEATURE_TO_OTHER:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Set Other Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Clear Device Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Clear Interface Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Clear Endpoint Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Clear Other Feature: Selector (%x) Index (%x)\n",
                             Urb->UrbControlFeatureRequest.FeatureSelector,
                             Urb->UrbControlFeatureRequest.Index));
            }
            Urb = Urb->UrbControlFeatureRequest.UrbLink;
            again = TRUE;
            break;


        case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Device Status: len (%x) Buffer (%x) MDL (%x) "
                             "Index (%x)\n",
                             Urb->UrbControlGetStatusRequest.TransferBufferLength,
                             Urb->UrbControlGetStatusRequest.TransferBuffer,
                             Urb->UrbControlGetStatusRequest.TransferBufferMDL,
                             Urb->UrbControlGetStatusRequest.Index));
            }
            Urb = Urb->UrbControlGetStatusRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Interface Status: len (%x) Buffer (%x) MDL (%x) "
                             "Index (%x)\n",
                             Urb->UrbControlGetStatusRequest.TransferBufferLength,
                             Urb->UrbControlGetStatusRequest.TransferBuffer,
                             Urb->UrbControlGetStatusRequest.TransferBufferMDL,
                             Urb->UrbControlGetStatusRequest.Index));
            }
            Urb = Urb->UrbControlGetStatusRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Endpoint Status: len (%x) Buffer (%x) MDL (%x) "
                             "Index (%x)\n",
                             Urb->UrbControlGetStatusRequest.TransferBufferLength,
                             Urb->UrbControlGetStatusRequest.TransferBuffer,
                             Urb->UrbControlGetStatusRequest.TransferBufferMDL,
                             Urb->UrbControlGetStatusRequest.Index));
            }
            Urb = Urb->UrbControlGetStatusRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_STATUS_FROM_OTHER:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Other Status: len (%x) Buffer (%x) MDL (%x) "
                             "Index (%x)\n",
                             Urb->UrbControlGetStatusRequest.TransferBufferLength,
                             Urb->UrbControlGetStatusRequest.TransferBuffer,
                             Urb->UrbControlGetStatusRequest.TransferBufferMDL,
                             Urb->UrbControlGetStatusRequest.Index));
            }
            Urb = Urb->UrbControlGetStatusRequest.UrbLink;
            again = TRUE;
            break;


        case URB_FUNCTION_VENDOR_DEVICE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Vendor Device Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbBulkOrInterruptTransfer.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_VENDOR_INTERFACE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Vendor Intfc Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_VENDOR_ENDPOINT:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Vendor Endpt Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_VENDOR_OTHER:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Vendor Other Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLASS_DEVICE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Class Device Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLASS_INTERFACE:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Class Intface Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLASS_ENDPOINT:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Class Endpnt Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_CLASS_OTHER:
            if (PrintMask & VA_PRINT_FEATURE) {
                HEADER(Urb);
                VA_KdPrint (("Class Other Req: len (%x) Buffer (%x) MDL (%x) "
                             "Flags (%x) RequestTypeBits (%x) "
                             "Request (%x) Value (%x) Index (%x)\n",
                             Urb->UrbControlVendorClassRequest.TransferBufferLength,
                             Urb->UrbControlVendorClassRequest.TransferBuffer,
                             Urb->UrbControlVendorClassRequest.TransferBufferMDL,
                             Urb->UrbControlVendorClassRequest.TransferFlags,
                             Urb->UrbControlVendorClassRequest.RequestTypeReservedBits,
                             Urb->UrbControlVendorClassRequest.Request,
                             Urb->UrbControlVendorClassRequest.Value,
                             Urb->UrbControlVendorClassRequest.Index));
            }
            Urb = Urb->UrbControlVendorClassRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_CONFIGURATION:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Configuration: len (%x) Buffer (%x) MDL (%x) "
                             "\n",
                             Urb->UrbControlGetConfigurationRequest.TransferBufferLength,
                             Urb->UrbControlGetConfigurationRequest.TransferBuffer,
                             Urb->UrbControlGetConfigurationRequest.TransferBufferMDL));
            }
            Urb = Urb->UrbControlGetConfigurationRequest.UrbLink;
            again = TRUE;
            break;

        case URB_FUNCTION_GET_INTERFACE:
            if (PrintMask & VA_PRINT_COMMAND) {
                HEADER(Urb);
                VA_KdPrint (("Get Interface: len (%x) Buffer (%x) MDL (%x) "
                             "\n",
                             Urb->UrbControlGetInterfaceRequest.TransferBufferLength,
                             Urb->UrbControlGetInterfaceRequest.TransferBuffer,
                             Urb->UrbControlGetInterfaceRequest.TransferBufferMDL));
            }
            Urb = Urb->UrbControlGetInterfaceRequest.UrbLink;
            again = TRUE;
            break;

        default:
            VA_KdPrint (("WARNING\n", Urb));
            VA_KdPrint (("WARNING Unkown Urb (%x)\n", Urb));
            VA_KdPrint (("WARNING\n", Urb));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\valueadd\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pnp.c

Abstract: USB lower filter driver
    This module contains the plug and play dispatch entries needed for this
    filter.

Author:

    Kenneth D. Ray

Environment:

    Kernel mode

Revision History:


--*/
#include <WDM.H>
#include "local.H"
#include "valueadd.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, VA_Power)
#pragma alloc_text (PAGE, VA_PnP)
#pragma alloc_text (PAGE, VA_StartDevice)
#pragma alloc_text (PAGE, VA_StopDevice)
#pragma alloc_text (PAGE, VA_CallUSBD)
#endif


NTSTATUS
VA_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The power dispatch routine.
    This filter does not recognize power IRPS.  It merely sends them down,
    unmodified to the next device on the attachment stack.

    As this is a POWER irp, and therefore a special irp, special power irp
    handling is required.

    No completion routine is required.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PVA_USB_DATA  usbData;
    NTSTATUS      status;

    PAGED_CODE ();

    TRAP ();

    usbData = (PVA_USB_DATA) DeviceObject->DeviceExtension;

    if (DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }
    //
    // This IRP was sent to the filter driver.
    // Since we do not know what to do with the IRP, we should pass
    // it on along down the stack.
    //

    InterlockedIncrement (&usbData->OutstandingIO);

    if (usbData->Removed) {
        status = STATUS_DELETE_PENDING;
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    } else {
        IoSkipCurrentIrpStackLocation (Irp);

        //
        // Power IRPS come synchronously; drivers must call
        // PoStartNextPowerIrp, when they are ready for the next power irp.
        // This can be called here, or in the completetion routine.
        //
        PoStartNextPowerIrp (Irp);

        //
        // NOTE!!! PoCallDriver NOT IoCallDriver.
        //
        status =  PoCallDriver (usbData->TopOfStack, Irp);
    }

    if (0 == InterlockedDecrement (&usbData->OutstandingIO)) {
        KeSetEvent (&usbData->RemoveEvent, 0, FALSE);
    }
    return status;
}



NTSTATUS
VA_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );



NTSTATUS
VA_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these this filter driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PVA_USB_DATA        usbData;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    PVA_CONTROL_DATA    controlData;
    KIRQL               oldIrql;

    PAGED_CODE ();

    usbData = (PVA_USB_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);

    if(DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }

    InterlockedIncrement (&usbData->OutstandingIO);
    if (usbData->Removed) {

        //
        // Someone sent us another plug and play IRP after the remove IRP.
        // This should never happen.
        //
        ASSERT (FALSE);

        if (0 == InterlockedDecrement (&usbData->OutstandingIO)) {
            KeSetEvent (&usbData->RemoveEvent, 0, FALSE);
        }
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);
        KeInitializeEvent(&usbData->StartEvent, NotificationEvent, FALSE);
        IoSetCompletionRoutine (Irp,
                                VA_PnPComplete,
                                usbData,
                                TRUE,
                                TRUE,
                                TRUE); // No need for Cancel

        status = IoCallDriver (usbData->TopOfStack, Irp);
        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &usbData->StartEvent,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout

            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS (status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            status = VA_StartDevice (usbData, Irp);
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    case IRP_MN_STOP_DEVICE:
        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //

        //
        // Do what ever
        //

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //
        VA_StopDevice (usbData, TRUE);
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (usbData->TopOfStack, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // The PlugPlay system has dictacted the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!usbData->Removed);

        //
        // We will no longer receive requests for this device as it has been
        // removed.
        //
        usbData->Removed = TRUE;

        if (usbData->Started) {
            // Stop the device without touching the hardware.
            VA_StopDevice(usbData, FALSE);
        }

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //

        controlData = (PVA_CONTROL_DATA) Global.ControlObject->DeviceExtension;
        KeAcquireSpinLock (&controlData->Spin, &oldIrql);
        RemoveEntryList (&usbData->List);
        InterlockedDecrement (&controlData->NumUsbDevices);
        KeReleaseSpinLock (&controlData->Spin, oldIrql);

        ASSERT (0 < InterlockedDecrement (&usbData->OutstandingIO));
        if (0 < InterlockedDecrement (&usbData->OutstandingIO)) {
            KeWaitForSingleObject (
                &usbData->RemoveEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
        }

        //
        // Send on the remove IRP
        //

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (usbData->TopOfStack, Irp);

        IoDetachDevice (usbData->TopOfStack);

        //
        // Clean up memory
        //

        IoDeleteDevice (usbData->Self);
        return STATUS_SUCCESS;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (usbData->TopOfStack, Irp);
        break;
    }


    if (0 == InterlockedDecrement (&usbData->OutstandingIO)) {
        KeSetEvent (&usbData->RemoveEvent, 0, FALSE);
    }

    return status;
}


NTSTATUS
VA_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;
    PVA_USB_DATA        usbData;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (DeviceObject);

    status = STATUS_SUCCESS;
    usbData = (PVA_USB_DATA) Context;
    stack = IoGetCurrentIrpStackLocation (Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    switch (stack->MajorFunction) {
    case IRP_MJ_PNP:

        switch (stack->MinorFunction) {
        case IRP_MN_START_DEVICE:

            KeSetEvent (&usbData->StartEvent, 0, FALSE);

            //
            // Take the IRP back so that we can continue using it during
            // the IRP_MN_START_DEVICE dispatch routine.
            // NB: we will have to call IoCompleteRequest
            //
            return STATUS_MORE_PROCESSING_REQUIRED;

        default:
            break;
        }
        break;

    case IRP_MJ_POWER:
    default:
        break;
    }
    return status;
}

NTSTATUS
VA_StartDevice (
    IN PVA_USB_DATA     UsbData,
    IN PIRP             Irp
    )
/*++

Routine Description:

Arguments:


--*/
{
    NTSTATUS    status;
    PURB        purb;
    struct _URB_CONTROL_DESCRIPTOR_REQUEST  urb;

    PAGED_CODE();

    ASSERT (!UsbData->Removed);
    //
    // The PlugPlay system should not have started a removed device!
    //

    if (UsbData->Started) {
        return STATUS_SUCCESS;
    }

    //
    // Learn about the device
    //

    purb = (PURB) &urb;

    UsbBuildGetDescriptorRequest (purb,
                                  (USHORT) sizeof (urb),
                                  USB_DEVICE_DESCRIPTOR_TYPE,
                                  0, // index
                                  0, // language id
                                  &UsbData->DeviceDesc,
                                  NULL, // no MDL
                                  sizeof (UsbData->DeviceDesc),
                                  NULL); // no linked urbs here

    status = VA_CallUSBD (UsbData, purb, Irp);

    if (!NT_SUCCESS (status)) {
        VA_KdPrint (("Get Device Descriptor failed (%x)\n", status));
        TRAP ();
        goto VA_START_DEVICE_REJECT;
    } else {
        VA_KdPrint (("-------------------------\n"));
        VA_KdPrint (("Device Descriptor = %x, len %x\n",
                         &UsbData->DeviceDesc,
                         urb.TransferBufferLength));

        VA_KdPrint (("USB Device Descriptor:\n"));
        VA_KdPrint (("bLength %d\n", UsbData->DeviceDesc.bLength));
        VA_KdPrint (("bDescriptorType 0x%x\n", UsbData->DeviceDesc.bDescriptorType));
        VA_KdPrint (("bcdUSB 0x%x\n", UsbData->DeviceDesc.bcdUSB));
        VA_KdPrint (("bDeviceClass 0x%x\n", UsbData->DeviceDesc.bDeviceClass));
        VA_KdPrint (("bDeviceSubClass 0x%x\n", UsbData->DeviceDesc.bDeviceSubClass));
        VA_KdPrint (("bDeviceProtocol 0x%x\n", UsbData->DeviceDesc.bDeviceProtocol));
        VA_KdPrint (("bMaxPacketSize0 0x%x\n", UsbData->DeviceDesc.bMaxPacketSize0));
        VA_KdPrint (("idVendor 0x%x\n", UsbData->DeviceDesc.idVendor));
        VA_KdPrint (("idProduct 0x%x\n", UsbData->DeviceDesc.idProduct));
        VA_KdPrint (("bcdDevice 0x%x\n", UsbData->DeviceDesc.bcdDevice));
        VA_KdPrint (("iManufacturer 0x%x\n", UsbData->DeviceDesc.iManufacturer));
        VA_KdPrint (("iProduct 0x%x\n", UsbData->DeviceDesc.iProduct));
        VA_KdPrint (("iSerialNumber 0x%x\n", UsbData->DeviceDesc.iSerialNumber));
        VA_KdPrint (("bNumConfigurations 0x%x\n", UsbData->DeviceDesc.bNumConfigurations));
        VA_KdPrint (("-------------------------\n"));
    }


    return status;

VA_START_DEVICE_REJECT:

//#define CondFree(addr) if ((addr)) ExFreePool ((addr))
//    CondFree(usbData->Ppd);
//#undef CondFree

    return status;
}

VOID
VA_StopDevice (
    IN PVA_USB_DATA UsbData,
    IN BOOLEAN      TouchTheHardware
    )
/*++

Routine Description:
    The PlugPlay system has dictacted the removal of this device.  We have
    no choise but to detach and delete the device objecct.
    (If we wanted to express and interest in preventing this removal,
    we should have filtered the query remove and query stop routines.)

    Note! we might receive a remove WITHOUT first receiving a stop.

Arguments:
    UsbData - The device extension for the usb device being started.
    TouchTheHardware - Can we actually send non PnP irps to this thing?

--*/
{
    TRAP();
    PAGED_CODE ();
    ASSERT (!UsbData->Removed);
    //
    // The PlugPlay system should not have started a removed device!
    //


    if (!UsbData->Started) {
        return;
    }

    if (TouchTheHardware) {
        //
        // Undo any value add thing required to allow this device to actually
        // stop.  If there is some shutdown procedure required, or any
        // settings required for this device before system shutdown or
        // device removal, now is the best time for it.
        //
        ;
    } else {
        //
        // The device is no longer around, so we cannot actually control it.
        // We should instead do what ever necessary in lieu of that.
        //
        ;
    }

    UsbData->Started = FALSE;

    return;
}

NTSTATUS
VA_Complete (
    IN PDEVICE_OBJECT   Device,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*+
Routine Description:
    Get the IRP back

--*/
{
    UNREFERENCED_PARAMETER (Device);
    KeSetEvent ((PKEVENT) Context, 0, FALSE);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
VA_CallUSBD(
    IN PVA_USB_DATA     UsbData,
    IN PURB             Urb,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Synchronously passes a URB to the USBD class driver
    This can only be called at PASSIVE_LEVEL and on a thread where you can
    wait on an event.  (EG a plug play irp)

Arguments:

    DeviceObject - pointer to the device object for this instance of an 82930

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    KEVENT              event;
    PIO_STACK_LOCATION  nextStack;

    PAGED_CODE ();

    VA_KdPrint (("enter VA_CallUSBD\n"));

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(Irp);
    ASSERT(nextStack != NULL);

    //
    // pass the URB to the USB driver stack
    //
    nextStack->Parameters.Others.Argument1 = Urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    IoSetCompletionRoutine (Irp, VA_Complete, &event, TRUE, TRUE, TRUE);

    VA_KdPrint (("calling USBD\n"));

    status = IoCallDriver(UsbData->TopOfStack, Irp);

    VA_KdPrint (("return from IoCallDriver USBD %x\n", status));

    if (STATUS_PENDING == status) {

        VA_KdPrint (("Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        VA_KdPrint (("KeWait (0x%x)\n", status));
    }

    VA_KdPrint (("URB status = %x status = %x irp status %x\n",
                 Urb->UrbHeader.Status, status, Irp->IoStatus.Status));

    return Irp->IoStatus.Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\valueadd\valueadd.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    VALIDATE.H

Abstract:

    This module contains the PUBLIC definitions for the to allow user
    apps to access this filter driver.

Environment:

    Kernel & user mode

Revision History:

    Feb-97 : created by Kenneth Ray

--*/


#ifndef _VALUEADD_H
#define _VALUEADD_H

#define VA_FILTER_NTNAME  L"\\Device\\USB_Valueadd_Driver"
#define VA_FILTER_SYMNAME L"\\DosDevices\\USBValueadd"
#define VA_FILTER_W32Name "\\\\.\\USBValueadd"


#define STIM_CODE(_x_) CTL_CODE(                             \
                           FILE_DEVICE_UNKNOWN,              \
                           (0x800 | _x_),                    \
                           METHOD_BUFFERED,                  \
                           FILE_ANY_ACCESS                   \
                           )

// #define IOCTL_HIDV_      CTL_CODE(1)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\common.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    common.c

Abstract:

    Common code for the Windows CE
    USB Serial Host and Filter drivers

Author:

    Jeff Midkiff (jeffmi)     08-24-99

--*/
#include <stdio.h>

#include "wceusbsh.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWCE0, QueryRegistryParameters)
#pragma alloc_text(PAGEWCE0, CreateDevObjAndSymLink)
#pragma alloc_text(PAGEWCE0, DeleteDevObjAndSymLink)
#pragma alloc_text(PAGEWCE0, IsWin9x)

#pragma alloc_text(PAGEWCE1, LogError)
#endif


NTSTATUS
QueryRegistryParameters(
   IN PUNICODE_STRING RegistryPath
    )
/*++

This routine queryies the Registry for our Parameters key.
We are given the RegistryPath to our driver during DriverEntry,
but don't yet have an extension, so we store the values in globals
until we get our device extension.

The values are setup from our INF.

On WinNT this is under
   HKLM\SYSTEM\ControlSet\Services\wceusbsh\Parameters

On Win98 this is under
   HKLM\System\CurrentControlSet\Services\Class\WCESUSB\000*


Returns - nothing; use defaults

--*/
{
    #define NUM_REG_ENTRIES 6
    RTL_QUERY_REGISTRY_TABLE rtlQueryRegTbl[ NUM_REG_ENTRIES + 1 ];

    ULONG sizeOfUl = sizeof( ULONG );
    ULONG ulAlternateSetting = DEFAULT_ALTERNATE_SETTING;
    LONG  lIntTimout = DEFAULT_INT_PIPE_TIMEOUT;
    ULONG ulMaxPipeErrors = DEFAULT_MAX_PIPE_DEVICE_ERRORS;
    ULONG ulDebugLevel = DBG_OFF;
    ULONG ulExposeComPort = FALSE;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT( RegistryPath != NULL );

    RtlZeroMemory( rtlQueryRegTbl, sizeof(rtlQueryRegTbl) );

    //
    // Setup the query table
    // Note: the 1st table entry is the \Parameters subkey,
    // and the last table entry is NULL
    //
    rtlQueryRegTbl[0].QueryRoutine = NULL;
    rtlQueryRegTbl[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    rtlQueryRegTbl[0].Name = L"Parameters";
    rtlQueryRegTbl[0].EntryContext = NULL;
    rtlQueryRegTbl[0].DefaultType = (ULONG_PTR)NULL;
    rtlQueryRegTbl[0].DefaultData = NULL;
    rtlQueryRegTbl[0].DefaultLength = (ULONG_PTR)NULL;

    rtlQueryRegTbl[1].QueryRoutine = NULL;
    rtlQueryRegTbl[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    rtlQueryRegTbl[1].Name = L"DebugLevel";
    rtlQueryRegTbl[1].EntryContext = &DebugLevel;
    rtlQueryRegTbl[1].DefaultType = REG_DWORD;
    rtlQueryRegTbl[1].DefaultData = &ulDebugLevel;
    rtlQueryRegTbl[1].DefaultLength = sizeOfUl;

    rtlQueryRegTbl[2].QueryRoutine = NULL;
    rtlQueryRegTbl[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    rtlQueryRegTbl[2].Name = L"AlternateSetting";
    rtlQueryRegTbl[2].EntryContext = &g_ulAlternateSetting;
    rtlQueryRegTbl[2].DefaultType = REG_DWORD;
    rtlQueryRegTbl[2].DefaultData = &ulAlternateSetting;
    rtlQueryRegTbl[2].DefaultLength = sizeOfUl;

    rtlQueryRegTbl[3].QueryRoutine = NULL;
    rtlQueryRegTbl[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    rtlQueryRegTbl[3].Name = L"InterruptTimeout";
    rtlQueryRegTbl[3].EntryContext = &g_lIntTimout;
    rtlQueryRegTbl[3].DefaultType = REG_DWORD;
    rtlQueryRegTbl[3].DefaultData = &lIntTimout;
    rtlQueryRegTbl[3].DefaultLength = sizeOfUl;

    rtlQueryRegTbl[4].QueryRoutine = NULL;
    rtlQueryRegTbl[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
    rtlQueryRegTbl[4].Name = L"MaxPipeErrors";
    rtlQueryRegTbl[4].EntryContext = &g_ulMaxPipeErrors;
    rtlQueryRegTbl[4].DefaultType = REG_DWORD;
    rtlQueryRegTbl[4].DefaultData = &ulMaxPipeErrors;
    rtlQueryRegTbl[4].DefaultLength = sizeOfUl;

    rtlQueryRegTbl[5].QueryRoutine = NULL;
    rtlQueryRegTbl[5].Flags = RTL_QUERY_REGISTRY_DIRECT;
    rtlQueryRegTbl[5].Name = L"ExposeComPort";
    rtlQueryRegTbl[5].EntryContext = &g_ExposeComPort;
    rtlQueryRegTbl[5].DefaultType = REG_DWORD;
    rtlQueryRegTbl[5].DefaultData = &ulExposeComPort;
    rtlQueryRegTbl[5].DefaultLength = sizeOfUl;

    //
    // query the Registry
    //
    status = RtlQueryRegistryValues(
                RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,  // RelativeTo
                RegistryPath->Buffer,                           // Path
                rtlQueryRegTbl,                                 // QueryTable
                NULL,                                           // Context
                NULL );                                         // Environment

    if ( !NT_SUCCESS( status ) )  {
      //
      // if registry query failed then use defaults
      //
      DbgDump( DBG_INIT,  ("RtlQueryRegistryValues error: 0x%x\n", status) );

      g_ulAlternateSetting = ulAlternateSetting;
      g_lIntTimout = lIntTimout;
      g_ulMaxPipeErrors = ulMaxPipeErrors;
      DebugLevel = DBG_OFF;

    }

   DbgDump( DBG_INIT, ("DebugLevel = 0x%x\n", DebugLevel));

   DbgDump( DBG_INIT, ("AlternateSetting = %d\n", g_ulAlternateSetting));
   DbgDump( DBG_INIT, ("MaxPipeErrors = %d\n", g_ulMaxPipeErrors));
   DbgDump( DBG_INIT, ("INT Timeout = %d\n", g_lIntTimout));

   return status;
}


VOID
ReleaseSlot(
   IN LONG Slot
   )
{
   LONG lNumDevices = InterlockedDecrement(&g_NumDevices);
   UNREFERENCED_PARAMETER( Slot );

   ASSERT( lNumDevices >= 0);

   return;
}


NTSTATUS
AcquireSlot(
   OUT PULONG PSlot
   )
{
   NTSTATUS status = STATUS_SUCCESS;

   *PSlot = InterlockedIncrement(&g_NumDevices);

   if (*PSlot == (ULONG)0) {
      status = STATUS_INVALID_DEVICE_REQUEST;
   }

   return status;
}


NTSTATUS
CreateDevObjAndSymLink(
    IN PDRIVER_OBJECT PDrvObj,
    IN PDEVICE_OBJECT PPDO,
    IN PDEVICE_OBJECT *PpDevObj,
    IN PCHAR PDevName
    )
/*++

Routine Description:

    Creates a named device object and symbolic link
    for the next available device instance. Saves both the \\Device\\PDevName%n
    and \\DosDevices\\PDevName%n in the device extension.

    Also registers our device interface with PnP system.

Arguments:

    PDrvObj - Pointer to our driver object
    PPDO - Pointer to the PDO for the stack to which we should add ourselves
    PDevName - device name to use

Return Value:

    NTSTATUS

--*/
{
   PDEVICE_EXTENSION pDevExt = NULL;
   NTSTATUS status;
   ULONG deviceInstance;
   ULONG bufferLen;
   BOOLEAN gotSlot = FALSE;

   ANSI_STRING asDevName;
   ANSI_STRING asDosDevName;

   UNICODE_STRING usDeviceName = {0}; // seen only in kernel-mode namespace
   UNICODE_STRING usDosDevName = {0}; // seen in user-mode namespace

   CHAR dosDeviceNameBuffer[DOS_NAME_MAX];
   CHAR deviceNameBuffer[DOS_NAME_MAX];

   DbgDump(DBG_INIT, (">CreateDevObjAndSymLink\n"));
   PAGED_CODE();
   ASSERT( PPDO );

   //
   // init the callers device obj
   //
   *PpDevObj = NULL;

   //
   // Get the next device instance number
   //
   status = AcquireSlot(&deviceInstance);
   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("AcquireSlot error: 0x%x\n", status));
      goto CreateDeviceObjectError;
   } else {
      gotSlot = TRUE;
   }

   //
   // concat device name & instance number
   //
   ASSERT( *PDevName != (CHAR)NULL);
   sprintf(dosDeviceNameBuffer, "%s%s%03d", "\\DosDevices\\", PDevName,
           deviceInstance);
   sprintf(deviceNameBuffer, "%s%s%03d", "\\Device\\", PDevName,
           deviceInstance);

   // convert names to ANSI string
   RtlInitAnsiString(&asDevName, deviceNameBuffer);
   RtlInitAnsiString(&asDosDevName, dosDeviceNameBuffer);

   usDeviceName.Length = 0;
   usDeviceName.Buffer = NULL;

   usDosDevName.Length = 0;
   usDosDevName.Buffer = NULL;

   //
   // convert names to UNICODE
   //
   status = RtlAnsiStringToUnicodeString(&usDeviceName, &asDevName, TRUE);
   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("RtlAnsiStringToUnicodeString error: 0x%x\n", status));
      goto CreateDeviceObjectError;
   }

   status = RtlAnsiStringToUnicodeString(&usDosDevName, &asDosDevName, TRUE);
   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("RtlAnsiStringToUnicodeString error: 0x%x\n", status));
      goto CreateDeviceObjectError;
   }

   //
   // create the named devive object
   // Note: we may want to change this to a non-exclusive later
   // so xena to come in without the filter.
   //
   status = IoCreateDevice( PDrvObj,
                            sizeof(DEVICE_EXTENSION),
                            &usDeviceName,
                            FILE_DEVICE_SERIAL_PORT,
                            0,
                            TRUE,       // Note: SerialPorts are exclusive
                            PpDevObj);

   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("IoCreateDevice error: 0x%x\n", status));
      TEST_TRAP();
      goto CreateDeviceObjectError;
   }

   //
   // get pointer to device extension
   //
   pDevExt = (PDEVICE_EXTENSION) (*PpDevObj)->DeviceExtension;

   RtlZeroMemory(pDevExt, sizeof(DEVICE_EXTENSION)); // (redundant)

   //
   // init SERIAL_PORT_INTERFACE
   //
   pDevExt->SerialPort.Type = WCE_SERIAL_PORT_TYPE;

   //
   // create symbolic link
   //
   status = IoCreateUnprotectedSymbolicLink(&usDosDevName, &usDeviceName);
   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("IoCreateUnprotectedSymbolicLink error: 0x%x\n", status));
      goto CreateDeviceObjectError;
   }

   DbgDump(DBG_INIT, ("SymbolicLink: %ws\n", usDosDevName.Buffer));

   //
   // Make the device visible via a device association as well.
   // The reference string is the eight digit device index
   //
   status = IoRegisterDeviceInterface(
                PPDO,
                (LPGUID)&GUID_WCE_SERIAL_USB,
                NULL,
                &pDevExt->DeviceClassSymbolicName );

   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("IoRegisterDeviceInterface error: 0x%x\n", status));
      pDevExt->DeviceClassSymbolicName.Buffer = NULL;
      goto CreateDeviceObjectError;
   }

   DbgDump(DBG_INIT, ("DeviceClassSymbolicName: %ws\n", pDevExt->DeviceClassSymbolicName.Buffer));

   //
   // save the Dos Device link name in our extension
   //
   strcpy(pDevExt->DosDeviceName, dosDeviceNameBuffer);

   pDevExt->SymbolicLink = TRUE;


   //
   // save (kernel) device name in extension
   //
   bufferLen = RtlAnsiStringToUnicodeSize(&asDevName);

   pDevExt->DeviceName.Length = 0;
   pDevExt->DeviceName.MaximumLength = (USHORT)bufferLen;

   pDevExt->DeviceName.Buffer = ExAllocatePool(PagedPool, bufferLen);
   if (pDevExt->DeviceName.Buffer == NULL) {
      //
      // Skip out.  We have worse problems than missing
      // the name if we have no memory at this point.
      //
      status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("CreateDevObjAndSymLink ERROR: 0x%x\n", status));
      goto CreateDeviceObjectError;
   }

   RtlAnsiStringToUnicodeString(&pDevExt->DeviceName, &asDevName, FALSE);
   // save 1's based device instance number
   pDevExt->SerialPort.Com.Instance = deviceInstance;

CreateDeviceObjectError:;

   //
   // free Unicode strings
   //
   RtlFreeUnicodeString(&usDeviceName);
   RtlFreeUnicodeString(&usDosDevName);

   //
   // Delete the devobj if there was an error
   //
   if (status != STATUS_SUCCESS) {

      if ( *PpDevObj ) {

         DeleteDevObjAndSymLink( *PpDevObj );

         *PpDevObj = NULL;

      }

      if (gotSlot) {
         ReleaseSlot(deviceInstance);
      }
   }

   DbgDump(DBG_INIT, ("<CreateDevObjAndSymLink 0x%x\n", status));

   return status;
}



NTSTATUS
DeleteDevObjAndSymLink(
   IN PDEVICE_OBJECT PDevObj
   )
{
   PDEVICE_EXTENSION pDevExt;
   UNICODE_STRING    usDevLink;
   ANSI_STRING       asDevLink;
   NTSTATUS          NtStatus = STATUS_SUCCESS;

   DbgDump(DBG_INIT, (">DeleteDevObjAndSymLink\n"));
   PAGED_CODE();
   ASSERT( PDevObj );

   pDevExt = (PDEVICE_EXTENSION) PDevObj->DeviceExtension;
   ASSERT( pDevExt );

   // get rid of the symbolic link
   if ( pDevExt->SymbolicLink ) {

      RtlInitAnsiString( &asDevLink, pDevExt->DosDeviceName );

      NtStatus = RtlAnsiStringToUnicodeString( &usDevLink,
                                              &asDevLink, TRUE);

      ASSERT(STATUS_SUCCESS == NtStatus);
      NtStatus = IoDeleteSymbolicLink(&usDevLink);

   }

    if (pDevExt->DeviceClassSymbolicName.Buffer)
    {
        NtStatus = IoSetDeviceInterfaceState(&pDevExt->DeviceClassSymbolicName, FALSE);
        if (NT_SUCCESS(NtStatus)) {
            DbgDump(DBG_WRN, ("IoSetDeviceInterfaceState.3: OFF\n"));
        }

        ExFreePool( pDevExt->DeviceClassSymbolicName.Buffer );
        pDevExt->DeviceClassSymbolicName.Buffer = NULL;
   }

   if (pDevExt->DeviceName.Buffer != NULL) {
      ExFreePool(pDevExt->DeviceName.Buffer);
      RtlInitUnicodeString(&pDevExt->DeviceName, NULL);
   }

   //
   // Wait to do this untill here as this triggers the unload routine
   // at which point everything better have been deallocated
   //
   IoDeleteDevice( PDevObj );

   DbgDump(DBG_INIT, ("<DeleteDevObjAndSymLink\n"));

   return NtStatus;
}

#if 0

VOID
SetBooleanLocked(
   IN OUT PBOOLEAN PDest,
   IN BOOLEAN      Src,
   IN PKSPIN_LOCK  PSpinLock
   )
/*++

Routine Description:

    This function is used to assign a BOOLEAN value with spinlock protection.

Arguments:

    PDest - A pointer to Lval.

    Src - Rval.

    PSpinLock - Pointer to the spin lock we should hold.

Return Value:

    None.

--*/
{
  KIRQL tmpIrql;

  KeAcquireSpinLock(PSpinLock, &tmpIrql);
  *PDest = Src;
  KeReleaseSpinLock(PSpinLock, tmpIrql);
}
#endif


VOID
SetPVoidLocked(
   IN OUT PVOID *PDest,
   IN OUT PVOID Src,
   IN PKSPIN_LOCK PSpinLock
   )
{
  KIRQL tmpIrql;

  KeAcquireSpinLock(PSpinLock, &tmpIrql);
  *PDest = Src;
  KeReleaseSpinLock(PSpinLock, tmpIrql);
}


//
// Note: had to use ExWorkItems to be binary compatible with Win98.
// The WorkerRoutine must take as it's only parameter a PWCE_WORK_ITEM
// and extract any parameters. When the WorkerRoutine is complete is MUST
// call DequeueWorkItem to free it back to the worker pool & signal any waiters.
//
NTSTATUS
QueueWorkItem(
   IN PDEVICE_OBJECT PDevObj,
   IN PWCE_WORKER_THREAD_ROUTINE WorkerRoutine,
   IN PVOID Context,
   IN ULONG Flags
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_INVALID_PARAMETER;
   PWCE_WORK_ITEM pWorkItem;
   KIRQL irql;

   DbgDump(DBG_WORK_ITEMS, (">QueueWorkItem\n" ));

   //
   // N.B: you need to ensure your driver does not queue anything when it is stopped.
   //
   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   if ( !CanAcceptIoRequests(PDevObj, FALSE, TRUE) ) {

      status = STATUS_DELETE_PENDING;
      DbgDump(DBG_ERR, ("QueueWorkItem: 0x%x\n", status));

   } else if ( PDevObj && WorkerRoutine ) {

      pWorkItem = ExAllocateFromNPagedLookasideList( &pDevExt->WorkItemPool );

      if ( pWorkItem ) {

         status = AcquireRemoveLock(&pDevExt->RemoveLock, pWorkItem);
         if ( !NT_SUCCESS(status) ) {
             DbgDump(DBG_ERR, ("QueueWorkItem: 0x%x\n", status));
             TEST_TRAP();
             ExFreeToNPagedLookasideList( &pDevExt->WorkItemPool, pWorkItem );
             KeReleaseSpinLock(&pDevExt->ControlLock, irql);
             return status;
         }

         RtlZeroMemory( pWorkItem, sizeof(*pWorkItem) );

         // bump the pending count
         InterlockedIncrement(&pDevExt->PendingWorkItemsCount);

         DbgDump(DBG_WORK_ITEMS, ("PendingWorkItemsCount: %d\n", pDevExt->PendingWorkItemsCount));

         //
         // put the worker on our pending list
         //
         InsertTailList(&pDevExt->PendingWorkItems,
                        &pWorkItem->ListEntry );

         //
         // store parameters
         //
         pWorkItem->DeviceObject = PDevObj;
         pWorkItem->Context = Context;
         pWorkItem->Flags = Flags;

         ExInitializeWorkItem( &pWorkItem->Item,
                               (PWORKER_THREAD_ROUTINE)WorkerRoutine,
                               (PVOID)pWorkItem // Context passed to WorkerRoutine
                              );

         // finally, queue the worker
         ExQueueWorkItem( &pWorkItem->Item,
                          CriticalWorkQueue );

         status = STATUS_SUCCESS;

      } else {
         status = STATUS_INSUFFICIENT_RESOURCES;
         DbgDump(DBG_ERR, ("AllocateWorkItem failed!\n"));
         TEST_TRAP()
      }
   }

   KeReleaseSpinLock(&pDevExt->ControlLock, irql);

   DbgDump(DBG_WORK_ITEMS, ("<QueueWorkItem 0x%x\n", status ));

   return status;
}


VOID
DequeueWorkItem(
   IN PDEVICE_OBJECT PDevObj,
   IN PWCE_WORK_ITEM PWorkItem
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   KIRQL irql;

   DbgDump(DBG_WORK_ITEMS, (">DequeueWorkItem\n" ));

   //
   // remove the worker from the pending list
   //
   KeAcquireSpinLock( &pDevExt->ControlLock,  &irql );

   RemoveEntryList( &PWorkItem->ListEntry );

   KeReleaseSpinLock( &pDevExt->ControlLock, irql);

   //
   // free the worker back to pool
   //
   ExFreeToNPagedLookasideList( &pDevExt->WorkItemPool, PWorkItem );

   //
   // signal event if this is the last one
   //
   if (0 == InterlockedDecrement( &pDevExt->PendingWorkItemsCount) ) {
      DbgDump(DBG_WORK_ITEMS, ("PendingWorkItemsEvent signalled\n" ));
      KeSetEvent( &pDevExt->PendingWorkItemsEvent, IO_NO_INCREMENT, FALSE);
   }
   DbgDump(DBG_WORK_ITEMS, ("PendingWorkItemsCount: %d\n", pDevExt->PendingWorkItemsCount));
   ASSERT(pDevExt->PendingWorkItemsCount >= 0);

   ReleaseRemoveLock(&pDevExt->RemoveLock, PWorkItem);

   DbgDump(DBG_WORK_ITEMS, ("<DequeueWorkItem\n" ));

   return;
}


#pragma warning( push )
#pragma warning( disable : 4706 ) // assignment w/i conditional expression
NTSTATUS
WaitForPendingItem(
   IN PDEVICE_OBJECT PDevObj,
   IN PKEVENT PPendingEvent,
   IN PULONG  PPendingCount
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   LARGE_INTEGER  timeOut = {0,0};
   LONG itemsLeft;
   NTSTATUS status = STATUS_SUCCESS;

   DbgDump(DBG_PNP, (">WaitForPendingItem\n"));

   if ( !PDevObj || !PPendingEvent || !PPendingCount ) {

      status = STATUS_INVALID_PARAMETER;
      DbgDump(DBG_ERR, ("WaitForPendingItem: STATUS_INVALID_PARAMETER\n"));
      TEST_TRAP();

   } else {

      //
      // wait for pending item to signal it's complete
      //
      while ( itemsLeft = InterlockedExchange( PPendingCount, *PPendingCount) ) {

         DbgDump(DBG_PNP|DBG_EVENTS, ("Pending Items Remain: %d\n", itemsLeft ) );

         timeOut.QuadPart = MILLISEC_TO_100NANOSEC( DEFAULT_PENDING_TIMEOUT );

         DbgDump(DBG_PNP|DBG_EVENTS, ("Waiting for %d msec...\n", timeOut.QuadPart/10000));

         PAGED_CODE();

         KeWaitForSingleObject( PPendingEvent,
                                Executive,
                                KernelMode,
                                FALSE,
                                &timeOut );

      }

      DbgDump(DBG_PNP, ("Pending Items: %d\n", itemsLeft ) );
   }

   DbgDump(DBG_PNP, ("<WaitForPendingItem (0x%x)\n", status));

   return status;
}
#pragma warning( pop )


BOOLEAN
CanAcceptIoRequests(
   IN PDEVICE_OBJECT DeviceObject,
   IN BOOLEAN        AcquireLock,
   IN BOOLEAN        CheckOpened
   )
/*++

Routine Description:

  Check device extension status flags.
  Can NOT accept a new I/O request if device:
      1) is removed,
      2) has never been started,
      3) is stopped,
      4) has a remove request pending, or
      5) has a stop device pending

  ** Called with the SpinLock held, else AcquireLock should be TRUE **

Arguments:

    DeviceObject - pointer to the device object
    AcquireLock  - if TRUE then we need to acquire the lock
    CheckOpened  - normally set to TRUE during I/O.
                   Special cases where FALSE include:
                   IRP_MN_QUERY_PNP_DEVICE_STATE
                   IRP_MJ_CREATE

Return Value:

    TRUE/FALSE

--*/
{
    PDEVICE_EXTENSION pDevExt = DeviceObject->DeviceExtension;
    BOOLEAN bRc = FALSE;
    KIRQL   irql;

    if (AcquireLock) {
        KeAcquireSpinLock(&pDevExt->ControlLock, &irql);
    }

    if ( !InterlockedCompareExchange(&pDevExt->DeviceRemoved, FALSE, FALSE) &&
          InterlockedCompareExchange(&pDevExt->AcceptingRequests, TRUE, TRUE) &&
          InterlockedCompareExchange((PULONG)&pDevExt->PnPState, PnPStateStarted, PnPStateStarted) &&
          (CheckOpened ? InterlockedCompareExchange(&pDevExt->DeviceOpened, TRUE, TRUE) : TRUE)
       )
    {
        bRc = TRUE;
    }
#if defined(DBG)
    else DbgDump(DBG_WRN|DBG_PNP, ("CanAcceptIoRequests = FALSE\n"));
#endif

    if (AcquireLock) {
        KeReleaseSpinLock(&pDevExt->ControlLock, irql);
    }

    return bRc;
}


BOOLEAN
IsWin9x(
   VOID
   )
/*++

Routine Description:

    Determine whether or not we are running on Win9x (vs. NT).

Arguments:


Return Value:

    TRUE iff we're running on Win9x.

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING keyName;
    HANDLE hKey;
    NTSTATUS status;
    BOOLEAN result;

    PAGED_CODE();

    /*
     *  Try to open the COM Name Arbiter, which exists only on NT.
     */
    RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter");
    InitializeObjectAttributes( &objectAttributes,
                                &keyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                (PSECURITY_DESCRIPTOR)NULL);

    status = ZwOpenKey(&hKey, KEY_QUERY_VALUE, &objectAttributes);
    if (NT_SUCCESS(status)){
        status = ZwClose(hKey);
        ASSERT(NT_SUCCESS(status));
        result = FALSE;
    }
    else {
        result = TRUE;
    }

    return result;
}



VOID
LogError(
   IN PDRIVER_OBJECT DriverObject,
   IN PDEVICE_OBJECT DeviceObject OPTIONAL,
   IN ULONG SequenceNumber,
   IN UCHAR MajorFunctionCode,
   IN UCHAR RetryCount,
   IN ULONG UniqueErrorValue,
   IN NTSTATUS FinalStatus,
   IN NTSTATUS SpecificIOStatus,
   IN ULONG LengthOfInsert1,
   IN PWCHAR Insert1,
   IN ULONG LengthOfInsert2,
   IN PWCHAR Insert2
   )

/*++

Routine Description:

    Stolen from serial.sys

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject - A pointer to the driver object for the device.

    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.

    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.

    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.

    RetryCount - The number of times a particular operation has been
    retried.

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfInsert1 - The length in bytes (including the terminating NULL)
                      of the first insertion string.

    Insert1 - The first insertion string.

    LengthOfInsert2 - The length in bytes (including the terminating NULL)
                      of the second insertion string.  NOTE, there must
                      be a first insertion string for their to be
                      a second insertion string.

    Insert2 - The second insertion string.

Return Value:

    None.

--*/

{
   PIO_ERROR_LOG_PACKET errorLogEntry;

   PVOID objectToUse = NULL;
   SHORT dumpToAllocate = 0;
   PUCHAR ptrToFirstInsert = NULL;
   PUCHAR ptrToSecondInsert = NULL;

   PAGED_CODE();

   DbgDump(DBG_ERR, (">LogError\n"));

   if (Insert1 == NULL) {
      LengthOfInsert1 = 0;
   }

   if (Insert2 == NULL) {
      LengthOfInsert2 = 0;
   }

   if (ARGUMENT_PRESENT(DeviceObject)) {

      objectToUse = DeviceObject;

   } else if (ARGUMENT_PRESENT(DriverObject)) {

      objectToUse = DriverObject;

   }

   errorLogEntry = IoAllocateErrorLogEntry(
                                          objectToUse,
                                          (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                                  dumpToAllocate
                                                  + LengthOfInsert1 +
                                                  LengthOfInsert2)
                                          );

   if ( errorLogEntry != NULL ) {

      errorLogEntry->ErrorCode = SpecificIOStatus;
      errorLogEntry->SequenceNumber = SequenceNumber;
      errorLogEntry->MajorFunctionCode = MajorFunctionCode;
      errorLogEntry->RetryCount = RetryCount;
      errorLogEntry->UniqueErrorValue = UniqueErrorValue;
      errorLogEntry->FinalStatus = FinalStatus;
      errorLogEntry->DumpDataSize = dumpToAllocate;
         ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

      ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

      if (LengthOfInsert1) {

         errorLogEntry->NumberOfStrings = 1;
         errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
                                                (PUCHAR)errorLogEntry);
         RtlCopyMemory(
                      ptrToFirstInsert,
                      Insert1,
                      LengthOfInsert1
                      );

         if (LengthOfInsert2) {

            errorLogEntry->NumberOfStrings = 2;
            RtlCopyMemory(
                         ptrToSecondInsert,
                         Insert2,
                         LengthOfInsert2
                         );

         }

      }

      IoWriteErrorLogEntry(errorLogEntry);

   }

   DbgDump(DBG_ERR, ("<LogError\n"));
   return;
}


#if defined(DBG)
PCHAR
PnPMinorFunctionString (
   UCHAR MinorFunction
   )
{
    switch (MinorFunction) {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        default:
            return ((PCHAR)("unknown IRP_MN_ 0x%x\n", MinorFunction));
    }
}
#endif

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\comport.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    COMPORT.C

Abstract:

   Most of this code was liberated from posusb.sys

Author:

    Jeff Midkiff (jeffmi)     08-24-99

-- */

#include "wceusbsh.h"

void NumToDecString(PWCHAR String, USHORT Number, USHORT stringLen);
LONG MyLog(ULONG base, ULONG num);
PVOID MemDup(PVOID dataPtr, ULONG length);
LONG WStrNCmpI(PWCHAR s1, PWCHAR s2, ULONG n);
ULONG LAtoD(PWCHAR string);


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWCE0, GetFreeComPortNumber)
#pragma alloc_text(PAGEWCE0, ReleaseCOMPort)
#pragma alloc_text(PAGEWCE0, DoSerialPortNaming)
#pragma alloc_text(PAGEWCE0, UndoSerialPortNaming)
#pragma alloc_text(PAGEWCE0, NumToDecString)
#pragma alloc_text(PAGEWCE0, MyLog)
#pragma alloc_text(PAGEWCE0, MemDup)
#pragma alloc_text(PAGEWCE0, WStrNCmpI)
#pragma alloc_text(PAGEWCE0, LAtoD)
#endif


LONG 
GetFreeComPortNumber(
   VOID
   )
/*++

Routine Description:

    Find the index of the next unused serial COM port name in the system
    (e.g. COM3, COM4, etc).

Arguments:


Return Value:

    Return COM port number or -1 if unsuccessful.

--*/

{
    LONG comNumber = -1;

    DbgDump(DBG_INIT, (">GetFreeComPortNumber\n"));
    PAGED_CODE();
    
    if (g_isWin9x){
        /*
         *  Windows 98
         *      Find the first unused name under Hardware\DeviceMap\SerialComm.
         *
         *      BUGBUG:
         *          This algorithm does not find all the COM ports reserved
         *          by modems.  May want to port tomgreen's AllocateCommPort
         *          function from \faulty\Wdm10\usb\driver\ccport\utils.c
         */
        HANDLE hKey;
        UNICODE_STRING keyName;
        NTSTATUS status;
        OBJECT_ATTRIBUTES objectAttributes;

        RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\Hardware\\DeviceMap\\SerialComm");
        
       InitializeObjectAttributes( &objectAttributes,
                                    &keyName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,               
                                    (PSECURITY_DESCRIPTOR)NULL);

        status = ZwOpenKey(&hKey, KEY_QUERY_VALUE | KEY_SET_VALUE, &objectAttributes);
        
       if (NT_SUCCESS(status)){
            #define MAX_COMPORT_NAME_LEN (sizeof("COMxxxx")-1)
            UCHAR keyValueBytes[sizeof(KEY_VALUE_FULL_INFORMATION)+(MAX_COMPORT_NAME_LEN+1)*sizeof(WCHAR)+sizeof(ULONG)];
            PKEY_VALUE_FULL_INFORMATION keyValueInfo = (PKEY_VALUE_FULL_INFORMATION)keyValueBytes;
            ULONG i, actualLen;
            ULONG keyIndex = 0;

            /*
             *  This bitmask represents the used COM ports.
             *  Bit i set indicates com port i+1 is reserved.
             *  Initialize with COM1 and COM2 reserved.
             *
             *  BUGBUG - only works for up to 32 ports.
             */
            ULONG comNameMask = 3;

            do {
                status = ZwEnumerateValueKey(
                            hKey,
                            keyIndex++,
                            KeyValueFullInformation,
                            keyValueInfo,
                            sizeof(keyValueBytes),
                            &actualLen); 
                if (NT_SUCCESS(status)){
                    if (keyValueInfo->Type == REG_SZ){
                        PWCHAR valuePtr = (PWCHAR)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset);
                        if (!WStrNCmpI(valuePtr, L"COM", 3)){
                            /*
                             *  valuePtr+3 points the index portion of the COMx string,
                             *  but we can't call LAtoD on it because it is
                             *  NOT NULL-TERMINATED.
                             *  So copy the index into our own buffer, 
                             *  null-terminate that, 
                             *  and call LAtoD to get the numerical index.
                             */
                            WCHAR comPortIndexString[4+1];
                            ULONG thisComNumber;
                            for (i = 0; (i < 4) && (i < keyValueInfo->DataLength/sizeof(WCHAR)); i++){
                                comPortIndexString[i] = valuePtr[3+i];
                            }
                            comPortIndexString[i] = UNICODE_NULL;

                            thisComNumber = LAtoD(comPortIndexString);
                            if (thisComNumber == 0){
                                ASSERT(thisComNumber != 0);
                            }
                            else if (thisComNumber <= sizeof(ULONG)*8){
                                comNameMask |= 1 << (thisComNumber-1);
                            }
                            else {
                                ASSERT(thisComNumber <= sizeof(ULONG)*8);
                            }
                        }
                    }
                }
            } while (NT_SUCCESS(status));

            /*
             *  First clear bit in comNameMask represents the first available COM name.
             */
            for (i = 0; i < sizeof(ULONG)*8; i++){
                if (!(comNameMask & (1 << i))){
                    WCHAR comName[] = L"COMxxxx";
                    ULONG comNumLen;

                    /*
                     *  Save the COM port number that we're returning.
                     */
                    comNumber = i+1;
                    DbgDump(DBG_INIT, ("GetFreeComPortNumber: got free COM port #%d\n", comNumber));

                    /*
                     *  Write a temporary COMx=COMx holder value to the SERIALCOMM key
                     *  so that no other PDOs get this COM port number.
                     *  This value will get overwritten by <symbolicLinkName=COMx> when the pdo is started.
                     */
                    comNumLen = MyLog(10, comNumber)+1;
                    ASSERT(comNumLen <= 4);
                    NumToDecString(comName+3, (USHORT)comNumber, (USHORT)comNumLen);
                    comName[3+comNumLen] = UNICODE_NULL;
                       
                    status = RtlWriteRegistryValue( RTL_REGISTRY_DEVICEMAP, 
                                                    L"SERIALCOMM",
                                                    comName, 
                                                    REG_SZ,
                                                    comName,
                                                    (3 + comNumLen + 1) * sizeof(WCHAR));

                    ASSERT(NT_SUCCESS(status));

                    break;
                }
            }
        }
        else {
            DbgDump(DBG_ERR, ("GetFreeComPortNumber: ZwOpenKey failed with status 0x%x\n", status));
        }
    }
    else {
    
        /*
         *  Windows NT.  
         *      Use the COM Name Arbiter bitmap.
         */

        HANDLE hKey;
        OBJECT_ATTRIBUTES objectAttributes;
        UNICODE_STRING keyName;
        NTSTATUS status;


        RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter");
        
       InitializeObjectAttributes( &objectAttributes,
                                    &keyName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,               
                                    (PSECURITY_DESCRIPTOR)NULL);

        status = ZwOpenKey( &hKey,
                            KEY_QUERY_VALUE | KEY_SET_VALUE,
                            &objectAttributes);

        if (NT_SUCCESS(status)){
            UNICODE_STRING valueName;
            PVOID rawData;
            ULONG dataSize;

            RtlInitUnicodeString(&valueName, L"ComDB");

            ASSERT(hKey);

            dataSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION);

            /*
             *  Allocate one extra byte in case we have to add a byte to ComDB
             */
            rawData = ExAllocatePool(NonPagedPool, dataSize+1);

            if (rawData){
                status = ZwQueryValueKey(   hKey, 
                                            &valueName, 
                                            KeyValuePartialInformation,
                                            rawData,
                                            dataSize,
                                            &dataSize);
                if (status == STATUS_BUFFER_OVERFLOW){
                    ExFreePool(rawData);
                    ASSERT(dataSize > FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                    /*
                     *  Allocate one extra byte in case we have to add a byte to ComDB
                     */
                    rawData = ExAllocatePool(NonPagedPool, dataSize+1);
                    if (rawData){
                        status = ZwQueryValueKey(   hKey, 
                                                    &valueName, 
                                                    KeyValuePartialInformation,
                                                    rawData,
                                                    dataSize,
                                                    &dataSize);
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (NT_SUCCESS(status)){
                    PKEY_VALUE_PARTIAL_INFORMATION keyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)rawData;
                    ULONG b, i;
                    BOOLEAN done = FALSE;

                    ASSERT(dataSize >= FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
                    
                    ASSERT(keyPartialInfo->Type == REG_BINARY);

                    /*
                     *  The ComDB value is just a bit mask where bit n set indicates
                     *  that COM port # n+1 is taken.
                     *  Get the index of the first unset bit; starting with bit 2 (COM3).
                     */
                    for (b = 0; (b < dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) && !done; b++){
                    
                        for (i = (b == 0) ? 2 : 0; (i < 8) && !done; i++){
                            if (keyPartialInfo->Data[b] & (1 << i)){
                                /*
                                 *  This COM port (#8*b+i+1) is taken, go to the next one.
                                 */
                            }
                            else {
                                /*
                                 *  Found a free COM port.  
                                 *  Write the value back with the new bit set.
                                 *  Only write back the number of bytes we read earlier.
                                 *  Only use this COM port if the write succeeds.
                                 *
                                 *  Note:   careful with the size of the KEY_VALUE_PARTIAL_INFORMATION
                                 *          struct.  Its real size is 0x0D bytes, 
                                 *          but the compiler aligns it to 0x10 bytes.
                                 *          So use FIELD_OFFSET, not sizeof, to determine
                                 *          how many bytes to write.
                                 */
                                keyPartialInfo->Data[b] |= (1 << i);
                                status = ZwSetValueKey( hKey, 
                                                        &valueName,
                                                        0,
                                                        REG_BINARY,
                                                        (PVOID)keyPartialInfo->Data, 
                                                        dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
                                if (NT_SUCCESS(status)){
                                    comNumber = 8*b + i + 1;
                                    DbgDump(DBG_INIT, ("GetFreeComPortNumber: got free COM port #0x%x\n", comNumber));
                                }
                                else {
                                    DbgDump(DBG_ERR, ("GetFreeComPortNumber: ZwSetValueKey failed with 0x%x\n", status));
                                }

                                done = TRUE;
                            }
                        }
                    }

                    if ((b == dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) && !done){
                        /*
                         *  No more available bits in ComDB, so add a byte.
                         */
                        ASSERT(comNumber == -1);
                        ASSERT(b > 0);
                        DbgDump(DBG_WRN, ("ComDB overflow -- adding new byte"));

                        keyPartialInfo->Data[b] = 1;
                        dataSize++;

                        status = ZwSetValueKey( hKey, 
                                                &valueName,
                                                0,
                                                REG_BINARY,
                                                (PVOID)keyPartialInfo->Data, 
                                                dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
                        if (NT_SUCCESS(status)){
                            comNumber = 8*b + 1;
                            DbgDump(DBG_INIT, ("GetFreeComPortNumber: got free COM port #0x%x.", comNumber));
                        }
                        else {
                            DbgDump(DBG_ERR, ("GetFreeComPortNumber: ZwSetValueKey #2 failed with 0x%x.", status));
                        }
                    }

                    ASSERT(comNumber != -1);
                }
                else {
                    DbgDump(DBG_ERR, ("GetFreeComPortNumber: ZwQueryValueKey failed with 0x%x.", status));
                }

                /*
                 *  Check that we didn't fail the second allocation before freeing this buffer.
                 */
                if (rawData){
                    ExFreePool(rawData);
                }
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            status = ZwClose(hKey);
            ASSERT(NT_SUCCESS(status));
        }
        else {
            DbgDump(DBG_ERR, ("GetFreeComPortNumber: ZwOpenKey failed with 0x%x.", status));
        }

    }

    ASSERT(comNumber != -1);

   DbgDump(DBG_INIT, ("<GetFreeComPortNumber\n"));
    
   return comNumber;
}


//
// the only time we want this is when we  uninstall...
//
VOID 
ReleaseCOMPort( 
   LONG comPortNumber
   )
{
    DbgDump(DBG_INIT, (">ReleaseCOMPort: %d\n", comPortNumber));
    PAGED_CODE();
   
    if (g_isWin9x){
        /*
         *  We punt on this for Win9x.  
         *  That's ok since the SERIALCOMM keys are dynamically-generated at each boot,
         *  so if start fails a COM port number will just be unavailable until the next boot.
         */
        DbgDump(DBG_WRN, ("ReleaseCOMPort: not implemented for Win9x\n")); // BUGBUG
    }
    else {

        HANDLE hKey = NULL;
        OBJECT_ATTRIBUTES objectAttributes;
        UNICODE_STRING keyName;
        NTSTATUS status;

        if ( !(comPortNumber > 0)) {
            DbgDump(DBG_ERR, ("ReleaseCOMPort - INVALID_PARAMETER: %d\n", comPortNumber )); // BUGBUG
            return;
        }

        RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter");
        InitializeObjectAttributes( &objectAttributes,
                                    &keyName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,               
                                    (PSECURITY_DESCRIPTOR)NULL);

        status = ZwOpenKey(&hKey, KEY_QUERY_VALUE | KEY_SET_VALUE, &objectAttributes);
        if (NT_SUCCESS(status)){
            UNICODE_STRING valueName;
            PVOID rawData;
            ULONG dataSize;

            RtlInitUnicodeString(&valueName, L"ComDB");

            ASSERT(hKey);

            dataSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION);
            rawData = ExAllocatePool(NonPagedPool, dataSize);

            if (rawData){
                status = ZwQueryValueKey(   hKey, 
                                            &valueName, 
                                            KeyValuePartialInformation,
                                            rawData,
                                            dataSize,
                                            &dataSize);
                if (status == STATUS_BUFFER_OVERFLOW){
                    ExFreePool(rawData);
                    ASSERT(dataSize > FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                    rawData = ExAllocatePool(NonPagedPool, dataSize);
                    if (rawData){
                        status = ZwQueryValueKey(   hKey, 
                                                    &valueName, 
                                                    KeyValuePartialInformation,
                                                    rawData,
                                                    dataSize,
                                                    &dataSize);
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (NT_SUCCESS(status)){
                    PKEY_VALUE_PARTIAL_INFORMATION keyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)rawData;

                    ASSERT(dataSize > FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                    ASSERT(keyPartialInfo->Type == REG_BINARY);

                    /*
                     *  The ComDB value is just a bit mask where bit n set indicates
                     *  that COM port # n+1 is taken.
                     *  Get the index of the first unset bit; starting with bit 2 (COM3).
                     *
                     *  Note:   careful with the size of the KEY_VALUE_PARTIAL_INFORMATION
                     *          struct.  Its real size is 0x0D bytes, 
                     *          but the compiler aligns it to 0x10 bytes.
                     *          So use FIELD_OFFSET, not sizeof, to determine
                     *          how many bytes to write.
                     */
                    ASSERT(comPortNumber >= 3);
                    if ((comPortNumber > 0) && (comPortNumber <= (LONG)(dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data))*8)){
                        //ASSERT(keyPartialInfo->Data[(comPortNumber-1)/8] & (1 << ((comPortNumber-1) & 7)));
                        keyPartialInfo->Data[(comPortNumber-1)/8] &= ~(1 << ((comPortNumber-1) & 7));
                        status = ZwSetValueKey( hKey, 
                                                &valueName,
                                                0,
                                                REG_BINARY,
                                                (PVOID)keyPartialInfo->Data, 
                                                dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
                        if (NT_SUCCESS(status)){
                            DbgDump(DBG_INIT, ("ReleaseCOMPort: released COM port # 0x%x\n", comPortNumber));
                        }
                        else {
                            DbgDump(DBG_ERR, ("ReleaseCOMPort: ZwSetValueKey failed with 0x%x\n", status));
                        }
                    }
                    else {
                        ASSERT((comPortNumber > 0) && (comPortNumber <= (LONG)(dataSize-FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data))*8));
                    }
                }
                else {
                    DbgDump(DBG_ERR, ("ReleaseCOMPort: ZwQueryValueKey failed with 0x%x\n", status));
                }

                /*
                 *  Check that we didn't fail the second allocation before freeing this buffer.
                 */
                if (rawData){
                    ExFreePool(rawData);
                }
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            status = ZwClose(hKey);
            ASSERT(NT_SUCCESS(status));
        }
        else {
            DbgDump(DBG_ERR, ("ReleaseCOMPort: ZwOpenKey failed with 0x%x\n", status));
        }
    }
    
    DbgDump(DBG_INIT, ("<ReleaseCOMPort\n"));
    
    return;
}


//
// Note: this is NT specific.
// Win98 is entirely different.
//
NTSTATUS
DoSerialPortNaming(
    IN PDEVICE_EXTENSION PDevExt,
    IN LONG  ComPortNumber
    )
{
   NTSTATUS status;
    PWCHAR pwcComPortName=NULL;
    static WCHAR comNamePrefix[] = L"\\DosDevices\\COM";
    WCHAR buf[sizeof(comNamePrefix)/sizeof(WCHAR) + 4];
    LONG numLen = MyLog(10, ComPortNumber)+1;

   DbgDump(DBG_INIT, (">DoSerialPortNaming %d\n", ComPortNumber));
   PAGED_CODE();

   ASSERT(PDevExt);
   ASSERT((numLen > 0) && (numLen <= 4));
   ASSERT_SERIAL_PORT(PDevExt->SerialPort);

    RtlCopyMemory(buf, comNamePrefix, sizeof(comNamePrefix));

    NumToDecString( buf+sizeof(comNamePrefix)/sizeof(WCHAR)-1, 
                        (USHORT)ComPortNumber,
                        (USHORT)numLen );

    buf[sizeof(comNamePrefix)/sizeof(WCHAR) - 1 + numLen] = UNICODE_NULL;

    pwcComPortName = MemDup(buf, sizeof(buf));

    if (pwcComPortName) {
      //
      // create symbolic link for the SerialPort interface
      // 
        RtlInitUnicodeString( &PDevExt->SerialPort.Com.SerialPortName, pwcComPortName);

      ASSERT( PDevExt->DeviceName.Buffer );
      ASSERT( PDevExt->SerialPort.Com.SerialPortName.Buffer );
        status = IoCreateSymbolicLink( &PDevExt->SerialPort.Com.SerialPortName, &PDevExt->DeviceName );

        if (NT_SUCCESS(status)) {
         //
         // let the system know there is another SERIALCOMM entry under HKLM\DEVICEMAP\SERIALCOMM
         //
            UNICODE_STRING comPortSuffix;

         PDevExt->SerialPort.Com.SerialSymbolicLink = TRUE;

            /*
             *  Create the '\Device\WCEUSBSI000x = COMx' entry 
             */
            RtlInitUnicodeString(&comPortSuffix, PDevExt->SerialPort.Com.SerialPortName.Buffer+(sizeof(L"\\DosDevices\\")-sizeof(WCHAR))/sizeof(WCHAR));
         
         //ASSERT( PDevExt->SerialPort.Com.SerialCOMMname.Buffer );
         status = RtlWriteRegistryValue( RTL_REGISTRY_DEVICEMAP, 
                                         L"SERIALCOMM",
                                         PDevExt->DeviceName.Buffer,
                                         REG_SZ,
                                         comPortSuffix.Buffer,
                                         comPortSuffix.Length + sizeof(WCHAR) );

         if (NT_SUCCESS(status)){

                PDevExt->SerialPort.Com.PortNumber = ComPortNumber;

                if (g_isWin9x){
                    NTSTATUS tmpStatus;

                    /*
                     *  Delete the temporary 'COMx=COMx' holder value we created earlier.
                     */
                    tmpStatus = RtlDeleteRegistryValue( RTL_REGISTRY_DEVICEMAP, 
                                                        L"SERIALCOMM",
                                                        comPortSuffix.Buffer);
                    //ASSERT(NT_SUCCESS(tmpStatus));
#if DBG
                    if ( !NT_SUCCESS(tmpStatus) ) {
                        DbgDump(DBG_WRN, ("RtlDeleteRegistryValue error: 0x%x\n", tmpStatus));
                    }
#endif
                }
         
         } else {

            DbgDump(DBG_ERR, ("RtlWriteRegistryValue error: 0x%x\n", status));

            LogError( NULL,
                   PDevExt->DeviceObject,
                   0, 0, 0, 
                   ERR_SERIALCOMM,
                   status, 
                   SERIAL_REGISTRY_WRITE_FAILED,
                   PDevExt->DeviceName.Length + sizeof(WCHAR),
                   PDevExt->DeviceName.Buffer,
                   0,
                   NULL
                   );

         }

        } else {
         DbgDump(DBG_ERR, ("IoCreateSymbolicLink error: 0x%x\n", status));

         LogError( NULL,
                   PDevExt->DeviceObject,
                   0, 0, 0, 
                   ERR_COMM_SYMLINK,
                   status, 
                   SERIAL_NO_SYMLINK_CREATED,
                   PDevExt->SerialPort.Com.SerialPortName.Length + sizeof(WCHAR),
                   PDevExt->SerialPort.Com.SerialPortName.Buffer,
                   PDevExt->DeviceName.Length + sizeof(WCHAR),
                   PDevExt->DeviceName.Buffer
                   );

         TEST_TRAP();

      }
    
   } else {
      status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("DoSerialPortNaming error: 0x%x\n", status));
      LogError( NULL,
                PDevExt->DeviceObject,
                0, 0, 0, 
                ERR_COMM_SYMLINK,
                status, 
                SERIAL_INSUFFICIENT_RESOURCES,
                0, NULL, 0, NULL );

    }

   DbgDump(DBG_INIT, ("<DoSerialPortNaming (0x%x)\n", status));
    
   return status;
}



VOID
UndoSerialPortNaming(
   IN PDEVICE_EXTENSION PDevExt
   )
{
   DbgDump(DBG_INIT, (">UndoSerialPortNaming\n"));
   PAGED_CODE();

   ASSERT(PDevExt);
   ASSERT_SERIAL_PORT(PDevExt->SerialPort);

   if (!g_ExposeComPort) {
       DbgDump(DBG_INIT, ("!g_ExposeComPort\n"));
       return;
   }

   // remove our entry from ComDB
   ReleaseCOMPort( PDevExt->SerialPort.Com.PortNumber );

   if (PDevExt->SerialPort.Com.SerialPortName.Buffer && PDevExt->SerialPort.Com.SerialSymbolicLink) {
      IoDeleteSymbolicLink(&PDevExt->SerialPort.Com.SerialPortName);
   }

   if (PDevExt->SerialPort.Com.SerialPortName.Buffer != NULL) {
      ExFreePool(PDevExt->SerialPort.Com.SerialPortName.Buffer);
      RtlInitUnicodeString(&PDevExt->SerialPort.Com.SerialPortName, NULL);
   }

   if (PDevExt->SerialPort.Com.SerialCOMMname.Buffer != NULL) {
      ExFreePool(PDevExt->SerialPort.Com.SerialCOMMname.Buffer);
      RtlInitUnicodeString(&PDevExt->SerialPort.Com.SerialCOMMname, NULL);
   }

   if (PDevExt->DeviceName.Buffer != NULL) {
      RtlDeleteRegistryValue( RTL_REGISTRY_DEVICEMAP, 
                              SERIAL_DEVICE_MAP,
                              PDevExt->DeviceName.Buffer);
      
      ExFreePool(PDevExt->DeviceName.Buffer);
      RtlInitUnicodeString(&PDevExt->DeviceName, NULL);
   }

   DbgDump(DBG_INIT, ("<UndoSerialPortNaming\n"));
}


void NumToDecString(PWCHAR String, USHORT Number, USHORT stringLen)
{
    const static WCHAR map[] = L"0123456789";
    LONG         i      = 0;

    PAGED_CODE();
    ASSERT(stringLen);

    for (i = stringLen-1; i >= 0; i--) {
        String[i] = map[Number % 10];
        Number /= 10;
    }
}


LONG MyLog(ULONG base, ULONG num)
{
    LONG result;
    ASSERT(num);
    
    PAGED_CODE();
    
    for (result = -1; num; result++){
        num /= base;
    }

    return result;
}


PVOID MemDup(PVOID dataPtr, ULONG length)
{
    PVOID newPtr;

    PAGED_CODE();

    newPtr = (PVOID)ExAllocatePool(NonPagedPool, length); // BUGBUG allow paged
    if (newPtr){
        RtlCopyMemory(newPtr, dataPtr, length);
    }
    return newPtr;
}


LONG WStrNCmpI(PWCHAR s1, PWCHAR s2, ULONG n)
{
    ULONG result;
    
    PAGED_CODE();
    
    while (n && *s1 && *s2 && ((*s1|0x20) == (*s2|0x20))){
        s1++, s2++;
        n--;
    }

    if (n){
        result = ((*s1|0x20) > (*s2|0x20)) ? 1 : ((*s1|0x20) < (*s2|0x20)) ? -1 : 0;
    }
    else {
        result = 0;
    }

    return result;
}


ULONG LAtoD(PWCHAR string)
/*++

Routine Description:

      Convert a decimal string (without the '0x' prefix) to a ULONG.

Arguments:

    string - null-terminated wide-char decimal-digit string 
                

Return Value:

    ULONG value

--*/
{
    ULONG i, result = 0;

    PAGED_CODE();

    for (i = 0; string[i]; i++){
        if ((string[i] >= L'0') && (string[i] <= L'9')){
            result *= 10;
            result += (string[i] - L'0');
        }
        else {
            ASSERT(0);
            break;
        }
    }

    return result;
}


#if 0
VOID
NumToHexString(
   PWCHAR String, 
   USHORT Number, 
   USHORT stringLen
   )
{
    const static WCHAR map[] = L"0123456789ABCDEF";
    LONG         i      = 0;

    PAGED_CODE();
    ASSERT(stringLen);

    for (i = stringLen-1; i >= 0; i--) {
        String[i] = map[Number & 0x0F];
        Number >>= 4;
    }
}


LONG 
GetComPort(
   PDEVICE_OBJECT PDevObj,
   ULONG ComInterfaceIndex
   )
/*++

Routine Description:

    Get the serial COM port index for a serial interface we're about to create.
    If this is the first plug-in, call GetFreeComPortNumber to reserve a new
    static COM port for this device and store it in our software key.
    If this is not the first plug-in, it should be sitting in the registry.

   ComInterfaceIndex - is our zero-based device interface index, 0000, 0001, etc.

Arguments:


Return Value:

    Return COM port number or -1 if unsuccessful.

--*/
{
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
    LONG comNumber = -1;
    NTSTATUS status;
    HANDLE hRegDevice;
    
    DbgDump(DBG_INIT, (">GetComPort\n"));
    PAGED_CODE();

    status = IoOpenDeviceRegistryKey( pDevExt->PDO, 
                                      /*PLUGPLAY_REGKEY_DEVICE,*/ PLUGPLAY_REGKEY_DRIVER, 
                                      KEY_READ, 
                                      &hRegDevice);

    if (NT_SUCCESS(status)){
        UNICODE_STRING keyName;
        PKEY_VALUE_FULL_INFORMATION keyValueInfo;
        ULONG keyValueTotalSize, actualLength;
        //
        // PLUGPLAY_REGKEY_DEVICE is under HKLM\System\CCS\Enum\USB\ROOT_HUB\4&574193&0
        // PLUGPLAY_REGKEY_DRIVER is under HKLM\System\CCS\Class\{Your_GUID}\000x
        //
        WCHAR interfaceKeyName[] = L"COMPortForInterfaceXXXX";

        NumToHexString( interfaceKeyName+sizeof(interfaceKeyName)/sizeof(WCHAR)-1-4, 
                        (USHORT)ComInterfaceIndex, 
                        4);

        RtlInitUnicodeString(&keyName, interfaceKeyName); 
        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) +
                            keyName.Length*sizeof(WCHAR) +
                            sizeof(ULONG);

        keyValueInfo = ExAllocatePool(PagedPool, keyValueTotalSize);
        
        if (keyValueInfo){
            status = ZwQueryValueKey( hRegDevice,
                                      &keyName,
                                      KeyValueFullInformation,
                                      keyValueInfo,
                                      keyValueTotalSize,
                                      &actualLength); 

            if (NT_SUCCESS(status)){

                ASSERT(keyValueInfo->Type == REG_DWORD);
                ASSERT(keyValueInfo->DataLength == sizeof(ULONG));
                                
                comNumber = (LONG)*((PULONG)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset));
                DbgDump(DBG_INIT, ("GetComPort: read COM port# 0x%x for interface 0x%x from registry\n", (ULONG)comNumber, ComInterfaceIndex));
            }
            else {

                /*
                 *  No COM port number recorded in registry.
                 *  Allocate a new static COM port from the COM name arbiter
                 *  and record it in our software key for the next PnP.
                 */
                comNumber = GetFreeComPortNumber();
                if (comNumber == -1){
                    DbgDump(DBG_ERR, ("GetComPort: GetFreeComPortNumber failed\n"));
                }
                else {
                    status = ZwSetValueKey( hRegDevice,
                                            &keyName,
                                            0,
                                            REG_DWORD,
                                            &comNumber,
                                            sizeof(ULONG));
                    if (!NT_SUCCESS(status)){
                        DbgDump(DBG_ERR, ("GetComPort: ZwSetValueKey failed with status 0x%x\n", status));
                    }
                }
            }

            ExFreePool(keyValueInfo);
        }
        else {
            ASSERT(keyValueInfo);
        }

        ZwClose(hRegDevice);
    }
    else {
        DbgDump(DBG_ERR, ("GetComPort: IoOpenDeviceRegistryKey failed with 0x%x\n", status));
    }

   DbgDump(DBG_INIT, ("<GetComPort %d\n", comNumber));
   
   return comNumber;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\debug.h ===
// Copyright (c) 1999-2000 Microsoft Corporation
#ifndef _DEBUG_H_
#define _DEBUG_H_


extern ULONG DebugLevel;


//
// Debugging Macros
//
#define DBG_OFF          ((ULONG)0x00000000)
#define DBG_ERR          ((ULONG)0x00000001)
#define DBG_WRN          ((ULONG)0x00000002)
#define DBG_INIT         ((ULONG)0x00000004)
#define DBG_PNP          ((ULONG)0x00000008)
#define DBG_READ         ((ULONG)0x00000010)
#define DBG_WRITE        ((ULONG)0x00000020)
#define DBG_DUMP_READS   ((ULONG)0x00000040)
#define DBG_DUMP_WRITES  ((ULONG)0x00000080)
#define DBG_READ_LENGTH  ((ULONG)0x00000100)
#define DBG_WRITE_LENGTH ((ULONG)0x00000200)
#define DBG_USB          ((ULONG)0x00000400)
#define DBG_SERIAL       ((ULONG)0x00000800)
#define DBG_TIME         ((ULONG)0x00001000)
#define DBG_EVENTS       ((ULONG)0x00002000)
#define DBG_CANCEL       ((ULONG)0x00004000)
#define DBG_IRP          ((ULONG)0x00008000)
#define DBG_INT          ((ULONG)0x00010000)
#define DBG_DUMP_INT     ((ULONG)0x00020000)
#define DBG_WORK_ITEMS   ((ULONG)0x00040000)
// ...
#define DBG_LOCKS        ((ULONG)0x00100000)
#define DBG_TRACE        ((ULONG)0x00200000)
// ...
#define DBG_PERF         ((ULONG)0x80000000)
// ...
#define DBG_ALL          ((ULONG)0xFFFFFFFF)


#if DBG

#ifndef DRV_NAME
#define DRV_NAME "WCEUSBSH"
#endif

#define DbgDump(_LEVEL, _STRING) \
{                                \
   ULONG level = _LEVEL;         \
   if ( DebugLevel & level ) {   \
         DbgPrint("%s(%d): ", DRV_NAME, KeGetCurrentIrql() ); \
         DbgPrint _STRING; \
   }  \
}

//
// these should be removed in the code if you can 'g' past these successfully
//
#define TEST_TRAP()  \
{ \
   DbgPrint( "%s: Code Coverage Trap: %s %d\nEnter 'g' to continue.\n", DRV_NAME, __FILE__, __LINE__); \
   DbgBreakPoint(); \
}

#else // !DBG

#define DbgDump(LEVEL,STRING)
#define TEST_TRAP() 

#endif // DBG


#endif //  _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\int.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

   int.c

Abstract:

   Interrupt Pipe handler
   Based on read.c

Author:

    Jeff Midkiff (jeffmi)     08-20-99

--*/

#include "wceusbsh.h"

VOID
RestartInterruptWorkItem(
   IN PWCE_WORK_ITEM PWorkItem
   );

NTSTATUS
UsbInterruptComplete(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp,
   IN PVOID Context
   );


//
// called with control lock held
//
#define START_ANOTHER_INTERRUPT( _PDevExt, _AcquireLock ) \
   ( (IRP_STATE_COMPLETE == _PDevExt->IntState) && \
     CanAcceptIoRequests(_PDevExt->DeviceObject, _AcquireLock, TRUE) \
   )


//
// This function allocates a single Irp & Urb to be continously
// submitted to USBD for INT pipe notifications.
// It is called from StartDevice.
// The Irp & Urb are finally freed in StopDevice.
//
NTSTATUS
AllocUsbInterrupt(
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_SUCCESS;
   PIRP     pIrp;
   PURB     pUrb;
   PAGED_CODE();

   DbgDump(DBG_INT, (">AllocUsbInterrupt(%p)\n", PDevExt->DeviceObject));

   ASSERT( PDevExt );

   if ( !PDevExt->IntPipe.hPipe ) {

      status = STATUS_UNSUCCESSFUL;
      DbgDump(DBG_ERR, ("AllocUsbInterrupt: 0x%x\n", status ));

   } else {

      ASSERT( NULL == PDevExt->IntIrp );

      pIrp = IoAllocateIrp( (CCHAR)(PDevExt->NextDevice->StackSize + 1), FALSE);

      if (pIrp) {

         //
         // fixup irp so we can pass to ourself,
         // and to USBD
         //
         FIXUP_RAW_IRP( pIrp, PDevExt->DeviceObject );

         //
         // alloc the int pipe's Urb
         //
         pUrb = ExAllocateFromNPagedLookasideList( &PDevExt->BulkTransferUrbPool );

         if (pUrb) {

            // save these to be freed when not needed
            SetPVoidLocked( &PDevExt->IntIrp,
                            pIrp,
                            &PDevExt->ControlLock);

            SetPVoidLocked( &PDevExt->IntUrb,
                            pUrb,
                            &PDevExt->ControlLock);

            DbgDump(DBG_INT, ("IntIrp: %p\t IntUrb: %p\n", PDevExt->IntIrp, PDevExt->IntUrb));

            InterlockedExchange(&PDevExt->IntState, IRP_STATE_COMPLETE);

            KeInitializeEvent( &PDevExt->IntCancelEvent,
                               SynchronizationEvent,
                               FALSE);

         } else {
            //
            // this is a fatal err since we can't post int requests to USBD
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
            DbgDump(DBG_ERR, ("AllocUsbInterrupt: 0x%x\n", status ));
            TEST_TRAP();

         }

      } else {
         //
         // this is a fatal err since we can't post int requests to USBD
         //
         status = STATUS_INSUFFICIENT_RESOURCES;
         DbgDump(DBG_ERR, ("AllocUsbInterrupt: 0x%x\n", status ));
         TEST_TRAP();
      }
   }

   DbgDump(DBG_INT, ("<AllocUsbInterrupt 0x%x\n", status ));

   return status;
}


//
// This routine takes the device's current IntIrp and submits it to USBD.
// When the Irp is completed by USBD our completion routine fires.
//
// Return: successful return value is STATUS_SUCCESS, or
//         STATUS_PENDING - which means the I/O is pending in the USB stack.
//
NTSTATUS
UsbInterruptRead(
   IN PDEVICE_EXTENSION PDevExt
   )
{
   PIO_STACK_LOCATION pNextStack;
   NTSTATUS status = STATUS_SUCCESS;
   KIRQL irql;

   DbgDump(DBG_INT, (">UsbInterruptRead(%p)\n", PDevExt->DeviceObject));


   do {
      //
      // check our USB INT state
      //
      KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

      if ( !PDevExt->IntPipe.hPipe || !PDevExt->IntIrp ||
           !PDevExt->IntUrb   || !PDevExt->IntBuff ) {
         status = STATUS_UNSUCCESSFUL;
         DbgDump(DBG_ERR, ("UsbInterruptRead: 0x%x\n", status ));
         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
         break;
      }

      if ( !CanAcceptIoRequests(PDevExt->DeviceObject, FALSE, TRUE) ) {
         status = STATUS_DELETE_PENDING;
         DbgDump(DBG_ERR, ("UsbInterruptRead: 0x%x\n", status ));
         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
         break;
      }

#if DBG
      if (IRP_STATE_CANCELLED == PDevExt->IntState)
         TEST_TRAP();
#endif

      //
      // we post our INT irp to USB if it has been completed (not cancelled),
      // and the device is accepting requests
      //
      if ( START_ANOTHER_INTERRUPT( PDevExt, FALSE ) ) {

          status = AcquireRemoveLock(&PDevExt->RemoveLock, PDevExt->IntIrp);
          if ( !NT_SUCCESS(status) ) {
             DbgDump(DBG_ERR, ("UsbInterruptRead: 0x%x\n", status ));
             KeReleaseSpinLock(&PDevExt->ControlLock, irql);
             break;
         }

         ASSERT( IRP_STATE_COMPLETE == PDevExt->IntState);

         InterlockedExchange(&PDevExt->IntState, IRP_STATE_PENDING);

         KeClearEvent( &PDevExt->PendingIntEvent );
         KeClearEvent( &PDevExt->IntCancelEvent );

         RecycleIrp( PDevExt->DeviceObject, PDevExt->IntIrp );

         UsbBuildTransferUrb( PDevExt->IntUrb,
                              PDevExt->IntBuff,
                              PDevExt->IntPipe.MaxPacketSize,
                              PDevExt->IntPipe.hPipe,
                              TRUE );

         //
         // set Irp up for a submit Urb IOCTL
         //
         IoCopyCurrentIrpStackLocationToNext(PDevExt->IntIrp);

         pNextStack = IoGetNextIrpStackLocation(PDevExt->IntIrp);
         pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
         pNextStack->Parameters.Others.Argument1 = PDevExt->IntUrb;
         pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

         //
         // completion routine will take care of updating buffer
         //
         IoSetCompletionRoutine( PDevExt->IntIrp,
                                 UsbInterruptComplete,
                                 NULL, //PDevExt,          // Context
                                 TRUE, TRUE, TRUE);

         InterlockedIncrement(&PDevExt->PendingIntCount);

         KeReleaseSpinLock( &PDevExt->ControlLock, irql );

         status = IoCallDriver(PDevExt->NextDevice, PDevExt->IntIrp );

         if ( (STATUS_SUCCESS != status) &&  (STATUS_PENDING != status)) {
            //
            // We can end up here after our completion routine runs
            // for an error condition i.e., when we have an
            // invalid parameter, or when user pulls the plug, etc.
            //
            DbgDump(DBG_ERR, ("UsbInterruptRead: 0x%x\n", status));
         }

      } else {
         //
         // we did not post an INT, but this is not an error condition
         //
         status = STATUS_SUCCESS;
         DbgDump(DBG_INT, ("!UsbInterruptRead RE: 0x%x\n", PDevExt->IntState ));

         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
      }


   } while (0);

   DbgDump(DBG_INT, ("<UsbInterruptRead 0x%x\n", status ));

   return status;
}


/*

This completion routine fires when USBD completes our IntIrp
Note: we allocated the Irp, and recycle it.
Always return STATUS_MORE_PROCESSING_REQUIRED to retain the Irp.
This routine runs at DPC_LEVEL.

Interrupt Endpoint:
This endpoint will be used to indicate the availability of IN data,
as well as to reflect the state of the device serial control lines :

D15..D3     Reserved
D2      DSR state  (1=Active, 0=Inactive)
D1      CTS state  (1=Active, 0=Inactive)
D0      Data Available  - (1=Host should read IN endpoint, 0=No data currently available)

*/
NTSTATUS
UsbInterruptComplete(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP Irp,
   IN PVOID Context)
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   ULONG             count;
   KIRQL             irql;
   PIRP              pCurrentMaskIrp = NULL;

   NTSTATUS    irpStatus;
   USBD_STATUS urbStatus;

   USHORT   usNewMSR;
   USHORT   usOldMSR;
   USHORT   usDeltaMSR;
   NTSTATUS workStatus;

   BOOLEAN bStartRead = FALSE;

   UNREFERENCED_PARAMETER( Irp );
   UNREFERENCED_PARAMETER( Context );

   ASSERT( pDevExt->IntIrp == Irp );
   ASSERT( pDevExt->IntBuff );

   DbgDump(DBG_INT, (">UsbInterruptComplete(%p)\n", PDevObj));

   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   //
   // Our INT state should be either pending or cancelled at this point.
   // If it pending then USB is completing the Irp normally.
   // If it is cancelled then our Cancel routine set it,
   // in which case USB can complete the irp normally or as cancelled
   // depending on where it was in processing. If the state is cancelled
   // then do NOT set to complete, else the Irp will
   // go back down to USB and you are hosed.
   //
   ASSERT( (IRP_STATE_PENDING == pDevExt->IntState)
           || (IRP_STATE_CANCELLED== pDevExt->IntState) );

   if (IRP_STATE_PENDING == pDevExt->IntState) {
      InterlockedExchange(&pDevExt->IntState, IRP_STATE_COMPLETE);
   }

   //
   // signal everyone if this is the last IRP
   //
   if ( 0 == InterlockedDecrement(&pDevExt->PendingIntCount) ) {

      // DbgDump(DBG_INT, ("PendingIntCount: 0\n"));

      // when we drop back to passive level they will get signalled
      KeSetEvent(&pDevExt->PendingIntEvent, IO_SERIAL_INCREMENT, FALSE);
   }

   //
   // get the completion info
   //
   count = pDevExt->IntUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;

   irpStatus = pDevExt->IntIrp->IoStatus.Status;
   DbgDump(DBG_INT, ("Irp->IoStatus.Status  0x%x\n", irpStatus));

   urbStatus = pDevExt->IntUrb->UrbHeader.Status;
   DbgDump(DBG_INT, ("Urb->UrbHeader.Status 0x%x\n", urbStatus ));

   switch (irpStatus) {

      case STATUS_SUCCESS: {

         ASSERT( USBD_STATUS_SUCCESS == urbStatus );

         //
         // clear pipe error count
         //
         InterlockedExchange( &pDevExt->IntDeviceErrors, 0);

#if DBG
         if (DebugLevel & DBG_DUMP_INT) {
            ULONG i;
            DbgDump(DBG_INT, ("IntBuff[%d]: ", count ));
            for (i=0; i < count; i++) {
               KdPrint( ("%02x ", pDevExt->IntBuff[i] ) );
            }
            KdPrint(("\n"));
         }
#endif

        //
        // Get Data Ready
        //
        // D0 - Data Available (1=Host should read IN endpoint, 0=No data currently available)
        //
        if ( pDevExt->IntBuff[0] & USB_COMM_DATA_READY_MASK ) {

           DbgDump(DBG_INT, ("Data Ready\n"));
           bStartRead = TRUE;

           // Note: we may be prematurely setting this bit since we have not
           // confirmed data reception, but need to get the user's read started.
           // Perhaps only set if not using the ring-buffer, since buffered reads are not bound to app's reads.
           pDevExt->SerialPort.HistoryMask |= SERIAL_EV_RXCHAR;
        }

        //
        // Get Modem Status Register
        //
        // D1       CTS state  (1=Active, 0=Inactive)
        // D2       DSR state  (1=Active, 0=Inactive)
        //
        usOldMSR = pDevExt->SerialPort.ModemStatus;

        usNewMSR = pDevExt->IntBuff[0] & USB_COMM_MODEM_STATUS_MASK;

        DbgDump(DBG_INT, ("USB_COMM State: 0x%x\n", usNewMSR));

        if (usNewMSR & USB_COMM_CTS) {
           pDevExt->SerialPort.ModemStatus |= SERIAL_MSR_CTS;
        } else {
           pDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_CTS;
        }

        if (usNewMSR & USB_COMM_DSR) {
           pDevExt->SerialPort.ModemStatus |= SERIAL_MSR_DSR | SERIAL_MSR_DCD;
        } else {
           pDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DSR & ~SERIAL_MSR_DCD;
        }

        // see what has changed in the status register
        usDeltaMSR = usOldMSR ^ pDevExt->SerialPort.ModemStatus;

        if (/*(pDevExt->SerialPort.RS232Lines & SERIAL_RTS_STATE) && */
            (usDeltaMSR & SERIAL_MSR_CTS)) {

           pDevExt->SerialPort.HistoryMask |= SERIAL_EV_CTS;
           pDevExt->SerialPort.ModemStatus |= SERIAL_MSR_DCTS;
        }

        if (/*(pDevExt->SerialPort.RS232Lines & SERIAL_DTR_STATE) && */
            (usDeltaMSR & SERIAL_MSR_DSR)) {

           pDevExt->SerialPort.HistoryMask |= SERIAL_EV_DSR | SERIAL_EV_RLSD;
           pDevExt->SerialPort.ModemStatus |= SERIAL_MSR_DDSR | SERIAL_MSR_DDCD;
        }

        DbgDump(DBG_INT, ("SerialPort.MSR: 0x%x\n", pDevExt->SerialPort.ModemStatus));

        KeReleaseSpinLock(&pDevExt->ControlLock, irql);

        //
        // signal serial events @ DISPATCH_LEVEL before starting our UsbRead,
        // since we run at higher IRQL than apps.
        //
        ProcessSerialWaits( pDevExt );

        if ( bStartRead )  {
           //
           // Get the data.
           // We do set a timeout on 1st read, in case the INT was illegit.
           // Note: we start this read @ DISPATCH_LEVEL.
           //
           UsbRead( pDevExt,
                    TRUE );

        }

        //
        // Queue a passive work item to sync execution of the INT pipe and the IN pipe
        // and then start the next INT packet.
        //
        workStatus = QueueWorkItem( PDevObj,
                                    RestartInterruptWorkItem,
                                    NULL,
                                    0 );

      }
      break;


      case STATUS_CANCELLED:  {
         DbgDump(DBG_INT|DBG_IRP, ("Int: STATUS_CANCELLED\n"));

         // signal anyone who cancelled this or is waiting for it to stop
         //
         KeSetEvent(&pDevExt->IntCancelEvent, IO_SERIAL_INCREMENT, FALSE);

         KeReleaseSpinLock(&pDevExt->ControlLock, irql);
      }
      break;


      case STATUS_DEVICE_DATA_ERROR: {
         //
         // generic device error set by USBD.
         //
         DbgDump(DBG_ERR, ("IntPipe STATUS_DEVICE_DATA_ERROR: 0x%x\n", urbStatus ));

         //
         // bump pipe error count
         //
         InterlockedIncrement( &pDevExt->IntDeviceErrors);

         KeReleaseSpinLock(&pDevExt->ControlLock, irql);

         //
         // is the endpoint is stalled?
         //
         if ( USBD_HALTED(pDevExt->IntUrb->UrbHeader.Status) ) {
               //
               // queue a reset request,
               // which also starts another INT
               //
               workStatus = QueueWorkItem( PDevObj,
                                           UsbResetOrAbortPipeWorkItem,
                                           (PVOID)((LONG_PTR)urbStatus),
                                           WORK_ITEM_RESET_INT_PIPE );

         } else {
            //
            // queue a passive work item to start the next INT packet.
            //
            workStatus = QueueWorkItem( PDevObj,
                                        RestartInterruptWorkItem,
                                        NULL,
                                        0 );
         }
      }
      break;

      default:
         DbgDump(DBG_WRN|DBG_INT, ("Unhandled INT Pipe status: 0x%x 0x%x\n", irpStatus, urbStatus ));
         KeReleaseSpinLock(&pDevExt->ControlLock, irql);
      break;
   }

   ReleaseRemoveLock(&pDevExt->RemoveLock, pDevExt->IntIrp);

   DbgDump(DBG_INT, ("<UsbInterruptComplete\n"));

   return STATUS_MORE_PROCESSING_REQUIRED;
}


//
// This routine requests USB to cancel our INT Irp.
// It must be called at passive level.
// Note: it is the responsibility of the caller to
// reset the IntState to IRP_STATE_COMPLETE and restart USB Ints
// when this routine completes. Else, no more Interrupts will get posted.
//
NTSTATUS
CancelUsbInterruptIrp(
   IN PDEVICE_OBJECT PDevObj
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   NTSTATUS wait_status;
   KIRQL irql;

   DbgDump(DBG_INT|DBG_IRP, (">CancelUsbInterruptIrp\n"));

   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   if ( pDevExt->IntPipe.hPipe && pDevExt->IntIrp ) {

      switch (pDevExt->IntState) {

         //case IRP_STATE_START:
         case IRP_STATE_PENDING:
         {
            //
            // the Irp is pending somewhere down the USB stack...
            //
            PVOID Objects[2] = { &pDevExt->PendingIntEvent,
                                 &pDevExt->IntCancelEvent };

            //
            // signal we need to cancel the Irp
            //
            pDevExt->IntState = IRP_STATE_CANCELLED;

            KeReleaseSpinLock(&pDevExt->ControlLock, irql);

            if ( !IoCancelIrp( pDevExt->IntIrp ) ) {
               //
               // This means USB has the IntIrp in a non-canceable state.
               // We still need to wait for either the pending INT event, or the cancel event.
               //
               DbgDump(DBG_INT|DBG_IRP, ("Irp (%p) was not cancelled\n", pDevExt->IntIrp ));
               // TEST_TRAP();
            }

            DbgDump(DBG_INT|DBG_IRP, ("Waiting for pending IntIrp (%p) to cancel...\n", pDevExt->IntIrp ));

            PAGED_CODE();
            wait_status = KeWaitForMultipleObjects(
                              2,
                              Objects,
                              WaitAny,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL,
                              NULL );

            DbgDump(DBG_INT|DBG_IRP, ("...IntIrp (%p) signalled by: %d\n", pDevExt->IntIrp, wait_status ));

            //
            // At this point we have the Irp back from USB
            //
         }
         break;

         case IRP_STATE_COMPLETE:
         case IRP_STATE_CANCELLED:
            pDevExt->IntState = IRP_STATE_CANCELLED;
            KeReleaseSpinLock(&pDevExt->ControlLock, irql);
            break;

         default:
            DbgDump(DBG_ERR, ("CancelUsbInterruptIrp - Invalid IntState: 0x%x\n", pDevExt->IntState ));
            KeReleaseSpinLock(&pDevExt->ControlLock, irql);
            break;
      }

      if ( (IRP_STATE_CANCELLED != pDevExt->IntState) ||
           (0 != pDevExt->PendingIntCount) ) {

           DbgDump(DBG_ERR, ("CancelUsbInterruptIrp error: IntState: 0x%x \tPendingIntCount: 0x%x\n", pDevExt->IntState, pDevExt->PendingIntCount ));
           TEST_TRAP();

      }

   } else {
      status = STATUS_UNSUCCESSFUL;
      DbgDump(DBG_ERR, ("No INT Irp\n" ));
      KeReleaseSpinLock(&pDevExt->ControlLock, irql);
      // TEST_TRAP();
   }

   DbgDump(DBG_INT|DBG_IRP, ("<CancelUsbInterruptIrp\n"));
   return status;
}


//
// Work item queued from interrupt completion
// to sync execution of the INT pipe and the IN pipe
// and then start another USB INT read if there is not one already in progress
//
VOID
RestartInterruptWorkItem(
   IN PWCE_WORK_ITEM PWorkItem
   )
{
   PDEVICE_OBJECT    pDevObj = PWorkItem->DeviceObject;
   PDEVICE_EXTENSION pDevExt = pDevObj->DeviceExtension;
   NTSTATUS status = STATUS_DELETE_PENDING;
   NTSTATUS wait_status;
   KIRQL irql;


   DbgDump(DBG_INT|DBG_WORK_ITEMS, (">RestartInterruptWorkItem(%p)\n", pDevObj ));

   KeAcquireSpinLock( &pDevExt->ControlLock, &irql );

   //
   // Is the READ Irp is pending somewhere in the USB stack?
   //
   if ( IRP_STATE_PENDING == pDevExt->UsbReadState ) {
      //
      // Then we need to sync with the Usb Read Completion routine.
      //
      #define WAIT_REASONS 2
      PVOID Objects[WAIT_REASONS] = { &pDevExt->UsbReadCancelEvent,
                                      &pDevExt->PendingDataInEvent };

      KeReleaseSpinLock(&pDevExt->ControlLock, irql);

      DbgDump(DBG_INT, ("INT pipe waiting for pending UsbReadIrp (%p) to finish...\n", pDevExt->UsbReadIrp ));

      PAGED_CODE();
      wait_status = KeWaitForMultipleObjects( WAIT_REASONS,
                                              Objects,
                                              WaitAny,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL,
                                              NULL );

      DbgDump(DBG_INT, ("...UsbReadIrp (%p) signalled by: %d\n", pDevExt->UsbReadIrp, wait_status ));

      //
      // At this point the read packet is back on our list
      // and we have the UsbReadIrp back from USB
      //

   } else {
      KeReleaseSpinLock(&pDevExt->ControlLock, irql);
   }

   // start another INT read
   if ( START_ANOTHER_INTERRUPT(pDevExt, TRUE) ) {
      status = UsbInterruptRead( pDevExt );
   }

   DequeueWorkItem( pDevObj, PWorkItem );

   DbgDump(DBG_INT|DBG_WORK_ITEMS, ("<RestartInterruptWorkItem 0x%x\n", status ));

   PAGED_CODE(); // we must exit at passive level

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\perf.c ===
/* Copyright (c) 1999-2000 Microsoft Corporation */
///======================================================================
// 
// Perf.c
//
// This file contains the performance counter initialization
// and dump routines. The only part of this file you
// must modify is the performance counter name table. Match
// the names with the counters you define in perf.h
//
///======================================================================

#include "wdm.h"
#include "perf.h"

#include "debug.h"

#if PERFORMANCE

//**********************************************************************
//
// Modify this section for your counters
//

//
// The names that correspond to the performance
// counter indexes in perf.h
//
static char CounterNames[NUM_PERF_COUNTERS][32] = {
   //
   // Write path
   //
   "Write",
   "WriteComplete",
   "WriteTimeout",
   
   //
   // Read path
   //
   "StartUsbReadWorkItem",
   "UsbRead",
   "UsbReadCompletion",
   "CheckForQueuedUserReads",
   "GetUserData",
   "PutUserData",
   "CancelUsbReadIrp",
   "Read",
   "StartOrQueueIrp",
   "StartUserRead",
   "GetNextUserIrp",
   "CancelCurrentRead",
   "CancelQueuedIrp",
   "ReadTimeout",
   "IntervalReadTimeout",
   "CancelUsbReadWorkItem",

   //
   // USB Path
   //
   "UsbReadWritePacket",

   //
   // Serial path
   //
   "ProcessSerialWaits",

   //
   // Utils
   //
   "TryToCompleteCurrentIrp",
   "RundownIrpRefs",
   "RecycleIrp",
   "ReuseIrp",
   "CalculateTimeout",

};

//
// End of user-modified portion
// 
//**********************************************************************


// print macro that only turns on when debugging is on

//#if DBG
#define PerfPrint(arg) DbgPrint arg
//#else
//#define PerfPrint(arg) 
//#endif


//
// The array of performance counters
//
PERF_COUNTER PerfCounter[NUM_PERF_COUNTERS];

//
// Number of cycles for a PERF_ENTRY and PERF_EXIT
//
static LARGE_INTEGER  PerfEntryExitCycles;

//
// Number of cycles per second
//
static LARGE_INTEGER  PerfCyclesPerSecond;

//
// The resolution of the NT-supplied performance
// counter
//
static LARGE_INTEGER  PerfFreq;

#endif


//----------------------------------------------------------------------
//
// InitPerfCounters
//
// This function initializes the performance counter statistic
// array, estimates how many cycles on this processor equal a second,
// and determines how many cycles it takes to execute a 
// PERF_ENTRY/PERF_EXIT pair.
//
//----------------------------------------------------------------------
VOID
InitPerfCounters()
{
#if PERFORMANCE
    volatile ULONG  i;
    LARGE_INTEGER  calStart;
    LARGE_INTEGER  calEnd;
    LARGE_INTEGER  perfStart, perfEnd;
    LARGE_INTEGER  seconds;
    KIRQL prevIrql;

    //
    // Number of calibration loops
    //
#define CALIBRATION_LOOPS 500000

    //
    // This define is for a dummy performance counter that we
    // use just to calibrate the performance macro overhead
    //
#define TEST 0

    //
    // Calibrate the overhead of PERF_ENTRY and PERF_EXIT, so that
    // they can be subtracted from the output
    //
    DbgDump(DBG_INIT, ("CALIBRATING PEFORMANCE TIMER....\n"));
    KeRaiseIrql( DISPATCH_LEVEL, &prevIrql );
    perfStart = KeQueryPerformanceCounter( &PerfFreq );
    RDTSC(calStart);
    for( i = 0; i < CALIBRATION_LOOPS; i++ ) {
        PERF_ENTRY(TEST);
        PERF_EXIT(TEST);
    }
    RDTSC(calEnd);
    perfEnd = KeQueryPerformanceCounter(NULL);
    KeLowerIrql( prevIrql );

    //
    // Calculate the cycles/PERF_ENTRY, and the number of cycles/second
    //
    PerfEntryExitCycles.QuadPart = (calEnd.QuadPart - calStart.QuadPart)/CALIBRATION_LOOPS;

    seconds.QuadPart = ((perfEnd.QuadPart - perfStart.QuadPart) * 1000 )/ PerfFreq.QuadPart;

    PerfCyclesPerSecond.QuadPart =
        seconds.QuadPart ? ((calEnd.QuadPart - calStart.QuadPart) * 1000) / seconds.QuadPart : 0;

    DbgDump(DBG_INIT, ("Machine's Cycles Per Second   : %I64d\n", PerfCyclesPerSecond.QuadPart ));
    DbgDump(DBG_INIT, ("Machine's Cycles in PERF_XXXX : %I64d\n", PerfEntryExitCycles.QuadPart ));
    DbgDump(DBG_INIT, ("Machine's NT Performance counter frequency: %I64d\n", PerfFreq.QuadPart ));

    //
    // Initialize the array
    //
    for( i = 0; i < NUM_PERF_COUNTERS; i++ ) {
        PerfCounter[i].Count = 0;
        KeInitializeSpinLock( &PerfCounter[i].Lock );
        PerfCounter[i].TotalCycles.QuadPart = 0;
    }
#endif
}


// *******************************************************************
// Name:
//   DumpPerfCounters()
//
// Description:
//   Dumps the performance counters
//
// Assumptions:
//
// Returns:
//
// *******************************************************************
VOID
DumpPerfCounters()
{
#if PERFORMANCE
    int    i;
    LARGE_INTEGER totCycles;
    LARGE_INTEGER totLengthMs;
    LARGE_INTEGER avgLengthMs;

   if (DebugLevel & DBG_PERF ) {

       PerfPrint(("\n"));
       PerfPrint(("Machine's Cycles Per Second   : %I64d\n", PerfCyclesPerSecond.QuadPart ));
       PerfPrint(("Machine's Cycles in PERF_XXXX : %I64d\n", PerfEntryExitCycles.QuadPart ));
       PerfPrint(("Machine's NT Performance counter frequency: %I64d\n", PerfFreq.QuadPart ));
       PerfPrint(("\n===================================================================================\n"));
       PerfPrint((" %-30s      Count          TTL Time        Avg Time (uS)\n", "Function" ));
       PerfPrint(("===================================================================================\n"));

       for( i = 0; i < NUM_PERF_COUNTERS; i++ ) {

           totCycles = PerfCounter[i].TotalCycles;
           totCycles.QuadPart -= (PerfCounter[i].Count * PerfEntryExitCycles.QuadPart);
           totLengthMs.QuadPart = PerfCyclesPerSecond.QuadPart ? (totCycles.QuadPart * 1000000)/
               PerfCyclesPerSecond.QuadPart : 0;
           avgLengthMs.QuadPart = PerfCounter[i].Count ? totLengthMs.QuadPart / PerfCounter[i].Count : 0;

           PerfPrint((" %-30s %10d %15I64d %14I64d\n",
                     CounterNames[i], PerfCounter[i].Count,
                     totLengthMs.QuadPart, avgLengthMs.QuadPart ));

/*
           PerfPrint((" %-30s %10s %15I64d %14I64d (CY)\n",
                     "", "",
                     totCycles.QuadPart,
                     totCycles.QuadPart ? totCycles.QuadPart / PerfCounter[i].Count: 0 ));

           PerfPrint(("------------------------------------------------------------------------------\n"));   
*/
       }
       
       PerfPrint(("------------------------------------------------------------------------------\n"));   
   }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\valueadd\valueadd.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    validate.c

Abstract: USB lower filter driver

Author:

    Kenneth D. Ray

Environment:

    Kernel mode

Revision History:


--*/
#include <WDM.H>
#include "valueadd.H"
#include "local.h"

struct _VA_GLOBALS Global;


NTSTATUS    DriverEntry (PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, VA_CreateClose)
#pragma alloc_text (PAGE, VA_AddDevice)
#pragma alloc_text (PAGE, VA_Unload)
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    registryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_OBJECT      deviceObject;
    UNICODE_STRING      uniNtNameString;
    UNICODE_STRING      uniWin32NameString;
    PVA_CONTROL_DATA    deviceData;
    ULONG               i;
    PDRIVER_DISPATCH  * dispatch;

    UNREFERENCED_PARAMETER (RegistryPath);

    VA_KdPrint (("Entered the Driver Entry\n"));
    RtlInitUnicodeString (&uniNtNameString, VA_FILTER_NTNAME);

    //
    // Create a controling device object.  All control commands to the
    // filter driver come via IOCTL's to this device object.  It lives
    // for the lifetime of the filter driver.
    //

    status = IoCreateDevice (
                 DriverObject,
                 sizeof (VA_CONTROL_DATA),
                 &uniNtNameString,
                 FILE_DEVICE_UNKNOWN,
                 0,                     // No standard device characteristics
                 FALSE,                 // This isn't an exclusive device
                 &deviceObject
                 );


    if(!NT_SUCCESS (status)) {
        VA_KdPrint (("Couldn't create the device\n"));
        return status;
    }
    //
    // Create W32 symbolic link name
    //
    RtlInitUnicodeString (&uniWin32NameString, VA_FILTER_SYMNAME);
    status = IoCreateSymbolicLink (&uniWin32NameString, &uniNtNameString);

    if (!NT_SUCCESS(status)) {
        VA_KdPrint (("Couldn't create the symbolic link\n"));
        IoDeleteDevice (DriverObject->DeviceObject);
        return status;
    }

    VA_KdPrint (("Initializing\n"));

    deviceData = (PVA_CONTROL_DATA) deviceObject->DeviceExtension;
    InitializeListHead (&deviceData->UsbDevices);
    KeInitializeSpinLock (&deviceData->Spin);
    deviceData->NumUsbDevices = 0;

    Global.ControlObject = deviceObject;

    //
    // Create dispatch points
    //

    for (i=0, dispatch = DriverObject->MajorFunction;
         i <= IRP_MJ_MAXIMUM_FUNCTION;
         i++, dispatch++) {

        *dispatch = VA_Pass;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = VA_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = VA_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = VA_FilterURB;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = VA_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = VA_Power;
    DriverObject->DriverExtension->AddDevice           = VA_AddDevice;
    DriverObject->DriverUnload                         = VA_Unload;

    return status;
}


NTSTATUS
VA_Pass (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The default dispatch routine.  If this filter does not recognize the
    IRP, then it should send it down, unmodified.
    No completion routine is required.

    As we have NO idea which function we are happily passing on, we can make
    NO assumptions about whether or not it will be called at raised IRQL.
    For this reason, this function must be in put into non-paged pool
    (aka the default location).

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PVA_USB_DATA    usbData;
    NTSTATUS        status;

    usbData = (PVA_USB_DATA) DeviceObject->DeviceExtension;

    if(DeviceObject == Global.ControlObject) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }

    //
    // This IRP was sent to the filter driver.
    // Since we do not know what to do with the IRP, we should pass
    // it on along down the stack.
    //

    InterlockedIncrement (&usbData->OutstandingIO);
    if (usbData->Removed) {
        status = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else {
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (usbData->TopOfStack, Irp);
    }

    if (0 == InterlockedDecrement (&usbData->OutstandingIO)) {
        KeSetEvent (&usbData->RemoveEvent, 0, FALSE);
    }
    return status;
}

NTSTATUS
VA_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Process the Create and close IRPs sent to this device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status = STATUS_SUCCESS;
    PVA_USB_DATA        usbData;

    PAGED_CODE ();
    TRAP ();

    VA_KdPrint (("Create\n"));

    stack = IoGetCurrentIrpStackLocation (Irp);
    usbData = (PVA_USB_DATA) DeviceObject->DeviceExtension;

    if (DeviceObject == Global.ControlObject) {
        //
        // We allow people to blindly access our control object.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    }
    //
    // Call the next driver in the routine.  We have no value add
    // for start and stop.
    //
    InterlockedIncrement (&usbData->OutstandingIO);

    if (usbData->Removed) {
        status = (IRP_MJ_CREATE == stack->MajorFunction) ?
                    STATUS_DELETE_PENDING:
                    STATUS_SUCCESS; // aka a close

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else {
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (usbData->TopOfStack, Irp);
    }

    if (0 == InterlockedDecrement (&usbData->OutstandingIO)) {
        KeSetEvent (&usbData->RemoveEvent, 0, FALSE);
    }
    return status;
}

NTSTATUS
VA_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new PDO, for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY non pnp IRPS to the given driver
    stack, UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    DeviceObject - pointer to a device object.

    PhysicalDeviceObject -  pointer to a device object pointer created by the
                            underlying bus driver.

Return Value:

    NT status code.

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_OBJECT          deviceObject = NULL;
    PVA_USB_DATA            usbData;
    PVA_CONTROL_DATA        controlData;

#define IS_THIS_OUR_DEVICE(DO) TRUE

    PAGED_CODE ();

    VA_KdPrint (("AddDevice\n"));

    controlData = (PVA_CONTROL_DATA) Global.ControlObject->DeviceExtension;

    //
    // Inquire about this device to see if we really want to filter.
    // Usually this test will not be performed by filter drivers since
    // they will not have registered via INF to load unless they wanted
    // to actually filter the PDO.
    //
    // Remember that you CANNOT send an IRP to the PDO because it has not
    // been started as of yet, but you can make PlugPlay queries to find
    // out things like hardware, compatible ID's, etc.
    // (IoGetDeviceProperty)
    //
    if (!IS_THIS_OUR_DEVICE(deviceObject)) {
        //
        // This is not a device we want to filter.  (Maybe we placed a general
        // entry in the inf file and we are more picky here.)
        //
        // In this case we do not create a device object,
        // and we do not attach.
        //
        // We DO still return status success, otherwise the device node will
        // fail and the device being attached will not function.
        //
        // We must return STATUS_SUCCESS, otherwise this particular device
        // cannot be used by the system
        //

        return STATUS_SUCCESS;
    }

    //
    // Create a filter device object.
    //

    status = IoCreateDevice (DriverObject,
                             sizeof (VA_USB_DATA),
                             NULL, // No Name
                             FILE_DEVICE_UNKNOWN,
                             0,
                             FALSE,
                             &deviceObject);
    //
    // It is important that you choose correctly the file type for this
    // device object.  Here we use FILE_DEVICE_UNKNOWN because this is 
    // a generic filter, however as will all filters, the creator needs 
    // to understand to which stack this filter is attaching.  
    // E.G. if you are writing a CD filter driver you need to use
    // FILE_DEVICE_CD_ROM.  IoCreateDevice actually creates device object
    // with different properties dependent on this field.  
    //

    if (!NT_SUCCESS (status)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //
        return status;
    }

    //
    // Initialize the the device extension.
    //
    usbData = (PVA_USB_DATA) deviceObject->DeviceExtension;

    usbData->Started = usbData->Removed = FALSE;
    usbData->Self = deviceObject;
    usbData->PDO = PhysicalDeviceObject;
    usbData->TopOfStack = NULL;
    usbData->PrintMask = VA_PRINT_ALL;
    ExInterlockedInsertHeadList (&controlData->UsbDevices,
                                 &usbData->List,
                                 &controlData->Spin);
    InterlockedIncrement (&controlData->NumUsbDevices);

    KeInitializeEvent(&usbData->RemoveEvent, SynchronizationEvent, FALSE);
    usbData->OutstandingIO = 1; // biassed to 1.  Transition to zero during
                                // remove device means IO is finished.

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
    //
    usbData->TopOfStack = IoAttachDeviceToDeviceStack (deviceObject,
                                                       PhysicalDeviceObject);
    //
    // if this attachment fails then top of stack will be null.
    // failure for attachment is an indication of a broken plug play system.
    //
    ASSERT (NULL != usbData->TopOfStack);

    return STATUS_SUCCESS;

#undef IS_THIS_OUR_DEVICE
}



VOID
VA_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    UNICODE_STRING      uniWin32NameString;

    PAGED_CODE ();

    //
    // We should not be unloaded until all the PDOs have been removed from
    // our queue.  The control device object should be the only thing left.
    //
    ASSERT (Global.ControlObject == DriverObject->DeviceObject);
    ASSERT (NULL == Global.ControlObject->NextDevice);
    VA_KdPrint (("unload\n"));

    //
    // Get rid of our control device object.
    //
    RtlInitUnicodeString (&uniWin32NameString, VA_FILTER_SYMNAME);
    IoDeleteSymbolicLink (&uniWin32NameString);
    IoDeleteDevice (DriverObject->DeviceObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\perf.h ===
// Copyright (c) 1999-2000 Microsoft Corporation
///======================================================================
//
// Perf.h
//
// Fill in this header file with definitions for the performance
// counters you want to use.
//
///======================================================================

#ifndef _PERF_H_
#define _PERF_H_

//**********************************************************************
//
// Modify this section for your counters
//

#define DRV_NAME "WCEUSBSH"

//
// Define PERFORMANCE to "1" turn on the cycle performance counters.
// I currently set it in the debug build (or explicitely in SOURCES for free build) since
// the free build only sees a slight gain IFF *all* debug tracing (except DBG_ERR)
// is turned off.
//
#if DBG
#if !defined(MSFT_NT_BUILD)
#define PERFORMANCE 1
#endif
#endif

//
// This is the array of counter index definitions.
// Note that when a new entry is added here that the name array
// in perf.c must be updated as well. The convention is that
// the index name should match the function name identically, with
// the PERF_ prefix.
//
enum {
   //
   // Write path
   //
   PERF_Write,
   PERF_WriteComplete,
   PERF_WriteTimeout,

   //
   // Read path
   //
   PERF_StartUsbReadWorkItem,
   PERF_UsbRead,
   PERF_UsbReadCompletion,
   PERF_CheckForQueuedUserReads,
   PERF_GetUserData,
   PERF_PutUserData,
   PERF_CancelUsbReadIrp,
   PERF_Read,
   PERF_StartOrQueueIrp,
   PERF_StartUserRead,
   PERF_GetNextUserIrp,
   PERF_CancelCurrentRead,
   PERF_CancelQueuedIrp,
   PERF_ReadTimeout,
   PERF_IntervalReadTimeout,
   PERF_CancelUsbReadWorkItem,

   //
   // USB Path
   //
   PERF_UsbReadWritePacket,

   //
   // Serial path
   //
   PERF_ProcessSerialWaits,

   //
   // Utils
   //
   PERF_TryToCompleteCurrentIrp,
   PERF_RundownIrpRefs,
   PERF_RecycleIrp,
   PERF_ReuseIrp,
   PERF_CalculateTimeout,

   //
   // leave this entry alone
   //
   NUM_PERF_COUNTERS
} PERF_INDICED;

//
// End of user-modified portion
//
//**********************************************************************

typedef struct {
   KSPIN_LOCK      Lock;
   LONG            Count;
   LARGE_INTEGER   TotalCycles;
} PERF_COUNTER, *PPERF_COUNTER;


#if PERFORMANCE

extern PERF_COUNTER PerfCounter[];

//
// Definition for raw bytes that generate RDTSC instruction
//
#define RDTSC(_VAR)                \
   _asm {                          \
       _asm push eax               \
       _asm push edx               \
       _asm _emit 0Fh              \
       _asm _emit 31h              \
       _asm mov _VAR.LowPart, eax  \
       _asm mov _VAR.HighPart, edx \
       _asm pop edx                \
       _asm pop eax                \
   }

//
// Definitions for performance counters that execute
// at DISPATCH_LEVEL (e.g. in DPCs) and lower IRQLs.
//
// NOTE: we read the cycle counter at the outside of the
// macros since we compensate for the overhead of the macros themselves.
//
#define PERF_ENTRY(_INDEX)                  \
      LARGE_INTEGER _INDEX##perfStart;         \
      LARGE_INTEGER _INDEX##perfEnd;           \
      RDTSC(_INDEX##perfStart);                \
      InterlockedIncrement( &PerfCounter[_INDEX].Count )


#define PERF_EXIT(_INDEX)                   \
      RDTSC(_INDEX##perfEnd);                  \
      _INDEX##perfEnd.QuadPart -= _INDEX##perfStart.QuadPart;          \
      ExInterlockedAddLargeInteger( &PerfCounter[_INDEX].TotalCycles,  \
            _INDEX##perfEnd,                   \
            &PerfCounter[_INDEX].Lock )


//
// Definitions for performance counters that execute
// in ISRs, and hence need no locking
//
#define PERF_ISR_ENTRY(_INDEX)  PERF_ENTRY(_INDEX)

#define PERF_ISR_EXIT(_INDEX)               \
   _INDEX##perfEnd.QuadPart -= _INDEX##perfStart.QuadPart;               \
   PerfCounter[_INDEX].TotalCycles.QuadPart += _INDEX##perfEnd.QuadPart; \
   RDTSC(_INDEX##perfEnd)

#else // PERFORMANCE

#define PERF_ENTRY(_INDEX)

#define PERF_EXIT(_INDEX)

#endif PERFORMANCE


//
// Externs for perf.c
//
VOID InitPerfCounters();
VOID DumpPerfCounters();

#endif _PERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\read.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

   read.c

Abstract:

   This driver implements a state machine which polls for USB read data.
   It pends a single private read irp to USBD as soon as it starts up (StartDevice)
   if there is no interrupt endpoint.

   We have only 1 USB read buffer of some configured size.
   When the USB read irp completes then we copy the data into any pending user read buffer,
   and resubmit the Usb UsbReadIrp to USBD, *IF OUR BUFFER* is emptied. This implements
   simple flow ctrl. There is an optional ring-buffer implementation, which will not bind USB reads
   to application reads.

   Timeouts are set from the app via serial ioctls.

   An alternative to this muck is to create a driver thread to do the polling
   for USB read data. This has it's own caveats & requires the thread to be scheduled,
   so take time to investigate beforehand.

Author:

    Jeff Midkiff (jeffmi)     07-16-99

--*/


#if defined (USE_RING_BUFF)
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#else
#include <stdlib.h>
#endif

#include "wceusbsh.h"


//
// called with control held
//
#if defined (USE_RING_BUFF)
#define START_ANOTHER_USBREAD( _PDevExt ) \
   ( (IRP_STATE_COMPLETE == _PDevExt->UsbReadState) && \
     CanAcceptIoRequests(_PDevExt->DeviceObject, FALSE, TRUE) \
   )
#else
#define START_ANOTHER_USBREAD( _PDevExt ) \
   ( (IRP_STATE_COMPLETE == _PDevExt->UsbReadState) && \
     (0 == _PDevExt->UsbReadBuffChars) && \
     CanAcceptIoRequests(_PDevExt->DeviceObject, FALSE, TRUE) \
   )
#endif


NTSTATUS
UsbReadCompletion(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp,
   IN PVOID Context
   );

__inline
ULONG
GetUserData(
   IN PDEVICE_EXTENSION PDevExt,
   IN PCHAR PDestBuff,
   IN ULONG RequestedLen,
   IN OUT PULONG PBytesCopied
   );

__inline
VOID
PutUserData(
   IN PDEVICE_EXTENSION PDevExt,
   IN ULONG Count
   );

__inline
VOID
CheckForQueuedUserReads(
   IN PDEVICE_EXTENSION PDevExt,
   IN KIRQL Irql
   );

VOID
CancelQueuedIrp(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

VOID
CancelUsbReadWorkItem(
   IN PWCE_WORK_ITEM PWorkItem
   );

VOID
StartUsbReadWorkItem(
    IN PWCE_WORK_ITEM PWorkItem
   );

NTSTATUS
StartUserRead(
   IN PDEVICE_EXTENSION PDevExt
   );

VOID
UsbReadTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   );

VOID
CancelCurrentRead(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

NTSTATUS
StartOrQueueIrp(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP PIrp,
   IN PLIST_ENTRY PIrpQueue,
   IN PIRP *PPCurrentIrp,
   IN PSTART_ROUTINE StartRoutine
   );

VOID
GetNextUserIrp(
   IN PIRP *PpCurrentOpIrp,
   IN PLIST_ENTRY PQueueToProcess,
   OUT PIRP *PpNextIrp,
   IN BOOLEAN CompleteCurrent,
   IN PDEVICE_EXTENSION PDevExt
   );


///////////////////////////////////////////////////////////////////
//
// USB read section
//
//

//
// This function allocates a single Irp & Urb to be continously submitted
// to USBD for buffered reads.
// It is called from StartDevice.
// The Irp & Urb are finally freed in StopDevice.
//
NTSTATUS
AllocUsbRead(
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_SUCCESS;
   PIRP     pIrp;

   DbgDump(DBG_READ, (">AllocUsbRead(%p)\n", PDevExt->DeviceObject));

   ASSERT( PDevExt );
   ASSERT( NULL == PDevExt->UsbReadIrp );

   pIrp = IoAllocateIrp( (CCHAR)(PDevExt->NextDevice->StackSize + 1), FALSE);

   if ( pIrp ) {

      DbgDump(DBG_READ, ("UsbReadIrp: %p\n", pIrp ));

      //
      // fixup irp so we can pass to ourself,
      // and to USBD
      //
      FIXUP_RAW_IRP( pIrp, PDevExt->DeviceObject );

      //
      // setup read state
      //
      KeInitializeEvent( &PDevExt->UsbReadCancelEvent,
                         SynchronizationEvent,
                         FALSE);

      PDevExt->UsbReadIrp = pIrp;

      ASSERT( PDevExt->UsbReadBuff );
      PDevExt->UsbReadBuffChars = 0;
      PDevExt->UsbReadBuffIndex = 0;

      ASSERT( 0 == PDevExt->PendingReadCount );

      InterlockedExchange(&PDevExt->UsbReadState, IRP_STATE_COMPLETE);

   } else {
      //
      // this is a fatal err since we can't post reads to USBD
      //
      TEST_TRAP();
      status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("AllocUsbRead: 0x%x\n", status ));
   }

   DbgDump(DBG_READ, ("<AllocUsbRead 0x%x\n", status ));

   return status;
}


//
// Work item queued from read completion or read timeout.
// Starts another USB read if there is not one already in progress
//
VOID
StartUsbReadWorkItem(
    IN PWCE_WORK_ITEM PWorkItem
   )
{
   PDEVICE_OBJECT    pDevObj = PWorkItem->DeviceObject;
   PDEVICE_EXTENSION pDevExt = pDevObj->DeviceExtension;
   NTSTATUS status = STATUS_DELETE_PENDING;

   PERF_ENTRY( PERF_StartUsbReadWorkItem );

   DbgDump(DBG_READ|DBG_WORK_ITEMS, (">StartUsbReadWorkItem(%p)\n", pDevObj ));

   if ( InterlockedCompareExchange(&pDevExt->AcceptingRequests, TRUE, TRUE) ) {
      status = UsbRead( pDevExt, FALSE );
   }

   DequeueWorkItem( pDevObj, PWorkItem );

   DbgDump(DBG_READ|DBG_WORK_ITEMS, ("<StartUsbReadWorkItem 0x%x\n", status ));

   PAGED_CODE(); // we must exit at passive level

   PERF_EXIT( PERF_StartUsbReadWorkItem );

   return;
}


//
// This routine takes the device's current USB UsbReadIrp and submits it to USBD.
// When the Irp is completed by USBD our completion routine fires.
//
// An optional Timeout value sets a timer on the USB Read Irp,
// so USBD won't queue the read Irp indefinetly.
// If there is a device error then USB returns the Irp.
//
// Return: successful return value is STATUS_SUCCESS, or
//         STATUS_PENDING - which means the I/O is pending in the USB stack.
//
NTSTATUS
UsbRead(
   IN PDEVICE_EXTENSION PDevExt,
   IN BOOLEAN UseTimeout
   )
{
   NTSTATUS status;
   KIRQL    irql;
   LARGE_INTEGER noTimeout = {0,0};

   PERF_ENTRY( PERF_UsbRead );

   DbgDump(DBG_READ, (">UsbRead(%p, %d)\n", PDevExt->DeviceObject, UseTimeout));

   do {
      //
      // check our USB read state
      //
      KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

      if ( !PDevExt->UsbReadIrp ) {
         status = STATUS_UNSUCCESSFUL;
         DbgDump(DBG_ERR, ("UsbRead NO READ IRP\n"));
         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
         PERF_EXIT( PERF_UsbRead );
         break;
      }

      if ( !CanAcceptIoRequests(PDevExt->DeviceObject, FALSE, TRUE)) {
         status = STATUS_DELETE_PENDING;
         DbgDump(DBG_ERR, ("UsbRead: 0x%x\n", status ));
         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
         PERF_EXIT( PERF_UsbRead );
         break;
      }

      //
      // we post our read irp to USB if it has been completed (not cancelled),
      // and our read bufer is driained (if not using a ring-buffer)
      // and the device is accepting requests
      //
      if ( START_ANOTHER_USBREAD( PDevExt ) ) {

         status = AcquireRemoveLock(&PDevExt->RemoveLock, PDevExt->UsbReadIrp);
         if ( !NT_SUCCESS(status) ) {
             DbgDump(DBG_ERR, ("UsbRead: 0x%x\n", status ));
             KeReleaseSpinLock(&PDevExt->ControlLock, irql);
             PERF_EXIT( PERF_UsbRead );
             break;
         }

         ASSERT( IRP_STATE_COMPLETE == PDevExt->UsbReadState);

         InterlockedExchange(&PDevExt->UsbReadState, IRP_STATE_PENDING);

         KeClearEvent( &PDevExt->PendingDataInEvent );
         KeClearEvent( &PDevExt->UsbReadCancelEvent );

         RecycleIrp( PDevExt->DeviceObject, PDevExt->UsbReadIrp );

         //
         // bump ttl request count
         //
         PDevExt->TtlUSBReadRequests++;

         KeReleaseSpinLock(&PDevExt->ControlLock, irql);

#if DBG
         if (UseTimeout) {
            DbgDump(DBG_INT, ("INT Read Timeout due in %d msec\n", (PDevExt->IntReadTimeOut.QuadPart/10000) ));
            KeQuerySystemTime(&PDevExt->LastIntReadTime);
         }
#endif

         status = UsbReadWritePacket( PDevExt,
                                      PDevExt->UsbReadIrp,
                                      UsbReadCompletion, // Irp completion routine
                                      UseTimeout ? PDevExt->IntReadTimeOut : noTimeout,
                                      UseTimeout ? UsbReadTimeout : NULL,    // Timeout routine
                                      TRUE );            // Read

         if ( (STATUS_SUCCESS != status) && (STATUS_PENDING != status) ) {
            //
            // We can end up here after our completion routine runs
            // for an error condition i.e., when we have an
            // invalid parameter, or when user pulls the plug, etc.
            //
            DbgDump(DBG_ERR, ("UsbReadWritePacket: 0x%x\n", status));
         }

      } else {
         //
         // we did not post a Read, but this is not an error condition
         //
         status = STATUS_SUCCESS;
         DbgDump(DBG_READ, ("!UsbRead RE(2): (0x%x,0x%x)\n", PDevExt->UsbReadState, PDevExt->UsbReadBuffChars ));

         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
      }

   } while (0);

   DbgDump(DBG_READ, ("<UsbRead 0x%x\n", status ));

   PERF_EXIT( PERF_UsbRead );

   return status;
}


//
// This completion routine fires when our USB read completes our UsbReadIrp
// Note: we allocated the Irp, and recycle it.
// Always return STATUS_MORE_PROCESSING_REQUIRED to retain the Irp.
// This routine runs at DPC_LEVEL.
//
NTSTATUS
UsbReadCompletion(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP Irp,
   IN PUSB_PACKET PPacket // Context
   )
{
   PDEVICE_EXTENSION pDevExt = PPacket->DeviceExtension;
   PDEVICE_OBJECT    pDevObj = pDevExt->DeviceObject;
   PURB              pUrb;
   ULONG             count;
   KIRQL             irql;
   NTSTATUS          irpStatus;
   NTSTATUS          workStatus;
   USBD_STATUS       urbStatus;
   NTSTATUS          packetStatus;

   PERF_ENTRY( PERF_UsbReadCompletion );

   UNREFERENCED_PARAMETER( PDevObj );

   DbgDump(DBG_READ, (">UsbReadCompletion (%p)\n", Irp));

   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   //
   // cancel the Packet Timer
   //
   if ( PPacket->Timeout.QuadPart != 0 ) {

      if (KeCancelTimer( &PPacket->TimerObj ) ) {
         //
         // the packet's timer was successfully removed from the system
         //
         DbgDump(DBG_READ|DBG_INT, ("Read PacketTimer: Canceled\n"));
      } else {
         //
         // the timer
         // a) already completed, in which case the Irp is being cancelled, or
         // b) it's spinning on the control lock, so tell it we took the Irp.
         //
         PPacket->Status = STATUS_ALERTED;
         DbgDump(DBG_READ|DBG_INT, ("Read PacketTimer: Alerted\n"));
      }
   }

   //
   // get everything we need out of the packet
   // and put it back on the list
   //

   // ensure the Irp is the same one as in our DevExt
   ASSERT( pDevExt->UsbReadIrp == Irp );

   // ensure the Packet's Irp is the same one as in our DevExt
   ASSERT( PPacket->Irp == Irp );

   pUrb = pDevExt->UsbReadUrb;

   // ensure the Packet's Urb is the same one as in our DevExt
   ASSERT( pUrb == &PPacket->Urb );

   count = pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;

   irpStatus = Irp->IoStatus.Status;
   DbgDump(DBG_READ, ("Irp->IoStatus.Status  0x%x\n", irpStatus));

   urbStatus = pUrb->UrbHeader.Status;
   DbgDump(DBG_READ, ("pUrb->UrbHeader.Status 0x%x\n", urbStatus ));

   packetStatus = PPacket->Status;

   RemoveEntryList( &PPacket->ListEntry );

   //
   // Our read state should be either pending or cancelled at this point.
   // If it pending then USB is completing the Irp normally.
   // If it is cancelled then our CancelUsbReadIrp set it,
   // in which case USB can complete the irp normally or as cancelled
   // depending on where it was in processing. If the read state is cancelled
   // then do NOT set to complete, else the read Irp will
   // go back down to USB and you are hosed.
   //
   ASSERT( (IRP_STATE_PENDING == pDevExt->UsbReadState)
           || (IRP_STATE_CANCELLED== pDevExt->UsbReadState) );

   if (IRP_STATE_PENDING == pDevExt->UsbReadState) {
      InterlockedExchange(&pDevExt->UsbReadState, IRP_STATE_COMPLETE);
   }

   //
   // Put the pacet back in packet pool
   //
   ExFreeToNPagedLookasideList( &pDevExt->PacketPool,  // Lookaside,
                                PPacket                // Entry
                                );

   //
   // signal everyone if this is the last IRP
   //
   if ( 0 == InterlockedDecrement(&pDevExt->PendingReadCount) ) {

      DbgDump(DBG_READ, ("PendingReadCount(1) = 0\n"));

      // when we drop back to passive level they will get signalled
      KeSetEvent(&pDevExt->PendingDataInEvent, IO_SERIAL_INCREMENT, FALSE);

   }

   // These things are free now, don't touch them again.
   //
   PPacket  = NULL;
   Irp      = NULL;
   pUrb     = NULL;

   switch (irpStatus) {

      case STATUS_SUCCESS: {
         //
         // save the read transfer info
         //
         ASSERT( USBD_STATUS_SUCCESS == urbStatus );

         DbgDump(DBG_READ_LENGTH, ("USB Read indication: %d\n", count));

         //
         // store read data
         //
         PutUserData( pDevExt, count );

         //
         // clear pipe error count
         //
         InterlockedExchange( &pDevExt->ReadDeviceErrors, 0);

         //
         // bump ttl byte counter
         //
         pDevExt->TtlUSBReadBytes += count;

         //
         // We have some USB read data in our local buffer,
         // let's see if we can satisfy any queued user read requests.
         // This f() releases the control lock.
         //
         CheckForQueuedUserReads(pDevExt, irql);

         //
         // kick off another USB read
         //
         UsbRead( pDevExt,
                  (BOOLEAN)(pDevExt->IntPipe.hPipe ? TRUE : FALSE) );

      }
      break;


      case STATUS_CANCELLED:  {

         DbgDump(DBG_WRN|DBG_READ|DBG_IRP, ("Read: STATUS_CANCELLED\n"));

         KeReleaseSpinLock(&pDevExt->ControlLock, irql);

         //
         // If it was cancelled, it may have timed out.
         // We can tell by looking at the packet attached to it.
         //
         if ( STATUS_TIMEOUT == packetStatus ) {
            //
            // no read data available from USBD
            //
            DbgDump(DBG_WRN|DBG_READ|DBG_IRP, ("Read: STATUS_TIMEOUT\n"));
            ASSERT( USBD_STATUS_CANCELED == urbStatus);
            //
            // We need to kick off another USB read when we are out of reads,
            // or have an error condition.
            //
            if ( !pDevExt->IntPipe.hPipe ) {

               workStatus = QueueWorkItem( pDevObj,
                                           StartUsbReadWorkItem,
                                           NULL,
                                           0 );

            } else {
               workStatus = STATUS_UNSUCCESSFUL;
            }
         }
         //
         // signal anyone who cancelled this or is waiting for it to stop
         //
         KeSetEvent(&pDevExt->UsbReadCancelEvent, IO_SERIAL_INCREMENT, FALSE);
      }
      break;


      case STATUS_DEVICE_DATA_ERROR: {
         //
         // generic device error set by USBD.
         //
         DbgDump(DBG_ERR, ("ReadPipe STATUS_DEVICE_DATA_ERROR: 0x%x\n", urbStatus ));

         KeReleaseSpinLock(&pDevExt->ControlLock, irql);

         //
         // bump pipe error count
         //
         InterlockedIncrement( &pDevExt->ReadDeviceErrors);

         //
         // is the endpoint is stalled?
         //
         if ( USBD_HALTED(urbStatus) ) {

               if ( USBD_STATUS_BUFFER_OVERRUN == urbStatus) {
                  pDevExt->TtlUSBReadBuffOverruns++;
               }

               //
               // queue a reset request,
               // which also starts another read
               //
               workStatus = QueueWorkItem( pDevObj,
                                           UsbResetOrAbortPipeWorkItem,
                                           (PVOID)((LONG_PTR)urbStatus),
                                           WORK_ITEM_RESET_READ_PIPE );

         } else {
            //
            // kick start another USB read
            //
            workStatus = QueueWorkItem( PDevObj,
                                        StartUsbReadWorkItem,
                                        NULL,
                                        0 );

         }
      }
      break;


      case STATUS_INVALID_PARAMETER:   {
         //
         // This means that our (TransferBufferSize > PipeInfo->MaxTransferSize)
         // we need to either break up requests or reject the Irp from the start.
         //
         DbgDump(DBG_WRN, ("STATUS_INVALID_PARAMETER\n"));

         ASSERT(USBD_STATUS_INVALID_PARAMETER == urbStatus);

         KeReleaseSpinLock(&pDevExt->ControlLock, irql);

         TEST_TRAP();
      }
      break;

      default: {
         DbgDump(DBG_ERR, ("READ: Unhandled Irp status: 0x%x\n", irpStatus));
         KeReleaseSpinLock(&pDevExt->ControlLock, irql);
      }
      break;
   }

   ReleaseRemoveLock(&pDevExt->RemoveLock, pDevExt->UsbReadIrp);

   DbgDump(DBG_READ, ("<UsbReadCompletion\n"));

   PERF_EXIT( PERF_UsbReadCompletion );

   return STATUS_MORE_PROCESSING_REQUIRED;
}


//
// This routine is called from the UsbReadCompletion routine
// when our USB UsbReadIrp has completed successfully.
// See if we have any queued user read Irps that we can satisfy.
// It is called with the control lock held (as an optimization)
// and must release the lock upon return.
//
__inline
VOID
CheckForQueuedUserReads(
   IN PDEVICE_EXTENSION PDevExt,
   IN KIRQL Irql
   )
{
   PERF_ENTRY( PERF_CheckForQueuedUserReads );

   DbgDump(DBG_READ, (">CheckForQueuedUserReads(%p)\n", PDevExt->DeviceObject));

   //
   // is there a user read pending?
   //
   if ( (PDevExt->UserReadIrp != NULL) &&
        (IRP_REFERENCE_COUNT(PDevExt->UserReadIrp) & IRP_REF_RX_BUFFER)) {
      //
      // copy our USB read data into user's irp buffer
      //
#if DBG
      ULONG charsRead =
#endif
      GetUserData( PDevExt,
                  ((PUCHAR)(PDevExt->UserReadIrp->AssociatedIrp.SystemBuffer))
                     + (IoGetCurrentIrpStackLocation(PDevExt->UserReadIrp))->Parameters.Read.Length
                     - PDevExt->NumberNeededForRead,
                  PDevExt->NumberNeededForRead,
                  (PULONG)&PDevExt->UserReadIrp->IoStatus.Information );

      if ( !PDevExt->UserReadIrp ) {
         //
         // it's (no longer) possible to have completed the read Irp
         // in the above GetUserData cycle.
         //
         DbgDump(DBG_READ, ("UsbReadIrp already completed(2)\n"));
         TEST_TRAP();

      } else if (PDevExt->NumberNeededForRead == 0) {
         //
         // Mark the user's read Irp as completed,
         // and try to get and service the next user read irp
         //
         ASSERT( PDevExt->UserReadIrp );

         PDevExt->UserReadIrp->IoStatus.Status = STATUS_SUCCESS;

         // signals the interval timer this read is complete
         PDevExt->CountOnLastRead = SERIAL_COMPLETE_READ_COMPLETE;

#if DBG
         if ( DebugLevel & DBG_READ_LENGTH) {

               ULONG count;

               if (PDevExt->UserReadIrp->IoStatus.Status == STATUS_SUCCESS) {
                  count = (ULONG)PDevExt->UserReadIrp->IoStatus.Information;
               } else {
                  count = 0;

               }

               KdPrint(("RD2: RL(%d) C(%d) I(%p)\n",
                        IoGetCurrentIrpStackLocation(PDevExt->UserReadIrp)->Parameters.Read.Length,
                        count,
                        PDevExt->UserReadIrp));
         }
#endif

         TryToCompleteCurrentIrp( PDevExt,
                                  STATUS_SUCCESS,
                                  &PDevExt->UserReadIrp,
                                  &PDevExt->UserReadQueue,
                                  &PDevExt->ReadRequestIntervalTimer,
                                  &PDevExt->ReadRequestTotalTimer,
                                  StartUserRead,
                                  GetNextUserIrp,
                                  IRP_REF_RX_BUFFER,
                                  TRUE,
                                  Irql );

      } else {
         //
         // we could get here if we did not staisfy the user's read
         // but have drained our read buffer. This requires another
         // USB read post.
         //
         ASSERT( PDevExt->UserReadIrp );
         ASSERT( PDevExt->NumberNeededForRead );
         DbgDump(DBG_READ|DBG_READ_LENGTH, ("Pending Irp (%p) has %d bytes to satisfy\n",
                           PDevExt->UserReadIrp, PDevExt->NumberNeededForRead));

         KeReleaseSpinLock( &PDevExt->ControlLock, Irql);
         // TEST_TRAP();
      }

   } else {
      //
      // Q: should we:
      // 1.) copy the data into a local ring-buffer and post another read to USBD, - or -
      // 2.) leave the data in the FIFO & let the device stall/NAK so that:
      //    a) we dont lose any data if the user is not posting reads,
      //    b) lets the other end know to stop sending data via NAKs
      //
      // ...Currently choose #2. If we were to add a ring-buffer then here is where you should do the
      // local copy.
      //
      // Note: we could get here before an app even opens this device
      // if the there is data coming in on the other side of the FIFO.
      //
      DbgDump(DBG_READ|DBG_READ_LENGTH, ("No pending user Reads\n"));
      KeReleaseSpinLock( &PDevExt->ControlLock, Irql);
      //TEST_TRAP();
   }

   //
   // process serial Rx wait masks
   //
   ProcessSerialWaits(PDevExt);

   DbgDump(DBG_READ, ("<CheckForQueuedUserReads\n"));

   PERF_EXIT( PERF_CheckForQueuedUserReads );

   return;
}


#if !defined (USE_RING_BUFF)
//
// We have no ring-buffer.
// Simply copy data from our USB read buffer into user's buffer.
// Called with the control lock held.
//
// Returns the number of bytes copied.
//

__inline
ULONG
GetUserData(
   IN PDEVICE_EXTENSION PDevExt,
   IN PCHAR PDestBuff,
   IN ULONG RequestedLen,
   IN OUT PULONG PBytesCopied
   )
{
   ULONG count;

   PERF_ENTRY( PERF_GetUserData );

   DbgDump(DBG_READ, (">GetUserData (%p)\n", PDevExt->DeviceObject ));

   count = min(PDevExt->UsbReadBuffChars, RequestedLen);

   if (count) {

      memcpy( PDestBuff, &PDevExt->UsbReadBuff[PDevExt->UsbReadBuffIndex], count);

      PDevExt->UsbReadBuffIndex += count;
      PDevExt->UsbReadBuffChars -= count;

      PDevExt->NumberNeededForRead -= count;
      *PBytesCopied += count;
      PDevExt->ReadByIsr += count;
   }

#if DBG
   // temp hack to debug iPAQ 'CLIENT' indications
   if ((DebugLevel & DBG_DUMP_READS) && (count <= 6))
   {
         ULONG i;

         KdPrint(("RD1(%d): ", count));
         for (i = 0; i < count; i++) {
            KdPrint(("%02x ", PDestBuff[i] & 0xFF));
         }
         KdPrint(("\n"));
   }
#endif

   DbgDump(DBG_READ, ("<GetUserData 0x%x\n", count ));

   PERF_EXIT( PERF_GetUserData );

   return count;
}


/*
 We have no ring buffer.
 Simply update the USB read buffer's count & index
 and process serial chars.

 Called with the ControlLock held.
*/
__inline
VOID
PutUserData(
   IN PDEVICE_EXTENSION PDevExt,
   IN ULONG Count
   )
{
    PERF_ENTRY( PERF_PutUserData );

    ASSERT( PDevExt );

    DbgDump(DBG_READ, (">PutUserData %d\n", Count ));

    PDevExt->UsbReadBuffChars = Count;
    PDevExt->UsbReadBuffIndex = 0;

    ASSERT_SERIAL_PORT(PDevExt->SerialPort);

    PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RXCHAR;
    // We have no concept of 80% full. If we blindly set it
    // then serial apps may go into flow handlers.
    // | SERIAL_EV_RX80FULL;

    //
    // Scan for RXFLAG char if needed
    //
    if (PDevExt->SerialPort.WaitMask & SERIAL_EV_RXFLAG) {
        ULONG i;
        for (i = 0; i < Count; i++) {
            if ( *((PUCHAR)&PDevExt->UsbReadBuff[PDevExt->UsbReadBuffIndex] + i)
                == PDevExt->SerialPort.SpecialChars.EventChar) {

               PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RXFLAG;

               DbgDump(DBG_READ|DBG_EVENTS, ("Found SpecialChar: %x\n", PDevExt->SerialPort.SpecialChars.EventChar ));
               break;
            }
        }
    }

    DbgDump(DBG_READ, ("<PutUserData\n"));

    PERF_EXIT( PERF_PutUserData );

    return;
}


#else

/*
 Ring-buffer version
 Copy the ring-buffer data into the user's buffer while checking for wrap around.
 Also must check if we exhaust the read buffer.

 Called with the ControlLock held.
*/
__inline
ULONG
GetUserData(
   IN PDEVICE_EXTENSION PDevExt,
   IN PCHAR PDestBuff,
   IN ULONG RequestedLen,
   IN OUT PULONG PBytesCopied
   )
{
   ULONG i, count;

   PERF_ENTRY( PERF_GetUserData );

   DbgDump(DBG_READ, (">GetUserData (%p)\n", PDevExt->DeviceObject ));

   count = min(PDevExt->RingBuff.CharsInBuff, RequestedLen);

   if (count) {

      for ( i = 0; i< count; i++) {

         // copy the ring buffer data into user's buffer
         PDestBuff[i] = *PDevExt->RingBuff.pHead;

         // bump head checking for wrap
         PDevExt->RingBuff.pHead = PDevExt->RingBuff.pBase + ((ULONG)(PDevExt->RingBuff.pHead + 1) % RINGBUFF_SIZE);
      }

      PDevExt->RingBuff.CharsInBuff -= count;

      PDevExt->NumberNeededForRead -= count;
      *PBytesCopied += count;
      PDevExt->ReadByIsr += count;
   }

#if DBG
   if (DebugLevel & DBG_DUMP_READS)
   {
         ULONG i;

         KdPrint(("RD1(%d): ", count));

         for (i = 0; i < count; i++) {
            KdPrint(("%02x ", PDestBuff[i] & 0xFF));
         }

         KdPrint(("\n"));
   }
#endif

   DbgDump(DBG_READ, ("<GetUserData 0x%x\n", count ));

   PERF_EXIT( PERF_GetUserData );

   return count;
}


/*
 Ring-buffer version
 Copy the USB Read buffer into the ring-buffer while checking for wrap around.

 The ring buffer is assummed to be at least the same size as the USB read buffer.
 This is a simple ring where writes occur at the tail, which can eventually overwrite the start of
 the user read buffer location at the head, if user is not consuming the data. If we overwrite the
 head then we must reset the head to be where we started the current write.

 Note: the USB read buffer is a simple char array, with it's current index = 0.
 Note: SerialPort ownership assummed.

 Called with the ControlLock held.

 Q: Should write an error log if an app has an open handle and we overrun the buffer?

*/
__inline
VOID
PutUserData(
   IN PDEVICE_EXTENSION PDevExt,
   IN ULONG Count
   )
{
   ULONG i;
   PUCHAR pPrevTail;

   PERF_ENTRY( PERF_PutUserData );

   ASSERT( PDevExt );
   ASSERT( PDevExt->RingBuff.pBase );
   ASSERT( PDevExt->RingBuff.pHead );
   ASSERT( PDevExt->RingBuff.pTail );
   ASSERT( PDevExt->RingBuff.Size >= PDevExt->UsbReadBuffSize );
   ASSERT_SERIAL_PORT(PDevExt->SerialPort);

   DbgDump(DBG_READ, (">PutUserData %d\n", Count ));

   pPrevTail = PDevExt->RingBuff.pTail;

   for ( i = 0; i < Count; i++) {

      // copy the USB data
      *PDevExt->RingBuff.pTail = PDevExt->UsbReadBuff[i];

      // check EV_RXFLAG while we are here
      if ( (PDevExt->SerialPort.WaitMask & SERIAL_EV_RXFLAG) &&
           (*PDevExt->RingBuff.pTail == PDevExt->SerialPort.SpecialChars.EventChar)) {

         PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RXFLAG;

         DbgDump(DBG_READ|DBG_SERIAL, ("Found SpecialChar: %x\n", PDevExt->SerialPort.SpecialChars.EventChar ));
      }

      // bump tail checking for wrap
      PDevExt->RingBuff.pTail = PDevExt->RingBuff.pBase + ((ULONG)(PDevExt->RingBuff.pTail + 1) % PDevExt->RingBuff.Size);
   }

   //
   // bump count
   //
   if ( (PDevExt->RingBuff.CharsInBuff + Count) <=  PDevExt->RingBuff.Size ) {

      PDevExt->RingBuff.CharsInBuff += Count;

   } else {
      //
      // Overrun condition. We could check for this first to save the above copy process,
      // but it's the unusual case. We could also optimize the above copy a bit, but still need
      // to check for EV_RXFLAG.
      //
      PDevExt->RingBuff.CharsInBuff = Count;
      PDevExt->RingBuff.pHead = pPrevTail;
#if PERFORMANCE
      PDevExt->TtlRingBuffOverruns.QuadPart ++;
#endif
   }

   PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RXCHAR;

   //
   // Check for 80% full.
   // We currently signal this at 50% since we run at a raised IRQL and serial apps are slow.
   //
   if ( PDevExt->RingBuff.CharsInBuff > RINGBUFF_HIGHWATER_MARK ) {
      DbgDump(DBG_READ|DBG_READ_LENGTH|DBG_SERIAL|DBG_WRN, ("SERIAL_EV_RX80FULL\n"));
      PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RX80FULL;
   }

   DbgDump(DBG_READ, ("<PutUserData\n"));

   PERF_EXIT( PERF_PutUserData );

   return;
}

#endif // USE_RING_BUFF


//
// This routine requests USB to cancel our USB Read Irp.
//
// Note: it is the responsibility of the caller to
//    reset the read state to IRP_STATE_COMPLETE and restart USB reads
//    when this routine completes. Else, no more reads will get posted.
// Note: when the USB Read Irp is cancelled the pending USB read packet
//    is cancelled via the USB Read completion routine.
// Note: must be called at PASSIVE_LEVEL.
//
NTSTATUS
CancelUsbReadIrp(
   IN PDEVICE_OBJECT PDevObj
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   NTSTATUS wait_status;
   KIRQL irql;

   PERF_ENTRY( PERF_CancelUsbReadIrp );

   DbgDump(DBG_READ|DBG_IRP, (">CancelUsbReadIrp\n"));

   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   if ( pDevExt->UsbReadIrp ) {

      switch (pDevExt->UsbReadState) {

         //case IRP_STATE_START:
         case IRP_STATE_PENDING:
         {
            //
            // the Irp is pending somewhere down the USB stack...
            //
            PVOID Objects[2] = { &pDevExt->PendingDataInEvent,
                                 &pDevExt->UsbReadCancelEvent };

            //
            // signal we need to cancel the Irp
            //
            pDevExt->UsbReadState = IRP_STATE_CANCELLED;

            KeReleaseSpinLock(&pDevExt->ControlLock, irql);

            if ( !IoCancelIrp( pDevExt->UsbReadIrp ) ) {
               //
               // This means USB has the UsbReadIrp in a non-canceable state.
               // We still need to wait for either the pending read event, or the cancel event.
               //
               DbgDump(DBG_READ|DBG_IRP, ("Irp (%p) was not cancelled\n", pDevExt->UsbReadIrp ));
               // TEST_TRAP();
            }

            DbgDump(DBG_READ|DBG_IRP, ("Waiting for pending UsbReadIrp (%p) to cancel...\n", pDevExt->UsbReadIrp ));

            PAGED_CODE();
            wait_status = KeWaitForMultipleObjects(
                              2,
                              Objects,
                              WaitAny,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL,
                              NULL );

            DbgDump(DBG_READ|DBG_IRP, ("...UsbReadIrp (%p) signalled by: %d\n", pDevExt->UsbReadIrp, wait_status ));

            //
            // At this point the read packet is back on our list
            // and we have the Irp back from USB
            //

         }
         break;

         case IRP_STATE_COMPLETE:
            pDevExt->UsbReadState = IRP_STATE_CANCELLED;
            KeReleaseSpinLock(&pDevExt->ControlLock, irql);
            break;

         default:
            DbgDump(DBG_ERR, ("CancelUsbReadIrp - Invalid UsbReadState: 0x%x\n", pDevExt->UsbReadState ));
            TEST_TRAP();
            KeReleaseSpinLock(&pDevExt->ControlLock, irql);
            break;
      }

      if ( (IRP_STATE_CANCELLED != pDevExt->UsbReadState) ||
           (0 != pDevExt->PendingReadCount) ) {

           DbgDump(DBG_ERR, ("CancelUsbReadIrp error: UsbReadState: 0x%x \tPendingReadCount: 0x%x\n", pDevExt->UsbReadState, pDevExt->PendingReadCount ));
           //TEST_TRAP();

      }

   } else {
      status = STATUS_UNSUCCESSFUL;
      DbgDump(DBG_ERR, ("No Read Irp\n" ));
      KeReleaseSpinLock(&pDevExt->ControlLock, irql);
      // TEST_TRAP();
   }

   DbgDump(DBG_READ|DBG_IRP, ("<CancelUsbReadIrp\n"));

   PERF_EXIT( PERF_CancelUsbReadIrp );

   return status;
}


//
// Work item queued from USB read timeout
// to Cancel the USB read irp pending in the USB stack
//
VOID
CancelUsbReadWorkItem(
   IN PWCE_WORK_ITEM PWorkItem
   )
{
   PDEVICE_OBJECT    pDevObj = PWorkItem->DeviceObject;
   PDEVICE_EXTENSION pDevExt = pDevObj->DeviceExtension;
   NTSTATUS status = STATUS_DELETE_PENDING;
   KIRQL irql;

   PERF_ENTRY( PERF_CancelUsbReadWorkItem );

   DbgDump(DBG_INT|DBG_READ|DBG_WORK_ITEMS, (">CancelUsbReadWorkItem(%p)\n", pDevObj ));

   KeAcquireSpinLock( &pDevExt->ControlLock, &irql);

   if (IRP_STATE_PENDING == pDevExt->UsbReadState) {

      KeReleaseSpinLock( &pDevExt->ControlLock, irql);

      status = CancelUsbReadIrp( pDevObj );

      InterlockedExchange(&pDevExt->UsbReadState, IRP_STATE_COMPLETE);

   } else {
      KeReleaseSpinLock( &pDevExt->ControlLock, irql);
   }

   DequeueWorkItem( pDevObj, PWorkItem );

   DbgDump(DBG_INT|DBG_READ|DBG_WORK_ITEMS, ("<CancelUsbReadWorkItem 0x%x\n", status ));

   PAGED_CODE(); // we must exit at passive level

   PERF_EXIT( PERF_CancelUsbReadWorkItem );

   return;
}



//
// USB read timeout set on a read packet in UsbRead.
// Runs at DISPATCH_LEVEL.
//
VOID
UsbReadTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   )
{
   PUSB_PACKET       pPacket = (PUSB_PACKET)DeferredContext;
   PDEVICE_EXTENSION pDevExt = pPacket->DeviceExtension;
   PDEVICE_OBJECT    pDevObj = pDevExt->DeviceObject;
   NTSTATUS status; // = STATUS_TIMEOUT;
   KIRQL irql;
#if DBG
   LARGE_INTEGER currentTime;
#endif

   UNREFERENCED_PARAMETER( PDpc );
   UNREFERENCED_PARAMETER( SystemContext1 );
   UNREFERENCED_PARAMETER( SystemContext2 );

   DbgDump(DBG_INT|DBG_READ, (">UsbReadTimeout\n"));

   if (pPacket && pDevExt && pDevObj) {
      //
      // sync with completion routine putting packet back on list
      //
      KeAcquireSpinLock( &pDevExt->ControlLock, &irql);

      if ( !pPacket || !pPacket->Irp ||
           (STATUS_ALERTED == pPacket->Status) ) {

         status = STATUS_ALERTED;

         DbgDump(DBG_INT|DBG_READ, ("STATUS_ALERTED\n" ));

         KeReleaseSpinLock( &pDevExt->ControlLock, irql );

       } else {
         //
         // queue a passive work item to cancel the USB read irp
         //
         KeReleaseSpinLock( &pDevExt->ControlLock, irql );

#if DBG
         KeQuerySystemTime(&currentTime);
         DbgDump(DBG_INT, ("INT Read Timeout occured in < %I64d msec\n", ((currentTime.QuadPart - pDevExt->LastIntReadTime.QuadPart)/(LONGLONG)10000) ));
#endif

         status = QueueWorkItem( pDevObj,
                                 CancelUsbReadWorkItem,
                                 NULL,
                                 0);
      }

   } else {

      status = STATUS_INVALID_PARAMETER;
      DbgDump(DBG_ERR, ("UsbReadTimeout: 0x%x\n", status ));
      TEST_TRAP();

   }

   DbgDump(DBG_INT|DBG_READ, ("<UsbReadTimeout (0x%x)\n", status ));

   return;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// User read section
//

NTSTATUS
Read(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp)
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status =  STATUS_SUCCESS;
   PIO_STACK_LOCATION pIrpSp;

   PERF_ENTRY( PERF_Read );

   DbgDump(DBG_READ|DBG_TRACE, (">Read (%p, %p)\n", PDevObj, PIrp ));

   if ( !CanAcceptIoRequests( pDevExt->DeviceObject, TRUE, TRUE) ) {

      status = PIrp->IoStatus.Status = STATUS_DELETE_PENDING;

      IoCompleteRequest (PIrp, IO_SERIAL_INCREMENT );

      DbgDump(DBG_ERR, ("Read: 0x%x\n", status ));

      PERF_EXIT( PERF_Read );

      return status;
   }

   //
   // set return values to something known
   //
   PIrp->IoStatus.Information = 0;

   pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   if (pIrpSp->Parameters.Read.Length != 0) {

      status = AcquireRemoveLock(&pDevExt->RemoveLock, PIrp);
      if ( !NT_SUCCESS(status) ) {
         DbgDump(DBG_ERR, ("Read:(0x%x)\n", status));
         PIrp->IoStatus.Status = status;
         IoCompleteRequest(PIrp, IO_NO_INCREMENT);
         return status;
      }

      DbgDump(DBG_READ_LENGTH, ("User Read (%p) length: %d\n", PIrp, pIrpSp->Parameters.Read.Length ));

      status = StartOrQueueIrp( pDevExt,
                                PIrp,
                                &pDevExt->UserReadQueue,
                                &pDevExt->UserReadIrp,
                                StartUserRead);

   } else {

      PIrp->IoStatus.Status = status = STATUS_SUCCESS;
      PIrp->IoStatus.Information = 0;

      IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);
   }

   DbgDump(DBG_READ|DBG_TRACE, ("<Read 0x%x\n", status));

   PERF_EXIT( PERF_Read );

   return status;
}



NTSTATUS
StartOrQueueIrp(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP PIrp,
   IN PLIST_ENTRY PQueue,
   IN PIRP *PPCurrentIrp,
   IN PSTART_ROUTINE Starter)
/*++

Routine Description:

    This function is used to either start processing an I/O request or to
    queue it on the appropriate queue if a request is already pending or
    requests may not be started.

Arguments:

    PDevExt       - A pointer to the DeviceExtension.
    PIrp          - A pointer to the IRP that is being started or queued.
    PQueue        - A pointer to the queue to place the IRP on if necessary.
    PPCurrentIrp  - A pointer to the pointer to the currently active I/O IRP.
    Starter       - Function to call if we decide to start this IRP.

Return Value:

    NTSTATUS

--*/
{
   KIRQL    irql;
   NTSTATUS status;

   PERF_ENTRY( PERF_StartOrQueueIrp );

   DbgDump(DBG_READ|DBG_TRACE, (">StartOrQueueIrp (%p, %p)\n", PDevExt->DeviceObject, PIrp ));

   //
   // Make sure the device is accepting request
   //
   if ( !CanAcceptIoRequests( PDevExt->DeviceObject, TRUE, TRUE) ) {

      status = PIrp->IoStatus.Status = STATUS_DELETE_PENDING;

      ReleaseRemoveLock(&PDevExt->RemoveLock, PIrp);

      IoCompleteRequest (PIrp, IO_SERIAL_INCREMENT );

      DbgDump(DBG_ERR, ("StartOrQueueIrp 0x%x\n", status ));

      PERF_EXIT( PERF_StartOrQueueIrp );

      return status;
   }

   KeAcquireSpinLock( &PDevExt->ControlLock, &irql );

   //
   // if nothing is pending then start this new irp
   //
   if (IsListEmpty(PQueue) && (NULL == *PPCurrentIrp)) {

      *PPCurrentIrp = PIrp;

      KeReleaseSpinLock( &PDevExt->ControlLock, irql );

      status = Starter(PDevExt);

      DbgDump(DBG_READ, ("<StartOrQueueIrp 0x%x\n", status ));

      PERF_EXIT( PERF_StartOrQueueIrp );

      return status;
   }

   //
   // We're queueing the irp, so we need a cancel routine -- make sure
   // the irp hasn't already been cancelled.
   //
   if (PIrp->Cancel) {
      //
      // The IRP was apparently cancelled.  Complete it.
      //
      KeReleaseSpinLock( &PDevExt->ControlLock, irql );

      PIrp->IoStatus.Status = STATUS_CANCELLED;

      ReleaseRemoveLock(&PDevExt->RemoveLock, PIrp);

      IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

      DbgDump(DBG_READ|DBG_TRACE, ("<StartOrQueueIrp 0x%x\n", STATUS_CANCELLED ));

      PERF_EXIT( PERF_StartOrQueueIrp );

      return STATUS_CANCELLED;
   }

   //
   // Mark as pending, attach our cancel routine, put on our wait list
   //
   PIrp->IoStatus.Status = STATUS_PENDING;

   IoMarkIrpPending(PIrp);

   InsertTailList(PQueue, &PIrp->Tail.Overlay.ListEntry);

   ASSERT ( !PIrp->CancelRoutine );

   IoSetCancelRoutine(PIrp, CancelQueuedIrp);

   KeReleaseSpinLock( &PDevExt->ControlLock, irql );

   DbgDump(DBG_READ, ("<StartOrQueueIrp 0x%x\n", STATUS_PENDING ));

   PERF_EXIT( PERF_StartOrQueueIrp );

   return STATUS_PENDING;
}



NTSTATUS
StartUserRead(
   IN PDEVICE_EXTENSION PDevExt
   )
/*++

Routine Description:

   This routine processes the active user read request by initializing any timers,
   doing the initial submission to the read state machine, etc.

Arguments:

    PDevExt - Pointer to the device extension for the device to start a read on

Return Value:

    NTSTATUS

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   BOOLEAN bSetStatus = FALSE;
   KIRQL irql;
   PIRP newIrp = NULL;
   ULONG readLen;
   ULONG multiplierVal = 0;
   ULONG constantVal = 0;
   ULONG ulNumberNeededForRead = 0;
   BOOLEAN useTotalTimer = FALSE;
   BOOLEAN returnWithWhatsPresent = FALSE;
   BOOLEAN os2ssreturn = FALSE;
   BOOLEAN crunchDownToOne = FALSE;
   BOOLEAN useIntervalTimer = FALSE;
   SERIAL_TIMEOUTS timeoutsForIrp;
   LARGE_INTEGER totalTime = {0,0};
   BOOLEAN bControlLockReleased = FALSE;

   PERF_ENTRY( PERF_StartUserRead );

   do {

      if ( !PDevExt || !PDevExt->DeviceObject ) {
         DbgDump(DBG_ERR, ("StartUserRead: NO Extension\n"));
         status = STATUS_UNSUCCESSFUL;
         TEST_TRAP();
         break;
      }

      DbgDump(DBG_READ, (">StartUserRead (%p, %p)\n", PDevExt->DeviceObject, PDevExt->UserReadIrp ));

      //
      // get user's read request parameters
      //
      bControlLockReleased = FALSE;
      KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

      // ensure we have a user Irp to play with
      if ( !PDevExt->UserReadIrp ) {
         DbgDump(DBG_ERR, ("StartUserRead: NO UserReadIrp!!\n"));
         KeReleaseSpinLock( &PDevExt->ControlLock, irql);
         status = STATUS_UNSUCCESSFUL;
         TEST_TRAP();
         break;
      }

      // ensure the timers were removed from an earilier read
      if ( KeCancelTimer(&PDevExt->ReadRequestTotalTimer) ||
           KeCancelTimer(&PDevExt->ReadRequestIntervalTimer) )
      {
         DbgDump(DBG_ERR, ("StartUserRead: Timer not cancelled !!\n"));
         TEST_TRAP();
      }

      //
      // Always initialize the timer objects so that the
      // completion code can tell when it attempts to
      // cancel the timers whether the timers had ever
      // been Set.
      //
      KeInitializeTimer(&PDevExt->ReadRequestTotalTimer);
      KeInitializeTimer(&PDevExt->ReadRequestIntervalTimer);

      IRP_SET_REFERENCE(PDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

      readLen = IoGetCurrentIrpStackLocation(PDevExt->UserReadIrp)->Parameters.Read.Length;

      PDevExt->NumberNeededForRead = readLen;
      PDevExt->ReadByIsr = 0;
      DbgDump(DBG_READ|DBG_TIME, ("NumberNeededForRead: %d\n", PDevExt->NumberNeededForRead ));
      DbgDump(DBG_READ|DBG_TIME, ("ReadByIsr: %d\n", PDevExt->ReadByIsr ));

      ASSERT_SERIAL_PORT( PDevExt->SerialPort );

      timeoutsForIrp = PDevExt->SerialPort.Timeouts;
      PDevExt->CountOnLastRead = 0;

      //
      // determine which timeouts we need to calculate for the read
      //
      if (timeoutsForIrp.ReadIntervalTimeout
          && (timeoutsForIrp.ReadIntervalTimeout != MAXULONG)) {

         useIntervalTimer = TRUE;

      }

      if (timeoutsForIrp.ReadIntervalTimeout == MAXULONG) {
         //
         // We need to do special return quickly stuff here.
         //

         //
         // 1) If both constant and multiplier are
         //    0 then we return immediately with whatever
         //    we've got, even if it was zero.
         //
         if (!timeoutsForIrp.ReadTotalTimeoutConstant
             && !timeoutsForIrp.ReadTotalTimeoutMultiplier) {
            returnWithWhatsPresent = TRUE;
         }

         //
         // 2) If constant and multiplier are not MAXULONG
         //    then return immediately if any characters
         //    are present, but if nothing is there, then
         //    use the timeouts as specified.
         //
         else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                    && (timeoutsForIrp.ReadTotalTimeoutMultiplier
                        != MAXULONG)) {
            useTotalTimer = TRUE;
            os2ssreturn = TRUE;
            multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
            constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
         }

         //
         // 3) If multiplier is MAXULONG then do as in
         //    "2" but return when the first character
         //    arrives.
         //
         else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                    && (timeoutsForIrp.ReadTotalTimeoutMultiplier
                        == MAXULONG)) {
            useTotalTimer = TRUE;
            os2ssreturn = TRUE;
            crunchDownToOne = TRUE;
            multiplierVal = 0;
            constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
         }

      } else {
         //
         // If both the multiplier and the constant are
         // zero then don't do any total timeout processing.
         //
         if (timeoutsForIrp.ReadTotalTimeoutMultiplier
             || timeoutsForIrp.ReadTotalTimeoutConstant) {
            //
            // We have some timer values to calculate
            //
            useTotalTimer = TRUE;
            multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
            constantVal   = timeoutsForIrp.ReadTotalTimeoutConstant;
         }
      }

      if (useTotalTimer) {
         ulNumberNeededForRead = PDevExt->NumberNeededForRead;
      }

      // bump total request count
      PDevExt->TtlReadRequests++;

      //
      // see if we have any read data already available
      //
#if defined (USE_RING_BUFF)
      if (PDevExt->RingBuff.CharsInBuff) {
#else
      if (PDevExt->UsbReadBuffChars) {
#endif

#if DBG
         ULONG charsRead =
#endif
         GetUserData( PDevExt,
                     ((PUCHAR)(PDevExt->UserReadIrp->AssociatedIrp.SystemBuffer))
                        + readLen - PDevExt->NumberNeededForRead,
                     PDevExt->NumberNeededForRead,
                     (PULONG)&PDevExt->UserReadIrp->IoStatus.Information );

      } else {

         DbgDump(DBG_READ|DBG_READ_LENGTH, ("No immediate Read data\n"));

      }

      //
      // Try to kick start another USB read.
      //
      if ( START_ANOTHER_USBREAD(PDevExt) ) {

         KeReleaseSpinLock(&PDevExt->ControlLock, irql);

         UsbRead( PDevExt,
                  (BOOLEAN)(PDevExt->IntPipe.hPipe ? TRUE : FALSE) );

         bControlLockReleased = FALSE;
         KeAcquireSpinLock(&PDevExt->ControlLock, &irql);
      }

      if ( !PDevExt->UserReadIrp ) {
         //
         // it's possible that we completed the read Irp already
         // in the above cycle
         //
         DbgDump(DBG_READ, ("UsbReadIrp already completed(1)\n"));

      } else if (returnWithWhatsPresent || (PDevExt->NumberNeededForRead == 0)
          || (os2ssreturn && PDevExt->UsbReadIrp->IoStatus.Information)) {
         //
         // See if this read is complete
         //
         ASSERT( PDevExt->UserReadIrp );
#if DBG
         if ( DebugLevel & DBG_READ_LENGTH)
         {
            ULONG count;

            if (PDevExt->UserReadIrp->IoStatus.Status == STATUS_SUCCESS) {
               count = (ULONG)PDevExt->UserReadIrp->IoStatus.Information;
            } else {
               count = 0;
            }

            KdPrint(("RD3: RL(%d) C(%d) I(%p)\n",
                        IoGetCurrentIrpStackLocation(PDevExt->UserReadIrp)->Parameters.Read.Length,
                        count,
                        PDevExt->UserReadIrp));
         }
#endif
         //
         // Update the amount of chars left in the ring buffer
         //
         PDevExt->UserReadIrp->IoStatus.Status = STATUS_SUCCESS;

         if (!bSetStatus) {
            status = STATUS_SUCCESS;
            bSetStatus = TRUE;
         }

      } else {
         //
         // The irp has the chance to timeout
         //
         IRP_INIT_REFERENCE(PDevExt->UserReadIrp);

         //
         // Check to see if it needs to be cancelled
         //
         if (PDevExt->UserReadIrp->Cancel) {

            PDevExt->UserReadIrp->IoStatus.Status = STATUS_CANCELLED;
            PDevExt->UserReadIrp->IoStatus.Information = 0;

            if (!bSetStatus) {
               bSetStatus = TRUE;
               status = STATUS_CANCELLED;
            }

         } else {
            //
            // If we are supposed to crunch the read down to
            // one character, then update the read length
            // in the irp and truncate the number needed for
            // read down to one.  Note that if we are doing
            // this crunching, then the information must be
            // zero (or we would have completed above) and
            // the number needed for the read must still be
            /// equal to the read length.
            //
            if (crunchDownToOne) {
               PDevExt->NumberNeededForRead = 1;
               IoGetCurrentIrpStackLocation(PDevExt->UserReadIrp)->Parameters.Read.Length = 1;
            }

            IRP_SET_REFERENCE(PDevExt->UserReadIrp, IRP_REF_RX_BUFFER);
            IRP_SET_REFERENCE(PDevExt->UserReadIrp, IRP_REF_CANCEL);

            if (useTotalTimer) {

               CalculateTimeout( &totalTime,
                                 ulNumberNeededForRead,
                                 multiplierVal,
                                 constantVal );

               IRP_SET_REFERENCE(PDevExt->UserReadIrp, IRP_REF_TOTAL_TIMER);

               DbgDump(DBG_READ|DBG_TIME, ("TotalReadTimeout for Irp %p due in %d msec\n", PDevExt->UserReadIrp, (totalTime.QuadPart/10000) ));

               KeSetTimer(&PDevExt->ReadRequestTotalTimer,
                           totalTime,
                          &PDevExt->TotalReadTimeoutDpc);
            }

            if (useIntervalTimer) {

               // relative time. Note we could lose the high order bit here
               PDevExt->IntervalTime.QuadPart = MILLISEC_TO_100NANOSEC( (signed)timeoutsForIrp.ReadIntervalTimeout );

               IRP_SET_REFERENCE(PDevExt->UserReadIrp, IRP_REF_INTERVAL_TIMER);

               KeQuerySystemTime(&PDevExt->LastReadTime);

               DbgDump(DBG_READ|DBG_TIME, ("ReadIntervalTimeout for Irp %p due in %d msec\n", PDevExt->UserReadIrp, (PDevExt->IntervalTime.QuadPart/10000) ));

               KeSetTimer(&PDevExt->ReadRequestIntervalTimer,
                          PDevExt->IntervalTime,
                          &PDevExt->IntervalReadTimeoutDpc);
            }

            //
            // Mark IRP as cancellable
            //
            ASSERT( PDevExt->UserReadIrp );
            IoSetCancelRoutine( PDevExt->UserReadIrp,
                                CancelCurrentRead );

            ASSERT( PDevExt->UserReadIrp );
            IoMarkIrpPending( PDevExt->UserReadIrp );

            bControlLockReleased = TRUE;
            KeReleaseSpinLock(&PDevExt->ControlLock, irql);

            if (!bSetStatus) {
               //
               // At this point the USB Read irp pending as the PDevExt->UsbReadIrp.
               // Either a read timer will fire to complete or cancel the Read,
               // or we hang indefinetly.
               //
               status = STATUS_PENDING;
            }
         }

         DbgDump(DBG_READ, ("<StartUserRead (1) 0x%x\n", status ));

         PERF_EXIT( PERF_StartUserRead );

         return status;
      }

      //
      // kick start the next queued user Read Irp
      //
      bControlLockReleased = TRUE;
      KeReleaseSpinLock(&PDevExt->ControlLock, irql);

      GetNextUserIrp( &PDevExt->UserReadIrp,
                      &PDevExt->UserReadQueue,
                      &newIrp,
                      TRUE,
                      PDevExt);

   } while (newIrp != NULL);

   DbgDump(DBG_READ, ("<StartUserRead (2) 0x%x\n", status ));

   PERF_EXIT( PERF_StartUserRead );

   return status;
}



VOID
GetNextUserIrp(
   IN PIRP *PpCurrentOpIrp,
   IN PLIST_ENTRY PQueueToProcess,
   OUT PIRP *PpNextIrp,
   IN BOOLEAN CompleteCurrent,
   IN PDEVICE_EXTENSION PDevExt
   )
/*++

Routine Description:

    This function gets the next IRP off a queue, marks it as current,
    and possibly completes the current IRP.

Arguments:

    PpCurrentOpIrp    - A pointer to the pointer to the current IRP.
    PQueueToProcess  - A pointer to the queue to get the next IRP from.
    PpNextIrp         - A pointer to the pointer to the next IRP to process.
    CompleteCurrent  - TRUE if we should complete the IRP that is current at
                       the time we are called.
    PDevExt          - A pointer to the device extension.

Return Value:

    NTSTATUS

--*/
{
   KIRQL irql;
   PIRP pOldIrp;

   PERF_ENTRY( PERF_GetNextUserIrp );

   if ( !PpCurrentOpIrp || !PQueueToProcess || !PpNextIrp || !PDevExt ) {
      DbgDump(DBG_ERR, ("GetNextUserIrp: missing parameter\n" ));
      PERF_EXIT( PERF_GetNextUserIrp );
      TEST_TRAP();
      return;
   }

   DbgDump(DBG_IRP|DBG_READ, (">GetNextUserIrp (%p)\n", PDevExt->DeviceObject ));

   KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

   pOldIrp = *PpCurrentOpIrp;

   //
   // Check to see if there is a new irp to start up
   //
   if ( !IsListEmpty(PQueueToProcess) ) {
      PLIST_ENTRY pHeadOfList;

      pHeadOfList = RemoveHeadList(PQueueToProcess);

      *PpCurrentOpIrp = CONTAINING_RECORD(pHeadOfList, IRP,
                                         Tail.Overlay.ListEntry);

      IoSetCancelRoutine(*PpCurrentOpIrp, NULL);

   } else {
      *PpCurrentOpIrp = NULL;
   }

   *PpNextIrp = *PpCurrentOpIrp;

   //
   // Complete the current one if so requested
   //
   if ( pOldIrp && CompleteCurrent ) {

      ASSERT(NULL == pOldIrp->CancelRoutine);

      DbgDump(DBG_IRP|DBG_READ|DBG_READ_LENGTH|DBG_TRACE, ("IoCompleteRequest(1, %p) Status: 0x%x Btyes: %d\n",
                                                pOldIrp, pOldIrp->IoStatus.Status,  pOldIrp->IoStatus.Information ));

      //
      // bump ttl byte counter
      //
      PDevExt->TtlReadBytes += (ULONG)pOldIrp->IoStatus.Information;

      ReleaseRemoveLock(&PDevExt->RemoveLock, pOldIrp);

      KeReleaseSpinLock(&PDevExt->ControlLock, irql);

      IoCompleteRequest(pOldIrp, IO_NO_INCREMENT );

   } else {
      KeReleaseSpinLock(&PDevExt->ControlLock, irql);
   }

   DbgDump(DBG_IRP|DBG_READ, ("Next Irp: %p\n", *PpNextIrp ));

   DbgDump(DBG_IRP|DBG_READ|DBG_TRACE, ("<GetNextUserIrp\n" ));

   PERF_EXIT( PERF_GetNextUserIrp );

   return;
}



VOID
CancelCurrentRead(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   )
/*++

Routine Description:

    This routine is used to cancel the User's current read Irp.

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/
{

   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   KIRQL irql;

   PERF_ENTRY( PERF_CancelCurrentRead );

   DbgDump(DBG_READ|DBG_IRP, (">CancelCurrentRead (%p)\n", PDevObj ));

   //
   // we manage our own Irp queue, so release this ASAP
   //
   IoReleaseCancelSpinLock( PIrp->CancelIrql );

    //
    // We set this to indicate to the interval timer
    // that the read has encountered a cancel.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

    pDevExt->CountOnLastRead = SERIAL_COMPLETE_READ_CANCEL;

    if ( pDevExt->UserReadIrp ) {

       // grab the read irp
       IRP_CLEAR_REFERENCE(pDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

       TryToCompleteCurrentIrp( pDevExt,
                                STATUS_CANCELLED,
                                &pDevExt->UserReadIrp,
                                &pDevExt->UserReadQueue,
                                &pDevExt->ReadRequestIntervalTimer,
                                &pDevExt->ReadRequestTotalTimer,
                                StartUserRead,
                                GetNextUserIrp,
                                IRP_REF_CANCEL,
                                TRUE,
                                irql );

   } else {
      //
      // it is already gone
      //
      DbgDump( DBG_ERR, ("UserReadIrp already gone!\n" ));
      KeReleaseSpinLock(&pDevExt->ControlLock, irql);
      TEST_TRAP();

   }

   DbgDump(DBG_READ|DBG_IRP, ("<CancelCurrentRead\n" ));

   PERF_EXIT( PERF_CancelCurrentRead );

   return;
}



VOID
CancelQueuedIrp(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   )
/*++

Routine Description:

    This function is used as a cancel routine for queued irps.
    Basically for us this means the user's Read IRPs.

Arguments:

    PDevObj - A pointer to the serial device object.

    PIrp    - A pointer to the IRP that is being cancelled

Return Value:

    VOID

--*/
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);
   KIRQL irql;

   PERF_ENTRY( PERF_CancelQueuedIrp );

   DbgDump(DBG_READ|DBG_IRP|DBG_TRACE, (">CancelQueuedIrp (%p)\n", PDevObj ));

   //
   // we manage our own Irp queue, so release this ASAP
   //
   IoReleaseCancelSpinLock(PIrp->CancelIrql);

   //
   // The irp was cancelled -- remove it from the queue
   //
   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   PIrp->IoStatus.Status = STATUS_CANCELLED;
   PIrp->IoStatus.Information = 0;

   RemoveEntryList(&PIrp->Tail.Overlay.ListEntry);

   ReleaseRemoveLock(&pDevExt->RemoveLock, PIrp);

   KeReleaseSpinLock(&pDevExt->ControlLock, irql);

   IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

   DbgDump(DBG_READ|DBG_IRP|DBG_TRACE, ("<CancelQueuedIrp\n" ));

   PERF_EXIT( PERF_CancelQueuedIrp );

   return;
}



VOID
ReadTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   )
/*++

Routine Description:

    This routine is used to complete a read because its total
    timer has expired.

Arguments:

    PDpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{
   PDEVICE_EXTENSION pDevExt = DeferredContext;
   KIRQL oldIrql;

   PERF_ENTRY( PERF_ReadTimeout );

   UNREFERENCED_PARAMETER(PDpc);
   UNREFERENCED_PARAMETER(SystemContext1);
   UNREFERENCED_PARAMETER(SystemContext2);

   DbgDump(DBG_TIME, (">ReadTimeout (%p)\n", pDevExt->DeviceObject ));

  KeAcquireSpinLock(&pDevExt->ControlLock, &oldIrql);

   if ( !CanAcceptIoRequests(pDevExt->DeviceObject, FALSE, TRUE) ) {

      TEST_TRAP();

      IRP_CLEAR_REFERENCE( pDevExt->UserReadIrp, IRP_REF_TOTAL_TIMER);

      // manually set the cancel routine
      IoSetCancelRoutine( pDevExt->UserReadIrp,
                          CancelCurrentRead );

      KeReleaseSpinLock(&pDevExt->ControlLock, oldIrql);

      IoCancelIrp(pDevExt->UserReadIrp);

      PERF_EXIT( PERF_ReadTimeout );

      return;
   }

    //
    // We set this to indicate to the interval timer
    // that the read has completed due to total timeout.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

   pDevExt->CountOnLastRead = SERIAL_COMPLETE_READ_TOTAL;

   // grab the read irp
   IRP_CLEAR_REFERENCE(pDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

   DbgDump(DBG_TIME|DBG_READ_LENGTH, ("TotalReadTimeout for (%p)\n", pDevExt->UserReadIrp ));

   TryToCompleteCurrentIrp( pDevExt,
                          STATUS_TIMEOUT,
                          &pDevExt->UserReadIrp,
                          &pDevExt->UserReadQueue,
                          &pDevExt->ReadRequestIntervalTimer,
                          &pDevExt->ReadRequestTotalTimer,
                          StartUserRead,
                          GetNextUserIrp,
                          IRP_REF_TOTAL_TIMER,
                          TRUE,
                          oldIrql );

   DbgDump(DBG_TIME, ("<ReadTimeout\n"));

   PERF_EXIT( PERF_ReadTimeout );

   return;
}



VOID
IntervalReadTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   )
/*++

Routine Description:

    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last the last time this routine was invoked (This dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is
    read.

Arguments:

    PDpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

   PDEVICE_EXTENSION pDevExt = DeferredContext;
   KIRQL irql;

   PERF_ENTRY( PERF_IntervalReadTimeout );

   UNREFERENCED_PARAMETER(PDpc);
   UNREFERENCED_PARAMETER(SystemContext1);
   UNREFERENCED_PARAMETER(SystemContext2);

   DbgDump(DBG_TIME, (">IntervalReadTimeout (%p)\n", pDevExt->DeviceObject ));

   KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

   if ( !pDevExt->UserReadIrp ||
        (IRP_REFERENCE_COUNT(pDevExt->UserReadIrp) & IRP_REF_INTERVAL_TIMER) == 0 ) {
      //
      // we already completed the read irp so just exit
      //
      DbgDump(DBG_TIME|DBG_IRP, ("Already completed User's Read Irp\n"));

      KeReleaseSpinLock(&pDevExt->ControlLock, irql);

      PERF_EXIT( PERF_IntervalReadTimeout );

      return;
   }

   if ( !CanAcceptIoRequests(pDevExt->DeviceObject, FALSE, TRUE) ) {

      IRP_CLEAR_REFERENCE( pDevExt->UserReadIrp, IRP_REF_INTERVAL_TIMER);

      // manually set the cancel routine
      IoSetCancelRoutine( pDevExt->UserReadIrp,
                          CancelCurrentRead );

      KeReleaseSpinLock(&pDevExt->ControlLock, irql);

      IoCancelIrp(pDevExt->UserReadIrp);

      PERF_EXIT( PERF_IntervalReadTimeout );

      return;
   }

   if (pDevExt->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL) {
      //
      // This value is only set by the total
      // timer to indicate that it has fired.
      // If so, then we should simply try to complete.
      //
      DbgDump(DBG_TIME, ("SERIAL_COMPLETE_READ_TOTAL\n"));

      // grab the read irp
      IRP_CLEAR_REFERENCE(pDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

      pDevExt->CountOnLastRead = 0;

      TryToCompleteCurrentIrp( pDevExt,
                               STATUS_TIMEOUT,
                               &pDevExt->UserReadIrp,
                               &pDevExt->UserReadQueue,
                               &pDevExt->ReadRequestIntervalTimer,
                               &pDevExt->ReadRequestTotalTimer,
                               StartUserRead,
                               GetNextUserIrp,
                               IRP_REF_INTERVAL_TIMER,
                               TRUE,
                               irql );

   } else if (pDevExt->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE) {
      //
      // This value is only set by the regular completion routine.
      // If so, then we should simply try to complete.
      //
      DbgDump(DBG_TIME|DBG_READ_LENGTH, ("SERIAL_COMPLETE_READ_COMPLETE\n"));

      // grab the read irp
      IRP_CLEAR_REFERENCE(pDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

      pDevExt->CountOnLastRead = 0;

      TryToCompleteCurrentIrp( pDevExt,
                               STATUS_SUCCESS,
                               &pDevExt->UserReadIrp,
                               &pDevExt->UserReadQueue,
                               &pDevExt->ReadRequestIntervalTimer,
                               &pDevExt->ReadRequestTotalTimer,
                               StartUserRead,
                               GetNextUserIrp,
                               IRP_REF_INTERVAL_TIMER,
                               TRUE,
                               irql );

   } else if (pDevExt->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL) {
      //
      // This value is only set by the cancel
      // read routine.
      //
      // If so, then we should simply try to complete.
      //
      DbgDump(DBG_TIME, ("SERIAL_COMPLETE_READ_CANCEL\n"));

      // grab the read irp
      IRP_CLEAR_REFERENCE(pDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

      pDevExt->CountOnLastRead = 0;

      TryToCompleteCurrentIrp( pDevExt,
                               STATUS_CANCELLED,
                               &pDevExt->UserReadIrp,
                               &pDevExt->UserReadQueue,
                               &pDevExt->ReadRequestIntervalTimer,
                               &pDevExt->ReadRequestTotalTimer,
                               StartUserRead,
                               GetNextUserIrp,
                               IRP_REF_INTERVAL_TIMER,
                               TRUE,
                               irql );

   } else if (pDevExt->CountOnLastRead || pDevExt->ReadByIsr) {
      //
      // Something has happened since we last came here.  We
      // check to see if the ISR has read in any more characters.
      // If it did then we should update the isr's read count
      // and resubmit the timer.
      //
      if (pDevExt->ReadByIsr) {

         DbgDump(DBG_TIME, ("ReadByIsr %d\n", pDevExt->ReadByIsr));

         pDevExt->CountOnLastRead = pDevExt->ReadByIsr;

         pDevExt->ReadByIsr = 0;

         //
         // Save off the "last" time something was read.
         // As we come back to this routine we will compare
         // the current time to the "last" time.  If the
         // difference is ever larger then the interval
         // requested by the user, then time out the request.
         //
         KeQuerySystemTime(&pDevExt->LastReadTime);

         DbgDump(DBG_TIME, ("ReadIntervalTimeout for Irp %p due in %d msec\n", pDevExt->UsbReadIrp, pDevExt->IntervalTime.QuadPart/10000 ));

         KeSetTimer(&pDevExt->ReadRequestIntervalTimer,
                    pDevExt->IntervalTime,
                    &pDevExt->IntervalReadTimeoutDpc);

         KeReleaseSpinLock(&pDevExt->ControlLock, irql);

      } else {
         //
         // Take the difference between the current time
         // and the last time we had characters and
         // see if it is greater then the interval time.
         // if it is, then time out the request.  Otherwise
         // restart the timer.
         //

         //
         // No characters read in the interval time.  Kill
         // this read.
         //
         LARGE_INTEGER currentTime;

         KeQuerySystemTime(&currentTime);

         if ((currentTime.QuadPart - pDevExt->LastReadTime.QuadPart) >=
            -(pDevExt->IntervalTime.QuadPart) ) { // absolute time

            DbgDump(DBG_TIME, ("TIMEOUT - CountOnLastRead=%d ReadByIsr=%d\n", pDevExt->CountOnLastRead, pDevExt->ReadByIsr));
#if DBG
            if (pDevExt->ReadByIsr > pDevExt->NumberNeededForRead ) {
               // did we we forgot to clear ReadByIsr
               TEST_TRAP();
            }
#endif
            // grab the read irp
            IRP_CLEAR_REFERENCE(pDevExt->UserReadIrp, IRP_REF_RX_BUFFER);

            pDevExt->CountOnLastRead = pDevExt->ReadByIsr = 0;

            // return any chars read up to this point
            TryToCompleteCurrentIrp( pDevExt,
                                     STATUS_TIMEOUT,
                                     &pDevExt->UserReadIrp,
                                     &pDevExt->UserReadQueue,
                                     &pDevExt->ReadRequestIntervalTimer,
                                     &pDevExt->ReadRequestTotalTimer,
                                     StartUserRead,
                                     GetNextUserIrp,
                                     IRP_REF_INTERVAL_TIMER,
                                     TRUE,
                                     irql );

         } else {

            DbgDump(DBG_TIME, ("ReadIntervalTimeout for Irp %p due in %d msec\n", pDevExt->UsbReadIrp, pDevExt->IntervalTime.QuadPart/10000 ));

            KeSetTimer(&pDevExt->ReadRequestIntervalTimer,
                       pDevExt->IntervalTime,
                       &pDevExt->IntervalReadTimeoutDpc);

            KeReleaseSpinLock(&pDevExt->ControlLock, irql);

         }
      }

   } else {
      //
      // Timer doesn't really start until the first character.
      // So we should simply resubmit ourselves.
      //
      DbgDump(DBG_TIME, ("ReadIntervalTimeout for Irp %p due in %d msec\n", pDevExt->UsbReadIrp, pDevExt->IntervalTime.QuadPart/10000 ));

      KeSetTimer(&pDevExt->ReadRequestIntervalTimer,
                 pDevExt->IntervalTime,
                 &pDevExt->IntervalReadTimeoutDpc);

      KeReleaseSpinLock(&pDevExt->ControlLock, irql);

   }

   DbgDump(DBG_TIME, ("<IntervalReadTimeout\n"));

   PERF_EXIT( PERF_IntervalReadTimeout );

   return;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\remlock.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    remlock.c

Abstract:

    Common RemoveLock

Authors:

    Jeff Midkiff

Environment:

    kernel mode only

Notes:
    
    Simple binary compatible RemoveLock definitions for Win9x & Win2k
    made to mimic the Win2k ONLY IoXxxRemoveLock functions.
    See the Win2k DDK for descriptions.

Revision History:

--*/

#include "remlock.h" 
#include "debug.h"

#if !(DBG && WIN2K_LOCKS)

#pragma alloc_text(PAGEWCE1, InitializeRemoveLock)
#pragma alloc_text(PAGEWCE1, ReleaseRemoveLockAndWait)

VOID
InitializeRemoveLock(
    IN  PREMOVE_LOCK Lock
    )
{
    PAGED_CODE();

    if (Lock) {
        Lock->Removed = FALSE;
        Lock->IoCount = 1;
        KeInitializeEvent( &Lock->RemoveEvent,
                           SynchronizationEvent,
                           FALSE );
        DbgDump(DBG_LOCKS, ("InitializeRemoveLock: %p, %d\n", Lock, Lock->IoCount));
    } else {
        DbgDump(DBG_ERR, ("InitializeRemoveLock: Invalid Parameter\n"));
        TEST_TRAP();
    }
}


NTSTATUS
AcquireRemoveLock(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    )
{
    LONG        ioCount;
    NTSTATUS    status;

    UNREFERENCED_PARAMETER(Tag);

#if DBG
    if (!Lock) {
        status = STATUS_INVALID_PARAMETER;
        DbgDump(DBG_ERR, ("AcquireRemoveLock error: 0x%x\n", status ));
        TEST_TRAP();
    }
#endif

    //
    // Grab the remove lock
    //
    ioCount = InterlockedIncrement( &Lock->IoCount );

    ASSERTMSG("AcquireRemoveLock - lock negative : \n", (ioCount > 0));

    if ( !Lock->Removed ) {

        status = STATUS_SUCCESS;

    } else {

        if (0 == InterlockedDecrement( &Lock->IoCount ) ) {
            KeSetEvent( &Lock->RemoveEvent, 0, FALSE);
        }
        status = STATUS_DELETE_PENDING;
        TEST_TRAP();
    }

    DbgDump(DBG_LOCKS, ("AcquireRemoveLock: %d, %p\n", Lock->IoCount, Tag));

    return status;
}


VOID
ReleaseRemoveLock(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    )
{
    LONG    ioCount;

    UNREFERENCED_PARAMETER(Tag);

#if DBG
    if (!Lock) {
        DbgDump(DBG_ERR, ("ReleaseRemoveLock: Invalid Parameter\n"));
        TEST_TRAP();
    }
#endif

    ioCount = InterlockedDecrement( &Lock->IoCount );

    ASSERT(0 <= ioCount);

    if (0 == ioCount) {

        ASSERT(Lock->Removed);

        TEST_TRAP();

        //
        // The device needs to be removed.  Signal the remove event
        // that it's safe to go ahead.
        //
        KeSetEvent(&Lock->RemoveEvent, IO_NO_INCREMENT, FALSE);

    }

    DbgDump(DBG_LOCKS, ("ReleaseRemoveLock: %d, %p\n", Lock->IoCount, Tag));

    return;
}


VOID
ReleaseRemoveLockAndWait(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    )
{
    LONG    ioCount;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(Tag);

#if DBG
    if (!Lock) {
        DbgDump(DBG_ERR, ("ReleaseRemoveLockAndWait: Invalid Parameter\n"));
        TEST_TRAP();
    }
#endif

    DbgDump(DBG_LOCKS, ("ReleaseRemoveLockAndWait: %d, %p\n", Lock->IoCount, Tag));

    Lock->Removed = TRUE;

    ioCount = InterlockedDecrement( &Lock->IoCount );
    ASSERT (0 < ioCount);

    if (0 < InterlockedDecrement( &Lock->IoCount ) ) {
    
        DbgDump(DBG_LOCKS, ("ReleaseRemoveLockAndWait: waiting for %d IoCount...\n", Lock->IoCount));
        
        // BUGBUG: may want a timeout here inside a loop
        KeWaitForSingleObject( &Lock->RemoveEvent, 
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        DbgDump(DBG_LOCKS, ("....ReleaseRemoveLockAndWait: done!\n"));
    }

    return;
}

#endif // !(DBG && WIN2K_LOCKS)

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\pnp.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

        PNP.C

Abstract:

        WinCE Host PnP functions

Environment:

        kernel mode only

Revision History:

        07-14-99 : created

Authors:

        Jeff Midkiff (jeffmi)

-- */

#include "wceusbsh.h"

NTSTATUS
StartDevice(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

NTSTATUS
StopDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
RemoveDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
SyncCompletion(
    IN PDEVICE_OBJECT PDevObj,
    IN PIRP PIrp,
    IN PKEVENT PSyncEvent
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWCE1, StartDevice)
#pragma alloc_text(PAGEWCE1, StopIo)
#pragma alloc_text(PAGEWCE1, StopDevice)
#pragma alloc_text(PAGEWCE1, RemoveDevice)
#pragma alloc_text(PAGEWCE1, Power)
#endif



NTSTATUS
StartDevice(
    IN PDEVICE_OBJECT PDevObj,
    IN PIRP PIrp
    )
/*++

Routine Description:

   This routine handles IRP_MN_START_DEVICE to either
   to start a newly enumerated device or to restart
   an existing device that was stopped.

   PnP Manager postpones exposing device interfaces
   and blocks create requests for the device until
   the start IRP succeeds.

   See:  Setup, Plug & Play, Power Management: Preliminary Windows 2000 DDK
         Section 3.1 Starting a Device

Arguments:

   DeviceObject
   Irp

Return Value:

    NTSTATUS

--*/
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   PNP_STATE oldPnPState;
   KEVENT event;

   DbgDump(DBG_PNP, (">StartDevice (%x)\n", PDevObj));
   PAGED_CODE();

   oldPnPState = pDevExt->PnPState;

   //
   // Pass the Start Irp down the stack.
   // We do are Start on the way back up.
   //
   KeInitializeEvent( &event, SynchronizationEvent, FALSE );

   IoCopyCurrentIrpStackLocationToNext( PIrp );

   IoSetCompletionRoutine( PIrp,
                           SyncCompletion,
                           &event,
                           TRUE, TRUE, TRUE );

   status = IoCallDriver( pDevExt->NextDevice, PIrp );

   //
   // SyncCompletion simple signals the event
   // and returns STATUS_MORE_PROCESSING_REQUIRED,
   // so we still own the Irp.
   //
   if ( status == STATUS_PENDING ) {
      KeWaitForSingleObject( &event, Suspended, KernelMode, FALSE, NULL );
   }

   status = PIrp->IoStatus.Status;

   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_PNP, ("ERROR: StartDevice returned 0x%x\n", status));
      goto ExitStartDevice;
   }

   //
   // The USB stack started OK, start our device...
   //

   //
   // Initialize our DPC's
   //
   KeInitializeDpc(&pDevExt->TotalReadTimeoutDpc,
                   ReadTimeout,
                   pDevExt);

   KeInitializeDpc( &pDevExt->IntervalReadTimeoutDpc,
                    IntervalReadTimeout,
                    pDevExt);

   //
   // Initialize timers
   //
   KeInitializeTimer(&pDevExt->ReadRequestTotalTimer);
   KeInitializeTimer(&pDevExt->ReadRequestIntervalTimer);

   //
   // Get our USB_DEVICE_DESCRIPTOR
   //
   status = UsbGetDeviceDescriptor(PDevObj);
   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("UsbGetDeviceDescriptor error: 0x%x\n", status));
      goto ExitStartDevice;
   }

   //
   // Configure USB stack
   //
   status = UsbConfigureDevice( PDevObj );
   if (status != STATUS_SUCCESS) {
      DbgDump(DBG_ERR, ("UsbConfigureDevice error: 0x%x\n", status));
      goto ExitStartDevice;
   }

   // set state
   InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateStarted);
   InterlockedExchange(&pDevExt->DeviceRemoved, FALSE);
   InterlockedExchange(&pDevExt->AcceptingRequests, TRUE);

   //
   // reset logical Serial interface
   //
   status = SerialResetDevice(pDevExt, PIrp, FALSE);
   if ( STATUS_SUCCESS != status ) {
      DbgDump(DBG_ERR, ("SerialResetDevice ERROR: 0x%x\n", status));
      TEST_TRAP();
   }

   //
   // allocate our read endpoint context
   //
   status = AllocUsbRead( pDevExt );
   if ( STATUS_SUCCESS != status ) {
      DbgDump(DBG_ERR, ("AllocUsbRead ERROR: 0x%x\n", status));
      TEST_TRAP();
   }

   //
   // allocate our interrupt endpoint context
   //
   if ( pDevExt->IntPipe.hPipe ) {
       status = AllocUsbInterrupt( pDevExt );
       if ( STATUS_SUCCESS != status ) {
          DbgDump(DBG_ERR, ("AllocUsbRead ERROR: 0x%x\n", status));
          TEST_TRAP();
       }
   }

   //
   // Now set the interface state active
   //
   status = IoSetDeviceInterfaceState(&pDevExt->DeviceClassSymbolicName, TRUE);
   if ( STATUS_SUCCESS != status ) {
      DbgDump(DBG_ERR, ("IoSetDeviceInterfaceState error: 0x%x\n", status));
      TEST_TRAP();
   } else{
      DbgDump(DBG_WRN, ("IoSetDeviceInterfaceState: ON\n"));
   }

ExitStartDevice:
   if ( STATUS_SUCCESS != status ) {
      pDevExt->PnPState = oldPnPState;
      UsbFreeReadBuffer( PDevObj );
   }

   //
   // complete the Irp
   //
   PIrp->IoStatus.Status = status;

   DbgDump(DBG_PNP, ("<StartDevice(0x%x)\n", status));

   return status;
}


NTSTATUS
StopIo(
   IN PDEVICE_OBJECT DeviceObject
   )
{
   PDEVICE_EXTENSION pDevExt = DeviceObject->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   KIRQL irql;


   DbgDump(DBG_PNP|DBG_INIT, (">StopIo\n"));
   PAGED_CODE();

   if ((pDevExt->PnPState < PnPStateInitialized) ||  (pDevExt->PnPState > PnPStateMax)) {
        DbgDump(DBG_ERR, ("StopIo:STATUS_INVALID_PARAMETER\n"));
        return STATUS_INVALID_PARAMETER;
   }

   InterlockedExchange(&pDevExt->DeviceOpened, FALSE);

    //
    // cancel any pending user Read Irps
    //
    KillAllPendingUserReads( DeviceObject,
                          &pDevExt->UserReadQueue,
                          &pDevExt->UserReadIrp);

    //
    // cancel our USB INT irp
    //
    if (pDevExt->IntIrp)
    {
        status = CancelUsbInterruptIrp(DeviceObject);
        if (STATUS_SUCCESS == status) {

            InterlockedExchange(&pDevExt->IntState, IRP_STATE_COMPLETE);

        } else {
            DbgDump(DBG_ERR, ("CancelUsbInterruptIrp ERROR: 0x%x\n", status));
            TEST_TRAP();
        }
    }

    //
    // cancel our USB Read irp
    //
    if (pDevExt->UsbReadIrp)
    {
        status = CancelUsbReadIrp(DeviceObject);
        if (STATUS_SUCCESS == status) {

            InterlockedExchange(&pDevExt->UsbReadState, IRP_STATE_COMPLETE);

        } else {
            DbgDump(DBG_ERR, ("CancelUsbReadIrp ERROR: 0x%x\n", status));
            TEST_TRAP();
        }
    }

    //
    // cancel pending USB Writes
    //
    CleanUpPacketList( DeviceObject,
                    &pDevExt->PendingWritePackets,
                    &pDevExt->PendingDataOutEvent );

    //
    // cancel pending USB Reads
    //
    CleanUpPacketList(DeviceObject,
                      &pDevExt->PendingReadPackets,
                      &pDevExt->PendingDataInEvent );


    //
    // cancel the pending serial port Irp
    //
    if (pDevExt->SerialPort.ControlIrp) {
        if ( !IoCancelIrp(pDevExt->SerialPort.ControlIrp) ) {
            //
            // We can get here if we are holding the Irp, i.e. we didn't set a cancel routine.
            // Wait for the default timeout, which was set on the corresponding Urb (Set/Clear DTR/RTS).
            //
            LARGE_INTEGER timeOut;

            timeOut.QuadPart = MILLISEC_TO_100NANOSEC( DEFAULT_PENDING_TIMEOUT );

            DbgDump(DBG_ERR, ("!IoCancelIrp(%p)\n", pDevExt->SerialPort.ControlIrp));

            KeDelayExecutionThread(KernelMode, FALSE, &timeOut);

            TEST_TRAP();
        }
    }

    //
    // cancel the pending serial port wait mask Irp
    //
    if (pDevExt->SerialPort.CurrentWaitMaskIrp) {
        if ( !IoCancelIrp(pDevExt->SerialPort.CurrentWaitMaskIrp) ) {
            // We should never get here because we set a cancel routine on this Irp
            DbgDump(DBG_ERR, ("!IoCancelIrp(%p)\n", pDevExt->SerialPort.CurrentWaitMaskIrp));
            TEST_TRAP();
        }
    }

    //
    // wait for pending Work Items to complets
    //
    status = WaitForPendingItem(DeviceObject,
                              &pDevExt->PendingWorkItemsEvent,
                              &pDevExt->PendingWorkItemsCount );
    if ( STATUS_SUCCESS != status ) {
        DbgDump(DBG_ERR, ("WaitForPendingItem ERROR: 0x%x\n", status));
        TEST_TRAP();
    }

   ASSERT( 0 == pDevExt->PendingReadCount );
   ASSERT( 0 == pDevExt->PendingWriteCount );
   ASSERT( 0 == pDevExt->PendingDataOutCount );
   ASSERT( 0 == pDevExt->PendingIntCount );
   ASSERT( 0 == pDevExt->PendingWorkItemsCount );
   ASSERT( NULL == pDevExt->SerialPort.ControlIrp );
   ASSERT( NULL == pDevExt->SerialPort.CurrentWaitMaskIrp );

   DbgDump(DBG_PNP|DBG_INIT, ("<StopIo(%x)\n", status));
   return status;
}



NTSTATUS
StopDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

   This routine handles IRP_MN_STOP_DEVICE.

Arguments:

   DeviceObject
   Irp

Return Value:

    NTSTATUS

--*/
{
   PDEVICE_EXTENSION pDevExt = DeviceObject->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;

   UNREFERENCED_PARAMETER( Irp );

   DbgDump(DBG_PNP, (">StopDevice (%x)\n", DeviceObject));
   PAGED_CODE();

   //
   // if we are not already in stopped state
   //
   if ((pDevExt->PnPState != PnPStateStopped) &&
       (pDevExt->PnPState != PnPStateSupriseRemove)) {

      //
      // Signal that we are no longer AcceptingRequests
      //
      InterlockedExchange(&pDevExt->AcceptingRequests, FALSE);

      //
      // set the interface state inactive
      //
      if (pDevExt->DeviceClassSymbolicName.Buffer )
      {
          status = IoSetDeviceInterfaceState(&pDevExt->DeviceClassSymbolicName, FALSE);
          if (NT_SUCCESS(status)) {
              DbgDump(DBG_WRN, ("IoSetDeviceInterfaceState.2: OFF\n"));
          }
      }

      status = StopIo(DeviceObject);
      if (STATUS_SUCCESS != status) {
          DbgDump(DBG_ERR, ("StopIo ERROR: 0x%x\n", status));
          TEST_TRAP();
      }

      //
      // free the Read Irp
      //
      if (pDevExt->UsbReadIrp) {

         ASSERT( (IRP_STATE_COMPLETE == pDevExt->UsbReadState)
           || (IRP_STATE_CANCELLED== pDevExt->UsbReadState) );

         IoFreeIrp(pDevExt->UsbReadIrp);
         pDevExt->UsbReadIrp = NULL;
      }

      //
      // free the INT Irp
      //
      if (pDevExt->IntIrp) {

         ASSERT( (IRP_STATE_COMPLETE == pDevExt->IntState)
            || (IRP_STATE_CANCELLED== pDevExt->IntState) );

         IoFreeIrp(pDevExt->IntIrp);
         pDevExt->IntIrp = NULL;
      }

      //
      // free the INT Urb
      //
      if (pDevExt->IntUrb) {
         ExFreeToNPagedLookasideList( &pDevExt->BulkTransferUrbPool, pDevExt->IntUrb );
         pDevExt->IntUrb = NULL;

      }

   }

   DbgDump(DBG_PNP, ("<StopDevice(0x%x)\n", status));

   return status;
}


NTSTATUS
CleanUpPacketList(
   IN PDEVICE_OBJECT DeviceObject,
   IN PLIST_ENTRY PListHead,
   IN PKEVENT PEvent
   )
/* ++

Routine Description:

   Walks the pending packet list and
   cancels the packet's timer and Irp

Arguments:

   DeviceObject
   PListHead   - pointer to head of packet List

Return Value:

      NTSTATUS

-- */
{
   PDEVICE_EXTENSION pDevExt = DeviceObject->DeviceExtension;
   PUSB_PACKET       pPacket;
   KIRQL             irql;
   PLIST_ENTRY       pleHead, pleCurrent, pleNext;
   NTSTATUS          status = STATUS_SUCCESS;

   DbgDump(DBG_PNP|DBG_IRP, (">CleanUpPacketLists (%x)\n", DeviceObject));

   // acquire lock
   KeAcquireSpinLock( &pDevExt->ControlLock, &irql );

   if ( !PListHead || !PEvent) {
      DbgDump(DBG_ERR, ("CleanUpPacketLists: !(Head|Event)\n"));
      TEST_TRAP();
      KeReleaseSpinLock( &pDevExt->ControlLock, irql );
      return STATUS_INVALID_PARAMETER;
   }

   // walk the list...
   for ( pleHead    = PListHead,          // get 1st ListEntry
         pleCurrent = pleHead->Flink,
         pleNext    = pleCurrent->Flink;

         pleCurrent != pleHead,           // done when we loop back to head
         !pleHead,                        // or hit a trashed list
         !pleCurrent,
         !pleNext;

         pleCurrent = pleNext,            // get the next in the list
         pleNext    = pleCurrent->Flink
        )
   {
      // did the list get trashed?
      ASSERT( pleHead );
      ASSERT( pleCurrent );
      ASSERT( pleNext );

      // extract packet pointer
      pPacket = CONTAINING_RECORD( pleCurrent,
                                   USB_PACKET,
                                   ListEntry );

      if ( pPacket &&
           pPacket->DeviceExtension &&
           pPacket->Irp ) {

        // cancel packet's timer
        KeCancelTimer( &pPacket->TimerObj);

        if ( !IoCancelIrp( pPacket->Irp ) ) {
           //
           // This means USB has the Irp in a non-canceable state.
           // We need to wait for either the pending read event, or the cancel event.
           //
           DbgDump(DBG_IRP, ("CleanUpPacketLists: Irp (%p) was not cancelled\n", pPacket->Irp));
        }

        //
        // we need to wait for the Irp to complete from USB
        //
        DbgDump(DBG_IRP, ("Waiting for Irp (%p) to complete...\n", pPacket->Irp ));

        KeReleaseSpinLock( &pDevExt->ControlLock, irql );

        PAGED_CODE();
        KeWaitForSingleObject( PEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        KeAcquireSpinLock( &pDevExt->ControlLock, &irql );

        DbgDump(DBG_IRP, ("...Irp (%p) signalled completion.\n", pPacket->Irp ));

      } else {
         // it was completed already
         DbgDump(DBG_WRN, ("CleanUpPacketLists: No Packet\n" ));

         if ( pPacket &&
              (!pPacket->ListEntry.Flink || !pPacket->ListEntry.Blink)) {

               DbgDump(DBG_ERR, ("CleanUpPacketLists: corrupt List!!\n" ));
               TEST_TRAP();
               break;
         }

      }

      //
      // The Irp should percolate back to our R/W completion
      // routine, which puts the packet back in packet pool.
      //
   }

#if DBG
   if ( !pleHead || !pleCurrent || !pleNext) {
      DbgDump(DBG_ERR, ("CleanUpPacketLists: corrupt List!!\n" ));
      TEST_TRAP();
   }
#endif

   KeReleaseSpinLock( &pDevExt->ControlLock, irql );

   DbgDump(DBG_PNP|DBG_IRP, ("<CleanUpPacketLists (0x%x)\n", STATUS_SUCCESS));

   return status;
}


NTSTATUS
RemoveDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

   This routine handles IRP_MN_REMOVE_DEVICE.

   See:  Setup, Plug & Play, Power Management: Preliminary Windows 2000 DDK
         Section 3.3.3.1 Removing a Device in a Function Driver

Arguments:

   DeviceObject
   Irp

Return Value:

    NTSTATUS

--*/
{
   PDEVICE_EXTENSION pDevExt = DeviceObject->DeviceExtension;
   NTSTATUS          status = STATUS_SUCCESS;

   DbgDump(DBG_PNP|DBG_TRACE, (">RemoveDevice (%x)\n", DeviceObject));
   PAGED_CODE();

   //
   // stop the device
   //
   status = StopDevice( DeviceObject, Irp );

   InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateRemoved);

   //
   // Pass the Irp down the stack now that we've done our work.
   // REMOVE_DEVICE must be handled first by the driver at the top of the device stack (this device)
   // and then by each next-lower driver (USBD) in the stack. A driver is not required to wait for underlying drivers to
   // finish their remove operations before continuing with its remove activities.
   //
   IoCopyCurrentIrpStackLocationToNext(Irp);
   status = IoCallDriver( pDevExt->NextDevice, Irp );

   //
   // wait for any pending I/O
   //
   ReleaseRemoveLockAndWait(&pDevExt->RemoveLock, Irp);

   //
   // cleanup any resources...
   //
   UsbFreeReadBuffer( DeviceObject );

   // free up notification buffer
   if(pDevExt->IntBuff) {
      ExFreePool(pDevExt->IntBuff);
      pDevExt->IntBuff = NULL;
   }

   //
   // delete LookasideLists
   //
   ExDeleteNPagedLookasideList( &pDevExt->PacketPool );
   ExDeleteNPagedLookasideList( &pDevExt->BulkTransferUrbPool );
   ExDeleteNPagedLookasideList( &pDevExt->PipeRequestUrbPool );
   ExDeleteNPagedLookasideList( &pDevExt->VendorRequestUrbPool );
   ExDeleteNPagedLookasideList( &pDevExt->WorkItemPool );

   if ( !g_isWin9x && g_ExposeComPort ) {
      // cleanup "COMx:" namespace
      UndoSerialPortNaming(pDevExt);
   }

   //
   // Dump PERF data
   //
#if PERFORMANCE
   if (DebugLevel & DBG_PERF )
   {
      DumpPerfCounters();

      DbgPrint("USB IN wMaxPacketSize: %d\n",    pDevExt->ReadPipe.MaxPacketSize);
      DbgPrint("USB OUT wMaxPacketSize: %d\n\n", pDevExt->WritePipe.MaxPacketSize );
      if ( pDevExt->IntPipe.hPipe) {
         DbgPrint("USB INT wMaxPacketSize: %d\n", pDevExt->IntPipe.MaxPacketSize);
         DbgPrint("USB INT Timeout: %d msec\n\n", -(pDevExt->IntReadTimeOut.QuadPart) / 10000 );
      }

      DbgPrint("TTL User Write Bytes   : %d\n",   pDevExt->TtlWriteBytes );
      DbgPrint("TTL User Write Requests: %d\n\n", pDevExt->TtlWriteRequests );

      DbgPrint("TTL User Read Bytes: %d\n",   pDevExt->TtlReadBytes );
      DbgPrint("TTL User Read Requests: %d\n\n", pDevExt->TtlReadRequests );

      DbgPrint("TTL USB Read Bytes: %d\n", pDevExt->TtlUSBReadBytes );
      DbgPrint("TTL USB Read Requests: %d\n\n", pDevExt->TtlUSBReadRequests );

      DbgPrint("USB Read Buffer Size: %d\n", pDevExt->UsbReadBuffSize );
      // Note: this signals the error condition: USB overran the *UsbReadBuffer* pending down the stack.
      DbgPrint("USB Read Buffer Overruns: %d\n\n", pDevExt->TtlUSBReadBuffOverruns );

#if USE_RING_BUFF
      DbgPrint("Internal RingBuffer Size: %d\n", pDevExt->RingBuff.Size );
      DbgPrint("Internal RingBuffer Overruns: %d\n\n", pDevExt->TtlRingBuffOverruns);
#endif
   }
#endif

   DbgDump(DBG_PNP|DBG_TRACE, ("<RemoveDevice (0x%x)\n", status));

   return status;
}



NTSTATUS
Pnp(
    IN PDEVICE_OBJECT PDevObj,
    IN PIRP PIrp
    )
{
   NTSTATUS status = STATUS_SUCCESS;
   PIO_STACK_LOCATION pIrpSp;
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

   PVOID   IoBuffer;
   ULONG   InputBufferLength;
   UCHAR   MinorFunction;
   BOOLEAN PassDown = TRUE;

   DbgDump(DBG_PNP|DBG_TRACE, (">Pnp)\n"));
   PAGED_CODE();

   status = AcquireRemoveLock(&pDevExt->RemoveLock, PIrp);
   if ( !NT_SUCCESS(status) ) {
        DbgDump(DBG_ERR, ("Pnp:(0x%x)\n", status));
        PIrp->IoStatus.Status = status;
        IoCompleteRequest(PIrp, IO_NO_INCREMENT);
        return status;
   }

   pIrpSp = IoGetCurrentIrpStackLocation(PIrp);
   MinorFunction     = pIrpSp->MinorFunction;
   IoBuffer          = PIrp->AssociatedIrp.SystemBuffer;
   InputBufferLength = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

   DbgDump(DBG_PNP, ("%s\n", PnPMinorFunctionString(MinorFunction)));

   switch (MinorFunction) {

        case IRP_MN_START_DEVICE:
          //
          // We cannot send the device any Non-PnP IRPs until
          // START_DEVICE has been propogated down the device stack
          //
          ASSERT( (PnPStateAttached == pDevExt->PnPState) ||
                  (PnPStateStopped == pDevExt->PnPState) );

          status = StartDevice(PDevObj, PIrp);
          PassDown = FALSE;
          break;

        case IRP_MN_STOP_DEVICE:

          status = StopDevice(PDevObj, PIrp);

          InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateStopped);
          break;

        case IRP_MN_SURPRISE_REMOVAL:
         //
         // * Win 2000 only *
         //
         status = StopDevice(PDevObj, PIrp);

         InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateSupriseRemove);
         break;

        case IRP_MN_REMOVE_DEVICE:
          //
          // sent when the device has been removed and probably physically detached
          // from the computer. As with STOP_DEVICE, the driver cannot
          // assume it has received any previous query and may have to
          // explicitly cancel any pending I/O IRPs it has staged.
          //
          status = RemoveDevice(PDevObj, PIrp);

           //
           // detach device from stack &
           //
           IoDetachDevice(pDevExt->NextDevice);

           //
           // delete our FDO and symbolic link
           //
           DeleteDevObjAndSymLink(PDevObj);

           //
           // A function driver does not specify an IoCompletion routine for a remove IRP,
           // nor does it complete the IRP. Remove IRPs are completed by the parent bus driver.
           // The device object & extension are now gone... don't touch it.
           //
           PassDown = FALSE;
           break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
          InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateRemovePending);
          break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
          InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateStarted);
          break;

        case IRP_MN_QUERY_STOP_DEVICE:
          InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateStopPending);
          break;

        case IRP_MN_CANCEL_STOP_DEVICE:
            InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateStarted);
          break;

        case IRP_MN_QUERY_CAPABILITIES: {
             KEVENT Event;

             KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

             IoCopyCurrentIrpStackLocationToNext(PIrp);

             IoSetCompletionRoutine( PIrp, SyncCompletion, &Event, TRUE, TRUE, TRUE);

             status = IoCallDriver(pDevExt->NextDevice, PIrp);
             if (status == STATUS_PENDING) {
                KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL);
             }

             status = PIrp->IoStatus.Status;
             if ( STATUS_SUCCESS == status ) {
               //
               // add in our capabilities
               //
               PDEVICE_CAPABILITIES pDevCaps = NULL;

               pDevCaps = pIrpSp->Parameters.DeviceCapabilities.Capabilities;

               //
               // touch Device PnP capabilities here...
               //
               pDevCaps->LockSupported = 0;
               pDevCaps->Removable = 1;
               pDevCaps->DockDevice = 0;
               pDevCaps->SilentInstall = 1;
               pDevCaps->SurpriseRemovalOK = 1;

               //
               // touch Device Power capabilities here...
               //
            }
            PassDown = FALSE;
          }
          break;


         case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {
            if (g_isWin9x) {
               status = PIrp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
               PassDown = FALSE;
            }
         }
         break;


        case IRP_MN_QUERY_PNP_DEVICE_STATE: {
            //
            // If the device took too many device errors then UsbResetOrAbortPipeWorkItem
            // disabled the device and called IoInvalidateDeviceState.
            // We only handle this Irp if we were disabled or marked as removed
            //
            KIRQL irql;
#if PnP_AS
            BOOLEAN bDisableInterface = FALSE;
#endif

            KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

            if (InterlockedCompareExchange(&pDevExt->DeviceRemoved, TRUE, TRUE)) {
                //
                // Do not set the PNP_DEVICE_REMOVED bit, else DevMan will mark the driver as banged out
                // until the next reboot; but stop taking requests.
                //
                DbgDump(DBG_WRN, ("PnP State: PNP_DEVICE_REMOVED\n"));

                InterlockedExchange(&pDevExt->AcceptingRequests, FALSE);
#if PnP_AS
                bDisableInterface = TRUE;
#endif

            } else if ( !CanAcceptIoRequests(PDevObj, FALSE, FALSE) ) {

                DbgDump(DBG_WRN, ("PnP State: PNP_DEVICE_FAILED\n"));

                PIrp->IoStatus.Information |= PNP_DEVICE_FAILED;

                status = PIrp->IoStatus.Status = STATUS_SUCCESS;
#if PnP_AS
                bDisableInterface = TRUE;
#endif
            }

            KeReleaseSpinLock(&pDevExt->ControlLock, irql);

#if PnP_AS
            // This is a great place to disable the interface, but unfortunately ActiveSync 3.1 will not reopen the device afterwards...
            // It misses about every other PnP this way. By *not* disableing the interface here then AS's only indication that anything is wrong is
            // by noticing that it's Read/Write/Serial requests get rejected, and AS will eventually timeout after some time dT ...
            // sometimes more than 5 seconds on Read/Writes. However, it does not sense Timeouts on Serial IOCTLS so will keep
            // sending us Serial requests, which will cause the bugcheck 0xCE in Set DTR. Disabeling the interface has the desired effect of
            // disallowing apps from sending us *ANY* requests.
            // This is an AS bug - there is pending email with kentce about this.
            if (bDisableInterface && pDevExt->DeviceClassSymbolicName.Buffer) {
                //
                // set the interface state to inactive to let ActiveSync know to release the handle. Must be done @ PASSIVE_LEVEL
                //
                status = IoSetDeviceInterfaceState(&pDevExt->DeviceClassSymbolicName, FALSE );
                if (NT_SUCCESS(status)) {
                    DbgDump(DBG_WRN, ("IoSetDeviceInterfaceState.1: OFF\n"));
                }
            }
#endif // PnP_AS
        }
        break;

        default:
          break;
   }

   if (IRP_MN_REMOVE_DEVICE != MinorFunction) {

      ReleaseRemoveLock(&pDevExt->RemoveLock, PIrp);

   }

   if (PassDown) {

      IoCopyCurrentIrpStackLocationToNext(PIrp);

      status = IoCallDriver(pDevExt->NextDevice, PIrp);

   } else if (IRP_MN_REMOVE_DEVICE != MinorFunction) {

      IoCompleteRequest(PIrp, IO_NO_INCREMENT);

   }

   DbgDump(DBG_PNP|DBG_TRACE, ("<Pnp (0x%x)\n", status));

   return status;
}



NTSTATUS
SyncCompletion(
    IN PDEVICE_OBJECT PDevObj,
    IN PIRP PIrp,
    IN PKEVENT PSyncEvent
    )
/*++

Routine Description:

    This function is used to signal an event.
    It is used as a default completion routine.

Arguments:

    PDevObj - Pointer to Device Object
    PIrp - Pointer to IRP that is being completed
    PSyncEvent - Pointer to event that we should set

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
   UNREFERENCED_PARAMETER( PDevObj );
   UNREFERENCED_PARAMETER( PIrp );

   KeSetEvent( PSyncEvent, IO_NO_INCREMENT, FALSE );

   return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
Power(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    DbgDump(DBG_PNP, (">PnpPower (%p, %p)\n", DeviceObject, Irp));

    //
    // If the device has been removed, the driver should not pass
    // the IRP down to the next lower driver.
    //
    if ( PnPStateRemoved == pDevExt->PnPState ) {

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status =  STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT );

        return STATUS_DELETE_PENDING;
    }

    //
    // passthrough
    //
    PoStartNextPowerIrp( Irp );
    IoSkipCurrentIrpStackLocation( Irp );

    DbgDump( DBG_PNP, ("<PnpPower\n") );

    return PoCallDriver( pDevExt->NextDevice, Irp );
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\remlock.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    remlock.h

Abstract:

    Common RemoveLock

Authors:

    Jeff Midkiff

Environment:

    kernel mode only

Notes:
    
    Simple binary compatible RemoveLock definitions for Win9x & Win2k
    made to mimic the new Win2k ONLY IoXxxRemoveLock functions.
    See the Win2k DDK for descriptions.

Revision History:

--*/

#include <ntverp.h>
#include <wdm.h>

#if !defined (_REMLOCK_)
#define _REMLOCK_


#if (DBG && WIN2K_LOCKS)

#include "debug.h"

typedef IO_REMOVE_LOCK  REMOVE_LOCK;
typedef PIO_REMOVE_LOCK PREMOVE_LOCK;

__inline VOID InitializeRemoveLock(IN PREMOVE_LOCK Lock) {
    IoInitializeRemoveLock(Lock, 'HECW', 1, 100);
    DbgDump(DBG_LOCKS, ("InitializeRemoveLock: %p, %d\n", Lock, Lock->Common.IoCount));
}

__inline NTSTATUS AcquireRemoveLock(PIO_REMOVE_LOCK Lock, PVOID   Tag)  {
    NTSTATUS status = IoAcquireRemoveLock(Lock, Tag);
    DbgDump(DBG_LOCKS, ("AcquireRemoveLock: %d, %p\n", Lock->Common.IoCount, Tag));
    return status;
}

__inline VOID ReleaseRemoveLock(PIO_REMOVE_LOCK Lock, PVOID   Tag)  {
    IoReleaseRemoveLock(Lock, Tag);
    DbgDump(DBG_LOCKS, ("ReleaseRemoveLock: %d, %p\n", Lock->Common.IoCount, Tag));
}

__inline VOID ReleaseRemoveLockAndWait(PIO_REMOVE_LOCK Lock, PVOID   Tag)  {
    DbgDump(DBG_LOCKS, ("ReleaseRemoveLockAndWait: %d, %p\n", Lock->Common.IoCount, Tag));
    IoReleaseRemoveLockAndWait(Lock, Tag);
}

#else

typedef struct _REMOVE_LOCK {
    
    BOOLEAN     Removed;
    BOOLEAN     Reserved[3];
    LONG        IoCount;
    KEVENT      RemoveEvent;

} REMOVE_LOCK, *PREMOVE_LOCK;

VOID
InitializeRemoveLock(
    IN PREMOVE_LOCK Lock
    );


NTSTATUS
AcquireRemoveLock(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    );


VOID
ReleaseRemoveLock(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    );

    
VOID
ReleaseRemoveLockAndWait(
    IN PREMOVE_LOCK Lock,
    IN OPTIONAL PVOID Tag
    );

#endif

#endif // _REMLOCK_

//EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\usbutils.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

        USBUTILS.C

Abstract:

        USB configuration utility functions.

        These functions are called in the context of PNP_START_DEVICE.
        In order to mark them pageable we don't use a spinlock, 
        which is OK because of the context.

        We do not use look-aside lists to manage pool allocs here since they are one-shot.
        If the allocs fail then the load will fail.

Environment:

        kernel mode only

Revision History:

        07-14-99 : created

Authors:

        Jeff Midkiff (jeffmi)

-- */

#include <wdm.h>
#include <stdio.h>
#include <stdlib.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <ntddser.h>

#include "wceusbsh.h"


NTSTATUS
UsbSelectInterface(
    IN PDEVICE_OBJECT PDevObj,
    IN PUSB_CONFIGURATION_DESCRIPTOR PConfigDesc,
    IN UCHAR AlternateSetting
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWCE1, UsbGetDeviceDescriptor)
#pragma alloc_text(PAGEWCE1, UsbSelectInterface)
#pragma alloc_text(PAGEWCE1, UsbConfigureDevice)
#endif

/*

Sample dump for the Anchor EZ-Link (AN2720) cable:

WCEUSBSH(0): DeviceDescriptor: fbfa8fe8
WCEUSBSH(0): Length 12
WCEUSBSH(0): 
WCEUSBSH(0): Device Descriptor
WCEUSBSH(0): ------------------------
WCEUSBSH(0): bLength         12
WCEUSBSH(0): bDescriptorType 1
WCEUSBSH(0): bcdUSB          100
WCEUSBSH(0): bDeviceClass    ff
WCEUSBSH(0): bDeviceSubClass ff
WCEUSBSH(0): bDeviceProtocol ff
WCEUSBSH(0): bMaxPacketSize0 8
WCEUSBSH(0): idVendor        547
WCEUSBSH(0): idProduct       2720
WCEUSBSH(0): bcdDevice       0
WCEUSBSH(0): iManufacturer   0
WCEUSBSH(0): iProduct        0
WCEUSBSH(0): iSerialNumber   0
WCEUSBSH(0): bNumConfigs     1
WCEUSBSH(0): ------------------------
WCEUSBSH(0): 
WCEUSBSH(0): Configuration Descriptor
WCEUSBSH(0): ----------------
WCEUSBSH(0): bLength             9
WCEUSBSH(0): bDescriptorType     2
WCEUSBSH(0): wTotalLength        d0
WCEUSBSH(0): bNumInterfaces      1
WCEUSBSH(0): bConfigurationValue 1
WCEUSBSH(0): iConfiguration      0
WCEUSBSH(0): bmAttributes        a0
WCEUSBSH(0): MaxPower            32
WCEUSBSH(0): ----------------
WCEUSBSH(0): 
WCEUSBSH(0): Interface Descriptor(0)
WCEUSBSH(0): ------------------------
WCEUSBSH(0): bLength             9
WCEUSBSH(0): bDescriptorType     4
WCEUSBSH(0): bInterfaceNumber    0
WCEUSBSH(0): bAlternateSetting   0
WCEUSBSH(0): bNumEndpoints       2
WCEUSBSH(0): bInterfaceClass     ff
WCEUSBSH(0): bInterfaceSubClass  ff
WCEUSBSH(0): bInterfaceProtocol  ff
WCEUSBSH(0): iInterface          0
WCEUSBSH(0): ------------------------
WCEUSBSH(0): 
WCEUSBSH(0): Interface Definition
WCEUSBSH(0): ------------------------
WCEUSBSH(0): Number of pipes   2
WCEUSBSH(0): Length            38
WCEUSBSH(0): Alt Setting       0
WCEUSBSH(0): Interface Number  0
WCEUSBSH(0): Class             ff
WCEUSBSH(0): Subclass          ff
WCEUSBSH(0): Protocol          ff
WCEUSBSH(0): ------------------------
WCEUSBSH(0): 'COMM' Device Found at Index:0 InterfaceNumber:0 AlternateSetting: 0
WCEUSBSH(0): 
WCEUSBSH(0): Pipe Information (0)
WCEUSBSH(0): ----------------
WCEUSBSH(0): Pipe Type        2
WCEUSBSH(0): Endpoint Addr    82
WCEUSBSH(0): MaxPacketSize    40
WCEUSBSH(0): Interval         0
WCEUSBSH(0): Handle           fbfcef90
WCEUSBSH(0): MaxTransSize     1ffff
WCEUSBSH(0): ----------------
WCEUSBSH(0): 
WCEUSBSH(0): Pipe Information (1)
WCEUSBSH(0): ----------------
WCEUSBSH(0): Pipe Type        2
WCEUSBSH(0): Endpoint Addr    2
WCEUSBSH(0): MaxPacketSize    40
WCEUSBSH(0): Interval         0
WCEUSBSH(0): Handle           fbfcefac
WCEUSBSH(0): MaxTransSize     1ffff
WCEUSBSH(0): ----------------
WCEUSBSH(0): IntPipe: 0 DataOutPipe: fbfcefac DataInPipe: fbfcef90 

*/



NTSTATUS
UsbGetDeviceDescriptor(
    IN PDEVICE_OBJECT PDevObj
    )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status;
   ULONG descSize;
   ULONG urbCDRSize;
   PURB pUrb;

   DbgDump(DBG_USB, (">UsbGetDeviceDescriptor\n"));
   PAGED_CODE();

   urbCDRSize = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);

   pUrb = ExAllocatePool(NonPagedPool, urbCDRSize);

   if (pUrb != NULL) {

      descSize = sizeof(USB_DEVICE_DESCRIPTOR);

      RtlZeroMemory(&pDevExt->DeviceDescriptor, sizeof(USB_DEVICE_DESCRIPTOR));

      UsbBuildGetDescriptorRequest(pUrb,
                                   (USHORT)urbCDRSize,
                                    USB_DEVICE_DESCRIPTOR_TYPE, 
                                    0, 
                                    0,
                                    &pDevExt->DeviceDescriptor,
                                    NULL, 
                                    descSize, 
                                    NULL );

         status = UsbSubmitSyncUrb( PDevObj, pUrb, TRUE, DEFAULT_CTRL_TIMEOUT );
       
         if (STATUS_SUCCESS == status) {
#if DBG        
            if (DebugLevel & DBG_USB) {
               DbgDump(DBG_USB, ("Device Descriptor\n"));
               DbgDump(DBG_USB, ("------------------------\n"));
               DbgDump(DBG_USB, ("bLength         0x%x\n", pDevExt->DeviceDescriptor.bLength));
               DbgDump(DBG_USB, ("bDescriptorType 0x%x\n", pDevExt->DeviceDescriptor.bDescriptorType));
               DbgDump(DBG_USB, ("bcdUSB          0x%x\n", pDevExt->DeviceDescriptor.bcdUSB));
               DbgDump(DBG_USB, ("bDeviceClass    0x%x\n", pDevExt->DeviceDescriptor.bDeviceClass));
               DbgDump(DBG_USB, ("bDeviceSubClass 0x%x\n", pDevExt->DeviceDescriptor.bDeviceSubClass));
               DbgDump(DBG_USB, ("bDeviceProtocol 0x%x\n", pDevExt->DeviceDescriptor.bDeviceProtocol));
               DbgDump(DBG_USB, ("bMaxPacketSize0 0x%x\n", pDevExt->DeviceDescriptor.bMaxPacketSize0));
               DbgDump(DBG_USB, ("idVendor        0x%x\n", pDevExt->DeviceDescriptor.idVendor));
               DbgDump(DBG_USB, ("idProduct       0x%x\n", pDevExt->DeviceDescriptor.idProduct));
               DbgDump(DBG_USB, ("bcdDevice       0x%x\n", pDevExt->DeviceDescriptor.bcdDevice));
               DbgDump(DBG_USB, ("iManufacturer   0x%x\n", pDevExt->DeviceDescriptor.iManufacturer));
               DbgDump(DBG_USB, ("iProduct        0x%x\n", pDevExt->DeviceDescriptor.iProduct));
               DbgDump(DBG_USB, ("iSerialNumber   0x%x\n", pDevExt->DeviceDescriptor.iSerialNumber));
               DbgDump(DBG_USB, ("bNumConfigs     0x%x\n", pDevExt->DeviceDescriptor.bNumConfigurations));
               DbgDump(DBG_USB, ("------------------------\n"));
            }
#endif
         } else {
            DbgDump(DBG_ERR, ("UsbSubmitSyncUrb error: 0x%x\n", status));
            RtlZeroMemory(&pDevExt->DeviceDescriptor, sizeof(USB_DEVICE_DESCRIPTOR));
         }

         ExFreePool(pUrb);

   } else {
      status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("UsbGetDeviceDescriptor 0x%x\n", status));
   }

   if (STATUS_INSUFFICIENT_RESOURCES == status) {

      LogError( NULL,
                PDevObj, 
                0, 0, 0, 
                ERR_GET_DEVICE_DESCRIPTOR,
                status, 
                SERIAL_INSUFFICIENT_RESOURCES,
                pDevExt->DeviceName.Length + sizeof(WCHAR),
                pDevExt->DeviceName.Buffer,
                0, NULL );
   
   } else if (STATUS_SUCCESS != status ) {
      // handles all other failures
      LogError( NULL,
                PDevObj, 
                0, 0, 0, 
                ERR_GET_DEVICE_DESCRIPTOR,
                status, 
                SERIAL_HARDWARE_FAILURE,
                pDevExt->DeviceName.Length + sizeof(WCHAR),
                pDevExt->DeviceName.Buffer,
                0,
                NULL 
                );
   }
   
   DbgDump(DBG_USB, ("<UsbGetDeviceDescriptor 0x%x\n", status));
   
   return status;
}


//
// BUGBUG: currently assumes 1 interface
//

NTSTATUS
UsbSelectInterface(
    IN PDEVICE_OBJECT PDevObj,
    IN PUSB_CONFIGURATION_DESCRIPTOR PConfigDesc,
    IN UCHAR AlternateSetting
    )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   PURB pUrb = NULL;

   ULONG pipe;
   ULONG index = 0;
   UCHAR interfaceNumber = 0;
   PUSBD_INTERFACE_INFORMATION pInterfaceInfo = NULL;
   BOOLEAN foundCommDevice = FALSE;

   USBD_INTERFACE_LIST_ENTRY interfaceList[2] = {0, 0};

   DbgDump(DBG_USB, (">UsbSelectInterface %d\n", AlternateSetting));
   PAGED_CODE();

   if ( !PDevObj || !PConfigDesc ) {
      status = STATUS_INVALID_PARAMETER;
      DbgDump(DBG_ERR, ("UsbSelectInterface 0x%x\n", status));
      goto SelectInterfaceError;
   }
     
   interfaceList[0].InterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                              PConfigDesc,
                                              PConfigDesc,
                                              -1,
                                              AlternateSetting,
                                              -1,
                                              -1,
                                              -1 );

   if (interfaceList[0].InterfaceDescriptor) {

      // interfaceList[1].InterfaceDescriptor = NULL;

      DbgDump(DBG_USB, ("\n"));
      DbgDump(DBG_USB, ("Interface Descriptor(%d)\n", interfaceNumber ));
      DbgDump(DBG_USB, ("------------------------\n"));
      DbgDump(DBG_USB, ("bLength             0x%x\n", interfaceList[0].InterfaceDescriptor->bLength ));
      DbgDump(DBG_USB, ("bDescriptorType     0x%x\n", interfaceList[0].InterfaceDescriptor->bDescriptorType));
      DbgDump(DBG_USB, ("bInterfaceNumber    0x%x\n", interfaceList[0].InterfaceDescriptor->bInterfaceNumber ));
      DbgDump(DBG_USB, ("bAlternateSetting   0x%x\n", interfaceList[0].InterfaceDescriptor->bAlternateSetting ));
      DbgDump(DBG_USB, ("bNumEndpoints       0x%x\n", interfaceList[0].InterfaceDescriptor->bNumEndpoints ));
      DbgDump(DBG_USB, ("bInterfaceClass     0x%x\n", interfaceList[0].InterfaceDescriptor->bInterfaceClass ));
      DbgDump(DBG_USB, ("bInterfaceSubClass  0x%x\n", interfaceList[0].InterfaceDescriptor->bInterfaceSubClass ));
      DbgDump(DBG_USB, ("bInterfaceProtocol  0x%x\n", interfaceList[0].InterfaceDescriptor->bInterfaceProtocol ));
      DbgDump(DBG_USB, ("iInterface          0x%x\n", interfaceList[0].InterfaceDescriptor->iInterface ));
      DbgDump(DBG_USB, ("------------------------\n"));

     pUrb = USBD_CreateConfigurationRequestEx( PConfigDesc, 
                                               &interfaceList[0]);
        
     if ( pUrb ) {
         //
         // perform any pipe initialization here
         //
         PUSBD_INTERFACE_INFORMATION pInitInterfaceInfo = &pUrb->UrbSelectConfiguration.Interface;

         for ( index = 0; 
               index < interfaceList[0].InterfaceDescriptor->bNumEndpoints;
               index++) {

            pInitInterfaceInfo->Pipes[index].MaximumTransferSize = pDevExt->MaximumTransferSize;
            pInitInterfaceInfo->Pipes[index].PipeFlags = 0; 
         
         }

         status = UsbSubmitSyncUrb(PDevObj, pUrb, TRUE, DEFAULT_CTRL_TIMEOUT );

         if (STATUS_SUCCESS == status) {

            pDevExt->ConfigurationHandle = pUrb->UrbSelectConfiguration.ConfigurationHandle;

            pInterfaceInfo = &pUrb->UrbSelectConfiguration.Interface;

            DbgDump(DBG_USB, ("Interface Definition\n" ));
            DbgDump(DBG_USB, ("------------------------\n"));
            DbgDump(DBG_USB, ("Number of pipes   0x%x\n", pInterfaceInfo->NumberOfPipes));
            DbgDump(DBG_USB, ("Length            0x%x\n", pInterfaceInfo->Length));
            DbgDump(DBG_USB, ("Alt Setting       0x%x\n", pInterfaceInfo->AlternateSetting));
            DbgDump(DBG_USB, ("Interface Number  0x%x\n", pInterfaceInfo->InterfaceNumber));
            DbgDump(DBG_USB, ("Class             0x%x\n", pInterfaceInfo->Class));
            DbgDump(DBG_USB, ("Subclass          0x%x\n", pInterfaceInfo->SubClass));
            DbgDump(DBG_USB, ("Protocol          0x%x\n", pInterfaceInfo->Protocol));
            DbgDump(DBG_USB, ("------------------------\n"));

            if ( (pInterfaceInfo->Class == USB_NULL_MODEM_CLASS) && 
                 (pInterfaceInfo->AlternateSetting == AlternateSetting) && 
                 (pInterfaceInfo->NumberOfPipes)) {

                  foundCommDevice = TRUE;

                  pDevExt->UsbInterfaceNumber = pInterfaceInfo->InterfaceNumber;

            } else {
               status = STATUS_NO_SUCH_DEVICE;
               DbgDump(DBG_ERR, ("UsbSelectInterface 0x%x\n", status));
               goto SelectInterfaceError;
            }

         } else {
            DbgDump(DBG_ERR, ("UsbSubmitSyncUrb 0x%x\n", status));
            goto SelectInterfaceError;
         }
       
      } else {
         status = STATUS_INSUFFICIENT_RESOURCES;
         DbgDump(DBG_ERR, ("USBD_CreateConfigurationRequestEx 0x%x\n", status));
         goto SelectInterfaceError;
      }

      DbgDump(DBG_USB, ("\n"));
      DbgDump(DBG_USB, ("Function Device Found at Index:0x%x InterfaceNumber:0x%x AlternateSetting: 0x%x\n", 
                      interfaceNumber, pDevExt->UsbInterfaceNumber, AlternateSetting));

      //
      // We found the interface we want, now discover the pipes
      // The standard interface is defined to contain 1 bulk read, 1 bulk write, and an optional INT pipe
      // BUGBUG: if there are more endpoints then they will overwrite the previous with this code.
      //
      ASSERT( pInterfaceInfo );
      for ( pipe = 0; pipe < pInterfaceInfo->NumberOfPipes; pipe++) {

         PUSBD_PIPE_INFORMATION pPipeInfo;

         pPipeInfo = &pInterfaceInfo->Pipes[pipe];

         DbgDump(DBG_USB, ("\n"));
         DbgDump(DBG_USB, ("Pipe Information (%d)\n", pipe));
         DbgDump(DBG_USB, ("----------------\n"));
         DbgDump(DBG_USB, ("Pipe Type        0x%x\n", pPipeInfo->PipeType));
         DbgDump(DBG_USB, ("Endpoint Addr    0x%x\n", pPipeInfo->EndpointAddress));
         DbgDump(DBG_USB, ("MaxPacketSize    0x%x\n", pPipeInfo->MaximumPacketSize));
         DbgDump(DBG_USB, ("Interval         0x%x\n", pPipeInfo->Interval));
         DbgDump(DBG_USB, ("Handle           0x%x\n", pPipeInfo->PipeHandle));
         DbgDump(DBG_USB, ("MaxTransSize     0x%x\n", pPipeInfo->MaximumTransferSize));
         DbgDump(DBG_USB, ("----------------\n"));

         //
         // save pipe info in our device extension
         //
         if ( USB_ENDPOINT_DIRECTION_IN( pPipeInfo->EndpointAddress ) ) {
            //
            // Bulk Data In pipe
            //
            if ( USB_ENDPOINT_TYPE_BULK == pPipeInfo->PipeType) {
               //
               // Bulk IN pipe
               //
               pDevExt->ReadPipe.wIndex = pPipeInfo->EndpointAddress;
               pDevExt->ReadPipe.hPipe  = pPipeInfo->PipeHandle;
               pDevExt->ReadPipe.MaxPacketSize = pPipeInfo->MaximumPacketSize;

            } else if ( USB_ENDPOINT_TYPE_INTERRUPT == pPipeInfo->PipeType ) {
               //
               // INT Pipe - alloc a notify buffer for 1 packet
               //
               PVOID pOldBuff = NULL;
               PVOID pNewBuff = NULL;

               pDevExt->IntPipe.MaxPacketSize = pPipeInfo->MaximumPacketSize;
            
               if ( pDevExt->IntPipe.MaxPacketSize ) {

                  pNewBuff = ExAllocatePool( NonPagedPool, pDevExt->IntPipe.MaxPacketSize );

                  if ( !pNewBuff ) {
                     status = STATUS_INSUFFICIENT_RESOURCES;
                     DbgDump(DBG_ERR, ("ExAllocatePool: 0x%x\n", status));
                     goto SelectInterfaceError;
                  }

               } else {
                  DbgDump(DBG_ERR, ("No INT MaximumPacketSize\n"));
                  status = STATUS_NO_SUCH_DEVICE;
                  goto SelectInterfaceError;
               }

               if (pDevExt->IntBuff) {
                  pOldBuff = pDevExt->IntBuff;
                  ExFreePool(pOldBuff);
               }

               pDevExt->IntBuff = pNewBuff;
               pDevExt->IntPipe.hPipe  = pPipeInfo->PipeHandle;
               pDevExt->IntPipe.wIndex = pPipeInfo->EndpointAddress;

               pDevExt->IntReadTimeOut.QuadPart = MILLISEC_TO_100NANOSEC( g_lIntTimout );

            } else {
               DbgDump(DBG_ERR, ("Invalid IN PipeType"));
               status = STATUS_NO_SUCH_DEVICE;
               goto SelectInterfaceError;
            }

         } else if ( USB_ENDPOINT_DIRECTION_OUT( pPipeInfo->EndpointAddress ) ) {
            //
            // OUT EPs
            //
            if ( USB_ENDPOINT_TYPE_BULK == pPipeInfo->PipeType ) {
               //
               // Bulk OUT Pipe
               //
               pDevExt->WritePipe.hPipe  = pPipeInfo->PipeHandle;
               pDevExt->WritePipe.wIndex = pPipeInfo->EndpointAddress;
               pDevExt->WritePipe.MaxPacketSize = pPipeInfo->MaximumPacketSize;

            } else {
               DbgDump(DBG_ERR, ("Invalid OUT PipeType"));
               status = STATUS_NO_SUCH_DEVICE;
               goto SelectInterfaceError;
            }

         } else {
               DbgDump(DBG_ERR, ("Invalid EndpointAddress"));
               status = STATUS_NO_SUCH_DEVICE;
               goto SelectInterfaceError;
         }
      }

      DbgDump(DBG_USB, ("\n"));
      DbgDump(DBG_USB, ("INT Pipe: %p\t OUT Pipe: %p\t IN Pipe: %p\n",
                         pDevExt->IntPipe.hPipe, pDevExt->WritePipe.hPipe, pDevExt->ReadPipe.hPipe ));

   } else {
      DbgDump(DBG_ERR, ("USBD_ParseConfigurationDescriptorEx: No match not found\n"));
      status = STATUS_NO_SUCH_DEVICE;
      goto SelectInterfaceError;
   }

   //
   // did we find all of our pipes?
   //
SelectInterfaceError:

   if ( !foundCommDevice || !pDevExt->ReadPipe.hPipe || !pDevExt->WritePipe.hPipe || (STATUS_SUCCESS != status) ) {
      
        LogError( NULL,
                PDevObj, 
                0, 0, 0, 
                ERR_SELECT_INTERFACE,
                status,
                (status == STATUS_INSUFFICIENT_RESOURCES) ? SERIAL_INSUFFICIENT_RESOURCES : SERIAL_HARDWARE_FAILURE,
                pDevExt->DeviceName.Length + sizeof(WCHAR),
                pDevExt->DeviceName.Buffer,
                0, NULL );

   }

   if ( pUrb ) {
      ExFreePool(pUrb);
   }

   DbgDump(DBG_USB, ("<UsbSelectInterface 0x%x\n", status));

   return status;
}



NTSTATUS
UsbConfigureDevice(
    IN PDEVICE_OBJECT PDevObj
    )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PUSB_CONFIGURATION_DESCRIPTOR pConDesc = NULL;
   NTSTATUS status = STATUS_UNSUCCESSFUL;
   PURB  pUrb = NULL;
   ULONG size;
   ULONG urbCDRSize;
   ULONG numConfigs;
   UCHAR config;

   DbgDump(DBG_USB, (">UsbConfigureDevice\n"));
   PAGED_CODE();

   urbCDRSize = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);

   // configure the device
   pUrb = ExAllocatePool(NonPagedPool, urbCDRSize);
   if (pUrb == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("UsbConfigureDevice ERROR: 0x%x\n", status));
      goto ConfigureDeviceError;
   }

   //
   // there may be problems with the 82930 chip, so make this buffer bigger
   // to prevent choking
   //
   size = sizeof(USB_CONFIGURATION_DESCRIPTOR) + 256;

   //
   // get the number of configurations
   //
   numConfigs = pDevExt->DeviceDescriptor.bNumConfigurations;

   //
   // walk all of the configurations looking for a CDC device
   //
   for (config = 0; config < numConfigs; config++) {

      //
      // we will probably only do this once, maybe twice
      //
      while (TRUE) {

         pConDesc = ExAllocatePool(NonPagedPool, size);

         if (pConDesc == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            DbgDump(DBG_ERR, ("ExAllocatePool: 0x%x\n", status));
            goto ConfigureDeviceError;
         }

         //
         // Get descriptor information from the host controller driver (HCD).
         // All interface, endpoint, class-specific, and vendor-specific descriptors 
         // for the configuration also are retrieved
         //
         UsbBuildGetDescriptorRequest( pUrb, 
                                       (USHORT)urbCDRSize,
                                       USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                       config,  // Index
                                       0,       // LanguageId
                                       pConDesc,// TransferBuffer 
                                       NULL,    // TransferBufferMdl
                                       size,    // TransferBufferLength
                                       NULL);   // Link

         status = UsbSubmitSyncUrb( PDevObj, pUrb, TRUE, DEFAULT_CTRL_TIMEOUT );

         if (status != STATUS_SUCCESS) {
            DbgDump(DBG_ERR, ("UsbSubmitSyncUrb: 0x%x\n", status));
            goto ConfigureDeviceError;
         }

         //
         // see if we got enough data, we may get an error in URB because of
         // buffer overrun
         //
         if ((pUrb->UrbControlDescriptorRequest.TransferBufferLength > 0)
              && (pConDesc->wTotalLength > size)) {

            //
            // size of data exceeds current buffer size, so allocate correct
            // size
            //
            size = pConDesc->wTotalLength;

            ExFreePool(pConDesc);
            pConDesc = NULL;

         } else {
            break;
         }
      }

#if DBG
      DbgDump(DBG_USB, ("\n"));
      DbgDump(DBG_USB, ("Configuration Descriptor\n" ));
      DbgDump(DBG_USB, ("----------------\n"));
      DbgDump(DBG_USB, ("bLength             0x%x\n", pConDesc->bLength ));
      DbgDump(DBG_USB, ("bDescriptorType     0x%x\n", pConDesc->bDescriptorType ));
      DbgDump(DBG_USB, ("wTotalLength        0x%x\n", pConDesc->wTotalLength ));
      DbgDump(DBG_USB, ("bNumInterfaces      0x%x\n", pConDesc->bNumInterfaces ));
      DbgDump(DBG_USB, ("bConfigurationValue 0x%x\n", pConDesc->bConfigurationValue ));
      DbgDump(DBG_USB, ("iConfiguration      0x%x\n", pConDesc->iConfiguration ));
      DbgDump(DBG_USB, ("bmAttributes        0x%x\n", pConDesc->bmAttributes ));
      DbgDump(DBG_USB, ("MaxPower            0x%x\n", pConDesc->MaxPower ));
      DbgDump(DBG_USB, ("----------------\n"));
      DbgDump(DBG_USB, ("\n"));
#endif
      
      status = UsbSelectInterface(PDevObj, pConDesc, (UCHAR)g_ulAlternateSetting);

      ExFreePool(pConDesc);
      pConDesc = NULL;

      //
      // found a config we like
      //
      if (status == STATUS_SUCCESS)
         break;

   } // config

ConfigureDeviceError:

   if (pUrb != NULL) {
      ExFreePool(pUrb);
   }

   if (pConDesc != NULL) {
      ExFreePool(pConDesc);
   }

   if (STATUS_INSUFFICIENT_RESOURCES == status) {

      LogError( NULL,
                PDevObj, 
                0, 0, 0, 
                ERR_CONFIG_DEVICE,
                status, 
                SERIAL_INSUFFICIENT_RESOURCES,
                pDevExt->DeviceName.Length + sizeof(WCHAR),
                pDevExt->DeviceName.Buffer,
                0, NULL );
   
   } else if (STATUS_SUCCESS != status ) {
      // handles all other failures
      LogError( NULL,
                PDevObj, 
                0, 0, 0, 
                ERR_CONFIG_DEVICE,
                status, 
                SERIAL_HARDWARE_FAILURE,
                pDevExt->DeviceName.Length + sizeof(WCHAR),
                pDevExt->DeviceName.Buffer,
                0, NULL );
   }

   DbgDump(DBG_USB, ("<UsbConfigureDevice (0x%x)\n", status));
   
   return status;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\serioctl.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

        SERIOCTL.C

Abstract:

        Routines to handle IOCTL_SERIAL_Xxx

Environment:

        kernel mode only

Revision History:

        07-14-99  Jeff Midkiff   (jeffmi)

-- */

#include "wceusbsh.h"

VOID
SerialCompletePendingWaitMasks(
   IN PDEVICE_EXTENSION PDevExt
   );

VOID
SerialCancelWaitMask(
   IN PDEVICE_OBJECT PDevObj, 
   IN PIRP PIrp
   );

//
// Debug spew
//
#if DBG

//
// gets the function code fom an ioctl code, which uses method buffered.
// assumes the device type is serial port
//
#define SERIAL_FNCT_CODE( _ctl_code_ ) ( (_ctl_code_ & 0xFF) >> 2)

//
// debug dumps. no spin lock usage to better simulate free build's run time.
// if these trap in the debugger you know why.
//
#define DBG_DUMP_BAUD_RATE( _PDevExt ) \
{  \
      DbgDump(DBG_SERIAL, ("SerialPort.CurrentBaud: %d\n", _PDevExt->SerialPort.CurrentBaud.BaudRate));  \
}

#define DBG_DUMP_LINE_CONTROL( _PDevExt ) \
{  \
      DbgDump(DBG_SERIAL, ("SerialPort.LineControl.StopBits : 0x%x\n", _PDevExt->SerialPort.LineControl.StopBits ));   \
      DbgDump(DBG_SERIAL, ("SerialPort.LineControl.Parity : 0x%x\n", _PDevExt->SerialPort.LineControl.Parity )); \
      DbgDump(DBG_SERIAL, ("SerialPort.LineControl.WordLength : 0x%x\n", _PDevExt->SerialPort.LineControl.WordLength ));  \
}

#define DBG_DUMP_SERIAL_HANDFLOW( _PDevExt )  \
{  \
      DbgDump(DBG_SERIAL, ("SerialPort.HandFlow.ControlHandShake: 0x%x\n", PDevExt->SerialPort.HandFlow.ControlHandShake));  \
      DbgDump(DBG_SERIAL, ("SerialPort.HandFlow.FlowReplace: 0x%x\n", PDevExt->SerialPort.HandFlow.FlowReplace));  \
      DbgDump(DBG_SERIAL, ("SerialPort.HandFlow.XonLimit: 0x%x\n", PDevExt->SerialPort.HandFlow.XonLimit));  \
      DbgDump(DBG_SERIAL, ("SerialPort.HandFlow.XoffLimit: 0x%x\n", PDevExt->SerialPort.HandFlow.XoffLimit));  \
}

#define DBG_DUMP_SERIAL_TIMEOUTS( _PDevExt ) \
{  \
      DbgDump(DBG_SERIAL|DBG_TIME, ("SerialPort.Timeouts.ReadIntervalTimeout: %d\n", _PDevExt->SerialPort.Timeouts.ReadIntervalTimeout ));         \
      DbgDump(DBG_SERIAL|DBG_TIME, ("SerialPort.Timeouts.ReadTotalTimeoutMultiplier: %d\n", _PDevExt->SerialPort.Timeouts.ReadTotalTimeoutMultiplier )); \
      DbgDump(DBG_SERIAL|DBG_TIME, ("SerialPort.Timeouts.ReadTotalTimeoutConstant: %d\n", _PDevExt->SerialPort.Timeouts.ReadTotalTimeoutConstant ));  \
      DbgDump(DBG_SERIAL|DBG_TIME, ("SerialPort.Timeouts.WriteTotalTimeoutMultiplier: %d\n", _PDevExt->SerialPort.Timeouts.WriteTotalTimeoutMultiplier ));  \
      DbgDump(DBG_SERIAL|DBG_TIME, ("SerialPort.Timeouts.WriteTotalTimeoutConstant: %d\n", _PDevExt->SerialPort.Timeouts.WriteTotalTimeoutConstant ));   \
}

#define DBG_DUMP_SERIAL_CHARS( _PDevExt)     \
{  \
      DbgDump(DBG_SERIAL, ("SerialPort.SpecialChars.EofChar:   0x%x\n", _PDevExt->SerialPort.SpecialChars.EofChar )); \
      DbgDump(DBG_SERIAL, ("SerialPort.SpecialChars.ErrorChar: 0x%x\n", _PDevExt->SerialPort.SpecialChars.ErrorChar )); \
      DbgDump(DBG_SERIAL, ("SerialPort.SpecialChars.BreakChar: 0x%x\n", _PDevExt->SerialPort.SpecialChars.BreakChar )); \
      DbgDump(DBG_SERIAL, ("SerialPort.SpecialChars.EventChar: 0x%x\n", _PDevExt->SerialPort.SpecialChars.EventChar )); \
      DbgDump(DBG_SERIAL, ("SerialPort.SpecialChars.XonChar:   0x%x\n", _PDevExt->SerialPort.SpecialChars.XonChar )); \
      DbgDump(DBG_SERIAL, ("SerialPort.SpecialChars.XoffChar:  0x%x\n", _PDevExt->SerialPort.SpecialChars.XoffChar )); \
}

#else
#define DBG_DUMP_BAUD_RATE( _PDevExt )
#define DBG_DUMP_LINE_CONTROL( _PDevExt )
#define DBG_DUMP_SERIAL_HANDFLOW( _PDevExt )
#define DBG_DUMP_SERIAL_TIMEOUTS( _PDevExt )
#define DBG_DUMP_SERIAL_CHARS( _PDevExt)
#endif

__inline
NTSTATUS
IoctlSetSerialValue(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP PIrp, 
   ULONG Size, 
   IN OUT PVOID PDest
   )
{
   PIO_STACK_LOCATION pIrpSp;
   NTSTATUS status = STATUS_DELETE_PENDING;
   ULONG information = Size;
   KIRQL oldIrql;

   KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);

    pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < Size) {

     information = 0;
     status = STATUS_BUFFER_TOO_SMALL;
     DbgDump(DBG_ERR, ("IoctlSetSerialValue: (0x%x)\n", status));

    } else {

     memcpy( PDest, PIrp->AssociatedIrp.SystemBuffer, Size);
     status = STATUS_SUCCESS;

    }

   KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
   
   PIrp->IoStatus.Information = information;
   PIrp->IoStatus.Status = status;
   
   return status;
}

__inline
NTSTATUS
IoctlGetSerialValue(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP PIrp, 
   ULONG Size, 
   IN PVOID PSrc
   )
{
   PIO_STACK_LOCATION pIrpSp;
   NTSTATUS status = STATUS_DELETE_PENDING;
   ULONG information = Size;
   KIRQL oldIrql;

   KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);
   
    pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < Size) {

         information = 0;
         status = STATUS_BUFFER_TOO_SMALL;
         DbgDump(DBG_ERR, ("IoctlGetSerialValue: (0x%x)\n", status));

    } else {

     memcpy( PIrp->AssociatedIrp.SystemBuffer, PSrc, Size );
     status = STATUS_SUCCESS;

    }

   KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);

   PIrp->IoStatus.Information = information;
   PIrp->IoStatus.Status = status;
   return status;
}


__inline
NTSTATUS
SetBaudRate(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">SetBaudRate(%p)\n", PIrp));

   status = IoctlSetSerialValue(PDevExt,
                                PIrp, 
                                sizeof( PDevExt->SerialPort.CurrentBaud ),
                                &PDevExt->SerialPort.CurrentBaud );

   DBG_DUMP_BAUD_RATE(PDevExt);
   
   DbgDump(DBG_SERIAL, ("<SetBaudRate %x\n", status));

   return status;
}


__inline
NTSTATUS
GetBaudRate(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">GetBaudRate(%p)\n", PIrp));
   
   status = IoctlGetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof( PDevExt->SerialPort.CurrentBaud ),
                        &PDevExt->SerialPort.CurrentBaud);

   DBG_DUMP_BAUD_RATE(PDevExt);

   DbgDump(DBG_SERIAL, ("<GetBaudRate %x\n", status));

   return status;
}



__inline
NTSTATUS
SetLineControl(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;
   
   DbgDump(DBG_SERIAL, (">SetLineControl(%p)\n", PIrp));
   
   status = IoctlSetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof(PDevExt->SerialPort.LineControl),
                        &PDevExt->SerialPort.LineControl);

   DBG_DUMP_LINE_CONTROL(  PDevExt );

   DbgDump(DBG_SERIAL, ("<SetLineControl %x\n",
                                     status));

   return status;
}



__inline
NTSTATUS
GetLineControl(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status= STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">GetLineControl(%p)\n", PIrp));

   status = IoctlGetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof(PDevExt->SerialPort.LineControl),
                        &PDevExt->SerialPort.LineControl );

   DBG_DUMP_LINE_CONTROL(  PDevExt );

   DbgDump(DBG_SERIAL, ("<GetLineControl %x\n",
                                     status));

   return status;
}



__inline
NTSTATUS
SetTimeouts(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL|DBG_TIME,(">SetTimeouts(%p)\n", PIrp));

   status = IoctlSetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof(PDevExt->SerialPort.Timeouts),
                        &PDevExt->SerialPort.Timeouts);

   DBG_DUMP_SERIAL_TIMEOUTS( PDevExt );

   DbgDump(DBG_SERIAL|DBG_TIME,("<SetTimeouts %x\n", status));

   return status;
}



__inline
NTSTATUS
GetTimeouts(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL|DBG_TIME, (">GetTimeouts(%p)\n", PIrp));

   status = IoctlGetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof(PDevExt->SerialPort.Timeouts),
                        &PDevExt->SerialPort.Timeouts);

   DBG_DUMP_SERIAL_TIMEOUTS( PDevExt );

   DbgDump(DBG_SERIAL|DBG_TIME, ("<GetTimeouts %x\n", status));

   return status;
}



__inline
NTSTATUS
SetSpecialChars( 
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">SetSpecialChars(%p)\n", PIrp));

   status = IoctlSetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof(PDevExt->SerialPort.SpecialChars),
                        &PDevExt->SerialPort.SpecialChars);

   DBG_DUMP_SERIAL_CHARS( PDevExt);

   DbgDump(DBG_SERIAL, ("<SetSpecialChars %x\n", status));

   return status;
}



__inline
NTSTATUS
GetSpecialChars(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">GetSpecialChars(%p)\n", PIrp));

   status = IoctlGetSerialValue( PDevExt, 
                        PIrp, 
                        sizeof(PDevExt->SerialPort.SpecialChars),
                        &PDevExt->SerialPort.SpecialChars);

   DBG_DUMP_SERIAL_CHARS( PDevExt);

   DbgDump(DBG_SERIAL, ("<GetSpecialChars %x\n", status));

   return status;
}



__inline
NTSTATUS
SetClearDTR(
    IN PDEVICE_EXTENSION PDevExt,
    IN PIRP Irp,
    IN BOOLEAN Set
    )
{
    NTSTATUS status = STATUS_DELETE_PENDING;
    KIRQL irql;
    USHORT usState = 0; // DRT/RTS state to send to USB device
    USHORT usOldMSR = 0;
    USHORT usDeltaMSR = 0;
    ULONG  ulOldHistoryMask = 0;
    ULONG  ulOldRS232Lines = 0;

    DbgDump(DBG_SERIAL, (">SetClearDTR (%x, %x)\n", PDevExt->DeviceObject, Set));

    KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

    //
    // we queue the user's Irp because this operation may take some time,
    // and we only want to hit the USB with one of these requests at a time.
    //
    if ( NULL != PDevExt->SerialPort.ControlIrp ) {
        DbgDump(DBG_WRN, ("SetClearDTR: STATUS_DEVICE_BUSY\n"));
        status = STATUS_DEVICE_BUSY;
        KeReleaseSpinLock(&PDevExt->ControlLock, irql);   
        return status;
    }

    if ( !CanAcceptIoRequests(PDevExt->DeviceObject, FALSE, TRUE) || 
         !NT_SUCCESS(AcquireRemoveLock(&PDevExt->RemoveLock, Irp)) ) 
    {
        status = STATUS_DELETE_PENDING;
        DbgDump(DBG_ERR, ("SetClearDTR: 0x%x\n", status));
        KeReleaseSpinLock( &PDevExt->ControlLock, irql);
        return status;
    }

    //
    // Queue the Irp.
    //
    ASSERT( NULL == PDevExt->SerialPort.ControlIrp );
    PDevExt->SerialPort.ControlIrp = Irp;

    usOldMSR         = PDevExt->SerialPort.ModemStatus;
    ulOldRS232Lines  = PDevExt->SerialPort.RS232Lines;
    ulOldHistoryMask = PDevExt->SerialPort.HistoryMask;

    if (PDevExt->SerialPort.RS232Lines & SERIAL_RTS_STATE) {
        usState |= USB_COMM_RTS;
    }

    if (Set) {

        PDevExt->SerialPort.RS232Lines |= SERIAL_DTR_STATE;

        //
        // If there is an INT pipe then MSR could get modified
        //
        PDevExt->SerialPort.ModemStatus |= SERIAL_MSR_DSR | SERIAL_MSR_DCD;

        usState |= USB_COMM_DTR;

    } else {

        PDevExt->SerialPort.RS232Lines &= ~SERIAL_DTR_STATE;

        //
        // If there is an INT pipe then MSR could get modified
        //
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DSR & ~SERIAL_MSR_DCD;
    }

    // see what has changed in the MSR
    usDeltaMSR = usOldMSR ^ PDevExt->SerialPort.ModemStatus;

    if (usDeltaMSR & (SERIAL_MSR_DSR|SERIAL_MSR_DCD)) {
        // set delta MSR bits
        PDevExt->SerialPort.ModemStatus |= SERIAL_MSR_DDSR | SERIAL_MSR_DDCD;
    }

    DbgDump(DBG_SERIAL, ("SerialPort.RS232Lines : 0x%x\n", PDevExt->SerialPort.RS232Lines ));
    DbgDump(DBG_SERIAL, ("SerialPort.ModemStatus: 0x%x\n", PDevExt->SerialPort.ModemStatus ));
    DbgDump(DBG_SERIAL, ("SerialPort.HistoryMask: 0x%x\n", PDevExt->SerialPort.HistoryMask ));

    KeReleaseSpinLock(&PDevExt->ControlLock, irql);

    //
    // set DTR/RTS on the USB device
    //
    status = UsbClassVendorCommand( PDevExt->DeviceObject,
                                    USB_COMM_SET_CONTROL_LINE_STATE,
                                    usState,
                                    PDevExt->UsbInterfaceNumber, 
                                    NULL,
                                    NULL, 
                                    FALSE, 
                                    WCEUSB_CLASS_COMMAND );

    DbgDump(DBG_SERIAL|DBG_READ_LENGTH, ("USB_COMM_SET_CONTROL_LINE_STATE(1, State: 0x%x, Status: 0x%x)\n", usState, status ));

_EzLink:
    if ( STATUS_SUCCESS == status ) {

        KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

        // signal history massk 
        if ( usDeltaMSR &  (SERIAL_MSR_DSR|SERIAL_MSR_DCD) ) {
            PDevExt->SerialPort.HistoryMask |= SERIAL_EV_DSR | SERIAL_EV_RLSD;
        }

        PDevExt->EP0DeviceErrors = 0;

        DbgDump(DBG_SERIAL, ("SerialPort.HistoryMask: 0x%x\n", PDevExt->SerialPort.HistoryMask ));

        KeReleaseSpinLock(&PDevExt->ControlLock, irql);
   
    } else {
        // Ez-link
        if ((PDevExt->DeviceDescriptor.idVendor  != 0x0547) && 
           ((PDevExt->DeviceDescriptor.idProduct != 0x2710) && (PDevExt->DeviceDescriptor.idProduct != 0x2720)))
        {
            // WINCE BUG 19544: 
            // AS 3.1 does not handle STATUS_TIMEOUT, so will not see a problem. 
            // A side effect is that it could sit spinning the green light trying to connect forever. 
            // However, this is a different case from BUG 19544, which is a disconnect problem.
            // If we return failure then it will keep pounding us with Set DTR Irps.
            // This would be OK if AS would recognize that we disabled the interface, but it won't - see above.
            // You only see this bug when you have a flakey device (iPAQ, hung Jornada, etc.) that times out or 
            // fails to properly handle the command. To prevent the bugcheck 0xCE the choices as of today are:
            //    a) let it spin and never connect for these bad devices (iPAQ). Fix your firmware.
            //    b) fix AcvtiveSync
            // I prefer both - pending email with COMPAQ (HTC) and ActiveSync. When AS gets their changes in then we need to 
            // investigate again.
            status = STATUS_TIMEOUT;

           KeAcquireSpinLock( &PDevExt->ControlLock, &irql);

           if ( ++PDevExt->EP0DeviceErrors < MAX_EP0_DEVICE_ERRORS) {
       
               DbgDump(DBG_ERR, ("USB_COMM_SET_CONTROL_LINE_STATE error: 0x%x\n", status ));
               //
               // The command failed. Reset the old states, propogate status, and disable the device interface. 
               // This should stop AS 3.1 from pounding us with Set DTR Irps.
               // However, AS does not participate in PnP well if we disable the interface
               // (see the note in IRP_MN_QUERY_PNP_DEVICE_STATE). Disabeling the 
               // interface has the desired effect of notifying apps to stop sending us requests and Close the handle.
               //
               PDevExt->SerialPort.ModemStatus = usOldMSR;
               PDevExt->SerialPort.HistoryMask = ulOldHistoryMask;
               PDevExt->SerialPort.RS232Lines  = ulOldRS232Lines;

               KeReleaseSpinLock( &PDevExt->ControlLock, irql);

            } else {
        
                 DbgDump(DBG_ERR, ("*** UNRECOVERABLE DEVICE ERROR.2: (0x%x, %d)  No longer Accepting Requests ***\n", status, PDevExt->EP0DeviceErrors ));

                 // mark as PNP_DEVICE_FAILED
                 InterlockedExchange(&PDevExt->AcceptingRequests, FALSE);

                 KeReleaseSpinLock( &PDevExt->ControlLock, irql);

                 IoInvalidateDeviceState( PDevExt->PDO );

                 LogError( NULL,
                           PDevExt->DeviceObject,
                           0, 0, 
                           (UCHAR)PDevExt->EP0DeviceErrors, 
                           ERR_NO_DTR,
                           status,
                           SERIAL_HARDWARE_FAILURE,
                           PDevExt->DeviceName.Length + sizeof(WCHAR),
                           PDevExt->DeviceName.Buffer,
                           0,
                           NULL );
            }

        } else {
            DbgDump(DBG_WRN, ("Ez-Link\n" ));
            status = STATUS_SUCCESS;
            goto _EzLink;
        }
    }

    //
    // finally, release any pending serial events
    //
    ProcessSerialWaits(PDevExt);

    //
    // DeQueue the user's Irp. It gets completed in the SerialIoctl dispatch
    //
    KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

    ReleaseRemoveLock(&PDevExt->RemoveLock, Irp);

    ASSERT( NULL != PDevExt->SerialPort.ControlIrp );

    PDevExt->SerialPort.ControlIrp = NULL;

    KeReleaseSpinLock(&PDevExt->ControlLock, irql);

    DbgDump(DBG_SERIAL, ("<SetClearDTR %x\n", status ));

    return status;
}



__inline
NTSTATUS
SetClearRTS(
    IN PDEVICE_EXTENSION PDevExt,
    IN PIRP Irp,
    IN BOOLEAN Set
    )
{
    NTSTATUS status = STATUS_DELETE_PENDING;
    KIRQL irql;
    USHORT usState = 0; // DRT/RTS state to send to USB device
    USHORT usOldMSR = 0;
    USHORT usDeltaMSR = 0;
    ULONG  ulOldRS232Lines = 0;
    ULONG  ulOldHistoryMask = 0;

    DbgDump(DBG_SERIAL, (">SetClearRTS (%x, %x)\n", PDevExt->DeviceObject, Set));

    KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

    //
    // we queue the user's Irp because this operation may take some time,
    // and we only want to hit the USB with one of these requests at a time.
    //
    if ( NULL != PDevExt->SerialPort.ControlIrp ) {
        status = STATUS_DEVICE_BUSY;
        DbgDump(DBG_WRN, ("SetClearRTS.1: 0x%x\n", status));
        KeReleaseSpinLock(&PDevExt->ControlLock, irql);   
        return status;
    }

    if ( !CanAcceptIoRequests(PDevExt->DeviceObject, FALSE, TRUE) ||
         !NT_SUCCESS(AcquireRemoveLock(&PDevExt->RemoveLock, Irp)) )
    {
        status = STATUS_DELETE_PENDING;
        DbgDump(DBG_ERR, ("SetClearRTS.2: 0x%x\n", status));
        KeReleaseSpinLock(&PDevExt->ControlLock, irql);
        return status;
    }

    //
    // Queue the Irp.
    //
    ASSERT( NULL == PDevExt->SerialPort.ControlIrp );
    PDevExt->SerialPort.ControlIrp = Irp;

    usOldMSR = PDevExt->SerialPort.ModemStatus;
    ulOldRS232Lines = PDevExt->SerialPort.RS232Lines;
    ulOldHistoryMask = PDevExt->SerialPort.HistoryMask;

    if (PDevExt->SerialPort.RS232Lines & SERIAL_DTR_STATE) {
        usState |= USB_COMM_DTR;
    }

    if (Set) {

        PDevExt->SerialPort.RS232Lines |= SERIAL_RTS_STATE;

        //
        // If there is an INT pipe then MSR could get modified
        //
        PDevExt->SerialPort.ModemStatus |= SERIAL_MSR_CTS;

        usState |= USB_COMM_RTS;

    } else {

        PDevExt->SerialPort.RS232Lines &= ~SERIAL_RTS_STATE;

        //
        // If there is an INT pipe then MSR could get modified
        //
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_CTS;
    }

    // see what has changed in the MSR
    usDeltaMSR = usOldMSR ^ PDevExt->SerialPort.ModemStatus;

    if (usDeltaMSR & SERIAL_MSR_CTS) {
        // set delta MSR bits
        PDevExt->SerialPort.ModemStatus |= SERIAL_MSR_DCTS;
    }

    DbgDump(DBG_SERIAL, ("SerialPort.RS232Lines : 0x%x\n", PDevExt->SerialPort.RS232Lines ));
    DbgDump(DBG_SERIAL, ("SerialPort.ModemStatus: 0x%x\n", PDevExt->SerialPort.ModemStatus));
    DbgDump(DBG_SERIAL, ("SerialPort.HistoryMask: 0x%x\n", PDevExt->SerialPort.HistoryMask ));

    KeReleaseSpinLock(&PDevExt->ControlLock, irql);

    //
    // set DTR/RTS on the USB device
    //
    status = UsbClassVendorCommand( PDevExt->DeviceObject,
                                    USB_COMM_SET_CONTROL_LINE_STATE, 
                                    usState,
                                    PDevExt->UsbInterfaceNumber, 
                                    NULL,
                                    NULL, 
                                    FALSE, 
                                    WCEUSB_CLASS_COMMAND );

    DbgDump(DBG_SERIAL|DBG_READ_LENGTH, ("USB_COMM_SET_CONTROL_LINE_STATE(2, State: 0x%x, Status: 0x%x)\n", usState, status ));

_EzLink:
    if ( STATUS_SUCCESS == status ) {

        KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

    // signal history mask
    if ( usDeltaMSR & SERIAL_MSR_CTS ) {
        PDevExt->SerialPort.HistoryMask |= SERIAL_EV_CTS;
    }

    PDevExt->EP0DeviceErrors = 0;

    DbgDump(DBG_SERIAL, ("SerialPort.HistoryMask: 0x%x\n", PDevExt->SerialPort.HistoryMask ));

    KeReleaseSpinLock(&PDevExt->ControlLock, irql);

    } else {
        // Ez-link
        if ((PDevExt->DeviceDescriptor.idVendor  != 0x0547) && 
           ((PDevExt->DeviceDescriptor.idProduct != 0x2710) && (PDevExt->DeviceDescriptor.idProduct != 0x2720)))
        {
            // AS 3.1 does not handle STATUS_TIMEOUT, so will not see a problem. 
            // A side effect is that it could sit spinning the green light trying to connect forever. 
            // However, this is a different case from BUG 19544, which is a disconnect problem.
            // If we return failure then it will keep pounding us with Set DTR Irps.
            // This would be OK if AS would recognize that we disabled the interface, but it won't - see above.
            // You only see this bug when you have a flakey device (iPAQ, hung Jornada, etc.) that times out or 
            // fails to properly handle the command. To prevent the bugcheck 0xCE the choices as of today are:
            //    a) let it spin and never connect for these bad devices (iPAQ). Fix your firmware.
            //    b) fix AcvtiveSync
            // I prefer both - pending email with COMPAQ (HTC) and ActiveSync. When AS gets their changes in then we need to 
            // investigate again.
           status = STATUS_TIMEOUT;

           KeAcquireSpinLock( &PDevExt->ControlLock, &irql);

           TEST_TRAP();

           if ( ++PDevExt->EP0DeviceErrors < MAX_EP0_DEVICE_ERRORS) {

               DbgDump(DBG_ERR, ("USB_COMM_SET_CONTROL_LINE_STATE error: %x\n", status ));
               //
               // The command failed. Reset the old states, propogate status, and disable the device interface. 
               // This should stop AS 3.1 from pounding us with Set DTR Irps.
               // However, AS does not participate in PnP well if we disable the interface
               // (see the note in IRP_MN_QUERY_PNP_DEVICE_STATE). Disabeling the 
               // interface has the desired effect of notifying apps to stop sending us requests and Close the handle.
               //
               PDevExt->SerialPort.ModemStatus = usOldMSR;
               PDevExt->SerialPort.RS232Lines  = ulOldRS232Lines;
               PDevExt->SerialPort.HistoryMask = ulOldHistoryMask;

               KeReleaseSpinLock( &PDevExt->ControlLock, irql);
    
            } else {
        
                 DbgDump(DBG_ERR, ("*** UNRECOVERABLE DEVICE ERROR.3: (0x%x, %d)  No longer Accepting Requests ***\n", status, PDevExt->EP0DeviceErrors ));

                 // mark as PNP_DEVICE_FAILED
                 InterlockedExchange(&PDevExt->AcceptingRequests, FALSE);

                 KeReleaseSpinLock( &PDevExt->ControlLock, irql);

                 IoInvalidateDeviceState( PDevExt->PDO );

                 LogError( NULL,
                           PDevExt->DeviceObject,
                           0, 0, 
                           (UCHAR)PDevExt->EP0DeviceErrors, 
                           ERR_NO_RTS,
                           status,
                           SERIAL_HARDWARE_FAILURE,
                           PDevExt->DeviceName.Length + sizeof(WCHAR),
                           PDevExt->DeviceName.Buffer,
                           0,
                           NULL );

            }

        } else {
            DbgDump(DBG_WRN, ("Ez-Link\n" ));
            status = STATUS_SUCCESS;
            goto _EzLink;
        }
    }

    //
    // finally, release any pending serial events
    //
    ProcessSerialWaits(PDevExt);

    //
    // DeQueue the user's Irp. It gets completed in the SerialIoctl dispatch
    //
    KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

    ReleaseRemoveLock(&PDevExt->RemoveLock, Irp);

    ASSERT( NULL != PDevExt->SerialPort.ControlIrp );

    PDevExt->SerialPort.ControlIrp = NULL;

    KeReleaseSpinLock(&PDevExt->ControlLock, irql);

    DbgDump(DBG_SERIAL, ("<SetClearRTS %x\n", status ));

    return status;
}



__inline
NTSTATUS
GetDtrRts(
   IN PIRP Irp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">GetDtrRts (%p)\n", Irp));

   status = IoctlGetSerialValue( PDevExt, 
                           Irp, 
                           sizeof(PDevExt->SerialPort.RS232Lines),
                           &PDevExt->SerialPort.RS232Lines);

   DbgDump(DBG_SERIAL, ("SerialPort.RS232Lines: 0x%x\n", PDevExt->SerialPort.RS232Lines ));

   DbgDump(DBG_SERIAL, ("<GetDtrRts %x\n", status));

   return status;
}



__inline
NTSTATUS
SerialResetDevice(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP Irp,
   IN BOOLEAN ClearDTR
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;
   BOOLEAN bRelease = TRUE;
   KIRQL oldIrql;
   
   DbgDump(DBG_SERIAL, (">SerialResetDevice (%x, %d)\n", PDevExt->DeviceObject, ClearDTR ));

   KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);

  ASSERT_SERIAL_PORT( PDevExt->SerialPort );

  PDevExt->SerialPort.SupportedBauds = SERIAL_BAUD_075 | SERIAL_BAUD_110 | SERIAL_BAUD_150
                          | SERIAL_BAUD_300 | SERIAL_BAUD_600 | SERIAL_BAUD_1200 
                          | SERIAL_BAUD_1800 | SERIAL_BAUD_2400 | SERIAL_BAUD_4800 | SERIAL_BAUD_7200
                          | SERIAL_BAUD_9600 | SERIAL_BAUD_14400 | SERIAL_BAUD_19200 | SERIAL_BAUD_38400 | SERIAL_BAUD_56K
                          | SERIAL_BAUD_128K | SERIAL_BAUD_57600  | SERIAL_BAUD_115200 | SERIAL_BAUD_USER;

  PDevExt->SerialPort.CurrentBaud.BaudRate = 115200;

  PDevExt->SerialPort.LineControl.StopBits = STOP_BIT_1;
  PDevExt->SerialPort.LineControl.Parity = NO_PARITY;
  PDevExt->SerialPort.LineControl.WordLength = SERIAL_DATABITS_8;

  PDevExt->SerialPort.HandFlow.ControlHandShake = 0;
  PDevExt->SerialPort.HandFlow.FlowReplace = 0;
  PDevExt->SerialPort.HandFlow.XonLimit = 0;
  PDevExt->SerialPort.HandFlow.XoffLimit = 0;

  RtlZeroMemory( &PDevExt->SerialPort.Timeouts, sizeof(SERIAL_TIMEOUTS) );
  RtlZeroMemory( &PDevExt->SerialPort.SpecialChars, sizeof(SERIAL_CHARS) );

  PDevExt->SerialPort.RS232Lines = 0;
  PDevExt->SerialPort.HistoryMask = 0;
  PDevExt->SerialPort.WaitMask = 0;
  PDevExt->SerialPort.ModemStatus = 0;

  DbgDump(DBG_SERIAL, ("SerialPort.RS232Lines : 0x%x\n",  PDevExt->SerialPort.RS232Lines ));
  DbgDump(DBG_SERIAL, ("SerialPort.ModemStatus: 0x%x\n", PDevExt->SerialPort.ModemStatus));
  DbgDump(DBG_SERIAL, ("SerialPort.HistoryMask: 0x%x\n", PDevExt->SerialPort.HistoryMask));

  if ( PDevExt->SerialPort.CurrentWaitMaskIrp ) {
     KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
     bRelease = FALSE;
     SerialCompletePendingWaitMasks(PDevExt);
  }

  //
  // drop the RTS/DTR lines on the USB device
  //
  if (bRelease) {
     KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
     bRelease = FALSE;
  }

  status = ClearDTR ? SetClearDTR(PDevExt, Irp, FALSE) : STATUS_SUCCESS;

  if (bRelease) {
      KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
  }

  DBG_DUMP_BAUD_RATE(PDevExt);
  DBG_DUMP_LINE_CONTROL(PDevExt);
  DBG_DUMP_SERIAL_HANDFLOW(PDevExt);
  DBG_DUMP_SERIAL_TIMEOUTS(PDevExt);
  DBG_DUMP_SERIAL_CHARS(PDevExt);

  DbgDump(DBG_SERIAL, ("<SerialResetDevice %x\n", status));

  return status;
}



__inline
NTSTATUS
SetBreak( 
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt,
   USHORT Time
   )
{
   UNREFERENCED_PARAMETER(PIrp);
   UNREFERENCED_PARAMETER(PDevExt);
   UNREFERENCED_PARAMETER(Time);

   DbgDump(DBG_SERIAL, (">SetBreak(%p)\n",  PIrp));
   DbgDump(DBG_SERIAL, ("<SetBreak %x\n", STATUS_NOT_SUPPORTED));
   
   return STATUS_NOT_SUPPORTED;
}



__inline
NTSTATUS
SetQueueSize(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
/* ++

   IOCTL_SERIAL_SET_QUEUE_SIZE
   Operation
   Resizes the driver's internal typeahead and input buffers.
   The driver can allocate buffers larger than the requested sizes
   and can refuse to allocate buffers larger than its capacity.

   Input
   Parameters.DeviceIoControl.InputBufferLength 
   indicates the size in bytes (must be >= sizeof(SERIAL_QUEUE_SIZE)) 
   of the buffer at Irp->AssociatedIrp.SystemBuffer, containing the 
   InSize and OutSize specifications.

   Output
   None

   I/O Status Block
   The Information field is set to zero. 
   The Status field is set to STATUS_SUCCESS or 
   possibly to STATUS_BUFFER_TOO_SMALL or 
   STATUS_INSUFFICIENT_RESOURCES if the driver 
   cannot satisfy the request by allocating more memory.

-- */
{
   NTSTATUS status = STATUS_DELETE_PENDING;
   
   UNREFERENCED_PARAMETER(PIrp);
   UNREFERENCED_PARAMETER(PDevExt);

   DbgDump(DBG_SERIAL, (">SetQueueSize (%p)\n",  PIrp));

   // we pretend to set this, but don't really care
   status = IoctlSetSerialValue(PDevExt, 
                                PIrp, 
                                sizeof(PDevExt->SerialPort.FakeQueueSize ),
                                &PDevExt->SerialPort.FakeQueueSize );

   DbgDump( DBG_SERIAL, ("SerialPort.FakeQueueSize.InSize = 0x%x\n", PDevExt->SerialPort.FakeQueueSize.InSize ));
   DbgDump( DBG_SERIAL, ("SerialPort.FakeQueueSize.OutSize = 0x%x\n", PDevExt->SerialPort.FakeQueueSize.OutSize));

   DbgDump(DBG_SERIAL, ("DataOutMaxPacketSize = %d\n", PDevExt->WritePipe.MaxPacketSize));
   DbgDump(DBG_SERIAL, ("UsbReadBuffSize = %d\n", PDevExt->UsbReadBuffSize ));

#if USE_RING_BUFF      
   DbgDump(DBG_SERIAL, ("Internal RingBuffer Size: %d\n", PDevExt->RingBuff.Size ));
#endif   
         
   DbgDump(DBG_SERIAL, ("<SetQueueSize %x\n", status));

   return status;
}



__inline
NTSTATUS
GetWaitMask(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">GetWaitMask (%p)\n",  PIrp));

   status = IoctlGetSerialValue(PDevExt, 
                                PIrp, 
                                sizeof(PDevExt->SerialPort.WaitMask),
                                &PDevExt->SerialPort.WaitMask);

   DbgDump(DBG_SERIAL, ("Current SerialPort.WaitMask = 0x%x\n", PDevExt->SerialPort.WaitMask));

   DbgDump(DBG_SERIAL, ("<GetWaitMask %x\n", status));

   return status;
}



__inline
NTSTATUS
SetWaitMask(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
/* ++

   IOCTL_SERIAL_SET_WAIT_MASK
   Operation
   Causes the driver to track the specified events, or, 
   if the specified value is zero, to complete pending waits.

   Input
   Parameters.DeviceIoControl.InputBufferLength 
   indicates the size in bytes (must be >= sizeof(ULONG)) of
   the bitmask at Irp->AssociatedIrp.SystemBuffer.

   Output
   None

   I/O Status Block
   The Information field is set to zero. 
   The Status field is set to STATUS_SUCCESS or 
   possibly to STATUS_PENDING, STATUS_CANCELLED, 
   STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_PARAMETER.

-- */
{
  PULONG pWaitMask = (PULONG)PIrp->AssociatedIrp.SystemBuffer;
  NTSTATUS status = STATUS_DELETE_PENDING;
  KIRQL oldIrql;
  PIO_STACK_LOCATION pIrpSp;

  DbgDump(DBG_SERIAL, (">SetWaitMask (%p)\n",  PIrp));

  KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);
   
  PIrp->IoStatus.Information = 0;

  pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

  if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) {

     status = STATUS_BUFFER_TOO_SMALL;
     DbgDump(DBG_ERR, ("SetWaitMask: (0x%x)\n", status));
     KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
  
  } else {
  
     // make sure it's a valid request
     if (*pWaitMask & ~(SERIAL_EV_RXCHAR   |
                        SERIAL_EV_RXFLAG   |
                        SERIAL_EV_TXEMPTY  |
                        SERIAL_EV_CTS      |
                        SERIAL_EV_DSR      |
                        SERIAL_EV_RLSD     |
                        SERIAL_EV_BREAK    |
                        SERIAL_EV_ERR      |
                        SERIAL_EV_RING     |
                        SERIAL_EV_PERR     |
                        SERIAL_EV_RX80FULL |
                        SERIAL_EV_EVENT1   |
                        SERIAL_EV_EVENT2) ) {

        status = STATUS_INVALID_PARAMETER;
        DbgDump(DBG_ERR, ("Invalid WaitMask: (0x%x)\n", *pWaitMask));
        KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
  
     } else {

        KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
     
        // force completion of any pending waits
        SerialCompletePendingWaitMasks( PDevExt );

        KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);

        PDevExt->SerialPort.HistoryMask = 0; // clear the history mask

        PDevExt->SerialPort.WaitMask = *pWaitMask;

        //
        // for NT RAS
        // A value of '0' means clear any pending waits, which should have read 
        // and cleared the MSR delta bits. The delta bits are the low nibble.
        //
        if (PDevExt->SerialPort.WaitMask == 0) {
           // clear delta bits
           PDevExt->SerialPort.ModemStatus &= 0xF0;
        }
                         
        DbgDump(DBG_SERIAL, ("New SerialPort.WaitMask = 0x%x\n", PDevExt->SerialPort.WaitMask));
        DbgDump(DBG_SERIAL, ("SerialPort.RS232Lines   = 0x%x\n", PDevExt->SerialPort.RS232Lines ));
        DbgDump(DBG_SERIAL, ("SerialPort.ModemStatus  = 0x%x\n", PDevExt->SerialPort.ModemStatus));
        
        KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
        
        status = STATUS_SUCCESS;
     }
  }
   
  DbgDump(DBG_SERIAL, ("<SetWaitMask %x\n", status));

  return status;
}


VOID
ProcessSerialWaits(
   IN PDEVICE_EXTENSION PDevExt
   )
{
   KIRQL irql;
   PULONG pWaitMask;
   PIRP pMaskIrp;
   BOOLEAN bReleaseNeeded = TRUE;

   PERF_ENTRY( PERF_ProcessSerialWaits );

   ASSERT(PDevExt);

   DbgDump(DBG_SERIAL|DBG_TRACE, (">ProcessSerialWaits\n"));

   KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

   if ( PDevExt->SerialPort.CurrentWaitMaskIrp ) {
   
      ASSERT_SERIAL_PORT( PDevExt->SerialPort );

      if ( PDevExt->SerialPort.WaitMask & PDevExt->SerialPort.HistoryMask) {

         DbgDump(DBG_SERIAL, ("Releasing SerialPort.CurrentWaitMaskIrp(%p) with Mask: 0x%x\n", 
                              PDevExt->SerialPort.CurrentWaitMaskIrp, PDevExt->SerialPort.HistoryMask));

         pWaitMask = (PULONG)PDevExt->SerialPort.CurrentWaitMaskIrp->AssociatedIrp.SystemBuffer;
         *pWaitMask = PDevExt->SerialPort.HistoryMask;

         PDevExt->SerialPort.HistoryMask = 0;
      
         pMaskIrp = PDevExt->SerialPort.CurrentWaitMaskIrp;

         pMaskIrp->IoStatus.Information = sizeof(ULONG);
      
         pMaskIrp->IoStatus.Status = STATUS_SUCCESS;
      
         PDevExt->SerialPort.CurrentWaitMaskIrp = NULL;
      
         IoSetCancelRoutine(pMaskIrp, NULL);

         bReleaseNeeded = FALSE;

         ReleaseRemoveLock(&PDevExt->RemoveLock, pMaskIrp);

         KeReleaseSpinLock(&PDevExt->ControlLock, irql);
         
         IoCompleteRequest(pMaskIrp, IO_NO_INCREMENT );
      
      } else {

         DbgDump(DBG_SERIAL, ("No Serial Events\n" ));
      
      }

   } else {

      DbgDump(DBG_SERIAL, ("No CurrentWaitMaskIrp\n"));
      
   }

   if (bReleaseNeeded) {
      KeReleaseSpinLock(&PDevExt->ControlLock, irql);
   }
   
   DbgDump(DBG_SERIAL|DBG_TRACE, ("<ProcessSerialWaits\n"));
   
   PERF_EXIT( PERF_ProcessSerialWaits );

   return;
}



__inline
NTSTATUS
WaitOnMask(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
/* ++

   IOCTL_SERIAL_WAIT_ON_MASK
   Operation
   Returns information about which events have occurred 
   among those that the caller was waiting on.

   Input
   Parameters.DeviceIoControl.OutputBufferLength indicates the
   size in bytes (must be >= sizeof(ULONG)) of the buffer.

   Output
   The driver returns a bitmask with bits set for events that 
   occurred (or with a value of zero if the preceding 
   set-waitmask request specified zero) to the buffer at 
   Irp->AssociatedIrp.SystemBuffer.

   I/O Status Block
   The Information field is set to sizeof(ULONG) when the 
   Status field is set to STATUS_SUCCESS. Otherwise, 
   the Information field is set to zero, and the Status field 
   can be set to STATUS_PENDING or 
   STATUS_INVALID_PARAMETER if a wait is already pending.

-- */
{
  PULONG pWaitMask = (PULONG)PIrp->AssociatedIrp.SystemBuffer;
  PIO_STACK_LOCATION pIrpSp;
  NTSTATUS status = STATUS_DELETE_PENDING;
  KIRQL oldIrql;

  DbgDump(DBG_SERIAL|DBG_TRACE, (">WaitOnMask (%p)\n",  PIrp));

  KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);

  if ( !CanAcceptIoRequests(PDevExt->DeviceObject, FALSE, TRUE) ) {
      status = STATUS_DELETE_PENDING;
      DbgDump(DBG_ERR, ("WaitOnMask: 0x%x\n", status) );
      KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
      return status;
  }

  status = STATUS_SUCCESS;

  PIrp->IoStatus.Information = 0;

  pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

  if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {
     
     KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
     status = STATUS_BUFFER_TOO_SMALL;
     DbgDump(DBG_ERR, ("WaitOnMask: (0x%x)\n", status));

  } else {
     //
     // Fake NULL modem...
     //
     if ((PDevExt->SerialPort.WaitMask & SERIAL_EV_CTS) && (PDevExt->SerialPort.ModemStatus & SERIAL_MSR_DCTS) ) {

        PDevExt->SerialPort.HistoryMask |= SERIAL_EV_CTS;
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DCTS;

     }

     if ((PDevExt->SerialPort.WaitMask & SERIAL_EV_DSR) && (PDevExt->SerialPort.ModemStatus & SERIAL_MSR_DDSR) ) {

        PDevExt->SerialPort.HistoryMask |= SERIAL_EV_DSR;
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DDSR;
        
        // make RAS happy
        PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RLSD;
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DDCD;

     }

     if ((PDevExt->SerialPort.WaitMask & SERIAL_EV_RLSD) && (PDevExt->SerialPort.ModemStatus & SERIAL_MSR_DDCD) ) {

        PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RLSD;
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DDCD;

     }

     if ((PDevExt->SerialPort.WaitMask & SERIAL_EV_RING) && (PDevExt->SerialPort.ModemStatus & SERIAL_MSR_DRI) ) {

        PDevExt->SerialPort.HistoryMask |= SERIAL_EV_RING;
        PDevExt->SerialPort.ModemStatus &= ~SERIAL_MSR_DRI;

     }

     DbgDump(DBG_SERIAL, ("WaitOnMask::SerialPort.ModemStatus: 0x%x\n", PDevExt->SerialPort.ModemStatus ));
     DbgDump(DBG_SERIAL, ("WaitOnMask::SerialPort.WaitMask   : 0x%x\n", PDevExt->SerialPort.WaitMask ));
     DbgDump(DBG_SERIAL, ("WaitOnMask::SerialPort.HistoryMask: 0x%x\n", PDevExt->SerialPort.HistoryMask ));

     //
     // If we already have an event to report, then just go ahead and return it.
     //
     if ( PDevExt->SerialPort.HistoryMask ) {

        *pWaitMask = PDevExt->SerialPort.HistoryMask;
     
        PDevExt->SerialPort.HistoryMask = 0;

        KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);

        PIrp->IoStatus.Information = sizeof(PDevExt->SerialPort.HistoryMask);

        // the Irp gets completed by the calling routine
        DbgDump(DBG_SERIAL | DBG_EVENTS, ("Returning WatiMask: 0x%08x\n", *pWaitMask));

     } else {
        //
        // we don't have any events yet, 
        // so queue the input Irp (PIrp)
        //

        //
        // just in case something comes in (Rx/Tx), 
        // we'll use a while loop to complete any 
        // pending wait mask Irps.
        //
        while (PDevExt->SerialPort.CurrentWaitMaskIrp) {
           PIRP pOldIrp;

           pOldIrp = PDevExt->SerialPort.CurrentWaitMaskIrp;
           PDevExt->SerialPort.CurrentWaitMaskIrp = NULL;

           pOldIrp->IoStatus.Status = STATUS_SUCCESS;

           IoSetCancelRoutine(pOldIrp, NULL);

           *pWaitMask = 0;

           DbgDump(DBG_SERIAL|DBG_EVENTS|DBG_TRACE, ("Completing maskirp(4) %p\n", pOldIrp));

           //
           // Release locks, complete request, then reacquire locks
           //
           ReleaseRemoveLock(&PDevExt->RemoveLock, pOldIrp);

           KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);

           IoCompleteRequest(pOldIrp, IO_SERIAL_INCREMENT);

           KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);
        }

        //
        // Check to see if the input Irp needs to be cancelled
        //
        if (PIrp->Cancel) {

           PIrp->IoStatus.Information = 0;

           status = PIrp->IoStatus.Status = STATUS_CANCELLED;
           //
           // the caller completes the Irp
           //
        } else {
              //
              // queue the input Irp as the SerialPort.CurrentWaitMaskIrp
              //
              DbgDump(DBG_SERIAL | DBG_EVENTS, ("Queuing Irp: %p for WatiMask: 0x%08x\n", PIrp, PDevExt->SerialPort.WaitMask ));

              IoSetCancelRoutine( PIrp, SerialCancelWaitMask );

              IoMarkIrpPending(PIrp);
        
              status = PIrp->IoStatus.Status = STATUS_PENDING;

              ASSERT( NULL == PDevExt->SerialPort.CurrentWaitMaskIrp); // don't want to drop Irps on the floor
              PDevExt->SerialPort.CurrentWaitMaskIrp = PIrp;

              //
              // now the Irp is on our queue, 
              // so the caller should NOT try to complete it.
              //
        }

        KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
     }  // !SerialPort.HistoryMask

  }  // pIrpSp->Parameters

   DbgDump(DBG_SERIAL, ("<WaitOnMask %x\n", status));

   return status;
}



VOID
SerialCompletePendingWaitMasks(
   IN PDEVICE_EXTENSION PDevExt
   )
/*++

Routine Description:

    This function is used to complete the pending SerialPort.WaitMask Irp
    due to IOCTL_SERIAL_SET_WAIT_MASK

Arguments:

Return Value:

    VOID

--*/
{
  KIRQL oldIrql;
  PIRP pCurrentMaskIrp = NULL;

  ASSERT(PDevExt);
  DbgDump(DBG_SERIAL|DBG_TRACE, (">SerialCompletePendingWaitMasks\n"));
   
  KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);

  ASSERT_SERIAL_PORT( PDevExt->SerialPort );

  pCurrentMaskIrp = PDevExt->SerialPort.CurrentWaitMaskIrp;

  if (pCurrentMaskIrp) {

     pCurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;
  
     pCurrentMaskIrp->IoStatus.Information = sizeof(PDevExt->SerialPort.HistoryMask);

     DbgDump(DBG_SERIAL, ("SerialCompletePendingWaitMasks: %p with 0x%x\n", PDevExt->SerialPort.CurrentWaitMaskIrp, PDevExt->SerialPort.HistoryMask));
     
     *((PULONG)pCurrentMaskIrp->AssociatedIrp.SystemBuffer) = PDevExt->SerialPort.HistoryMask;
  
     PDevExt->SerialPort.HistoryMask = 0;
  
     PDevExt->SerialPort.CurrentWaitMaskIrp = NULL;

     IoSetCancelRoutine(pCurrentMaskIrp, NULL);

   }

   KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);

   // complete the queued SerialPort.WaitMask IRP if needed
   if (pCurrentMaskIrp) {
      
      ReleaseRemoveLock(&PDevExt->RemoveLock, pCurrentMaskIrp);
      
      IoCompleteRequest(pCurrentMaskIrp, IO_SERIAL_INCREMENT);
   }

   DbgDump(DBG_SERIAL|DBG_TRACE, ("<SerialCompletePendingWaitMasks\n"));

   return;
}


VOID
SerialCancelWaitMask(
   IN PDEVICE_OBJECT PDevObj, 
   IN PIRP PIrp
   )
/*++

Routine Description:

    This function is used as a cancel routine for Irps queued due 
    to IOCTL_SERIAL_WAIT_ON_MASK

Arguments:

    PDevObj - Pointer to Device Object
    PIrp    - Pointer to IRP that is being canceled; must be the same as
              the current mask IRP.

Return Value:

    VOID

--*/
{
  PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;
  KIRQL oldIrql;

  DbgDump(DBG_SERIAL|DBG_IRP|DBG_CANCEL|DBG_TRACE, (">SerialCancelWaitMask (%p)\n", PIrp));

  //
  // release ASAP since we queue our own Irps
  //
  IoReleaseCancelSpinLock(PIrp->CancelIrql);

  KeAcquireSpinLock(&pDevExt->ControlLock, &oldIrql);  

  ASSERT_SERIAL_PORT( pDevExt->SerialPort );

  ASSERT(pDevExt->SerialPort.CurrentWaitMaskIrp == PIrp);

  PIrp->IoStatus.Status = STATUS_CANCELLED;
  PIrp->IoStatus.Information = 0;

  pDevExt->SerialPort.CurrentWaitMaskIrp = NULL;

  ReleaseRemoveLock(&pDevExt->RemoveLock, PIrp);

  KeReleaseSpinLock(&pDevExt->ControlLock, oldIrql);

  IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

  DbgDump(DBG_SERIAL|DBG_IRP|DBG_CANCEL|DBG_TRACE, ("<SerialCancelWaitMask\n"));

  return;
}


__inline
NTSTATUS
GetCommStatus(
   IN PIRP PIrp,
   IN PDEVICE_EXTENSION PDevExt
   )
/* ++

   IOCTL_SERIAL_GET_COMMSTATUS
   Operation
   Returns general status information, including how many 
   Errors and HoldReasons have occurred, how much data 
   is in the driver's buffers as indicated by the AmountInInQueue 
   and AmountInOutQueue values, and whether EofReceived and 
   WaitForImmediate are set.

   Input
   Parameters.DeviceIoControl.OutputBufferLength 
   indicates the size in bytes of the buffer, which must be 
   >= sizeof(SERIAL_STATUS).

   Output
   The driver returns information to the buffer at 
   Irp->AssociatedIrp.SystemBuffer.

   I/O Status Block
   The Information field is set to sizeof(SERIAL_STATUS) 
   when the Status field is set to STATUS_SUCCESS. Otherwise, 
   the Information field is set to zero and the Status field is set to 
   STATUS_BUFFER_TOO_SMALL.

-- */
{
    PSERIAL_STATUS pSerialStatus = (PSERIAL_STATUS)PIrp->AssociatedIrp.SystemBuffer;
    NTSTATUS status = STATUS_DELETE_PENDING;
    KIRQL oldIrql;
    PIO_STACK_LOCATION  pIrpSp;

    DbgDump(DBG_SERIAL, (">GetCommStatus (%p)\n", PIrp));

    KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);
   
    pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_STATUS)) {

        status = STATUS_BUFFER_TOO_SMALL;
        PIrp->IoStatus.Information = 0;
        DbgDump(DBG_ERR, ("GetCommStatus: (0x%x)\n", status));

    } else {

        status = STATUS_SUCCESS;
        PIrp->IoStatus.Information = sizeof(SERIAL_STATUS);

        RtlZeroMemory(pSerialStatus, sizeof(SERIAL_STATUS));

        pSerialStatus->Errors = 0;
        pSerialStatus->EofReceived = FALSE;

        pSerialStatus->WaitForImmediate = 0;
        pSerialStatus->HoldReasons = 0;

#if defined (USE_RING_BUFF)
        pSerialStatus->AmountInInQueue = PDevExt->RingBuff.CharsInBuff;
#else
        pSerialStatus->AmountInInQueue = PDevExt->UsbReadBuffChars;
#endif
        pSerialStatus->AmountInOutQueue= PDevExt->SerialPort.CharsInWriteBuf;

        DbgDump(DBG_SERIAL, ("AmountInInQueue: %x\n", pSerialStatus->AmountInInQueue ));
        DbgDump(DBG_SERIAL, ("AmountInOutQueue: %x\n", pSerialStatus->AmountInOutQueue));
    }

    KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);
   
    DbgDump(DBG_SERIAL, ("<GetCommStatus %x\n", status));

    return status;
}


__inline
NTSTATUS
GetModemStatus(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING;

   DbgDump(DBG_SERIAL, (">GetModemStatus (%p)\n", PIrp));

   // get current MSR
   status = IoctlGetSerialValue(PDevExt,
                                PIrp, 
                                sizeof( PDevExt->SerialPort.ModemStatus ),
                                &PDevExt->SerialPort.ModemStatus );

   DbgDump(DBG_SERIAL, ("<GetModemStatus %x\n", status));

   return status;
}



__inline
NTSTATUS
ImmediateChar(
   IN PIRP Irp, 
   IN PDEVICE_OBJECT DeviceObject
   )
{
   PUCHAR   Char = (PUCHAR) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS status = STATUS_SUCCESS;
   PIO_STACK_LOCATION IrpStack;

   DbgDump(DBG_SERIAL, (">ImmediateChar (%p)\n", Irp));

   TEST_TRAP();

   Irp->IoStatus.Information = 0;
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR)) {

      status = STATUS_BUFFER_TOO_SMALL;
      DbgDump(DBG_ERR, ("ImmediateChar: (0x%x)\n", status));

   } else {
      //
      // Fabricate a write irp & send it to our write path.
      // We do this because the R/W path depends on receiving an Irp of type
      // IRP_MJ_WRITE or IRP_MJ_READ. It would be easier to 
      // simply say "not supported", but legacy apps depend on this.
      //
      PIRP pIrp;
      KEVENT event;
      IO_STATUS_BLOCK ioStatusBlock = {0, 0};
      LARGE_INTEGER startingOffset  = {0, 0};

      PAGED_CODE();

      KeInitializeEvent(
         &event,
         NotificationEvent,
         FALSE
         );

      pIrp = IoBuildSynchronousFsdRequest(
                 IRP_MJ_WRITE,   // MajorFunction,
                 DeviceObject,   // DeviceObject,
                 &Char,          // Buffer,
                 sizeof(Char),   // Length ,
                 &startingOffset,// StartingOffset,
                 &event,         // Event,
                 &ioStatusBlock  // OUT PIO_STATUS_BLOCK  IoStatusBlock
                 );

      if ( !pIrp ) {

         status = Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
         DbgDump(DBG_ERR, ("IoBuildSynchronousFsdRequest: STATUS_INSUFFICIENT_RESOURCES\n", status));

      } else {

         status = IoCallDriver( DeviceObject, 
                                pIrp );

         if ( STATUS_PENDING == status ) {
            KeWaitForSingleObject( &event, Suspended, KernelMode, FALSE, NULL );
         }

         //
         // Propogate Write status.
         // Note: the system released the Irp we just created & sent
         // when the Write completes.... so don't touch it.
         //
         status = ioStatusBlock.Status ;
      }

   }

   DbgDump(DBG_SERIAL, ("<ImmediateChar, %x\n", status));

   return status;
}


NTSTATUS
SerialPurgeRxClear(
   IN PDEVICE_OBJECT PDevObj,
   IN BOOLEAN CancelRead
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   KIRQL irql;

   DbgDump( DBG_SERIAL, (">SerialPurgeRxClear:%d\n", CancelRead));

   //
   // Cancel the USB INT & Read Irps, which effectvely NAKs all packets from the client
   // device untill we resubmit it.
   //
   if ( CancelRead ) 
   {
        if (pDevExt->IntIrp) 
        {
            status = CancelUsbInterruptIrp( PDevObj );
        }
        status = CancelUsbReadIrp( PDevObj );
   }

   if (STATUS_SUCCESS == status) {
      //
      // Now, purge the Rx buffer.
      //
      KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

#if DBG
   if ( DebugLevel & (DBG_DUMP_READS|DBG_READ_LENGTH)) 
   {
      ULONG i;
#if defined (USE_RING_BUFF)
      KdPrint( ("PurgeRxBuff[%d]: ", pDevExt->RingBuff.CharsInBuff ));
      for (i = 0; i < pDevExt->RingBuff.CharsInBuff; i++) {
         KdPrint(("%02x ", *pDevExt->RingBuff.pHead++ & 0xFF));
      }
#else
      KdPrint( ("PurgeRxBuff[%d]: ", pDevExt->UsbReadBuffChars ));
      for (i = 0; i < pDevExt->UsbReadBuffChars; i++) {
         KdPrint(("%02x ", pDevExt->UsbReadBuff[i] & 0xFF));
      }
#endif // USE_RING_BUFF
      KdPrint(("\n"));
   }
#endif // DBG

#if defined (USE_RING_BUFF)
      pDevExt->RingBuff.CharsInBuff = 0;
      pDevExt->RingBuff.pHead =
      pDevExt->RingBuff.pTail = 
      pDevExt->RingBuff.pBase;
#else    // USE_RING_BUFF
      pDevExt->UsbReadBuffChars = 0;
      pDevExt->UsbReadBuffIndex   = 0;
#endif

      if ( CancelRead ) {
         //
         // reset read states
         //
         InterlockedExchange(&pDevExt->UsbReadState, IRP_STATE_COMPLETE);
         InterlockedExchange(&pDevExt->IntState,     IRP_STATE_COMPLETE);
      }

      KeReleaseSpinLock(&pDevExt->ControlLock, irql);
   }
   
   DbgDump(DBG_SERIAL, ("<SerialPurgeRxClear:0x%x\n", status ));

   return status;
}



__inline
NTSTATUS
Purge(
   IN PDEVICE_OBJECT PDevObj, 
   IN PIRP Irp
   )
/* ++

   IOCTL_SERIAL_PURGE
   Operation
   Purges the specified operation(s) or queues: one or more of 
   the current and all pending writes, the current and all pending 
   reads, the transmit buffer if one exists, and the receive buffer 
   if one exists.

   Input
   Parameters.DeviceIoControl.InputBufferLength indicates the 
   size in bytes of the buffer at Irp->AssociatedIrp.SystemBuffer,
   which contains a bitmask of type ULONG, indicating what to purge.

   Output
   None

   I/O Status Block
   The Information field is set to zero, and the Status field is set 
   to STATUS_SUCCESS or possibly to STATUS_PENDING, 
   STATUS_CANCELLED, or STATUS_INVALID_PARAMETER

-- */
{
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
    PIO_STACK_LOCATION pIrpStack;
    NTSTATUS status = STATUS_DELETE_PENDING;
    ULONG    ulMask = 0;
    KIRQL  irql;
    PIRP NulllIrp = NULL;

    DbgDump(DBG_SERIAL|DBG_IRP, (">Purge (%p)\n", Irp));

    KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

    Irp->IoStatus.Information = 0;
    pIrpStack = IoGetCurrentIrpStackLocation(Irp);

    if (!Irp->AssociatedIrp.SystemBuffer ||
        pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        DbgDump(DBG_ERR, ("Purge: (0x%x)\n", status));

    } else {

         ulMask = *((PULONG) Irp->AssociatedIrp.SystemBuffer);

         // make sure purge request is valid
         if ( (!ulMask) || (ulMask & ( ~( SERIAL_PURGE_TXABORT  |
                                          SERIAL_PURGE_RXABORT |
                                          SERIAL_PURGE_TXCLEAR  |
                                          SERIAL_PURGE_RXCLEAR)))) {

            status = STATUS_INVALID_PARAMETER;
            DbgDump(DBG_ERR, ("Purge: (0x%x)\n", status));

         } else {

            DbgDump(DBG_SERIAL, ("Purge Mask: 0x%x\n", ulMask ));

            status = STATUS_SUCCESS;

            if ( ulMask & SERIAL_PURGE_RXCLEAR) {
               //
               // SERIAL_PURGE_RXCLEAR - Implies the receive buffer if exists.
               //
               DbgDump(DBG_SERIAL|DBG_IRP, ("SERIAL_PURGE_RXCLEAR\n"));
               KeReleaseSpinLock(&pDevExt->ControlLock, irql);
       
               status = SerialPurgeRxClear(PDevObj, TRUE);

               if ( NT_SUCCESS(status) ) {
                   if ( !pDevExt->IntPipe.hPipe ) {
                      DbgDump(DBG_SERIAL, ("kick starting another USB Read\n" ));
                      status = UsbRead( pDevExt, FALSE );
                   } else {
                      DbgDump(DBG_SERIAL, ("kick starting another USB INT Read\n" ));
                      status = UsbInterruptRead( pDevExt );
                   }
               }

               if ( NT_SUCCESS(status) ) { 
                   // should be STATUS_PENDING
                   status = STATUS_SUCCESS;
               }
      
               KeAcquireSpinLock(&pDevExt->ControlLock, &irql);
            }

            if (ulMask & SERIAL_PURGE_RXABORT) {
               //
               // SERIAL_PURGE_RXABORT - Implies the current and all pending reads.
               //
               DbgDump(DBG_SERIAL|DBG_IRP, ("SERIAL_PURGE_RXABORT\n"));

               KeReleaseSpinLock(&pDevExt->ControlLock, irql);

               // cancel all outstanding USB read requests
               //status = CleanUpPacketList( PDevObj, &pDevExt->PendingReadPackets);
       
               // cancel all outstanding user reads
               KillAllPendingUserReads( PDevObj,
                                        &pDevExt->UserReadQueue,
                                        &pDevExt->UserReadIrp ); //&NulllIrp );
       
               KeAcquireSpinLock(&pDevExt->ControlLock, &irql);
            }

            if (ulMask & SERIAL_PURGE_TXCLEAR) {
               //
               // SERIAL_PURGE_TXCLEAR - Implies the transmit buffer if exists
               //
               DbgDump(DBG_SERIAL|DBG_IRP, ("SERIAL_PURGE_TXCLEAR\n"));
    
               pDevExt->SerialPort.CharsInWriteBuf = 0;

            }

            if (ulMask & SERIAL_PURGE_TXABORT) {
               //
               // SERIAL_PURGE_TXABORT - Implies the current and all pending writes.
               //
               DbgDump(DBG_SERIAL|DBG_IRP, ("SERIAL_PURGE_TXABORT\n"));

               KeReleaseSpinLock(&pDevExt->ControlLock, irql);
       
               //
               // We don't queue write Irps, rather write packets.
               // So, cancel all outstanding write requests 
               //
               status = CleanUpPacketList( PDevObj, 
                                           &pDevExt->PendingWritePackets,
                                           &pDevExt->PendingDataOutEvent
                                           );
       
               KeAcquireSpinLock(&pDevExt->ControlLock, &irql);
            }

         }
    }

   KeReleaseSpinLock(&pDevExt->ControlLock, irql);

   DbgDump(DBG_SERIAL|DBG_IRP, ("<Purge %x\n", status));

   return status;
}



__inline
NTSTATUS
GetHandflow(
   IN PIRP Irp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status = STATUS_DELETE_PENDING; 

   DbgDump(DBG_SERIAL, (">GetHandFlow (%p)\n", Irp));

   status = IoctlGetSerialValue(PDevExt,
                                Irp, 
                                sizeof( PDevExt->SerialPort.HandFlow ),
                                &PDevExt->SerialPort.HandFlow);

   DBG_DUMP_SERIAL_HANDFLOW( PDevExt );
   
   DbgDump(DBG_SERIAL, ("<GetHandFlow %x\n", status));

   return status;
}



__inline
NTSTATUS
SetHandflow(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS status= STATUS_DELETE_PENDING;
   
   DbgDump(DBG_SERIAL, (">SetHandFlow(%p)\n", PIrp));

   status = IoctlSetSerialValue( PDevExt, 
                           PIrp, 
                           sizeof( PDevExt->SerialPort.HandFlow ),
                           &PDevExt->SerialPort.HandFlow);

   DBG_DUMP_SERIAL_HANDFLOW( PDevExt );
      
   DbgDump(DBG_SERIAL, ("<SetHandFlow %x\n", status));

   return status;
}



NTSTATUS
GetProperties(
   IN PIRP Irp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   NTSTATUS           status = STATUS_DELETE_PENDING;
   PSERIAL_COMMPROP   Properties;
   PIO_STACK_LOCATION IrpStack;
   KIRQL oldIrql;

   DbgDump(DBG_SERIAL, (">GetProperties (%p)\n", Irp));
   
    KeAcquireSpinLock(&PDevExt->ControlLock, &oldIrql);

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_COMMPROP)) {
 
        status = STATUS_BUFFER_TOO_SMALL;
        DbgDump(DBG_ERR, ("GetProperties: (0x%x)\n", status));

    } else {

        Properties = (PSERIAL_COMMPROP)Irp->AssociatedIrp.SystemBuffer;
  
        RtlZeroMemory(Properties, sizeof(SERIAL_COMMPROP));

        Properties->PacketLength   = sizeof(SERIAL_COMMPROP);
        Properties->PacketVersion  = 2;

        Properties->ServiceMask    = SERIAL_SP_SERIALCOMM;

        // internal limits
        Properties->MaxTxQueue = DEFAULT_PIPE_MAX_TRANSFER_SIZE; 
        #if defined (USE_RING_BUFF)
        Properties->MaxRxQueue = PDevExt->RingBuff.Size;
        #else
        Properties->MaxRxQueue = PDevExt->UsbReadBuffSize;
        #endif

        Properties->MaxBaud        = SERIAL_BAUD_USER; // SERIAL_BAUD_115200;
        Properties->SettableBaud  = PDevExt->SerialPort.SupportedBauds;

        Properties->ProvSubType  = SERIAL_SP_UNSPECIFIED; // SERIAL_SP_RS232;

        Properties->ProvCapabilities = SERIAL_PCF_DTRDSR | SERIAL_PCF_RTSCTS
                                  | SERIAL_PCF_CD | SERIAL_PCF_XONXOFF
                                  | SERIAL_PCF_TOTALTIMEOUTS | SERIAL_PCF_INTTIMEOUTS
                                  | SERIAL_PCF_SPECIALCHARS;

        Properties->SettableParams = SERIAL_SP_BAUD | SERIAL_SP_CARRIER_DETECT;

        Properties->SettableData  = SERIAL_DATABITS_8;

        Properties->SettableStopParity  = SERIAL_STOPBITS_10 | SERIAL_STOPBITS_20 
                                     | SERIAL_PARITY_NONE | SERIAL_PARITY_ODD  
                                     | SERIAL_PARITY_EVEN | SERIAL_PARITY_MARK
                                     | SERIAL_PARITY_SPACE;

#if defined (USE_RING_BUFF)
        Properties->CurrentRxQueue = PDevExt->RingBuff.Size;
#else
        Properties->CurrentRxQueue = PDevExt->UsbReadBuffSize;
        Properties->CurrentTxQueue = PDevExt->ReadPipe.MaxPacketSize;
#endif

        status = STATUS_SUCCESS;
    }

    KeReleaseSpinLock(&PDevExt->ControlLock, oldIrql);

    if (STATUS_SUCCESS == status)  {
        Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
    } else {
        Irp->IoStatus.Information = 0;
    }

    DbgDump(DBG_SERIAL, ("<GetProperties %x\n", status));

    return status;
}



__inline
NTSTATUS
LsrmstInsert(
   IN PIRP Irp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   UNREFERENCED_PARAMETER(  Irp );
   UNREFERENCED_PARAMETER( PDevExt );

   DbgDump(DBG_SERIAL, (">LsrmstInsert (%p)\n", Irp));
   DbgDump(DBG_SERIAL, ("<LsrmstInsert (%x)\n", STATUS_NOT_SUPPORTED));

   return STATUS_NOT_SUPPORTED;
}



__inline
NTSTATUS
ConfigSize(
   IN PIRP Irp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
   PULONG               ConfigSize = (PULONG) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS             status = STATUS_SUCCESS;
   PIO_STACK_LOCATION   IrpStack;

   UNREFERENCED_PARAMETER( PDevExt );

   DbgDump(DBG_SERIAL, (">ConfigSize (%p)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {

      status = STATUS_BUFFER_TOO_SMALL;
      DbgDump(DBG_ERR, ("ConfigSize: (0x%x)\n", status));
   
   } else {
      *ConfigSize = 0;

      Irp->IoStatus.Information = sizeof(ULONG);
   }

   DbgDump(DBG_SERIAL, ("<ConfigSize %x\n", status));

   return status;
}



__inline
NTSTATUS
GetStats(
   IN PIRP PIrp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
    PSERIALPERF_STATS pStats = NULL;
    PIO_STACK_LOCATION pIrpSp;
    NTSTATUS status = STATUS_DELETE_PENDING;
    ULONG information = 0;
    KIRQL irql;

    DbgDump(DBG_SERIAL, (">GetStats %p\n", PIrp));

    KeAcquireSpinLock(&PDevExt->ControlLock, &irql );
      
    pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIALPERF_STATS) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        DbgDump(DBG_ERR, ("GetStats: (0x%x)\n", status));

    } else {
        information = sizeof(SERIALPERF_STATS);
        status = STATUS_SUCCESS;

        pStats = (PSERIALPERF_STATS)PIrp->AssociatedIrp.SystemBuffer;                  
        RtlZeroMemory(pStats , sizeof(SERIALPERF_STATS));

        pStats->ReceivedCount     = PDevExt->TtlUSBReadBytes;
        pStats->TransmittedCount = PDevExt->TtlWriteBytes;
        pStats->FrameErrorCount  = PDevExt->ReadDeviceErrors + PDevExt->WriteDeviceErrors + PDevExt->IntDeviceErrors; // ??
        pStats->SerialOverrunErrorCount = PDevExt->TtlUSBReadBuffOverruns;
#if defined (USE_RING_BUFF)
        pStats->BufferOverrunErrorCount = PDevExt->TtlRingBuffOverruns;
#else
        pStats->BufferOverrunErrorCount = 0;
#endif         
        pStats->ParityErrorCount = 0;

        DbgDump(DBG_SERIAL, ("ReceivedCount:    %d\n", pStats->ReceivedCount )); \
        DbgDump(DBG_SERIAL, ("TransmittedCount: %d\n", pStats->TransmittedCount )); \
        DbgDump(DBG_SERIAL, ("FrameErrorCount:  %d\n", pStats->FrameErrorCount ));  \
        DbgDump(DBG_SERIAL, ("SerialOverrunErrorCount: %d\n", pStats->SerialOverrunErrorCount ));  \
        DbgDump(DBG_SERIAL, ("BufferOverrunErrorCount: %d\n", pStats->BufferOverrunErrorCount ));  \
        DbgDump(DBG_SERIAL, ("ParityErrorCount: %d\n", pStats->ParityErrorCount )); \
   }

   KeReleaseSpinLock(&PDevExt->ControlLock, irql);

   PIrp->IoStatus.Information = information;
   PIrp->IoStatus.Status = status;     

   DbgDump(DBG_SERIAL, ("<GetStats %x\n", status));

   return status;
}



NTSTATUS
ClearStats(
   IN PIRP Irp, 
   IN PDEVICE_EXTENSION PDevExt
   )
{
    NTSTATUS status = STATUS_DELETE_PENDING;
    KIRQL irql;

    DbgDump(DBG_SERIAL, (">ClearStats (%p)\n", Irp));

    KeAcquireSpinLock(&PDevExt->ControlLock, &irql);

    PDevExt->TtlWriteRequests = 0;
    PDevExt->TtlWriteBytes = 0;
    PDevExt->TtlReadRequests = 0;
    PDevExt->TtlReadBytes = 0;
    PDevExt->TtlUSBReadRequests = 0;
    PDevExt->TtlUSBReadBytes = 0;
    PDevExt->TtlUSBReadBuffOverruns = 0;
#if defined (USE_RING_BUFF)
    PDevExt->TtlRingBuffOverruns = 0;
#endif
    status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    KeReleaseSpinLock(&PDevExt->ControlLock, irql);

    DbgDump(DBG_SERIAL, ("<ClearStats %x\n", status));

    return status;
}



/*++

Note:  Unhandled IOCTL_SERIAL_: 0x2b002c : function code 11 is IOCTL_MODEM_CHECK_FOR_MODEM,
which if unhandled tells the system to load modem.sys over this serial port driver. 
This is setup by RAS & unimodem.

--*/
NTSTATUS
SerialIoctl(
   PDEVICE_OBJECT PDevObj, 
   PIRP PIrp
   )
{
   PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);
   ULONG ioctl = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
   NTSTATUS status = STATUS_NOT_SUPPORTED;
   BOOLEAN bSignalNeeded = FALSE;
   KIRQL irql;
   LONG lSanity = 0;

   DbgDump(DBG_SERIAL|DBG_TRACE, (">SerialIoctl(%p)\n", PIrp));

    do {
        KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

        //
        // Make sure the device is accepting request
        //
        if ( !CanAcceptIoRequests( PDevObj, FALSE, TRUE) || 
             !NT_SUCCESS(AcquireRemoveLock(&pDevExt->RemoveLock, PIrp)) ) 
        {
            status = STATUS_DELETE_PENDING;
            DbgDump(DBG_WRN, ("SerialIoctl: 0x%x, 0x%x\n", ioctl, status));
            PIrp->IoStatus.Status = status;
            KeReleaseSpinLock(&pDevExt->ControlLock, irql);
            IoCompleteRequest(PIrp, IO_NO_INCREMENT);
            return status;
        }

        ASSERT_SERIAL_PORT( pDevExt->SerialPort );

        KeReleaseSpinLock(&pDevExt->ControlLock, irql);

        switch (ioctl) 
        {
             case IOCTL_SERIAL_SET_BAUD_RATE:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_BAUD_RATE\n"));
                status = SetBaudRate(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_BAUD_RATE:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_BAUD_RATE\n"));
                status = GetBaudRate(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_LINE_CONTROL:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_LINE_CONTROL\n"));
                status = SetLineControl(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_LINE_CONTROL:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_LINE_CONTROL\n"));
                status = GetLineControl(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_TIMEOUTS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_TIMEOUTS\n"));
                status = SetTimeouts(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_TIMEOUTS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_TIMEOUTS\n"));
                status = GetTimeouts(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_CHARS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_CHARS\n"));
                status = SetSpecialChars(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_CHARS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_CHARS\n"));
                status = GetSpecialChars(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_DTR:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_DTR\n"));
                status = SetClearDTR(pDevExt, PIrp, TRUE);
                break;

             case IOCTL_SERIAL_CLR_DTR:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_CLR_DTR\n"));
                status = SetClearDTR(pDevExt, PIrp, FALSE);
                break;

             case IOCTL_SERIAL_SET_RTS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_RTS\n"));
                status = SetClearRTS(pDevExt, PIrp, TRUE);
                break;

             case IOCTL_SERIAL_CLR_RTS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_CLR_RTS\n"));
                status = SetClearRTS(pDevExt, PIrp, FALSE);
                break;

             case IOCTL_SERIAL_GET_DTRRTS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_DTRRTS\n"));
                status = GetDtrRts(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_BREAK_ON:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_BREAK_ON\n"));
                status = SetBreak(PIrp, pDevExt, 0xFFFF);
                break;

             case IOCTL_SERIAL_SET_BREAK_OFF:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_BREAK_OFF\n"));
                status = SetBreak(PIrp, pDevExt, 0);
                break;

             case IOCTL_SERIAL_SET_QUEUE_SIZE:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_QUEUE_SIZE\n"));
                status = SetQueueSize(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_WAIT_MASK:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_WAIT_MASK\n"));
                status = GetWaitMask(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_WAIT_MASK:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_WAIT_MASK\n"));
                status = SetWaitMask(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_WAIT_ON_MASK:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_WAIT_ON_MASK\n"));
                status = WaitOnMask(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_MODEMSTATUS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_MODEMSTATUS\n"));
                status = GetModemStatus(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_COMMSTATUS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_COMMSTATUS\n"));
                status = GetCommStatus(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_IMMEDIATE_CHAR:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_IMMEDIATE_CHAR\n"));
                status = ImmediateChar(PIrp, PDevObj);
                break;

             case IOCTL_SERIAL_PURGE:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_PURGE\n"));
                status = Purge(PDevObj, PIrp);
                break;

             case IOCTL_SERIAL_GET_HANDFLOW:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_HANDFLOW\n"));
                status = GetHandflow(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_SET_HANDFLOW:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_SET_HANDFLOW\n"));
                status = SetHandflow(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_RESET_DEVICE:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_RESET_DEVICE\n"));
                status = SerialResetDevice(pDevExt, PIrp, TRUE);
                break;

             case IOCTL_SERIAL_LSRMST_INSERT:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_LSRMST_INSERT\n"));
                status = LsrmstInsert(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_CONFIG_SIZE:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_CONFIG_SIZE\n"));
                status = ConfigSize(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_STATS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_STATS\n"));
                status = GetStats(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_CLEAR_STATS:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_CLEAR_STATS\n"));
                status = ClearStats(PIrp, pDevExt);
                break;

             case IOCTL_SERIAL_GET_PROPERTIES:
                DbgDump(DBG_SERIAL, ("IOCTL_SERIAL_GET_PROPERTIES\n"));
                status = GetProperties(PIrp, pDevExt);
                break;

             default:
                DbgDump(DBG_WRN, ("Unhandled IOCTL_SERIAL_: 0x%x : function code %d\n",
                                               ioctl, SERIAL_FNCT_CODE(ioctl) ) );
                status = STATUS_NOT_SUPPORTED;
                break;
        }

   } while (0);

   //
   // Don't complete any pending Irps
   //
   if ( STATUS_PENDING != status) {
      
      PIrp->IoStatus.Status = status;

      ReleaseRemoveLock(&pDevExt->RemoveLock, PIrp);

      IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

   }

#ifdef DELAY_RXBUFF
   //
   // Special Case: the device was just opened.
   // To emulate a serial port RX buffer we need to kick start a USB read.
   // We don't want to do this in the IRP_MJ_CREATE code since AS does 
   // IOCTL_SERIAL_SET_WAIT_MASK then *two* IOCTL_SERIAL_SET_DTR requests. If we start the USB read
   // too soon then the CE device can get confused with a Read then SetDTR requests.
   // So, if we were just opened, and we have seen *one* successful IOCTL_SERIAL_SET_DTR then start our USB read.
   // Two good DTRs works better, but we'll let one slip for a timeout or something to recover, e.g. iPAQ on NEC E13+.
   // This may cause problems with other apps, but our target is ActiveSync. We could add a magic registry flag is required.
   // This means that outside of the initial get/set descriptors/configuration the USB is quiet until
   // an app opens the device for I/O... which is a good thing. 
   // However, this implementation causes the initial connect to a bit too slow for slow devices (e.g., HP Jornada, Cassiopeia).
   //
   if ( pDevExt->StartUsbRead && (IOCTL_SERIAL_SET_DTR == ioctl) && (STATUS_SUCCESS == status)) 
   {
        if ( 0 == InterlockedDecrement(&pDevExt->StartUsbRead)) 
        {
            if ( !pDevExt->IntPipe.hPipe ) {
                DbgDump(DBG_SERIAL, ("SerialIoctl: kick starting another USB Read\n" ));
                status = UsbRead( pDevExt, FALSE );
            } else {
                DbgDump(DBG_SERIAL, ("SerialIoctl: kick starting another USB INT Read\n" ));
                status = UsbInterruptRead( pDevExt );
            }

            if ( NT_SUCCESS(status) ) {
                // should be STATUS_PENDING
                status = STATUS_SUCCESS;
            } else {
                InterlockedIncrement(&pDevExt->StartUsbRead);
            }
        }
   }
#endif

   DbgDump(DBG_SERIAL|DBG_TRACE, ("<SerialIoctl: %p, 0x%x\n", PIrp, status));   

   return status;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\wceusbsh.h ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    wceusbsh.h

Abstract:

    Main entrypoint for Windows CE USB Serial Host driver, for
        ... Windows CE USB sync devices:
            SL11, Socket CF cards, HP Jornada, COMPAQ iPAQ, Casio Cassiopeia, etc.
        ... cables using the Anchor AN27x0 chipset (i.e. EZ-Link)
        ... ad-hoc USB NULL Modem Class

Environment:

    kernel mode only

Author:

    Jeff Midkiff (jeffmi)

Revision History:

    07-15-99    :   rev 1.00    ActiveSync 3.1  initial release
    04-20-00    :   rev 1.01    Cedar 3.0 Platform Builder
    09-20-00    :   rev 1.02    finally have some hardware

Notes:

    o) WCE Devices currently do not handle remote wake, nor can we put the device in power-off state when not used, etc.
    o) Pageable Code sections are marked as follows:
           PAGEWCE0 - useable only during init/deinit
           PAGEWCE1 - useable during normal runtime

-- */

#if !defined(_WCEUSBSH_H_)
#define _WCEUSBSH_H_

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <ntddser.h>

#define DRV_NAME "WCEUSBSH"

#include "errlog.h"
#include "perf.h"
#include "debug.h"

//
// Instantiate the GUID
//
#if !defined(FAR)
#define FAR
#endif

#include <initguid.h>
/* 25dbce51-6c8f-4a72-8a6d-b54c2b4fc835 */
DEFINE_GUID( GUID_WCE_SERIAL_USB, 0x25dbce51, 0x6c8f, 0x4a72, 0x8a, 0x6d, 0xb5, 0x4c, 0x2b, 0x4f, 0xc8, 0x35);

#define WCEUSB_POOL_TAG 'HECW'

//
// Max times we let a pipe take STATUS_DEVICE_DATA_ERROR
// before we shoot it in the head. This is registry configurable.
// Make the default large enough for (somewhat) working hardware to recover.
// I choose 100 because I know the error queuing code has handled queue depths of this size,
// and COMPAQ/INTEL has known USB function chipset bugs and requested a huge recovery window.
//
#define DEFAULT_MAX_PIPE_DEVICE_ERRORS 100

//
// The max times we take a class/vendor specific command error on EP0.
// This number can NOT change since
// a) commands on EP0 should never fail unless the device is bad
// b) ActiveSync retries commands (e.g. SET_DTR) this many times,
//    so we need a way to inform the user that device is hosed.
//
#define MAX_EP0_DEVICE_ERRORS 2

extern ULONG   g_ulMaxPipeErrors;

#include "remlock.h"

// TRUE  - OS = Win98
// FALSE - OS = WinNT
extern BOOLEAN g_isWin9x;

// do we expose a COMx: port. The default is NO,
// since this is only for debug purposes
extern BOOLEAN g_ExposeComPort;


#ifdef POOL_TAGGING
#undef  ExAllocatePool
#undef  ExAllocatePoolWithQuota
#define ExAllocatePool(a,b)             ExAllocatePoolWithTag(a, b, WCEUSB_POOL_TAG)
#define ExAllocatePoolWithQuota(a,b)    ExAllocatePoolWithQuotaTag(a, b, WCEUSBSH_POOL_TAG)
#endif

extern LONG  g_NumDevices;

//typedef struct _DEVICE_EXTENSION *PDEVICE_EXTENSION;

//
// Emulation of the bit mask on the MODEM STATUS REGISTER.
//
#define SERIAL_MSR_DCTS     0x0001
#define SERIAL_MSR_DDSR     0x0002
#define SERIAL_MSR_DRI      0x0004
#define SERIAL_MSR_DDCD     0x0008
#define SERIAL_MSR_CTS      0x0010
#define SERIAL_MSR_DSR      0x0020
#define SERIAL_MSR_RI       0x0040
#define SERIAL_MSR_DCD      0x0080

//
// Maximum char length for dos device name
//
#define DOS_NAME_MAX 80

//
// Maximum length for symbolic link
//
#define SYMBOLIC_NAME_LENGTH  128

//
// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.
//
//#define DEFAULT_DIRECTORY  L"DosDevices"

//
// PNP_STATE_Xxx flags
//
typedef enum _PNP_STATE {
    PnPStateInitialized,
    PnPStateAttached,
    PnPStateStarted,
    PnPStateRemovePending,
    PnPStateSupriseRemove,
    PnPStateStopPending,
    PnPStateStopped,
    PnPStateRemoved,
    PnPStateMax = PnPStateRemoved,
} PNP_STATE, *PPNP_STATE;


#define MILLISEC_TO_100NANOSEC(x)  ((ULONGLONG) ((-(x)) * 10000))

// default timeouts for pending items, in msec
#define DEFAULT_CTRL_TIMEOUT    500
#define DEFAULT_BULK_TIMEOUT    1000
#define DEFAULT_PENDING_TIMEOUT DEFAULT_BULK_TIMEOUT

#define WORK_ITEM_COMPLETE (0xFFFFFFFF)

//
// Work Item
//
typedef struct _WCE_WORK_ITEM {
   //
   // owning list this packet belongs on
   //
   LIST_ENTRY  ListEntry;

   //
   // owning Device for this work item
   //
   PDEVICE_OBJECT DeviceObject;

   //
   // Context
   //
   PVOID Context;

   //
   // Flags
   //
   ULONG Flags;

   //
   // The work item
   //
   WORK_QUEUE_ITEM Item;

} WCE_WORK_ITEM, *PWCE_WORK_ITEM;


//
// Where in the DeviceMap section of the registry serial port entries
// should appear
//
#define SERIAL_DEVICE_MAP  L"SERIALCOMM"

//
// COMM Port Context
//
typedef struct _COMPORT_INFO {
    //
    // Com Port number
    // read/written to from registry
    //
    ULONG PortNumber;

    //
    // (ones-based) instance number of device driver
    //
    ULONG Instance;

    //
    // number of successful Create calls on device
    //
    ULONG OpenCnt;

    //
    // True if a serial port symbolic link has been
    // created and should be removed upon deletion.
    //
    BOOLEAN SerialSymbolicLink;

    //
    // Symbolic link name -- e.g., \\DosDevices\COMx
    //
    UNICODE_STRING SerialPortName;

    //
    // written to SERIALCOMM -- e.g., COMx
    //
    UNICODE_STRING SerialCOMMname;

} COM_INFO, *PCOMPORT_INFO;


#define WCE_SERIAL_PORT_TYPE GUID_WCE_SERIAL_USB.Data2

#if DBG
#define ASSERT_SERIAL_PORT( _SP ) \
{ \
   ASSERT( WCE_SERIAL_PORT_TYPE == _SP.Type); \
}
#else
#define ASSERT_SERIAL_PORT( _SP )
#endif


//
// Serial Port Interface
//
typedef struct _SERIAL_PORT_INTERFACE {

    USHORT Type;

    //
    // exposed COMx information
    //
    COM_INFO Com;

    //
    // "named" (via SERIAL_BAUD_Xxx bitmask)
    // baud rates for this device
    //
    ULONG SupportedBauds;

    //
    // current baud rate
    //
    SERIAL_BAUD_RATE  CurrentBaud;

    //
    // line control reg: StopBits, Parity, Wordlen
    //
    SERIAL_LINE_CONTROL  LineControl;

    //
    // Handshake and control Flow control settings
    //
    SERIAL_HANDFLOW   HandFlow;

    //
    // RS-232 Serial Interface Lines
    //
    ULONG RS232Lines;

    //
    // Emulation of Modem Status Register (MSR)
    //
    USHORT ModemStatus;

    //
    // pending set/clear DTR/RTS command, etc. in progress
    //
    PIRP  ControlIrp;

    //
    // timeout controls for device
    //
    SERIAL_TIMEOUTS   Timeouts;

    //
    // Special Chars: EOF, ERR, BREAK, EVENT, XON, XOFF
    //
    SERIAL_CHARS   SpecialChars;

    //
    // Wait Mask
    //
    ULONG WaitMask;           // Flag to determine if the occurence of SERIAL_EV_ should be noticed
    ULONG HistoryMask;        // history of SERIAL_EV_
    PIRP  CurrentWaitMaskIrp; // current wait mask Irp

    //
    // Fake Rx/Tx buffer size.
    //
    SERIAL_QUEUE_SIZE FakeQueueSize;

    //
    // Current number of Tx characters buffered.
    //
    ULONG CharsInWriteBuf;

} SERIAL_PORT_INTERFACE, *PSERIAL_PORT_INTERFACE;


//
// Unique error log values
//
#define ERR_COMM_SYMLINK                  1
#define ERR_SERIALCOMM                    2
#define ERR_GET_DEVICE_DESCRIPTOR         3
#define ERR_SELECT_INTERFACE              4
#define ERR_CONFIG_DEVICE                 5
#define ERR_RESET_WORKER                  6
#define ERR_MAX_READ_PIPE_DEVICE_ERRORS   7
#define ERR_MAX_WRITE_PIPE_DEVICE_ERRORS  8
#define ERR_MAX_INT_PIPE_DEVICE_ERRORS    9
#define ERR_USB_READ_BUFF_OVERRUN         10
#define ERR_NO_USBREAD_BUFF               11
#define ERR_NO_RING_BUFF                  12
#define ERR_NO_DEVICE_OBJ                 13
#define ERR_NO_READ_PIPE_RESET            14
#define ERR_NO_WRITE_PIPE_RESET           15
#define ERR_NO_INT_PIPE_RESET             16
#define ERR_NO_CREATE_FILE                17
#define ERR_NO_DTR                        18
#define ERR_NO_RTS                        19



//
// NULL Modem USB Class
//
#define USB_NULL_MODEM_CLASS 0xFF


#define DEFAULT_ALTERNATE_SETTING 0

extern ULONG g_ulAlternateSetting;


//
// On a 300MHz MP machine it takes ~73 msec to
// cancel a pending USB Read Irp from the USB stack.
// On a P90 is takes ~14 ms (no SpinLock contention).
// With a default timeout of 1000 msec you have a hard time connecting via
// ActiveSync to CEPC using INT endpoints, and NT RAS ping times out a lot,
// both due to app's timing.
// However, you can easily connect with 100, 250, 500, 2000, etc. msec.
// Note: with 100 msec reads take longer than normal since we timeout at almost 10x/sec
//
#define DEFAULT_INT_PIPE_TIMEOUT 1280

extern LONG g_lIntTimout;


//
// USB COMM constants
//
#define WCEUSB_VENDOR_COMMAND 0
#define WCEUSB_CLASS_COMMAND  1

// Abstract Control Model defines
#define USB_COMM_SET_CONTROL_LINE_STATE   0x0022

// Control Line State - sent to device on default control pipe
#define USB_COMM_DTR    0x0001
#define USB_COMM_RTS    0x0002

// Serial State Notification masks
#define USB_COMM_DATA_READY_MASK   0X0001
#define USB_COMM_MODEM_STATUS_MASK 0X0006

// Serial State Notification bits - read from device on int pipe
#define USB_COMM_CTS 0x0002
#define USB_COMM_DSR 0x0004


//
// state machine defines for Irps that can pend in the USB stack
//
#define IRP_STATE_INVALID          0x0000
#define IRP_STATE_START            0x0001
#define IRP_STATE_PENDING          0x0002
#define IRP_STATE_COMPLETE         0x0004
#define IRP_STATE_CANCELLED        0x0008


//
// The following macros are used to initialize, set
// and clear references in IRPs that are used by
// this driver.  The reference is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//
#define IRP_REF_RX_BUFFER        (0x00000001)
#define IRP_REF_CANCEL           (0x00000002)
#define IRP_REF_TOTAL_TIMER      (0x00000004)
#define IRP_REF_INTERVAL_TIMER   (0x00000008)

#define IRP_INIT_REFERENCE(Irp) { \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define IRP_SET_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PUINT_PTR _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       *_arg4 |= _refType; \
   } while (0)

#define IRP_CLEAR_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PUINT_PTR _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       *_arg4 &= ~_refType; \
   } while (0)

#define IRP_REFERENCE_COUNT(Irp) \
    ((UINT_PTR)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))


//
// Priority increment for app's thread when completing
// USB Serial I/O (IoCompleteRequest). Used mainly for pumpimg up
// serial events & read completions.
//
//#define IO_WCEUSBS_INCREMENT     6


//
// These values are used by the routines that can be used
// to complete a read (other than interval timeout) to indicate
// to the interval timeout that it should complete.
//
#define SERIAL_COMPLETE_READ_CANCEL     ((LONG)-1)
#define SERIAL_COMPLETE_READ_TOTAL      ((LONG)-2)
#define SERIAL_COMPLETE_READ_COMPLETE   ((LONG)-3)

//
// flags for work items
//
#define WORK_ITEM_RESET_READ_PIPE   (0x00000001)
#define WORK_ITEM_RESET_WRITE_PIPE  (0x00000002)
#define WORK_ITEM_RESET_INT_PIPE    (0x00000004)
#define WORK_ITEM_ABORT_READ_PIPE   (0x00000010)
#define WORK_ITEM_ABORT_WRITE_PIPE  (0x00000020)
#define WORK_ITEM_ABORT_INT_PIPE    (0x00000040)


typedef struct _DEVICE_EXTENSION *PDEVICE_EXTENSION;

//
// Common Read/Write USB Packet
//
typedef struct _USB_PACKET {
   //
   // owning list this packet belongs on (Read, Write, PacketPool)
   //
   LIST_ENTRY  ListEntry;

   //
   // owning Device for this read/write
   //
   PDEVICE_EXTENSION DeviceExtension;

   //
   // Irp this packet belongs with.
   //
   PIRP Irp;

   //
   // Read/Write Timeout Value
   //
   LARGE_INTEGER Timeout;

   //
   // Read/Write Timer Object
   //
   KTIMER TimerObj;

   //
   // Read/Write TimerDPC Object
   //
   KDPC TimerDPCObj;

   //
   // Read/Write DPC Routine
   //
   PKDEFERRED_ROUTINE TimerDPCRoutine;

   //
   // Status
   //
   NTSTATUS Status;

   //
   // Urb for this write  N.B.: size is variable, so leave last
   // may not need it becase the Irp has a pointer to the Urb
   //
   URB Urb;

} USB_PACKET, *PUSB_PACKET;


//
// Note: the SL11 is now pushing faster transfer rates,
// and we were getting USBD_STATUS_BUFFER_OVERRUN with a 1024 USB Read Buffer.
//
// Note: ActiveSync can burst up to 6 IP packets at 1500 bytes each, so we have a Read Buffer
// to accomodate it (9000 bytes). Since all allocs are paged based and any space remaining inside that page is lost,
// then just round up to the next page size i.e., 3 (4k) pages.
// Note: we have hardcoded the page size here for x86 in case this driver ever makes it
// onto another platform (e.g. Alpha).
//
#if !defined (USE_RING_BUFF)
#define USB_READBUFF_SIZE     (4096 * 3)
#else
#define USB_READBUFF_SIZE     (4096)
#define RINGBUFF_SIZE                       (USB_READBUFF_SIZE * 3)
#define RINGBUFF_HIGHWATER_MARK  (RINGBUFF_SIZE/2)
//
// Ring Buffer to cache USB Reads.
//      Reads occur at the head.
//      Writes occur at the tail.
//      Both Head & Tail move in the same direction.
//
typedef struct _RING_BUFF {
    ULONG   Size;  // in bytes
    ULONG   CharsInBuff;
    PUCHAR  pBase;
    PUCHAR  pHead;
    PUCHAR  pTail;
} RING_BUFF, *PRING_BUFF;
#endif // USE_RING_BUFF

//
// PipeInfo->MaximumTransferSize
//
#define DEFAULT_PIPE_MAX_TRANSFER_SIZE      USB_READBUFF_SIZE


typedef struct _USB_PIPE {

    USBD_PIPE_HANDLE  hPipe;

    ULONG             MaxPacketSize;

    UCHAR             wIndex;

    LONG              ResetOrAbortPending;
    LONG              ResetOrAbortFailed;

} USB_PIPE, *PUSB_PIPE;


typedef struct _DEVICE_EXTENSION {

      ///////////////////////////////////////////////////////////
      //
      // WDM Interface
      //

      //
      // Device Extension's global SpinLock.
      // No major need for multiple locks since all paths basically need to sync to the same data.
      //
      KSPIN_LOCK  ControlLock;

      REMOVE_LOCK RemoveLock;

      //
      // Back pointer to our DeviceObject
      //
      PDEVICE_OBJECT DeviceObject;

      //
      // Device just below us in the device stack
      //
      PDEVICE_OBJECT NextDevice;

      //
      // Our Physical Device Object
      //
      PDEVICE_OBJECT PDO;

      //
      // Our Device PnP State
      //
      PNP_STATE PnPState;

      //
      // is the device removed
      //
      ULONG DeviceRemoved;

      //
      // is the device stopped
      //
      ULONG AcceptingRequests;

      //
      // open/close state
      //
      ULONG DeviceOpened;

#ifdef DELAY_RXBUFF
      //
      // used to emulate RX buffer
      //
      ULONG StartUsbRead;
#endif

#ifdef POWER
      // The CE devices do not yet handle power, let the bus driver manage

      //
      // SystemWake from devcaps
      //
      SYSTEM_POWER_STATE SystemWake;

      //
      // DeviceWake from devcaps
      //
      DEVICE_POWER_STATE DevicePowerState;
#endif

      //
      // User visible name \\DosDevices\WCEUSBSHx, where x = 001, 002, ...
      // Open as CreateFile("\\\\.\\WCEUSBSH001", ... )
      //
      CHAR DosDeviceName[DOS_NAME_MAX];

      //
      // (kernel) Device Name -- e.g., \\Devices\WCEUSBSHx
      //
      UNICODE_STRING DeviceName;

      //
      // True if a symbolic link has been
      // created to the kernel namspace and should be removed upon deletion.
      //
      BOOLEAN SymbolicLink;

      //
      // String where we keep the symbolic link that is returned to us when we
      // register our device (IoRegisterDeviceInterface) with the Plug and Play manager.
      // The string looks like \\??\\USB#Vid_0547&Pid_2720#Inst_0#{GUID}
      //
      UNICODE_STRING DeviceClassSymbolicName;

      //
      // Pointer to our Serial Port Interface
      //
      SERIAL_PORT_INTERFACE SerialPort;

      ///////////////////////////////////////////////////////////
      //
      // USB Interface ...
      //

      //
      // USB Device descriptor for this device
      //
      USB_DEVICE_DESCRIPTOR DeviceDescriptor;

      //
      // USBD configuration
      //
      USBD_CONFIGURATION_HANDLE  ConfigurationHandle;

      //
      // index of USB interface we are using
      //
      UCHAR UsbInterfaceNumber;

      //
      // USBD Pipe Handles
      //
      USB_PIPE ReadPipe;

      USB_PIPE WritePipe;

      //
      // FIFO size in bytes
      // written to PipeInfo->MaximumTransferSize
      //
      ULONG MaximumTransferSize;

      //
      // USB Packet (_USB_PACKET) Pool
      //
      NPAGED_LOOKASIDE_LIST PacketPool;

      //
      // Pending USB Packet Lists
      // We queue packets, not Irps. We allocate a packet from PacketPool,
      // then put it on it's R or W pending queue (list). When the I/O completes
      // then remove the packet from it's pending list & place back in
      // PacketPool. The list is processed FIFO, so the most recent packet is at the tail.
      // If a Timer fires then we remove the packet from the pending R/W
      // list, cancel the Irp, and put packet back in PacketPool.
      // The list is protected by grabbing the extension's global spinlock.
      //
      LIST_ENTRY  PendingReadPackets; // ListHead
      ULONG       PendingReadCount;

      LIST_ENTRY  PendingWritePackets; // ListHead
      LONG        PendingWriteCount;

      //
      // N-Paged LookAside Lists
      //
      NPAGED_LOOKASIDE_LIST BulkTransferUrbPool;
      NPAGED_LOOKASIDE_LIST PipeRequestUrbPool;
      NPAGED_LOOKASIDE_LIST VendorRequestUrbPool;

      //
      // These events are signalled for waiters (e.g. AbortPipes) when a packet list is empty
      //
      KEVENT PendingDataOutEvent;       // PendingWritePackets drained

      ULONG  PendingDataOutCount;

      //
      // Work Item context
      //
      NPAGED_LOOKASIDE_LIST WorkItemPool;
      LIST_ENTRY            PendingWorkItems;      // ListHead
      // remove lock
      LONG                  PendingWorkItemsCount;
      KEVENT                PendingWorkItemsEvent;


      ///////////////////////////////////////////////////
      //
      // support for buffered reads & polling the USBD stack
      //
      PIRP    UsbReadIrp;        // Irp for read requests to USBD
      PURB    UsbReadUrb;        // Urb for read requests to USBD

      //
      // USB Read state machine
      //
      ULONG   UsbReadState;

      //
      // Used to signal canceled USB read Irp.
      // Note that this could get signalled before the
      // PendingDataIn event.
      //
      KEVENT  UsbReadCancelEvent;

      //
      // This is the USB read buffer which gets sent down the USB stack,
      // not a ring-buffer for user.
      //
      PUCHAR UsbReadBuff;        // buffer for read requests
      ULONG UsbReadBuffSize;
      ULONG  UsbReadBuffIndex;   // current zero based index into read buffer
      ULONG  UsbReadBuffChars;   // current number of characters buffered

      KEVENT PendingDataInEvent; // signals PendingReadCount hit zero

#if defined (USE_RING_BUFF)
      //
      // Ring Buffer
      //
      RING_BUFF RingBuff;
#endif

      //
      // Current Read Irp which is pending from User
      //
      PIRP UserReadIrp;

      //
      // Read queue for pending user Read requests
      //
      LIST_ENTRY UserReadQueue;

      //
      // This value holds the number of characters desired for a
      // particular read.  It is initially set by read length in the (UserReadIrp)
      // IRP.  It is decremented each time more characters are placed
      // into the "users" buffer by the code that reads characters
      // out of the USB read buffer into the users buffer.  If the
      // read buffer is exhausted by the read, and the reads buffer
      // is given to the isr to fill, this value is becomes meaningless.
      //
      ULONG NumberNeededForRead;

      //
      // Timer for timeout on total read request
      //
      KTIMER ReadRequestTotalTimer;

      //
      // Timer for timeout on the interval
      //
      KTIMER ReadRequestIntervalTimer;

      //
      // Relative time set by the read code which holds the time value
      // used for read interval timing.  We keep it in the extension
      // so that the interval timer dpc routine determine if the
      // interval time has passed for the IO.
      //
      LARGE_INTEGER IntervalTime;

      //
      // This holds the system time when we last time we had
      // checked that we had actually read characters.  Used
      // for interval timing.
      //
      LARGE_INTEGER LastReadTime;

      //
      // This dpc is fired off if the timer for the total timeout
      // for the read expires.  It will execute a dpc routine that
      // will cause the current read to complete.
      //
      KDPC TotalReadTimeoutDpc;

      //
      // This dpc is fired off if the timer for the interval timeout
      // expires.  If no more characters have been read then the
      // dpc routine will cause the read to complete.  However, if
      // more characters have been read then the dpc routine will
      // resubmit the timer.
      //
      KDPC IntervalReadTimeoutDpc;

      //
      // This holds a count of the number of characters read
      // the last time the interval timer dpc fired.  It
      // is a long (rather than a ulong) since the other read
      // completion routines use negative values to indicate
      // to the interval timer that it should complete the read
      // if the interval timer DPC was lurking in some DPC queue when
      // some other way to complete occurs.
      //
      LONG CountOnLastRead;

      //
      // This is a count of the number of characters read by the
      // isr routine.  It is *ONLY* written at isr level.  We can
      // read it at dispatch level.
      //
      ULONG ReadByIsr;


      ///////////////////////////////////////////////////
      //
      // support for interrupt endpoints
      //
      USB_PIPE  IntPipe;
      ULONG     IntState;           // state machine for starting reads from completion routine
      PIRP      IntIrp;             // Irp for Int reads
      PURB      IntUrb;             // Urb for Int Irp

      // remove lock
      ULONG     PendingIntCount;
      KEVENT    PendingIntEvent;

      KEVENT    IntCancelEvent;
      PUCHAR    IntBuff;            // buffer for notifications

      // Value in 100 nanosec units to timeout USB reads
      // Used in conjunction with the INT endpoint
      LARGE_INTEGER IntReadTimeOut;
#if DBG
      LARGE_INTEGER LastIntReadTime;
#endif

      //
      // device error counters
      //
      ULONG  ReadDeviceErrors;
      ULONG  WriteDeviceErrors;
      ULONG  IntDeviceErrors;
      ULONG  EP0DeviceErrors;

      //
      // perf counters ~ SERIALPERF_STATS.
      //
      ULONG TtlWriteRequests;
      ULONG TtlWriteBytes;     // TTL bytes written for user

      ULONG TtlReadRequests;
      ULONG TtlReadBytes;        // TTL bytes read for user

      ULONG TtlUSBReadRequests;
      ULONG TtlUSBReadBytes;   // TTL bytes indicatid up from USB
      ULONG TtlUSBReadBuffOverruns;   // TTL USB read buffer overruns

#if defined (USE_RING_BUFF)
      ULONG TtlRingBuffOverruns; // TTL ring buffer overruns
#endif

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;



#define FIXUP_RAW_IRP( _pirp, _deviceObject ) \
{  \
   PIO_STACK_LOCATION _irpSp; \
   ASSERT( _pirp ); \
   ASSERT( _deviceObject ); \
   _pirp->CurrentLocation--; \
   _irpSp = IoGetNextIrpStackLocation( _pirp ); \
   ASSERT( _irpSp  );   \
   _pirp->Tail.Overlay.CurrentStackLocation = _irpSp; \
   _irpSp->MajorFunction = IRP_MJ_READ; \
   _irpSp->DeviceObject = _deviceObject; \
   _irpSp->Parameters.Others.Argument1 = 0; \
   _irpSp->Parameters.Others.Argument2 = 0; \
   _irpSp->Parameters.Others.Argument3 = 0; \
   _irpSp->Parameters.Others.Argument4 = 0; \
}


/***************************************************
    P R O T O S
***************************************************/

//
// common.c
//
NTSTATUS
QueryRegistryParameters(
   IN PUNICODE_STRING RegistryPath
    );

VOID
ReleaseSlot(
   IN LONG Slot
   );

NTSTATUS
AcquireSlot(
   OUT PULONG PSlot
   );

NTSTATUS
CreateDevObjAndSymLink(
    IN PDRIVER_OBJECT PDrvObj,
    IN PDEVICE_OBJECT PPDO,
    IN PDEVICE_OBJECT *PpDevObj,
    IN PCHAR PDevName
    );

NTSTATUS
DeleteDevObjAndSymLink(
   IN PDEVICE_OBJECT DeviceObject
   );

VOID
SetPVoidLocked(
   IN OUT PVOID *PDest,
   IN OUT PVOID Src,
   IN PKSPIN_LOCK PSpinLock
   );

typedef
VOID
(*PWCE_WORKER_THREAD_ROUTINE)(
    IN PWCE_WORK_ITEM Context
    );

NTSTATUS
QueueWorkItem(
   IN PDEVICE_OBJECT PDevObj,
   IN PWCE_WORKER_THREAD_ROUTINE WorkerRoutine,
   IN PVOID Context,
   IN ULONG Flags
   );

VOID
DequeueWorkItem(
   IN PDEVICE_OBJECT PDevObj,
   IN PWCE_WORK_ITEM PWorkItem
   );

NTSTATUS
WaitForPendingItem(
   IN PDEVICE_OBJECT PDevObj,
   IN PKEVENT PPendingEvent,
   IN PULONG  PPendingCount
   );

BOOLEAN
CanAcceptIoRequests(
   IN PDEVICE_OBJECT DeviceObject,
   IN BOOLEAN        AcquireLock,
   IN BOOLEAN        CheckOpened
   );

BOOLEAN
IsWin9x(
   VOID
   );

VOID
LogError(
   IN PDRIVER_OBJECT DriverObject,
   IN PDEVICE_OBJECT DeviceObject OPTIONAL,
   IN ULONG SequenceNumber,
   IN UCHAR MajorFunctionCode,
   IN UCHAR RetryCount,
   IN ULONG UniqueErrorValue,
   IN NTSTATUS FinalStatus,
   IN NTSTATUS SpecificIOStatus,
   IN ULONG LengthOfInsert1,
   IN PWCHAR Insert1,
   IN ULONG LengthOfInsert2,
   IN PWCHAR Insert2
   );

#if DBG
PCHAR
PnPMinorFunctionString (
   UCHAR MinorFunction
   );
#endif

//
// comport.c
//
LONG
GetFreeComPortNumber(
   VOID
   );

VOID
ReleaseCOMPort(
   LONG comPortNumber
   );

NTSTATUS
DoSerialPortNaming(
   IN PDEVICE_EXTENSION PDevExt,
   IN LONG  ComPortNumber
   );

VOID
UndoSerialPortNaming(
   IN PDEVICE_EXTENSION PDevExt
   );

//
// int.c
//
NTSTATUS
AllocUsbInterrupt(
   IN PDEVICE_EXTENSION DeviceExtension
   );

NTSTATUS
UsbInterruptRead(
   IN PDEVICE_EXTENSION DeviceExtension
   );

NTSTATUS
CancelUsbInterruptIrp(
   IN PDEVICE_OBJECT PDevObj
   );

//
// pnp.c
//
NTSTATUS
Pnp(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

NTSTATUS
Power(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
StopIo(
   IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
CleanUpPacketList(
   IN PDEVICE_OBJECT DeviceObject,
   IN PLIST_ENTRY PListHead,
   IN PKEVENT PEvent
   );

//
// read.c
//
NTSTATUS
AllocUsbRead(
   IN PDEVICE_EXTENSION PDevExt
   );

NTSTATUS
UsbRead(
   IN PDEVICE_EXTENSION PDevExt,
   IN BOOLEAN UseTimeout
   );

NTSTATUS
CancelUsbReadIrp(
   IN PDEVICE_OBJECT PDevObj
   );


NTSTATUS
Read(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

VOID
ReadTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   );

VOID
IntervalReadTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   );

//
// serioctl.c
//
NTSTATUS
SerialIoctl(
   PDEVICE_OBJECT PDevObj,
   PIRP PIrp
   );

NTSTATUS
SerialResetDevice(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP Irp,
   IN BOOLEAN ClearDTR
   );

VOID
ProcessSerialWaits(
   IN PDEVICE_EXTENSION PDevExt
   );

NTSTATUS
SerialPurgeRxClear(
   IN PDEVICE_OBJECT PDevObj,
   IN BOOLEAN CancelRead
   );

//
// usbio.c
//
NTSTATUS
UsbSubmitSyncUrb(
    IN PDEVICE_OBJECT   PDevObj,
    IN PURB             PUrb,
    IN BOOLEAN          Configuration,
    IN LONG             TimeOut
    );

NTSTATUS
UsbClassVendorCommand(
   IN PDEVICE_OBJECT PDevObj,
   IN UCHAR  Request,
   IN USHORT Value,
   IN USHORT Index,
   IN PVOID  Buffer,
   IN OUT PULONG BufferLen,
   IN BOOLEAN Read,
   IN ULONG   Class
   );

NTSTATUS
UsbReadWritePacket(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP PIrp,
   IN PIO_COMPLETION_ROUTINE  CompletionRoutine,
   IN LARGE_INTEGER Timeout,
   IN PKDEFERRED_ROUTINE TimeoutRoutine,
   IN BOOLEAN Read
   );

VOID
UsbBuildTransferUrb(
   PURB Urb,
   PUCHAR Buffer,
   ULONG Length,
   IN USBD_PIPE_HANDLE PipeHandle,
   IN BOOLEAN Read
   );


#define RESET TRUE
#define ABORT FALSE

NTSTATUS
UsbResetOrAbortPipe(
   IN PDEVICE_OBJECT PDevObj,
   IN PUSB_PIPE PPipe,
   IN BOOLEAN Reset
   );

VOID
UsbResetOrAbortPipeWorkItem(
   IN PWCE_WORK_ITEM PWorkItem
   );

//
// usbutils.c
//
NTSTATUS
UsbGetDeviceDescriptor(
   IN PDEVICE_OBJECT PDevObj
   );

NTSTATUS
UsbConfigureDevice(
   IN PDEVICE_OBJECT PDevObj
   );

//
// utils.c
//
typedef
NTSTATUS
(*PSTART_ROUTINE)(              // StartRoutine
   IN PDEVICE_EXTENSION
   );

typedef
VOID
(*PGET_NEXT_ROUTINE) (          // GetNextIrpRoutine
      IN PIRP *CurrentOpIrp,
      IN PLIST_ENTRY QueueToProcess,
      OUT PIRP *NewIrp,
      IN BOOLEAN CompleteCurrent,
      PDEVICE_EXTENSION Extension
      );

VOID
TryToCompleteCurrentIrp(
   IN PDEVICE_EXTENSION PDevExt,
   IN NTSTATUS StatusToUse,
   IN PIRP *PpCurrentOpIrp,
   IN PLIST_ENTRY PQueue OPTIONAL,
   IN PKTIMER PIntervalTimer OPTIONAL,
   IN PKTIMER PTotalTimer OPTIONAL,
   IN PSTART_ROUTINE Starter OPTIONAL,
   IN PGET_NEXT_ROUTINE PGetNextIrp OPTIONAL,
   IN LONG RefType,
   IN BOOLEAN Complete,
   IN KIRQL IrqlForRelease
   );

VOID
RecycleIrp(
   IN PDEVICE_OBJECT PDevOjb,
   IN PIRP  PIrp
   );

NTSTATUS
ManuallyCancelIrp(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

VOID
CalculateTimeout(
   IN OUT PLARGE_INTEGER PTimeOut,
   IN ULONG Length,
   IN ULONG Multiplier,
   IN ULONG Constant
   );

//
// wceusbsh.c
//
NTSTATUS
DriverEntry(
   IN PDRIVER_OBJECT PDrvObj,
   IN PUNICODE_STRING PRegistryPath
   );

NTSTATUS
AddDevice(
   IN PDRIVER_OBJECT PDrvObj,
   IN PDEVICE_OBJECT PPDO
   );

VOID
KillAllPendingUserReads(
   IN PDEVICE_OBJECT PDevObj,
   IN PLIST_ENTRY PQueueToClean,
   IN PIRP *PpCurrentOpIrp
   );

VOID
UsbFreeReadBuffer(
   IN PDEVICE_OBJECT PDevObj
   );

//
// write.c
//
NTSTATUS
Write(
   IN PDEVICE_OBJECT PDevObj,
   PIRP PIrp
   );

#endif // _WCEUSBSH_H_

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\utils.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

        UTILS.C

Abstract:

        Utility functions 

Environment:

        kernel mode only

Revision History:

        07-15-99  : created

Author:

        Jeff Midkiff (jeffmi)

Notes:

-- */

#include <wdm.h>
#include <stdio.h>
#include <stdlib.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <ntddser.h>

#include "wceusbsh.h"

__inline
VOID
ReuseIrp (
    PIRP Irp,
    NTSTATUS Status
    );

__inline
VOID
RundownIrpRefs(
   IN PIRP *PpCurrentOpIrp, 
   IN PKTIMER IntervalTimer OPTIONAL,
   IN PKTIMER TotalTimer OPTIONAL,
   IN PDEVICE_EXTENSION PDevExt
   );



VOID
TryToCompleteCurrentIrp(
    IN PDEVICE_EXTENSION PDevExt,
    IN NTSTATUS ReturnStatus,
    IN PIRP *PpCurrentIrp,
    IN PLIST_ENTRY PIrpQueue OPTIONAL,
    IN PKTIMER PIntervalTimer OPTIONAL,
    IN PKTIMER PTotalTimer OPTIONAL,
    IN PSTART_ROUTINE PStartNextIrpRoutine OPTIONAL,
    IN PGET_NEXT_ROUTINE PGetNextIrpRoutine OPTIONAL,
    IN LONG ReferenceType,
    IN BOOLEAN CompleteRequest,
    IN KIRQL IrqlForRelease
    )
/*++

Routine Description:

    This routine attempts to rundown all of the reasons there are
    references on the current Irp.  If everything can be killed
    then it will complete this Irp, and then try to start another.

    Similiar to StartIo.

   NOTE: This routine assumes that it is called with the control lock held.

Arguments:

    Extension - Simply a pointer to the device extension.

    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.

    IrqlForRelease - This routine is called with the control lock held.
                     This is the irql that was current when it was acquired.

    ReturnStatus - The irp's status field will be set to this value, if
                  this routine can complete the irp.


Return Value:

    None.

--*/

{
   PERF_ENTRY( PERF_TryToCompleteCurrentIrp );

   if ( !PDevExt || !PpCurrentIrp || !(*PpCurrentIrp) ) {
      DbgDump(DBG_ERR, ("TryToCompleteCurrentIrp: INVALID PARAMETER\n"));
      KeReleaseSpinLock(&PDevExt->ControlLock, IrqlForRelease);
      PERF_EXIT( PERF_TryToCompleteCurrentIrp );
      TEST_TRAP();
      return;
   }
   
   DbgDump(DBG_IRP|DBG_TRACE, (">TryToCompleteCurrentIrp(%p, 0x%x)\n", *PpCurrentIrp, ReturnStatus));

    //
    // We can decrement the reference to "remove" the fact
    // that the caller no longer will be accessing this irp.
    //
    IRP_CLEAR_REFERENCE(*PpCurrentIrp, ReferenceType);
    
    //
    // Try to run down all other references (i.e., Timers) to this irp.
    //
    RundownIrpRefs(PpCurrentIrp, PIntervalTimer, PTotalTimer, PDevExt);

    //
    // See if the ref count is zero after trying to kill everybody else.
    //
    if (!IRP_REFERENCE_COUNT(*PpCurrentIrp)) {
        //
        // The ref count was zero so we should complete this request.
        //
        PIRP pNewIrp;

        DbgDump( DBG_IRP, ("!IRP_REFERENCE_COUNT\n"));

         // set Irp's return status
        (*PpCurrentIrp)->IoStatus.Status = ReturnStatus;

        if (ReturnStatus == STATUS_CANCELLED) {

            (*PpCurrentIrp)->IoStatus.Information = 0;

        }

        if (PGetNextIrpRoutine) {
            //
            // Get the next Irp off the specified Irp queue
            //
            KeReleaseSpinLock(&PDevExt->ControlLock, IrqlForRelease);
            DbgDump( DBG_IRP, ("<< Current IRQL(1)\n"));
           
            DbgDump( DBG_IRP, ("Calling GetNextUserIrp\n"));
            (*PGetNextIrpRoutine)(PpCurrentIrp, PIrpQueue, &pNewIrp, CompleteRequest, PDevExt);

            if (pNewIrp) {
               //
               // There was an Irp in the queue
               //
               DbgDump( DBG_IRP, ("Calling StartNextIrpRoutine\n"));

                //
                // kick-start the next Irp
                //
                PStartNextIrpRoutine(PDevExt);
            }

        } else {
            
            PIRP pOldIrp = *PpCurrentIrp;
            
            //
            // There was no GetNextIrpRoutine.  
            // We will simply complete the Irp.  
            //
            DbgDump( DBG_IRP, ("No GetNextIrpRoutine\n"));
            
            *PpCurrentIrp = NULL;
            
            KeReleaseSpinLock(&PDevExt->ControlLock, IrqlForRelease);
            DbgDump( DBG_IRP, ("<< Current IRQL(2)\n"));
            
            if (CompleteRequest) {
               //
               // complete the Irp
               //
               DbgDump(DBG_IRP|DBG_READ|DBG_READ_LENGTH|DBG_TRACE, ("IoCompleteRequest(2, %p) Status: 0x%x Btyes: %d\n", pOldIrp, pOldIrp->IoStatus.Status,  pOldIrp->IoStatus.Information ));
             
               ReleaseRemoveLock(&PDevExt->RemoveLock, pOldIrp);

               IoCompleteRequest( pOldIrp, IO_NO_INCREMENT );
            }
        }

    } else {
        //
        // Irp still has outstanding references
        //
        DbgDump(DBG_WRN|DBG_IRP|DBG_TRACE, ("Current IRP %p still has reference of %x\n", *PpCurrentIrp,
                  ((UINT_PTR)((IoGetCurrentIrpStackLocation((*PpCurrentIrp))->
                               Parameters.Others.Argument4)))));

        KeReleaseSpinLock(&PDevExt->ControlLock, IrqlForRelease);
        DbgDump( DBG_IRP, ("<< Current IRQL(3)\n"));
    
   }

   DbgDump( DBG_IRP|DBG_TRACE, ("<TryToCompleteCurrentIrp\n"));

   PERF_EXIT( PERF_TryToCompleteCurrentIrp );
   
   return;
}



VOID
RundownIrpRefs(
   IN PIRP *PpCurrentIrp, 
   IN PKTIMER IntervalTimer OPTIONAL,
   IN PKTIMER TotalTimer OPTIONAL,
   IN PDEVICE_EXTENSION PDevExt
   )
/*++

Routine Description:

    This routine runs through the various items that *could*
    have a reference to the current read/write Irp.  It try's to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.

    NOTE: This routine assumes that it is called with the control lock held.

Arguments:

    PpCurrentIrp - Pointer to a pointer to current irp for the
                   particular operation.

    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.

    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.

    PDevExt - Pointer to device extension

Return Value:

    None.

--*/
{
   PERF_ENTRY( PERF_RundownIrpRefs );

   if ( !PDevExt || !PpCurrentIrp || !(*PpCurrentIrp) ) {
      DbgDump(DBG_ERR, ("RundownIrpRefs: INVALID PARAMETER\n"));
      PERF_EXIT( PERF_RundownIrpRefs );
      TEST_TRAP();
      return;
   }

   DbgDump(DBG_IRP, (">RundownIrpRefs(%p)\n", *PpCurrentIrp));
   
    //
    // This routine is called with the cancel spin lock held
    // so we know only one thread of execution can be in here
    // at one time.
    //

    //
    // First we see if there is still a cancel routine.  If
    // so then we can decrement the count by one.
    //
    if ((*PpCurrentIrp)->CancelRoutine) {

        IRP_CLEAR_REFERENCE(*PpCurrentIrp, IRP_REF_CANCEL);

        IoSetCancelRoutine(*PpCurrentIrp, NULL);

    }

    if (IntervalTimer) {
        //
        // Try to cancel the operation's interval timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an interval timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //
        if (KeCancelTimer(IntervalTimer)) {
            IRP_CLEAR_REFERENCE(*PpCurrentIrp, IRP_REF_INTERVAL_TIMER);
        } else {
            // short circuit the read irp from the interval timer
            DbgDump(DBG_IRP|DBG_TIME, ("clearing IRP_REF_INTERVAL_TIMER on (%p)\n", *PpCurrentIrp ));
            IRP_CLEAR_REFERENCE(*PpCurrentIrp, IRP_REF_INTERVAL_TIMER);
        }
    }

    if (TotalTimer) {
        //
        // Try to cancel the operations total timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an total timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //        
        // If we have an escape char event pending, we can't overstuff,
        // so subtract one from the length
        //

        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //
        if (KeCancelTimer(TotalTimer)) {
            IRP_CLEAR_REFERENCE(*PpCurrentIrp, IRP_REF_TOTAL_TIMER);
        }
    }

   DbgDump(DBG_IRP, ("<RundownIrpRefs\n"));

   PERF_EXIT( PERF_RundownIrpRefs );

   return;
}


//
// Recycle the passed in Irp for reuse.
// May be called holding a SpinLock to protect your Irp.
//
VOID
RecycleIrp(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP  PIrp
   )
{
   NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;

   PERF_ENTRY( PERF_RecycleIrp );

   DbgDump(DBG_IRP, (">RecycleIrp(%p)\n", PIrp));

   if ( PDevObj && PIrp ) {
      //
      // recycle the Irp
      //
      IoSetCancelRoutine( PIrp, NULL );  

      ReuseIrp( PIrp, STATUS_SUCCESS ); 

      FIXUP_RAW_IRP( PIrp, PDevObj );

   } else {
      DbgDump(DBG_ERR, ("RecycleIrp: INVALID PARAMETER !!\n"));
      TEST_TRAP();
   }

   DbgDump(DBG_IRP, ("<RecycleIrp\n" ));

   PERF_EXIT( PERF_RecycleIrp );

   return;
}


__inline
VOID
ReuseIrp(
   PIRP Irp,
   NTSTATUS Status
   )
/*--

Routine Description:

    This routine is used by drivers to initialize an already allocated IRP for reuse.
    It does what IoInitializeIrp does but it saves the allocation flags so that we know
    how to free the Irp and take care of quote requirements. Call ReuseIrp
    instead of calling IoInitializeIrp to reinitialize an IRP.

Arguments:

    Irp - Pointer to Irp to be reused

    Status - Status to preinitialize the Iostatus field.

--*/
{
    USHORT  PacketSize;
    CCHAR   StackSize;
    UCHAR   AllocationFlags;

    PERF_ENTRY( PERF_ReuseIrp );

    // Did anyone forget to pull their cancel routine?
    ASSERT(Irp->CancelRoutine == NULL) ;

    // We probably don't want thread enqueue'd IRPs to be used
    // ping-pong style as they cannot be dequeue unless they
    // complete entirely. Not really an issue for worker threads,
    // but definitely for operations on application threads.
#if DBG
   if (!g_isWin9x) {
      ASSERT(IsListEmpty(&Irp->ThreadListEntry));
   }
#endif

   AllocationFlags = Irp->AllocationFlags;
   StackSize = Irp->StackCount;
   PacketSize =  IoSizeOfIrp(StackSize);
   IoInitializeIrp(Irp, PacketSize, StackSize);
   Irp->AllocationFlags = AllocationFlags;
   Irp->IoStatus.Status = Status;

   PERF_EXIT( PERF_ReuseIrp );

   return;
}


NTSTATUS
ManuallyCancelIrp(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDRIVER_CANCEL pCancelRoutine;
   NTSTATUS status = STATUS_SUCCESS;
   KIRQL irql, cancelIrql;
   BOOLEAN bReleased = FALSE;

   DbgDump(DBG_IRP, (">ManuallyCancelIrp (%p)\n", PIrp ));

   KeAcquireSpinLock( &pDevExt->ControlLock, &irql );

   if ( PIrp ) {
            
        pCancelRoutine = PIrp->CancelRoutine;
        PIrp->Cancel = TRUE;

        //
        // If the current irp is not in a cancelable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancelable state then the following will kill it.
        //
        if (pCancelRoutine) {

            PIrp->CancelRoutine = NULL;
            PIrp->CancelIrql = irql;

            //
            // This irp is in a cancelable state.  We simply
            // mark it as canceled and manually call the cancel routine.
            //
            bReleased = TRUE;
            KeReleaseSpinLock( &pDevExt->ControlLock, irql );

            IoAcquireCancelSpinLock(&cancelIrql);

            ASSERT(irql == cancelIrql);

            DbgDump(DBG_IRP, ("Invoking Cancel Routine (%p)\n", pCancelRoutine ));

            pCancelRoutine(PDevObj, PIrp);

            //
            // pCancelRoutine releases the cancel lock
            //

         } else {

            DbgDump(DBG_WRN, ("No CancelRoutine on %p\n", PIrp ));

         }

   } else {

      // the Irp could have completed already since we relesed the 
      // spinlock before calling, so call it a success.
      DbgDump(DBG_WRN, ("ManuallyCancelIrp: No Irp!\n"));

   }

   if (!bReleased) {
      KeReleaseSpinLock( &pDevExt->ControlLock, irql );
   }


   DbgDump(DBG_IRP, (">ManuallyCancelIrp 0x%x\n", status ));
   
   return status;
}



//
// Calculates a Serial Timeout in millisec
//
VOID
CalculateTimeout(
   IN OUT PLARGE_INTEGER PTimeOut,
   IN ULONG Length,
   IN ULONG Multiplier,
   IN ULONG Constant
   )
{
   PERF_ENTRY( PERF_CalculateTimeout );
   
   if (PTimeOut) {

      PTimeOut->QuadPart = (LONGLONG)0;

      if (Multiplier) {

         PTimeOut->QuadPart = UInt32x32To64( Length, Multiplier);
      }

      if (Constant) {
         
         PTimeOut->QuadPart += (LONGLONG)Constant;

      }

      //
      // put into (relative) 100-nano second units
      //
      PTimeOut->QuadPart = MILLISEC_TO_100NANOSEC( PTimeOut->QuadPart );
   
   } else {
      TEST_TRAP();
   }

   PERF_EXIT( PERF_CalculateTimeout );
   
   return;
}


// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\usbio.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

        USBIO.C

Abstract:

        USB I/O functions

Environment:

        kernel mode only


Revision History:

        07-14-99 : created

Authors:

       Jeff Midkiff  (jeffmi)

-- */

#include <wdm.h>
#include <stdio.h>
#include <stdlib.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <ntddser.h>

#include "wceusbsh.h"


NTSTATUS
UsbSubmitSyncUrbCompletion(
    IN PDEVICE_OBJECT PDevObj,
    IN PIRP PIrp,
    IN PKEVENT PSyncEvent
    )
/*++

Routine Description:


Arguments:

    PDevObj - Pointer to Device Object
    PIrp - Pointer to IRP that is being completed
    PSyncEvent - Pointer to event that we should set

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
   UNREFERENCED_PARAMETER( PDevObj );
   UNREFERENCED_PARAMETER( PIrp );

   DbgDump(DBG_USB, (">UsbSubmitSyncUrbCompletion (%p)\n", PIrp) );

   ASSERT( PSyncEvent );
   KeSetEvent( PSyncEvent, IO_NO_INCREMENT, FALSE );

   DbgDump(DBG_USB, ("<UsbSubmitSyncUrbCompletion 0x%x\n", PIrp->IoStatus.Status ) );

   // our driver owns and releases the irp
   return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
UsbSubmitSyncUrb(
   IN PDEVICE_OBJECT    PDevObj,
   IN PURB              PUrb,
   IN BOOLEAN           Configuration,
   IN LONG              TimeOut
   )
/*++

Routine Description:

    This routine issues a synchronous URB request to the USBD.

Arguments:

    PDevObj - Ptr to our FDO

    PUrb - URB to pass

    Configuration - special case to allow USB config transactions onto the bus.
        We need to do this because a) if the device was removed then we can stall the controller
        which results in a reset kicking anything off the bus and re-enumerating the bus.
        b) to trap any cases of suprise removal from numerous paths

    TimeOut - timeout in milliseconds

Note: runs at PASSIVE_LEVEL.

Return Value:

    NTSTATUS - propogates status from USBD

--*/
{
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
    IO_STATUS_BLOCK ioStatus = {0, 0};
    PIO_STACK_LOCATION pNextIrpSp;
    KEVENT event;
    NTSTATUS status, wait_status;
    PIRP pIrp;

    PAGED_CODE();

    DbgDump(DBG_USB|DBG_TRACE, (">UsbSubmitSyncUrb\n") );

    if ( !PUrb || !pDevExt->NextDevice ) {
        status = STATUS_INVALID_PARAMETER;
        DbgDump(DBG_ERR, ("UsbSubmitSyncUrb.1: 0x%x\n", status));
        TEST_TRAP();
        return status;
    }

    if ( !Configuration && !CanAcceptIoRequests(PDevObj, TRUE, TRUE) ) {
        status = STATUS_DELETE_PENDING;
        DbgDump(DBG_ERR, ("UsbSubmitSyncUrb.2: 0x%x\n", status));
        return status;
    }

    // we need to grab the lock here to keep it's IoCount correct
    status = AcquireRemoveLock(&pDevExt->RemoveLock, PUrb);
    if ( !NT_SUCCESS(status) ) {
        DbgDump(DBG_ERR, ("UsbSubmitSyncUrb.3: 0x%x\n", status));
        return status;
    }

    DbgDump(DBG_USB, (">UsbSubmitSyncUrb (%p, %p)\n", PDevObj, PUrb) );

    pIrp = IoAllocateIrp( (CCHAR)(pDevExt->NextDevice->StackSize + 1), FALSE);

    if ( pIrp ) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        RecycleIrp( PDevObj, pIrp);

        IoSetCompletionRoutine(pIrp,
                               UsbSubmitSyncUrbCompletion,
                               &event,  // Context
                               TRUE, TRUE, TRUE );

        pNextIrpSp = IoGetNextIrpStackLocation(pIrp);
        ASSERT(pNextIrpSp);
        pNextIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        pNextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
        pNextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
        pNextIrpSp->Parameters.DeviceIoControl.InputBufferLength = 0;

        pNextIrpSp->Parameters.Others.Argument1 = PUrb;

        status = IoCallDriver( pDevExt->NextDevice, pIrp );

        if (STATUS_PENDING == status ) {
            //
            // Set a default timeout in case the hardware is flakey, so USB will not hang us.
            // We may want these timeouts user configurable via registry.
            //
            LARGE_INTEGER timeOut;

            ASSERT(TimeOut >= 0);
            timeOut.QuadPart = MILLISEC_TO_100NANOSEC( (TimeOut == 0 ? DEFAULT_PENDING_TIMEOUT : TimeOut) );

            wait_status = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, &timeOut );

            if (STATUS_TIMEOUT == wait_status) {
                //
                // The wait timed out, try to cancel the Irp.
                // N.B: if you freed the Irp in the completion routine
                // then you have a race condition between the completion routine freeing the Irp
                // and the timer firing where we need to set the cancel bit.
                //
                DbgDump(DBG_USB|DBG_WRN, ("UsbSubmitSyncUrb: STATUS_TIMEOUT\n"));

                if ( !IoCancelIrp(pIrp) ) {
                    //
                    // This means USB has the Irp in a non-canceable state.
                    //
                    DbgDump(DBG_ERR, ("!IoCancelIrp(%p)\n", pIrp));
                    TEST_TRAP();
                }

                //
                // Wait for our completion routine, to see if the Irp completed normally or actually cancelled.
                // An alternative could be alloc an event & status block, stored in the Irp
                // strung along a list, which would also get freed in the completion routine...
                // which creates other problems not worth the effort for an exit condition.
                //
                wait_status = KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL );
            }
        }

        //
        // The completion routine signalled the event and completed,
        // and our the timer has expired. Now we can safely free the Irp.
        //
        status = pIrp->IoStatus.Status;

#if DBG
        if (STATUS_SUCCESS != status) {
            DbgDump(DBG_ERR, ("UsbSubmitSyncUrb IrpStatus: 0x%x UrbStatus: 0x%x\n", status, PUrb->UrbHeader.Status) );
        }
#endif

        IoFreeIrp( pIrp );

    } else {
        DbgDump(DBG_ERR, ("IoAllocateIrp failed!\n") );
        status = STATUS_INSUFFICIENT_RESOURCES;
        TEST_TRAP();
    }

    ReleaseRemoveLock(&pDevExt->RemoveLock, PUrb);

    DbgDump(DBG_USB|DBG_TRACE, ("<UsbSubmitSyncUrb (0x%x)\n", status) );

    return status;
}


NTSTATUS
UsbClassVendorCommand(
   IN PDEVICE_OBJECT PDevObj,
   IN UCHAR  Request,
   IN USHORT Value,
   IN USHORT Index,
   IN PVOID  Buffer,
   IN OUT PULONG BufferLen,
   IN BOOLEAN Read,
   IN ULONG   Class
   )
/*++

Routine Description:

   Issue class or vendor specific command

Arguments:

   PDevObj      - pointer to a your object
   Request      - request field of class/vendor specific command
   Value        - value field of class/vendor specific command
   Index        - index field of class/vendor specific command
   Buffer       - pointer to data buffer
   BufferLen    - data buffer length
   Read         - data direction flag
   Class        - True if Class Command, else vendor command

Return Value:
    NTSTATUS

--*/
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status;
   PURB     pUrb;
   ULONG    ulSize;
   ULONG    ulLength;

   PAGED_CODE();

   DbgDump(DBG_USB, (">UsbClassVendorCommand\n" ));

   ulLength = BufferLen ? *BufferLen : 0;

   ulSize = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);

   pUrb = ExAllocateFromNPagedLookasideList( &pDevExt->VendorRequestUrbPool );

   if (pUrb) {

      UsbBuildVendorRequest( pUrb,
                             Class == WCEUSB_CLASS_COMMAND ? URB_FUNCTION_CLASS_INTERFACE : URB_FUNCTION_VENDOR_DEVICE,
                             (USHORT)ulSize,
                             Read ? USBD_TRANSFER_DIRECTION_IN : USBD_TRANSFER_DIRECTION_OUT,
                             0,
                             Request,
                             Value,
                             Index,
                             Buffer,
                             NULL,
                             ulLength,
                             NULL);

      status = UsbSubmitSyncUrb(PDevObj, pUrb, FALSE, DEFAULT_CTRL_TIMEOUT);

      if (BufferLen)
         *BufferLen = pUrb->UrbControlVendorClassRequest.TransferBufferLength;

      ExFreeToNPagedLookasideList( &pDevExt->VendorRequestUrbPool, pUrb );

   } else {
      status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("ExAllocatePool error: 0x%x\n", status));
      TEST_TRAP();
   }

   DbgDump(DBG_USB, ("<UsbClassVendorCommand (0x%x)\n", status));

   return status;
}



/////////////////////////////////////////////////////////////////////////
//
//    Usb Read / Write Utils
//

NTSTATUS
UsbReadWritePacket(
   IN PDEVICE_EXTENSION PDevExt,
   IN PIRP PIrp,
   IN PIO_COMPLETION_ROUTINE CompletionRoutine,
   IN LARGE_INTEGER TimeOut,
   IN PKDEFERRED_ROUTINE TimeoutRoutine,
   IN BOOLEAN Read
   )
/*++

Routine Description:

    This function allocates and passes a Bulk Transfer URB Request
    down to USBD to perform a Read/Write. Note that the Packet
    MUST freed (put back on the packet list) in the
    CompletionRoutine.

Arguments:

    PDevExt - Pointer to device extension

    PIrp    - Read/Write IRP

    CompletionRoutine - completion routine to set in the Irp

    TimeOut - Timeout value for packet. If no timeout is
      specified the we use a default timeout.

    Read - TRUE for Read, else Write

Return Value:

    NTSTATUS

Notes:

   This is not currently documented in the DDK, so here 's what
   happens:

   We pass the Irp to USBD. USBD parameter checks the Irp.
   If any parameters are invalid then USBD returns an NT status code
   and Urb status code, then the Irp goes to our completion routine.
   If there are no errors then USBD passes Irp to HCD. HCD queues the
   Irp to it's StartIo & and returns STATUS_PENDING.  When HCD finishes
   the (DMA) transfer it completes the Irp, setting the Irp & Urb status
   fields. USBD's completion routine gets the Irp, translates any HCD
   error codes, completes it, which percolates it back up to our
   completion routine.

   Note: HCD uses DMA & therefore MDLs. Since this client driver
   currently uses METHOD_BUFFERED, then USBD allocates an MDL for
   HCD. So you have the I/O manager double bufffering the data
   and USBD mapping MDLs. What the hell, we have to buffer user reads
   too... uggh. Note that if you change to method direct then
   the read path gets nastier.

   Note: when the user submits a write buffer > MaxTransferSize
   then we reject the buffer.

--*/
{
   PIO_STACK_LOCATION pIrpSp;
   PUSB_PACKET   pPacket;
   NTSTATUS status;
   KIRQL irql; //, cancelIrql;
   PURB  pUrb;
   PVOID pvBuffer;
   ULONG ulLength;
   USBD_PIPE_HANDLE hPipe;

   PERF_ENTRY( PERF_UsbReadWritePacket );

   DbgDump(DBG_USB, (">UsbReadWritePacket (%p, %p, %d, %d)\n", PDevExt->DeviceObject, PIrp, TimeOut.QuadPart/10000, Read));


   if ( !PDevExt || !PIrp || !CompletionRoutine ) {

      status = PIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
      DbgDump(DBG_ERR, ("<UsbReadWritePacket 0x%x\n", status));
      KeAcquireSpinLock( &PDevExt->ControlLock, &irql );

      TryToCompleteCurrentIrp(
               PDevExt,
               status,
               &PIrp,
                NULL,               // Queue
                NULL,               // IntervalTimer
                NULL,               // PTotalTimer
                NULL,               // Starter
                NULL,               // PGetNextIrp
                IRP_REF_RX_BUFFER,  // RefType
                (BOOLEAN)(!Read),
                irql  ); // Complete

      PERF_EXIT( PERF_UsbReadWritePacket );
      TEST_TRAP();
      return status;
   }

   IRP_SET_REFERENCE(PIrp, IRP_REF_RX_BUFFER);

   pIrpSp = IoGetCurrentIrpStackLocation(PIrp);
   ASSERT( pIrpSp );

   //
   // Allocate & Build a USB Bulk Transfer Request (Packet)
   //
   pPacket = ExAllocateFromNPagedLookasideList( &PDevExt->PacketPool );

   if ( !pPacket ) {

      status = PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
      DbgDump(DBG_ERR, ("<UsbReadWritePacket 0x%x\n", status));
      KeAcquireSpinLock( &PDevExt->ControlLock, &irql );

      TryToCompleteCurrentIrp(
               PDevExt,
               status,
               &PIrp,
                NULL,               // Queue
                NULL,               // IntervalTimer
                NULL,               // PTotalTimer
                NULL,               // Starter
                NULL,               // PGetNextIrp
                IRP_REF_RX_BUFFER,  // RefType
                (BOOLEAN)(!Read),
                irql );

      PERF_EXIT( PERF_UsbReadWritePacket );
      TEST_TRAP();
      return status;
   }

   //
   // init the Packet
   //
   RtlZeroMemory( pPacket, sizeof(USB_PACKET) );

   pPacket->DeviceExtension = PDevExt;

   pPacket->Irp = PIrp;

   pUrb = &pPacket->Urb;
   ASSERT( pUrb );

   KeAcquireSpinLock( &PDevExt->ControlLock, &irql );


   if (Read) {
      //
      // store the Urb for buffered reads
      //
      PDevExt->UsbReadUrb = pUrb;
   }

   //
   // Build the URB.
   // Note: HCD breaks up our buffer into Transport Descriptors (TD)
   // of PipeInfo->MaxPacketSize.
   // Q: does USBD/HCD look at the PipeInfo->MaxTransferSize to see
   // if he can Rx/Tx?
   // A: Yes. HCD will return urbStatus = USBD_STATUS_INVALID_PARAMETER
   // and status = STATUS_INVALID_PARAMETER of too large.
   //
   ASSERT( Read ? (PDevExt->UsbReadBuffSize <= PDevExt->MaximumTransferSize ) :
                  (pIrpSp->Parameters.Write.Length <= PDevExt->MaximumTransferSize ) );

   //
   // Note: Reads are done into our local USB read buffer,
   // and then copied into the user's buffer on completion.
   // Writes are done directly from user's buffer.
   // We allow NULL writes to indicate end of a USB transaction.
   //
   pvBuffer = Read ? PDevExt->UsbReadBuff :
                     PIrp->AssociatedIrp.SystemBuffer;

   ulLength = Read ? PDevExt->UsbReadBuffSize :
                     pIrpSp->Parameters.Write.Length;

   hPipe = Read ? PDevExt->ReadPipe.hPipe :
                 PDevExt->WritePipe.hPipe;

   ASSERT( hPipe );

   UsbBuildTransferUrb(
            pUrb,       // Urb
            pvBuffer,   // Buffer
            ulLength,   // Length
            hPipe,       // PipeHandle
            Read        // ReadRequest
            );

   //
   // put the packet on a pending list
   //
   InsertTailList( Read ? &PDevExt->PendingReadPackets : // ListHead,
                          &PDevExt->PendingWritePackets,
                   &pPacket->ListEntry );                // ListEntry

   //
   // Increment the pending packet counter
   //
   InterlockedIncrement( Read ? &PDevExt->PendingReadCount:
                                &PDevExt->PendingWriteCount );

   //
   // Setup Irp for submit Urb IOCTL
   //
   IoCopyCurrentIrpStackLocationToNext(PIrp);

   pIrpSp = IoGetNextIrpStackLocation(PIrp);

   pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

   pIrpSp->Parameters.Others.Argument1 = pUrb;

   pIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

   IoSetCompletionRoutine( PIrp,
                           CompletionRoutine,
                           pPacket,          // Context
                           TRUE, TRUE, TRUE);
   //
   // Initialize and Arm the Packet's Timer.
   // If the Timer fires then the packet's Timeout routine runs.
   //
   KeInitializeTimer( &pPacket->TimerObj );

   if ( 0 != TimeOut.QuadPart ) {

      pPacket->Timeout = TimeOut;

      ASSERT( TimeoutRoutine );

      pPacket->TimerDPCRoutine = TimeoutRoutine;

      KeInitializeDpc( &pPacket->TimerDPCObj,      // DPC Object
                       pPacket->TimerDPCRoutine,   // DPC Routine
                       pPacket );                  // Context

      DbgDump(DBG_USB, ("Timer for Irp %p due in %d msec\n", pPacket->Irp, pPacket->Timeout.QuadPart/10000 ));

      KeSetTimer( &pPacket->TimerObj,      // TimerObj
                  pPacket->Timeout,        // DueTime
                  &pPacket->TimerDPCObj    // DPC Obj
                  );

   }

   //
   // pass the Irp to USBD
   //
   DbgDump(DBG_IRP, ("UsbReadWritePacket IoCallDriver with %p\n", PIrp));

   KeReleaseSpinLock( &PDevExt->ControlLock, irql );

   status = IoCallDriver( PDevExt->NextDevice, PIrp );

   if ( (STATUS_SUCCESS != status) && (STATUS_PENDING != status) ) {
      //
      // We end up here after our completion routine runs
      // for an error condition i.e., when we have and
      // invalid parameter, or when user pulls the plug, etc.
      //
      DbgDump(DBG_ERR, ("UsbReadWritePacket error: 0x%x\n", status));
   }

   DbgDump(DBG_USB , ("<UsbReadWritePacket 0x%x\n", status));

   PERF_EXIT( PERF_UsbReadWritePacket );

   return status;
}



//
// This routine sets up a PUrb for a _URB_BULK_OR_INTERRUPT_TRANSFER.
// It assumes it's called holding a SpinLock.
//
VOID
UsbBuildTransferUrb(
    PURB PUrb,
    PUCHAR PBuffer,
    ULONG Length,
    IN USBD_PIPE_HANDLE PipeHandle,
    IN BOOLEAN Read
    )
{
   ULONG size;

   ASSERT( PUrb );
   ASSERT( PipeHandle );

   size = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

   RtlZeroMemory(PUrb, size);

   PUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)size;

   PUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;

   PUrb->UrbBulkOrInterruptTransfer.Hdr.Status = USBD_STATUS_SUCCESS;

   PUrb->UrbBulkOrInterruptTransfer.PipeHandle = PipeHandle;

   //
   // we are using a tranfsfer buffer instead of an MDL
   //
   PUrb->UrbBulkOrInterruptTransfer.TransferBuffer = PBuffer;

   PUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = Length;

   PUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;

   //
   // Set transfer flags
   //
   PUrb->UrbBulkOrInterruptTransfer.TransferFlags |= Read ? USBD_TRANSFER_DIRECTION_IN : USBD_TRANSFER_DIRECTION_OUT;

   //
   // Short transfer is not treated as an error.
   // If USBD_TRANSFER_DIRECTION_IN is set,
   // directs the HCD not to return an error if a packet is received from the device
   // shorter than the maximum packet size for the endpoint.
   // Otherwise, a short request is returns an error condition.
   //
   PUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;

   //
   // no linkage for now
   //
   PUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

   return;
}


/////////////////////////////////////////////////////////////////////////
//
//    Usb Reset Utils
//
VOID
UsbResetOrAbortPipeWorkItem(
   IN PWCE_WORK_ITEM PWorkItem
   )
{
    PDEVICE_OBJECT    pDevObj = PWorkItem->DeviceObject;
    PDEVICE_EXTENSION pDevExt = pDevObj->DeviceExtension;

    UCHAR    retries = 0;
    ULONG    ulUniqueErrorValue = 0;
    NTSTATUS status = STATUS_DELETE_PENDING;

    DbgDump(DBG_WORK_ITEMS, (">UsbResetOrAbortPipeWorkItem (0x%x)\n", pDevObj));

    //
    // The work item was queued at IRQL > PASSIVE some time ago from an I/O completion routine.
    // If we are unsuccessful after max retries then stop taking I/O requests & assume the device is broken
    //
    if ( CanAcceptIoRequests(pDevObj, TRUE, TRUE) )
    {
        switch (PWorkItem->Flags)
        {
            case WORK_ITEM_RESET_READ_PIPE:
            {
                DbgDump(DBG_WORK_ITEMS, ("WORK_ITEM_RESET_READ_PIPE\n"));

                if ( pDevExt->ReadDeviceErrors < g_ulMaxPipeErrors)
                {
                   //
                   // reset read Pipe, which could fail.
                   // E.g. flakey h/w, suprise remove, timeout, ...
                   //
                   status = UsbResetOrAbortPipe( pDevObj, &pDevExt->ReadPipe, RESET );

                   switch (status)
                   {
                       case STATUS_SUCCESS:
                       {
                          //
                          // kick start another read
                          //
                          status = UsbRead( pDevExt,
                                           (BOOLEAN)(pDevExt->IntPipe.hPipe ? TRUE : FALSE) );

                          if ( (STATUS_SUCCESS == status) || (STATUS_PENDING == status) ) {
                             //
                             // the device recovered OK
                             //
                             status = STATUS_SUCCESS;

                          } else {
                             DbgDump(DBG_ERR, ("UsbRead error: 0x%x\n", status));
                          }

                       } break;

                       case STATUS_UNSUCCESSFUL:
                       // a previous reset/abort request failed, so this request was rejected
                       break;

                       case STATUS_DELETE_PENDING:
                       // the device is going away
                       break;

                       case STATUS_PENDING:
                       // there is a reset/abort request already pending
                       break;

                       default:
                       {
                          //
                          // if we can not reset the endpoint the device is hosed or removed
                          //
                          DbgDump(DBG_ERR, ("UsbResetOrAbortPipeWorkItem.1 error: 0x%x\n", status ));
                          retries = 1;
                          ulUniqueErrorValue = ERR_NO_READ_PIPE_RESET;
                       } break;

                    } // status

                } else {
                    status = (NTSTATUS)PtrToLong(PWorkItem->Context); // Urb status is stored here
                    retries = (UCHAR)pDevExt->ReadDeviceErrors;
                    ulUniqueErrorValue = ERR_MAX_READ_PIPE_DEVICE_ERRORS;
                }

                if ( USBD_STATUS_BUFFER_OVERRUN == (USBD_STATUS)PtrToLong(PWorkItem->Context)) {
                    LogError( NULL,
                             pDevObj,
                             0, 0,
                             (UCHAR)pDevExt->ReadDeviceErrors,
                             ERR_USB_READ_BUFF_OVERRUN,
                             (USBD_STATUS)PtrToLong(PWorkItem->Context),
                             SERIAL_USB_READ_BUFF_OVERRUN,
                             pDevExt->DeviceName.Length + sizeof(WCHAR),
                             pDevExt->DeviceName.Buffer,
                             0, NULL );
                }
            } // WORK_ITEM_RESET_READ_PIPE
            break;


            case WORK_ITEM_RESET_WRITE_PIPE:
            {
                DbgDump(DBG_WORK_ITEMS, ("WORK_ITEM_RESET_WRITE_PIPE\n"));

                if (pDevExt->WriteDeviceErrors < g_ulMaxPipeErrors)
                {
                   //
                   // reset write Pipe, which could fail.
                   // E.g. flakey h/w, suprise remove, timeout, ...
                   //
                   status = UsbResetOrAbortPipe( pDevObj, &pDevExt->WritePipe, RESET );

                   switch (status)
                   {
                       case STATUS_SUCCESS:
                       // the device recovered OK
                       break;

                       case STATUS_UNSUCCESSFUL:
                       // a previous reset/abort request failed, so this request was rejected
                       break;

                       case STATUS_DELETE_PENDING:
                       // the device is going away
                       break;

                       case STATUS_PENDING:
                       // there is a reset/abort request already pending
                       break;

                       default: {
                          //
                          // if we can not reset the endpoint the device is hosed or removed
                          //
                          DbgDump(DBG_ERR, ("UsbResetOrAbortPipeWorkItem.2 error: 0x%x\n", status ));
                          retries = 1;
                          ulUniqueErrorValue = ERR_NO_WRITE_PIPE_RESET;
                       } break;

                    } // status

                } else {
                    status = (NTSTATUS)PtrToLong(PWorkItem->Context);
                    retries = (UCHAR)pDevExt->WriteDeviceErrors;
                    ulUniqueErrorValue = ERR_MAX_WRITE_PIPE_DEVICE_ERRORS;
                }

            } // WORK_ITEM_RESET_WRITE_PIPE
            break;


            case WORK_ITEM_RESET_INT_PIPE:
            {
                DbgDump(DBG_WORK_ITEMS, ("WORK_ITEM_RESET_INT_PIPE\n"));

                if ( pDevExt->IntDeviceErrors < g_ulMaxPipeErrors)
                {
                   //
                   // reset INT Pipe, which could fail.
                   // E.g. flakey h/w, suprise remove, timeout, ...
                   //
                   status = UsbResetOrAbortPipe( pDevObj, &pDevExt->IntPipe, RESET );

                   switch (status)
                   {
                       case STATUS_SUCCESS:
                       {
                          //
                          // kick start another INT read
                          //
                          status = UsbInterruptRead( pDevExt );

                          if ((STATUS_SUCCESS == status) || (STATUS_PENDING == status) ) {
                             //
                             // the device recovered OK
                             //
                             status = STATUS_SUCCESS;

                          } else {
                             DbgDump(DBG_ERR, ("UsbInterruptRead error: 0x%x\n", status));
                          }

                       } break;

                       case STATUS_UNSUCCESSFUL:
                       // a previous reset/abort request failed, so this request was rejected
                       break;

                       case STATUS_DELETE_PENDING:
                       // the device is going away
                       break;

                       case STATUS_PENDING:
                       // there is a reset/abort request already pending
                       break;

                       default:
                       {
                          //
                          // if we can not reset the endpoint the device is either hosed or removed
                          //
                          DbgDump(DBG_ERR, ("UsbResetOrAbortPipeWorkItem.3 error: 0x%x\n", status ));
                          retries = 1;
                          ulUniqueErrorValue = ERR_NO_INT_PIPE_RESET;
                       } break;

                   } // switch

                 } else {
                    status = (NTSTATUS)PtrToLong(PWorkItem->Context);
                    retries = (UCHAR)pDevExt->IntDeviceErrors;
                    ulUniqueErrorValue = ERR_MAX_INT_PIPE_DEVICE_ERRORS;
                 }

            } // WORK_ITEM_RESET_INT_PIPE
            break;

            case WORK_ITEM_ABORT_READ_PIPE:
            case WORK_ITEM_ABORT_WRITE_PIPE:
            case WORK_ITEM_ABORT_INT_PIPE:
            default:
            // status = STATUS_NOT_IMPLEMENTED; - let it fall through and see what happens
            DbgDump(DBG_ERR, ("ResetWorkItemFlags: 0x%x 0x%x\n", PWorkItem->Flags, status ));
            ASSERT(0);
            break;

        } // PWorkItem->Flags

    } else {
        status = STATUS_DELETE_PENDING;
    }

    //
    // is the device is hosed?
    //
    if ( (STATUS_SUCCESS != status) && (STATUS_DELETE_PENDING != status) && (0 != retries)) {

        // only log known errors, not suprise remove.
        if (1 == retries ) {

            // mark as PNP_DEVICE_REMOVED
            InterlockedExchange(&pDevExt->DeviceRemoved, TRUE);

            DbgDump(DBG_WRN, ("DEVICE REMOVED\n"));

        } else {

            // mark as PNP_DEVICE_FAILED
            InterlockedExchange(&pDevExt->AcceptingRequests, FALSE);

            DbgDump(DBG_ERR, ("*** UNRECOVERABLE DEVICE ERROR: (0x%x, %d)  No longer Accepting Requests ***\n", status, retries ));

            LogError( NULL,
                    pDevObj,
                    0, 0,
                    retries,
                    ulUniqueErrorValue,
                    status,
                    SERIAL_HARDWARE_FAILURE,
                    pDevExt->DeviceName.Length + sizeof(WCHAR),
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL );
        }

        IoInvalidateDeviceState( pDevExt->PDO );

    }

    DequeueWorkItem( pDevObj, PWorkItem );

    DbgDump(DBG_WORK_ITEMS, ("<UsbResetOrAbortPipeWorkItem 0x%x\n", status));
}



//
// NT's USB stack likes only 1 reset pending at any time.
// Also, if any reset fails then do NOT send anymore, else you'll get the controller
// or HUB in a funky state, where it will try to reset the port... which kicks off all
// the other devices on the hub.
//
NTSTATUS
UsbResetOrAbortPipe(
   IN PDEVICE_OBJECT PDevObj,
   IN PUSB_PIPE      PPipe,
   IN BOOLEAN        Reset
   )
{
    PDEVICE_EXTENSION pDevExt;
    NTSTATUS status;
    KIRQL irql;
    PURB pUrb;

    ASSERT( PDevObj );

    DbgDump(DBG_USB, (">UsbResetOrAbortPipe (%p)\n", PDevObj) );

    PAGED_CODE();

    if (!PDevObj || !PPipe || !PPipe->hPipe ) {
        DbgDump(DBG_ERR, ("UsbResetOrAbortPipe: STATUS_INVALID_PARAMETER\n") );
        TEST_TRAP();
        return STATUS_INVALID_PARAMETER;
    }

    pDevExt = PDevObj->DeviceExtension;

    KeAcquireSpinLock(&pDevExt->ControlLock, &irql);

    if ( PPipe->ResetOrAbortFailed ) {
        status = STATUS_UNSUCCESSFUL;
        DbgDump(DBG_ERR, ("UsbResetOrAbortPipe.1: 0x%x\n", status) );
        KeReleaseSpinLock(&pDevExt->ControlLock, irql);
        return status;
    }

    if (!CanAcceptIoRequests(PDevObj, FALSE, TRUE) ||
        !NT_SUCCESS(AcquireRemoveLock(&pDevExt->RemoveLock, UlongToPtr(Reset ? URB_FUNCTION_RESET_PIPE : URB_FUNCTION_ABORT_PIPE))))
    {
        status = STATUS_DELETE_PENDING;
        DbgDump(DBG_ERR, ("UsbResetOrAbortPipe.2: 0x%x\n", status) );
        KeReleaseSpinLock(&pDevExt->ControlLock, irql);
        return status;
    }

    KeReleaseSpinLock(&pDevExt->ControlLock, irql);

    //
    // USBVERIFIER ASSERT: Reset sent on a pipe with a reset already pending
    // The USB stack likes only 1 pending Reset or Abort request per pipe a time.
    //
    if ( 1 == InterlockedIncrement(&PPipe->ResetOrAbortPending) ) {

        pUrb = ExAllocateFromNPagedLookasideList( &pDevExt->PipeRequestUrbPool );

        if ( pUrb != NULL ) {
            //
            // pass the Reset -or- Abort request to USBD
            //
            pUrb->UrbHeader.Length = (USHORT)sizeof(struct _URB_PIPE_REQUEST);

            pUrb->UrbHeader.Function = Reset ? URB_FUNCTION_RESET_PIPE : URB_FUNCTION_ABORT_PIPE;

            pUrb->UrbPipeRequest.PipeHandle = PPipe->hPipe;

            status = UsbSubmitSyncUrb(PDevObj, pUrb, FALSE, DEFAULT_BULK_TIMEOUT);

            if (status != STATUS_SUCCESS) {
                DbgDump(DBG_ERR , ("*** UsbResetOrAbortPipe ERROR: 0x%x ***\n", status));
                InterlockedIncrement(&PPipe->ResetOrAbortFailed);
            }

            ExFreeToNPagedLookasideList(&pDevExt->PipeRequestUrbPool, pUrb);

        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            DbgDump(DBG_ERR , ("ExAllocateFromNPagedLookasideList failed (0x%x)!\n", status));
        }

        InterlockedDecrement(&PPipe->ResetOrAbortPending);

        ASSERT(PPipe->ResetOrAbortPending == 0);

    } else {
        //
        // If there is a reset/abort request pending then we are done.
        // Return STATUS_PENDING here so the work item won't start another transfer,
        // but will dequeue the item. The real item will follow-up with the correct status.
        //
        DbgDump(DBG_WRN, ("UsbResetOrAbortPipe: STATUS_PENDING\n"));
        TEST_TRAP();
        status = STATUS_PENDING;
    }

    ReleaseRemoveLock(&pDevExt->RemoveLock, UlongToPtr(Reset ? URB_FUNCTION_RESET_PIPE : URB_FUNCTION_ABORT_PIPE));

    DbgDump(DBG_USB, ("<UsbResetOrAbortPipe(0x%x)\n", status) );

    return status;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\write.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

   write.c

Abstract:

   Write functions

Environment:

   kernel mode only

Revision History:

   07-14-99 : created

Authors:

   Jeff Midkiff (jeffmi)

-- */

#include <wdm.h>
#include <stdio.h>
#include <stdlib.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <ntddser.h>

#include "wceusbsh.h"

NTSTATUS
WriteComplete(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp,
   IN PUSB_PACKET PPacket
   );

VOID
WriteTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   );

#if DBG
VOID
DbgDumpReadWriteData(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp,
   IN BOOLEAN Read
   );
#else
#define DbgDumpReadWriteData( _devobj, _irp, _read )
#endif



NTSTATUS
Write(
   IN PDEVICE_OBJECT PDevObj,
   PIRP PIrp
   )
/*++

Routine Description:

   Process the IRPs sent to this device for writing.
   IRP_MJ_WRITE

Arguments:

    PDevObj - Pointer to the device object for the device written to
    PIrp       - Pointer to the write IRP.

Return Value:

    NTSTATUS

Notes:

   The AN2720 is a low-quality FIFO device and will NAK all packets when it's
   FIFO gets full. We can't get real device status, like serial port registers.
   If we submit a USBDI 'GetEndpointStatus', then all we get back is a stall bit.
   PROBLEM: what to do when it's FIFO get's full, i.e., how to handle flow control?
   If the peer/client on the other side of the FIFO is not reading packets out of the FIFO,
   then AN2720 NAKS every packet thereafter, until the FIFO gets drained (or, at least 1 packet
   removed).

   Here's what we currently do: on every _USB_PACKET we submit, set a timeout.
   When the timer expires we check if our R/W completion routine has already cancelled that
   packet's timer. If our completion did cancel the timer, then we are done.
   If not, then we timed out on this packet. We do not reset the endpoint on a timeout
   since the FIFO's contents will be lost. We simply complete the Irp to
   user with STATUS_TIMEOUT. User should then go into whatever retry logic they require.

--*/
{
   PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   KIRQL irql;
   LARGE_INTEGER timeOut = {0,0};
   ULONG ulTransferLength;
   NTSTATUS status = STATUS_UNSUCCESSFUL;
   BOOLEAN bCompleteIrp = FALSE;

   PERF_ENTRY( PERF_Write );

   DbgDump(DBG_WRITE|DBG_TRACE, (">Write(%p, %p, %x)\n", PDevObj, PIrp, Read));

   PIrp->IoStatus.Information = 0L;

    //
    // Make sure the device is accepting request
    //
    if ( !CanAcceptIoRequests( PDevObj, TRUE, TRUE) ||
         !NT_SUCCESS(AcquireRemoveLock(&pDevExt->RemoveLock, PIrp)) )
    {
        status = PIrp->IoStatus.Status = STATUS_DELETE_PENDING;
        DbgDump(DBG_ERR, ("Write ERROR: 0x%x\n", status));
        PIrp->IoStatus.Status = status;
        IoCompleteRequest(PIrp, IO_NO_INCREMENT);
        return status;
   }

   //
   // Check write length.
   // Allow zero length writes for apps to send a NULL packet
   // to signal end of transaction.
   //
   ulTransferLength = pIrpSp->Parameters.Write.Length;

   if ( ulTransferLength > pDevExt->MaximumTransferSize ) {

      DbgDump(DBG_ERR, ("Write Buffer too large: %d\n", ulTransferLength ));

      status = PIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;

      bCompleteIrp = TRUE;

      goto WriteExit;
   }

   DbgDump(DBG_WRITE_LENGTH, ("User Write request length: %d\n", ulTransferLength ));

   //
   // calculate Serial TimeOut values
   //
    ASSERT_SERIAL_PORT(pDevExt->SerialPort);

    CalculateTimeout( &timeOut,
                    pIrpSp->Parameters.Write.Length,
                    pDevExt->SerialPort.Timeouts.WriteTotalTimeoutMultiplier,
                    pDevExt->SerialPort.Timeouts.WriteTotalTimeoutConstant );

    DbgDump(DBG_TIME, ("CalculateWriteTimeOut = %d msec\n", timeOut.QuadPart ));

    status = STATUS_SUCCESS;

   //
   // check if this Irp should be cancelled.
   // Note that we don't queue write Irps.
   //
   IoAcquireCancelSpinLock(&irql);

   if (PIrp->Cancel) {

      TEST_TRAP();
      IoReleaseCancelSpinLock(irql);
      status = PIrp->IoStatus.Status = STATUS_CANCELLED;
      // since we don't set a completion routine we complete it here
      bCompleteIrp = TRUE;

   } else {
      //
      // prepare to submit the IRP to the USB stack.
      //
      IoSetCancelRoutine(PIrp, NULL);
      IoReleaseCancelSpinLock(irql);

      KeAcquireSpinLock( &pDevExt->ControlLock, &irql);

      IRP_INIT_REFERENCE(PIrp);

      // set current number of chars in the Tx buffer
      InterlockedExchange( &pDevExt->SerialPort.CharsInWriteBuf, ulTransferLength );

      KeClearEvent( &pDevExt->PendingDataOutEvent );

      //
      // bump ttl request count
      //
      pDevExt->TtlWriteRequests++;

      KeReleaseSpinLock( &pDevExt->ControlLock, irql);

      status = UsbReadWritePacket( pDevExt,
                                   PIrp,
                                   WriteComplete,
                                   timeOut,
                                   WriteTimeout,
                                   FALSE );

   }

WriteExit:

   if (bCompleteIrp)
   {
       ReleaseRemoveLock(&pDevExt->RemoveLock, PIrp);

       IoCompleteRequest (PIrp, IO_SERIAL_INCREMENT );
   }

   DbgDump(DBG_WRITE|DBG_TRACE, ("<Write 0x%x\n", status));

   PERF_EXIT( PERF_Write );

   return status;
}



NTSTATUS
WriteComplete(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp,
   IN PUSB_PACKET PPacket
   )
/*++

Routine Description:

    This is the completion routine for Write requests.
    It assumes you have the serial port context.

Arguments:

    PDevObj - Pointer to device object
    PIrp    - Irp we are completing
    PPacket - USB Packet which will be freed

Return Value:

    NTSTATUS -- propogate Irp's status.

Notes:

   This routine runs at DPC_LEVEL.

--*/
{
   PDEVICE_EXTENSION pDevExt = PPacket->DeviceExtension;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   PURB pUrb = &PPacket->Urb;
   NTSTATUS irpStatus, workStatus;
   USBD_STATUS urbStatus;
   KIRQL irql;
   LONG curCount;

   PERF_ENTRY( PERF_WriteComplete );

   UNREFERENCED_PARAMETER( PDevObj );

   DbgDump(DBG_WRITE, (">WriteComplete(%p, %p, %p)\n", PDevObj, PIrp, PPacket));

   // Note: we don't hold the control lock so this could
   // disappear on us.
   ASSERT_SERIAL_PORT(pDevExt->SerialPort);

   //
   // First off, cancel the Packet Timer
   //
   if ( PPacket->Timeout.QuadPart != 0 ) {

      if (KeCancelTimer( &PPacket->TimerObj ) ) {
         //
         // the packet's timer was successfully removed from the system
         //
      } else {
         //
         // the timer could be spinning on the control lock,
         // so tell it we took the Irp.
         //
         PPacket->Status = STATUS_ALERTED;
      }

   }

   //
   // Now we can process the Irp.
   // If the lower driver returned PENDING,
   // then mark our stack location as pending.
   //
   if ( PIrp->PendingReturned ) {
      DbgDump(DBG_WRITE, ("Resetting Irp STATUS_PENDING\n"));
      IoMarkIrpPending(PIrp);
   }

   //
   // This is the R/W operation's return status.
   // irpStatus is the Irp's completion status
   // ubrStatus is a more USBD specific Urb operation completion status
   //
   irpStatus = PIrp->IoStatus.Status;
   DbgDump(DBG_WRITE, ("Irp->IoStatus.Status  0x%x\n", irpStatus));

   urbStatus = pUrb->UrbHeader.Status;
   DbgDump(DBG_WRITE, ("Urb->UrbHeader.Status 0x%x\n", urbStatus  ));

   // get the Irp type Read or Write
   ASSERT( IRP_MJ_WRITE == pIrpStack->MajorFunction );

   switch (irpStatus) {

      case STATUS_SUCCESS: {
//         ASSERT( USBD_STATUS_SUCCESS == urbStatus );

         //
         // indicate the number of Tx bytes transferred, as indicated in the Urb
         //
         PIrp->IoStatus.Information = pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;

         //
         // indicate that our Tx buffer is empty, although the data may
         // actually still reside on the AN2720 chip.
         // There is no way for us to know.
         //
         InterlockedExchange( &pDevExt->SerialPort.CharsInWriteBuf, 0 );

         //
         // clear pipe error count
         //
         InterlockedExchange( &pDevExt->WriteDeviceErrors, 0);

         //
         // incr ttl byte counter
         //
         pDevExt->TtlWriteBytes += (ULONG)PIrp->IoStatus.Information;

         DbgDump( DBG_WRITE_LENGTH , ("USB Write indication: %d\n",  PIrp->IoStatus.Information) );

         DbgDumpReadWriteData( PDevObj, PIrp, FALSE);
      }
      break;

      case STATUS_CANCELLED:  {

            DbgDump(DBG_WRN|DBG_WRITE|DBG_IRP, ("Write: STATUS_CANCELLED\n"));
            //
            // If it was cancelled, it may have timed out.
            // We can tell by looking at the packet attached to it.
            //
            if ( STATUS_TIMEOUT == PPacket->Status ) {
                //
               // more than likely the FIFO was stalled (i.e., the other side did not
               // read fom the endpoint). Inform user we timed out the R/W request
               //
               ASSERT( USBD_STATUS_CANCELED == urbStatus);
               irpStatus = PIrp->IoStatus.Status = STATUS_TIMEOUT;
               DbgDump(DBG_WRN|DBG_WRITE|DBG_IRP, ("Write: STATUS_TIMEOUT\n"));
            }
      }
      break;

      case STATUS_DEVICE_DATA_ERROR:   {
         //
         // generic device error set by USBD.
         //
         DbgDump(DBG_ERR, ("WritePipe STATUS_DEVICE_DATA_ERROR: 0x%x\n", urbStatus));

         //
         // bump pipe error count
         //
         InterlockedIncrement( &pDevExt->WriteDeviceErrors);

         //
         // is the endpoint is stalled?
         //
         if ( USBD_HALTED(pUrb->UrbHeader.Status) ) {
               //
               // queue a reset request
               //
               workStatus = QueueWorkItem( pDevExt->DeviceObject,
                                           UsbResetOrAbortPipeWorkItem,
                                           (PVOID)((LONG_PTR)urbStatus),
                                           WORK_ITEM_RESET_WRITE_PIPE
                                           );
         }

      }
      break;

      case STATUS_INVALID_PARAMETER:
            //
            // This means that our (TransferBufferSize > PipeInfo->MaxTransferSize)
            // we need to either break up requests or reject the Irp from the start.
            //
            DbgDump(DBG_WRN, ("STATUS_INVALID_PARAMETER\n"));
            ASSERT(USBD_STATUS_INVALID_PARAMETER == urbStatus);

            //
            // pass the Irp through for completion
            //
      break;

      default:
         DbgDump(DBG_WRN, ("WRITE: Unhandled Irp status: 0x%x\n", irpStatus));
      break;
   }

   //
   // Remove the packet from the pending List
   //
   KeAcquireSpinLock( &pDevExt->ControlLock,  &irql );

   RemoveEntryList( &PPacket->ListEntry );

   curCount = InterlockedDecrement( &pDevExt->PendingWriteCount );

   //
   // Put the packet back in packet pool.
   //
   PPacket->Irp = NULL;

   ExFreeToNPagedLookasideList( &pDevExt->PacketPool,  // Lookaside,
                                PPacket                // Entry
                                );

   ReleaseRemoveLock(&pDevExt->RemoveLock, PIrp);

   //
   // Complete the IRP
   //
   TryToCompleteCurrentIrp(
            pDevExt,
            irpStatus,  // ReturnStatus
            &PIrp,      // Irp
            NULL,       // Queue
            NULL,       // IntervalTimer
            NULL,       // TotalTimer
            NULL,       // StartNextIrpRoutine
            NULL,       // GetNextIrpRoutine
            IRP_REF_RX_BUFFER, // ReferenceType
            FALSE,       // CompleteRequest
            irql );

   //
   // Perform any post I/O processing.
   //
   ASSERT(curCount >= 0);

   if ( 0 == curCount ) {
      //
      // do Tx post processing here...
      //
      KeAcquireSpinLock( &pDevExt->ControlLock , &irql);
      pDevExt->SerialPort.HistoryMask |= SERIAL_EV_TXEMPTY;
      KeReleaseSpinLock( &pDevExt->ControlLock, irql);

      ProcessSerialWaits( pDevExt );

      KeSetEvent( &pDevExt->PendingDataOutEvent, IO_SERIAL_INCREMENT, FALSE);
   }

   DbgDump(DBG_WRITE, ("<WriteComplete 0x%x\n", irpStatus));

   PERF_EXIT( PERF_WriteComplete );

   return irpStatus;
}



VOID
WriteTimeout(
   IN PKDPC PDpc,
   IN PVOID DeferredContext,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   )
/*++

Routine Description:

    This is the Write Timeout DPC routine that is called when a
    Timer expires on a packet submitted to USBD.
    Runs at DPC_LEVEL.

Arguments:

    PDpc             - Unused
    DeferredContext  - pointer to the Packet
    SystemContext1   - Unused
    SystemContext2   - Unused

Return Value:
    VOID

--*/
{
   PUSB_PACKET       pPacket = (PUSB_PACKET)DeferredContext;
   PDEVICE_EXTENSION pDevExt = pPacket->DeviceExtension;
   PDEVICE_OBJECT    pDevObj = pDevExt->DeviceObject;

   NTSTATUS status = STATUS_TIMEOUT;
   KIRQL irql;

   PERF_ENTRY( PERF_WriteTimeout );

   UNREFERENCED_PARAMETER(PDpc);
   UNREFERENCED_PARAMETER(SystemContext1);
   UNREFERENCED_PARAMETER(SystemContext2);

   DbgDump(DBG_WRITE|DBG_TIME, (">WriteTimeout\n"));

   if (pPacket && pDevExt && pDevObj) {
      //
      // sync with completion routine putting packet back on list
      //
      KeAcquireSpinLock( &pDevExt->ControlLock, &irql );

      if ( !pPacket || !pPacket->Irp ||
           (STATUS_ALERTED == pPacket->Status) ) {

         status = STATUS_ALERTED;

         KeReleaseSpinLock( &pDevExt->ControlLock, irql );

         DbgDump(DBG_WRITE, ("WriteTimeout: Irp completed\n" ));
         PERF_EXIT( PERF_WriteTimeout );
         return;

      } else {
         //
         // mark the packet as timed out, so we can propogate this to user
         // from completion routine
         //
         pPacket->Status = STATUS_TIMEOUT;

         KeReleaseSpinLock( &pDevExt->ControlLock, irql );

         //
         // Cancel the Irp.
         //
         if ( !IoCancelIrp(pPacket->Irp) ) {
            //
            // The Irp is not in a cancelable state.
            //
            DbgDump(DBG_WRITE|DBG_TIME, ("Warning: couldn't cancel Irp: %p,\n", pPacket->Irp));
         }

      }

   } else {
      status = STATUS_INVALID_PARAMETER;
      DbgDump(DBG_ERR, ("WriteTimeout: 0x%x\n", status ));
      TEST_TRAP();
   }

   DbgDump(DBG_WRITE|DBG_TIME, ("<WriteTimeout 0x%x\n", status));

   PERF_EXIT( PERF_WriteTimeout );

   return;
}


#if DBG
VOID
DbgDumpReadWriteData(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp,
   IN BOOLEAN Read
   )
{
   PIO_STACK_LOCATION pIrpSp;

   ASSERT(PDevObj);
   ASSERT(PIrp);

   pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   if ( (Read && (DebugLevel & DBG_DUMP_READS)) ||
        (!Read && (DebugLevel & DBG_DUMP_WRITES)) ) {

      ULONG i;
      ULONG count=0;
      NTSTATUS status;

      status = PIrp->IoStatus.Status;

      if (STATUS_SUCCESS ==  status) {
         count = (ULONG)PIrp->IoStatus.Information;
      }

      KdPrint( ("WCEUSBSH: %s: for DevObj(%p) Irp(0x%x) Length(0x%x) status(0x%x)\n",
                     Read ? "ReadData" : "WriteData", PDevObj, PIrp, count, status ));

      for (i = 0; i < count; i++) {
         KdPrint(("%02x ", *(((PUCHAR)PIrp->AssociatedIrp.SystemBuffer) + i) & 0xFF));
      }

      KdPrint(("\n"));
   }

   return;
}
#endif

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\hccoin\hccoin.h ===
#ifndef _HCCOIN_H
#define _HCCOIN_H


DWORD
HCCOIN_DoWin2kInstall(
    HDEVINFO  DeviceInfoSet,
    PSP_DEVINFO_DATA  DeviceInfoData
    );

DWORD
HCCOIN_CheckControllers(
    DWORD Haction,
    DWORD NextHaction,
    BOOLEAN Setup
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\hccoin\hccoin.c ===
//#define UNICODE

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <malloc.h>
#include <basetyps.h>
#include <regstr.h>
#include <devioctl.h>
#include <initguid.h>
#include <usb.h>
#include <usbuser.h>
#include <setupapi.h>
#include <cfgmgr32.h>

#include <assert.h>
#include "hccoin.h"

#define PSTR    LPSTR

BOOL Win2k = FALSE;

#if DBG

#define TEST_TRAP() DebugBreak()

ULONG
_cdecl
KdPrintX(
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function.

Arguments:

Return Value:


--*/
{
    va_list list;
    int i;
    int arg[6];
    TCHAR tmp[256];

#ifdef UNICODE
    OutputDebugString(L"HCCOIN.DLL:");
#else
    OutputDebugString("HCCOIN.DLL:");
#endif
    va_start(list, Format);
    for (i=0; i<6; i++) {
        arg[i] = va_arg(list, int);

        wsprintf((PSTR)&tmp[0], Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);
    }

    OutputDebugString((PSTR)tmp);

    return 0;
}


#define KdPrint(_x_) KdPrintX _x_

#else

#define KdPrint(_x_)
#define TEST_TRAP()

#endif


DWORD
HCCOIN_Win2k (
    DI_FUNCTION InstallFunction,
    HDEVINFO  DeviceInfoSet,
    PSP_DEVINFO_DATA  DeviceInfoData,
    PCOINSTALLER_CONTEXT_DATA  Context
    )
{
    DWORD status = NO_ERROR;

    KdPrint(("HCCOIN_Win2k 0x%x\n", InstallFunction));
    KdPrint(("Context %08.8x, DeviceInfoData %08.8x\n",
        Context, DeviceInfoData));

    switch(InstallFunction) {

    case DIF_DESTROYPRIVATEDATA:
        KdPrint(("DIF_DESTROYPRIVATEDATA\n"));
        break;

    case DIF_PROPERTYCHANGE:
        break;

    case DIF_INSTALLDEVICE:
        if (Context->PostProcessing) {
            KdPrint(("DIF_INSTALLDEVICE, post\n"));
            status = HCCOIN_DoWin2kInstall(DeviceInfoSet, DeviceInfoData);
        } else {
            status = ERROR_DI_POSTPROCESSING_REQUIRED;
        }
        break;
    }

    return status;

}

/*

    HACTION STATES
    (0) companion can enumerate
    (1) companion should wait on 2.0 controller, 2.0 is enabled
    (2) companion is disabled, needs reenable 2.0 is disabled
    (3) companion is disabled, needs reenable 2.0 is enabled
    (4) companion is disabled, needs reenable 2.0 is removed
*/

#define USB2_DISABLE  1
#define USB2_ENABLE   2
#define USB2_REMOVE   3
#define USB2_INSTALL  4

// Global state of install process
ULONG MyContext = 0;

DWORD
HCCOIN_WinXp (
    DI_FUNCTION InstallFunction,
    HDEVINFO  DeviceInfoSet,
    PSP_DEVINFO_DATA  DeviceInfoData,
    PCOINSTALLER_CONTEXT_DATA  Context
    )

{
    DWORD status = NO_ERROR;
    ULONG pd;

    KdPrint(("HCCOIN_WinXp 0x%x\n", InstallFunction));
    KdPrint(("Context %08.8x, DeviceInfoData %08.8x private %08.8x\n",
        Context, DeviceInfoData, Context->PrivateData));

    //pd = (ULONG) Context->PrivateData;
    pd = MyContext;
    KdPrint(("pd %08.8x\n", pd));

    switch(InstallFunction) {

    case DIF_DESTROYPRIVATEDATA:
        KdPrint(("DIF_DESTROYPRIVATEDATA\n"));
        switch (pd) {
        case USB2_INSTALL:
            KdPrint((">(INSTALL)DISABLE 2>0\n"));
            // disabling 2.0 hc find current state 2,
            // cc need reenable and set to state 0 (ok to enum)
            // 2->0
            status = HCCOIN_CheckControllers(2, 0, TRUE);
            break;

            break;

        case USB2_DISABLE:
            KdPrint((">DISABLE 2>0\n"));
            // disabling 2.0 hc find current state 2,
            // cc need reenable and set to state 0 (ok to enum)
            // 2->0
            status = HCCOIN_CheckControllers(2, 0, FALSE);
            break;

        case USB2_ENABLE:
            KdPrint((">ENABLE 3>1\n"));
            // enabling 2.0 hc find state 3
            // cc need reenable and set to state 1 (wait to enum)
            // 3->1
            status = HCCOIN_CheckControllers(3, 1, FALSE);
            break;

        case USB2_REMOVE:
            // removing 2.0 hc find state 4
            // cc need reenumerate and set to state 0 (ok to enum)
            // 3->1
            KdPrint((">REMOVE 4>0\n"));
            status = HCCOIN_CheckControllers(4, 0, TRUE);
            break;
        }
        break;

    case DIF_PROPERTYCHANGE:
        {
        SP_PROPCHANGE_PARAMS propChange;

        // get the private data
        propChange.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        propChange.ClassInstallHeader.InstallFunction = InstallFunction;

        if (SetupDiGetClassInstallParams(DeviceInfoSet,
                                     DeviceInfoData,
                                     &propChange.ClassInstallHeader,
                                     sizeof(propChange),
                                     NULL)) {

            switch (propChange.StateChange) {
            case DICS_ENABLE:
                pd = USB2_ENABLE;
                break;
            case DICS_DISABLE:
                pd = USB2_DISABLE;
                break;
            default:
                pd = 0;
            }
            //Context->PrivateData = (PVOID) pd;
            MyContext = pd;

            KdPrint(("DIF_PROPERTYCHANGE %x\n", pd));
            if (pd == USB2_ENABLE) {
                KdPrint((">ENABLE\n"));
                if (Context->PostProcessing) {
                    KdPrint(("DIF_PROPERTYCHANGE, post 0>3\n"));
                    // enabling 2.0 hc. find state 0 and disable
                    // set to state 3 need reenable
                    // 0->3
                    status = HCCOIN_CheckControllers(0, 3, FALSE);
               } else {
                    status = ERROR_DI_POSTPROCESSING_REQUIRED;
               }
            }
        } else {
            TEST_TRAP();
            return GetLastError();
        }
        }
        break;

    case DIF_INSTALLDEVICE:
        // two options here, force a reboot or attempt to locate all
        // companion controllers and cycle them
        KdPrint(("DIF_INSTALLDEVICE\n"));
        // set all controllers to 'wait mode'
        MyContext = USB2_INSTALL;
        status = HCCOIN_CheckControllers(0, 1, FALSE);

        break;

    case DIF_REMOVE:
        if (Context->PostProcessing) {
            KdPrint(("DIF_REMOVE, post\n"));
            MyContext = USB2_REMOVE;
            status = HCCOIN_CheckControllers(2, 4, FALSE);
        } else {
            status = ERROR_DI_POSTPROCESSING_REQUIRED;
        }
        break;
    }

    return status;
}


DWORD
HCCOIN_CopyFile(
    PSTR SrcPath,
    PSTR DestPath,
    PSTR FileName
    )
{
    TCHAR src[MAX_PATH];
    TCHAR dest[MAX_PATH];
    ULONG fileNameLen, pathlen;

    KdPrint(("SrcPath <%s>\n", SrcPath));
    KdPrint(("DstPath <%s>\n", DestPath));
    KdPrint(("File <%s>\n", FileName));

    // validate that we do not go beyond
    // maxpath length

    pathlen = _tcslen(SrcPath);
    fileNameLen = _tcslen(FileName);
    if (pathlen+fileNameLen+sizeof(TCHAR)*2 > MAX_PATH) {
        TEST_TRAP();
        return ERROR_INVALID_PARAMETER;
    }
    wsprintf(src,"%s\\%s", SrcPath, FileName);

    pathlen = _tcslen(DestPath);
    fileNameLen = _tcslen(FileName);
    if (pathlen+fileNameLen+sizeof(TCHAR)*2 > MAX_PATH) {
        TEST_TRAP();
        return ERROR_INVALID_PARAMETER;
    }
    wsprintf(dest,"%s\\%s", DestPath, FileName);

    if (CopyFile(src, dest, FALSE)) {
        return NO_ERROR;
    } else {
        return GetLastError();
    }
}


// global string buffers
TCHAR Usb2Path[MAX_PATH];
TCHAR Usb2Inf[MAX_PATH];
TCHAR SourcePath[MAX_PATH];
TCHAR Usb2Section[MAX_PATH];

DWORD
HCCOIN_DoWin2kInstall(
    HDEVINFO  DeviceInfoSet,
    PSP_DEVINFO_DATA  DeviceInfoData
    )
{
    DWORD status = NO_ERROR;
    SP_DRVINFO_DATA driverInfoData;
    SP_DRVINFO_DETAIL_DATA driverInfoDetailData;
    TCHAR tmp[MAX_PATH+1];
    TCHAR fileName[MAX_PATH];
    HINF infHandle;
    INFCONTEXT infContext;
    BOOL findFirst, found;
    UINT len;

    // Destination
    // get our strings, localize?

    len = GetWindowsDirectory(tmp, MAX_PATH+1);
    assert(sizeof(tmp) == sizeof(TCHAR) * (MAX_PATH+1));

    // make sure there is enough room to tack on our directory
    // minus 6 TCHARs
    if (len && len < MAX_PATH-6) {
        wsprintf((PSTR)Usb2Path, "%s\\USB2", tmp);
        wsprintf((PSTR)Usb2Inf, "USB2.INF");
        KdPrint(("Usb2Path <%s>\n", Usb2Path));
    } else {
       status = ERROR_INVALID_NAME;
       return status;
    }

    wsprintf((PSTR)Usb2Section, "USB2COINSTALLER");

    // create our USB2 directory
    if (!CreateDirectory((PSTR)Usb2Path, NULL)) {
        status = GetLastError();

        if (status != ERROR_ALREADY_EXISTS) {
            KdPrint(("CreateDirectory status %d\n", status));
            return status;
        }
    }

    // Source
    // get setup info from PnP
    driverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver(DeviceInfoSet,
                                  DeviceInfoData,
                                  &driverInfoData)) {

        status = GetLastError();
        KdPrint(("SetupDiGetSelectedDriver status %d\n", status));

        return status;
    }

    driverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    &driverInfoData,
                                    &driverInfoDetailData,
                                    sizeof(driverInfoDetailData),
                                    NULL)) {
        status = GetLastError();
        KdPrint(("SetupDiGetDriverInfoDetail status %d\n", status));

        if (status == ERROR_INSUFFICIENT_BUFFER) {
            // don't need extended info
            status = NO_ERROR;
        } else {
            return status;
        }
    }
    KdPrint(("driverInfoData %08.8x driverInfoDetailData %08.8x\n",
        &driverInfoData, &driverInfoDetailData));

    assert(sizeof(driverInfoDetailData.InfFileName) == sizeof(SourcePath));
    memcpy(SourcePath,
           driverInfoDetailData.InfFileName,
           sizeof(driverInfoDetailData.InfFileName));

    // strip the file name
    // note that this won't work with DBCS so either compile as
    // UNICODE or convert the source string to unicode and back
    // again
    {
        PTCHAR pStart, pEnd;

        pEnd = pStart = &SourcePath[0];
#ifdef UNICODE
        pEnd = pStart + wstrlen(SourcePath);
#else
        pEnd = pStart + strlen(SourcePath);
#endif

        while (*pEnd != '\\' && pEnd != pStart) {
            pEnd--;
        }
        if (*pEnd == '\\') {
            *pEnd = UNICODE_NULL;
        }
    }

    KdPrint(("SourcePath <%s>\n", SourcePath));
    // copy files to our directory
    status = HCCOIN_CopyFile(SourcePath, Usb2Path, Usb2Inf);
    if (status != NO_ERROR) {
        return status;
    }

    // now open the source inf
    infHandle = SetupOpenInfFile(driverInfoDetailData.InfFileName,
                                 NULL,
                                 INF_STYLE_WIN4,
                                 NULL);

    if (INVALID_HANDLE_VALUE == infHandle) {
        status = ERROR_INVALID_NAME;
        return status;
    }

    findFirst = TRUE;
    // read the inf for files to copy
    do {
        if (findFirst) {
            found = SetupFindFirstLine(infHandle,
                               Usb2Section,
                               NULL,
                               &infContext);
            findFirst = FALSE;
        } else {
            found = SetupFindNextLine(&infContext,
                                      &infContext);
        }

        if (found) {

            if (SetupGetLineText(&infContext,
                                 infHandle,
                                 Usb2Section,  //Section
                                 NULL,         //Key
                                 fileName,     //ReturnBuffer
                                 sizeof(fileName),  //ReturnBufferLength
                                 NULL)) {

                status = HCCOIN_CopyFile(SourcePath, Usb2Path, fileName);
                if (status != NO_ERROR) {
                    SetupCloseInfFile(infHandle);
                    return status;
                }
            }
        }
    } while (found);

    SetupCloseInfFile(infHandle);

    wsprintf((PSTR)tmp, "%s\\%s", Usb2Path, Usb2Inf);

    // tell setup about our inf
    if (!SetupCopyOEMInf(tmp,  //SourceInfFileName
                    Usb2Path,      //OEMSourceMediaLocation
                    SPOST_PATH,    //OEMSourceMediaType
                    0,             //CopyStyle
                    NULL,          //DestinationInfFileName
                    0,             //DestinationInfFileNameSize
                    NULL,          //RequiredSize
                    NULL)) {       //DestinationInfFileNameComponent

        status = GetLastError();
        KdPrint(("SetupCopyOEMInf status %d\n", status));
    }

    return status;

}


DEVINST
HCCOIN_FindUSBController(
    DWORD Haction,
    DWORD NextHaction
    )
/*++
    do a depth first search of the device tree looking for any
    usb controllers that need attention
--*/
{
    DEVINST     devInst;
    DEVINST     devInstNext;
    CONFIGRET   cr;
    BOOL        walkDone = FALSE;
    ULONG       len = 0;
    ULONG       status = 0, problemNumber = 0;
    HKEY        devKey;
    DWORD       haction = 0;
    TCHAR       buf[MAX_PATH];

    //
    // Get Root DevNode
    //
    cr = CM_Locate_DevNode(&devInst, NULL, 0);

    if (cr != CR_SUCCESS) {
        return 0;
    }

    //
    // Do a depth first search for the DevNode
    //
    while (!walkDone) {
        //
        // check for our key
        //

        if (cr == CR_SUCCESS) {

            //KdPrint(("devInst %08.8x - ", devInst));

            len = sizeof(buf);
            // CM_Api takes length in bytes
            if (CM_Get_DevNode_Registry_Property(devInst,
                                                 CM_DRP_DRIVER,
                                                 NULL,
                                                 buf,
                                                 &len,
                                                 0) == CR_SUCCESS) {
                //KdPrint(("<%s>\n",buf));
            } else {
                //KdPrint(("<no driver>\n"));
            }

            if (CM_Open_DevNode_Key(devInst,
                                    KEY_ALL_ACCESS,
                                    CM_REGISTRY_HARDWARE,
                                    RegDisposition_OpenExisting,
                                    &devKey,
                                    0) == CR_SUCCESS) {
                len = sizeof(DWORD);
                if (RegQueryValueEx(devKey,
                                    "haction",
                                    NULL,
                                    NULL,
                                    (LPBYTE) &haction,
                                    &len) == ERROR_SUCCESS) {

                    KdPrint(("Found Key %d\n", haction));

                    if (haction == Haction) {
                        LONG err;

                        len = sizeof(DWORD);
                        haction = NextHaction;
                        // reset the key
                        err = RegSetValueEx(devKey,
                                    "haction",
                                    0,
                                    REG_DWORD,
                                    (LPBYTE) &haction,
                                    len);

                        RegCloseKey(devKey);
                        //KdPrint(("Reset Key %x\n", err));

                        return devInst;
                    }
                }

                RegCloseKey(devKey);
            }

        }

        //
        // This DevNode didn't match, go down a level to the first child.
        //
        cr = CM_Get_Child(&devInstNext,
                          devInst,
                          0);

        if (cr == CR_SUCCESS) {
            devInst = devInstNext;
            continue;
        }

        //
        // Can't go down any further, go across to the next sibling.  If
        // there are no more siblings, go back up until there is a sibling.
        // If we can't go up any further, we're back at the root and we're
        // done.
        //
        for (;;) {
            cr = CM_Get_Sibling(&devInstNext,
                                devInst,
                                0);

            if (cr == CR_SUCCESS) {
                devInst = devInstNext;
                break;
            }

            cr = CM_Get_Parent(&devInstNext,
                               devInst,
                               0);

            if (cr == CR_SUCCESS) {
                devInst = devInstNext;
            } else {
                walkDone = TRUE;
                break;
            }
        }
    }

    return 0;
}


DWORD
HCCOIN_CheckControllers(
    DWORD Haction,
    DWORD NextHaction,
    BOOLEAN Setup
    )
/*++
--*/
{
    DEVINST devInst;
    ULONG err;

    do {
        if (devInst = HCCOIN_FindUSBController(Haction, NextHaction)) {
            KdPrint((">Take Haction %08.8x\n", devInst));

            switch(Haction) {
            // 0->3
            // 0->1
            case 0:
                if (NextHaction != 1) {
                    err = CM_Disable_DevNode(devInst, CM_DISABLE_UI_NOT_OK |
                                                      CM_DISABLE_ABSOLUTE);
                    KdPrint(("<Take Haction %d->%d - disable %x\n",
                        Haction,
                        NextHaction,
                        err));
                }
                break;

            // 3->1
            // 2->0
            // 2->4
            case 3:
            case 2:
                if (NextHaction != 4) {
                    if (Setup) {
                        err = CM_Setup_DevNode(devInst, CM_SETUP_DEVNODE_READY);
                    } else {
                        err = CM_Enable_DevNode(devInst, 0);
                    }
                }
                KdPrint(("<Take Haction %d->%d - enable %x\n",
                    Haction,
                    NextHaction,
                    err));
                break;
            case 4:
                if (Setup) {
                    err = CM_Setup_DevNode(devInst, CM_SETUP_DEVNODE_READY);
                } else {
                    err = CM_Enable_DevNode(devInst, 0);
                }
                KdPrint(("<Take Haction %d->%d - enumerate %x\n",
                    Haction,
                    NextHaction,
                    err));
                break;
            }
        }
    }  while (devInst);

    return NO_ERROR;
}


DWORD
HCCOIN_Entry (
    DI_FUNCTION InstallFunction,
    HDEVINFO  DeviceInfoSet,
    PSP_DEVINFO_DATA  DeviceInfoData,
    PCOINSTALLER_CONTEXT_DATA  Context
    )
{
    OSVERSIONINFO osVersion;

    // parameter validation

    if (DeviceInfoSet == NULL ||
        DeviceInfoData == NULL ||
        Context == NULL) {
        TEST_TRAP();
        return ERROR_INVALID_PARAMETER;
    }

    osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osVersion);

    if ( osVersion.dwMajorVersion == 5 && osVersion.dwMinorVersion == 0 ) {
        Win2k = TRUE;
    }

    if (Win2k) {

        KdPrint(("Microsoft Windows 2000 "));

        return HCCOIN_Win2k(InstallFunction,
                            DeviceInfoSet,
                            DeviceInfoData,
                            Context);
    } else {
        KdPrint(("Microsoft Windows XP or later "));

        return HCCOIN_WinXp(InstallFunction,
                            DeviceInfoSet,
                            DeviceInfoData,
                            Context);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\wceusbsh\wceusbsh.c ===
/* ++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    wceusbsh.c

Abstract:

    Main entrypoint for Windows CE USB Serial Host driver, for
        ... Windows CE USB sync devices:
            SL11, Socket CF cards, HP Jornada, COMPAQ iPAQ, Casio Cassiopeia, etc.
        ... cables using the Anchor AN27x0 chipset (i.e. EZ-Link)
        ... ad-hoc USB NULL Modem Class

Environment:

    kernel mode only

Author:

    Jeff Midkiff (jeffmi)

Revision History:

    07-15-99    :   rev 1.00    ActiveSync 3.1  initial release
    04-20-00    :   rev 1.01    Cedar 3.0 Platform Builder
    09-20-00    :   rev 1.02    finally have some hardware

Notes:

    o) WCE Devices currently do not handle remote wake, nor can we put the device in power-off state when not used, etc.
    o) Pageable Code sections are marked as follows:
           PAGEWCE0 - useable only during init/deinit
           PAGEWCE1 - useable during normal runtime

-- */

#include "wceusbsh.h"

//
// This is currently missing from wdm.h,
// but IoUnregisterShutdownNotification is there
//
#if !defined( IoRegisterShutdownNotification )
NTKERNELAPI
NTSTATUS
IoRegisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );
#endif

NTSTATUS
Create(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

NTSTATUS
Close(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   );

NTSTATUS
Cleanup(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

VOID
Unload(
   IN PDRIVER_OBJECT DriverObject
   );

NTSTATUS
SetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
QueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Flush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Shutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
KillAllPendingUserIrps(
   PDEVICE_OBJECT PDevObj
   );

NTSTATUS 
SystemControl(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

//
// GLOBALS
//
BOOLEAN g_isWin9x   = FALSE;
BOOLEAN g_ExposeComPort = FALSE;

LONG  g_NumDevices;
LONG  g_lIntTimout = DEFAULT_INT_PIPE_TIMEOUT;
ULONG g_ulAlternateSetting = 0;
ULONG g_ulMaxPipeErrors = DEFAULT_MAX_PIPE_DEVICE_ERRORS;

ULONG DebugLevel;


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGEWCE0, AddDevice)

#pragma alloc_text(PAGEWCE1, Unload)
#pragma alloc_text(PAGEWCE1, Flush)
#pragma alloc_text(PAGEWCE1, QueryInformationFile)
#pragma alloc_text(PAGEWCE1, SetInformationFile)
#pragma alloc_text(PAGEWCE1, Shutdown)
#pragma alloc_text(PAGEWCE1, UsbFreeReadBuffer)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT PDrvObj,
    IN PUNICODE_STRING PRegistryPath
    )
{
#ifdef DBG
   CHAR VersionHerald[] = "Windows CE USB Serial Host, Version %s built on %s\n";
   CHAR VersionNumber[] = "1.02";
   CHAR VersionTimestamp[] = __DATE__ " " __TIME__;
#endif

   PAGED_CODE();
   KdPrint((VersionHerald, VersionNumber, VersionTimestamp));

   //
   // determine OS
   //
   g_isWin9x = IsWin9x();
   KdPrint(("This is Win %s\n", g_isWin9x ? "9x" : "NT" ));

   PDrvObj->MajorFunction[IRP_MJ_CREATE]  = Create;
   PDrvObj->MajorFunction[IRP_MJ_CLOSE]   = Close;
   PDrvObj->MajorFunction[IRP_MJ_CLEANUP] = Cleanup;

   PDrvObj->MajorFunction[IRP_MJ_READ]   = Read;
   PDrvObj->MajorFunction[IRP_MJ_WRITE]  = Write;
   PDrvObj->MajorFunction[IRP_MJ_DEVICE_CONTROL]    = SerialIoctl;

   PDrvObj->MajorFunction[IRP_MJ_FLUSH_BUFFERS]     = Flush;
   PDrvObj->MajorFunction[IRP_MJ_QUERY_INFORMATION] = QueryInformationFile;
   PDrvObj->MajorFunction[IRP_MJ_SET_INFORMATION]   = SetInformationFile;

   PDrvObj->DriverExtension->AddDevice  = AddDevice;
   PDrvObj->MajorFunction[IRP_MJ_PNP]   = Pnp;
   PDrvObj->MajorFunction[IRP_MJ_POWER] = Power;
   PDrvObj->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SystemControl;

   PDrvObj->MajorFunction[IRP_MJ_SHUTDOWN] = Shutdown;

   PDrvObj->DriverUnload = Unload;

   //
   // initialize Globals
   //
   g_NumDevices = 0;

   QueryRegistryParameters( PRegistryPath );

   DbgDump(DBG_INIT, ("Create @ %p\n", Create));
   DbgDump(DBG_INIT, ("Close @ %p\n", Close));
   DbgDump(DBG_INIT, ("Cleanup @ %p\n", Cleanup));
   DbgDump(DBG_INIT, ("Read @ %p\n", Read));
   DbgDump(DBG_INIT, ("Write @ %p\n", Write));
   DbgDump(DBG_INIT, ("SerialIoctl @ %p\n", SerialIoctl));
   DbgDump(DBG_INIT, ("Flush @ %p\n", Flush));
   DbgDump(DBG_INIT, ("QueryInformationFile @ %p\n", QueryInformationFile));
   DbgDump(DBG_INIT, ("SetInformationFile @ %p\n", SetInformationFile));
   DbgDump(DBG_INIT, ("AddDevice @ %p\n", AddDevice));
   DbgDump(DBG_INIT, ("Pnp @ %p\n", Pnp));
   DbgDump(DBG_INIT, ("Power @ %p\n", Power));
   DbgDump(DBG_INIT, ("Shutdown @ %p\n", Shutdown));
   DbgDump(DBG_INIT, ("Unload @ %p\n", Unload));

   return STATUS_SUCCESS;
}



NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT PDrvObj,
    IN PDEVICE_OBJECT PPDO
    )
/*++

Routine Description:

    Add our driver to the USB device stack.
    This also creates our base device name and symbolic link.

Arguments:

    PDrvObj - Pointer to our driver object
    PPDO    - Pointer to the PDO for the stack to which we should add ourselves

Return Value:

    NTSTATUS

--*/

{
   NTSTATUS status;
   PDEVICE_OBJECT pDevObj = NULL;
   PDEVICE_EXTENSION pDevExt = NULL;
   LONG  comPortNumber=0;
   BOOLEAN bListsInitilized = FALSE;
   ULONG UniqueErrorValue = 0;

   DbgDump(DBG_INIT, (">AddDevice\n"));
   PAGED_CODE();

   //
   // Create the FDO
   //
   if (PPDO == NULL) {
      DbgDump(DBG_ERR, ("No PDO\n"));
      return STATUS_NO_MORE_ENTRIES;
   }

   //
   // create a named device object
   // and unprotected symbolic link.
   //
   status = CreateDevObjAndSymLink(
                  PDrvObj,
                  PPDO,
                  &pDevObj,
                  DRV_NAME );

   if ( (status != STATUS_SUCCESS) || !pDevObj ) {
      DbgDump(DBG_ERR, ("CreateDevObjAndSymLink error: 0x%x\n", status));
      UniqueErrorValue = ERR_NO_DEVICE_OBJ;
      goto AddDeviceFailed;
   }

   DbgDump( DBG_INIT, ("DevObj: %p\n", pDevObj));

   // init our device extension
   //
   pDevExt = pDevObj->DeviceExtension;

   pDevExt->DeviceObject = pDevObj;

   pDevExt->PDO = PPDO;

   // init our states
   //
   InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateInitialized);
#ifdef POWER
   pDevExt->DevicePowerState= PowerDeviceD0;
#endif

   // set FDO flags
   //
   ASSERT( !(pDevObj->Flags & DO_POWER_PAGABLE) );
   pDevObj->Flags |= (PPDO->Flags & DO_POWER_PAGABLE);

   pDevObj->Flags |= DO_BUFFERED_IO;
   pDevObj->Flags &= ~ DO_DEVICE_INITIALIZING;

   //
   // Create or initialize any other non-hardware resources here.
   // These items get cleaned up in IRP_MN_REMOVE_DEVICE....
   //

   // Initialize locks
   //
   KeInitializeSpinLock(&pDevExt->ControlLock);

   InitializeRemoveLock( &pDevExt->RemoveLock );

   //
   // Initialize USB Read Buffer, This value has an effect on performance.
   // In addition to testing the endpoint's MaximumPacketSize (64 byte max),
   // I tested 512, 1024, 2048, & 4096 across the EZ-Link, SL11, & CF.
   // 1024, 2048, and 4096 all gave similiar results which were much faster than 64 bytes
   // or even 512.
   //
   // EZ-Link Note: the pserial perf tests can sometimes go into timeout/retry/abort
   // situatiuon in the 2nd phase of a test. This is because it closes and then re-opens (so therefore purges) the driver's read  buffer.
   // The driver's USB read buffer is purged of a full 960 byte device FIFO, already consumed by the driver.
   // This is viewable in the debugger using DBG_READ_LENGTH. This does not happen with ActiveSync.
   //
   pDevExt->UsbReadBuffSize = USB_READBUFF_SIZE;
   pDevExt->UsbReadBuff = ExAllocatePool( NonPagedPool, pDevExt->UsbReadBuffSize );
   if ( !pDevExt->UsbReadBuff ) {

      status = STATUS_INSUFFICIENT_RESOURCES;
      UniqueErrorValue = ERR_NO_USBREAD_BUFF;

      goto AddDeviceFailed;
   }

   pDevExt->MaximumTransferSize = DEFAULT_PIPE_MAX_TRANSFER_SIZE;

#if defined (USE_RING_BUFF)
   // setup Ring Buffer
   pDevExt->RingBuff.Size  = RINGBUFF_SIZE;
   pDevExt->RingBuff.pHead =
   pDevExt->RingBuff.pTail =
   pDevExt->RingBuff.pBase = ExAllocatePool( NonPagedPool, pDevExt->RingBuff.Size );
   if ( !pDevExt->RingBuff.pBase ) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      UniqueErrorValue = ERR_NO_RING_BUFF;
      goto AddDeviceFailed;
   }
#endif

   // Initialize events
   //
   KeInitializeEvent( &pDevExt->PendingDataInEvent,    NotificationEvent /*SynchronizationEvent*/, FALSE);
   KeInitializeEvent( &pDevExt->PendingDataOutEvent,   NotificationEvent /*SynchronizationEvent*/, FALSE);
   KeInitializeEvent( &pDevExt->PendingIntEvent,       NotificationEvent /*SynchronizationEvent*/, FALSE);
   KeInitializeEvent( &pDevExt->PendingWorkItemsEvent, NotificationEvent /*SynchronizationEvent*/, FALSE);

   //
   // initialize nonpaged pools...
   //
   ExInitializeNPagedLookasideList(
         &pDevExt->PacketPool,   // Lookaside,
         NULL,                   // Allocate  OPTIONAL,
         NULL,                   // Free  OPTIONAL,
         0,                      // Flags,
         sizeof(USB_PACKET),   // Size,
         WCEUSB_POOL_TAG,        // Tag,
         0 );                    // Depth
   DbgDump(DBG_INIT, ("PacketPool: %p\n", &pDevExt->PacketPool));


   ExInitializeNPagedLookasideList(
         &pDevExt->BulkTransferUrbPool,
         NULL, NULL, 0,
         sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
         WCEUSB_POOL_TAG,
         0 );
   DbgDump(DBG_INIT, ("BulkTransferUrbPool: %p\n", &pDevExt->BulkTransferUrbPool));


   ExInitializeNPagedLookasideList(
         &pDevExt->PipeRequestUrbPool,
         NULL, NULL, 0,
         sizeof(struct _URB_PIPE_REQUEST),
         WCEUSB_POOL_TAG,
         0 );
   DbgDump(DBG_INIT, ("PipeRequestUrbPool: %p\n", &pDevExt->PipeRequestUrbPool));


   ExInitializeNPagedLookasideList(
         &pDevExt->VendorRequestUrbPool,
         NULL, NULL, 0,
         sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
         WCEUSB_POOL_TAG,
         0 );
   DbgDump(DBG_INIT, ("VendorRequestUrbPool: %p\n", &pDevExt->VendorRequestUrbPool));


   ExInitializeNPagedLookasideList(
         &pDevExt->WorkItemPool,
         NULL, NULL, 0,
         sizeof(WCE_WORK_ITEM),
         WCEUSB_POOL_TAG,
         0 );
   DbgDump(DBG_INIT, ("WorkItemPool: %p\n", &pDevExt->WorkItemPool));


   bListsInitilized = TRUE;


   //
   // initialize pending I/O lists
   //
   InitializeListHead( &pDevExt->PendingReadPackets );
   pDevExt->PendingReadCount = 0;

   InitializeListHead( &pDevExt->PendingWritePackets );
   pDevExt->PendingWriteCount = 0;

   InitializeListHead(&pDevExt->UserReadQueue);

   InitializeListHead( &pDevExt->PendingWorkItems );
   pDevExt->PendingWorkItemsCount = 0;


   //
   // Win 2000 ONLY : setup external SerialPort (COMx) interface
   // iff the user setup the magic reg key under
   // HKLM\SYSTEM\ControlSet\Services\wceusbsh\Parameters\ExposeComPort:REG_DWORD:1
   // This is NOT required for ActiveSync, only testing and is disabled by default.
   //
   // The Win9x CommXxx API *requires* going through VCOMM. Thus, we must
   // be installed as a virtual modem, and use ccport.sys and wdmmdmld.vxd ... NFW.
   //
   if ( !g_isWin9x && g_ExposeComPort ) {
      //
      // N.B. we don't want to use the static port name from the registry because the device
      // can come & go quickly (power up/down, etc.) and run into name collisions.
      //comPortNumber = GetComPort(pDevObj, pDevExt->SerialPort.Com.Instance-1);
      comPortNumber = GetFreeComPortNumber( );
      if (-1 == comPortNumber) {
         status = STATUS_DEVICE_DATA_ERROR;
         UniqueErrorValue = ERR_COMM_SYMLINK;
         goto AddDeviceFailed;
      }

      status = DoSerialPortNaming( pDevExt, comPortNumber );
      if (status != STATUS_SUCCESS) {
         UniqueErrorValue = ERR_COMM_SYMLINK;
         DbgDump(DBG_ERR, ("DoSerialPortNaming error: 0x%x\n", status));
         goto AddDeviceFailed;
      }

      status = IoRegisterShutdownNotification( pDevExt->DeviceObject );
      if (status != STATUS_SUCCESS) {
         UniqueErrorValue = ERR_COMM_SYMLINK;
         DbgDump(DBG_ERR, ("IoRegisterShutdownNotification error: 0x%x\n", status));
         TEST_TRAP();
         goto AddDeviceFailed;
      }

   } else {
        DbgDump(DBG_INIT, ("!GetFreeComPortNumber(%d, %d)\n", g_isWin9x, g_ExposeComPort));
   }

   //
   // attach to device stack
   //
   pDevExt->NextDevice = IoAttachDeviceToDeviceStack(pDevObj, PPDO);
   if ( !pDevExt->NextDevice ) {

      status = STATUS_NO_SUCH_DEVICE;
      DbgDump(DBG_ERR, ("IoAttachDeviceToDeviceStack error: 0x%x\n", status));

   } else {

      // set state after we attach to the stack
      InterlockedExchange((PULONG)&pDevExt->PnPState, PnPStateAttached);

   }

#if PERFORMANCE
   InitPerfCounters();
#endif


AddDeviceFailed:

   if (status != STATUS_SUCCESS) {

      if (pDevObj != NULL) {
         UsbFreeReadBuffer( pDevObj );
         if (pDevExt) {
            if (pDevExt->NextDevice) {
                DbgDump(DBG_INIT, ("Detach from PDO\n"));
                IoDetachDevice(pDevExt->NextDevice);
            }
            if ( bListsInitilized) {
               //
               // delete LookasideLists
               //
               DbgDump(DBG_INIT, ("Deleting LookasideLists\n"));
               ExDeleteNPagedLookasideList( &pDevExt->PacketPool );
               ExDeleteNPagedLookasideList( &pDevExt->BulkTransferUrbPool );
               ExDeleteNPagedLookasideList( &pDevExt->PipeRequestUrbPool );
               ExDeleteNPagedLookasideList( &pDevExt->VendorRequestUrbPool );
               ExDeleteNPagedLookasideList( &pDevExt->WorkItemPool );
            }
            UndoSerialPortNaming(pDevExt);
         }
         ReleaseSlot( PtrToLong(NULL) );
         DeleteDevObjAndSymLink(pDevObj);
      }
   }

   if (STATUS_INSUFFICIENT_RESOURCES == status) {

      DbgDump(DBG_ERR, ("AddDevice ERROR: 0x%x, %d\n", status, UniqueErrorValue));
      LogError( PDrvObj,
                NULL,
                0, 0, 0,
                UniqueErrorValue,
                status,
                SERIAL_INSUFFICIENT_RESOURCES,
                (pDevExt && pDevExt->DeviceName.Buffer) ? pDevExt->DeviceName.Length + sizeof(WCHAR) : 0,
                (pDevExt && pDevExt->DeviceName.Buffer) ? pDevExt->DeviceName.Buffer : NULL,
                0, NULL );

   } else if (STATUS_SUCCESS != status ) {
      // handles all other failures
      LogError( PDrvObj,
                NULL,
                0, 0, 0,
                UniqueErrorValue,
                status,
                SERIAL_INIT_FAILED,
                (pDevExt && pDevExt->DeviceName.Buffer) ? pDevExt->DeviceName.Length + sizeof(WCHAR) : 0,
                (pDevExt && pDevExt->DeviceName.Buffer) ? pDevExt->DeviceName.Buffer : NULL,
                0, NULL );
   }

   DbgDump(DBG_INIT, ("<AddDevice 0x%x\n", status));

   return status;
}



NTSTATUS
Create(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   )
{
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
    NTSTATUS status;

    DbgDump(DBG_INIT|DBG_TRACE, (">Create (%p)\n", PDevObj));

    if (!CanAcceptIoRequests(PDevObj, TRUE, FALSE) ||
        !NT_SUCCESS(AcquireRemoveLock(&pDevExt->RemoveLock, IRP_MJ_CREATE)))
    {
        status = STATUS_DELETE_PENDING;
        DbgDump(DBG_ERR, ("Create: 0x%x\n", status));
        PIrp->IoStatus.Status = status;
        IoCompleteRequest(PIrp, IO_NO_INCREMENT);
        return status;
    }

    ASSERT_SERIAL_PORT(pDevExt->SerialPort);

    //
    // Serial devices do not allow multiple concurrent opens
    //
    if ( InterlockedIncrement( &pDevExt->SerialPort.Com.OpenCnt ) != 1 ) {
        InterlockedDecrement( &pDevExt->SerialPort.Com.OpenCnt );
        status = STATUS_ACCESS_DENIED;
        DbgDump(DBG_ERR, ("OpenComPort ERROR: 0x%x\n", status));
        goto CreateDone;
    }

    InterlockedExchange(&pDevExt->DeviceOpened, TRUE);

    // Take out an additional reference on ourself.
    // We are seeing a possible premature unload with open handles in ActiveSync.
    // We dereference it in IRP_MJ_CLEANUP instead or IRP_MJ_CLOSE in case the app crashes
    // where we wouldn't otherwise get it.
    ObReferenceObject( PDevObj );

    //
    // reset the virtual serial port interface,
    // but don't send anything on the bus yet
    //
    status = SerialResetDevice(pDevExt, PIrp, FALSE);

    if (STATUS_SUCCESS == status) {
        //
        // CederRapier BUGBUG 13310: clean the read buffer when the app does CreateFile.
        //
        status = SerialPurgeRxClear(PDevObj, TRUE );

        if ( NT_SUCCESS(status) ) {

#if !defined(DELAY_RXBUFF)
            // this will subit the read a bit earlier, making the connection faster
            if ( !pDevExt->IntPipe.hPipe ) {
                DbgDump(DBG_INIT, ("Create: kick starting another USB Read\n" ));
                status = UsbRead( pDevExt, FALSE );
            } else {
                DbgDump(DBG_INIT, ("Create: kick starting another USB INT Read\n" ));
                status = UsbInterruptRead( pDevExt );
            }

            if ( NT_SUCCESS(status) ) {
                // should be STATUS_PENDING
                status = STATUS_SUCCESS;
            }
#else
            // signal to start the RX buffer in SerIoctl
            InterlockedExchange(&pDevExt->StartUsbRead, 1);
#endif

        } else {
            DbgDump(DBG_ERR, ("SerialPurgeRxClear ERROR: %x\n", status));
            TEST_TRAP();
        }
    }

    if (STATUS_SUCCESS != status) {
        //
        // Let the user know that the device can not be opened.
        //
        DbgDump(DBG_ERR, ("*** UNRECOVERABLE CreateFile ERROR:0x%x, No longer Accepting Requests ***\n", status));

        InterlockedExchange(&pDevExt->AcceptingRequests, FALSE);

        InterlockedExchange(&pDevExt->DeviceOpened, FALSE);

        IoInvalidateDeviceState( pDevExt->PDO );

        LogError( NULL, PDevObj,
                  0, IRP_MJ_CREATE,
                  1, // retries
                  ERR_NO_CREATE_FILE,
                  status,
                  SERIAL_HARDWARE_FAILURE,
                  pDevExt->DeviceName.Length + sizeof(WCHAR),
                  pDevExt->DeviceName.Buffer,
                  0,
                  NULL );
    }

CreateDone:
   // we release this reference on Close.
   if (STATUS_SUCCESS != status) {
        ReleaseRemoveLock(&pDevExt->RemoveLock, IRP_MJ_CREATE);
   }

   PIrp->IoStatus.Status = status;
   PIrp->IoStatus.Information = 0;
   IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

   DbgDump(DBG_INIT|DBG_TRACE, ("<Create 0x%x\n", status));

   return status;
}


NTSTATUS
Close(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP PIrp
   )
{
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG openCount;

    DbgDump(DBG_INIT|DBG_TRACE, (">Close (%p)\n", PDevObj));
    PAGED_CODE();

    ASSERT_SERIAL_PORT(pDevExt->SerialPort);

    //
    // stop any pending I/O
    //
    InterlockedExchange(&pDevExt->DeviceOpened, FALSE);

    status = StopIo(PDevObj);

    if (STATUS_SUCCESS == status) {

        if ( pDevExt->SerialPort.Com.OpenCnt ) {

            openCount = InterlockedDecrement( &pDevExt->SerialPort.Com.OpenCnt );

            if ( openCount != 0) {
               status = STATUS_UNSUCCESSFUL;
               DbgDump(DBG_WRN, ("Close ERROR: 0x%x RE: %d\n", status, openCount));
               TEST_TRAP();
            }
#ifdef DELAY_RXBUFF
            // signal our RX buffer
            InterlockedExchange(&pDevExt->StartUsbRead, 0);
#endif
        }

    } else {
        DbgDump(DBG_ERR, ("StopIo ERROR: 0x%x\n", status));
        TEST_TRAP();
    }

    PIrp->IoStatus.Status = status;
    PIrp->IoStatus.Information = 0;

    IoCompleteRequest(PIrp, IO_SERIAL_INCREMENT);

    if (STATUS_SUCCESS == status) {
        // Release the lock acquired in IRP_MJ_CREATE.
        // Warning: if the app misses our PnP signal then could we hang on this reference?
        ReleaseRemoveLock(&pDevExt->RemoveLock, IRP_MJ_CREATE);
   }

   DbgDump(DBG_INIT|DBG_TRACE, ("<Close 0x%x\n", status));

   return status;
}


NTSTATUS
Cleanup(
   IN PDEVICE_OBJECT PDevObj,
   IN PIRP Irp
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;

   DbgDump(DBG_INIT, (">Cleanup\n"));

   //
   // stop any pending I/O
   //
   InterlockedExchange(&pDevExt->DeviceOpened, FALSE);

   status = StopIo(PDevObj);
   if (STATUS_SUCCESS != status) {
       DbgDump(DBG_ERR, ("StopIo ERROR: 0x%x\n", status));
       TEST_TRAP();
   }

#ifdef DELAY_RXBUFF
   // signal our RX buffer
   InterlockedExchange(&pDevExt->StartUsbRead, 0);
#endif

   // Dereference the additional reference taken on IRP_MJ_CREATE.
   ObDereferenceObject( PDevObj );

   Irp->IoStatus.Status = STATUS_SUCCESS;
   Irp->IoStatus.Information = 0;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   DbgDump(DBG_INIT, ("<Cleanup 0x%x\n", status));
   return status;
}



VOID
KillAllPendingUserReads(
   IN PDEVICE_OBJECT PDevObj,
   IN PLIST_ENTRY PQueueToClean,
   IN PIRP *PpCurrentOpIrp
   )

/*++

Routine Description:

    cancel all queued user reads.

Arguments:

    PDevObj - A pointer to the serial device object.

    PQueueToClean - A pointer to the queue which we're going to clean out.

    PpCurrentOpIrp - Pointer to a pointer to the current irp.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
    KIRQL irql;
    NTSTATUS status;

    DbgDump( DBG_IRP, (">KillAllPendingUserReads\n"));


    KeAcquireSpinLock( &pDevExt->ControlLock, &irql );

    //
    // Clean the list from back to front.
    //
    while (!IsListEmpty(PQueueToClean)) {

        PIRP pCurrentLastIrp = CONTAINING_RECORD( PQueueToClean->Blink,
                                                  IRP,
                                                  Tail.Overlay.ListEntry);

        RemoveEntryList(PQueueToClean->Blink);

        KeReleaseSpinLock( &pDevExt->ControlLock, irql );

        status = ManuallyCancelIrp( PDevObj, pCurrentLastIrp);

        ASSERT(STATUS_SUCCESS == status );

        KeAcquireSpinLock( &pDevExt->ControlLock, &irql );
    }

    //
    // The queue is clean.  Now go after the current if
    // it's there.
    //
    if (*PpCurrentOpIrp) {

        KeReleaseSpinLock( &pDevExt->ControlLock, irql );

        status = ManuallyCancelIrp( PDevObj, *PpCurrentOpIrp );

        ASSERT(STATUS_SUCCESS == status );

    } else {

        DbgDump(DBG_IRP, ("No current Irp\n"));
        KeReleaseSpinLock( &pDevExt->ControlLock, irql );

    }

   DbgDump( DBG_IRP, ("<KillAllPendingUserReads\n"));

   return;
}


VOID
Unload(
   IN PDRIVER_OBJECT DriverObject
   )
/*++

Routine Description:

   Undo everything setup in DriverEntry

Arguments:

    DriverObject

Return Value:

    VOID

--*/
{
   UNREFERENCED_PARAMETER( DriverObject );

   DbgDump(DBG_INIT, (">Unload\n"));
   PAGED_CODE();

   // release global resources here

   DbgDump(DBG_INIT, ("<Unload\n"));
}



NTSTATUS
Flush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for flush.  Flushing works by placing
    this request in the write queue.  When this request reaches the
    front of the write queue we simply complete it since this implies
    that all previous writes have completed.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );

    DbgDump( DBG_INIT|DBG_READ_LENGTH|DBG_WRITE_LENGTH, ("Flush\n"));
    PAGED_CODE();

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0L;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}



NTSTATUS
QueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to query the end of file information on
    the opened serial port.  Any other file information request
    is retured with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    UNREFERENCED_PARAMETER(DeviceObject);

    DbgDump( DBG_INIT|DBG_READ_LENGTH, (">QueryInformationFile\n"));
    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;

    if (IrpSp->Parameters.QueryFile.FileInformationClass == FileStandardInformation) {

        PFILE_STANDARD_INFORMATION Buf = Irp->AssociatedIrp.SystemBuffer;

        Buf->AllocationSize.QuadPart = 0;
        Buf->EndOfFile = Buf->AllocationSize;
        Buf->NumberOfLinks = 0;
        Buf->DeletePending = FALSE;
        Buf->Directory = FALSE;
        Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);

    } else if (IrpSp->Parameters.QueryFile.FileInformationClass == FilePositionInformation) {

        ((PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->CurrentByteOffset.QuadPart = 0;
        Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);

    } else {
        Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
    }

   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   DbgDump( DBG_INIT|DBG_READ_LENGTH, ("<QueryInformationFile\n"));

    return Status;
}



NTSTATUS
SetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to set the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

    DbgDump( DBG_INIT|DBG_READ_LENGTH, (">SetInformationFile\n"));

    Irp->IoStatus.Information = 0L;

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileEndOfFileInformation) {
//        || (IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileAllocationInformation)) { // FileAllocationInformationnot defined in wdm.h

        Status = STATUS_SUCCESS;

    } else {

        Status = STATUS_INVALID_PARAMETER;

    }

   Irp->IoStatus.Status = Status;

   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   DbgDump( DBG_INIT|DBG_READ_LENGTH, ("<SetInformationFile\n"));

    return Status;
}



NTSTATUS
Shutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    DbgDump(DBG_INIT, (">Shutdown\n"));
    PAGED_CODE();

    //
    // Special Case - If an app has an open handle to the device,
    // and the system is being shut down in a controlled manner,
    // and we have not been removed via PnP, then remove the COMx name
    // from the Registry's COM Name Arbitrator DataBase for the next boot cycle.
    // Win NT only; Win9x does not export COMx names.
    //
    // N.B: we have to do this in a Shutdown handler, and NOT in the PNP_POWER handler
    // because the Registry entry is NOT saved in the Power down code path.
    //
    if ( !g_isWin9x && g_ExposeComPort &&
         pDevExt->SerialPort.Com.PortNumber &&
         (PnPStateStarted  == pDevExt->PnPState) ) {
            //
            // remove our entry from ComDB
            //
            ReleaseCOMPort( pDevExt->SerialPort.Com.PortNumber );
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0L;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DbgDump(DBG_INIT, ("<Shutdown\n"));

    return status;
}


VOID
UsbFreeReadBuffer(
   IN PDEVICE_OBJECT PDevObj
   )
{
   PDEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

   DbgDump(DBG_USB, (">UsbFreeReadBuffer %p\n", PDevObj));
   PAGED_CODE();

   if ( pDevExt->UsbReadBuff != NULL ) {
      ExFreePool(pDevExt->UsbReadBuff);
      pDevExt->UsbReadBuff = NULL;
   }

#if defined (USE_RING_BUFF)
   if ( pDevExt->RingBuff.pBase != NULL ) {
      ExFreePool(pDevExt->RingBuff.pBase);
      pDevExt->RingBuff.pBase =
      pDevExt->RingBuff.pHead =
      pDevExt->RingBuff.pTail = NULL;
   }
#endif // USE_RING_BUFF

   DbgDump(DBG_USB, ("<UsbFreeReadBuffer\n"));
   return;
}


NTSTATUS 
SystemControl(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
{
    PDEVICE_EXTENSION   pDevExt;

    PAGED_CODE();

    DbgDump(DBG_INIT, ("SystemControl\n"));

    pDevExt = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(pDevExt->NextDevice, Irp);
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\kdext.c ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Stephane Plante (splante)
    jdunn, adapted to USB2

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

#ifdef USB_KD64
DBGKD_GET_VERSION64     KernelVersionPacket;
#else 
DBGKD_GET_VERSION32     KernelVersionPacket;
#endif

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    return;
}


VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ( (SavedMajorVersion != 0x0c) ||
         (SavedMinorVersion != VER_PRODUCTBUILD) ) {

        dprintf(
            "\r\n*** Extension DLL(%d Checked) does not match target "
            "system(%d %s)\r\n\r\n",
            VER_PRODUCTBUILD,
            SavedMinorVersion,
            (SavedMajorVersion==0x0f) ? "Free" : "Checked"
            );

    }
#else
    if ( (SavedMajorVersion != 0x0f) ||
         (SavedMinorVersion != VER_PRODUCTBUILD) ) {

        dprintf(
            "\r\n*** Extension DLL(%d Free) does not match target "
            "system(%d %s)\r\n\r\n",
            VER_PRODUCTBUILD,
            SavedMinorVersion,
            (SavedMajorVersion==0x0f) ? "Free" : "Checked"
            );

    }
#endif
}


BOOL
HaveDebuggerData(
    VOID
    )
{
    static int havedata = 0;

    if (havedata == 2) {
        return FALSE;
    }

    if (havedata == 0) {
        if (!Ioctl(
                IG_GET_KERNEL_VERSION,
                (PVOID)(&KernelVersionPacket),
                sizeof(KernelVersionPacket)
                )
            ) {
            havedata = 2;

        } else if (KernelVersionPacket.MajorVersion == 0) {

            havedata = 2;

        } else {

            havedata = 1;

        }

    }

    return (havedata == 1) &&
           ((KernelVersionPacket.Flags & DBGKD_VERS_FLAG_DATA) != 0);
}

#if 0
BOOL
GetUlong (
    IN  PCHAR   String,
    IN  PULONG  Value
    )
{
    BOOL    status;
    ULONG_PTR Location;
    ULONG   result;


    Location = GetExpression( String );
    if (!Location) {

        dprintf("unable to get %s\n",String);
        return FALSE;

    }

    status = ReadMemory(
        Location,
        Value,
        sizeof(ULONG),
        &result
        );
    if (status == FALSE || result != sizeof(ULONG)) {

        return FALSE;

    }
    return TRUE;
}


BOOL
GetUlongPtr (
    IN  PCHAR   String,
    IN  PULONG_PTR Address
    )
{
    BOOL    status;
    ULONG_PTR Location;
    ULONG   result;


    Location = GetExpression( String );
    if (!Location) {

        dprintf("unable to get %s\n",String);
        return FALSE;

    }

    status = ReadMemory(
        Location,
        Address,
        sizeof(ULONG_PTR),
        &result
        );
    if (status == FALSE || result != sizeof(ULONG)) {

        return FALSE;

    }
    return TRUE;
}
#endif //xxx

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf(
        "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
        DebuggerType,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
        );

   return S_OK;         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\inc\hackflag.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    hackflag.h

Abstract:

    USB 'hack flags' are defined to work around specific 
    device problems.

    These flags are placed in the registry under 
    HKLM\CCS\Services\USB\DeviceHackFlags\VIDnnnn&PIDnnnn&REVnnnn
    or
    HKLM\CCS\Services\USB\DeviceHackFlags\VIDnnnn&PIDnnnn

    as a DWORD key HackFlags

Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __HACKFLAG_H__
#define   __HACKFLAG_H__



#define USB_HACKFLAG_IGNORE_PF_XXX         0x00000001


#endif    //__HACKFLAG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\inc\usbpriv.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbpriv.h

Abstract:

Environment:

    Kernel & user mode

Revision History:

    10-30-01 : created

--*/

#ifndef   __USB_PRIV_H__
#define   __USB_PRIV_H__

// {022252A1-ED5D-4e3f-976F-B2D9DB3D2BD3}
DEFINE_GUID(GUID_USBPRIV_ROOTPORT_STATUS, 
0x22252a1, 0xed5d, 0x4e3f, 0x97, 0x6f, 0xb2, 0xd9, 0xdb, 0x3d, 0x2b, 0xd3);


typedef struct _USBPRIV_ROOTPORT_STATUS
{
    RH_PORT_STATUS PortStatus;
    USHORT         PortNumber;
}
USBPRIV_ROOTPORT_STATUS, *PUSBPRIV_ROOTPORT_STATUS;

#endif /* __USB_PRIV_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\ext.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ext.c

Abstract:

    WinDbg Extension Api
    implements !_ext
               !_help
               !_pow

Author:

    jdunn

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usbhcdkd.h"


PUCHAR
S_State(
    SYSTEM_POWER_STATE S
    )
{
    switch (S) {
    case PowerSystemUnspecified:
        return "SystemUnspecified(S?)";
    case PowerSystemWorking:
        return "SystemWorking    (S0)";
    case PowerSystemSleeping1:
        return "SystemSleeping1  (S1)";
    case PowerSystemSleeping2:
        return "SystemSleeping2  (S2)";
    case PowerSystemSleeping3:
        return "SystemSleeping3  (S3)";
    case PowerSystemHibernate:
        return "SystemHibernate      ";
    case PowerSystemShutdown:
        return "SystemShutdown       ";
    case PowerSystemMaximum:
        return "SystemMaximum        ";
    }

    return "???";
}


PUCHAR
PwrAttributes(
    HC_POWER_ATTRIBUTES A
    )
{
    switch (A) {
    case HcPower_N_Wakeup_N:
        return "HcPower_N_Wakeup_N";
    case HcPower_Y_Wakeup_Y:
        return "HcPower_Y_Wakeup_Y";
    case HcPower_Y_Wakeup_N:
        return "HcPower_Y_Wakeup_N";
    case HcPower_N_Wakeup_Y:
        return "HcPower_N_Wakeup_Y";
    }
    return "???";
}


PUCHAR
D_State(
    DEVICE_POWER_STATE D
    )
{
    switch (D) {
    case PowerDeviceUnspecified:
        return "D?";
    case PowerDeviceD0:
        return "D0";
    case PowerDeviceD1:
        return "D1";
    case PowerDeviceD2:
        return "D2";
    case PowerDeviceD3:
        return "D3";
    case PowerDeviceMaximum:
        return "DX";
    }

    return "??";
}


VOID
DumpPortFdoDevExt(
    MEMLOC ExtMemLoc
    )
{
    ULONG i, f;
    UCHAR cs[] = "usbport!_FDO_EXTENSION";
    ULONG bandwidthTable[USBPORT_MAX_INTEP_POLLING_INTERVAL];
    MEMLOC l;

    FLAG_TABLE fdoFlags[] = {
    "USBPORT_FDOFLAG_IRQ_CONNECTED", USBPORT_FDOFLAG_IRQ_CONNECTED,
    "USBPORT_FDOFLAG_ENABLE_SYSTEM_WAKE", USBPORT_FDOFLAG_ENABLE_SYSTEM_WAKE,
    "USBPORT_FDOFLAG_POLL_CONTROLLER", USBPORT_FDOFLAG_POLL_CONTROLLER,
    "USBPORT_FDOFLAG_KILL_THREAD", USBPORT_FDOFLAG_KILL_THREAD,

    "USBPORT_FDOFLAG_NEED_SET_POWER_D0", USBPORT_FDOFLAG_NEED_SET_POWER_D0,
    "USBPORT_FDOFLAG_DM_TIMER_ENABLED", USBPORT_FDOFLAG_DM_TIMER_ENABLED,
    "USBPORT_FDOFLAG_SKIP_TIMER_WORK", USBPORT_FDOFLAG_SKIP_TIMER_WORK,
    "USBPORT_FDOFLAG_OFF", USBPORT_FDOFLAG_OFF,

    "USBPORT_FDOFLAG_SUSPENDED", USBPORT_FDOFLAG_SUSPENDED,
    "USBPORT_FDOFLAG_IRQ_EN", USBPORT_FDOFLAG_IRQ_EN,
    "USBPORT_FDOFLAG_RH_CAN_SUSPEND", USBPORT_FDOFLAG_RH_CAN_SUSPEND,
    "USBPORT_FDOFLAG_RESUME_SIGNALLING", USBPORT_FDOFLAG_RESUME_SIGNALLING,

    "USBPORT_FDOFLAG_HCPENDING_WAKE_IRP", USBPORT_FDOFLAG_HCPENDING_WAKE_IRP,
    "USBPORT_FDOFLAG_DM_TIMER_INIT",  USBPORT_FDOFLAG_DM_TIMER_INIT,
    "USBPORT_FDOFLAG_THREAD_INIT", USBPORT_FDOFLAG_THREAD_INIT

    };

    FLAG_TABLE mpStateFlags[] = {
        "MP_STATE_STARTED", MP_STATE_STARTED,
        "MP_STATE_SUSPENDED", MP_STATE_SUSPENDED
         };


    dprintf ("\n");
    PrintfMemLoc("**USBPORT FDO_EXTENSION ", ExtMemLoc, "\n");

    PrintfMemLoc("WorkerThreadHandle: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "WorkerThreadHandle"),
            "\n");

    PrintfMemLoc("WorkerPkThread: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "WorkerPkThread"),
            "\n");

    PrintfMemLoc("HcPendingWakeIrp: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "HcPendingWakeIrp"),
            "\n");

    PrintfMemLoc("PhysicalDeviceObject: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "PhysicalDeviceObject"),
            "\n");

    PrintfMemLoc("TopOfStackDeviceObject: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "TopOfStackDeviceObject"),
            "\n");

    PrintfMemLoc("RootHubPdo: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "RootHubPdo"),
            "\n");

    dprintf ("DM_TimerInterval: %d\n",
                UsbReadFieldUlong(ExtMemLoc, cs, "DM_TimerInterval")
            );
    dprintf ("DeviceNameIdx: %d\n",
                UsbReadFieldUlong(ExtMemLoc, cs, "DeviceNameIdx")
            );
    dprintf ("TotalBusBandwidth: %d\n",
                UsbReadFieldUlong(ExtMemLoc, cs, "TotalBusBandwidth")
            );

    dprintf ("Bandwidth Table[]\n");


    {
    ULONG64 addr;
    ULONG cb;

    addr = ExtMemLoc + UsbFieldOffset(cs,
            "BandwidthTable[0]");

    ReadMemory(addr,
               &bandwidthTable,
               (ULONG)sizeof(bandwidthTable),
               &cb);
    }

    for (i=0; i< USBPORT_MAX_INTEP_POLLING_INTERVAL/4; i++) {
        dprintf ("[%02.2d] - %8d [%02.2d] - %8d [%02.2d] - %8d [%02.2d] - %8d\n",
            i*4, bandwidthTable[i*4],
            i*4+1, bandwidthTable[i*4+1],
            i*4+2, bandwidthTable[i*4+2],
            i*4+3, bandwidthTable[i*4+3]);
    }

    dprintf ("AllocedInterruptBW 1,2,4,8,16,32 ms\n");
    for (i=0; i<6; i++) {
        UCHAR s[80];
        sprintf(s, "AllocedInterruptBW[%d]", i);
        dprintf ("bits/sec %d \n",
            UsbReadFieldUlong(ExtMemLoc, cs, s)
            );
    }

    dprintf ("AllocedIsoBW %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "AllocedIsoBW")
        );

    // pm stats
    //dprintf ("D0ResumeTimeStart %d \n",
    //    UsbReadFieldUlong(ExtMemLoc, cs, "D0ResumeTimeStart")
    //    );
    //dprintf ("S0ResumeTimeStart %d \n",
    //    UsbReadFieldUlong(ExtMemLoc, cs, "S0ResumeTimeStart")
    //    );
    //dprintf ("ThreadResumeTimeStart %d \n",
    //    UsbReadFieldUlong(ExtMemLoc, cs, "ThreadResumeTimeStart")
    //    );
    dprintf ("HC FDO Time -------------\n");
    dprintf ("ThreadResumeTime %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "ThreadResumeTime")
        );
    dprintf ("ControllerResumeTime %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "ControllerResumeTime")
        );
    dprintf ("D0ResumeTime %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "D0ResumeTime")
        );
    dprintf ("S0ResumeTime %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "S0ResumeTime")
        );
    dprintf ("CancelHcWakeIrp %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "CancelHcWakeIrp")
        );
    dprintf ("CcLockTime %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "CcLockTime")
        );

    //dprintf ("RootHubS0ResumeTime %d \n",
    //    UsbReadFieldUlong(ExtMemLoc, cs, "RootHubS0ResumeTime")
    //    );

    dprintf ("HUB PDO Time -------------\n");
    dprintf ("RootHubD0Time %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "RootHubD0Time")
        );
    dprintf ("MpResumeTime %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "MpResumeTime")
        );
    dprintf ("MpStartTime %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "MpStartTime")
        );
    dprintf ("CompletePdoWaitWake %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "CompletePdoWaitWake")
        );
    dprintf ("CompletePendingIdleIrp %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "CompletePendingIdleIrp")
        );
    dprintf ("ResumeController %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "ResumeController")
        );
    dprintf ("ControllerWait %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "ControllerWait")
        );
    dprintf ("-------------------------\n");
    // stats

    dprintf ("StatBulkBytes %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "StatBulkBytes")
        );

    dprintf ("StatIsoBytes %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "StatIsoBytes")
        );

    dprintf ("StatInterruptBytes %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "StatInterruptBytes")
        );

    dprintf ("StatControlDataBytes %d \n",
        UsbReadFieldUlong(ExtMemLoc, cs, "StatControlDataBytes")
        );

    PrintfMemLoc("***Miniport Extension: ",
            ExtMemLoc + UsbFieldOffset(cs, "MiniportExtension"),
            "\n");

    f = UsbReadFieldUlong(ExtMemLoc, cs, "FdoFlags"),
    dprintf ("FdoFlags %08.8x\n", f);
    UsbDumpFlags(f, fdoFlags,
        sizeof(fdoFlags)/sizeof(FLAG_TABLE));

    f = UsbReadFieldUlong(ExtMemLoc, cs, "MpStateFlags"),
    dprintf ("MpStateFlags %08.8x\n", f);
    UsbDumpFlags(f, mpStateFlags,
        sizeof(mpStateFlags)/sizeof(FLAG_TABLE));

    dprintf ("DmaBusy %d\n",
        UsbReadFieldUlong(ExtMemLoc, cs, "DmaBusy")
        );
    dprintf ("WorkerDpc %d\n",
        UsbReadFieldUlong(ExtMemLoc, cs, "WorkerDpc")
        );

    dprintf ("PciVendorId: %04.4x PciDeviceId: %04.4x Rev %02.2x\n",
        UsbReadFieldUshort(ExtMemLoc, cs, "PciVendorId"),
        UsbReadFieldUshort(ExtMemLoc, cs, "PciDeviceId"),
        UsbReadFieldUshort(ExtMemLoc, cs, "PciRevisionId")
        );

    f = UsbReadFieldUlong(ExtMemLoc, cs, "HcFlavor"),
    dprintf ("ControllerFlavor: %d ", f);

    switch(f) {
    case USB_HcGeneric:
        dprintf ("USB_HcGeneric\n");
        break;
    case OHCI_Generic:
        dprintf ("OHCI_Generic\n");
        break;
    case OHCI_Hydra:
        dprintf ("OHCI_Hydra\n");
        break;
    case OHCI_NEC:
        dprintf ("OHCI_NEC\n");
        break;
    case UHCI_Generic:
        dprintf ("UHCI_Generic\n");
        break;
    case UHCI_Piix4:
        dprintf ("UHCI_Piix4\n");
        break;
    case EHCI_Generic:
        dprintf ("EHCI_Generic\n");
        break;
//    case EHCI_960MUlator:
//        dprintf ("EHCI_960MUlator\n");
//        break;
    default:
        dprintf ("???\n");
    }

    dprintf ("-Driver Lists-\n");
    //GETMEMLOC(x, MemLoc, DEVICE_EXTENSION, Fdo.DeviceHandleList);

    l = ExtMemLoc + UsbFieldOffset(cs, "DeviceHandleList");
    PrintfMemLoc("(DH) DeviceHandleList: ",
            l,
            ListEmpty(l));

    l = ExtMemLoc + UsbFieldOffset(cs, "MapTransferList");
    PrintfMemLoc("(MT) MapTransferList: ",
            l,
            ListEmpty(l));

    l = ExtMemLoc + UsbFieldOffset(cs, "DoneTransferList");
    PrintfMemLoc("(DT) DoneTransferList: ",
            l,
            ListEmpty(l));

    l = ExtMemLoc + UsbFieldOffset(cs, "EpStateChangeList");
    PrintfMemLoc("(SC) EpStateChangeList: ",
            l,
            ListEmpty(l));

    l = ExtMemLoc + UsbFieldOffset(cs, "GlobalEndpointList");
    PrintfMemLoc("(GL) GlobalEndpointList: ",
            l,
            ListEmpty(l));

    l = ExtMemLoc + UsbFieldOffset(cs, "AttendEndpointList");
    PrintfMemLoc("(AT) AttendEndpointList: ",
            l,
            ListEmpty(l));

    l = ExtMemLoc + UsbFieldOffset(cs, "EpClosedList");
    PrintfMemLoc("(XL) EpClosedList: ",
            l,
            ListEmpty(l));

    l = ExtMemLoc + UsbFieldOffset(cs, "BadRequestList");
    PrintfMemLoc("(BA) BadRequestList: ",
            l,
            ListEmpty(l));
}


VOID
DumpPortPdoDevExt(
    MEMLOC ExtMemLoc
    )
{
    UCHAR cs[] = "usbport!_PDO_EXTENSION";

    dprintf ("\n");
    PrintfMemLoc("**USBPORT PDO_EXTENSION ", ExtMemLoc, "\n");


    PrintfMemLoc("RootHubInterruptEndpoint: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "RootHubInterruptEndpoint"),
            "\n");

    dprintf ("ConfigurationValue: %d\n",
                UsbReadFieldUchar(ExtMemLoc, cs, "Flags"));

    PrintfMemLoc("DeviceDescriptor: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "DeviceDescriptor"),
            "\n");

    PrintfMemLoc("ConfigurationDescriptor: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "ConfigurationDescriptor"),
            "\n");

    PrintfMemLoc("HubDescriptor: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "HubDescriptor"),
            "\n");

    PrintfMemLoc("PendingWaitWakeIrp: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "PendingWaitWakeIrp"),
            "\n");

    PrintfMemLoc("PendingIdleNotificationIrp: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "PendingIdleNotificationIrp"),
            "\n");

    PrintfMemLoc("Descriptors: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "Descriptors"),
            "\n");

}


VOID
DumpPowerCaps(
    MEMLOC MemLoc
    )
{
    SYSTEM_POWER_STATE s;
    DEVICE_CAPABILITIES devCaps;
    ULONG cb;

    PrintfMemLoc(">Power Capabilities @ ",
                  MemLoc,
                 "\n");

    ReadMemory(MemLoc,
               &devCaps,
               sizeof(devCaps),
               &cb);


    dprintf ("\tSystemWake = %s\n",
        S_State(devCaps.SystemWake));

    dprintf ("\tDeviceWake = %s\n",
        D_State(devCaps.DeviceWake));

    dprintf ("\t<System Power State Map>\n");
    for (s=PowerSystemUnspecified; s< PowerSystemMaximum; s++) {
        dprintf ("\t%s =  %s\n",
            S_State(s), D_State(devCaps.DeviceState[s]));
    }
}


VOID
DumpFdoPower(
    MEMLOC MemLoc
    )
{
    MEMLOC ExtMemLoc;
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    ULONG pa, st, d, i;
    UCHAR s[64];
    UCHAR csFdo[] = "usbport!_FDO_EXTENSION";

    PrintfMemLoc("*POWER SUMMARY fdo (ext) ",
                  MemLoc,
                 "\n");

    // dump the hc power caps
    dprintf ("HC Power Capabilities\n");
    DumpPowerCaps(MemLoc + UsbFieldOffset(cs, "DeviceCapabilities"));

    ExtMemLoc = MemLoc + UsbFieldOffset(cs, "Fdo");
    // dump power attributes
    dprintf ("HC Power Attributes\n");
    for (i=0; i< USBPORT_MAPPED_SLEEP_STATES; i++) {

        sprintf(s, "HcPowerStateTbl.PowerState[0].SystemState", i);
        st = UsbReadFieldUlong(ExtMemLoc, csFdo, s);
        sprintf(s, "HcPowerStateTbl.PowerState[0].DeviceState", i);
        d = UsbReadFieldUlong(ExtMemLoc, csFdo, s);
        sprintf(s, "HcPowerStateTbl.PowerState[0].Attributes", i);
        pa = UsbReadFieldUlong(ExtMemLoc, csFdo, s);

        dprintf("[%d] %s - %s  %s\n",
            i,
            S_State(st),
            D_State(d),
            PwrAttributes(pa));
        ExtMemLoc+=sizeof(HC_POWER_STATE);
    }


}


VOID
DumpFdoSpin(
    MEMLOC MemLoc
    )
{
    MEMLOC ExtMemLoc;
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    ULONG pa, st, d, i;
    UCHAR s[64];
    UCHAR csFdo[] = "usbport!_FDO_EXTENSION";

    PrintfMemLoc("*SPINLOCK SUMMARY fdo ",
                  MemLoc,
                 "\n");

    ExtMemLoc = MemLoc + UsbFieldOffset(cs, "Fdo");

    PrintfMemLoc("CoreFunctionSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "CoreFunctionSpin"),
                 "\n");
    PrintfMemLoc("MapTransferSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "MapTransferSpin"),
                 "\n");
    PrintfMemLoc("DoneTransferSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "DoneTransferSpin"),
                 "\n");
    PrintfMemLoc("EndpointListSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "EndpointListSpin"),
                 "\n");
    PrintfMemLoc("EpStateChangeListSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "EpStateChangeListSpin"),
                 "\n");
    PrintfMemLoc("DevHandleListSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "DevHandleListSpin"),
                 "\n");
    PrintfMemLoc("EpClosedListSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "EpClosedListSpin"),
                 "\n");
    PrintfMemLoc("PendingTransferIrpSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "PendingTransferIrpSpin"),
                 "\n");
    PrintfMemLoc("ActiveTransferIrpSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "ActiveTransferIrpSpin"),
                 "\n");
    PrintfMemLoc("WorkerThreadSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "WorkerThreadSpin"),
                 "\n");
    PrintfMemLoc("DM_TimerSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "DM_TimerSpin"),
                 "\n");
    PrintfMemLoc("WakeIrpSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "WakeIrpSpin"),
                 "\n");
    PrintfMemLoc("HcPendingWakeIrpSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "HcPendingWakeIrpSpin"),
                 "\n");
    PrintfMemLoc("IdleIrpSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "IdleIrpSpin"),
                 "\n");
    PrintfMemLoc("IsrDpcSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "IsrDpcSpin"),
                 "\n");
    PrintfMemLoc("StatCounterSpin - ",
                  ExtMemLoc + UsbFieldOffset(csFdo, "StatCounterSpin"),
                 "\n");
}


VOID
DumpBandwidth(
    MEMLOC MemLoc
    )
{
    MEMLOC ExtMemLoc;
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    ULONG pa, st, d, i;
    UCHAR s[64];
    UCHAR csFdo[] = "usbport!_FDO_EXTENSION";
    ULONG bandwidthTable[USBPORT_MAX_INTEP_POLLING_INTERVAL];

    PrintfMemLoc("*BANDWIDTH SUMMARY fdo_ext ",
                  MemLoc,
                 "\n");

    ExtMemLoc = MemLoc + UsbFieldOffset(cs, "Fdo");

    dprintf ("TotalBusBandwidth (bits/sec): %d\n",
                UsbReadFieldUlong(ExtMemLoc, csFdo, "TotalBusBandwidth")
            );


    // dump the 32 node bandwidth table

    {
    ULONG64 addr;
    ULONG cb;

    addr = ExtMemLoc + UsbFieldOffset(csFdo,
            "BandwidthTable[0]");

    ReadMemory(addr,
               &bandwidthTable,
               (ULONG)sizeof(bandwidthTable),
               &cb);
    }

    for (i=0; i< USBPORT_MAX_INTEP_POLLING_INTERVAL/4; i++) {
        dprintf ("[%02.2d] - %8d [%02.2d] - %8d [%02.2d] - %8d [%02.2d] - %8d\n",
            i*4, bandwidthTable[i*4],
            i*4+1, bandwidthTable[i*4+1],
            i*4+2, bandwidthTable[i*4+2],
            i*4+3, bandwidthTable[i*4+3]);
    }

    dprintf ("AllocedInterruptBW, period 1,2,4,8,16,32 ms\n");
    for (i=0; i<6; i++) {
        UCHAR s[80];
        sprintf(s, "AllocedInterruptBW[%d]", i);
        dprintf ("bits/sec %d \n",
            UsbReadFieldUlong(ExtMemLoc, csFdo, s)
            );
    }

    dprintf ("AllocedIsoBW %d \n",
        UsbReadFieldUlong(ExtMemLoc, csFdo, "AllocedIsoBW")
        );

    {
    ULONG m, t;
    t =  UsbReadFieldUlong(ExtMemLoc, csFdo, "TotalBusBandwidth");
    m =  UsbReadFieldUlong(ExtMemLoc, csFdo, "MaxAllocedBw");
    dprintf ("MaxAllocedBw %d %% (%d)\n", m, (m*100/t));
    m =  UsbReadFieldUlong(ExtMemLoc, csFdo, "MinAllocedBw");
    dprintf ("MinAllocedBw %d %% (%d)\n", m, (m*100/t));
    }

}


#if 0
VOID
DumpCaps(
    PDEVICE_CAPABILITIES DevCaps
    )
{
    dprintf ("USBPORT PDO Extension\n");

    dprintf("DeviceCapabilities: \n");
    dprintf(">Size %d Version %d\n", devCaps.Size, devCaps.Version);
    dprintf(">Address %08.8x UINumber %08.8x\n", devCaps.Address, devCaps.UINumber);

    dprintf(">DeviceD1: ");
    if (devCaps.DeviceD1) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">DeviceD2: ");
    if (devCaps.DeviceD2) {
    dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">LockSupported: ");
    if (devCaps.LockSupported) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">EjectSupported: ");
    if (devCaps.EjectSupported) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">Removable: ");
    if (devCaps.Removable) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">DockDevice: ");
    if (devCaps.DockDevice) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">UniqueID: ");
    if (devCaps.UniqueID) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">SilentInstall: ");
    if (devCaps.SilentInstall) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">RawDeviceOK: ");
    if (devCaps.RawDeviceOK) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">SurpriseRemovalOK: ");
    if (devCaps.SurpriseRemovalOK) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">WakeFromD0: ");
    if (devCaps.WakeFromD0) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">WakeFromD1: ");
    if (devCaps.WakeFromD1) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">WakeFromD2: ");
    if (devCaps.WakeFromD2) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">WakeFromD3: ");
    if (devCaps.WakeFromD3) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">HardwareDisabled: ");
    if (devCaps.HardwareDisabled) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">NonDynamic: ");
    if (devCaps.NonDynamic) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }
    dprintf(">WarmEjectSupported: ");
    if (devCaps.WarmEjectSupported) {
        dprintf(" yes\n");
    } else {
        dprintf(" no\n");
    }

    //BUGBUG
    //DEVICE_POWER_STATE DeviceState[PowerSystemMaximum];
    //SYSTEM_POWER_STATE SystemWake;
    //DEVICE_POWER_STATE DeviceWake;
    dprintf(">D1Latency: %d\n", devCaps.D1Latency);
    dprintf(">D2Latency: %d\n", devCaps.D2Latency);
    dprintf(">D3Latency: %d\n", devCaps.D3Latency);
}
#endif


VOID
DumpPortDevExt(
    MEMLOC ExtMemLoc
    )
{
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    ULONG sig, f;
    DEVICE_POWER_STATE dps;

    FLAG_TABLE flags[] = {
        "USBPORT_FLAG_SYM_LINK", USBPORT_FLAG_SYM_LINK
        };
    FLAG_TABLE pnpFlags[] = {
        "USBPORT_PNP_STOPPED", USBPORT_PNP_STOPPED,
        "USBPORT_PNP_STARTED", USBPORT_PNP_STARTED,
        "USBPORT_PNP_REMOVED", USBPORT_PNP_REMOVED,
        "USBPORT_PNP_START_FAILED", USBPORT_PNP_START_FAILED
        };

    PrintfMemLoc("*USBPORT DEVICE_EXTENSION ", ExtMemLoc, "\n");

    PrintfMemLoc("DummyUsbdExtension: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "DummyUsbdExtension"),
            "\n");

    sig = UsbReadFieldUlong(ExtMemLoc, cs, "Sig");

    if (sig != USBPORT_DEVICE_EXT_SIG &&
        sig != ROOTHUB_DEVICE_EXT_SIG) {
        dprintf("Not a USBPORT Extension\n");
        return;
    }

    Sig(sig, "");

    PrintfMemLoc("HcFdoDeviceObject: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "HcFdoDeviceObject"),
            "\n");

    PrintfMemLoc("LogPtr: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "Log.LogPtr"),
            "");
    PrintfMemLoc("LogStart: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "Log.LogStart"),
            "");
    PrintfMemLoc("LogEnd: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "Log.LogEnd"),
            "\n");

    PrintfMemLoc("EnumLog.LogPtr: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "EnumLog.LogPtr"),
            "");
    PrintfMemLoc("EnumLog.LogStart: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "EnumLog.LogStart"),
            "");
    PrintfMemLoc("EnumLog.LogEnd: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "EnumLog.LogEnd"),
            "\n");

    PrintfMemLoc("PendingRequestCount: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "PendingRequestCount"),
            "\n");

    PrintfMemLoc("TrackIrpList.Flink: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "TrackIrpList.Flink"),
            "\n");
    PrintfMemLoc("TrackIrpList.Blink: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "TrackIrpList.Blink"),
            "\n");

    PrintfMemLoc("PendingTransferIrpTable: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "PendingTransferIrpTable"),
            "\n");
    PrintfMemLoc("ActiveTransferIrpTable: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "ActiveTransferIrpTable"),
            "\n");

    f = UsbReadFieldUlong(ExtMemLoc, cs, "Flags");
    dprintf("Flags: %08.8x\n", f);
    UsbDumpFlags(f, flags,
        sizeof(flags)/sizeof(FLAG_TABLE));

    f = UsbReadFieldUlong(ExtMemLoc, cs, "PnpStateFlags");
    dprintf("PnpStateFlags: %08.8x\n", f);
    UsbDumpFlags(f, pnpFlags,
        sizeof(pnpFlags)/sizeof(FLAG_TABLE));

    dprintf("----------------\n");
    PrintfMemLoc("SystemPowerIrp: ",
            UsbReadFieldPtr(ExtMemLoc, cs, "SystemPowerIrp"),
            "\n");
    dprintf("CurrentDevicePowerState: ");

    dps = (DEVICE_POWER_STATE) UsbReadFieldUlong(ExtMemLoc, cs,
                                "CurrentDevicePowerState");
    switch (dps) {
    case PowerDeviceUnspecified:
        dprintf("PowerDeviceUnspecified\n");
        break;
    case PowerDeviceD0:
        dprintf("PowerDeviceD0\n");
        break;
    case PowerDeviceD1:
        dprintf("PowerDeviceD1\n");
        break;
    case PowerDeviceD2:
        dprintf("PowerDeviceD2\n");
        break;
    case PowerDeviceD3:
        dprintf("PowerDeviceD3\n");
        break;
    default:
        dprintf("???\n");
    }

    dprintf ("Power Capabilities\n");
    DumpPowerCaps(ExtMemLoc + UsbFieldOffset(cs, "DeviceCapabilities"));

    dprintf("----------------\n");

//    dprintf("SymbolicLinkName:\n");
//    DumpUnicodeString(devExt.SymbolicLinkName);
    if (sig == USBPORT_DEVICE_EXT_SIG) {
        ExtMemLoc = ExtMemLoc + UsbFieldOffset(cs, "Fdo");
        DumpPortFdoDevExt(ExtMemLoc);
    }

    if (sig == ROOTHUB_DEVICE_EXT_SIG) {
        ExtMemLoc = ExtMemLoc + UsbFieldOffset(cs, "Pdo");
        DumpPortPdoDevExt(ExtMemLoc);
    }

}


VOID
DumpMiniportList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC mpMemLoc;
    ULONG i=0;
    UCHAR cs[] = "_USBPORT_MINIPORT_DRIVER";

    dprintf ("*USBPORT DRIVER LIST: ");
    PrintfMemLoc("", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    PrintfMemLoc("blink: ", blink, "\n");
    PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc && i < 5) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        mpMemLoc = flink - UsbFieldOffset("_USBPORT_MINIPORT_DRIVER",
            "ListEntry");

        dprintf ("[%d] MiniportDriver: ", i);
        PrintfMemLoc("", mpMemLoc, "\n");
        i++;

        PrintfMemLoc("\tDriverObject: ",
            UsbReadFieldPtr(mpMemLoc, cs, "DriverObject"),
            "\n");
        PrintfMemLoc("\tMiniportUnload: ",
            UsbReadFieldPtr(mpMemLoc, cs, "MiniportUnload"),
            "\n");

        flink = UsbReadFieldPtr(mpMemLoc, cs, "ListEntry.Flink");


    }
}


VOID
DumpIrps(
    MEMLOC ExtMemLoc
    )
{
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    UCHAR is[] = "_USBPORT_IRP_TABLE";
    MEMLOC nxt, tbl;
    ULONG i;
    UCHAR s[64];

    PrintfMemLoc("*USBPORT DEVICE_EXTENSION ", ExtMemLoc, "\n");

    tbl = UsbReadFieldPtr(ExtMemLoc, cs, "PendingTransferIrpTable");

    PrintfMemLoc("Pending TABLE @", tbl, "\n");
    nxt = UsbReadFieldPtr(tbl, is, "NextTable"),
    PrintfMemLoc("NextTable: ", nxt, "\n");
    for (i= 0; i<IRP_TABLE_LENGTH; i++) {
        MEMLOC irp;
        sprintf(s, "Irps[%d]", i);
        irp = UsbReadFieldPtr(tbl, is, s);
        if (irp != 0) {
            PrintfMemLoc("irp: ",
                         irp,
                         "\n");
        }
    }

    tbl = UsbReadFieldPtr(ExtMemLoc, cs, "ActiveTransferIrpTable");

    PrintfMemLoc("Active TABLE @", tbl, "\n");
    nxt = UsbReadFieldPtr(tbl, is, "NextTable"),
    PrintfMemLoc("NextTable: ", nxt, "\n");
    for (i= 0; i<IRP_TABLE_LENGTH; i++) {
        MEMLOC irp;
        sprintf(s, "Irps[%d]", i);
        irp = UsbReadFieldPtr(tbl, is, s);
        if (irp != 0) {
            PrintfMemLoc("irp: ",
                         irp,
                         "\n");
        }
    }
}


DECLARE_API( _ext )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;

    CHECKSYM();

    addr = GetExpression( args );

    DumpPortDevExt (addr);

    return S_OK;
}


DECLARE_API( _usbirps )

/*++

Routine Description:

   dumps the irps from our active and pending
   tables

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;

    CHECKSYM();

    addr = GetExpression( args );

    DumpIrps (addr);

    return S_OK;
}


DECLARE_API( _help )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{

    // usbport extensions
    dprintf("usbport extensions\n");
    dprintf("!_ext [addr] - addr = DEVICE_EXTENSION fdo | pdo\n");
    dprintf("!_pow [addr] - addr = fdo DEVICE_EXTENSION\n");

    dprintf("!_list [n], [type]\n");

    dprintf("!_devh [addr]\n");
    dprintf("!_log [addr], [count] - addr = DEVICE_EXTENSION\n");
    dprintf("                        count = entries to dump \n");

    dprintf("!_urb [addr]\n");
    dprintf("!_endp [addr]\n");
    dprintf("!_cmbf [addr]\n");
    dprintf("!_tfer [addr] - dumps HCD_TRANSFER_CONTEXT for usbport\n");
    dprintf("!_iso [addr] - dumps MINIPORT_ISO_TRANSFER for usbport\n");
    dprintf("---\n");

    // usbohci miniport extensions
    dprintf("usbohci miniport extensions \n");
    dprintf("!_ohcidd [addr] - addr = DEVICE_DATA\n");
    dprintf("!_ohcitd [addr] - addr = HCD_TRANSFER_DESCRIPTOR\n");
    dprintf("!_ohcied [addr] - addr = HCD_ENDPOINT_DESCRIPTOR\n");
    dprintf("!_ohciep [addr] - addr = ENDPOINT_DATA\n");
    dprintf("!_ohcitfer [addr] - addr = TRANSFER_CONTEXT\n");
    dprintf("!_ohciregs [addr] - addr = OHCI Opertation Registers\n");
    dprintf("---\n");

    // usbehci miniport extensions
    dprintf("usbehci miniport extensions \n");
    dprintf("!_ehcidd [addr] - addr = DEVICE_DATA\n");
    dprintf("!_ehciitd [addr] - addr = HCD_HSISO_TRANSFER_DESCRIPTOR (TD)\n");
    dprintf("!_ehcitd [addr] - addr = HCD_TRANSFER_DESCRIPTOR (ITD)\n");
    dprintf("!_ehcsitd [addr] - addr = HCD_SI_TRANSFER_DESCRIPTOR (SITD)\n");
    dprintf("!_ehciqh [addr] - addr = HCD_QUEUEHEAD_DESCRIPTOR\n");
    dprintf("!_ehcistq [addr] - addr = <static> HCD_QUEUEHEAD_DESCRIPTOR\n");
    dprintf("!_ehciep [addr] - addr = ENDPOINT_DATA\n");
    dprintf("!_ehcitfer [addr] - addr = TRANSFER_CONTEXT\n");
    dprintf("!_ehciregs [addr] - addr = OperationalRegisters\n");
    dprintf("!_ehciframe [addr], [n] - addr = FrameListBaseAddress \n");
    dprintf("---\n");

    dprintf("!_help - displays this screen\n");

    return S_OK;
}


DECLARE_API( _pow )

/*++

Routine Description:

   dumps a summary of the power info

   pow fdo_ext

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;

    CHECKSYM();

    addr = GetExpression( args );

    DumpFdoPower (addr);

    return S_OK;

}


DECLARE_API( _usbport )

/*++

Routine Description:

   dumps the extension

Arguments:

    args -

Return Value:

    None

--*/

{
    MEMLOC          addr;

//    memLoc = GetExpression(args);

    // fetch the list head
    addr = GetExpression( "usbport!USBPORT_MiniportDriverList" );

    if (addr == 0) {
       dprintf("Error retrieving address of USBPORT_MiniportDriverList\n");
       return E_INVALIDARG;
    }

    DumpMiniportList(addr);

    return S_OK;
}


DECLARE_API( _spin )

/*++

Routine Description:

   dumps the extension

Arguments:

    args -

Return Value:

    None

--*/

{
    MEMLOC          addr;

    CHECKSYM();

    addr = GetExpression( args );

    DumpFdoSpin (addr);

    return S_OK;
}


DECLARE_API( _bw )

/*++

Routine Description:

   dumps the extension

Arguments:

    args -

Return Value:

    None

--*/

{
    MEMLOC          addr;

    CHECKSYM();

    addr = GetExpression( args );

    DumpBandwidth (addr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\extflags.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    extflags.h

Abstract:

    This header file (re)defines various flags used by extensions. These definitions
    are copied from different header files as stated.

--*/

#ifndef _EXTFLAGS_
#define _EXTFLAGS_


#if 0
///////////////////////////////////////////////////////////////////////////////
//
// apic.inc
//
///////////////////////////////////////////////////////////////////////////////

//
//  Default Physical addresses of the APICs in a PC+MP system
//

#define IO_BASE_ADDRESS 0xFEC00000  // Default address of
                                    // 1st IO Apic
#define LU_BASE_ADDRESS 0xFEE00000  // Default address
                                    // of Local Apic

#define IO_REGISTER_SELECT      0x00000000 //
#define IO_REGISTER_WINDOW      0x00000010 //

#define IO_ID_REGISTER          0x00000000
#define IO_VERS_REGISTER        0x00000001
#define IO_ARB_ID_REGISTER      0x00000002
#define IO_REDIR_00_LOW         0x00000010
#define IO_REDIR_00_HIGH        0x00000011

#define IO_MAX_REDIR_MASK       0x00FF0000
#define IO_VERSION_MASK         0x000000FF

#define LU_ID_REGISTER          0x00000020 //
#define LU_VERS_REGISTER        0x00000030 //
#define LU_TPR                  0x00000080 //
#define LU_APR                  0x00000090 //
#define LU_PPR                  0x000000A0 //
#define LU_EOI                  0x0000