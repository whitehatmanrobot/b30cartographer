XCLUSIVE( dwIfBucket );

	    if ( FindIfEntry(
	            IF_BUCKET_HEAD( dwIfBucket ), dwInIfIndex,
	            dwInIfNextHopAddr, &pie
	            ) )
	    {
	        if ( FindRefEntry(
	                &pie-> leInIfList, prre-> dwSourceAddr, prre-> dwSourceMask,
	                prre-> dwGroupAddr, prre-> dwGroupMask, &pire
	                ) )
	        {
	            RemoveEntryList( &pire-> leRefList );

	            MGM_FREE( pire );
	        }

	        else
	        {
	            TRACE2(
	                ANY, "Could not find ref entry for %x, %x",
	                prre-> dwSourceAddr, prre-> dwGroupAddr
	                );
	        }
	    }

	    else
	    {
	        TRACE2(
	            ANY, "Could not find i/f entry for %x, %x",
	            dwInIfIndex, dwInIfNextHopAddr
	            );
	    }
	
	    RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );

	    MGM_FREE( prre );
	}
}


HANDLE
SelectNextHop(
    PRTM_DEST_INFO      prdi
)
{
    DWORD               dwErr, dwSize;

    HANDLE              hNextHop;

    PRTM_ROUTE_INFO     prri;


    //
    // Allocate route info structure
    //

    dwSize = sizeof ( RTM_ROUTE_INFO ) +
             ( g_rrpRtmProfile.MaxNextHopsInRoute - 1 ) *
             sizeof( RTM_NEXTHOP_HANDLE );

    prri = MGM_ALLOC( dwSize );

    if ( prri == NULL )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

        TRACE1( ANY, "Failed to allocate route info, size : %x", dwSize );

        return NULL;
    }

    ZeroMemory( prri, dwSize );


    //
    // get route info
    //

    dwErr = RtmGetRouteInfo(
                g_hRtmHandle, prdi-> ViewInfo[ 0 ].Route,
                prri, NULL
                );

    if ( dwErr != NO_ERROR )
    {
        TRACE1( ANY, "Failed to get route info : %x", dwErr );

        MGM_FREE( prri );

        return NULL;
    }


    //
    // Pick the first next hop for now
    //

    hNextHop = prri-> NextHopsList.NextHops[0];


    //
    // Release the route info
    //

    dwErr = RtmReleaseRouteInfo( g_hRtmHandle, prri );

    if ( dwErr != NO_ERROR )
    {
        TRACE1( ANY, "Failed to release route info : %x", dwErr );
    }

    MGM_FREE( prri );

    return hNextHop;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\route.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: route.h
//
// History:
//      V Raman	2-5-1997  Created.
//
// Declarations for routines that manipulate routes entries
//============================================================================


#ifndef _ROUTE_H_
#define _ROUTE_H_


DWORD
WINAPI 
RtmChangeNotificationCallback(
    RTM_ENTITY_HANDLE           hRtmHandle,
    RTM_EVENT_TYPE              retEventType,
    PVOID                       pvContext1,
    PVOID                       pvContext2
);

VOID
WorkerFunctionProcessRtmChangeNotification(
    PVOID                       pvContext
);

DWORD
ProcessUnMarkedDestination(
    PRTM_DEST_INFO          prdi
);

DWORD
ProcessRouteDelete(
    PRTM_DEST_INFO          prdi
);

DWORD
ProcessRouteUpdate(
    PRTM_DEST_INFO          prdi
);

VOID
DeleteMfeAndRefs(
    PLIST_ENTRY     ple
);

HANDLE
SelectNextHop(
    PRTM_DEST_INFO      prdi
);



//----------------------------------------------------------------------------
//
// Route reference operations
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// MFE_REFERENCE_ENTRY
//
// Each route maintains a list of MFE entries that use this route for 
// their RPF check.  Each entry in this reference list stores the
// source, group info.
//
// Fields descriptions are left as an exercise to the reader.
//
//----------------------------------------------------------------------------

typedef struct _ROUTE_REFERENCE_ENTRY
{
    LIST_ENTRY                  leRefList;

    DWORD                       dwGroupAddr;

    DWORD                       dwGroupMask;

    DWORD                       dwSourceAddr;

    DWORD                       dwSourceMask;

    HANDLE                      hNextHop;

} ROUTE_REFERENCE_ENTRY, *PROUTE_REFERENCE_ENTRY;



VOID
AddSourceGroupToRouteRefList(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    HANDLE                      hNextHop,
    PBYTE                       pbBuffer
);



BOOL
FindRouteRefEntry(
    PLIST_ENTRY                 pleRefList,
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    PROUTE_REFERENCE_ENTRY *    pprre
);



VOID
DeleteRouteRef(
    PROUTE_REFERENCE_ENTRY      prre
);

//
// imported from packet.c
//

BOOL
IsMFEPresent(
    DWORD                       dwSourceAddr,
    DWORD                       dwSourceMask,
    DWORD                       dwGroupAddr,
    DWORD                       dwGroupMask,
    BOOL                        bAddToForwarder
);

#endif // _ROUTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\scope.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: scope.h
//
// History:
//      V Raman    June-25-1997  Created.
//
// Prototypes for functions that implement the admin-scoped boundaries 
//============================================================================


#ifndef _SCOPE_H_
#define _SCOPE_H_


DWORD
APIENTRY
MgmBlockGroups(
    IN          DWORD       dwFirstGroup,
    IN          DWORD       dwLastGroup,
    IN          DWORD       dwIfIndex,
    IN          DWORD       dwIfNextHopAddr
);



DWORD
APIENTRY
MgmUnBlockGroups(
    IN          DWORD       dwFirstGroup,
    IN          DWORD       dwLastGroup,
    IN          DWORD       dwIfIndex,
    IN          DWORD       dwIfNextHopAddr
);


//
// Routines that invoke the NEW and DELETE member callbacks for
// protocols as per the interop rules
//

VOID
InvokePruneAlertCallbacks(
    PGROUP_ENTRY        pge,
    PSOURCE_ENTRY       pse,
    DWORD               dwIfIndex,
    DWORD               dwIfNextHopAddr,
    PPROTOCOL_ENTRY     ppe
);

VOID
InvokeJoinAlertCallbacks(
    PGROUP_ENTRY        pge,
    PSOURCE_ENTRY       pse,
    POUT_IF_ENTRY       poie,
    BOOL                bIGMP,
    PPROTOCOL_ENTRY     ppe
);




//
// Node in the Outstanding Join List
//

typedef struct _JOIN_ENTRY
{
    LIST_ENTRY  leJoinList;
    
    DWORD       dwSourceAddr;

    DWORD       dwSourceMask;

    DWORD       dwGroupAddr;

    DWORD       dwGroupMask;

    DWORD       dwIfIndex;

    DWORD       dwIfNextHopAddr;

    BOOL        bJoin;
    
} JOIN_ENTRY, *PJOIN_ENTRY;



//
// Functions to manipulate the join list
//

DWORD
AddToOutstandingJoinList(
    DWORD       dwSourceAddr,
    DWORD       dwSourceMask,
    DWORD       dwGroupAddr,
    DWORD       dwGroupMask,
    DWORD       dwIfIndex,
    DWORD       dwIfNextHopAddr,
    BOOL        bJoin
);

VOID
InvokeOutstandingCallbacks(
);



 //
 // Functions to manipulate the check for creation alert list
 //

VOID
AddToCheckForCreationAlertList(
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwInIfIndex,
    DWORD           dwInIfNextHopAddr,
    PLIST_ENTRY     pleForwardList
);


VOID
FreeList(
    PLIST_ENTRY     pleForwardList
);


BOOL
IsForwardingEnabled(
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    PLIST_ENTRY     pleSourceList
);


DWORD
InvokeCreationAlertForList( 
    PLIST_ENTRY     pleForwardList,
    DWORD           dwProtocolId,
    DWORD           dwComponentId,
    DWORD           dwIfIndex,
    DWORD           dwIfNextHopAddr
);


//
// Context passed to worker function WorkerFunctionInvokeCreationAlert
//

typedef struct _CREATION_ALERT_CONTEXT {

    //
    // Source(s) for the group that was joined
    //
    
    DWORD           dwSourceAddr;

    DWORD           dwSourceMask;

    //
    // Group(s) that were joined
    //

    DWORD           dwGroupAddr;

    DWORD           dwGroupMask;

    //
    // Interface on which joined.  This is the interface
    // for which creation alerts have to issued
    //

    DWORD           dwIfIndex;

    DWORD           dwIfNextHopAddr;


    //
    // Protocol that performed the join
    //

    DWORD           dwProtocolId;

    DWORD           dwComponentId;

    BOOL            bIGMP;


    //
    // for (*, G) entries, list of MFE(s) for G to be
    // updated
    //

    LIST_ENTRY      leSourceList;
    
} CREATION_ALERT_CONTEXT, *PCREATION_ALERT_CONTEXT;


//
// worker function required for invoking creation alert
// to protocols from a worker thread
//

VOID
WorkerFunctionInvokeCreationAlert(
    PVOID           pvContext
);

#endif // _SCOPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\sync.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: sync.c
//
// History:
//      V Raman	July-11-1997  Created.
//
// Basic locking operations. Borrowed from RIP implementation by abolade
//============================================================================


#include "pchmgm.h"
#pragma hdrstop


//----------------------------------------------------------------------------
// Function:    QueueMgmWorker  
//
// This function is called to queue a MGM function in a safe fashion;
// if cleanup is in progress or if MGM has stopped, this function
// discards the work-item.
//----------------------------------------------------------------------------

DWORD
QueueMgmWorker(
    WORKERFUNCTION pFunction,
    PVOID pContext
    ) {

    DWORD dwErr;

    ENTER_GLOBAL_SECTION();
    
    if (ig.imscStatus != IPMGM_STATUS_RUNNING) {

        //
        // cannot queue a work function when MGM has quit or is quitting
        //

        dwErr = ERROR_CAN_NOT_COMPLETE;
    }
    else {

        ++ig.lActivityCount;

        dwErr = RtlQueueWorkItem(pFunction, pContext, 0);

        if (dwErr != STATUS_SUCCESS) { --ig.lActivityCount; }
    }

    LEAVE_GLOBAL_SECTION();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    EnterMgmAPI
//
// This function is called to when entering a MGM api, as well as
// when entering the input thread and timer thread.
// It checks to see if MGM has stopped, and if so it quits; otherwise
// it increments the count of active threads.
//----------------------------------------------------------------------------

BOOL
EnterMgmAPI(
    ) {

    BOOL bEntered;

    ENTER_GLOBAL_SECTION();

    if (ig.imscStatus == IPMGM_STATUS_RUNNING) {

        //
        // MGM is running, so the API may continue
        //

        ++ig.lActivityCount;

        bEntered = TRUE;
    }
    else {

        //
        // MGM is not running, so the API exits quietly
        //

        bEntered = FALSE;
    }

    LEAVE_GLOBAL_SECTION();

    return bEntered;
}




//----------------------------------------------------------------------------
// Function:    EnterMgmWorker
//
// This function is called when entering a MGM worker-function.
// Since there is a lapse between the time a worker-function is queued
// and the time the function is actually invoked by a worker thread,
// this function must check to see if MGM has stopped or is stopping;
// if this is the case, then it decrements the activity count, 
// releases the activity semaphore, and quits.
//----------------------------------------------------------------------------

BOOL
EnterMgmWorker(
    ) {

    BOOL bEntered;

    ENTER_GLOBAL_SECTION();

    if (ig.imscStatus == IPMGM_STATUS_RUNNING) {

        //
        // MGM is running, so the function may continue
        //

        bEntered = TRUE;
    }
    else
    if (ig.imscStatus == IPMGM_STATUS_STOPPING) {

        //
        // MGM is not running, but it was, so the function must stop.
        // 

        --ig.lActivityCount;

        ReleaseSemaphore(ig.hActivitySemaphore, 1, NULL);

        bEntered = FALSE;
    }
    else {

        //
        // MGM probably never started. quit quietly
        //

        bEntered = FALSE;
    }

    LEAVE_GLOBAL_SECTION();

    return bEntered;
}




//----------------------------------------------------------------------------
// Function:    LeaveMgmWorker
//
// This function is called when leaving a MGM API or worker function.
// It decrements the activity count, and if it detects that MGM has stopped
// or is stopping, it releases the activity semaphore.
//----------------------------------------------------------------------------

VOID
LeaveMgmWorker(
    ) {

    ENTER_GLOBAL_SECTION();

    --ig.lActivityCount;

    if (ig.imscStatus == IPMGM_STATUS_STOPPING) {

        ReleaseSemaphore(ig.hActivitySemaphore, 1, NULL);
    }

    LEAVE_GLOBAL_SECTION();

}




//----------------------------------------------------------------------------
// CreateReadWriteLock
//
// This function is called to create and initialize a new read-write lock
// structure.  It is invoked by AcquireXLock ( X = { Read | Write } )
//----------------------------------------------------------------------------

DWORD
CreateReadWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
    )
{

    DWORD                   dwErr;
    PMGM_READ_WRITE_LOCK    pmrwl;
    

    TRACELOCK1( "ENTERED CreateReadWriteLock : %x", ppmrwl );

    do
    {
        *ppmrwl = NULL;
        
    
        //
        // Allocate a lock structure
        //

        pmrwl = MGM_ALLOC( sizeof( MGM_READ_WRITE_LOCK ) );

        if ( pmrwl == NULL ) 
        {
            dwErr = GetLastError();

            TRACE1( 
                ANY, "CreateReadWriteLock failed to allocate lock : %x", dwErr
                );

            break;                
        }


        //
        // Init. critcal section
        //

        try
        {
            InitializeCriticalSection( &pmrwl-> csReaderWriterBlock );
        }
        except ( EXCEPTION_EXECUTE_HANDLER )
        {
            dwErr = GetLastError();

            MGM_FREE( pmrwl );

            TRACE1( 
                ANY, 
                "CreateReadWriteLock failed to initialize critical section : %x",
                dwErr
                );

            break;
        }

        
        //
        // create reader done event.
        //
        
        pmrwl-> hReaderDoneEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

        if ( pmrwl-> hReaderDoneEvent == NULL )
        {
            dwErr = GetLastError();
        
            MGM_FREE( pmrwl );
            
            TRACE1( 
                ANY, 
                "CreateReadWriteLock failed to create event : %x",
                dwErr
                );

            break;                
        }


        //
        // initialize count fields
        //
        
        pmrwl-> lUseCount = 0;

        pmrwl-> lReaderCount = 0;


        pmrwl-> sleLockList.Next = NULL;

        *ppmrwl = pmrwl;

        dwErr = NO_ERROR;
        
    } while ( FALSE );


    TRACELOCK1( "LEAVING CreateReadWriteLock : %x", dwErr );

    return dwErr;
}


//----------------------------------------------------------------------------
// DeleteReadWriteLock
//
// This functions destroys a read-write lock.  It is invoked when MGM is
// being stopped.  During normal operation when a read-write lock is no longer
// required it pushed onto a global stack of locks for reuse as needed.
//----------------------------------------------------------------------------

VOID
DeleteReadWriteLock(
    IN      PMGM_READ_WRITE_LOCK    pmrwl
    )
{
    DeleteCriticalSection( &pmrwl-> csReaderWriterBlock ); 

    CloseHandle( pmrwl-> hReaderDoneEvent );

    MGM_FREE( pmrwl );
}



//----------------------------------------------------------------------------
// DeleteLockList
//
// This function deletes the entire list of locks present in the stack of
// read write locks.  Assumes stack of locks is locked.
//----------------------------------------------------------------------------

VOID
DeleteLockList(
)
{
    PSINGLE_LIST_ENTRY      psle = NULL;

    PMGM_READ_WRITE_LOCK    pmrwl = NULL;
    

    TRACELOCK0( "ENTERED DeleteLockList"  );

    ENTER_GLOBAL_LOCK_LIST_SECTION();
    

    psle = PopEntryList( &ig.llStackOfLocks.sleHead );

    while ( psle != NULL )
    {
        pmrwl = CONTAINING_RECORD( psle, MGM_READ_WRITE_LOCK, sleLockList );

        DeleteReadWriteLock( pmrwl );
        
        psle = PopEntryList( &ig.llStackOfLocks.sleHead );
    }

    LEAVE_GLOBAL_LOCK_LIST_SECTION();

    TRACELOCK0( "LEAVING DeleteLockList");
}



//----------------------------------------------------------------------------
// AcquireReadLock
//
// This function provides read access to a protected resource.  If needed 
// it will reuse a lock from the stack of locks if available or allocate a 
// new read-write lock.
//----------------------------------------------------------------------------

DWORD
AcquireReadLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
    )
{
    DWORD                           dwErr = NO_ERROR;
    
    PSINGLE_LIST_ENTRY              psle = NULL;
    


    //
    // determine if a lock needs to be allocated first.  
    // Perform this check with in a critical section so
    // that two locks are not concurrently 
    // assigned to a single resource.  
    //

    ENTER_GLOBAL_LOCK_LIST_SECTION();

    if ( *ppmrwl == NULL )
    {
        //
        // get a lock from the stack of locks
        //

        psle = PopEntryList( &ig.llStackOfLocks.sleHead );

        if ( psle != NULL )
        {
            *ppmrwl = CONTAINING_RECORD( 
                        psle, MGM_READ_WRITE_LOCK, sleLockList 
                        );
        }

        else
        {
            //
            // Stack of locks was empty. Create a new lock
            // 

            dwErr = CreateReadWriteLock( ppmrwl );

            if ( dwErr != NO_ERROR )
            {
                //
                // failed to create a lock.  Possibly ran out of resources
                //
                
                LEAVE_GLOBAL_LOCK_LIST_SECTION();
                
                TRACE2( 
                    ANY, "LEAVING AcquireReadLock, lock %x, error %x",
                    ppmrwl, dwErr
                    );
                    
                return dwErr;
            }
        }
    }

    
    //
    // *ppmrwl points to a valid lock structure.
    //

    InterlockedIncrement( &( (*ppmrwl)-> lUseCount ) );

    TRACECOUNT1( "AcquireReadLock, Users %d", (*ppmrwl)-> lUseCount );

    LEAVE_GLOBAL_LOCK_LIST_SECTION();


    //
    // Increment reader count
    //
    
    EnterCriticalSection( &( (*ppmrwl)-> csReaderWriterBlock ) );

    InterlockedIncrement( &( (*ppmrwl)-> lReaderCount ) );

    TRACECOUNT1( "Readers %d", (*ppmrwl)-> lReaderCount );
        
    LeaveCriticalSection( &( (*ppmrwl)-> csReaderWriterBlock ) );

    
    return NO_ERROR;
}



//----------------------------------------------------------------------------
// ReleaseReadLock
//
// This function is invoked to release read access to a protected resource.
// If there are no more reader/writers waiting on this lock, the read-write
// lock is released to the global stack of locks for later reuse.
//----------------------------------------------------------------------------

VOID
ReleaseReadLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
    )
{
    //
    // Decrement reader count, and signal any waiting writer
    //

    if ( InterlockedDecrement( &( (*ppmrwl)-> lReaderCount ) ) < 0 )
    {
        SetEvent( (*ppmrwl)-> hReaderDoneEvent );
    }


    //
    // determine if the lock is being used. If not the lock should be
    // released to the stack of locks.
    //

    ENTER_GLOBAL_LOCK_LIST_SECTION();


    if ( InterlockedDecrement( &( (*ppmrwl)-> lUseCount ) ) == 0 )
    {
        PushEntryList( &ig.llStackOfLocks.sleHead, &( (*ppmrwl)-> sleLockList ) );
        *ppmrwl = NULL;

        TRACECOUNT0( "ReleaseReadLock no more users" );
    }

    else
    {
        TRACECOUNT2(
            "ReleaseReadLock, Readers %x, users %x",
            (*ppmrwl)-> lReaderCount, (*ppmrwl)-> lUseCount
            );
    }
    
    LEAVE_GLOBAL_LOCK_LIST_SECTION();
}



//----------------------------------------------------------------------------
// AcquireWriteLock
//
// This function provides write access to a protected resource.  If needed 
// it will reuse a lock from the stack of locks if available or allocate a 
// new read-write lock.
//----------------------------------------------------------------------------

DWORD
AcquireWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
    )
{
    DWORD                           dwErr = NO_ERROR;
    
    PSINGLE_LIST_ENTRY              psle = NULL;
    
    //
    // determine is the you need to allocate a lock first.  If needed
    // do so under mutual exclusive so that two locks are not
    // concurrently assigned for the same resources.
    //

    ENTER_GLOBAL_LOCK_LIST_SECTION();

    if ( *ppmrwl == NULL )
    {
        //
        // get a lock from the stack of locks
        //

        psle = PopEntryList( &ig.llStackOfLocks.sleHead );

        if ( psle != NULL )
        {
            *ppmrwl = CONTAINING_RECORD( 
                        psle, 
                        MGM_READ_WRITE_LOCK, 
                        sleLockList 
                        );
        }

        else
        {
            //
            // Stack of locks was empty. Create a new lock
            // 

            dwErr = CreateReadWriteLock( ppmrwl );

            if ( dwErr != NO_ERROR )
            {
                LEAVE_GLOBAL_LOCK_LIST_SECTION();
                return dwErr;
            }
        }
    }

    
    //
    // *ppmrwl points to a valid lock structure.
    //

    InterlockedIncrement( &( (*ppmrwl)-> lUseCount ) );

    TRACECOUNT1( "AcquireWriteLock, Users %d", (*ppmrwl)-> lUseCount );
    
    LEAVE_GLOBAL_LOCK_LIST_SECTION();


    //
    // acquire write lock.
    //

    EnterCriticalSection( &( (*ppmrwl)-> csReaderWriterBlock ) );

    if ( InterlockedDecrement( &( (*ppmrwl)-> lReaderCount ) ) >= 0 )
    {
        //
        // other readers present.  Wait for them to finish
        //

        TRACECOUNT1( "AcquireWriteLock, Readers %d", (*ppmrwl)-> lReaderCount );
       
        WaitForSingleObject( (*ppmrwl)-> hReaderDoneEvent, INFINITE );
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// ReleaseWriteLock
//
// This function is invoked to release write access to a protected resource.
// If there are no more reader/writers waiting on this lock, the read-write
// lock is released to the global stack of locks for later reuse.
//----------------------------------------------------------------------------

VOID
ReleaseWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
    )
{
    //
    // release the write lock
    //
    
    (*ppmrwl)-> lReaderCount = 0;

    LeaveCriticalSection( &( (*ppmrwl)-> csReaderWriterBlock ) );


    //
    // determine if the lock is being used by anyone else.
    // if not we need to release the lock back to the stack.
    //

    ENTER_GLOBAL_LOCK_LIST_SECTION();

    if ( InterlockedDecrement( &( (*ppmrwl)-> lUseCount ) ) == 0 )
    {
        PushEntryList( &ig.llStackOfLocks.sleHead, &( (*ppmrwl)-> sleLockList ) );
        *ppmrwl = NULL;
        TRACECOUNT0( "ReleaseWriteLock no more users" );
    }

    else
    {
        TRACECOUNT2(
            "ReleaseWriteLock, Readers %x, users %x",
            (*ppmrwl)-> lReaderCount, (*ppmrwl)-> lUseCount
            );
    }
    
    
    LEAVE_GLOBAL_LOCK_LIST_SECTION();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\scope.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: scope.c
//
// History:
//      V Raman    June-25-1997  Created.
//
// Functions that deal with addition/deletion of scope-boundary.
//============================================================================


#include "pchmgm.h"
#pragma hdrstop


//
// prototypes for local functions
//

VOID
ScopeIfAndInvokeCallbacks(
    PGROUP_ENTRY        pge,
    PSOURCE_ENTRY       pse,
    POUT_IF_ENTRY       poie
);


VOID
UnScopeIfAndInvokeCallbacks(
    PGROUP_ENTRY    pge,
    PSOURCE_ENTRY   pse,
    POUT_IF_ENTRY   poie
);


PJOIN_ENTRY
GetNextJoinEntry(
);

BOOL
FindJoinEntry(
    PLIST_ENTRY     pleJoinList,
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwIfIndex,
    DWORD           dwIfNextHopAddr,
    PJOIN_ENTRY *   ppje
);


DWORD
APIENTRY
MgmBlockGroups(
    IN          DWORD       dwFirstGroup,
    IN          DWORD       dwLastGroup,
    IN          DWORD       dwIfIndex,
    IN          DWORD       dwIfNextHopAddr
)
/*++

Routine Description :

    This function walks the Master group list and updates all group entries
    that fall in the range specified by dwFirstGroup-dwLastGroup.  It ensures
    that the interface specified by dwifIndex is not present in the OIF list
    of any MFE for groups in that range.  In addition any memberships for 
    groups in the range on interface dwIfIndex are removed and added to the 
    scoped interface list for the corresponding group.  The scoped i/f list
    is maintained so that subsequent unblocking of a group is transparently
    handled by MGM.  The interfaces present in the scoped i/f list for
    a group are automatically moved back to the OIF list when traffic for
    that group is unblocked.


Arguements :

    dwFirstGroup - Lower end of the range to be blocked

    dwLastGroup - Upper end of the range to be blocked

    dwIfIndex - Interface on which traffic is to be blocked


Return Value :

    NO_ERROR - Success

    
Environment :

    This routine is invoked by the IP RouterManager in response to setting
    of a administrative scoped boundary on an interface.
    
--*/
{

    INT             iCmp;
    
    DWORD           dwIfBucket, dwTimeOut = 0;

    BOOL            bFound, bDeleteCallback, bNewComp = FALSE;

    PIF_ENTRY       pieIfEntry;

    PPROTOCOL_ENTRY ppe;
    
    PGROUP_ENTRY    pge;

    PSOURCE_ENTRY   pse;

    POUT_IF_ENTRY   poie, poieTemp;

    PLIST_ENTRY     pleGrpHead, pleGrp, pleSrcHead, pleSrc, ple;

    
    //
    // Verify that MGM is up and running and update thread-count
    //
    
    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }


    TRACE3( 
        SCOPE, "ENTERED MgmBlockGroups (%lx - %lx) on %lx",
        dwFirstGroup, dwLastGroup, dwIfIndex
        );

        
    do
    {
        ACQUIRE_PROTOCOL_LOCK_SHARED();


        //
        // Verify that interface specified by dwIfIndex exists
        //

        dwIfBucket = IF_TABLE_HASH( dwIfIndex );
        
        ACQUIRE_IF_LOCK_SHARED( dwIfBucket );

        pieIfEntry = GetIfEntry( 
                        IF_BUCKET_HEAD( dwIfBucket ), dwIfIndex, 
                        dwIfNextHopAddr
                        );

        if ( pieIfEntry == NULL )
        {
            TRACE1( SCOPE, "Interface %lx not found", dwIfIndex );

            break;
        }


        //
        // merge temp and master group lists
        //

        ACQUIRE_TEMP_GROUP_LOCK_EXCLUSIVE();

        MergeTempAndMasterGroupLists( TEMP_GROUP_LIST_HEAD() );
        
        RELEASE_TEMP_GROUP_LOCK_EXCLUSIVE();

        
        //
        // Lock master group list for reading
        //

        ACQUIRE_MASTER_GROUP_LOCK_SHARED();

        for ( pleGrpHead = MASTER_GROUP_LIST_HEAD(), 
              pleGrp = pleGrpHead-> Flink;
              pleGrp != pleGrpHead;
              pleGrp = pleGrp-> Flink )
        {
            pge = CONTAINING_RECORD( pleGrp, GROUP_ENTRY, leGrpList );


            //
            // check if group is within range
            //

            if ( INET_CMP( pge-> dwGroupAddr, dwLastGroup, iCmp ) > 0 )
            {
                //
                // The master group list is ordered by group number and 
                // the high end of the range to be blocked has been crossed.
                //

                break;            
            }

            else if ( INET_CMP( pge-> dwGroupAddr, dwFirstGroup, iCmp ) < 0 )
            {
                //
                // Skip group entries smaller than the lower end of the range
                //

                continue;
            }

            
            //
            // Group Entry in range
            //

            //
            // lock the entry and merge the temp and master source lists
            //
            
            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );

            MergeTempAndMasterSourceLists( pge );
            

            //
            // Walk the Master source list.
            // For each source in the group
            //

            for ( pleSrcHead = MASTER_SOURCE_LIST_HEAD( pge ), 
                  pleSrc = pleSrcHead-> Flink;
                  pleSrc != pleSrcHead;
                  pleSrc = pleSrc-> Flink )
            {
                pse = CONTAINING_RECORD( pleSrc, SOURCE_ENTRY, leSrcList );
                
                //-----------------------------------------------------------
                // Part 1 : Membership updates.
                //-----------------------------------------------------------

                //
                // If there are any memberships for this group on this
                // interface, move them to the scoped interface list
                //

                bFound = FindOutInterfaceEntry( 
                            &pse-> leOutIfList, pieIfEntry-> dwIfIndex,
                            pieIfEntry-> dwIfNextHopAddr, 
                            pieIfEntry-> dwOwningProtocol, 
                            pieIfEntry-> dwOwningComponent, &bNewComp, &poie
                            );

                if ( bFound )
                {
                    //
                    // Move interface entry from OIF list to scoped list
                    // and invoke deletion alerts are per interop rules.
                    //

                    ScopeIfAndInvokeCallbacks( pge, pse, poie );
                    
                }

                
                //-------------------------------------------------------
                // Part 2 : MFE update.
                //-------------------------------------------------------

                bDeleteCallback = FALSE;
                
                //
                // Check if this source entry has an MFE.
                //

                if ( !IS_VALID_INTERFACE( 
                        pse-> dwInIfIndex,  pse-> dwInIfNextHopAddr 
                        ) )
                {
                    //
                    // This source entry is not an MFE.  No further 
                    // processing required, Move to next source entry
                    //

                    continue;
                }

                
                //
                // This source entry is also an MFE
                //
                
                //
                // check if the boundary being added in on incoming
                // interface. If so create negative MFE, and issue 
                // callbacks
                //

                if ( ( pse-> dwInIfIndex == pieIfEntry-> dwIfIndex ) &&
                     ( pse-> dwInIfNextHopAddr == 
                            pieIfEntry-> dwIfNextHopAddr ) )
                {
                    //
                    // Interface on which this group is to blocked is the 
                    // incoming interface
                    //

                    //
                    // Check if this is already a negative MFE.  If so 
                    // nothing more to be done, move on to next source 
                    // entry
                    //

                    if ( IsListEmpty( &pse-> leMfeIfList ) )
                    {
                        continue;
                    }
                    
                    //
                    // Delete all the outgoing interfaces in the MFE OIF
                    // list
                    //
                    
                    while ( !IsListEmpty( &pse-> leMfeIfList ) )
                    {
                        ple = RemoveHeadList( &pse-> leMfeIfList ) ;

                        poieTemp = CONTAINING_RECORD( 
                                    ple, OUT_IF_ENTRY, leIfList
                                    );

                        MGM_FREE( poieTemp );
                    }

                    pse-> dwMfeIfCount = 0;

                    //
                    // this MFE is now a negative MFE.  Make sure to 
                    // invoke the deletion alert callback for the 
                    // protocol component that owns the incoming 
                    // interface
                    //
                    
                    bDeleteCallback = TRUE;                    
                }

                else
                {
                    //
                    // Check if interface is present in the OIF of MFE.  
                    // If so remove interface from OIF and issue 
                    // callbacks as appropriate
                    //

                    bFound = FindOutInterfaceEntry(
                                &pse-> leMfeIfList, pieIfEntry-> dwIfIndex,
                                pieIfEntry-> dwIfNextHopAddr, 
                                pieIfEntry-> dwOwningProtocol, 
                                pieIfEntry-> dwOwningComponent, &bNewComp, 
                                &poie
                                );

                    if ( !bFound )
                    {
                        //
                        // interface not present in the OIF list of MFE
                        // move on to next entry
                        //

                        continue;
                    }

                    //
                    // Delete the outgoing interface
                    //

                    DeleteOutInterfaceEntry( poie );

                    pse-> dwMfeIfCount--;

                    if ( !pse-> dwMfeIfCount )
                    {
                        //
                        // MFE OIF list has no more outgoing interfaces.
                        // Need to issue deletion alert to protocol component
                        // owning incoming interface
                        //

                        bDeleteCallback = TRUE;
                    }
                }


                //
                // If needed issue deletion alert to the protocol on the 
                // incoming interface
                //

                if ( bDeleteCallback )
                {
                    ppe = GetProtocolEntry( 
                            PROTOCOL_LIST_HEAD(), pse-> dwInProtocolId,
                            pse-> dwInComponentId
                            );

                    if ( ppe == NULL )
                    {
                        //
                        // Protocol owning incoming interface is not present
                        // in incoming list.  Very strange and should not happen.
                        // Nothing to be done here, move on to next source.
                        //
                        
                        TRACE3( 
                            SCOPE, 
                            "Protocol (%d, %d) not present for interface %d",
                            pse-> dwInProtocolId, pse-> dwInComponentId, 
                            dwIfIndex
                            );

                        continue;
                    }


                    if ( IS_PRUNE_ALERT( ppe ) )
                    {
                        PRUNE_ALERT( ppe )(
                            pse-> dwSourceAddr, pse-> dwSourceMask,
                            pge-> dwGroupAddr, pge-> dwGroupMask,
                            pse-> dwInIfIndex, pse-> dwInIfNextHopAddr,
                            FALSE, &dwTimeOut
                            );
                    }
                }


                //
                // Update Kernel Mode forwarder
                //

                AddMfeToForwarder( pge, pse, dwTimeOut );
            }
            
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        } 

        RELEASE_MASTER_GROUP_LOCK_SHARED();

    } while ( FALSE );


    RELEASE_IF_LOCK_SHARED( dwIfBucket);


    //
    // Invoke pended Join/Prune alerts
    //

    InvokeOutstandingCallbacks();


    RELEASE_PROTOCOL_LOCK_SHARED();

    LEAVE_MGM_API();

    TRACE3( 
        SCOPE, "LEAVING MgmBlockGroups (%lx - %lx) on %lx\n",
        dwFirstGroup, dwLastGroup, dwIfIndex
        );

    return NO_ERROR;

}




VOID
ScopeIfAndInvokeCallbacks(
    PGROUP_ENTRY        pge,
    PSOURCE_ENTRY       pse,
    POUT_IF_ENTRY       poie
)
/*++

Routine Description :

    This routine remove an interface entry from the outgoing interface
    list for the specified source entry and puts it into the scoped
    interface list.  If the deletion of the interface to the OIF list
    requires deletion alert callbacks to be issued to protocol components
    these are issued by this routine.


Arguements :

    pge - Group entry correspondong to the group being blocked.

    pse - Source entry for the group being blocked

    poie - Interface entry corresponding to the interface over which
           the (source, group) entry is being blocked

Return Value :

    None

Environment :

    Invoked from MgmBlockGroups.  Assumes the protocol list and 
    interface bucket are locked for read, and the group entry is
    locked for write.
    
--*/
{
    BOOL                bFound, bNewComp;
    
    PPROTOCOL_ENTRY     ppe;

    POUT_IF_ENTRY       poieTemp = NULL;

    
    do
    {
        //
        // find the protocol component on the interface specified by poie
        //

        ppe = GetProtocolEntry( 
                PROTOCOL_LIST_HEAD(), poie-> dwProtocolId, 
                poie-> dwComponentId
                );

        if ( ppe == NULL )
        {
            //
            // Outgoing interface entry but corresponding owning
            // protocol is no present. This should not happen.
            // Print a warning indicating bad state and return
            //
            
            TRACE3( 
                SCOPE, "Protocol (%d, %d) not present for interface %d",
                poie-> dwProtocolId, poie-> dwComponentId, 
                poie-> dwIfIndex
                );

            break;
        }

        
        //
        // Remove interface entry from the OIF list
        //

        RemoveEntryList( &poie-> leIfList );


        //
        // Find the locaion in the scoped i/f list and insert it
        //

        bFound = FindOutInterfaceEntry(
                    &pse-> leScopedIfList, poie-> dwIfIndex, 
                    poie-> dwIfNextHopAddr, poie-> dwProtocolId,
                    poie-> dwComponentId, &bNewComp, &poieTemp
                    );

        if ( bFound )
        {
            //
            // Interface being scoped is already present in scoped
            // i/f list.  Strange.  Print warning and quit.
            //

            TRACE4(
                ANY, "Interface (%d, %d) already present in the scoped list"
                " for (%x, %x)", poie-> dwIfIndex, poie-> dwIfNextHopAddr,
                pse-> dwSourceAddr, pge-> dwGroupAddr
                );

            MGM_FREE( poie );

            break;
        }
                    

        InsertTailList( 
            ( poieTemp == NULL ) ? &pse-> leScopedIfList :
                                   &poieTemp-> leIfList,
            &poie-> leIfList
            );


        //
        // If group membership has been added by IGMP and this interface
        // is owned by a  different protocol, inform the protocol that IGMP
        // has just left the interface.  'Hank you, 'hank you very much.
        //

        if ( IS_ADDED_BY_IGMP( poie ) && !IS_PROTOCOL_IGMP( ppe ) )
        {
            if ( IS_LOCAL_LEAVE_ALERT( ppe ) )
            {
                LOCAL_LEAVE_ALERT( ppe )(
                    pse-> dwSourceAddr, pse-> dwSourceMask,
                    pge-> dwGroupAddr, pge-> dwGroupMask,
                    poie-> dwIfIndex, poie-> dwIfNextHopAddr
                    );
            }
        }

        
        //
        // Check if the removal of this interface from the OIF list
        // resulted in decreasing the number of components present 
        // in the OIF list.
        //

        FindOutInterfaceEntry(
            &pse-> leOutIfList, poie-> dwIfIndex, poie-> dwIfNextHopAddr, 
            poie-> dwProtocolId, poie-> dwComponentId, &bNewComp, &poieTemp
            );

        if ( bNewComp )
        {
            pse-> dwOutCompCount--;

            //
            // number of componets in OIF list has decreased.
            // Invoke deletion alerts as per interop rules.
            //
            
            InvokePruneAlertCallbacks( 
                pge, pse, poie-> dwIfIndex, poie-> dwIfNextHopAddr, ppe 
                );
        }
        
    } while ( FALSE );
}





VOID
InvokePruneAlertCallbacks(
    PGROUP_ENTRY        pge,
    PSOURCE_ENTRY       pse,
    DWORD               dwIfIndex,
    DWORD               dwIfNextHopAddr,
    PPROTOCOL_ENTRY     ppe
)
/*++

Routine Description :

    This routine invokes deletion alert callbacks of protocol components
    in response to an interface being removed from the OIF list of a 
    source entry. Deletion alert callbacks are issued as per the 
    interop rules.


Arguements :

    pge - Entry corresponding to group for which deletion alert callbacks
          are being issued.

    pse - Entry corresponding to source for which deletion alert callbacks
          are being issued.

    dwIfIndex - Index of interface that is being deleted (or scoped)

    dwIfNextHopAddr - Next hop on interface that is being deleted (or scoped)
    
    ppe - Protocol entry for the protocol component that owns the interface
          corresponding to poie.


Return Value :

    None


Environment :

    Invoked from ScopeIfAndCanInvokeCallbacks and 
    DeleteInterfaceFromSourceEntry
    
--*/
{
    PPROTOCOL_ENTRY ppeEntry;
    
    POUT_IF_ENTRY poieTemp;

    PLIST_ENTRY pleStart, pleProtocol;
    
    
    //----------------------------------------------------------------
    // Callback time
    //----------------------------------------------------------------
    
    //
    // Check if Source specific join
    //

    if ( !IS_WILDCARD_SOURCE( pse-> dwSourceAddr, pse-> dwSourceMask ) )
    {
        if ( pse-> dwOutCompCount == 0 )
        {

            TRACESCOPE0( GROUP, "Last component in OIL for source specific" );

            AddToOutstandingJoinList(
                pse-> dwSourceAddr, pse-> dwSourceMask,
                pge-> dwGroupAddr, pge-> dwGroupMask,
                dwIfIndex, dwIfNextHopAddr, 
                FALSE
                );
        }
    }

    else if ( pse-> dwOutCompCount == 1 )
    {
        TRACESCOPE0( 
            GROUP, "Number of components in the OIL is down to 1" 
            );


        //
        // Number of protocol components that have interfaces in the OIL
        // has reduced from 2 to 1.
        //
        // invoke PRUNE_ALERT to the remaining protocol component
        //

        poieTemp = CONTAINING_RECORD(
                    pse-> leOutIfList.Flink, OUT_IF_ENTRY, leIfList
                    );

        ppeEntry = GetProtocolEntry( 
                    PROTOCOL_LIST_HEAD(), poieTemp-> dwProtocolId,
                    poieTemp-> dwComponentId
                    );

        if ( ppeEntry == NULL )
        {
            TRACE2( 
                ANY, "InvokePruneAlertCallbacks : Could not"
                " find protocol (%x, %x)", poieTemp-> dwProtocolId,
                poieTemp-> dwComponentId
                );
        }

        
        //
        // invoke the delete membership callback for only the remaining
        // interface.
        //

        else if ( IS_PRUNE_ALERT( ppeEntry ) )
        {
            PRUNE_ALERT( ppeEntry ) (
                pse-> dwSourceAddr, pse-> dwSourceMask, 
                pge-> dwGroupAddr, pge-> dwGroupMask,
                dwIfIndex, dwIfNextHopAddr, TRUE, NULL
            );
        }
    }

    else if ( pse-> dwOutCompCount == 0 )
    {
        TRACESCOPE0( 
            GROUP, "Number of components in the OIL is down to 0" 
            );

        //
        // Number of protocol components that have interfaces in the 
        // OIL has reduced from 1 to 0.
        //
        // invoke PRUNE_ALERT to all the other protocol 
        // components
        //

        for ( pleStart = PROTOCOL_LIST_HEAD(), 
              pleProtocol = pleStart-> Flink;
              pleProtocol != pleStart;
              pleProtocol = pleProtocol-> Flink )
        {
            ppeEntry = CONTAINING_RECORD( 
                            pleProtocol, PROTOCOL_ENTRY, leProtocolList
                    );
            
            if ( ( ppeEntry-> dwProtocolId == ppe-> dwProtocolId ) &&
                 ( ppeEntry-> dwComponentId == ppe-> dwComponentId ) )
            {
                continue;
            }

            if ( IS_PRUNE_ALERT( ppeEntry ) )
            {
                PRUNE_ALERT( ppeEntry ) (
                    pse-> dwSourceAddr, pse-> dwSourceMask, 
                    pge-> dwGroupAddr, pge-> dwGroupMask, 
                    dwIfIndex, dwIfNextHopAddr, TRUE, NULL
                    );
            }
        }
    }
}



DWORD
APIENTRY
MgmUnBlockGroups(
    IN          DWORD       dwFirstGroup,
    IN          DWORD       dwLastGroup,
    IN          DWORD       dwIfIndex,
    IN          DWORD       dwIfNextHopAddr
)
/*++

Routine Description :

    This function walks the master group list and updates the memberships
    of each group entry.  If the interface (dwIfIndex) has previously been
    removed from the outgoing list of the group entry (and placed in the
    scoped i/f list) on account of a previous call to MgmBlockGroups 
    it is put back and all the MFEs for the group are
    updated to reflect this addition.
    
    In addition if this interface was the incoming interface for an MFE
    update the timer to expire the MFE in short order (within a second).
    This way we force the recreation of an MFE should there be traffic
    for this group.


Arguements :
    
    dwFirstGroup -  Lower end of the range of groups to be unblocked

    dwLastGroup -   Upper end of the range of groups be be unblocked

    dwIfIndex   -   Interface over which groups have to be unblocked.


Return Value :

    NO_ERROR - Group range successfully unblocked


Environment :

    This function is invoked by the IP RouterManager in response to
    removal of a group boundary.

--*/
{
    BOOL            bNewComp = FALSE, bWCGrpLock = FALSE,
                    bUpdatePass = FALSE;

    WORD            wWCGroupAddedBy = 0, wWCGroupNumAddsByRP = 0,
                    wGroupAddedBy, wGroupNumAddsByRP, wGroupNumAddsByIGMP,
                    wSourceAddedBy, wSourceNumAddsByRP, 
                    wSourceNumAddsByIGMP;
                    
    INT             iCmp;
    
    DWORD           dwIfBucket, dwWCBucket, dwIfProtocol, 
                    dwIfComponent, dwErr;

    PIF_ENTRY       pieIfEntry;

    PGROUP_ENTRY    pgeWC = NULL, pge;

    PSOURCE_ENTRY   pseWC = NULL, pse;

    POUT_IF_ENTRY   poie = NULL;
    

    PLIST_ENTRY     pleGrpHead, pleGrp, pleSrcHead, pleSrc;
    LIST_ENTRY      leForwardList;


    //
    // Ensure that MGM is running and increment count of threads
    // exceuting in MGM
    //

    if ( !ENTER_MGM_API() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    TRACE3( 
        SCOPE, "ENTERED MgmUnblockGroups : (%lx - %lx) on %lx",
        dwFirstGroup, dwLastGroup, dwIfIndex
        );


    ACQUIRE_PROTOCOL_LOCK_SHARED ();

    InitializeListHead( &leForwardList );

    do
    {
        //
        // Pass I : aka Scan pass (bupdatePass == FALSE)
        //  Scan and Collect all MFEs for which CREATION_ALERTS need to
        //  invoked before updating the MFEs.  Invoke the CREATION_ALERTS
        //  outside of any locks (which is why we need two passes).
        //
        // Pass II : Update pass (bupdatePass == TRUE)
        //  Update memberships and MFEs
        //

        //
        // Verify dwIfIndex is a valid interface with MGM
        //

        dwIfBucket = IF_TABLE_HASH( dwIfIndex );
        
        ACQUIRE_IF_LOCK_SHARED( dwIfBucket );

        pieIfEntry = GetIfEntry( 
                        IF_BUCKET_HEAD( dwIfBucket ), dwIfIndex, 
                        dwIfNextHopAddr
                        );

        if ( pieIfEntry == NULL )
        {
            TRACE2( 
                SCOPE, "Interface (%lx-%lx) not found", dwIfIndex,
                dwIfNextHopAddr
                );

            RELEASE_IF_LOCK_SHARED( dwIfBucket );

            break;
        }


        if ( bUpdatePass )
        {
            //
            // Verify the interface is still owned by the same protocol
            // as when you made the scan pass.
            // If not the protocol on the interface (on the scan pass)
            // has released the interface and there is no update to be done.
            // 

            if ( ( pieIfEntry-> dwOwningProtocol != dwIfProtocol ) ||
                 ( pieIfEntry-> dwOwningComponent != dwIfComponent ) )
            {
                TRACE2( 
                    SCOPE, "Ne protocol on interface (%lx-%lx)", dwIfIndex,
                    dwIfNextHopAddr
                    );

                RELEASE_IF_LOCK_SHARED( dwIfBucket );

                break;
            }
        }

        else
        {
            //
            // On the scan pass, store the protocol on the interface.
            // We need to verify that the protocol remains the same
            // between the scan and update passes.
            //

            dwIfProtocol    = pieIfEntry-> dwOwningProtocol;

            dwIfComponent   = pieIfEntry-> dwOwningComponent;
        }

        
        //
        // Merge temp and master group lists
        //

        ACQUIRE_TEMP_GROUP_LOCK_EXCLUSIVE();

        MergeTempAndMasterGroupLists( TEMP_GROUP_LIST_HEAD() );

        RELEASE_TEMP_GROUP_LOCK_EXCLUSIVE();

        
        //
        // Lock the master group list for reading
        //

        ACQUIRE_MASTER_GROUP_LOCK_SHARED( );

        //
        // Check if wild card recevier (*, *) for this interface.  If it is
        // note this. i.e. mark as added by protocol and numaddsbyRp = 1.
        // 
        // N.B.  
        //  You are scanning the master group list for the 
        //  WILDCARD_GROUP.  This is not as expensive as it seems since the
        //  WC entry if present would right at the beginning of the master
        //  list.
        //

        if ( FindGroupEntry( 
                MASTER_GROUP_LIST_HEAD(), WILDCARD_GROUP,
                WILDCARD_GROUP_MASK, &pgeWC, FALSE
                ) )
        {
            //
            // Lock this group entry to prevent changes to its OIF list
            // while unblokcing is in progress
            //
            
            ACQUIRE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
            bWCGrpLock = TRUE;
            
            dwWCBucket = SOURCE_TABLE_HASH( 
                            WILDCARD_SOURCE, WILDCARD_SOURCE_MASK
                            );

            if ( FindSourceEntry(
                    SOURCE_BUCKET_HEAD( pgeWC, dwWCBucket ),
                    WILDCARD_SOURCE, WILDCARD_SOURCE_MASK, &pseWC, TRUE
                    ) )
            {
                //
                // (*, *) entry present, check if dwIfIndex is present in its
                // OIF list
                //

                if ( FindOutInterfaceEntry( 
                        &pseWC-> leOutIfList, pieIfEntry-> dwIfIndex, 
                        pieIfEntry-> dwIfNextHopAddr, 
                        pieIfEntry->dwOwningProtocol,
                        pieIfEntry-> dwOwningComponent, &bNewComp, &poie 
                        ) )
                {
                    //
                    // This interface is a wildcard receiver.  Note this as 
                    // added by routing protocol since IGMP would never be 
                    // a (*, *) receiver
                    //

                    wWCGroupAddedBy     = poie-> wAddedByFlag;
                    wWCGroupNumAddsByRP = poie-> wNumAddsByRP;
                }
            }
        }


        for ( pleGrpHead = MASTER_GROUP_LIST_HEAD(), 
              pleGrp = pleGrpHead-> Flink;
              pleGrp != pleGrpHead;
              pleGrp = pleGrp-> Flink )
        {
            //
            // For each group in the master list
            //
            
            pge = CONTAINING_RECORD( pleGrp, GROUP_ENTRY, leGrpList );

            //
            // Skip the (*, *) entry. i.e. Skip the wildcard group.
            // This group entry has already been examined above (just
            // before the for loop).  There is no need to look at this
            // entry as the ref. counts for this entry have been collected
            // above.  In addition the "group entry lock" for this entry
            // has been acquired above and attempting to reacquire it will
            // lead to DEAD-LOCK.  This presents only a minor inconvience
            // in this "for" loop i.e. having to check and skip this entry.
            //

            if ( IS_WILDCARD_GROUP( pge-> dwGroupAddr, pge-> dwGroupMask ) )
            {
                continue;
            }

            
            //
            // check is in range specified
            //
            
            if ( INET_CMP( pge-> dwGroupAddr, dwLastGroup, iCmp ) > 0 )
            {
                //
                // The master group list is ordered by group number and 
                // the high end of the range has been crossed.  Quit
                //

                break;
            }

            if ( INET_CMP( pge-> dwGroupAddr, dwFirstGroup, iCmp ) < 0 )
            {
                //
                // Skip groups entries smaller than the lower end of the 
                // range
                //

                continue;
            }


            //
            // Group entry in range specified
            //

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );


            //
            // This group entry inherits the counts from the wildcard 
            // group entry
            //

            wGroupAddedBy       = wWCGroupAddedBy;
            wGroupNumAddsByRP   = wWCGroupNumAddsByRP;
            wGroupNumAddsByIGMP = 0;

            
            //
            // Check if there are group memberships for the wildcard source
            // that have been scoped.  Update interface counts appropriately
            //

            dwWCBucket = SOURCE_TABLE_HASH( 
                            WILDCARD_SOURCE, WILDCARD_SOURCE_MASK
                            );

            if ( FindSourceEntry( 
                    SOURCE_BUCKET_HEAD( pge, dwWCBucket ), WILDCARD_SOURCE,
                    WILDCARD_SOURCE_MASK, &pseWC, TRUE
                    ) )
            {
                //
                // Wild card source present.  Check if this interface
                // is present in its scoped i/f list
                //

                if ( FindOutInterfaceEntry( 
                        &pseWC-> leScopedIfList, pieIfEntry-> dwIfIndex,
                        pieIfEntry-> dwIfNextHopAddr, 
                        pieIfEntry-> dwOwningProtocol,
                        pieIfEntry-> dwOwningComponent,
                        &bNewComp, &poie
                        ) )
                {
                    //
                    // Wildcard member ship present present on the interface.
                    // Note it by updating counts
                    //

                    wGroupAddedBy       |= poie-> wAddedByFlag;
                        
                    wGroupNumAddsByRP   += poie-> wNumAddsByRP;
                        
                    wGroupNumAddsByIGMP  = poie-> wNumAddsByIGMP;
                }
            }


            //
            // Merge the temp and master source lists, before walking
            // the source list
            //

            MergeTempAndMasterSourceLists( pge );


            //
            // for each source entry
            //

            pleSrcHead = MASTER_SOURCE_LIST_HEAD( pge );

            for ( pleSrc = pleSrcHead-> Flink; 
                  pleSrc != pleSrcHead; 
                  pleSrc = pleSrc-> Flink )
            {
                pse = CONTAINING_RECORD( pleSrc, SOURCE_ENTRY, leSrcList );

                //
                // each source entry inherits the aggregated counts of
                // the wildcard group (*, *) and the wildcard source (*, G)
                // entry
                //
                
                wSourceAddedBy       = wGroupAddedBy;
                wSourceNumAddsByRP   = wGroupNumAddsByRP;
                wSourceNumAddsByIGMP = wGroupNumAddsByIGMP;


                //
                // Check if interface being unblocked is present in
                // the scoped i/f list for this source
                //

                if ( FindOutInterfaceEntry(
                        &pse-> leScopedIfList, pieIfEntry-> dwIfIndex,
                        pieIfEntry-> dwIfNextHopAddr,
                        pieIfEntry-> dwOwningProtocol,
                        pieIfEntry-> dwOwningComponent, &bNewComp, &poie
                        ) )
                {
                    //
                    // If this is not the wildcard source entry, presence
                    // of this interface in the scoped i/f list indicates
                    // that a source specific join for this group was
                    // performed.  Note the counts for this interface for
                    // the source specific join
                    //

                    if ( !IS_WILDCARD_SOURCE( 
                            pse-> dwSourceAddr, pse-> dwSourceMask 
                            ) )
                    {
                        wSourceAddedBy          |= poie-> wAddedByFlag;
                            
                        wSourceNumAddsByRP      += poie-> wNumAddsByRP;
                            
                        wSourceNumAddsByIGMP    += poie-> wNumAddsByIGMP;
                    }

                    
                    //
                    // The function name says it.
                    //

                    if ( bUpdatePass )
                    {
                        UnScopeIfAndInvokeCallbacks( pge, pse, poie );
                    }
                }


                //-----------------------------------------------------------
                // Part 2 : MFE Update
                //-----------------------------------------------------------

                if ( IS_VALID_INTERFACE( 
                        pse-> dwInIfIndex, pse-> dwInIfNextHopAddr
                        ) )
                {
                    //
                    // This is an MFE
                    //

                    //
                    // Check if the interface being unblocked is the
                    // incoming interface for this MFE
                    //

                    if ( ( pse-> dwInIfIndex == pieIfEntry-> dwIfIndex ) &&
                         ( pse-> dwInIfNextHopAddr == 
                                pieIfEntry-> dwIfNextHopAddr ) )
                    {
                        //
                        // The incoming interface is being unblocked.
                        // That implies this MFE is currently a negative.
                        // The easiest way to re-create the correct MFE
                        // is to delete the MFE and force its re-creation
                        // when the next packet arrives from the same
                        // (source, group).  The simplest way to delete
                        // the MFE and references to it in the interface
                        // table is to update the expiry time (set
                        // arbitrarily to 2 seconds here) and let the
                        // deletion happen via the MFETimerProc (timer.c)
                        //

                        if ( bUpdatePass )
                        {
                            RtlUpdateTimer( 
                                TIMER_QUEUE_HANDLE( 
                                    TIMER_TABLE_HASH( pge-> dwGroupAddr )
                                    ),
                                pse-> hTimer, 2000, 0 
                                );
                        }
                    }


                    //
                    // ELSE clause comment
                    //
                    // Interface being unblocked is not the incoming
                    // interface.  It could be an outgoing interface 
                    // for this MFE.  Check if any component is 
                    // interested in traffic for this (S, G).  To do
                    // this check the added by flag and if it is
                    // non-zero the interface should be added to the
                    // MFE OIF list.
                    //
                    // In addition, make sure that the incoming interface
                    // does not have a (scope) boundary on it.  In that 
                    // case, there is no MFE OIF list changes required.
                    //

                    else if (  wSourceAddedBy                       &&
                              ( !( IS_HAS_BOUNDARY_CALLBACK() ) ||
                                ( IS_HAS_BOUNDARY_CALLBACK()  &&
                                  !HAS_BOUNDARY_CALLBACK()( 
                                    dwIfIndex, pge-> dwGroupAddr
                                    ) ) ) )
                    {
                        if ( bUpdatePass && 
                             IsForwardingEnabled( 
                                pge-> dwGroupAddr, pge-> dwGroupMask,
                                pse-> dwSourceAddr, pse-> dwSourceMask,
                                &leForwardList
                                ) )
                        {
                            poie = NULL;
                            
                            AddInterfaceToSourceMfe(
                                pge, pse, pieIfEntry-> dwIfIndex,
                                pieIfEntry-> dwIfNextHopAddr,
                                pieIfEntry-> dwOwningProtocol,
                                pieIfEntry-> dwOwningComponent, FALSE, &poie
                                );

                            //
                            // Update counts for the OIF in the MFE list
                            //

                            if ( poie != NULL )
                            {
                                poie-> wAddedByFlag     = wSourceAddedBy;
                                poie-> wNumAddsByRP     = wSourceNumAddsByRP;
                                poie-> wNumAddsByIGMP   = wSourceNumAddsByIGMP;
                            }
                        }

                        else if ( !bUpdatePass )
                        {
                            AddToCheckForCreationAlertList(
                                pge-> dwGroupAddr, pge-> dwGroupMask,
                                pse-> dwSourceAddr, pse->dwSourceMask,
                                pse-> dwInIfIndex, pse-> dwInIfNextHopAddr,
                                &leForwardList
                                );
                        }
                    }
                }
            }
            
            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }

        //
        // if lock on the Wildcard group entry is held, release it
        //
        
        if ( bWCGrpLock )
        {
            RELEASE_GROUP_ENTRY_LOCK_SHARED( pgeWC );
        }

        RELEASE_MASTER_GROUP_LOCK_SHARED( );

        RELEASE_IF_LOCK_SHARED( dwIfBucket );

        if ( !bUpdatePass )
        {
            dwErr = InvokeCreationAlertForList( 
                        &leForwardList, dwIfProtocol, dwIfComponent,
                        dwIfIndex, dwIfNextHopAddr
                    );
                
            if ( dwErr != NO_ERROR )
            {
                break;
            }
            
            bUpdatePass = TRUE;
        }
        else
        {
            break;
        }
        
    } while ( TRUE );


    //
    // Release all locks and decrement thread-counts etc.
    //
    
    //
    // Invoke pended Join/Prune alerts
    //

    InvokeOutstandingCallbacks();

    
    RELEASE_PROTOCOL_LOCK_SHARED();

    FreeList( &leForwardList );
    
    LEAVE_MGM_API();

    TRACE0( SCOPE, "LEAVING MgmUnblockGroups" );

    return NO_ERROR;
}





VOID
UnScopeIfAndInvokeCallbacks(
    PGROUP_ENTRY    pge,
    PSOURCE_ENTRY   pse,
    POUT_IF_ENTRY   poie
)
/*++

Routine Description :

    This routine remove an interface entry from the scoped interface
    list for the specified source entry and puts it into the outgoing
    interface list.  If the addition of the interface to the OIF list
    requires new member callbacks to be issued to protocol components
    these are issued by this routine.


Arguements :

    pge - Group entry correspondong to the group being unblocked.

    pse - Source entry for the group being unblocked

    poie - Interface entry corresponding to the interface over which
           the (source, group) entry is being unblocked

Return Value :

    None

Environment :

    Invoked from MgmUnBlockGroups.  Assumes the protocol list and 
    interface bucket are locked for read, and the group entry is
    locked for write.
    
--*/
{
    BOOL            bFound, bNewComp = FALSE;
    
    PPROTOCOL_ENTRY ppe;
    
    POUT_IF_ENTRY   poieNext = NULL;

    
    do
    {
        //
        // Remove interface entry from the scoped I/f list
        //

        RemoveEntryList( &poie-> leIfList );


        //
        // Find its place in the OIF list for the source entry
        // and insert it in
        //

        bFound = FindOutInterfaceEntry(
                    &pse-> leOutIfList, poie-> dwIfIndex, 
                    poie-> dwIfNextHopAddr, poie-> dwProtocolId, 
                    poie-> dwComponentId, &bNewComp, &poieNext
                    );
            
        if ( bFound )
        {
            //
            // Trouble.  The interface to be inserted should not be
            // present in the OIF list for the source entry.  Since it
            // print a warning message and move on.
            //

            TRACE4( 
                ANY, "Interface (%d-%d) present in OIF list of (%x-%x)"
                " inspite of being scoped", poie-> dwIfIndex, 
                poie-> dwIfNextHopAddr, pse-> dwSourceAddr, pge-> dwGroupAddr
                );

            MGM_FREE( poie );

            break;

        }

        InsertTailList( 
            ( poieNext == NULL ) ?  &pse-> leOutIfList : 
                                    &poieNext-> leIfList,
            &poie-> leIfList
            );


        //
        // if new component, update component count and
        // call callback invoker
        //

        if ( bNewComp )
        {
            pse-> dwOutCompCount++;

            ppe = GetProtocolEntry( 
                    PROTOCOL_LIST_HEAD(), poie-> dwProtocolId, 
                    poie-> dwComponentId
                    );

            if ( ppe == NULL )
            {
                //
                // Trouble.  Interface present without any owning 
                // protocol component.
                //

                TRACE4( 
                    ANY, "Owning protocol(%d, %) for interface(%d, %d)"
                    " not found", poie-> dwProtocolId, poie-> dwComponentId,
                    poie-> dwIfIndex, poie-> dwIfNextHopAddr
                    );

                return;
            }

            InvokeJoinAlertCallbacks( 
                pge, pse, poie, IS_ADDED_BY_IGMP( poie ), ppe
                );
        }

    } while ( FALSE );
}



VOID
InvokeJoinAlertCallbacks(
    PGROUP_ENTRY        pge,
    PSOURCE_ENTRY       pse,
    POUT_IF_ENTRY       poie,
    BOOL                bIGMP,
    PPROTOCOL_ENTRY     ppe
)
/*++

Routine Description :

    This routine invokes New Member callbacks in response to a new
    protocol component being added to the outgoing interface list
    of a source entry.  New member callbacks are issued according
    to interop rules.

Argumements :

    pge - Entry corresponding to group for which new member callbacks
          are being issued.

    pse - Entry corresponding to source for which new member callbacks
          are being issued.

    poie - Entry corresponding to interface whose addition triggered the 
           callback mechanism.

    bIGMP - Indicates if IGMP is adding this interface.

    ppe - Protocol entry for the protocol component that owns the interface
          corresponding to poie.
          
Return Value :

    None


Environment :

    Invoked from AddInterfaceToSourceEntry and UnScopeIfAndInvokeCallbacks
    
--*/
{
    PPROTOCOL_ENTRY     ppeEntry;

    POUT_IF_ENTRY       poiePrev;
    
    PLIST_ENTRY         ple, pleStart;

    

    //
    // Check if Source specific join
    //

    if ( !IS_WILDCARD_SOURCE( pse-> dwSourceAddr, pse-> dwSourceMask ) )
    {
        if ( pse-> dwOutCompCount == 1 )
        {

            TRACESCOPE0( GROUP, "First component in OIL for source specific" );

            AddToOutstandingJoinList(
                pse-> dwSourceAddr, pse-> dwSourceMask,
                pge-> dwGroupAddr, pge-> dwGroupMask,
                poie-> dwIfIndex, poie-> dwIfNextHopAddr, 
                TRUE
                );
        }
    }

    
    else if ( pse-> dwOutCompCount == 1 )
    {
        TRACESCOPE0( GROUP, "First component in OIL" );

        //
        // Interaction between routing protocols.
        //
        
        //
        // first component in the OIL.
        //
        // Send new member callback to all the other (than the
        // the one adding this group membership on
        // this interface) routing protocol components
        //
        // At this point you have a read lock on the protocol list
        // so you can walk the list
        //

        pleStart = PROTOCOL_LIST_HEAD();
        
        for ( ple = pleStart-> Flink; ple != pleStart; ple = ple-> Flink )
        {
            ppeEntry = CONTAINING_RECORD( 
                        ple, PROTOCOL_ENTRY, leProtocolList 
                        );

            //
            // all OTHER protocol components need to be told of the 
            // interface addition. So skip the component adding 
            // this interface.
            //
            
            if ( ( ppeEntry-> dwProtocolId == ppe-> dwProtocolId ) &&
                 ( ppeEntry-> dwComponentId == ppe-> dwComponentId ) )
            {
                continue;
            }


            //
            // if routing protocol has requested new member callback
            //
            
            if ( IS_JOIN_ALERT( ppeEntry ) )
            {
                JOIN_ALERT( ppeEntry )(
                    pse-> dwSourceAddr, pse-> dwSourceMask,
                    pge-> dwGroupAddr, pge-> dwGroupMask, TRUE
                );
            }
        }
    }


    //
    // if second component to add an interface to the OIL
    // invoke new member callback to first component.
    // 
    // Note :
    //  If the first component that added a group membership
    //  was IGMP skip JOIN_ALERT callback.
    //

    else if ( pse-> dwOutCompCount == 2 )
    {
        TRACESCOPE0( GROUP, "Second component in OIL" );
        
        //
        // find the "other (first)" routing protocol component to add 
        // an interface to the OIL
        //

        for ( ple = pse-> leOutIfList.Flink;
              ple != &pse-> leOutIfList;
              ple = ple-> Flink )
        {
            poiePrev = CONTAINING_RECORD( 
                        ple, OUT_IF_ENTRY, leIfList 
                        );

            //
            // if the protocol component that added this interface to 
            // the OIL is different indicating that it is the other 
            // component invoke its new member interface
            // 

            if ( ( poiePrev-> dwProtocolId != ppe-> dwProtocolId ) ||
                 ( poiePrev-> dwComponentId != ppe-> dwComponentId ) )
            {

                //
                // Find the protocol entry for the other interface
                //

                ppeEntry = GetProtocolEntry( 
                            &ig.mllProtocolList.leHead,
                            poiePrev-> dwProtocolId,
                            poiePrev-> dwComponentId
                            );

                if ( ppeEntry == NULL )
                {
                    TRACE2( 
                        ANY, "InvokeJoinAlertCallbacks : Could not"
                        "find protocol %x, %x", poie-> dwProtocolId,
                        poie-> dwComponentId
                    );
                }

                else if ( IS_ROUTING_PROTOCOL( ppeEntry ) &&
                          IS_JOIN_ALERT( ppeEntry ) )
                {
                    //
                    // JOIN_ALERT callback will be skipped if
                    // the first component is IGMP
                    //
                    
                    JOIN_ALERT( ppeEntry )(
                        pse-> dwSourceAddr, pse-> dwSourceMask, 
                        pge-> dwGroupAddr, pge-> dwGroupMask, TRUE
                        );
                }

                break;
            }
        }
    }


    //
    // if this group membership was added by IGMP, and
    // a routing protocol co-exists with IGMP on this interface
    // inform the routing protocol too.
    //

    if ( bIGMP && IS_ROUTING_PROTOCOL( ppe ) )
    {
        if ( IS_LOCAL_JOIN_ALERT( ppe ) )
        {
            LOCAL_JOIN_ALERT( ppe )(
                pse-> dwSourceAddr, pse-> dwSourceMask, 
                pge-> dwGroupAddr, pge-> dwGroupMask,
                poie-> dwIfIndex, poie-> dwIfNextHopAddr
                );
        }
    }
}




DWORD
AddToOutstandingJoinList(
    DWORD       dwSourceAddr,
    DWORD       dwSourceMask,
    DWORD       dwGroupAddr,
    DWORD       dwGroupMask,
    DWORD       dwIfIndex,
    DWORD       dwIfNextHopAddr,
    BOOL        bJoin
)
/*++

Routine Description :

    This routine adds a Join entry to the global outstanding join list.
    Each entry in this list represents a "source specific" join/leave for
    which the corresponding join/prune alerts have not yet been issued.
    The reason for deferring the callbacks has to do with the order of
    locking of buckets in the IF HASH table.  When a membership is 
    added/deleted a lock is taken on the interface bucket that contains
    the interface on which the membership is being changed.  When the
    source entry for which the membership is being changed has been
    updated you determine (as per interop rules) whether 
    a join/prune needs to be issued to the protocol on the incoming 
    interface.  If it must you need to look up the incoming interface
    and then find the protocol on that interface and invoke its callbacks.
    To do this you need to look up the incoming interface in the 
    IF hash table and locking the bucket for that IF entry.  You lock two
    buckets simultaneously.  Hence the deferral
    

Arguements :

    dwSourceAddr - Source address for which a join/leave has occured

    dwSourceMask - Mask corresponding to dwSourceAddr

    dwGroupAddr - Group for which a join/leave has occured

    dwGroupMask - Mask corresponding to dwGroupAddr

    dwIfIndex   - Incoming interface index as per the MCAST RIB

    dwIfNextHopAddr - Next hop address corresponding to dwIfIndex

    bJoin - Indicates if an outstanding entry is being added because of a
            join or leave


Return Value :

    NO_ERROR - Success

    ERROR_NOT_ENOUGH_MEMORY - failed to allocate a join entry


Environment :

    Invoked in the context of Invoke[PruneAlert/JoinAlert]Callbacks
    
--*/
{
    BOOL            bFound;
    
    DWORD           dwErr = NO_ERROR;

    PJOIN_ENTRY     pje = NULL, pjeNew;

    
    ACQUIRE_JOIN_LIST_LOCK_EXCLUSIVE();
    
    do
    {
        bFound = FindJoinEntry(
                    JOIN_LIST_HEAD(), dwSourceAddr, dwSourceMask,
                    dwGroupAddr, dwGroupMask, dwIfIndex, dwIfNextHopAddr,
                    &pje
                    );

        if ( bFound )
        {
            //
            // Join entry already exists for this interface.
            // Check if it is of the same type 
            //

            if ( pje-> bJoin != bJoin )
            {
                //
                // Join entries of different types, null each other
                // remove this join entry
                //

                RemoveEntryList( &pje-> leJoinList );

                MGM_FREE( pje );
            }
        }

        else
        {
            //
            // Join entry does not exist.  Create one and insert it.
            //

            pjeNew = MGM_ALLOC( sizeof( JOIN_ENTRY ) );

            if ( pjeNew == NULL )
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                TRACE1( ANY, "Failed to create Join Entry : %x", dwErr );

                break;
            }

            InitializeListHead( &pjeNew-> leJoinList );

            pjeNew-> dwSourceAddr      = dwSourceAddr;

            pjeNew-> dwSourceMask      = dwSourceMask;

            pjeNew-> dwGroupAddr       = dwGroupAddr;

            pjeNew-> dwGroupMask       = dwGroupMask;

            pjeNew-> dwIfIndex         = dwIfIndex;

            pjeNew-> dwIfNextHopAddr   = dwIfNextHopAddr;

            pjeNew-> bJoin             = bJoin;

            InsertTailList( 
                ( pje == NULL ) ? JOIN_LIST_HEAD() : &pje-> leJoinList,
                &pjeNew-> leJoinList
                );
        }
        
    } while ( FALSE );

    RELEASE_JOIN_LIST_LOCK_EXCLUSIVE();

    return dwErr;
}




PJOIN_ENTRY
GetNextJoinEntry(
)
/*++

Routine Description :

    This function removes the first outstanding join entry and returns it


Arguements :


Return Values :

    NULL -  if outstanding join list is empty

    pointer to a join entry otherwise


Environment :

    Invoked from InvokeOutstandingCallbacks
    
--*/
{
    PLIST_ENTRY     ple;

    PJOIN_ENTRY     pje = NULL;

    
    ACQUIRE_JOIN_LIST_LOCK_EXCLUSIVE();

    if ( !IsListEmpty( JOIN_LIST_HEAD() ) )
    {
        ple = RemoveHeadList( JOIN_LIST_HEAD() );

        pje = CONTAINING_RECORD( ple, JOIN_ENTRY, leJoinList );
    }

    RELEASE_JOIN_LIST_LOCK_EXCLUSIVE();

    return pje;
}




BOOL
FindJoinEntry(
    PLIST_ENTRY     pleJoinList,
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwIfIndex,
    DWORD           dwIfNextHopAddr,
    PJOIN_ENTRY *   ppje
)
/*++

Routine Description :

    This routine finds a specified join entry in the outstanding join list.


Arguements :
    pleJoinList - Join list to be searched

    dwSourceAddr - Source address for which a join/leave has occured

    dwSourceMask - Mask corresponding to dwSourceAddr

    dwGroupAddr - Group for which a join/leave has occured

    dwGroupMask - Mask corresponding to dwGroupAddr

    dwIfIndex   - Incoming interface index as per the MCAST RIB

    dwIfNextHopAddr - Next hop address corresponding to dwIfIndex

    ppje - a pointer to join entry if found or 
           a pointer to the next element in the join list if it exists or
           NULL

           
Return Values :

    TRUE - Join entry found

    FALSE - Join entry not found


Environment :

    Invoked from AddToOutstandingJoinList
--*/
{
    INT             iCmp;
    
    PLIST_ENTRY     ple = NULL;

    PJOIN_ENTRY     pje = NULL;

    BOOL            bFound = FALSE;
    


    *ppje = NULL;
    

    for ( ple = pleJoinList-> Flink; ple != pleJoinList; ple = ple-> Flink )
    {
        pje = CONTAINING_RECORD( ple, JOIN_ENTRY, leJoinList );

        if ( INET_CMP( pje-> dwGroupAddr, dwGroupAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //

            *ppje = pje;
            break;
        }
        

        if ( INET_CMP( pje-> dwSourceAddr, dwSourceAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //
            
            *ppje = pje;
            break;
        }

        
        if ( pje-> dwIfIndex < dwIfIndex )
        {
            continue;
        }

        else if ( pje-> dwIfIndex > dwIfIndex )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //
            
            *ppje = pje;
            break;
        }
        

        if ( INET_CMP( pje-> dwIfNextHopAddr, dwIfNextHopAddr, iCmp ) < 0 )
        {
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //

            *ppje = pje;
            break;
        }

        
        //
        // entry found
        //

        *ppje = pje;

        bFound = TRUE;
        
        break;
    }

    return bFound;
}




VOID
InvokeOutstandingCallbacks(
)
/*++

Routine Description :

    This routine walks the global outstanding join list, and for each entry
    finds the incoming interface and the protocol on it and invokes the
    appropriate callback (JoinAlert/PruneAlert).
    

Arguements :

           
Return Values :


Environment :

    Whenever a source specific join or leave occurs or when scoped boundaries
    change.
--*/
{
    BOOL            bFound;
    
    DWORD           dwIfBucket;
    
    PJOIN_ENTRY     pje;

    PIF_ENTRY       pie;

    PPROTOCOL_ENTRY ppe;
    
    DWORD           dwErr;
    
    RTM_NET_ADDRESS rnaAddr;

    RTM_DEST_INFO   rdiDest;

    RTM_NEXTHOP_INFO rniNextHop;

    BOOL            bRelDest, bRelNextHop, bRelIfLock;

    HANDLE          hNextHop;


    //
    // While there are join entries
    //  - Get the next join entry
    //  - Look source and find incoming interface
    //  - Find the interface entry and get the protocol on that i/f
    //  - invoke its callback
    //

    while ( ( pje = GetNextJoinEntry() ) != NULL )
    {
        bRelDest = bRelNextHop = bRelIfLock = FALSE;
        
        do
        {
            //
            // Get route to source
            //
            
            RTM_IPV4_MAKE_NET_ADDRESS( 
                &rnaAddr, pje-> dwSourceAddr, IPv4_ADDR_LEN 
                );

            dwErr = RtmGetMostSpecificDestination(
                        g_hRtmHandle, &rnaAddr, RTM_BEST_PROTOCOL, 
                        RTM_VIEW_MASK_MCAST, &rdiDest
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( 
                    ANY, "InvokeOutstandingCallbacks : Failed to lookup "
                    "route : %x", dwErr
                    );

                break;
            }

            bRelDest = TRUE;


            //
            // Select next hop info
            //

            hNextHop = SelectNextHop( &rdiDest );

            if ( hNextHop == NULL )
            {
                TRACE1(
                    ANY, "InvokeOutstandingCallbacks : Failed to select "
                    "next hop : %x", dwErr
                    );

                break;
            }


            //
            // Get nexthop info
            //

            dwErr = RtmGetNextHopInfo(
                        g_hRtmHandle, hNextHop, &rniNextHop
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( 
                    ANY, "InvokeOutstandingCallbacks : Failed to get "
                    "next hop info : %x", dwErr
                    );

                break;
            }

            bRelNextHop = TRUE;


            //
            // Find the incming interface entry
            //
            
            dwIfBucket = IF_TABLE_HASH( rniNextHop.InterfaceIndex );

            ACQUIRE_IF_LOCK_SHARED( dwIfBucket );
            bRelIfLock = TRUE;
            
            bFound = FindIfEntry( 
                        IF_BUCKET_HEAD( dwIfBucket ), rniNextHop.InterfaceIndex,
                        0, &pie
                        );

            if ( ( pie == NULL )            ||
                 ( !bFound          && 
                   pie-> dwIfIndex != rniNextHop.InterfaceIndex ) )
            {
                //
                // No interface with the specified ID exists. 
                // Nothing to be done
                //

                break;
            }


            //
            // Check if the interface on which JOIN/PRUNE occured is
            // the same as the incoming interface.
            //
            // If so skip it.
            //

            if ( ( pje-> dwIfIndex == pie-> dwIfIndex ) &&
                 ( pje-> dwIfNextHopAddr == pie-> dwIfNextHopAddr ) )
            {
                //
                // No join/prune required
                //

                TRACEGROUP2(
                    GROUP, "No callback as incoming if == joined/pruned "
                    "if 0x%x 0x%x",
                    pje-> dwIfIndex, pje-> dwIfNextHopAddr
                    );

                break;
            }

            
            ppe = GetProtocolEntry(
                    PROTOCOL_LIST_HEAD(), pie-> dwOwningProtocol,
                    pie-> dwOwningComponent
                    );
                    
            if ( ppe == NULL )
            {
                //
                // No protocol present for interface entry.  Strange
                //
                
                break;
            }


            if ( pje-> bJoin )
            {
                if ( IS_JOIN_ALERT( ppe ) )
                {
                    JOIN_ALERT( ppe )(
                        pje-> dwSourceAddr, pje-> dwSourceMask, 
                        pje-> dwGroupAddr, pje-> dwGroupMask,
                        TRUE
                        );
                }
            }

            else
            {
                if ( IS_PRUNE_ALERT( ppe ) )
                {
                    PRUNE_ALERT( ppe )(
                        pje-> dwSourceAddr, pje-> dwSourceMask, 
                        pje-> dwGroupAddr, pje-> dwGroupMask,
                        pje-> dwIfIndex, pje-> dwIfNextHopAddr, 
                        TRUE, NULL
                        );
                }
            }

        } while ( FALSE );

        MGM_FREE( pje );

        if ( bRelIfLock )
        {
            RELEASE_IF_LOCK_SHARED( dwIfBucket );
        }

        if ( bRelDest )
        {
            dwErr = RtmReleaseDestInfo( g_hRtmHandle, &rdiDest );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to release dest info : %x", dwErr );
            }
        }

        if ( bRelNextHop )
        {
            dwErr = RtmReleaseNextHopInfo( g_hRtmHandle, &rniNextHop );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to release dest info : %x", dwErr );
            }
        }
    }
}



VOID
AddToCheckForCreationAlertList(
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwInIfIndex,
    DWORD           dwInIfNextHopAddr,
    PLIST_ENTRY     pleForwardList
)
/*++

Routine Description :


Arguements :

           
Return Values :


Environment :

--*/
{
    PJOIN_ENTRY     pje;

    
    //
    // Create an entry in the forward list
    //

    pje = MGM_ALLOC( sizeof( JOIN_ENTRY ) );

    if ( pje == NULL )
    {
        TRACE0( ANY, "Failed to allocate forward list entry" );

        return;
    }

    InitializeListHead( &pje-> leJoinList );

    pje-> dwSourceAddr      = dwSourceAddr;

    pje-> dwSourceMask      = dwSourceMask;
    
    pje-> dwGroupAddr       = dwGroupAddr;
    
    pje-> dwGroupMask       = dwGroupMask;

    pje-> dwIfIndex         = dwInIfIndex;

    pje-> dwIfNextHopAddr   = dwInIfNextHopAddr;

    pje-> bJoin             = TRUE;


    //
    // Insert at the end of the list
    //
    
    InsertTailList( pleForwardList, &pje-> leJoinList );

    return;
}



BOOL
IsForwardingEnabled(
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    PLIST_ENTRY     pleForwardList
)
/*++
--*/
{
    PLIST_ENTRY     ple, pleTemp;

    PJOIN_ENTRY     pje;

    BOOL            bEnable = FALSE;

    INT             iCmp;


    
    //
    // find the source group entry and 
    // check if forwarding is enabled for it
    //

    ple = pleForwardList-> Flink; 

    while ( ple != pleForwardList )
    {
        pje = CONTAINING_RECORD( ple, JOIN_ENTRY, leJoinList );

        if ( INET_CMP( pje-> dwGroupAddr, dwGroupAddr, iCmp ) < 0 )
        {
            pleTemp = ple-> Flink;

            RemoveEntryList( ple );

            MGM_FREE( pje );

            ple = pleTemp;
            
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //

            break;
        }
        

        if ( INET_CMP( pje-> dwSourceAddr, dwSourceAddr, iCmp ) < 0 )
        {
            pleTemp = ple-> Flink;

            RemoveEntryList( ple );

            MGM_FREE( pje );

            ple = pleTemp;
            
            continue;
        }

        else if ( iCmp > 0 )
        {
            //
            // you are now past the position where an existing
            // entry would be.
            //

            break;
        }


        //
        // found source-group entry
        //

        bEnable = pje-> bJoin;

        RemoveEntryList( ple );

        MGM_FREE( pje );

        break;
    }

    return bEnable;
}




DWORD
InvokeCreationAlertForList( 
    PLIST_ENTRY     pleForwardList,
    DWORD           dwProtocolId,
    DWORD           dwComponentId,
    DWORD           dwIfIndex,
    DWORD           dwIfNextHopAddr
)
{
    PPROTOCOL_ENTRY ppe;

    PLIST_ENTRY     ple;

    PJOIN_ENTRY     pje;

    MGM_IF_ENTRY    mie;


    //
    // Get the protocol entry on which CREATION_ALERTs are to
    // be invoked.
    //

    ppe = GetProtocolEntry(
            PROTOCOL_LIST_HEAD(), dwProtocolId, dwComponentId
            );

    if ( ppe == NULL )
    {
        TRACE2(
            ANY, "Could not invoke CREATION_ALERTs since protocol"
            "(%ld, %ld) not found", dwProtocolId, dwComponentId
            );
            
        return ERROR_NOT_FOUND;
    }


    if ( !( IS_CREATION_ALERT( ppe ) ) )
    {
        TRACE2(
            ANY, "Protocol (%ld, %ld) does not have a CREATION_ALERT",
            dwProtocolId, dwComponentId
            );

        return NO_ERROR;
    }

    
    //
    // for each member of the list invoke CREATION_ALERT
    //

    ple = pleForwardList-> Flink;

    while ( ple != pleForwardList )
    {
        pje = CONTAINING_RECORD( ple, JOIN_ENTRY, leJoinList );

        mie.dwIfIndex       = dwIfIndex;

        mie.dwIfNextHopAddr = dwIfNextHopAddr;

        mie.bIGMP           = TRUE;

        mie.bIsEnabled        = pje-> bJoin;


        CREATION_ALERT( ppe )(
            pje-> dwSourceAddr, pje-> dwSourceMask,
            pje-> dwGroupAddr, pje-> dwGroupMask,
            pje-> dwIfIndex, pje-> dwIfNextHopAddr,
            1, &mie
            );

        pje-> bJoin         = mie.bIsEnabled;

        ple                 = ple-> Flink;
    }

    return NO_ERROR;
}


VOID
WorkerFunctionInvokeCreationAlert(
    PVOID       pvContext
    )
/*++

Routine Description:

    This routine invokes the creation alert for the protocol that
    owns the interface specified in the context.  This invocation
    needs to happen from a worker thread for locking reasons.

    For a group join the protocol calls into MGM via the
    MgmAddGroupMembership API.  We cannot call back into the protocol
    in the context of this API call since the protocol could be holding 
    locks when invoking this API which in turn may be acquired in the 
    context of the callback.  Hence the call back are invoked from a 
    worker thread

Parameters

    pvContext   - pointer to a CREATION_ALERT_CONTEXT structure 
                  containing the source, group, and interface on which 
                  a membership join occured.

Return Value:

    None

Environment:

    Invoked from MgmAddGroupMembership for (*, G) and (*, *) joins.  
    Calls in protocols to issue CREATION_ALERT_CALLBACK
    
--*/
{
    DWORD dwInd, dwErr, dwIfBucket, dwGrpBucket, dwSrcBucket;
    
    BOOL bNewComp, bIfLock = FALSE, bGrpLock = FALSE, bgeLock = FALSE;
    
    PIF_ENTRY pieEntry;
    PGROUP_ENTRY pge;
    PSOURCE_ENTRY pse;
    POUT_IF_ENTRY poie;
    LIST_ENTRY leSourceList;
    
    PCREATION_ALERT_CONTEXT pcac = (PCREATION_ALERT_CONTEXT) pvContext;


    if (!ENTER_MGM_WORKER())
    {
        TRACE0(
            ANY, "InvokeCreationAlert: Failed to enter"
            );

        MGM_FREE( pcac );
        
        return;
    }


    TRACE0( GROUP, "ENTERED WorkerFunctionInvokeCreationAlert" );

    //
    // Acquire protocol lock first to maintain locking order
    //

    ACQUIRE_PROTOCOL_LOCK_SHARED();

    do
    {
        dwIfBucket = IF_TABLE_HASH(
                        pcac-> dwIfIndex
                        );

        //
        // For wildcard group - i.e. (*, *) membership adds.
        //
        
        if ( IS_WILDCARD_GROUP( pcac-> dwGroupAddr, pcac-> dwGroupMask ) )
        {
            InitializeListHead( &leSourceList );
            
            //
            // Walk each bucket of the group table
            //
            
            for ( dwInd = 1; dwInd < GROUP_TABLE_SIZE; dwInd++ )
            {
                //
                // Lock the interface to prevent the (*, *)
                // membership from being deleted while MFEs
                // are being updated.
                //
                
                ACQUIRE_IF_LOCK_SHARED( dwIfBucket );

                pieEntry = GetIfEntry(
                            IF_BUCKET_HEAD( dwIfBucket ),
                            pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                            );

                if ( pieEntry == NULL )
                {
                    //
                    // Interface is no longer present with MGM.
                    // possibly deleted in another thread.
                    // There is no further MFE update to be performed.
                    // quit now.
                    //

                    RELEASE_IF_LOCK_SHARED( dwIfBucket );

                    break;
                }

                //
                // Pass 1: Accumulate (S, G) values for all groups
                //         in this group bucket into leSourceList.
                //
                
                AddInterfaceToAllMfeInGroupBucket(
                    pcac-> dwIfIndex, pcac-> dwIfNextHopAddr,
                    pcac-> dwProtocolId, pcac-> dwComponentId,
                    dwInd, pcac-> bIGMP, FALSE, &leSourceList
                    );

                RELEASE_IF_LOCK_SHARED( dwIfBucket );


                //
                // Invoke CREATION_ALERTs on them outside locks
                //
                
                dwErr = InvokeCreationAlertForList( 
                            &leSourceList, 
                            pcac-> dwProtocolId, pcac-> dwComponentId,
                            pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                            );
                            
                if ( dwErr == NO_ERROR )
                {
                    //
                    // Lock the interface to prevent the (*, *)
                    // membership from being deleted while MFEs
                    // are being updated.
                    //
                    
                    ACQUIRE_IF_LOCK_SHARED( dwIfBucket );

                    pieEntry = GetIfEntry(
                                IF_BUCKET_HEAD( dwIfBucket ),
                                pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                                );
                                
                    if ( pieEntry == NULL )
                    {
                        //
                        // Interface is no longer present with MGM.
                        // possibly deleted in another thread.
                        // There is no further MFE update to be performed.
                        // quit now.
                        //

                        RELEASE_IF_LOCK_SHARED( dwIfBucket );

                        break;
                    }
                    

                    //
                    // Verify that the (*, *) membership on this interface
                    // is still present.
                    // It could have been deleted in a separate thread.
                    //

                    dwGrpBucket = GROUP_TABLE_HASH( 0, 0 );

                    ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

                    pge = GetGroupEntry( 
                            GROUP_BUCKET_HEAD( dwGrpBucket ), 0, 0
                            );
                    
                    if ( pge != NULL )
                    {
                        ACQUIRE_GROUP_ENTRY_LOCK_SHARED( pge );
                        
                        dwSrcBucket = SOURCE_TABLE_HASH( 0, 0 );
                        
                        if ( FindSourceEntry(
                                SOURCE_BUCKET_HEAD( pge, dwSrcBucket ), 
                                0, 0, &pse, TRUE ) )
                        {
                            if ( FindOutInterfaceEntry(
                                    &pse-> leOutIfList,
                                    pcac-> dwIfIndex, 
                                    pcac-> dwIfNextHopAddr,
                                    pcac-> dwProtocolId, 
                                    pcac-> dwComponentId,
                                    &bNewComp, 
                                    &poie ) )
                            {
                                //
                                // (*, *) membership is present on 
                                // this interface
                                //

                                //
                                // Pass 2 : Update all MFEs in this
                                //          bucket as per the results
                                //          of the CREATION_ALERTs
                                //
                                
                                AddInterfaceToAllMfeInGroupBucket(
                                    pcac-> dwIfIndex, 
                                    pcac-> dwIfNextHopAddr,
                                    pcac-> dwProtocolId, 
                                    pcac-> dwComponentId,
                                    dwInd, 
                                    pcac-> bIGMP, 
                                    TRUE, 
                                    &leSourceList
                                    );
                            }

                            else
                            {
                                //
                                // (*, *) membership is NO longer 
                                // present on this interface
                                //
                                
                                dwInd = GROUP_TABLE_SIZE;
                            }
                        }

                        else
                        {
                            //
                            // (*, *) membership is no longer present
                            //
                            
                            dwInd = GROUP_TABLE_SIZE;
                        }

                        RELEASE_GROUP_ENTRY_LOCK_SHARED( pge );
                    }

                    else
                    {
                        //
                        // (*, *) membership is no longer present
                        //
                        
                        dwInd = GROUP_TABLE_SIZE;
                    }
                    
                    RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
                    
                    RELEASE_IF_LOCK_SHARED( dwIfBucket );
                }

                FreeList( &leSourceList );
            }

            FreeList( &leSourceList );
        }


        //
        // For wildard sources i.e. (*, G) membership adds
        //
        
        else if ( IS_WILDCARD_SOURCE( 
                    pcac-> dwSourceAddr, pcac-> dwSourceMask 
                    ) )
        {
            do
            {
                //
                // Invoke CREATION_ALERTs for all MFEs for the group
                //
                
                dwErr = InvokeCreationAlertForList( 
                            &(pcac-> leSourceList),
                            pcac-> dwProtocolId,
                            pcac-> dwComponentId, 
                            pcac-> dwIfIndex,
                            pcac-> dwIfNextHopAddr
                            );
                            
                if ( dwErr != NO_ERROR )
                {
                    break;
                }


                //
                // Lock the interface to prevent the (*, G)
                // membership from being deleted while MFEs
                // are being updated.
                //
                
                ACQUIRE_IF_LOCK_SHARED( dwIfBucket );
                bIfLock = TRUE;

                pieEntry = GetIfEntry(
                            IF_BUCKET_HEAD( dwIfBucket ),
                            pcac-> dwIfIndex, 
                            pcac-> dwIfNextHopAddr
                            );

                if ( pieEntry == NULL )
                {
                    //
                    // Interface is no longer present with MGM.
                    // possibly deleted in another thread.
                    // There is no further MFE update to be performed.
                    // quit now.
                    //

                    TRACE2(
                        ANY, "InvokeCreationAlert: Interface 0x%x 0x%x"
                        " is no longer present",
                        pcac-> dwIfIndex, 
                        pcac-> dwIfNextHopAddr
                        );
                        
                    break;
                }
                

                //
                // Verify that the (*, G) membership is still
                // present on the interface
                //
                
                dwGrpBucket = GROUP_TABLE_HASH( 
                                pcac-> dwGroupAddr, 
                                pcac-> dwGroupMask
                                );

                ACQUIRE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
                bGrpLock = TRUE;

                pge = GetGroupEntry( 
                        GROUP_BUCKET_HEAD( dwGrpBucket ), 
                        pcac-> dwGroupAddr,
                        pcac-> dwGroupMask
                        );

                if ( pge == NULL )
                {
                    //
                    // Group entry no longer present, possibly
                    // deleted in some other thread
                    //

                    TRACE2(
                        ANY, "InvokeCreationAlert: Group 0x%x 0x%x "
                        "is no longer present",
                        pcac-> dwGroupAddr, pcac-> dwGroupMask
                        );

                    break;
                }
                
                ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                bgeLock = TRUE;

                dwSrcBucket = SOURCE_TABLE_HASH( 
                                pcac-> dwSourceAddr, 
                                pcac-> dwSourceMask 
                                );

                pse = GetSourceEntry(
                        SOURCE_BUCKET_HEAD( pge, dwSrcBucket ),
                        pcac-> dwSourceAddr, 
                        pcac-> dwSourceMask
                        );
                        
                if ( pse == NULL )
                {
                    //
                    // Source entry no longer present, possibly
                    // deleted in some other thread
                    //

                    TRACE2(
                        ANY, "InvokeCreationAlert: Source 0x%x 0x%x "
                        "is no longer present",
                        pcac-> dwSourceAddr, pcac-> dwSourceMask
                        );

                    break;
                
                }

                poie = GetOutInterfaceEntry(
                        &pse-> leOutIfList,
                        pcac-> dwIfIndex, pcac-> dwIfNextHopAddr,
                        pcac-> dwProtocolId, pcac-> dwComponentId
                        );

                if ( poie == NULL )
                {
                    TRACE2(
                        ANY, "InvokeCreationAlert: Interface 0x%x 0x%x "
                        "is no longer present in OIF",
                        pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                        );

                    break;
                    
                }
                
                //
                // (*, G) present on this interface.
                // Update all for group MFE as per results of 
                // creation alerts.
                //
                
                AddInterfaceToGroupMfe(
                    pge, pcac-> dwIfIndex, pcac-> dwIfNextHopAddr,
                    pcac-> dwProtocolId, pcac-> dwComponentId,
                    pcac-> bIGMP, TRUE, &(pcac-> leSourceList)
                    );
                
            } while ( FALSE );


            //
            // release locks
            //

            if ( bgeLock )
            {
                RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
                bgeLock = FALSE;
            }
            
            if ( bGrpLock )
            {
                RELEASE_GROUP_LOCK_EXCLUSIVE( dwGrpBucket );
                bgeLock = FALSE;
            }

            if ( bIfLock )
            {
                RELEASE_IF_LOCK_SHARED( dwIfBucket );
                bIfLock = FALSE;
            }
            
            FreeList( &(pcac-> leSourceList) );
        } 
        
    } while ( FALSE );
    

    if ( bIfLock )
    {
        RELEASE_IF_LOCK_SHARED( dwIfBucket );
    }
    
    RELEASE_PROTOCOL_LOCK_SHARED();

    MGM_FREE( pcac );
    
    LEAVE_MGM_WORKER();
    
    TRACE0( GROUP, "LEAVING WorkerFunctionInvokeCreationAlert" );

    return;
}


#if 0
v()
{
        //
        // Ensure interface on which join occured is still present 
        //

        dwIfBucket = IF_TABLE_HASH(
                        pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                        );

        ACQUIRE_IF_LOCK_SHARED( dwIfBucket );
        bIfLock = TRUE;
        
        pieEntry = GetIfEntry(
                    IF_BUCKET_HEAD( dwIfBucket ),
                    pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                    );

        if ( pieEntry == NULL )
        {
            TRACE2(
                ANY,
                "InvokeCreationAlert: Could not find interface 0x%x 0x%x",
                pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                );

            break;
        }


        //
        // Ensure that group is still joined on the interface.  Since this
        // is being executed asynchronously, it is possible that between 
        // the time this work item was queued and the time it gets executed 
        // the membership may have been deleted.
        //

        dwGrpBucket = GROUP_TABLE_HASH( 
                        pcac-> dwGroupAddr, pcac-> dwGroupMask
                        );

        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );
        bGrpBucket = TRUE;

        pge = GetGroupEntry(
                GROUP_BUCKET_HEAD( dwGrpBucket ),
                pcac-> dwGroupAddr, pcac-> dwGroupMask
                );

        if ( pge == NULL )
        {
            TRACE2(
                ANY, "InvokeCreationAlert: Could not find group 0x%x 0x%x",
                pcac-> dwGroupAddr, pcac-> dwGroupMask
                );

            break;
        }

        ACQUIRE_GROUP_ENTRY_LOCK_SHARED( pge );
        bGrpLock = TRUE;

        dwSrcBucket = SOURCE_TABLE_HASH(
                         pcac-> dwSourceAddr, pcac-> dwSourceMask
                         );

        pse = GetSourceEntry(
                SOURCE_BUCKET_HEAD( pge, dwSrcBucket ),
                pcac-> dwSourceAddr, pcac-> dwSourceMask
                );

        if ( pse == NULL )
        {
            TRACE2(
                ANY, "InvokeCreationAlert: Could not find source 0x%x "
                "0x%x",
                pcac-> dwSourceAddr, pcac-> dwSourceMask
                );

            break;
        }


        if (GetOutInterfaceEntry(
                &pse-> leOutIfList,
                pcac-> dwIfIndex, pcac-> dwIfNextHopAddr,
                pcac-> dwProtocolId, pcac-> dwComponentId
                ) == NULL)
        {
            TRACE2(
                ANY, "InvokeCreationAlert: Interface 0x%x 0x%x not "
                "present in OIF list",
                pcac-> dwIfIndex, pcac-> dwIfNextHopAddr
                );

            break;
        }

        //
        // release locks
        //

        RELEASE_GROUP_ENTRY_LOCK_SHARED( pge );
        bGrpLock = FALSE;

        RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
        bGrpBucket = FALSE;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\sync.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: sync.h
//
// History:
//      V Raman	July-11-1997  Created.
//
// Lock structures and synchronization routines.
// Lock structures borrowed from RIPv2 by Abolade Gbadegesin.
// Dynamic locking idea borrowed from RTM by Vadim Eydelman.
//============================================================================

#ifndef _SYNC_H_
#define _SYNC_H_


//----------------------------------------------------------------------------
//
// Read/Write locks for synchronization of access to various lists
//
// Given the large number of lists (including the various hash buckets) and
// the relatively small number of clients that concurrently invoke MGM 
// API, statically allocating a lock structure for each list was 
// considered expensive.  Locks are created as needed and stored in a 
// stack structure (implemented as a singly linked list) after use.
//
// Subsequent requests for locks are all satisfied by reusing the locks 
// stored on the stack.  Only if the stack is empty ie. all locks in the
// stack are in use are new locks created.
//
// This ensures that the most number of locks created is no larger than
// the maximum number of concurrent clients at any time.
//
// csReadWriteBlock     -       Critical section guarding access to
//                              lReaderCount.
// lReaderCount         -       Count of readers currently using the
//                              shared resource.
// hReaderDoneEvent     -       Event on which writers block when readers
//                              are currently using the lists.
// lUseCount            -       Count of readers + writers.  Used to 
//                              determine if there are any threads waiting
//                              on the lock.  If there are none the lock
//                              can be released to te stack of locks.
//----------------------------------------------------------------------------

typedef struct _MGM_READ_WRITE_LOCK
{
    SINGLE_LIST_ENTRY           sleLockList;
    
    CRITICAL_SECTION            csReaderWriterBlock;
    
    LONG                        lReaderCount;
    
    HANDLE                      hReaderDoneEvent;

    LONG                        lUseCount;
    
} MGM_READ_WRITE_LOCK, *PMGM_READ_WRITE_LOCK;



//----------------------------------------------------------------------------
//
// Read/write locks are created dynamically and stored for
// reuse in a stack struture.  
//
//----------------------------------------------------------------------------

typedef struct _LOCK_LIST
{
    SINGLE_LIST_ENTRY               sleHead;

    CRITICAL_SECTION                csListLock;

    BOOL                            bInit;

} LOCK_LIST, *PLOCK_LIST;



//----------------------------------------------------------------------------
// Standard locked list structure.
//----------------------------------------------------------------------------

typedef struct _MGM_LOCKED_LIST 
{

    LIST_ENTRY                  leHead;

    PMGM_READ_WRITE_LOCK        pmrwlLock;

    DWORD                       dwCreated;
    
} MGM_LOCKED_LIST, *PMGM_LOCKED_LIST;


#define CREATE_LOCKED_LIST( p )                                             \
{                                                                           \
    (p)-> pmrwlLock = NULL;                                                 \
    InitializeListHead( &(p)->leHead );                                     \
    (p)-> dwCreated = 0x12345678;                                           \
}


#define DELETE_LOCKED_LIST( p )                                             \
{                                                                           \
    (p)-> pmrwlLock = NULL;                                                 \
    if ( !IsListEmpty( &(p)-> leHead ) )                                    \
        TRACE0( ANY, "Locked list being deleted is not empty" );            \
    InitializeListHead( &(p)-> leHead );                                    \
    (p)-> dwCreated = 0;                                                    \
}


#define LOCKED_LIST_HEAD( p )   &(p)-> leHead 



//
// Routines to create/delete locks
//

DWORD
CreateReadWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
);

VOID
DeleteReadWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK    pmrwl
);

VOID
DeleteLockList(
);


//
// Routines to acquire and release locks.
//

DWORD
AcquireReadLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
);

VOID
ReleaseReadLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
);


DWORD
AcquireWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
);

VOID
ReleaseWriteLock(
    IN  OUT PMGM_READ_WRITE_LOCK *  ppmrwl
);



#endif // _SYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mprmsg\evttbl.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:


Abstract:


--*/

#pragma once

#include <mprlog.h>

typedef struct _SUBCOMP_ENTRY
{
    PWCHAR          pwszSubComp;
    ULONG           ulEventCount;
    PDWORD          Events;
}SUBCOMP_ENTRY, *PSUBCOMP_ENTRY;

#define CreateSubcompEntry(n, t)    \
    {n, sizeof(t)/sizeof(DWORD), t}

typedef struct _COMP_ENTRY
{
    PWCHAR          pwszComponent;
    ULONG           ulSubcompCount;
    PSUBCOMP_ENTRY  SubcompInfo;
}COMP_ENTRY, *PCOMP_ENTRY;

#define CreateCompEntry(w,t)        \
    {w, sizeof(t)/sizeof(SUBCOMP_ENTRY), t}


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Define your tables here                                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD ppp_auth[] = {
    ROUTERLOG_AUTH_FAILURE,
    ROUTERLOG_AUTH_SUCCESS,
    ROUTERLOG_AUTH_CONVERSATION_FAILURE,
    ROUTERLOG_CANT_ADD_RASSECURITYNAME,
    ROUTERLOG_SESSOPEN_REJECTED,
    ROUTERLOG_SECURITY_NET_ERROR,
    ROUTERLOG_CANNOT_INIT_SEC_ATTRIBUTE,
    ROUTERLOG_CANNOT_REGISTER_LSA,
    ROUTERLOG_AUTH_TIMEOUT,
    ROUTERLOG_AUTH_NO_PROJECTIONS,
    ROUTERLOG_AUTH_INTERNAL_ERROR,
    ROUTERLOG_NO_DIALIN_PRIVILEGE,
    ROUTERLOG_ENCRYPTION_REQUIRED,
    ROUTERLOG_NO_SECURITY_CHECK,
    ROUTERLOG_PASSWORD_EXPIRED,
    ROUTERLOG_ACCT_EXPIRED,
    ROUTERLOG_SEC_AUTH_FAILURE,
    ROUTERLOG_SEC_AUTH_INTERNAL_ERROR,
    ROUTERLOG_AUTH_DIFFUSER_FAILURE,
    ROUTERLOG_LICENSE_LIMIT_EXCEEDED
};

SUBCOMP_ENTRY ppp_table[] = {
    CreateSubcompEntry(L"auth", ppp_auth),
};


COMP_ENTRY ppp_info[]  = {
    CreateCompEntry(L"RemoteAccess", ppp_table),
};

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Add your info to the global table                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

PCOMP_ENTRY g_Components[] = 
{
    ppp_info,
};

ULONG   g_ulCompCount = sizeof(g_Components)/sizeof(PCOMP_ENTRY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\timer.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: timer.h
//
// History:
//      V Raman	June-25-1997  Created.
//
// Prototyes for functions to manage ageing out of MFEs.
//============================================================================

#ifndef _TIMER_H_
#define _TIMER_H_


//----------------------------------------------------------------------------
// TIMER_CONTEXT
//
//  structure used to pass context information to timer routines
//----------------------------------------------------------------------------

typedef struct _TIMER_CONTEXT
{
    DWORD           dwSourceAddr;

    DWORD           dwSourceMask;

    DWORD           dwGroupAddr;

    DWORD           dwGroupMask;

    DWORD           dwIfIndex;

    DWORD           dwIfNextHopAddr;
    
} TIMER_CONTEXT, *PTIMER_CONTEXT;



DWORD
DeleteFromForwarder(
    DWORD                       dwEntryCount,
    PIPMCAST_DELETE_MFE         pimdmMfes
);

VOID
MFETimerProc(
    PVOID                       pvContext,
    BOOLEAN                     pbFlag                        
);

#endif //_TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mprmsg\makefile.inc ===
$(O)\mprmsg.mc: ..\inc\mprlog.h $(SDK_INC_PATH)\mprerror.h $(SDK_INC_PATH)\raserror.h
    mapmsg ROUTER ROUTER_LOG_BASE ..\inc\mprlog.h > $(O)\mprmsg.mc
    mapmsg -a $(O)\mprmsg.mc ROUTER ROUTEBASE $(SDK_INC_PATH)\mprerror.h
    mapmsg -a $(O)\mprmsg.mc ROUTER RASBASE $(SDK_INC_PATH)\raserror.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mgm\timer.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: timer.c
//
// History:
//      V Raman	June-25-1997  Created.
//
// Functions to manager ageing out of MFEs.
//============================================================================


#include "pchmgm.h"
#pragma hdrstop


//----------------------------------------------------------------------------
// DeleteFromForwarder
//
//  This function is an entry point for IP RouterManager.  It is invoked
//  in response to deletion (because of timeouts) of MFEs in the kernel
//  mode forwarder.  This entry point is invoked with a list of deleted
//  MFEs.
//
//  This function flags each of the MFEs that have been deleted by the
//  forwarder as "not present in the forwarder"
//----------------------------------------------------------------------------

DWORD
DeleteFromForwarder(
    DWORD                       dwEntryCount,
    PIPMCAST_DELETE_MFE         pimdmMfes
)
{
    DWORD                       dwInd, dwGrpBucket, dwSrcBucket;

    PGROUP_ENTRY                pge;

    PSOURCE_ENTRY               pse;

    PLIST_ENTRY                 pleHead;

    

    TRACE1( TIMER, "ENTERED DeleteFromForwarder, Entries %x", dwEntryCount );


    //
    // for each MFE that has been deleted from the KMF
    //

    for ( dwInd = 0; dwInd < dwEntryCount; dwInd++ )
    {
        //
        // 1. Lookup the MFE in MGM 
        //

        //
        // 1.1 Find group entry
        //
        
        dwGrpBucket = GROUP_TABLE_HASH( pimdmMfes[ dwInd ].dwGroup, 0 );

        ACQUIRE_GROUP_LOCK_SHARED( dwGrpBucket );

        pleHead = GROUP_BUCKET_HEAD( dwGrpBucket );
        
        pge = GetGroupEntry( pleHead, pimdmMfes[ dwInd ].dwGroup, 0 );

        if ( pge != NULL )
        {
            //
            // 1.2 Group entry found, find source entry
            //

            ACQUIRE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
            
            dwSrcBucket = SOURCE_TABLE_HASH( 
                            pimdmMfes[ dwInd ].dwSource, 
                            pimdmMfes[ dwInd ].dwSrcMask
                            );

            pleHead = SOURCE_BUCKET_HEAD( pge, dwSrcBucket );

            pse = GetSourceEntry(
                     pleHead, 
                     pimdmMfes[ dwInd ].dwSource, 
                     pimdmMfes[ dwInd ].dwSrcMask
                     );

            if ( pse != NULL )
            {
                pse-> bInForwarder = FALSE;
            }

            else
            {
                TRACE2( 
                    TIMER, "DeleteFromForwarder - Source Entry not found : "
                    "( %x, %x )", pimdmMfes[ dwInd ].dwSource, 
                    pimdmMfes[ dwInd ].dwSrcMask
                    ); 
            }

            RELEASE_GROUP_ENTRY_LOCK_EXCLUSIVE( pge );
        }

        else
        {
            TRACE1( 
                TIMER, "DeleteFromForwarder - Group Entry not found : "
                "( %x )", pimdmMfes[ dwInd ].dwGroup 
                ); 
        }

        RELEASE_GROUP_LOCK_SHARED( dwGrpBucket );
    }

    TRACE0( TIMER, "LEAVING DeleteFromForwarder\n" );

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// MFETimerProc
//
//  This function is invoked by the MFE timer mechanism.  
//  It deletes the MFE that has timed out from the source/group table.
//  If the MFE is currently present in the Kernel mode forwarder, then
//  it is deleted from the forwarder as well.
//
//  If this MFE was in use by the forwarder, it will be recreated on the
//  next packet miss.
//
//----------------------------------------------------------------------------

VOID
MFETimerProc(
    PVOID                       pvContext,
    BOOLEAN                     pbFlag                        
)
{
    BOOL                        bUnLock = FALSE, bUnMark = FALSE;
    
    DWORD                       dwIfBucket, dwErr;

    PLIST_ENTRY                 pleIfHead;

    PIF_ENTRY                   pie = NULL;

    PIF_REFERENCE_ENTRY         pire = NULL;

    PTIMER_CONTEXT              ptwc = (PTIMER_CONTEXT) pvContext;
    
    RTM_NET_ADDRESS             rnaSource;

    RTM_DEST_INFO               rdiDestInfo;

    PBYTE                       pbOpaqueInfo = NULL;

    PMGM_LOCKED_LIST            pmllMfeList;

    PROUTE_REFERENCE_ENTRY      prreNew = NULL;



    TRACE4( 
        TIMER, "ENTERED MFETimerProc, Source : %x %x, Group : %x %x",
        ptwc-> dwSourceAddr, ptwc-> dwSourceMask,
        ptwc-> dwGroupAddr, ptwc-> dwGroupMask
        );


    do
    {
        //
        // delete the reference to this MFE in the route used for its RPF
        //

        do
        {
            //
            // Lookup route to source
            //

            RTM_IPV4_MAKE_NET_ADDRESS( 
                &rnaSource, ptwc-> dwSourceAddr, IPv4_ADDR_LEN
                );

            dwErr = RtmGetMostSpecificDestination(
                        g_hRtmHandle, &rnaSource, RTM_BEST_PROTOCOL,
                        RTM_VIEW_MASK_MCAST, &rdiDestInfo
                        );
                        
            if ( dwErr != NO_ERROR )
            {
                TRACE2(
                    ANY, "No Route to source %x, %d", ptwc-> dwSourceAddr, 
                    dwErr 
                    );

                break;
            }


            //
            // Lock the dest
            //

            dwErr = RtmLockDestination(
                        g_hRtmHandle, rdiDestInfo.DestHandle, TRUE, TRUE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to lock dest %x", dwErr );

                break;
            }

            bUnLock = TRUE;


            //
            // Get the opaque pointer
            //

            dwErr = RtmGetOpaqueInformationPointer(
                        g_hRtmHandle, rdiDestInfo.DestHandle, &pbOpaqueInfo
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to retrieve opaque pointer %x", dwErr );

                break;
            }


            //
            // if opaque info is present
            //
            
            if ( *( ( PBYTE * ) pbOpaqueInfo ) != NULL )
            {
                pmllMfeList = ( PMGM_LOCKED_LIST ) *( ( PBYTE *) pbOpaqueInfo );

                ACQUIRE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );

                //
                // delete the rre from the list
                //

                if ( FindRouteRefEntry(
                        &pmllMfeList-> leHead, ptwc-> dwSourceAddr, 
                        ptwc-> dwSourceMask, ptwc-> dwGroupAddr, 
                        ptwc-> dwGroupMask, &prreNew
                        ) )
                {
                    DeleteRouteRef( prreNew );
                }

                else
                {
                    TRACE1(
                        ANY, "Reference does not exist for source %x", 
                        ptwc-> dwSourceAddr
                        );
                }

                //
                // if there are no more references to this dest, delete the locked list
                //

                if ( IsListEmpty( &pmllMfeList-> leHead ) )
                {
                    //
                    // Clear opaque pointer info
                    //

                    *( ( PBYTE * ) pbOpaqueInfo ) = NULL;

                    //
                    // release list lock
                    //

                    RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );

                    MGM_FREE( pmllMfeList );


                    //
                    // unmark the dest.  Change notifications for this
                    // dest are no longer required.
                    //

                    bUnMark = TRUE;
                }

                else
                {
                    //
                    // release the list lock
                    //

                    RELEASE_ROUTE_LOCK_EXCLUSIVE( pmllMfeList );
                }
                
                dwErr = NO_ERROR;
            }
            
        } while ( FALSE );
        

        //
        // Unlock dest
        //

        if ( bUnLock )
        {
            dwErr = RtmLockDestination(
                        g_hRtmHandle, rdiDestInfo.DestHandle,
                        TRUE, FALSE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to unlock dest : %x", dwErr );
            }
        }


        //
        // Unmark dest
        //

        if ( bUnMark )
        {
            dwErr = RtmMarkDestForChangeNotification(
                        g_hRtmHandle, g_hNotificationHandle,
                        rdiDestInfo.DestHandle, FALSE
                        );

            if ( dwErr != NO_ERROR )
            {
                TRACE1( ANY, "Failed to unmark DEST: %x", dwErr );
            }
        }

        
        //
        // delete the MFE and the reference to it in the 
        // incoming interface entry
        //

        //
        // find If entry for incomng interface of the MFE
        //

        dwIfBucket = IF_TABLE_HASH( ptwc-> dwIfIndex );

        ACQUIRE_IF_LOCK_EXCLUSIVE( dwIfBucket );

        pleIfHead = IF_BUCKET_HEAD( dwIfBucket );

        if ( !FindIfEntry( 
                pleIfHead, ptwc-> dwIfIndex, ptwc-> dwIfNextHopAddr, &pie ) )
        {
            //
            // specified incoming interface does not exist, 
            // this is an error condition.  All MFEs using this 
            // interface should have been deleted when this interface
            // was removed.  print an error message and quit.
            //

            TRACE2( 
                ANY, "MFETimerProc has invalid incoming interface : %x, %x",
                ptwc-> dwIfIndex, ptwc-> dwIfNextHopAddr
                );

            TRACE4(
                ANY, "Source : %x %x, Group : %x %x", 
                ptwc-> dwSourceAddr, ptwc-> dwSourceMask,
                ptwc-> dwGroupAddr, ptwc-> dwGroupMask
                );

            break;
        }

        LookupAndDeleteYourMfe( 
            ptwc-> dwSourceAddr, ptwc-> dwSourceMask, 
            ptwc-> dwGroupAddr, ptwc-> dwGroupMask, 
            TRUE, NULL, NULL
            );


        //
        // delete reference to this MFE from the incoming refeence list
        // for this interface
        //

        pleIfHead = &pie-> leInIfList;

        if ( !FindRefEntry( pleIfHead, ptwc-> dwSourceAddr, ptwc-> dwSourceMask,
                ptwc-> dwGroupAddr, ptwc-> dwGroupMask, &pire )  )
        {
            //
            // Apparently this interface is not reference by the specified
            // MFE.  This is a non-critical error.  Log a message too track
            // this condition.
            //

            TRACE2( 
                ANY, "MFETimerProc : No reference for interface : %x, %x",
                ptwc-> dwIfIndex, ptwc-> dwIfNextHopAddr
                );

            TRACE4(
                ANY, "Source : %x %x, Group : %x %x", 
                ptwc-> dwSourceAddr, ptwc-> dwSourceMask,
                ptwc-> dwGroupAddr, ptwc-> dwGroupMask
                );

            break;
        }


        RemoveEntryList( &pire-> leRefList );

        MGM_FREE( pire );
        
    } while ( FALSE );


    RELEASE_IF_LOCK_EXCLUSIVE( dwIfBucket );

    //
    // release route reference.
    //

    MGM_FREE( ptwc );

    TRACE0( TIMER, "LEAVING MFETimerProc\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\asyframe.h ===
#define 	RECV_OVERFLOW	10  // preamb + postamb + ?

#define 	RESYNC_LEN		10 	// size of rcv default buffer


//*********** ASYNC PROTOCOL DEFINITIONS AND STRUCTURES *****************
#define		SOH_BCAST		0x01
#define		SOH_DEST		0x02

// if a type field exists, OR in this bit (i.e. TCP/IP,  IPX)
#define		SOH_TYPE		0x80

// if the frame went through coherency, OR in this bit
#define		SOH_COMPRESS	0x40

// if the frame has escape characters removed (ASCII 0-31) set this.
#define		SOH_ESCAPE		0x20


#define		SYN				0x16
#define		ETX				0x03

//*********** FRAME STRUCTURES
typedef struct preamble preamble;
struct preamble {

	UCHAR		syn;
	UCHAR		soh;
};

typedef struct postamble postamble;

struct postamble {

	UCHAR		etx;
	UCHAR		crclsb;
	UCHAR		crcmsb;
};


//*** Frame parsing....
#define     ETHERNET_HEADER_SIZE    14


//*** Ethernet type header
typedef struct ether_addr ether_addr;

struct ether_addr {
		UCHAR   dst[6];
	    UCHAR   src[6];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\mprmsg\mprmsg.c ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <crt\stddef.h>

#include "evttbl.h"

BOOL
WINAPI
DLLMAIN(
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID pUnused
    ) 
{
    switch(dwReason) {
        case DLL_PROCESS_ATTACH:

            DisableThreadLibraryCalls(hInstance);

            break;

        case DLL_PROCESS_DETACH:

            break;

        default:

            break;
    }

    return TRUE;
}

DWORD
GetEventIds(
    IN  PWCHAR  pwszComponent,
    IN  PWCHAR  pwszSubComponent,
    OUT PDWORD  pdwEventIds,
    OUT PULONG  pulEventCount
    )
{
    ULONG   i;

    PSUBCOMP_ENTRY  pInfo;

    pInfo = NULL;

    for(i = 0; i < g_ulCompCount; i++)
    {
        ULONG   j;

        if(_wcsicmp(pwszComponent,
                    g_Components[i]->pwszComponent) != 0)
        {
            continue;
        }

        for(j = 0; j < g_Components[i]->ulSubcompCount; j++)
        {
            if(_wcsicmp(pwszSubComponent,
                        g_Components[i]->SubcompInfo[j].pwszSubComp) == 0)
            {
                pInfo = &(g_Components[i]->SubcompInfo[j]);
                
                break;
            }
        }

        if(pInfo)
        {
            break;
        }
    }

    if(pInfo == NULL)
    {
        return ERROR_NOT_FOUND;
    }

    if(pInfo->ulEventCount > *pulEventCount)
    {
        *pulEventCount = pInfo->ulEventCount;

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pulEventCount = pInfo->ulEventCount;

    CopyMemory(pdwEventIds,
               pInfo->Events,
               (sizeof(DWORD) * pInfo->ulEventCount));
        
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\asyncall.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    asyncall.h

Abstract:

     This code include most of the 'h' files for rashub.c

Author:

    Thomas J. Dimitri (TommyD) 29-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

/* This flag enables the retrofitted support for old RAS compression and
** coherency, i.e. the scheme available on WFW311 and NT31 clients.  This
** support was added post-NT35 for inclusion in the NT-PPC release.  It looks
** to NDISWAN like a hardware specific compression.  (SteveC)
**
** Note: The 'CompressBCast' feature that allows user to control whether
**       broadcast frames are compressed is not supported here because the
**       ethernet header (from which NT31 determined a frame was a broadcast)
**       is not available in the new NDISWAN interface.  This was a tuning
**       feature, where data not likely to repeat (broadcasts) were eliminated
**       from the pattern buffer.  There should not be any functional problems
**       simply compressing broadcast frames since the receiver determines
**       whether decompression is required regardless of this setting.  Given
**       this, it's a mystery why TommyD bothered negotiating this with the
**       peer.  To avoid hitting non-default code paths on the clients we will
**       simply negotiate the old default (no compression), but will still
**       compress everything on the outgoing path.
*/

#include <ndis.h>
#include <ndiswan.h>
#include <asyncpub.h>

#include <xfilter.h>
#include <ntddser.h>

#include "asynchrd.h"

#include "frame.h"
#include "asyncsft.h"
#include "globals.h"
#include "asyframe.h"

//
//  Global constants.
//


#define PPP_ALL     (PPP_FRAMING | \
                     PPP_COMPRESS_ADDRESS_CONTROL | \
                     PPP_COMPRESS_PROTOCOL_FIELD | \
                     PPP_ACCM_SUPPORTED)

#define SLIP_ALL    (SLIP_FRAMING | \
                     SLIP_VJ_COMPRESSION | \
                     SLIP_VJ_AUTODETECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\asynchrd.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    async.c

Abstract:

    The main program for a ASYNC (Local Area Network Controller
    Am 7990) MAC driver.

Author:

    Anthony V. Ercolano (tonye) creation-date 19-Jun-1990

Environment:

    This driver is expected to work in DOS, OS2 and NT at the equivalent
    of kernal mode.

    Architecturally, there is an assumption in this driver that we are
    on a little endian machine.

Notes:

    optional-notes

Revision History:


--*/

#ifndef _ASYNCHARDWARE_
#define _ASYNCHARDWARE_

//
// All registers on the ASYNC are 16 bits.
//



//
// Masks for the normal summary bits in the transmit descriptor.
//
#define ASYNC_TRANSMIT_END_OF_PACKET       ((UCHAR)(0x01))
#define ASYNC_TRANSMIT_START_OF_PACKET     ((UCHAR)(0x02))
#define ASYNC_TRANSMIT_DEFERRED            ((UCHAR)(0x04))
#define ASYNC_TRANSMIT_ONE_RETRY           ((UCHAR)(0x08))
#define ASYNC_TRANSMIT_MORE_THAN_ONE_RETRY ((UCHAR)(0x10))
#define ASYNC_TRANSMIT_ANY_ERRORS          ((UCHAR)(0x40))
#define ASYNC_TRANSMIT_OWNED_BY_CHIP       ((UCHAR)(0x80))

//
// Set of masks to recover particular errors that a transmit can encounter.
//
#define ASYNC_TRANSMIT_TDR            ((USHORT)(0x03ff))
#define ASYNC_TRANSMIT_RETRY          ((USHORT)(0x0400))
#define ASYNC_TRANSMIT_LOST_CARRIER   ((USHORT)(0x0800))
#define ASYNC_TRANSMIT_LATE_COLLISION ((USHORT)(0x0100))
#define ASYNC_TRANSMIT_UNDERFLOW      ((USHORT)(0x4000))
#define ASYNC_TRANSMIT_BUFFER         ((USHORT)(0x8000))


#endif // _ASYNCHARDWARE_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\asyncmac.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    async.c

Abstract:

    This is the main file for the AsyncMAC Driver for the Remote Access
    Service.  This driver conforms to the NDIS 3.0 interface.

    This driver was adapted from the LANCE driver written by
    TonyE.

    NULL device driver code from DarrylH.

    The idea for handling loopback and sends simultaneously is largely
    adapted from the EtherLink II NDIS driver by Adam Barr.

Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#include "asyncall.h"

// asyncmac.c will define the global parameters.
#define GLOBALS
#include "globals.h"


NDIS_HANDLE NdisWrapperHandle;
PDRIVER_OBJECT  AsyncDriverObject;
NDIS_HANDLE     AsyncDeviceHandle;
NPAGED_LOOKASIDE_LIST   AsyncIoCtxList;
NPAGED_LOOKASIDE_LIST   AsyncInfoList;
ULONG   glConnectionCount = 0;

VOID
AsyncUnload(
    IN NDIS_HANDLE MacMacContext
    );

NDIS_STATUS
AsyncFillInGlobalData(
    IN PASYNC_ADAPTER Adapter,
    IN PNDIS_REQUEST NdisRequest);

//
// Define the local routines used by this driver module.
//

NTSTATUS
AsyncIOCtlRequest(
    IN PIRP pIrp,                       // Pointer to I/O request packet
    IN PIO_STACK_LOCATION pIrpSp        // Pointer to the IRP stack location
);


//
// ZZZ Portable interface.
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath)


/*++

Routine Description:

    This is the primary initialization routine for the async driver.
    It is simply responsible for the intializing the wrapper and registering
    the MAC.  It then calls a system and architecture specific routine that
    will initialize and register each adapter.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The status of the operation.

--*/

{
    NDIS_STATUS InitStatus;
    NDIS_MINIPORT_CHARACTERISTICS AsyncChar;

    //
    // Initialize some globals
    //
    ExInitializeNPagedLookasideList(&AsyncIoCtxList,
        NULL,
        NULL,
        0,
        sizeof(ASYNC_IO_CTX),
        ASYNC_IOCTX_TAG,
        0);

    ExInitializeNPagedLookasideList(&AsyncInfoList,
        NULL,
        NULL,
        0,
        sizeof(ASYNC_INFO),
        ASYNC_INFO_TAG,
        0);

    NdisAllocateSpinLock(&GlobalLock);

    AsyncDriverObject = DriverObject;

    //
    //  Initialize the wrapper.
    //
    NdisMInitializeWrapper(&NdisWrapperHandle,
                           DriverObject,
                           RegistryPath,
                           NULL);

    //
    //  Initialize the MAC characteristics for the call to NdisRegisterMac.
    //
    NdisZeroMemory(&AsyncChar, sizeof(AsyncChar));

    AsyncChar.MajorNdisVersion = ASYNC_NDIS_MAJOR_VERSION;
    AsyncChar.MinorNdisVersion = ASYNC_NDIS_MINOR_VERSION;
    AsyncChar.Reserved = NDIS_USE_WAN_WRAPPER;

    //
    // We do not need the following handlers:
    // CheckForHang
    // DisableInterrupt
    // EnableInterrupt
    // HandleInterrupt
    // ISR
    // Send
    // TransferData
    //
    AsyncChar.HaltHandler = MpHalt;
    AsyncChar.InitializeHandler = MpInit;
    AsyncChar.QueryInformationHandler = MpQueryInfo;
    AsyncChar.ReconfigureHandler = MpReconfigure;
    AsyncChar.ResetHandler = MpReset;
    AsyncChar.WanSendHandler = MpSend;
    AsyncChar.SetInformationHandler = MpSetInfo;

    InitStatus =
    NdisMRegisterMiniport(NdisWrapperHandle,
                          &AsyncChar,
                          sizeof(AsyncChar));

    if ( InitStatus == NDIS_STATUS_SUCCESS ) {

#if MY_DEVICE_OBJECT
        //
        // Initialize the driver object with this device driver's entry points.
        //
        NdisMjDeviceControl = DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL];
        NdisMjCreate = DriverObject->MajorFunction[IRP_MJ_CREATE];
        NdisMjCleanup = DriverObject->MajorFunction[IRP_MJ_CLEANUP];

        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = AsyncDriverDispatch;
        DriverObject->MajorFunction[IRP_MJ_CREATE]  = AsyncDriverCreate;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP]  = AsyncDriverCleanup;

        AsyncSetupExternalNaming(DriverObject);
#endif

        NdisUnload = DriverObject->DriverUnload;
        DriverObject->DriverUnload = AsyncUnload;

        DbgTracef(0,("AsyncMAC succeeded to Register MAC\n"));

        return NDIS_STATUS_SUCCESS;
    }

    ExDeleteNPagedLookasideList(&AsyncIoCtxList);
    ExDeleteNPagedLookasideList(&AsyncInfoList);

    NdisTerminateWrapper(NdisWrapperHandle, DriverObject);

    return NDIS_STATUS_FAILURE;
}

NTSTATUS
AsyncDriverCreate(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
{
    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if (pDeviceObject != AsyncDeviceObject) {

        return(NdisMjCreate(pDeviceObject, pIrp));
    }
#endif

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return (STATUS_SUCCESS);

}

NTSTATUS
AsyncDriverCleanup(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
{
    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if (pDeviceObject != AsyncDeviceObject) {

        return(NdisMjCleanup(pDeviceObject, pIrp));
    }
#endif

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return (STATUS_SUCCESS);
}

NTSTATUS
AsyncDriverDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)

/*++

Routine Description:

    This routine is the main dispatch routine for the AsyncMac device
    driver.  It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.


--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    ULONG   ulDeviceType;
    ULONG   ulMethod;

    // 
    // if this is win64 make sure the calling process is 64bit
    // since this interface is only used by rasman and rasman
    // will always be 64bit on 64bit systems we will not bother
    // with thunking.  if the process is not a 64bit process get
    // out.
#ifdef _WIN64
    if (IoIs32bitProcess(Irp)) {
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return (STATUS_NOT_SUPPORTED);
    }
#endif

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ulDeviceType = (irpSp->Parameters.DeviceIoControl.IoControlCode >> 16) & 0x0000FFFF;
    ulMethod = irpSp->Parameters.DeviceIoControl.IoControlCode & 0x00000003;

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if ((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
        (ulDeviceType != FILE_DEVICE_ASYMAC) ||
        (DeviceObject != AsyncDeviceObject)) {

        return(NdisMjDeviceControl(DeviceObject, Irp));
    }
#else
    if ((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
        (ulDeviceType != FILE_DEVICE_NETWORK) ||
        (DeviceObject != AsyncDeviceObject) ||
        (ulMethod != METHOD_BUFFERED)) {

        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return (STATUS_NOT_SUPPORTED);
    }
#endif

    status = AsyncIOCtlRequest(Irp, irpSp);

    switch (status) {
        case STATUS_SUCCESS:
            break;

        case STATUS_PENDING:
            return(status);

        case STATUS_INFO_LENGTH_MISMATCH:
            //
            // See if this was a request to get size needed for
            // ioctl.
            //
            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= 
                sizeof(ULONG)) {
                *(PULONG_PTR)Irp->AssociatedIrp.SystemBuffer = 
                    Irp->IoStatus.Information;
                Irp->IoStatus.Information = sizeof(ULONG);
            } else {
                Irp->IoStatus.Information = 0;
            }
            status = STATUS_SUCCESS;
        break;

        default:
            if (status < 0xC0000000) {
                status = STATUS_UNSUCCESSFUL;
            }
            Irp->IoStatus.Information = 0;
            break;
    }

    //
    // Copy the final status into the return status, 
    // complete the request and get out of here.
    //

    Irp->IoStatus.Status = status;

    IoCompleteRequest( Irp, (UCHAR)0 );

    return (status);
}

VOID
AsyncUnload(
    PDRIVER_OBJECT  DriverObject
    )

/*++

Routine Description:

    AsyncUnload is called when the MAC is to unload itself.

Arguments:

    MacMacContext - not used.

Return Value:

    None.

--*/

{
    ExDeleteNPagedLookasideList(&AsyncIoCtxList);
    ExDeleteNPagedLookasideList(&AsyncInfoList);

#ifdef MY_DEVICE_OBJECT
    AsyncCleanupExternalNaming();
#endif

    (*NdisUnload)(DriverObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\debug.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\asyncsft.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    asyncsft.h

Abstract:


Author:


Environment:

    This driver is expected to work in DOS, OS2 and NT at the equivalent
    of kernal mode.

    Architecturally, there is an assumption in this driver that we are
    on a little endian machine.

Notes:

    optional-notes

Revision History:


--*/

#ifndef _ASYNCSFT_
#define _ASYNCSFT_

//
// Memory tags
//
#define ASYNC_IOCTX_TAG     '1ysA'
#define ASYNC_INFO_TAG      '2ysA'
#define ASYNC_ADAPTER_TAG   '3ysA'
#define ASYNC_FRAME_TAG     '4ysA'
#define ASYNC_WORKITEM_TAG  '5ysA'

#define INLINE  __inline

//
//  UINT min(UINT a, UINT b)
//

#ifndef min
#define min(a, b)   ((a) <= (b) ? (a) : (b))
#endif

//
//  UINT max(UINT a, UINT b)
//

#ifndef max
#define max(a, b)   ((a) >= (b) ? (a) : (b))
#endif


#define MAKEWORD(l, h)                  ((USHORT) ((l) | ((h) << 8)))
#define MAKELONG(l, h)                  ((ULONG)  ((l) | ((h) << 16)))
#define MAKE_SIGNATURE(a, b, c, d)      MAKELONG(MAKEWORD(a, b), MAKEWORD(c, d))


#define ASYNC_NDIS_MAJOR_VERSION 4
#define ASYNC_NDIS_MINOR_VERSION 0

//  change these, just added these to compile.

#define ETHERNET_HEADER_SIZE    14

//  what window size to request on the line-up indication

#define ASYNC_WINDOW_SIZE       2

//
//  PPP uses CIPX, and VJ TCP/IP header compression
//  the frame gets expanded inplace when decompressed.
//

#define PPP_PADDING 128

#define MAC_NAME_SIZE           256

//
//  ZZZ These macros are peculiar to NT.
//

#define ASYNC_MOVE_MEMORY(Destination,Source,Length)  NdisMoveMemory(Destination,Source,Length)
#define ASYNC_ZERO_MEMORY(Destination,Length)         NdisZeroMemory(Destination,Length)


/* Added this macro to eliminate problems caused by Tommy's redefinition and
** hard-coding of MaxFrameSize for PPP.
*/
#define MaxFrameSizeWithPppExpansion(x) (((x)*2)+PPP_PADDING+100)

typedef struct _OID_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    PVOID           Context;
} OID_WORK_ITEM, *POID_WORK_ITEM;

//
//  Used to contain a queued operation.
//

typedef struct _ASYNC_PEND_DATA {
    PNDIS_REQUEST Next;
    struct _ASYNC_OPEN * Open;
    NDIS_REQUEST_TYPE RequestType;
} ASYNC_PEND_DATA, * PASYNC_PEND_DATA;


// o CRC errors are when the 16bit V.41 CRC check fails
// o TimeoutErrors occur when inter-character delays within
//   a frame are exceeded
// o AlignmentErrors occur when the SYN byte or ETX bytes which
//   mark the beginning and end of frames are not found.
// o The other errors are standard UART errors returned by the serial driver
typedef struct SERIAL_STATS SERIAL_STATS, *PSERIAL_STATS;
struct SERIAL_STATS {
    ULONG       CRCErrors;                      // Serial-like info only
    ULONG       TimeoutErrors;                  // Serial-like info only
    ULONG       AlignmentErrors;                // Serial-like info only
    ULONG       SerialOverrunErrors;            // Serial-like info only
    ULONG       FramingErrors;                  // Serial-like info only
    ULONG       BufferOverrunErrors;            // Serial-like info only
};

// The bytes transmitted, bytes received, frames received, frame transmitted
// are monitored for frame and bytes going to the output device or
// coming from the output device.  If software compression used, it
// is on top of this layer.
typedef struct GENERIC_STATS GENERIC_STATS, *PGENERIC_STATS;
struct GENERIC_STATS {
    ULONG       BytesTransmitted;               // Generic info
    ULONG       BytesReceived;                  // Generic info
    ULONG       FramesTransmitted;              // Generic info
    ULONG       FramesReceived;                 // Generic info
};

//
//  This macro will return a pointer to the reserved area of
//  a PNDIS_REQUEST.
//

#define PASYNC_PEND_DATA_FROM_PNDIS_REQUEST(Request) \
   ((PASYNC_PEND_DATA)((PVOID)((Request)->MacReserved)))

//
//  This macros returns the enclosing NdisRequest.
//

#define PNDIS_REQUEST_FROM_PASYNC_PEND_DATA(PendOp)\
   ((PNDIS_REQUEST)((PVOID)(PendOp)))

typedef struct ASYNC_CCB ASYNC_CCB, *PASYNC_CCB;

//  Every port will be atomically at some state.  Typically states go into
//  intermediate states when they go from from closed to open and vice-versa.

typedef enum _ASYNC_PORT_STATE {
    PORT_BOGUS,         //  PORT_BOGUS gets assigned the NULL value
    PORT_OPEN,          //  Port opened
    PORT_CLOSED,        //  Port closed
    PORT_CLOSING,       //  Port closing (cleaning up, deallocating)
    PORT_OPENING,       //  Port opening (checking arguments, allocating)
    PORT_FRAMING,       //  Port opened and sending/reading frames
} ASYNC_PORT_STATE;

#if DBG

typedef struct _PENDING_REQUEST
{
    LIST_ENTRY le;
    VOID *pvContext;
    ULONG Sig;
    ULONG lineNum;
} PENDING_REQUEST;

#define REF_ASYNCINFO(_pai, _context)                               \
{                                                                   \
    PENDING_REQUEST * _Request;                                     \
    ASSERT((_pai)->RefCount > 0);                                   \
    InterlockedIncrement(&(_pai)->RefCount);                        \
    _Request = ExAllocatePoolWithTag(NonPagedPool,                  \
                                    sizeof(PENDING_REQUEST),        \
                                    'nepA');                        \
    if(NULL  != _Request)                                           \
    {                                                               \
        _Request->pvContext = _context;                             \
        _Request->Sig = __FILE_SIG__;                               \
        _Request->lineNum = __LINE__;                               \
        InsertTailList(&_pai->lePendingRequests, &_Request->le);    \
    }                                                               \
}                                                                   \


#define DEREF_ASYNCINFO(_pai, _context)                             \
{                                                                   \
    if(NULL != (_pai))                                              \
    {                                                               \
        LIST_ENTRY *_ple;                                           \
        NdisAcquireSpinLock(&(_pai)->Lock);                         \
        ASSERT((_pai)->RefCount > 0);                               \
        InterlockedDecrement(&(_pai)->RefCount);                    \
        if((_pai)->RefCount == 0)                                   \
        {                                                           \
            KeSetEvent(&(_pai)->AsyncEvent, 1,                      \
                        FALSE);                                     \
        }                                                           \
        for (_ple = _pai->lePendingRequests.Flink;                  \
             _ple != &_pai->lePendingRequests;                      \
             _ple = _ple->Flink)                                    \
        {                                                           \
            if(((PENDING_REQUEST *)_ple)->pvContext == _context)   \
            {                                                       \
                RemoveEntryList(_ple);                              \
                ExFreePoolWithTag(_ple, 'nepA');                    \
                break;                                              \
            }                                                       \
        }                                                           \
        NdisReleaseSpinLock(&(_pai)->Lock);                         \
    }                                                               \
}                                                                   \

#else

#define REF_ASYNCINFO(_pai, _context)               \
{                                                   \
    ASSERT((_pai)->RefCount > 0);                   \
    InterlockedIncrement(&(_pai)->RefCount);        \
}                                                   \

#define DEREF_ASYNCINFO(_pai, _context)             \
{                                                   \
    if(NULL != (_pai))                              \
    {                                               \
        NdisAcquireSpinLock(&(_pai)->Lock);         \
        ASSERT((_pai)->RefCount > 0);               \
        InterlockedDecrement(&(_pai)->RefCount);    \
        if((_pai)->RefCount == 0)                   \
        {                                           \
            KeSetEvent(&(_pai)->AsyncEvent, 1,      \
                        FALSE);                     \
        }                                           \
        NdisReleaseSpinLock(&(_pai)->Lock);         \
    }                                               \
}                                                   \

#endif

//
//  The ASYNC_INFO structure is a per port field.  The ASYNC_CONNECTION
//  field is embedded in it because it also a per port field.
//

struct ASYNC_INFO {
    LIST_ENTRY          Linkage;
    ULONG               RefCount;
    ULONG               Flags;
#define OID_WORK_SCHEDULED              0x00000001
#define ASYNC_FLAG_CHECK_COMM_STATUS    0x00000002
#define ASYNC_FLAG_ASYNCMAC_OPEN        0x00000004
#define ASYNC_FLAG_SET_LINK_INFO        0x00000008
#define ASYNC_FLAG_SEND_PACKET          0x00000010
#define ASYNC_FLAG_SLIP_READ            0x00000020
#define ASYNC_FLAG_PPP_READ             0x00000040
#define ASYNC_FLAG_WAIT_MASK            0x00000080

    PASYNC_ADAPTER      Adapter;        //  Back pointer to ADAPTER struct.
    PDEVICE_OBJECT      DeviceObject;   //  Pointer to device object.

    ASYNC_PORT_STATE    PortState;      //  OPEN, CLOSED, CLOSING, OPENING
    HANDLE              Handle;         //  Port handle
    PFILE_OBJECT        FileObject;     //  handle is dereferenced for IRPs
    KEVENT              ClosingEvent;   //  we use this event to synch closing
    KEVENT              DetectEvent;    //  sync the detect worker
    KEVENT              AsyncEvent;     // async event

    UINT                QualOfConnect;  //  Defined by NDIS
    ULONG               LinkSpeed;      //  in 100bps

    NDIS_HANDLE         hNdisEndPoint;
    NDIS_HANDLE         NdisLinkContext;
    LIST_ENTRY          DDCDQueue;


    ULONG               WaitMaskToUse ; // Wait mask used for reads.

    union {

        NDIS_WAN_GET_LINK_INFO  GetLinkInfo;    //... For OID requests.
        NDIS_WAN_SET_LINK_INFO  SetLinkInfo;

    };

    //  use for reading frames

    PASYNC_FRAME        AsyncFrame;     //  allocated for READs (one frame only)
    WORK_QUEUE_ITEM     WorkItem;       //  use to queue up first read thread
    UINT                BytesWanted;
    UINT                BytesRead;

    //... Statistics tracking

    SERIAL_STATS        SerialStats;    // Keep track of serial stats

    ULONG               In;
    ULONG               Out;
    UINT                ReadStackCounter;

    ULONG               ExtendedACCM[8];    //Extended ACCM bit masks (256 bits)
    
    NDIS_SPIN_LOCK      Lock;

#if DBG

    ULONG               Pppreads;

    ULONG               PppreadsCompleted;

    LIST_ENTRY          lePendingRequests;

#endif
    
};


//
//  This structure, and it corresponding per port structures are
//  allocated when we get AddAdapter.
//

struct ASYNC_ADAPTER {

    //
    //  WAN information. for OID_WAN_GET_INFO request.
    //
    NDIS_WAN_INFO   WanInfo;

    //
    //  Keeps a reference count on the current number of uses of
    //  this adapter block.  Uses is defined to be the number of
    //  routines currently within the "external" interface.
    //
    LONG    RefCount;

    //
    // List of active ports
    //
    LIST_ENTRY  ActivePorts;

    //
    //  Spinlock to protect fields in this structure..
    //
    NDIS_SPIN_LOCK Lock;

    //
    //  Handle given by NDIS at MPInit
    //
    NDIS_HANDLE MiniportHandle;

    //
    //  Flag that when enabled lets routines know that a reset
    //  is in progress.
    //
    BOOLEAN ResetInProgress;

/*
    LIST_ENTRY  FramePoolHead;

    LIST_ENTRY  AllocPoolHead;
*/

    //  It will handle most file operations and transport
    //  operations known today.  You pay about 44 bytes
    //  per stacksize.  The registry parameter 'IrpStackSize'
    //  will change this default if it exists.
    UCHAR IrpStackSize;

    //  Here we default to the ethernet max frame size
    //  The regsitry parameter 'MaxFrameSize' will change
    //  this default if it exists.

    /* Note: This is meaningful only for non-PPP framing.  For PPP framing the
    **       value is currently the hard-coded DEFAULT_PPP_MAX_FRAME_SIZE.
    **       See also DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE;
    */
    ULONG MaxFrameSize;

    //
    //  Number of ports this adapter owns.
    //
    USHORT      NumPorts;

    //  How many frames to allocate per port.
    //  The registry parameter 'FramesPerPort' can change this value
    USHORT FramesPerPort;

    //  Minimum inter character timeout
    ULONG   TimeoutBase;

    //  Tacked on to TimeoutBase based on the baud rate
    ULONG   TimeoutBaud;

    //  Timeout to use to resync if a frame is dropped
    ULONG   TimeoutReSync;

    //
    // Serial driver should only complete sends when the
    // data hits the wire
    //
    ULONG   WriteBufferingEnabled;

    //
    // Used to flag if we should escape the XON/XOFF characters
    // with the parity bit set (0x91, 0x93)
    //
    ULONG   ExtendedXOnXOff;
    
    NPAGED_LOOKASIDE_LIST   AsyncFrameList;
};

//
//  Define Maximum number of bytes a protocol can read during a
//  receive data indication.
//
#define ASYNC_MAX_LOOKAHEAD DEFAULT_MAX_FRAME_SIZE

typedef struct _ASYNC_IO_CTX {
    BOOLEAN         Sync;
    KEVENT          Event;          // use this event to signal completion
    IO_STATUS_BLOCK IoStatus;       // use this to store Irp status
    PVOID           Context;
    union {
        SERIAL_STATUS       SerialStatus;
        SERIAL_QUEUE_SIZE   SerialQueueSize;
        SERIAL_TIMEOUTS     SerialTimeouts;
        SERIAL_CHARS        SerialChars;
        SERIAL_COMMPROP     CommProperties;
        UCHAR               EscapeChar;
        UCHAR               SerialPurge;
        ULONG               WaitMask;
        ULONG               WriteBufferingEnabled;
    };
} ASYNC_IO_CTX, *PASYNC_IO_CTX;

//
//  This macro will act a "epilogue" to every routine in the
//  *interface*.  It will check whether any requests need
//  to defer their processing.  It will also decrement the reference
//  count on the adapter.
//
//  NOTE: This really does nothing now since there is no DPC for the AsyncMac.
//  --tommyd
//
//  Note that we don't need to include checking for blocked receives
//  since blocked receives imply that there will eventually be an
//  interrupt.
//
//  NOTE: This macro assumes that it is called with the lock acquired.
//
//  ZZZ This routine is NT specific.
//
#define ASYNC_DO_DEFERRED(Adapter) \
{ \
    PASYNC_ADAPTER _A = (Adapter); \
    _A->References--; \
    NdisReleaseSpinLock(&_A->Lock); \
}


//
//  We define the external interfaces to the async driver.
//  These routines are only external to permit separate
//  compilation.  Given a truely fast compiler they could
//  all reside in a single file and be static.
//

NTSTATUS
AsyncSendPacket(
    IN PASYNC_INFO      AsyncInfo,
    IN PNDIS_WAN_PACKET WanPacket);

VOID
AsyncIndicateFragment(
    IN PASYNC_INFO  pInfo,
    IN ULONG        Error);

NTSTATUS
AsyncStartReads(
    PASYNC_INFO     pInfo);

NTSTATUS
AsyncSetupIrp(
    IN PASYNC_FRAME Frame,
    IN PIRP         irp);

VOID
SetSerialStuff(
    PIRP            irp,
    PASYNC_INFO     pInfo,
    ULONG           linkSpeed);

VOID
CancelSerialRequests(
    PASYNC_INFO     pInfo);

VOID
SetSerialTimeouts(
    PASYNC_INFO         pInfo,
    ULONG               linkSpeed);

VOID
SerialSetEscapeChar(
    PASYNC_INFO         pInfo,
    UCHAR               EscapeChar);

VOID
SerialSetWaitMask(
    PASYNC_INFO         pInfo,
    ULONG               WaitMask);

VOID
SerialSetEventChar(
    PASYNC_INFO         pInfo,
    UCHAR               EventChar);

VOID
InitSerialIrp(
    PIRP                irp,
    PASYNC_INFO         pInfo,
    ULONG               IoControlCode,
    ULONG               InputBufferLength);

NTSTATUS
AsyncAllocateFrames(
    IN  PASYNC_ADAPTER  Adapter,
    IN  UINT            NumOfFrames);

VOID
AsyncSendLineUp(
    PASYNC_INFO pInfo);

//
// mp.c
//
VOID    
MpHalt(
    IN NDIS_HANDLE  MiniportAdapterContext
    );

NDIS_STATUS
MpInit(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN  PNDIS_MEDIUM    MediumArray,
    IN  UINT            MediumArraySize,
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    );

NDIS_STATUS
MpQueryInfo(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    );

NDIS_STATUS
MpReconfigure(
    OUT PNDIS_STATUS    OpenErrorStatus,
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    );

NDIS_STATUS
MpReset(
    OUT PBOOLEAN        AddressingReset,
    IN  NDIS_HANDLE     MiniportAdapterContext
    );

NDIS_STATUS
MpSend(
    IN  NDIS_HANDLE         MiniportAdapterContext,
    IN  NDIS_HANDLE         NdisLinkHandle,
    IN  PNDIS_WAN_PACKET    Packet
    );

NDIS_STATUS
MpSetInfo(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesRead,
    OUT PULONG      BytesNeeded
    );

//
//  crc.c
//

USHORT
CalcCRC(
    PUCHAR  Frame,
    UINT    FrameSize);

//
//  pppcrc.c
//
USHORT
CalcCRCPPP(
    PUCHAR cp,
    UINT   len);


//
//  init.c
//

VOID
AsyncSetupExternalNaming(
    PDRIVER_OBJECT  DriverObject
    );

VOID
AsyncCleanupExternalNaming(VOID);

//
// io.c
//
PASYNC_IO_CTX
AsyncAllocateIoCtx(
    BOOLEAN AllocateSync,
    PVOID   Context
);

VOID
AsyncFreeIoCtx(
    PASYNC_IO_CTX   AsyncIoCtx
);

//
//   chkcomm.c
//

VOID
AsyncCheckCommStatus(
    IN PASYNC_INFO      pInfo);


//
//  send.c
//

NDIS_STATUS
AsyncTryToSendPacket(
    IN NDIS_HANDLE      MacBindingHandle,
    IN PASYNC_INFO      AsyncInfo,
    IN PASYNC_ADAPTER   Adapter);

//
//  pppread.c
//
NTSTATUS
AsyncPPPWaitMask(
    IN PASYNC_INFO Info);

NTSTATUS
AsyncPPPRead(
    IN PASYNC_INFO Info);

//
//  irps.c
//
VOID
AsyncCancelQueued(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp);

VOID
AsyncCancelAllQueued(
    PLIST_ENTRY     QueueToCancel);

VOID
AsyncQueueIrp(
    PLIST_ENTRY     Queue,
    PIRP            Irp);

BOOLEAN
TryToCompleteDDCDIrp(
    PASYNC_INFO     pInfo);

//
//  pppframe.c
//

VOID
AssemblePPPFrame(
    PNDIS_WAN_PACKET Packet);

//
//  slipframe.c
//

VOID
AssembleSLIPFrame(
    PNDIS_WAN_PACKET Packet);

VOID
AssembleRASFrame(
        PNDIS_WAN_PACKET Packet);


//
// serial.c
//
NTSTATUS
SerialIoSyncCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);
    
NTSTATUS
SerialIoAsyncCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);

//
// asyncmac.c
//
NTSTATUS
AsyncDriverDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
AsyncDriverCreate(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

NTSTATUS
AsyncDriverCleanup(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

#endif //  _ASYNCSFT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\crc.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    crc.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/
#include "asyncall.h"

// asyncmac.c will define the global parameters.
#include "globals.h"
#include "crctable.h"


USHORT
CalcCRC(
	register PUCHAR	Frame,
	register UINT	FrameSize)
{

	register USHORT  currCRC=0;

	// we use a do while for efficiency purposes in loop optimizations
	do {
		currCRC=crc_table[((currCRC >> 8) ^ *Frame++) & 0xff] ^ (currCRC << 8);
	} while(--FrameSize);

	return currCRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\crcppp.h ===
//
// u16 represents an unsigned 16-bit number.  Adjust the typedef for
// your hardware.
//

typedef unsigned short u16;


//
// FCS lookup table as calculated by the table generator in section
// B.2.
//

static USHORT fcstab[256] = {
      0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
      0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
      0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
      0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
      0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
      0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
      0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
      0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
      0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
      0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
      0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
      0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
      0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
      0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
      0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
      0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
      0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
      0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
      0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
      0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
      0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
      0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
      0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
      0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
      0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
      0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
      0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
      0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
      0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
      0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
      0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
      0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

#define PPPINITFCS      0xffff  /* Initial FCS value */
#define PPPGOODFCS      0xf0b8  /* Good final FCS value */

//
// Calculate a new fcs given the current fcs and the new data.
//
USHORT
pppfcs(
	UCHAR cp,
	UINT  len)
{
	register USHORT fcs = 0;

	while (len--)
		fcs = (fcs >> 8) ^ fcstab[(fcs ^ *cp++) & 0xff];

	return (fcs);
}













=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\chkcomm.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    chkcomm.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#if DBG

#define __FILE_SIG__    'ckhC'

#endif

#include "asyncall.h"

NTSTATUS
AsyncCheckCommStatusCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)

/*++



--*/
{
    NTSTATUS            status;
    PSERIAL_STATUS      pSerialStatus;
    PASYNC_IO_CTX AsyncIoCtx = (PASYNC_IO_CTX)Context;
    PASYNC_INFO         pInfo=AsyncIoCtx->Context;

    DeviceObject;       // prevent compiler warnings

    status = Irp->IoStatus.Status;
    pSerialStatus=(PSERIAL_STATUS)(Irp->AssociatedIrp.SystemBuffer);

    DbgTracef(0,("ACCSCR: s=$%x\n",status));

    switch (status) {
    case STATUS_SUCCESS:

        if (pSerialStatus->Errors & SERIAL_ERROR_FRAMING) {
            DbgTracef(-1,("ACCSCR: Framing error\n"));
            pInfo->SerialStats.FramingErrors++;
        }

        if (pSerialStatus->Errors & SERIAL_ERROR_OVERRUN) {
            DbgTracef(-1,("ACCSCR: Overrun error \n"));
            pInfo->SerialStats.SerialOverrunErrors++;
        }

        if (pSerialStatus->Errors & SERIAL_ERROR_QUEUEOVERRUN) {
            DbgTracef(-1,("ACCSCR: Q-Overrun error\n"));
            pInfo->SerialStats.BufferOverrunErrors++;
        }

        //
        // Keep proper count of errors
        //
        AsyncIndicateFragment(
            pInfo,
            pSerialStatus->Errors);

        // Fall through...

    default:
        //
        // Free up memory we used to make this call
        //
        IoFreeIrp(Irp);
        AsyncFreeIoCtx(AsyncIoCtx);
    }

    //
    // Deref the ref applied in AsyncCheckCommStatus
    //
    pInfo->Flags &= ~(ASYNC_FLAG_CHECK_COMM_STATUS);
    DEREF_ASYNCINFO(pInfo, Irp);


    //
    //  We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    //

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

VOID
AsyncCheckCommStatus(
    IN PASYNC_INFO  pInfo)
/*++

    This is the Worker Thread entry for reading comm status errors

--*/
{
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    PDEVICE_OBJECT      deviceObject=pInfo->DeviceObject;
    PFILE_OBJECT        fileObject=pInfo->FileObject;
    PASYNC_IO_CTX       AsyncIoCtx;
    NTSTATUS            status;

    irp=IoAllocateIrp(deviceObject->StackSize, (BOOLEAN)FALSE);

    //
    // Are we out of irps?  Oh no!
    //
    if (irp==NULL) {
        return;
    }

    AsyncIoCtx = AsyncAllocateIoCtx(FALSE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;
    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = NULL;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    irp->Flags = IRP_BUFFERED_IO;
    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->SerialStatus;

    irpSp = IoGetNextIrpStackLocation(irp);


    irpSp->FileObject = fileObject;
    if (fileObject->Flags & FO_WRITE_THROUGH) {
        irpSp->Flags = SL_WRITE_THROUGH;
    }


    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.IoControlCode=IOCTL_SERIAL_GET_COMMSTATUS;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(SERIAL_STATUS);

    IoSetCompletionRoutine(
            irp,                            // irp to use
            AsyncCheckCommStatusCompletionRoutine,      // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel


    pInfo->Flags |= ASYNC_FLAG_CHECK_COMM_STATUS;
    //
    // Reference the asyncinfo block so that its still around when
    // the completion routine is called
    //
    REF_ASYNCINFO(pInfo, irp);
    
    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(deviceObject, irp);

    DbgTracef(0,("ACCS: IoctlGetCommStatus returned with 0x%.8x\n", status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\data.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    data.c

Abstract:

     This source file contains global data items.

Author:

    RAy Patch  (raypa) 04/19/94

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#include "asyncall.h"

//
// We use the global below to daisy chain the IOCtl.
//

PDISPATCH_FUNC NdisMjDeviceControl = NULL;
PDISPATCH_FUNC NdisMjCreate = NULL;
PDISPATCH_FUNC NdisMjCleanup = NULL;
PDRIVER_UNLOAD	NdisUnload = NULL;

//
// TraceLevel is used for DbgTracef printing.  If the trace_level
// is less than or equal to TraceLevel, the message will be printed.
//

SCHAR TraceLevel = -2;

//
// This struct keeps track of the last Adapter as well
// as all the Adapters opened so far.
//

PASYNC_ADAPTER	GlobalAdapter = NULL;

//
// Keep track of how many adapters we have total.
//

ULONG GlobalAdapterCount = 0;

//
//  Keep track of sends.
//

ULONG GlobalXmitWentOut = 0;

//
// Use this lock when playing with the GlobalAdapterHead or other
// global variables.
//

NDIS_SPIN_LOCK GlobalLock;

NDIS_PHYSICAL_ADDRESS HighestAcceptableMax = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);

PDEVICE_OBJECT	AsyncDeviceObject = NULL;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\crcppp.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    crcppp.c

Abstract:

Author:

    Thomas J. Dimitri  (TommyD)

Environment:

Revision History:

--*/
#include "asyncall.h"

//
// FCS lookup table as calculated by the table generator in section
// B.2.
//

static USHORT fcstab[256] = {
      0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
      0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
      0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
      0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
      0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
      0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
      0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
      0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
      0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
      0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
      0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
      0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
      0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
      0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
      0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
      0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
      0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
      0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
      0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
      0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
      0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
      0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
      0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
      0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
      0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
      0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
      0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
      0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
      0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
      0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
      0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
      0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

#define PPPINITFCS      0xffff  /* Initial FCS value */
#define PPPGOODFCS      0xf0b8  /* Good final FCS value */

//
// Calculate a new fcs given the current fcs and the new data.
//
USHORT
CalcCRCPPP(
	PUCHAR cp,
	UINT   len)
{
	register USHORT fcs = PPPINITFCS;

	while (len--)
		fcs = (fcs >> 8) ^ fcstab[(fcs ^ *cp++) & 0xff];

	return (fcs);
}













=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\detect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    detect.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#include "asyncall.h"

VOID
SerialFlushReads(
    PASYNC_INFO         pInfo);


NTSTATUS
AsyncDetectCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PASYNC_INFO      pInfo)

/*++

    This is the IO Completion routine for ReadFrame.

--*/
{
    NTSTATUS        status;
    PASYNC_FRAME    pFrame;
    PUCHAR          frameStart;

    DbgTracef(-1,("Entering AsyncDetectCompletionRoutine\n"));

    status = Irp->IoStatus.Status;

    pInfo->BytesRead = (ULONG)Irp->IoStatus.Information;

    IoFreeIrp(Irp);

    pFrame=pInfo->AsyncFrame;

    DbgTracef(2,("DET PortState = %u for Info 0x%.8x\n", pInfo->PortState, pInfo));

    //
    // check if this port is closing down or already closed
    //
    if (pInfo->PortState == PORT_CLOSING ||
        pInfo->PortState == PORT_CLOSED) {

        if (pInfo->PortState == PORT_CLOSED) {
            DbgTracef(-2,("ASYNC: Port closed - but still reading on it!\n"));
        }

        //
        // Acknowledge that the port is closed
        //
        KeSetEvent(
            &pInfo->ClosingEvent,       // Event
            1,                          // Priority
            (BOOLEAN)FALSE);            // Wait (does not follow)

        //
        // Ok, if this happens, we are shutting down.  Stop
        // posting reads.  Don't make it try to deallocate the irp!
        //
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    //
    // If the port is close and we are still posting reads, something
    // is seriously wrong here!
    //

    if (pInfo->PortState == PORT_CLOSED) {
        DbgTracef(-2, ("ASYNC: !!Whoa, I'm reading bytes on a dead port!!\n"));
    }


    //
    //  Send off a irp to check comm status
    //

    AsyncCheckCommStatus(pInfo);

    switch (status) {

    case STATUS_SUCCESS:

        //
        // Look at the first byte and see if we can
        // detect the framing.
        //
        frameStart=pFrame->Frame + PPP_PADDING;

        //
        // NOTE: New RAS framing clients come in with 0x02 not 0x01
        //
        if (frameStart[0] == SYN && (frameStart[1]==0x01 || frameStart[1] == 0x02)) {
            ULONG   bytesWanted;
            PUCHAR  frameStart2;

            pInfo->SetLinkInfo.SendFramingBits =
            pInfo->SetLinkInfo.RecvFramingBits = RAS_FRAMING;

            DbgTracef(-1,("ASYNC: RAS framing detected\n"));

            frameStart2=pFrame->Frame+10;

            //
            // Adjust buffer for old RAS read
            //
            ASYNC_MOVE_MEMORY(
                frameStart2,
                frameStart,
                6);

            frameStart=frameStart2;

            bytesWanted=(frameStart[2]*256)+(frameStart[3]);

            if (bytesWanted > (ULONG)(max( pInfo->Adapter->MaxFrameSize, DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE ))) {

                DbgTracef(-1,("---ASYNC: Frame too large -- size: %d!\n", bytesWanted));
                //
                // set frame start to non-SYN character
                //
                *frameStart = 0;
                pInfo->BytesRead=0;
                pInfo->BytesWanted=6;

                //
                // break added to fix problem where frame has length
                // greater than max frame size.  This will send us back
                // to detect the next frame!  Added 10/31/95 by TonyBe.
                //
                break;
            }

            // if this is the first we posted, post another to get
            // rest of frame.
            if (pInfo->BytesRead == 6) {

                pInfo->BytesRead=6;
                pInfo->BytesWanted=bytesWanted +
                                    // SYN+SOH+LEN+ETX+CRC
                                        1 + 1 + 2 + 1 + 2 -
                                        6;

                DbgTracef(2,("---Posting second read for %d bytes\n",pInfo->BytesWanted));
            }

        } else

            //
            // It turns out that NetManage sends the flag byte at the
            // end always.  This means that their first frame is wrong.
            // Anyway, this throws off the detect routine.  So, we
            // will be robust and accept frames without the FLAG_BYTE.
            //

            if ((frameStart[0] == PPP_FLAG_BYTE && frameStart[1]==0xFF) ||
                (frameStart[0] == 0xFF && frameStart[1]==PPP_ESC_BYTE)) {

                pInfo->SetLinkInfo.SendFramingBits =
                pInfo->SetLinkInfo.RecvFramingBits = PPP_FRAMING;
                pInfo->SetLinkInfo.SendACCM = 
                    AsyncInfo->ExtendedACCM[0] = 0xFFFFFFFF;

                DbgTracef(-1,("ASYNC: PPP framing detected\n"));

            }
            else {

                //
                // Read again!
                //

                DbgTracef(-1,("ASYNC: No framing detected yet\n"));
                DbgTracef(-1,("ASYNC: Got %.2x %.2x %.2x %.2x %.2x %.2x\n",
                            frameStart[0],
                            frameStart[1],
                            frameStart[2],
                            frameStart[3],
                            frameStart[4],
                            frameStart[5]));

                break;
            }


        //
        // set framing mode active
        //
        pInfo->PortState = PORT_FRAMING;

        //
        //  Send off the worker thread to start reading frames
        //  off this port - we want to be at passive level otherwise
        //  it don't work.
        //
    
        ExInitializeWorkItem(&(pInfo->WorkItem),
                             (PWORKER_THREAD_ROUTINE)AsyncStartReads,
                             pInfo);
        
        ExQueueWorkItem(&(pInfo->WorkItem), DelayedWorkQueue);

        return(STATUS_MORE_PROCESSING_REQUIRED);

    case STATUS_TIMEOUT:
        DbgTracef(-1,("---ASYNC: detect Status %x%0.8x on read\n", status));
        break;

    case STATUS_CANCELLED:
    case STATUS_PORT_DISCONNECTED:
    default:
        return(STATUS_MORE_PROCESSING_REQUIRED);

    }

    //
    // Wipe out rest of this buffer
    //
    SerialFlushReads(pInfo);

    KeClearEvent(&pInfo->DetectEvent);

    //
    // Here we are at the end of processing this IRP so we go
    // ahead and post another read from the serial port.
    //
    // this is done on a worker since we run out of stack otherwise
    //
    ExInitializeWorkItem(&(pInfo->WorkItem),
                         (PWORKER_THREAD_ROUTINE) AsyncDetectRead,
                         pInfo);

    ExQueueWorkItem(&(pInfo->WorkItem), DelayedWorkQueue);

    // We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    //
    return(STATUS_MORE_PROCESSING_REQUIRED);
}


NTSTATUS
AsyncDetectRead(
    IN PASYNC_INFO pInfo)

/*++

--*/
{
    NTSTATUS            status;
    PIRP                irp;
    PDEVICE_OBJECT      deviceObject=pInfo->DeviceObject;
    PFILE_OBJECT        fileObject=pInfo->FileObject;
    PIO_STACK_LOCATION  irpSp;
    PASYNC_FRAME        pFrame;
    PASYNC_ADAPTER      pAdapter=pInfo->Adapter;

    DbgTracef(-1,("Entering AsyncDetectRead\n"));

    do {

        if (pInfo->PortState == PORT_CLOSING ||
            pInfo->PortState == PORT_CLOSED) {

            status = STATUS_SUCCESS;
            break;
        }

        // get ptr to first frame in list...
        pFrame=pInfo->AsyncFrame;

        irp =
            IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

        // Setup this irp with defaults
        AsyncSetupIrp(pFrame, irp);

        irp->AssociatedIrp.SystemBuffer =
        irp->UserBuffer =
             pFrame->Frame + PPP_PADDING;

        //
        // Get a pointer to the stack location for the first driver.  This will be
        // used to pass the original function codes and parameters.
        //

        irpSp = IoGetNextIrpStackLocation(irp);
        irpSp->MajorFunction = IRP_MJ_READ;
        irpSp->FileObject = fileObject;
        if (fileObject->Flags & FO_WRITE_THROUGH) {
            irpSp->Flags = SL_WRITE_THROUGH;
        }

        //
        // If this write operation is to be performed without any caching, set the
        // appropriate flag in the IRP so no caching is performed.
        //

        irp->Flags |= IRP_READ_OPERATION;

        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
            irp->Flags |= IRP_NOCACHE;
        }

        //
        // Copy the caller's parameters to the service-specific portion of the
        // IRP.
        //

        irpSp->Parameters.Read.Length = 6;                  // from frame...
        irpSp->Parameters.Read.Key = 0;                     // we don't use a key
        irpSp->Parameters.Read.ByteOffset = fileObject->CurrentByteOffset;

        IoSetCompletionRoutine(
                irp,                            // irp to use
                AsyncDetectCompletionRoutine,   // routine to call when irp is done
                pInfo,                          // context to pass routine
                TRUE,                           // call on success
                TRUE,                           // call on error
                TRUE);                          // call on cancel

        //
        // We DO NOT insert the packet at the head of the IRP list for the thread.
        // because we do NOT really have an IoCompletionRoutine that does
        // anything with the thread.
        //

        //
        // Now simply invoke the driver at its dispatch entry with the IRP.
        //

        status = IoCallDriver(deviceObject, irp);

    } while (FALSE);

    KeSetEvent(&pInfo->DetectEvent,
               1,
               FALSE);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\digiser.h ===
/*++

*****************************************************************************
*                                                                           *
*  This software contains proprietary and confidential information of       *
*                                                                           *
*                    Digi International Inc.                                *
*                                                                           *
*  By accepting transfer of this copy, Recipient agrees to retain this      *
*  software in confidence, to prevent disclosure to others, and to make     *
*  no use of this software other than that for which it was delivered.      *
*  This is an unpublished copyrighted work of Digi International Inc.       *
*  Except as permitted by federal law, 17 USC 117, copying is strictly      *
*  prohibited.                                                              *
*                                                                           *
*****************************************************************************

Module Name:

   digiser.h

Abstract:

   This file contains the recommended extensions to the Microsoft Windows NT
   Serial Interface (NTDDSER.H) needed to support hardware framing.

Revision History:

   $Log: digiser.h $

   Revision 1.3  1995/09/15 14:55:24  dirkh
   Remove SERIAL_ERROR_CRC (use STATUS_CRC_ERROR instead).
   Comments are more explicit.

   Revision 1.2  1995/06/12 15:23:44  dirkh
   Merge two structures (SERIAL_GET_FRAMING and SERIAL_SET_FRAMING)
   into one (SERIAL_FRAMING_STATE).  Document relationship with IOCTLs.

   Revision 1.1  1995/05/31 15:05:19  mikez
   Initial revision

--*/


//
// NtDeviceIoControlFile IoControlCode values for this device
//
#ifndef Microsoft_Adopts_These_Changes
#define IOCTL_SERIAL_QUERY_FRAMING			CTL_CODE(FILE_DEVICE_SERIAL_PORT,0x801,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_FRAMING			CTL_CODE(FILE_DEVICE_SERIAL_PORT,0x802,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_FRAMING			CTL_CODE(FILE_DEVICE_SERIAL_PORT,0x803,METHOD_BUFFERED,FILE_ANY_ACCESS)
#else
#define IOCTL_SERIAL_QUERY_FRAMING			CTL_CODE(FILE_DEVICE_SERIAL_PORT,35,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_FRAMING			CTL_CODE(FILE_DEVICE_SERIAL_PORT,36,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_FRAMING			CTL_CODE(FILE_DEVICE_SERIAL_PORT,37,METHOD_BUFFERED,FILE_ANY_ACCESS)
#endif


//
// Provider capabilities flags (IOCTL_SERIAL_GET_PROPERTIES)
//
#define SERIAL_PCF_FRAMING	((ULONG)0x0400)


//
// Defines the bitmask that the driver can use to notify
// state changes via IOCTL_SERIAL_SET_WAIT_MASK and IOCTL_SERIAL_WAIT_ON_MASK.
//
// Note that these events will *not* be delivered if there is an outstanding read IRP.
// The status of the read IRP serves as notification of the receipt of a (good or bad) frame.
// Repeat:  These events will be detected and delivered only if the read queue is empty.
//
#define SERIAL_EV_RXFRAME	0x2000  // A valid frame was received
#define SERIAL_EV_BADFRAME	0x4000  // An errored frame was received.


//
// Read IRPs are always completed when a frame is received.
// Following are the values that can be returned by the
// driver in IoStatus.Status of the read IRP.
//
// STATUS_SUCCESS (good frame, data length is IoStatus.Information)
// STATUS_CRC_ERROR
// STATUS_DATA_ERROR (abort frame)
// STATUS_DATA_OVERRUN (buffer overrun -- note that buffer must have space for CRC bytes, although CRC bytes will not be indicated on STATUS_SUCCESS)
//


//
// This structure is used to query the framing options
// supported by hardware (IOCTL_SERIAL_QUERY_FRAMING).
//
typedef struct _SERIAL_FRAMING_INFO {
	OUT ULONG FramingBits;			// Standard NDIS_WAN_INFO field
	OUT ULONG HdrCompressionBits;	// Standard NDIS_WAN_INFO field
	OUT ULONG DataCompressionBits;	// To be decided
	OUT ULONG DataEncryptionBits;	// To be decided
} SERIAL_FRAMING_INFO, *PSERIAL_FRAMING_INFO;


//
// This structure is used to set and retrieve
// the current hardware framing settings
// (IOCTL_SERIAL_SET_FRAMING, IOCTL_SERIAL_GET_FRAMING).
//
// Valid values for [Send,Recv]FramingBits include (for example)
// PPP_FRAMING, PPP_ACCM_SUPPORTED, and ISO3309_FRAMING.
//
typedef struct _SERIAL_FRAMING_STATE {
	IN OUT ULONG	BitMask;				// 0: 16 bit CRC
											// 1: 32 bit CRC
	IN OUT ULONG	SendFramingBits;		// Standard NDIS_WAN_SET_LINK_INFO field
	IN OUT ULONG	RecvFramingBits;		// Standard NDIS_WAN_SET_LINK_INFO field
	IN OUT ULONG	SendCompressionBits;	// Standard NDIS_WAN_SET_LINK_INFO field
	IN OUT ULONG	RecvCompressionBits;	// Standard NDIS_WAN_SET_LINK_INFO field
	IN OUT ULONG	SendEncryptionBits; // To be decided
	IN OUT ULONG	RecvEncryptionBits;	// To be decided
	IN OUT ULONG 	SendACCM;				// Standard NDIS_WAN_SET_LINK_INFO field
	IN OUT ULONG 	RecvACCM;				// Standard NDIS_WAN_SET_LINK_INFO field
} SERIAL_FRAMING_STATE, *PSERIAL_FRAMING_STATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\globals.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    globals.h

Abstract:

	 This include file either prototypes the globals or defines the globals
    depending on whether the GLOBALS define value is extern or not.

Author:

    Thomas J. Dimitri (TommyD) 29-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

// only one module (asyncmac.c) gets to define the GLOBALS macro

#ifdef NOCODE

#define DBGPRINT 1

#ifndef	GLOBALS

#define	GLOBALS extern
#define EQU  ; / ## /
#define GLOBALSTATIC extern
#else
#define EQU  =
#define GLOBALSTATIC static
#endif

#else

#define GLOBALS

#endif


#define STATIC


#if DBG
#define DbgPrintf(_x_) DbgPrint _x_
#define DbgTracef(trace_level,_x_) if ((SCHAR)trace_level < TraceLevel) DbgPrint _x_
#define DbgDumpBytes(_x_) DebugDumpBytes _x_
#else
#define DbgPrintf(_x_)
#define DbgTracef(trace_level,_x_)
#define DbgDumpBytes(_x_)
#endif

//
//ZZZ Get from configuration file.
//

#define MAX_MULTICAST_ADDRESS ((UINT)16)
#define MAX_ADAPTERS ((UINT)4)

//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDISPATCH_FUNC) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
//  Global data items.
//

extern PDISPATCH_FUNC NdisMjDeviceControl;

extern PDISPATCH_FUNC NdisMjCreate;

extern PDISPATCH_FUNC NdisMjCleanup;

extern PDRIVER_UNLOAD NdisUnload;

extern SCHAR TraceLevel;

extern NDIS_SPIN_LOCK	GlobalLock;

extern PASYNC_ADAPTER	GlobalAdapter;

extern ULONG	GlobalAdapterCount;

extern ULONG GlobalXmitWentOut;

extern NDIS_PHYSICAL_ADDRESS HighestAcceptableMax;

extern NPAGED_LOOKASIDE_LIST	AsyncIoCtxList;

extern NPAGED_LOOKASIDE_LIST	AsyncInfoList;

extern PDEVICE_OBJECT	AsyncDeviceObject;

extern NDIS_HANDLE		AsyncDeviceHandle;

extern ULONG    glConnectionCount;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\init.h ===
//
// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.
#define DEFAULT_DIRECTORY L"DosDevices"

//
// For the above directory, the AsyncMAC driver will
// use the following name as the suffix of the AsyncMAC
// driver for that directory.  It will NOT append
// a number onto the end of the name.
#define DEFAULT_ASYNCMAC_NAME L"ASYNCMAC"


// define some globals

UNICODE_STRING	ObjectDirectory;
UNICODE_STRING	SymbolicLinkName;
BOOLEAN 		CreatedSymbolicLink=FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\init.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	init.c

Abstract:


Author:

	Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

	Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/
#include "asyncall.h"

// asyncmac.c will define the global parameters.
#include "globals.h"
#include "init.h"

#ifdef MY_DEVICE_OBJECT

VOID
AsyncSetupExternalNaming(
	PDRIVER_OBJECT	DriverObject
	)

/*++

Routine Description:

	This routine will be used to create a symbolic link
	to the driver name in the given object directory.

	It will also create an entry in the device map for
	this device.

Arguments:

	MacName - The NDIS Mac Name in Open Adapter

Return Value:

	None.

--*/

{
	NDIS_STRING SymbolicName = NDIS_STRING_CONST("\\DosDevices\\ASYNCMAC");
	NDIS_STRING Name = NDIS_STRING_CONST("\\Device\\ASYNCMAC");
	NTSTATUS	Status;

	AsyncDeviceObject = NULL;

	Status =
	IoCreateDevice(DriverObject,
				   sizeof(LIST_ENTRY),
				   &Name,
				   FILE_DEVICE_ASYMAC,
				   0,
				   FALSE,
				   (PDEVICE_OBJECT*)&AsyncDeviceObject);

	if (Status != STATUS_SUCCESS) {
#if DBG
		DbgPrint("ASYNCMAC: IoCreateDevice Failed %4.4x\n", Status);
#endif
		return;
	}

	AsyncDeviceObject->Flags |= DO_BUFFERED_IO;

	IoCreateSymbolicLink(&SymbolicName, &Name);
}


VOID
AsyncCleanupExternalNaming(
	VOID
	)

/*++

Routine Description:

	This routine will be used to delete a symbolic link
	to the driver name in the given object directory.

	It will also delete an entry in the device map for
	this device.

Arguments:

	MacName - The NDIS Mac Name in Open Adapter

Return Value:

	None.

--*/

{
	NDIS_STRING SymbolicName = NDIS_STRING_CONST("\\DosDevices\\ASYNCMAC");

	DbgTracef(1,
		("ASYNC: In SerialCleanupExternalNaming\n"));

	if (AsyncDeviceObject == NULL) {
		return;
	}

	IoDeleteSymbolicLink(&SymbolicName);

	IoDeleteDevice(AsyncDeviceObject);

	AsyncDeviceObject = NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\crctable.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    crctable.h

Abstract:

	This module is used to take apart NBF Frames and print what LLC
	and/or NetBIOS Frame is being sent (or received).

Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

UCHAR	dst_addr[6] = {' ', 'D', 'E', 'S', 'T', ' '};
UCHAR	src_addr[6] = {' ', 'S', 'R', 'C', ' ', ' '};
UCHAR	bcast_addr[6] = {0x03, 0x00, 0x00, 0x00, 0x00, 0x01};

//*** CRC table

static USHORT crc_table[256] = {

	0x0000,
	0x1021,
	0x2042,
	0x3063,
	0x4084,
	0x50a5,
	0x60c6,
	0x70e7,
	0x8108,
	0x9129,
	0xa14a,
	0xb16b,
	0xc18c,
	0xd1ad,
	0xe1ce,
	0xf1ef,
	0x1231,
	0x0210,
	0x3273,
	0x2252,
	0x52b5,
	0x4294,
	0x72f7,
	0x62d6,
	0x9339,
	0x8318,
	0xb37b,
	0xa35a,
	0xd3bd,
	0xc39c,
	0xf3ff,
	0xe3de,
	0x2462,
	0x3443,
	0x0420,
	0x1401,
	0x64e6,
	0x74c7,
	0x44a4,
	0x5485,
	0xa56a,
	0xb54b,
	0x8528,
	0x9509,
	0xe5ee,
	0xf5cf,
	0xc5ac,
	0xd58d,
	0x3653,
	0x2672,
	0x1611,
	0x0630,
	0x76d7,
	0x66f6,
	0x5695,
	0x46b4,
	0xb75b,
	0xa77a,
	0x9719,
	0x8738,
	0xf7df,
	0xe7fe,
	0xd79d,
	0xc7bc,
	0x48c4,
	0x58e5,
	0x6886,
	0x78a7,
	0x0840,
	0x1861,
	0x2802,
	0x3823,
	0xc9cc,
	0xd9ed,
	0xe98e,
	0xf9af,
	0x8948,
	0x9969,
	0xa90a,
	0xb92b,
	0x5af5,
	0x4ad4,
	0x7ab7,
	0x6a96,
	0x1a71,
	0x0a50,
	0x3a33,
	0x2a12,
	0xdbfd,
	0xcbdc,
	0xfbbf,
	0xeb9e,
	0x9b79,
	0x8b58,
	0xbb3b,
	0xab1a,
	0x6ca6,
	0x7c87,
	0x4ce4,
	0x5cc5,
	0x2c22,
	0x3c03,
	0x0c60,
	0x1c41,
	0xedae,
	0xfd8f,
	0xcdec,
	0xddcd,
	0xad2a,
	0xbd0b,
	0x8d68,
	0x9d49,
	0x7e97,
	0x6eb6,
	0x5ed5,
	0x4ef4,
	0x3e13,
	0x2e32,
	0x1e51,
	0x0e70,
	0xff9f,
	0xefbe,
	0xdfdd,
	0xcffc,
	0xbf1b,
	0xaf3a,
	0x9f59,
	0x8f78,
	0x9188,
	0x81a9,
	0xb1ca,
	0xa1eb,
	0xd10c,
	0xc12d,
	0xf14e,
	0xe16f,
	0x1080,
	0x00a1,
	0x30c2,
	0x20e3,
	0x5004,
	0x4025,
	0x7046,
	0x6067,
	0x83b9,
	0x9398,
	0xa3fb,
	0xb3da,
	0xc33d,
	0xd31c,
	0xe37f,
	0xf35e,
	0x02b1,
	0x1290,
	0x22f3,
	0x32d2,
	0x4235,
	0x5214,
	0x6277,
	0x7256,
	0xb5ea,
	0xa5cb,
	0x95a8,
	0x8589,
	0xf56e,
	0xe54f,
	0xd52c,
	0xc50d,
	0x34e2,
	0x24c3,
	0x14a0,
	0x0481,
	0x7466,
	0x6447,
	0x5424,
	0x4405,
	0xa7db,
	0xb7fa,
	0x8799,
	0x97b8,
	0xe75f,
	0xf77e,
	0xc71d,
	0xd73c,
	0x26d3,
	0x36f2,
	0x0691,
	0x16b0,
	0x6657,
	0x7676,
	0x4615,
	0x5634,
	0xd94c,
	0xc96d,
	0xf90e,
	0xe92f,
	0x99c8,
	0x89e9,
	0xb98a,
	0xa9ab,
	0x5844,
	0x4865,
	0x7806,
	0x6827,
	0x18c0,
	0x08e1,
	0x3882,
	0x28a3,
	0xcb7d,
	0xdb5c,
	0xeb3f,
	0xfb1e,
	0x8bf9,
	0x9bd8,
	0xabbb,
	0xbb9a,
	0x4a75,
	0x5a54,
	0x6a37,
	0x7a16,
	0x0af1,
	0x1ad0,
	0x2ab3,
	0x3a92,
	0xfd2e,
	0xed0f,
	0xdd6c,
	0xcd4d,
	0xbdaa,
	0xad8b,
	0x9de8,
	0x8dc9,
	0x7c26,
	0x6c07,
	0x5c64,
	0x4c45,
	0x3ca2,
	0x2c83,
	0x1ce0,
	0x0cc1,
	0xef1f,
	0xff3e,
	0xcf5d,
	0xdf7c,
	0xaf9b,
	0xbfba,
	0x8fd9,
	0x9ff8,
	0x6e17,
	0x7e36,
	0x4e55,
	0x5e74,
	0x2e93,
	0x3eb2,
	0x0ed1,
	0x1ef0 };


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\frame.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    frame.h

Abstract:

Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

// first, some default values

// the ethernet max frame size is 1500+6+6+2  = 1514

/* Note that this only applies to non-PPP framing.  See below.
*/
#define DEFAULT_MAX_FRAME_SIZE  1514

/* The hard-coded PPP maximum frame sizes for send and receive paths.
**
** Note:  TommyD had these hard-coded.  I have simply made this more explicit
**        by removing their attachment to MaxFrameSize which was causing
**        problems for NT31 RAS compression.  The doubling is for PPP
**        byte-stuffing, the PPP_PADDING to adjust for possible VJ expansion,
**        and the 100...well, ask TommyD...and the 14 to limit exposure, i.e.
**        wind up with the exact number TommyD was using.
*/
#define DEFAULT_PPP_MAX_FRAME_SIZE          1500
#define DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE ((DEFAULT_PPP_MAX_FRAME_SIZE*2)+PPP_PADDING+100+14)

// ChuckL says 5 is a good default irp stack size
// perhaps we should lower this though since it's typically just 1
// but what if the com port is redirected??
#define DEFAULT_IRP_STACK_SIZE  5

#define SLIP_END_BYTE       192
#define SLIP_ESC_BYTE       219
#define SLIP_ESC_END_BYTE   220
#define SLIP_ESC_ESC_BYTE   221


#define PPP_FLAG_BYTE       0x7e
#define PPP_ESC_BYTE        0x7d


// define the number of framesPerPort

/* The NT35 setting, where sends are IRPed directly from the input buffer
** passed down from NDISWAN.
*/
#define DEFAULT_FRAMES_PER_PORT 1

// define if xon/xoff capability is on by default (off)
#define DEFAULT_XON_XOFF    0

// the mininmum timeout value per connection in ms
#define DEFAULT_TIMEOUT_BASE 500

// the multiplier based on the baud rate tacked on to the base in ms
#define DEFAULT_TIMEOUT_BAUD 28800

// the timeout to use if we drop a frame in ms
#define DEFAULT_TIMEOUT_RESYNC 500

// define to turn on extended xon/xoff escaping (on)
#define DEFAULT_EXTENDED_XONXOFF    1

typedef struct ASYNC_FRAME_HEADER ASYNC_FRAME_HEADER, *PASYNC_FRAME_HEADER;

struct ASYNC_FRAME_HEADER {
    UCHAR   SyncByte;           // 0x16
    UCHAR   FrameType;          // 0x01, 0x02 (directed vs. multicast)
                                // 0x08 compression
    UCHAR   HighFrameLength;
    UCHAR   LowFrameLength;
};

typedef struct ASYNC_FRAME_TRAILER ASYNC_FRAME_TRAILER, *PASYNC_FRAME_TRAILER;

struct ASYNC_FRAME_TRAILER {
    UCHAR   EtxByte;            // 0x03
    UCHAR   LowCRCByte;
    UCHAR   HighCRCByte;
};

typedef ULONG  FRAME_ID;

typedef struct ASYNC_ADAPTER ASYNC_ADAPTER, *PASYNC_ADAPTER;
typedef struct ASYNC_INFO ASYNC_INFO, *PASYNC_INFO;
typedef struct ASYNC_FRAME ASYNC_FRAME, *PASYNC_FRAME;

struct ASYNC_FRAME {

    // For PPP/SLIP.

    ULONG       WaitMask;               // Mask bits when IRP completes
#if 0
    PIRP        Irp;                    // Irp allocated based on DefaultIrpStackSize.
#if DBG
    ULONG       Line;
    CHAR       *File;
#endif
#endif

    UINT        FrameLength;            // Size of Frame allocated.
    PUCHAR      Frame;                  // Buffer allocated based on
                                        // DefaultFrameSize

    WORK_QUEUE_ITEM WorkItem;           // For stack overflow reads

    PASYNC_ADAPTER      Adapter;        // back ptr to adapter
    PASYNC_INFO         Info;           // back ptr to info field

    NDIS_HANDLE     MacBindingHandle;
    NDIS_HANDLE     NdisBindingContext;
};

NTSTATUS
AsyncGetFrameFromPool(
    IN  PASYNC_INFO  Info,
    OUT PASYNC_FRAME *NewFrame );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\io.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    io.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/
#include "asyncall.h"

// asyncmac.c will define the global parameters.
#include "globals.h"


NTSTATUS
AsyncSetupIrp(
    IN  PASYNC_FRAME Frame,
    IN  PIRP    irp
    )

/*++

    This is the routine which intializes the Irp

--*/
{
    //    PMDL              mdl;
    PDEVICE_OBJECT  deviceObject=Frame->Info->DeviceObject;
    PFILE_OBJECT    fileObject=Frame->Info->FileObject;

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = NULL;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    //
    // Now determine whether this device expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the caller's data is copied into it.  Otherwise, a Memory
    // Descriptor List (MDL) is allocated and the caller's buffer is locked
    // down using it.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The device does not support direct I/O.  Allocate a system buffer,
        // and copy the caller's data into it.  This is done using an
        // exception handler that will perform cleanup if the operation
        // fails.  Note that this is only done if the operation has a non-zero
        // length.
        //

        irp->AssociatedIrp.SystemBuffer = Frame->Frame;

        //
        // Set the IRP_BUFFERED_IO flag in the IRP so that I/O completion
        // will know that this is not a direct I/O operation.
        //

        irp->Flags = IRP_BUFFERED_IO;


    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This
        // is done using an exception handler that will perform cleanup if
        // the operation fails.  Note that no MDL is allocated, nor is any
        // memory probed or locked if the length of the request was zero.
        //

#if DBG
    DbgPrintf(("The DeviceObject is NOT BUFFERED_IO!! IRP FAILURE!!\n"));

    DbgBreakPoint();
#endif

    } else {

        //
        // Pass the address of the caller's buffer to the device driver.  It
        // is now up to the driver to do everything.
        //

        irp->UserBuffer = Frame->Frame;

    }

    // For now, if we get this far, it means success!
    return(STATUS_SUCCESS);
}

PASYNC_IO_CTX
AsyncAllocateIoCtx(
    BOOLEAN AllocateSync,
    PVOID   Context
)
{
    PASYNC_IO_CTX   AsyncIoCtx;

    AsyncIoCtx = ExAllocateFromNPagedLookasideList(&AsyncIoCtxList);

    if (AsyncIoCtx == NULL) {
        return (NULL);
    }

    RtlZeroMemory(AsyncIoCtx, sizeof(ASYNC_IO_CTX));
    AsyncIoCtx->Context = Context;
    AsyncIoCtx->Sync = AllocateSync;
    if (AllocateSync) {
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
        KeInitializeEvent(&AsyncIoCtx->Event,
                          SynchronizationEvent,
                          (BOOLEAN)FALSE);
    }

    return (AsyncIoCtx);
}

VOID
AsyncFreeIoCtx(
    PASYNC_IO_CTX   AsyncIoCtx
)
{
    ExFreeToNPagedLookasideList(&AsyncIoCtxList,
                                AsyncIoCtx);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\irps.c ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

	irps.c

Abstract:


Author:

	Thomas Dimitri (tommyd) 08-May-1992

--*/

#include "asyncall.h"
#include "globals.h"

VOID
AsyncCancelQueued(
	PDEVICE_OBJECT	DeviceObject,
	PIRP			Irp)
{
	DbgTracef(0, ("RASHUB: IRP 0x%.8x is being cancelled.\n", Irp));

	// Mark this Irp as cancelled
	Irp->IoStatus.Status = STATUS_CANCELLED;
	Irp->IoStatus.Information = 0;

	// Take off our own list
	RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

	// Release cancel spin lock which the IO system acquired??
	IoReleaseCancelSpinLock(Irp->CancelIrql);

	IoCompleteRequest(
		Irp,
		IO_NETWORK_INCREMENT);
}

VOID
AsyncCancelAllQueued(
	PLIST_ENTRY		QueueToCancel)
{
	KIRQL		oldIrql;
	PLIST_ENTRY	headOfList;
	PIRP		pIrp;

	//
	// We are pigs here using the global spin lock
	// but this is called so infrequently, we can
	// be pigs
	//
	IoAcquireCancelSpinLock(&oldIrql);

	//
	// Run through entire list until it is empty
	//
	for (;;) {

		if (IsListEmpty(QueueToCancel)) {
			break;
		}

		//
		// pick off the head of the list
		//
		headOfList = RemoveHeadList(QueueToCancel);

		pIrp = CONTAINING_RECORD(
				headOfList,
				IRP,
				Tail.Overlay.ListEntry);

		//
		// Disable the cancel routine
		//
		IoSetCancelRoutine(
			pIrp,
			NULL);

		//
		// Mark this irp as cancelled
		//
		pIrp->Cancel = TRUE;
		pIrp->IoStatus.Status = STATUS_CANCELLED;
		pIrp->IoStatus.Information = 0;

		//
		// We must release the spin lock before calling completing the irp
		//
		IoReleaseCancelSpinLock(oldIrql);

		DbgTracef(0, ("RASHUB: Cancelling a request\n"));

		IoCompleteRequest(
			pIrp,
			IO_NETWORK_INCREMENT);

		DbgTracef(0, ("RASHUB: Done cancelling a request\n"));

		//
		// Acquire it again before looking at the list
		//
		IoAcquireCancelSpinLock(&oldIrql);

	}

	IoReleaseCancelSpinLock(oldIrql);

}


VOID
AsyncQueueIrp(
	PLIST_ENTRY		Queue,
	PIRP			Irp)
{
	KIRQL		oldIrql;

	//
	// We are pigs here using the global spin lock
	//
	IoAcquireCancelSpinLock(&oldIrql);

	//
	// Mark the irp as pending and return from this ioctl
	//
	Irp->IoStatus.Status = STATUS_PENDING;
	IoMarkIrpPending(Irp);

	//
	// Queue up the irp at the end
	//
	InsertTailList(
		Queue,
		&Irp->Tail.Overlay.ListEntry);

	//
	// Set the cancel routine (also the purge routine)
	//
	IoSetCancelRoutine(
		Irp,
		AsyncCancelQueued);

	IoReleaseCancelSpinLock(oldIrql);

}


BOOLEAN
TryToCompleteDDCDIrp(
	PASYNC_INFO		pInfo)
	
/*++

Routine Description:


Arguments:


Return Value:


--*/

{

	KIRQL				oldIrql;
	PLIST_ENTRY			headOfList;
	PIRP				pIrp;

	IoAcquireCancelSpinLock(&oldIrql);

	if (IsListEmpty(&pInfo->DDCDQueue)) {
		IoReleaseCancelSpinLock(oldIrql);
		return((BOOLEAN)FALSE);
	}

	headOfList = RemoveHeadList(&pInfo->DDCDQueue);

	pIrp = CONTAINING_RECORD(
				headOfList,
				IRP,
				Tail.Overlay.ListEntry);

	IoSetCancelRoutine(
			pIrp,
			NULL);

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;

	IoReleaseCancelSpinLock(oldIrql);

	IoCompleteRequest(
			pIrp,
			IO_NETWORK_INCREMENT);

	return((BOOLEAN)TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\ioctl.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This is the main file for handling DevIOCtl calls for AsyncMAC.
    This driver conforms to the NDIS 3.0 interface.

Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/
#include "asyncall.h"

#ifdef NDIS_NT
    #include <ntiologc.h>
#endif

#if DBG

#define __FILE_SIG__    'tcoi'

#endif


//  asyncmac.c will define the global parameters.

VOID
AsyncSendLineUp(
    PASYNC_INFO pInfo
    )
{
    PASYNC_ADAPTER      pAdapter = pInfo->Adapter;
    NDIS_MAC_LINE_UP    MacLineUp;

    //
    //  divide the baud by 100 because NDIS wants it in 100s of bits per sec
    //

    MacLineUp.LinkSpeed = pInfo->LinkSpeed / 100;
    MacLineUp.Quality = pInfo->QualOfConnect;
    MacLineUp.SendWindow = ASYNC_WINDOW_SIZE;

    MacLineUp.ConnectionWrapperID = pInfo;
    MacLineUp.NdisLinkHandle      = pInfo;

    MacLineUp.NdisLinkContext = pInfo->NdisLinkContext;

    //
    // Tell the transport above (or really RasHub) that the connection
    // is now up.  We have a new link speed, frame size, quality of service
    //

    NdisMIndicateStatus(pAdapter->MiniportHandle,
                        NDIS_STATUS_WAN_LINE_UP,   // General Status.
                        &MacLineUp,                // (baud rate in 100 bps).
                        sizeof(NDIS_MAC_LINE_UP));

    //
    // Get the next binding (in case of multiple bindings like BloodHound)
    //

    pInfo->NdisLinkContext = MacLineUp.NdisLinkContext;
}


NTSTATUS
AsyncIOCtlRequest(
    IN PIRP                 pIrp,
    IN PIO_STACK_LOCATION   pIrpSp
    )

/*++

Routine Description:

    This routine takes an irp and checks to see if the IOCtl
    is a valid one.  If so, it performs the IOCtl and returns
    any errors in the process.

Return Value:

    The function value is the final status of the IOCtl.

--*/

{
    NTSTATUS            status;
    ULONG               funcCode;
    PVOID               pBufOut;
    ULONG               InBufLength, OutBufLength;
    NDIS_HANDLE         hNdisEndPoint;
    PASYMAC_CLOSE       pCloseStruct;
    PASYMAC_OPEN        pOpenStruct;
    PASYMAC_DCDCHANGE   pDCDStruct;
    PASYNC_ADAPTER      Adapter;
    LARGE_INTEGER li ;

    //
    //  Initialize locals.
    //

    status = STATUS_SUCCESS;

    //
    // Initialize the I/O Status block
    //

    InBufLength     = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    OutBufLength    = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    funcCode        = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

    //
    // Validate the function code
    //

#ifdef MY_DEVICE_OBJECT
    if ( (funcCode >> 16) != FILE_DEVICE_ASYMAC ) {

        return STATUS_INVALID_PARAMETER;
    }
#else
    if ( (funcCode >> 16) != FILE_DEVICE_NETWORK ) {

        return STATUS_INVALID_PARAMETER;
    }
#endif
    //
    //  Get a quick ptr to the IN/OUT SystemBuffer
    //

    pBufOut = pIrp->AssociatedIrp.SystemBuffer;

    switch ( funcCode ) {

        case IOCTL_ASYMAC_OPEN:

            DbgTracef(0,("AsyncIOCtlRequest: IOCTL_ASYMAC_OPEN.\n"));

            pIrp->IoStatus.Information = sizeof(ASYMAC_OPEN);

            if (InBufLength  >= sizeof(ASYMAC_OPEN) &&
                OutBufLength >= sizeof(ASYMAC_OPEN)) {

                pOpenStruct = pBufOut;

            } else {

                status = STATUS_INFO_LENGTH_MISMATCH;
            }

            break;


        case IOCTL_ASYMAC_CLOSE:

            DbgTracef(0,("AsyncIOCtlRequest: IOCTL_ASYMAC_CLOSE\n"));

            if ( InBufLength >= sizeof(ASYMAC_CLOSE) ) {

                pCloseStruct = pBufOut;

            } else {

                status = STATUS_INFO_LENGTH_MISMATCH;
            }

            break;


        case IOCTL_ASYMAC_TRACE:

#if DBG
            DbgPrint("AsyncIOCtlRequest: IOCTL_ASYMAC_TRACE.\n");

            if ( InBufLength >= sizeof(TraceLevel) ) {

                CHAR *pTraceLevel=pBufOut;
                TraceLevel=*pTraceLevel;

            } else {

                status = STATUS_INFO_LENGTH_MISMATCH;
            }
#endif
            return status;
            break;


        case IOCTL_ASYMAC_DCDCHANGE:

            DbgTracef(0,("AsyncIOCtlRequest: IOCTL_ASYMAC_DCDCHANGE.\n"));


            if ( InBufLength >= sizeof(ASYMAC_DCDCHANGE) ) {

                pDCDStruct = pBufOut;

            } else {
                status = STATUS_INFO_LENGTH_MISMATCH;
            }

            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Check if we already have an error (like STATUS_INFO_LENGTH_MISMATCH).
    //

    if ( status != STATUS_SUCCESS ) {

        return status;
    }

    //
    // Since most of IOCTL structs are similar
    // we get the Adapter and hNdisEndPoint here using
    // the StatsStruct (we could several of them)
    //

    pOpenStruct     = pBufOut;
    hNdisEndPoint   = pOpenStruct->hNdisEndpoint;

    //
    //  No error yet, let's go ahead and grab the global lock...
    //

    if ((Adapter = GlobalAdapter) == NULL ) {

        return ASYNC_ERROR_NO_ADAPTER;
    }

    // there's a race condition right here that I am
    // not bothering to get rid of because it would
    // require the removal of this adapter in between
    // here (which is, for all intensive purposes, impossible).

    // Hmm... now that we have the lock we can do stuff

    NdisAcquireSpinLock(&Adapter->Lock);

    // Here we do the real work for the function call

    switch ( funcCode ) {

        case IOCTL_ASYMAC_OPEN:
        {
            PASYNC_INFO                 pNewInfo = NULL;
            USHORT                      i;
            PDEVICE_OBJECT              deviceObject;
            PFILE_OBJECT                fileObject;
            OBJECT_HANDLE_INFORMATION   handleInformation;

            //
            // Get a new AsyncInfo
            //
            pNewInfo = (PASYNC_INFO)
                ExAllocateFromNPagedLookasideList(&AsyncInfoList);

            //
            // Check if we could not find an open port
            //

            if ( pNewInfo == NULL ) {

                NdisReleaseSpinLock(&Adapter->Lock);

                return ASYNC_ERROR_NO_PORT_AVAILABLE;
            }

            RtlZeroMemory(pNewInfo, sizeof(ASYNC_INFO));

            pNewInfo->Adapter = Adapter;

            status =
                AsyncGetFrameFromPool(pNewInfo, &pNewInfo->AsyncFrame);

            if (status != NDIS_STATUS_SUCCESS) {
                ExFreeToNPagedLookasideList(&AsyncInfoList, pNewInfo);

                NdisReleaseSpinLock(&Adapter->Lock);

                return ASYNC_ERROR_NO_PORT_AVAILABLE;
            }

            KeInitializeEvent(&pNewInfo->DetectEvent,
                              SynchronizationEvent,
                              TRUE);

            KeInitializeEvent(&pNewInfo->AsyncEvent,
                               SynchronizationEvent,
                               TRUE);

            // increment the reference count (don't kill this adapter)
            InterlockedIncrement(&Adapter->RefCount);

            //
            // Initialize the refcount on the new asyncinfo block.
            //
            pNewInfo->RefCount++;

#if DBG
            InitializeListHead(&pNewInfo->lePendingRequests);

            {

                PENDING_REQUEST *_Request = ExAllocatePoolWithTag(NonPagedPool, 
                                                sizeof(PENDING_REQUEST),
                                                'nepA');                
                if(NULL  != _Request)                                   
                {                                                       
                    _Request->pvContext = pNewInfo;                    
                    _Request->Sig = __FILE_SIG__;                       
                    _Request->lineNum = __LINE__;                       
                    InsertTailList(&pNewInfo->lePendingRequests, &_Request->le);
                }                                                               \
            }
#endif            

            pNewInfo->Flags |= ASYNC_FLAG_ASYNCMAC_OPEN;

            //
            // Set signalled state of event to not-signalled.
            //
            KeClearEvent(&pNewInfo->AsyncEvent);

            // release spin lock so we can do some real work.
            NdisReleaseSpinLock(&Adapter->Lock);

            //
            // Reference the file object so the target device can be found and
            // the access rights mask can be used in the following checks for
            // callers in user mode.  Note that if the handle does not refer to
            // a file object, then it will fail.
            //

            status = ObReferenceObjectByHandle(pOpenStruct->FileHandle,
                                               FILE_READ_DATA | FILE_WRITE_DATA,
                                               *IoFileObjectType,
                                               UserMode,
                                               (PVOID) &fileObject,
                                               &handleInformation);

            if (!NT_SUCCESS(status)) {

                pNewInfo->PortState = PORT_CLOSED;

                NdisAcquireSpinLock(&Adapter->Lock);
                // RemoveEntryList(&pNewInfo->Linkage);
                ExFreeToNPagedLookasideList(&Adapter->AsyncFrameList,
                                            pNewInfo->AsyncFrame);
                NdisReleaseSpinLock(&Adapter->Lock);
                ExFreeToNPagedLookasideList(&AsyncInfoList,
                                            pNewInfo);

                return ASYNC_ERROR_NO_PORT_AVAILABLE;
            }

            //
            // Init the portinfo block
            //
            InitializeListHead(&pNewInfo->DDCDQueue);

            // Ok, we've gotten this far.  We have a port.
            // Own port, and check params...
            // Nothing can be done to the port until it comes
            // out of the PORT_OPENING state.
            pNewInfo->PortState = PORT_OPENING;

            NdisAllocateSpinLock(&pNewInfo->Lock);

            //
            // Get the address of the target device object.  Note that this was already
            // done for the no intermediate buffering case, but is done here again to
            // speed up the turbo write path.
            //

            deviceObject = IoGetRelatedDeviceObject(fileObject);

            ObReferenceObject(deviceObject);

            // ok, we have a VALID handle of *something*
            // we do NOT assume that the handle is anything
            // in particular except a device which accepts
            // non-buffered IO (no MDLs) Reads and Writes

            // set new info...

            pNewInfo->Handle = pOpenStruct->FileHandle;

            //
            // Tuck away link speed for line up
            // and timeouts
            //
            pNewInfo->LinkSpeed = pOpenStruct->LinkSpeed;

            //
            // Return endpoint to RASMAN
            //
            pOpenStruct->hNdisEndpoint  =
            pNewInfo->hNdisEndPoint     = pNewInfo;

            // Get parameters set from Registry and return our capabilities

            pNewInfo->QualOfConnect     = pOpenStruct->QualOfConnect;
            pNewInfo->PortState         = PORT_FRAMING;
            pNewInfo->FileObject        = fileObject;
            pNewInfo->DeviceObject      = deviceObject;
            pNewInfo->NdisLinkContext   = NULL;

            //
            //  Initialize the NDIS_WAN_GET_LINK_INFO structure.
            //

            pNewInfo->GetLinkInfo.MaxSendFrameSize  = DEFAULT_PPP_MAX_FRAME_SIZE;
            pNewInfo->GetLinkInfo.MaxRecvFrameSize  = DEFAULT_PPP_MAX_FRAME_SIZE;
            pNewInfo->GetLinkInfo.HeaderPadding         = DEFAULT_PPP_MAX_FRAME_SIZE;
            pNewInfo->GetLinkInfo.TailPadding           = 4;
            pNewInfo->GetLinkInfo.SendFramingBits       = PPP_FRAMING;
            pNewInfo->GetLinkInfo.RecvFramingBits       = PPP_FRAMING;
            pNewInfo->GetLinkInfo.SendCompressionBits   = 0;
            pNewInfo->GetLinkInfo.RecvCompressionBits   = 0;
            pNewInfo->GetLinkInfo.SendACCM              = (ULONG) -1;
            pNewInfo->GetLinkInfo.RecvACCM              = (ULONG) -1;

            //
            // Initialize the Extended ACCM information so that we always
            // escape 0x7D and 0x7E and we never escape 0x5E
            //
            pNewInfo->ExtendedACCM[0] = (ULONG) -1;
            pNewInfo->ExtendedACCM[3] = (ULONG) 0x60000000;


            ASYNC_ZERO_MEMORY(&(pNewInfo->SerialStats), sizeof(SERIAL_STATS));

            NdisAcquireSpinLock(&Adapter->Lock);
            InsertHeadList(&Adapter->ActivePorts, &pNewInfo->Linkage);
            NdisReleaseSpinLock(&Adapter->Lock);


            //
            //  Send a line up to the WAN wrapper.
            //
            AsyncSendLineUp(pNewInfo);

            //
            // We send a special IRP to the serial driver to set it in RAS friendly mode
            // where it will not complete write requests until the packet has been transmitted
            // on the wire. This is mostly important in case of intelligent controllers.
            //
            pNewInfo->WaitMaskToUse = 
                (SERIAL_EV_RXFLAG | SERIAL_EV_RLSD | SERIAL_EV_DSR | 
                 SERIAL_EV_RX80FULL | SERIAL_EV_ERR) ;

            {
                NTSTATUS        retStatus;
                PASYNC_IO_CTX   AsyncIoCtx;
                PIRP            irp;

                irp = 
                    IoAllocateIrp(pNewInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

                if (irp != NULL) {
                    AsyncIoCtx = AsyncAllocateIoCtx(TRUE, pNewInfo);

                    if (AsyncIoCtx == NULL) {
                        IoFreeIrp(irp);
                        irp = NULL;
                    }
                }

                if (irp != NULL) {
#define IOCTL_SERIAL_PRIVATE_RAS CTL_CODE(FILE_DEVICE_SERIAL_PORT,4000,METHOD_BUFFERED,FILE_ANY_ACCESS)

                    InitSerialIrp(irp,
                                  pNewInfo,
                                  IOCTL_SERIAL_PRIVATE_RAS,
                                  sizeof(ULONG));

                    AsyncIoCtx->WriteBufferingEnabled =
                        Adapter->WriteBufferingEnabled;

                    irp->AssociatedIrp.SystemBuffer=
                        &AsyncIoCtx->WriteBufferingEnabled;

                    IoSetCompletionRoutine(irp,                             // irp to use
                                           SerialIoSyncCompletionRoutine,   // routine to call when irp is done
                                           AsyncIoCtx,                      // context to pass routine
                                           TRUE,                            // call on success
                                           TRUE,                            // call on error
                                           TRUE);                           // call on cancel

                    // Now simply invoke the driver at its dispatch entry with the IRP.
                    //
                    KeClearEvent(&AsyncIoCtx->Event);
                    retStatus = IoCallDriver(pNewInfo->DeviceObject, irp);
                    if (retStatus == STATUS_PENDING) {
                        KeWaitForSingleObject(&AsyncIoCtx->Event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL);
                        retStatus = AsyncIoCtx->IoStatus.Status;
                    }

                    IoFreeIrp(irp);
                    AsyncFreeIoCtx(AsyncIoCtx);

                    if (retStatus == STATUS_SUCCESS) {

                        //
                        // this means that the driver below is DIGI. we should disable setting of the EV_ERR
                        // flags in this case.
                        //

                        pNewInfo->WaitMaskToUse &= ~SERIAL_EV_ERR;

                    }
                }
            }

            //
            // Start the detect framing out with a 6 byte read to get the header
            //
            pNewInfo->BytesWanted=6;
            pNewInfo->BytesRead=0;

            //
            //  Start reading.
            //

            AsyncStartReads(pNewInfo);

            if (NdisInterlockedIncrement(&glConnectionCount) == 1) {
                ObReferenceObject(AsyncDeviceObject);

            }

            break;
        }

        case IOCTL_ASYMAC_TRACE:
            NdisReleaseSpinLock(&Adapter->Lock);
            status = STATUS_SUCCESS;
            break;

        case IOCTL_ASYMAC_CLOSE:
        case IOCTL_ASYMAC_DCDCHANGE:
        {
            PASYNC_INFO     pNewInfo;       // ptr to open port if found
            USHORT          i;
            PLIST_ENTRY     pListEntry;
            BOOLEAN         Valid = FALSE;

            switch (funcCode) {

                case IOCTL_ASYMAC_CLOSE:
                {
                    NDIS_MAC_LINE_DOWN  AsyncLineDown;

                    pNewInfo = (PASYNC_INFO)pCloseStruct->hNdisEndpoint;

                    // Verify that the pointer is a valid ASYNC_INFO
                    for (pListEntry=Adapter->ActivePorts.Flink;
                         pListEntry!=&Adapter->ActivePorts;
                         pListEntry=pListEntry->Flink)
                    {
                        if (&pNewInfo->Linkage==pListEntry)
                        {
                            Valid = TRUE;
                            break;
                        }
                    }

                    if (!Valid) {
                        status=ASYNC_ERROR_PORT_NOT_FOUND;
                        break;
                    }

                    // release spin lock so we can do some real work.
                    NdisReleaseSpinLock(&Adapter->Lock);

                    NdisAcquireSpinLock(&pNewInfo->Lock);

                    // ASSERT(pNewInfo->PortState == PORT_FRAMING);
                    
                    if(pNewInfo->PortState != PORT_FRAMING)
                    {
                        KdPrint(("AsyncIOCtlRequest: IOCTL_ASYMAC_CLOSE."));
                        KdPrint(("PortState = %d != PORT_FRAMING\n", pNewInfo->PortState));

                        NdisReleaseSpinLock(&pNewInfo->Lock);
                        return ASYNC_ERROR_PORT_BAD_STATE;
                        // break;
                    }

                    AsyncLineDown.NdisLinkContext = pNewInfo->NdisLinkContext;

                    // Signal that port is closing.
                    pNewInfo->PortState = PORT_CLOSING;

                    //Set MUTEX to wait on
                    KeInitializeEvent(&pNewInfo->ClosingEvent,       // Event
                                      SynchronizationEvent,          // Event type
                                      (BOOLEAN)FALSE);               // Not signalled state

                    NdisReleaseSpinLock(&pNewInfo->Lock);

                    //
                    // If we have an outstanding Detect worker
                    // wait for it to complete!
                    //
                    KeWaitForSingleObject(&pNewInfo->DetectEvent,
                                          UserRequest,
                                          KernelMode,
                                          FALSE,
                                          NULL);

                    //
                    // now we must send down an IRP do cancel
                    // any request pending in the serial driver
                    //
                    CancelSerialRequests(pNewInfo);

                    //
                    // Also, cancel any outstanding DDCD irps
                    //

                    AsyncCancelAllQueued(&pNewInfo->DDCDQueue);

                    // Synchronize closing with the read irp
                    
                    li.QuadPart = Int32x32To64(10000, -10000);          // wait for 10 secs

                    if (KeWaitForSingleObject (&pNewInfo->ClosingEvent,// PVOID Object,
                                               UserRequest,           // KWAIT_REASON WaitReason,
                                               KernelMode,            // KPROCESSOR_MODE WaitMode,
                                               (BOOLEAN)FALSE,        // BOOLEAN Alertable,
                                               &li) == STATUS_TIMEOUT) {

                        // If the wait fails cause another flush
                        //
                        NTSTATUS    retStatus;
                        PIRP        irp;
                        PASYNC_IO_CTX   AsyncIoCtx;

                        irp=
                            IoAllocateIrp(pNewInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

                        if (irp == NULL)
                            goto DEREF ;


                        AsyncIoCtx = AsyncAllocateIoCtx(TRUE, pNewInfo);

                        if (AsyncIoCtx == NULL) {
                            IoFreeIrp(irp);
                            goto DEREF;
                        }

                        InitSerialIrp(irp,
                                      pNewInfo,
                                      IOCTL_SERIAL_PURGE,
                                      sizeof(ULONG));

                        // kill all read and write threads.
                        AsyncIoCtx->SerialPurge =
                            SERIAL_PURGE_TXABORT | SERIAL_PURGE_RXABORT;

                        irp->AssociatedIrp.SystemBuffer=
                            &AsyncIoCtx->SerialPurge;

                        IoSetCompletionRoutine(irp,     // irp to use
                                               SerialIoSyncCompletionRoutine,  // routine to call when irp is done
                                               AsyncIoCtx,                 // context to pass routine
                                               TRUE,                       // call on success
                                               TRUE,                       // call on error
                                               TRUE);                      // call on cancel

                        // Now simply invoke the driver at its dispatch entry with the IRP.
                        //
                        KeClearEvent(&AsyncIoCtx->Event);
                        retStatus = IoCallDriver(pNewInfo->DeviceObject, irp);

                        if (retStatus == STATUS_PENDING) {
                            KeWaitForSingleObject(&AsyncIoCtx->Event,
                                                  Executive,
                                                  KernelMode,
                                                  FALSE,
                                                  NULL);
                            retStatus = AsyncIoCtx->IoStatus.Status;
                        }

                        IoFreeIrp(irp);
                        AsyncFreeIoCtx(AsyncIoCtx);

                        // if we do hit this code - wait for some time to let
                        // the read complete
                        //
                        KeDelayExecutionThread (KernelMode, FALSE, &li) ;
                    }


                    //
                    // Get rid of our reference to the serial port
                    //
                    DEREF:
                    ObDereferenceObject(pNewInfo->DeviceObject);

                    ObDereferenceObject(pNewInfo->FileObject);

                    NdisMIndicateStatus(Adapter->MiniportHandle,
                                        NDIS_STATUS_WAN_LINE_DOWN,  // General Status
                                        &AsyncLineDown,            // Specific Status
                                        sizeof(NDIS_MAC_LINE_DOWN));


                    pNewInfo->Flags &= ~(ASYNC_FLAG_ASYNCMAC_OPEN);
                    //
                    // Deref the ref applied in IOCTL_ASYNCMAC_OPEN
                    //
                    DEREF_ASYNCINFO(pNewInfo, pNewInfo);

                    //
                    // Wait for ref on pNewInfo to go to 0
                    //
                    KeWaitForSingleObject(&pNewInfo->AsyncEvent,
                                          UserRequest,
                                          KernelMode,
                                          FALSE,
                                          NULL);
                    
                    // reacquire spin lock
                    NdisAcquireSpinLock(&Adapter->Lock);

                    RemoveEntryList(&pNewInfo->Linkage);

                    // decrement the reference count because we're done.
                    InterlockedDecrement(&Adapter->RefCount);

                    pNewInfo->PortState = PORT_CLOSED;

                    NdisFreeSpinLock(&pNewInfo->Lock);

                    ExFreeToNPagedLookasideList(&Adapter->AsyncFrameList,
                                                pNewInfo->AsyncFrame);

                    ExFreeToNPagedLookasideList(&AsyncInfoList,
                                                pNewInfo);

                    if (NdisInterlockedDecrement(&glConnectionCount) == 0) {
                        ObDereferenceObject(AsyncDeviceObject);
                    }

                    break;          // get out of case statement
                }

                case IOCTL_ASYMAC_DCDCHANGE:
    
                    pNewInfo = (PASYNC_INFO)pDCDStruct->hNdisEndpoint;
                    
                    // Verify that the pointer is a valid ASYNC_INFO
                    for (pListEntry=Adapter->ActivePorts.Flink;
                         pListEntry!=&Adapter->ActivePorts;
                         pListEntry=pListEntry->Flink)
                    {
                        if (&pNewInfo->Linkage==pListEntry)
                        {
                            Valid = TRUE;
                            break;
                        }
                    }

                    //
                    // If the port is already closed, we WILL complain
                    //
                    if (!Valid || pNewInfo->PortState == PORT_CLOSED) {
                        status=ASYNC_ERROR_PORT_NOT_FOUND;
                        break;
                    }

                    //
                    // If any irps are pending, cancel all of them
                    // Only one irp can be outstanding at a time.
                    //
                    AsyncCancelAllQueued(&pNewInfo->DDCDQueue);

                    DbgTracef(0, ("ASYNC: Queueing up DDCD IRP\n"));

                    AsyncQueueIrp(&pNewInfo->DDCDQueue, pIrp);

                    //
                    // we'll have to wait for the SERIAL driver
                    // to flip DCD or DSR
                    //
                    status=STATUS_PENDING;
                    break;

            } // end switch

            NdisReleaseSpinLock(&Adapter->Lock);
            return(status);
        }
        break;

    }   // end switch

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\oid.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    oid.c

Abstract:

    This source file handles ALL oid requests from the wrapper.

Author:

    Ray Patch (raypa) 04/12/94

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    raypa           04/12/94            Created.

--*/

#if DBG

#define __FILE_SIG__    ' diO'

#endif


#include "asyncall.h"

//
//  New WAN OID supported list.
//

NDIS_OID AsyncGlobalSupportedOids[] = {
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,

    OID_WAN_PERMANENT_ADDRESS,
    OID_WAN_CURRENT_ADDRESS,
    OID_WAN_PROTOCOL_TYPE,
    OID_WAN_MEDIUM_SUBTYPE,
    OID_WAN_HEADER_FORMAT,

    OID_WAN_GET_INFO,
    OID_WAN_GET_LINK_INFO,
    OID_WAN_GET_COMP_INFO,

    OID_WAN_SET_LINK_INFO,
    OID_WAN_SET_COMP_INFO,

    OID_WAN_GET_STATS_INFO,

    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
    OID_PNP_ENABLE_WAKE_UP
};


//
//  Forward references for this source file.
//

NDIS_STATUS
AsyncSetLinkInfo(
    IN  POID_WORK_ITEM  OidWorkItem
    );

NDIS_STATUS
MpQueryInfo(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    )
/*++

Routine Description:

    The MpQueryProtocolInformation process a Query request for
    NDIS_OIDs that are specific to a binding about the MAC.  Note that
    some of the OIDs that are specific to bindings are also queryable
    on a global basis.  Rather than recreate this code to handle the
    global queries, I use a flag to indicate if this is a query for the
    global data or the binding specific data.

Arguments:

    Adapter - a pointer to the adapter.

    Oid - the NDIS_OID to process.

Return Value:

    The function value is the status of the operation.

--*/

{
    NDIS_MEDIUM             Medium          = NdisMediumWan;
    ULONG                   GenericULong    = 0;
    USHORT                  GenericUShort   = 0;
    UCHAR                   GenericArray[] = {' ', 'A', 'S', 'Y', 'N', 0xFF};
    NDIS_STATUS             StatusToReturn  = NDIS_STATUS_SUCCESS;
    NDIS_HARDWARE_STATUS    HardwareStatus  = NdisHardwareStatusReady;
    PVOID                   MoveSource;
    ULONG                   MoveBytes;
    INT                     fDoCommonMove = TRUE;
    PASYNC_ADAPTER          Adapter = MiniportAdapterContext;

    ASSERT( sizeof(ULONG) == 4 );

    //
    //  Switch on request type
    //
    //  By default we assume the source and the number of bytes to move

    MoveSource = &GenericULong;
    MoveBytes  = sizeof(GenericULong);

    switch ( Oid ) {

    case OID_GEN_SUPPORTED_LIST:

        MoveSource = AsyncGlobalSupportedOids;
        MoveBytes  = sizeof(AsyncGlobalSupportedOids);

        break;

    case OID_GEN_HARDWARE_STATUS:
        MoveSource = (PVOID)&HardwareStatus;
        MoveBytes = sizeof(HardwareStatus);
        break;

    case OID_GEN_MEDIA_SUPPORTED:
    case OID_GEN_MEDIA_IN_USE:
        MoveSource = (PVOID)&Medium;
        MoveBytes = sizeof(Medium);
        break;

    case OID_GEN_MAXIMUM_LOOKAHEAD:
    case OID_GEN_CURRENT_LOOKAHEAD:
    case OID_GEN_MAXIMUM_FRAME_SIZE:
        GenericULong = Adapter->MaxFrameSize;
        break;

    case OID_GEN_LINK_SPEED:
        //
        // Who knows what the initial link speed is?
        // This should not be called, right?
        //
        GenericULong = (ULONG)288;
        break;

    case OID_GEN_TRANSMIT_BUFFER_SPACE:
    case OID_GEN_RECEIVE_BUFFER_SPACE:
        GenericULong = (ULONG)(Adapter->MaxFrameSize * 2);
        break;

    case OID_GEN_TRANSMIT_BLOCK_SIZE:
    case OID_GEN_RECEIVE_BLOCK_SIZE:
    case OID_GEN_MAXIMUM_TOTAL_SIZE:
        GenericULong = (ULONG)(Adapter->MaxFrameSize);
        break;

    case OID_GEN_VENDOR_ID:
        GenericULong = 0xFFFFFFFF;
        MoveBytes = 3;
        break;

    case OID_GEN_VENDOR_DESCRIPTION:
        MoveSource = (PVOID)"AsyncMac Adapter";
        MoveBytes = 16;
        break;

    case OID_GEN_DRIVER_VERSION:
        GenericUShort = 0x0500;
        MoveSource = (PVOID)&GenericUShort;
        MoveBytes = sizeof(USHORT);
        break;

    case OID_GEN_MAC_OPTIONS:
        GenericULong = (ULONG)(NDIS_MAC_OPTION_RECEIVE_SERIALIZED |
                               NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                               NDIS_MAC_OPTION_FULL_DUPLEX |
                               NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA);
        break;

    case OID_WAN_PROTOCOL_TYPE:

        DbgTracef(0,("AsyncQueryProtocolInformation: Oid = OID_WAN_PROTOCOL_TYPE.\n"));

        break;

    case OID_WAN_PERMANENT_ADDRESS:
    case OID_WAN_CURRENT_ADDRESS:
        MoveSource = (PVOID)GenericArray;
        MoveBytes = ETH_LENGTH_OF_ADDRESS;
        break;

    case OID_WAN_MEDIUM_SUBTYPE:
        GenericULong = NdisWanMediumSerial;
        break;

    case OID_WAN_HEADER_FORMAT:
        GenericULong = NdisWanHeaderEthernet;
        break;

    case OID_WAN_GET_INFO:

        DbgTracef(0,("AsyncQueryProtocolInformation: Oid = OID_WAN_GET_INFO.\n"));

        MoveSource = &Adapter->WanInfo;
        MoveBytes  = sizeof(NDIS_WAN_INFO);

        break;

    case OID_WAN_GET_LINK_INFO:
        {
        NDIS_WAN_GET_LINK_INFO* pInfo;
        PASYNC_INFO             AsyncInfo;

        DbgTracef(0,("AsyncQueryProtocolInformation: Oid = OID_WAN_GET_LINK_INFO.\n"));
        pInfo = (NDIS_WAN_GET_LINK_INFO* )InformationBuffer;
        AsyncInfo = (PASYNC_INFO) pInfo->NdisLinkHandle;
        MoveSource = &AsyncInfo->GetLinkInfo,
        MoveBytes = sizeof(NDIS_WAN_GET_LINK_INFO);

        }

        break;

    case OID_WAN_GET_COMP_INFO:
    {
        DbgTracef(0,("AsyncQueryProtocolInformation: Oid = OID_WAN_GET_COMP_INFO.\n"));
        StatusToReturn = NDIS_STATUS_NOT_SUPPORTED;
        break;
    }

    case OID_WAN_GET_STATS_INFO:
    {

        DbgTracef(0,("AsyncQueryProtocolInformation: Oid = OID_WAN_GET_STATS_INFO\n"));
        StatusToReturn = NDIS_STATUS_NOT_SUPPORTED;
        break;
    }



    case OID_GEN_XMIT_OK:
    case OID_GEN_RCV_OK:
    case OID_GEN_XMIT_ERROR:
    case OID_GEN_RCV_ERROR:
    case OID_GEN_RCV_NO_BUFFER:
        break;

    case OID_PNP_CAPABILITIES:
    case OID_PNP_SET_POWER:
    case OID_PNP_QUERY_POWER:
    case OID_PNP_ENABLE_WAKE_UP:
        break;

    default:
        StatusToReturn = NDIS_STATUS_NOT_SUPPORTED;
        break;
    }

    //
    //  If were here then we need to move the data into the callers buffer.
    //

    if ( StatusToReturn == NDIS_STATUS_SUCCESS ) {

        if (fDoCommonMove)
        {
            //
            //  If there is enough room then we can copy the data and
            //  return the number of bytes copied, otherwise we must
            //  fail and return the number of bytes needed.
            //
            if ( MoveBytes <= InformationBufferLength ) {

                ASYNC_MOVE_MEMORY(InformationBuffer, MoveSource, MoveBytes);

                *BytesWritten += MoveBytes;

            } else {

                *BytesNeeded = MoveBytes;

                StatusToReturn = NDIS_STATUS_BUFFER_TOO_SHORT;

            }
        }
    }

    return StatusToReturn;
}


NDIS_STATUS
MpSetInfo(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesRead,
    OUT PULONG      BytesNeeded
    )
/*++

Routine Description:

    The AsyncSetInformation is used by AsyncRequest to set information
    about the MAC.

    Note: Assumes it is called with the lock held.  Any calls are made down
    to the serial driver from this routine may return pending.  If this happens
    the completion routine for the call needs to complete this request by
    calling NdisMSetInformationComplete.

Arguments:

    MiniportAdapterContext - A pointer to the adapter.


Return Value:

    The function value is the status of the operation.

--*/

{
    NDIS_STATUS     StatusToReturn;
    PASYNC_ADAPTER  Adapter = MiniportAdapterContext;

    //
    //  Initialize locals.
    //

    StatusToReturn = NDIS_STATUS_SUCCESS;

    switch ( Oid ) {

    case OID_WAN_SET_LINK_INFO:
        {
        PASYNC_INFO AsyncInfo;
        WORK_QUEUE_ITEM WorkItem;
        PNDIS_WAN_SET_LINK_INFO SetLinkInfo;
        POID_WORK_ITEM  OidWorkItem;

        SetLinkInfo = (PNDIS_WAN_SET_LINK_INFO)InformationBuffer;
        AsyncInfo = (PASYNC_INFO) SetLinkInfo->NdisLinkHandle;

        NdisAcquireSpinLock(&AsyncInfo->Lock);

        if (AsyncInfo->PortState != PORT_FRAMING) {
            NdisReleaseSpinLock(&AsyncInfo->Lock);
            break;
        }

        OidWorkItem = ExAllocatePoolWithTag(NonPagedPool,
            sizeof(OID_WORK_ITEM), ASYNC_WORKITEM_TAG);

        if (OidWorkItem == NULL) {
            NdisReleaseSpinLock(&AsyncInfo->Lock);
            break;
        }

        AsyncInfo->Flags |= OID_WORK_SCHEDULED;

        //
        // Cannot issue IRPs at anything but PASSIVE level!
        // We must schedule a passive worker to carry this out.
        //
        DbgTracef(-2,("AsyncSetInformation: Oid = OID_WAN_SET_LINK_INFO\n"));

        REF_ASYNCINFO(AsyncInfo, OidWorkItem);

        NdisReleaseSpinLock(&AsyncInfo->Lock);

        OidWorkItem->Context = SetLinkInfo;

        ExInitializeWorkItem(&OidWorkItem->WorkQueueItem, 
            AsyncSetLinkInfo, OidWorkItem);


        ExQueueWorkItem(&OidWorkItem->WorkQueueItem, DelayedWorkQueue);

        StatusToReturn = NDIS_STATUS_PENDING;

        break;
        }

    case OID_WAN_SET_COMP_INFO:
    {
        DbgTracef(0,("AsyncSetInformation: Oid = OID_WAN_SET_COMP_INFO.\n"));
        StatusToReturn = NDIS_STATUS_INVALID_OID;
        break;
    }

        case OID_PNP_CAPABILITIES:
        case OID_PNP_SET_POWER:
        case OID_PNP_QUERY_POWER:
        case OID_PNP_ENABLE_WAKE_UP:
            break;

    default:

        StatusToReturn = NDIS_STATUS_INVALID_OID;

        *BytesRead   = 0;
        *BytesNeeded = 0;

        break;
    }

    if ( StatusToReturn == NDIS_STATUS_SUCCESS ) {

        *BytesRead   = InformationBufferLength;
        *BytesNeeded = 0;

    }

    return StatusToReturn;
}

NDIS_STATUS
AsyncSetLinkInfo(
    IN  POID_WORK_ITEM  OidWorkItem
    )
{
    PASYNC_INFO AsyncInfo;
    ULONG       RecvFramingBits;
    NDIS_STATUS Status;
    PNDIS_WAN_SET_LINK_INFO SetLinkInfo;

    SetLinkInfo = (PNDIS_WAN_SET_LINK_INFO)OidWorkItem->Context;
    AsyncInfo = (PASYNC_INFO) SetLinkInfo->NdisLinkHandle;
    ExFreePool(OidWorkItem);

    do {

        //
        //  If the port is already closed, we bail out.
        //
        NdisAcquireSpinLock(&AsyncInfo->Lock);

        AsyncInfo->Flags &= ~OID_WORK_SCHEDULED;

        if (AsyncInfo->PortState != PORT_FRAMING) {
    
            Status = NDIS_STATUS_FAILURE;
            NdisReleaseSpinLock(&AsyncInfo->Lock);
            break;
        }
    
        //
        //  Save off the current receive framing bits before we copy the
        //  incoming link information into our local copy.
        //
    
        RecvFramingBits = AsyncInfo->SetLinkInfo.RecvFramingBits;
    
        //
        //  Fill in the NDIS_WAN_SET_LINK_INFO structure.
        //
    
        ASYNC_MOVE_MEMORY(&AsyncInfo->SetLinkInfo,
                          SetLinkInfo,
                          sizeof(NDIS_WAN_SET_LINK_INFO));
    
        DbgTracef(1,("ASYNC: Framing change to 0x%.8x from 0x%.8x\n",
                SetLinkInfo->RecvFramingBits, RecvFramingBits));

        AsyncInfo->ExtendedACCM[0] = AsyncInfo->SetLinkInfo.SendACCM;

        //
        // Initialize the Extended ACCM information so that we always
        // escape 0x7D and 0x7E and we never escape 0x5E
        //
        AsyncInfo->ExtendedACCM[2] &= (ULONG) ~0x40000000;
        AsyncInfo->ExtendedACCM[3] |= (ULONG) 0x60000000;

        if (AsyncInfo->Adapter->ExtendedXOnXOff) {

            // If we are escaping XON/XOFF (0x11, 0x13) then we will also
            // escape XON/XOFF with parity set (0x91, 0x93).  This is to
            // work around an interop problem with a cisco router
            // winseraid2 34328
            if (AsyncInfo->ExtendedACCM[0] & (0x01 << (0x11 & 0x1F))) {
                AsyncInfo->ExtendedACCM[4] |= (0x01 << (0x11 & 0x1F));
            } else {
                AsyncInfo->ExtendedACCM[4] &= ~(0x01 << (0x11 & 0x1F));
            }

            if (AsyncInfo->ExtendedACCM[0] & (0x01 << (0x13 & 0x1F))) {
                AsyncInfo->ExtendedACCM[4] |= (0x01 << (0x13 & 0x1F));
            } else {
                AsyncInfo->ExtendedACCM[4] &= ~(0x01 << (0x13 & 0x1F));
            }
        }
    
        //
        // If we are in auto-detect and they want auto-detect
        // then there is nothing to do!!!
        //
        if (!(RecvFramingBits | SetLinkInfo->RecvFramingBits)) {
            Status = NDIS_STATUS_SUCCESS;
            NdisReleaseSpinLock(&AsyncInfo->Lock);
            break;
        }
    
        if (SetLinkInfo->RecvFramingBits == 0 && AsyncInfo->PortState == PORT_FRAMING) {
            //
            // ignore the request
            //
            Status = NDIS_STATUS_SUCCESS;
            NdisReleaseSpinLock(&AsyncInfo->Lock);
            break;
        }
    
        //
        //  If we are changing from PPP framing to another
        //  form of PPP framing, or from SLIP framing to
        //  another form then there is no need to kill the
        //  current framing.
        //
        
        if ((RecvFramingBits & SetLinkInfo->RecvFramingBits & PPP_FRAMING)  ||
            (RecvFramingBits & SetLinkInfo->RecvFramingBits & SLIP_FRAMING) ) {
        
            DbgTracef(-1,("ASYNC: Framing already set to 0x%.8x - ignoring\n",
                SetLinkInfo->RecvFramingBits));
        
            //
            //  We are framing, start reading.
            //
        
            AsyncInfo->PortState = PORT_FRAMING;
        
            Status = NDIS_STATUS_SUCCESS;
            NdisReleaseSpinLock(&AsyncInfo->Lock);
            break;
        }
    
        //
        //  If we have some sort of framing we must
        //  kill that framing and wait for it to die down
        //
    
        KeInitializeEvent(&AsyncInfo->ClosingEvent,
                          SynchronizationEvent,
                          FALSE);
    
        //
        // Signal that port is closing.
        //
    
        AsyncInfo->PortState = PORT_CLOSING;
    
        NdisReleaseSpinLock(&AsyncInfo->Lock);

        //
        //  Now we must send down an IRP
        //
        CancelSerialRequests(AsyncInfo);
    
        //
        //  Synchronize closing with the read irp
        //
        KeWaitForSingleObject (&AsyncInfo->ClosingEvent,
                               UserRequest,
                               KernelMode,
                               FALSE,
                               NULL);
    
        AsyncInfo->PortState = PORT_FRAMING;
    
        AsyncStartReads(AsyncInfo);

        Status = NDIS_STATUS_SUCCESS;

    } while ( 0 );

    NdisMSetInformationComplete(AsyncInfo->Adapter->MiniportHandle, Status);

    //
    // deref the ref applied in MpSetInfo
    //
    DEREF_ASYNCINFO(AsyncInfo, OidWorkItem);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\pppread.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pppread.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#if DBG

#define __FILE_SIG__    'rppP'

#endif

#include "asyncall.h"

NTSTATUS
AsyncSLIPCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);

NTSTATUS
AsyncWaitMaskCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);

NTSTATUS
AsyncPPPWaitMask(
    IN PASYNC_INFO Info)

/*++

Assumption -- 0 length frames are not sent (this includes headers)!!!
Also, this is NOT a synchronous operation.  It is always asynchronous.

Routine Description:

    This service writes Length bytes of data from the caller's Buffer to the
    "port" handle.  It is assumed that the handle uses non-buffered IO.

--*/
{
    NTSTATUS            status;
    PIRP                irp;
    PASYNC_FRAME        pFrame;
    PASYNC_ADAPTER      pAdapter=Info->Adapter;

    pFrame=Info->AsyncFrame;

    irp = 
        IoAllocateIrp(Info->DeviceObject->StackSize, (BOOLEAN)FALSE);
        
    if (irp == NULL) {
        return(NDIS_STATUS_RESOURCES);
    }

    InitSerialIrp(irp,
                  Info,
                  IOCTL_SERIAL_WAIT_ON_MASK,
                  sizeof(ULONG));

    irp->AssociatedIrp.SystemBuffer=&pFrame->WaitMask;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            AsyncWaitMaskCompletionRoutine, // routine to call when irp is done
            Info,                           // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //
    Info->Flags |= ASYNC_FLAG_WAIT_MASK;
    REF_ASYNCINFO(Info, irp);

    status = IoCallDriver(Info->DeviceObject, irp);

    //
    // Status for a local serial driver should be
    // STATUS_SUCCESS since the irp should complete
    // immediately because there are no read timeouts.
    //
    // For a remote serial driver, it will pend.
    //
    return(status);
}


NTSTATUS
AsyncPPPCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)

/*++

    This is the IO Completion routine for ReadFrame.

--*/
{
    NTSTATUS        status;
    PASYNC_INFO     pInfo;
    ULONG           bytesReceived;

    PASYNC_FRAME    pFrame;
    PUCHAR          frameStart, frameEnd;
    USHORT          crcData;
    PUCHAR          frameEnd2,frameStart2;
    LONG            bytesWanted;

    DeviceObject;       // prevent compiler warnings

    status = Irp->IoStatus.Status;
    bytesReceived=(ULONG)Irp->IoStatus.Information;

    IoFreeIrp(Irp);

    pInfo=Context;

    pFrame=pInfo->AsyncFrame;

    switch (status) {

    case STATUS_SUCCESS:

        pFrame=pInfo->AsyncFrame;

        //
        // Any bytes to process?  This can happen if
        // the WaitMask completes late and by the time
        // we process the read, another event character has come
        // in.
        //
        if (bytesReceived==0) {
            break;
        }

        //
        // Update num of bytes read total for this frame
        //
        pInfo->BytesRead = bytesReceived = pInfo->BytesRead + bytesReceived;

        //
        // Set frameEnd to last byte processed.  Initially,
        // we have processed nothing (i.e. processed up to
        // the start of the first byte).
        //
        frameStart=pFrame->Frame + PPP_PADDING;

PROCESS_FRAME:
        //
        // Now we have actuallyRead bytes unused
        // Also, we may have a complete frame.
        //
        while (*frameStart == PPP_FLAG_BYTE && --bytesReceived) {
            frameStart++;
        }

        //
        // If we reach here, there is only a start FLAG...
        //
        if (bytesReceived == 0) {
            break;
        }

        //
        // frameEnd is set to the first byte not yet processed.
        // If we are starting out, that is the first byte!
        //
        frameEnd=frameStart;

        //
        // Assume the start of the frame has the PPP_FLAG_BYTE
        // Look for the second PPP_FLAG_BYTE (end of frame)
        //
        while (*frameEnd != PPP_FLAG_BYTE && --bytesReceived) {
            frameEnd++;
        }

        //
        // At this point...
        // frameStart = beginning PPP_FLAG_BYTE seen
        // frameEnd = end PPP_FLAG_BYTE
        // bytesReceived = bytes after frameEnd not processed
        //

        //
        // if bytesReceived is 0, we ran out of space before hitting
        // the END flag.  We will have to wait for the next round
        //
        // NOTE: if BytesRead gets too high we trash the frame
        // because we could not find the FLAG_BYTE
        //
        if (bytesReceived==0) {
            break;
        }
        
        if (*(pFrame->Frame+PPP_PADDING) != PPP_FLAG_BYTE) {

            //
            // We had garbage at the start.  Remove the garbage.
            //
            pInfo->SerialStats.AlignmentErrors++;

            //
            //  Tell the transport above us that we dropped a packet
            //  Hopefully, it will quickly resync.
            //
            AsyncIndicateFragment(
                pInfo,
                WAN_ERROR_ALIGNMENT);


            goto NEXT_PPP_FRAME;
        }

        //
        // Length of frame is frameEnd - frameStart
        //
        bytesWanted = (LONG)(frameEnd - frameStart);

        frameEnd2 = frameStart2 = frameStart;

        //
        // Replace back all control chars, ESC, and FLAG chars
        //
        while (bytesWanted-- > 0) {
            if ((*frameEnd2=*frameStart2++) == PPP_ESC_BYTE) {

                //
                // We have not run the CRC check yet!!
                // We have be careful about sending bytesWanted
                // back to -1 on corrupted data
                //

                bytesWanted--;

                *frameEnd2 = (*frameStart2++ ^ 0x20);
            }

            frameEnd2++;
        }

        if (*frameStart2 != PPP_FLAG_BYTE) {
            DbgTracef(-2,("BAD PPP FRAME at 0x%.8x  0x%.8x\n", frameStart, frameEnd2));
        }

        //
        // if CRC-16, get 16 bit CRC from end of frame
        //
        frameEnd2 -= 2;

        //
        // Little endian assumptions for CRC
        //
        crcData=(USHORT)frameEnd2[0]+(USHORT)(frameEnd2[1] << 8);
        crcData ^= 0xFFFF;

        //
        // Change the bytesWanted field to what it normally is
        // without the byte stuffing (length of frame between flags)
        // Note that it can be -1 if only one byte was
        // found in between the flag bytes
        //
        bytesWanted = (LONG)(frameEnd2 - frameStart);

        //
        // If we get some sort of garbage inbetween
        // the PPP flags, we just assume it is noise and
        // discard it.  We don't record a PPP CRC error just
        // an alignment error.
        //
        if (bytesWanted < 3) {
            pInfo->SerialStats.AlignmentErrors++;
            //
            //  Tell the transport above us that we dropped a packet
            //  Hopefully, it will quickly resync.
            //
            AsyncIndicateFragment(pInfo, WAN_ERROR_ALIGNMENT);

            goto NEXT_PPP_FRAME;
        }

        //
        // get CRC from FLAG byte to FLAG byte
        //
        if (crcData != CalcCRCPPP(frameStart, bytesWanted)) {

            DbgTracef(0,("---CRC check failed on control char frame!\n"));

            //
            // Record the CRC error
            //
            pInfo->SerialStats.CRCErrors++;

            //
            //  Tell the transport above us that we dropped a packet
            //  Hopefully, it will quickly resync.
            //
            AsyncIndicateFragment(
                pInfo,
                WAN_ERROR_CRC);


            goto NEXT_PPP_FRAME;
        }

/*
        for ( i = 0; (i < (ULONG)bytesWanted) && (i < 48); i++ )
        {
            if ( (i & 15) == 0 )
                DbgTracef(-1, ("\nrx:\t") );
            DbgTracef(-1, ("%.2x ", frameStart[i]) );
        }
        DbgTracef(-1, ("\n") );
*/
    {
        KIRQL               irql;
        NDIS_STATUS         Status;
        PASYNC_ADAPTER      Adapter = pInfo->Adapter;

        KeRaiseIrql( (KIRQL)DISPATCH_LEVEL, &irql );
        //
        // Tell the transport above (or really RasHub) that the connection
        // is now up.  We have a new link speed, frame size, quality of service
        //

        NdisMWanIndicateReceive(&Status,
                               Adapter->MiniportHandle,
                               pInfo->NdisLinkContext,
                               frameStart,              // ptr to start of packet
                               bytesWanted);            // Total packet length  - header
        NdisMWanIndicateReceiveComplete(Adapter->MiniportHandle,
                                       pInfo->NdisLinkContext);

        KeLowerIrql( irql );
    }
    
    NEXT_PPP_FRAME:

        //
        // if bytesReceived == 0 no frame was found
        // thus we must keep the current frame and continue
        // processing
        //
        if (bytesReceived) {

            //
            // Calculate how much of what we received
            // just got passed up as a frame and move the
            // rest to the beginning.
            //
            frameStart=pFrame->Frame + PPP_PADDING;
            frameEnd2=frameStart + pInfo->BytesRead;
            pInfo->BytesRead =
                            bytesReceived = (ULONG)(frameEnd2-frameEnd);

            ASYNC_MOVE_MEMORY(
                frameStart,         // dest
                frameEnd,           // src
                bytesReceived);     // length

            //
            // Need at least four bytes for a frame to exist
            //
            if (bytesReceived > 3) {
                goto PROCESS_FRAME;
            }
        }

        break;

    case STATUS_PENDING:
        DbgTracef(0,("---ASYNC: Status PENDING on read\n"));
        pInfo->Flags &= ~(ASYNC_FLAG_PPP_READ);
#if DBG
        pInfo->PppreadsCompleted++;
#endif
        DEREF_ASYNCINFO(pInfo, Irp);
        // return(STATUS_MORE_PROCESSING_REQUIRED);
        goto done;

    case STATUS_CANCELLED:
        // else this is an anomally!
        DbgTracef(-2,("---ASYNC: Status cancelled on read for unknown reason!!\n"));
        pInfo->Flags &= ~(ASYNC_FLAG_PPP_READ);
        DEREF_ASYNCINFO(pInfo, Irp);
#if DBG
        pInfo->PppreadsCompleted++;
#endif
        //return(STATUS_MORE_PROCESSING_REQUIRED);
        goto done;

    default:
#if DBG
        DbgPrint ("AsyncPPPCompletionRoutine: status == %x, no more reads\n", status) ;
#endif
        pInfo->Flags &= ~(ASYNC_FLAG_PPP_READ);
        DEREF_ASYNCINFO(pInfo, Irp);
#if DBG
        pInfo->PppreadsCompleted++;
#endif
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    if(status == STATUS_SUCCESS)
    {
        //
        // Here we are at the end of processing this IRP so we go
        // ahead and post another read from the serial port. 
        //
        AsyncPPPWaitMask(pInfo);
    }

    // We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    pInfo->Flags &= ~(ASYNC_FLAG_PPP_READ);
    DEREF_ASYNCINFO(pInfo, Irp);
#if DBG
    pInfo->PppreadsCompleted++;
#endif

done:
    if(status != STATUS_SUCCESS)
    {
        if(pInfo->PortState == PORT_CLOSING ||
           pInfo->PortState == PORT_CLOSED)
        {
            KeSetEvent(&pInfo->ClosingEvent,
                       1,
                       (BOOLEAN) FALSE);
        }
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


NTSTATUS
AsyncPPPRead(
    IN PASYNC_INFO Info)


/*++

Assumption -- 0 length frames are not sent (this includes headers)!!!
Also, this is NOT a synchronous operation.  It is always asynchronous.

MUST use non-paged pool to read!!!

Routine Description:

    This service writes Length bytes of data from the caller's Buffer to the
    "port" handle.  It is assumed that the handle uses non-buffered IO.

--*/
{
    NTSTATUS            status;
    PIRP                irp;
    PDEVICE_OBJECT      deviceObject=Info->DeviceObject;
    PFILE_OBJECT        fileObject=Info->FileObject;
    PIO_STACK_LOCATION  irpSp;
    PASYNC_FRAME        pFrame;
    PASYNC_ADAPTER      pAdapter=Info->Adapter;
    PIO_COMPLETION_ROUTINE routine;

    pFrame=Info->AsyncFrame;

    //
    // check if this port is closing down or already closed
    //
    if (Info->PortState == PORT_CLOSING ||
        Info->PortState == PORT_CLOSED) {

        if (Info->PortState == PORT_CLOSED) {
            DbgTracef(-2,("ASYNC: Port closed - but still reading on it!\n"));
        }

        //
        // Acknowledge that the port is closed
        //
        KeSetEvent(&Info->ClosingEvent,     // Event
                   1,                           // Priority
                   (BOOLEAN)FALSE);         // Wait (does not follow)

        //
        // Ok, if this happens, we are shutting down.  Stop
        // posting reads.  Don't make it try to deallocate the irp!
        //
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    //
    //  Has our stack counter reached its max?
    //

    if ( Info->ReadStackCounter > 1 ) {

        //
        //  Send off the worker thread to compress this frame
        //
    
        ExInitializeWorkItem(&pFrame->WorkItem,
            (PWORKER_THREAD_ROUTINE) AsyncPPPRead, Info);

        //
        // reset stack counter since we are scheduling
        // a worker thread
        //
        Info->ReadStackCounter=0;

        //
        //  We choose to be nice and use delayed.
        //

        ExQueueWorkItem(&pFrame->WorkItem, DelayedWorkQueue);


        return NDIS_STATUS_PENDING;
    }

    //
    //  One more stack used up.
    //

    Info->ReadStackCounter++;


    // get irp from frame (each frame has an irp allocate with it)

    irp =
        IoAllocateIrp(Info->DeviceObject->StackSize, (BOOLEAN)FALSE);
        
    if (irp == NULL) {
        return(NDIS_STATUS_RESOURCES);
    }

    // Setup this irp with defaults
    AsyncSetupIrp(pFrame, irp);

    //
    // If we've read all the bytes we can and we still do not
    // have a frame, we trash our buffer and start over
    // again.
    //

    if (Info->BytesRead >= (DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE - PPP_PADDING)) {

        Info->SerialStats.BufferOverrunErrors++;

        //
        //  Tell the transport above us that we dropped a packet
        //  Hopefully, it will quickly resync.
        //
        AsyncIndicateFragment(Info, WAN_ERROR_BUFFEROVERRUN);

        Info->BytesRead=0;
    }
    
    irp->AssociatedIrp.SystemBuffer =
         pFrame->Frame + Info->BytesRead + PPP_PADDING;


    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;
    if (fileObject->Flags & FO_WRITE_THROUGH) {
        irpSp->Flags = SL_WRITE_THROUGH;
    }

    //
    // If this write operation is to be performed without any caching, set the
    // appropriate flag in the IRP so no caching is performed.
    //

    irp->Flags |= IRP_READ_OPERATION;

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Read.Length =
        DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE - Info->BytesRead - PPP_PADDING;

    irpSp->Parameters.Read.Key = 0;                     // we don't use a key
    irpSp->Parameters.Read.ByteOffset = fileObject->CurrentByteOffset;

    if ( Info->GetLinkInfo.SendFramingBits & SLIP_FRAMING ) {

        routine=AsyncSLIPCompletionRoutine;
        Info->Flags |= ASYNC_FLAG_SLIP_READ;

    } else {
        Info->Flags |= ASYNC_FLAG_PPP_READ;
#if DBG
        Info->Pppreads++;
#endif
        routine=AsyncPPPCompletionRoutine;
    }

    REF_ASYNCINFO(Info, irp);
    IoSetCompletionRoutine(
            irp,                            // irp to use
            routine,                        // routine to call when irp is done
            Info,                           // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // We DO NOT insert the packet at the head of the IRP list for the thread.
    // because we do NOT really have an IoCompletionRoutine that does
    // anything with the thread.
    //


    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(deviceObject, irp);

    //
    // unroll the stack counter
    //
    if ( Info->ReadStackCounter > 0 ) {

        Info->ReadStackCounter--;
    }

    //
    // Status for a local serial driver should be
    // STATUS_SUCCESS since the irp should complete
    // immediately because there are no read timeouts.
    //
    // For a remote serial driver, it will pend.
    //
    return(status);
}


NTSTATUS
AsyncWaitMaskCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)

/*++

    This is the IO Completion routine for ReadFrame.

--*/
{
    NTSTATUS        status;
    PASYNC_INFO     pInfo=Context;
    PASYNC_FRAME    pFrame;
    DeviceObject;   // avoid compiler warnings

    status = Irp->IoStatus.Status;
    pFrame=pInfo->AsyncFrame;

    IoFreeIrp(Irp);

    // check if this port is closing down or already closed
    if (pInfo->PortState == PORT_CLOSING ||
        pInfo->PortState == PORT_CLOSED) {

        if (pInfo->PortState == PORT_CLOSED) {
            DbgTracef(-2,("ASYNC: Port closed - but still reading on it!\n"));
        }

        //
        // Acknowledge that the port is closed
        //
        KeSetEvent(
            &pInfo->ClosingEvent,       // Event
            1,                          // Priority
            (BOOLEAN)FALSE);            // Wait (does not follow)

        DbgTracef(1,("ASYNC: PPP no longer holds the wait_on_mask\n"));

        pInfo->Flags &= ~(ASYNC_FLAG_WAIT_MASK);

        DEREF_ASYNCINFO(pInfo, Irp);
        //
        // Ok, if this happens, we are shutting down.  Stop
        // posting reads.  Don't make it try to deallocate the irp!
        //
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    // wait failed
    //
    if (status != STATUS_SUCCESS) {

        pInfo->PortState = PORT_FRAMING;
        pInfo->Flags &= ~(ASYNC_FLAG_WAIT_MASK);
        DEREF_ASYNCINFO(pInfo, Irp);
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    //
    //  Send off a irp to check comm status
    //  of this port (because we suspect a problem).
    //
    if (pFrame->WaitMask & SERIAL_EV_ERR) {
        AsyncCheckCommStatus(pInfo);
    }

    //
    // Check if RLSD or DSR changed state.
    // If so, we probably have to complete and IRP
    //
    if (pFrame->WaitMask & (SERIAL_EV_RLSD | SERIAL_EV_DSR)) {
        TryToCompleteDDCDIrp(pInfo);
    }

#if DBG
    if (status == STATUS_INVALID_PARAMETER) {

        DbgPrint("ASYNC: PPP BAD WAIT MASK!  Irp is at 0x%.8x\n",Irp);
        DbgBreakPoint();
    }
#endif

    //
    // If we have some more bytes (specifically the event character)
    // in the buffer, let's process those new bytes
    //
    if (pFrame->WaitMask & (SERIAL_EV_RXFLAG | SERIAL_EV_RX80FULL)) {

        //
        // Read current buffer and try to process a frame
        //

        AsyncPPPRead(pInfo);

    } else {
        //
        // Set another WaitMask call
        //
        AsyncPPPWaitMask(pInfo);
    }
    pInfo->Flags &= ~(ASYNC_FLAG_WAIT_MASK);
    DEREF_ASYNCINFO(pInfo, Irp);
    
    // We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    return(STATUS_MORE_PROCESSING_REQUIRED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\mp.c ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    mp.c
    
Abstract:

    This file contains the routines that asyncmac uses to present
    the NDIS 5.0 miniport interface
    
Author:

    Tony Bell   (TonyBe) May 20, 1997

Environment:

    Kernel Mode

Revision History:

    TonyBe      05/20/97        Created

--*/

#include "asyncall.h"

extern  NDIS_HANDLE NdisWrapperHandle;

VOID    
MpHalt(
    IN NDIS_HANDLE  MiniportAdapterContext
    )
{
    PASYNC_ADAPTER  Adapter = (PASYNC_ADAPTER)MiniportAdapterContext;

    DbgTracef(0,("AsyncMac: In MpHalt\n"));

    NdisAcquireSpinLock(&GlobalLock);

    ASSERT(Adapter == GlobalAdapter);

#if DBG
    if (InterlockedCompareExchange(&glConnectionCount, 0, 0) != 0) {
        DbgPrint("MpHalt with outstanding connections!\n");
        DbgBreakPoint();
    }
#endif

    GlobalAdapterCount--;
    GlobalAdapter = NULL;

    NdisReleaseSpinLock(&GlobalLock);

    ExDeleteNPagedLookasideList(&Adapter->AsyncFrameList);

#ifndef MY_DEVICE_OBJECT
    if (AsyncDeviceHandle != NULL) {
        NdisMDeregisterDevice(AsyncDeviceHandle);
        AsyncDeviceHandle = NULL;
        AsyncDeviceObject = NULL;
    }
#endif

    ExFreePool(Adapter);

    return;

}

NDIS_STATUS
MpInit(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN  PNDIS_MEDIUM    MediumArray,
    IN  UINT            MediumArraySize,
    IN  NDIS_HANDLE     MiniportAdapterHandle,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    )
{
    //
    // Pointer for the adapter root.
    //
    PASYNC_ADAPTER Adapter;

    NDIS_HANDLE ConfigHandle;
    PNDIS_CONFIGURATION_PARAMETER ReturnedValue;

    NDIS_STRING PortsStr    = NDIS_STRING_CONST("Ports");

    NDIS_STRING IrpStackSizeStr = NDIS_STRING_CONST("IrpStackSize");
    NDIS_STRING MaxFrameSizeStr = NDIS_STRING_CONST("MaxFrameSize");
    NDIS_STRING FramesPerPortStr= NDIS_STRING_CONST("FramesPerPort");
    NDIS_STRING XonXoffStr      = NDIS_STRING_CONST("XonXoff");
    NDIS_STRING TimeoutBaseStr=   NDIS_STRING_CONST("TimeoutBase");
    NDIS_STRING TimeoutBaudStr=   NDIS_STRING_CONST("TimeoutBaud");
    NDIS_STRING TimeoutReSyncStr= NDIS_STRING_CONST("TimeoutReSync");
    NDIS_STRING WriteBufferingStr= NDIS_STRING_CONST("WriteBufferingEnabled");
    NDIS_STRING ExtendedXOnXOffStr= NDIS_STRING_CONST("ExtendedXonXoffEnabled");

    NDIS_STATUS Status;

    // assign some defaults if these strings are not found in the registry

    UCHAR       irpStackSize  = DEFAULT_IRP_STACK_SIZE;
    ULONG       maxFrameSize  = DEFAULT_MAX_FRAME_SIZE;
    USHORT      framesPerPort = DEFAULT_FRAMES_PER_PORT;
    ULONG       xonXoff       = DEFAULT_XON_XOFF;
    ULONG       timeoutBase   = DEFAULT_TIMEOUT_BASE;
    ULONG       timeoutBaud   = DEFAULT_TIMEOUT_BAUD;
    ULONG       timeoutReSync = DEFAULT_TIMEOUT_RESYNC;
    ULONG       WriteBufferingEnabled = 1;
    ULONG       NeededFrameSize;
    ULONG       extendedXOnXOff = DEFAULT_EXTENDED_XONXOFF;

    UINT        MaxMulticastList = 32;
    USHORT      i;      // counter

    //
    // We only support a single instance of AsyncMac
    //
    if (GlobalAdapterCount != 0) {
        return NDIS_STATUS_FAILURE;
    }

    for (i = 0; i < MediumArraySize; i++) {
        if (MediumArray[i] == NdisMediumWan) {
            break;
        }
    }

    if (i == MediumArraySize) {
        return (NDIS_STATUS_UNSUPPORTED_MEDIA);
    }

    *SelectedMediumIndex = i;

    //
    //  Card specific information.
    //


    //
    // Allocate the Adapter block.
    //
    Adapter = (PASYNC_ADAPTER)
        ExAllocatePoolWithTag(NonPagedPool,
                              sizeof(ASYNC_ADAPTER),
                              ASYNC_ADAPTER_TAG);
    if (Adapter == NULL){

        DbgTracef(-1,("AsyncMac: Could not allocate physical memory!!!\n"));
        return NDIS_STATUS_RESOURCES;
    }

    ASYNC_ZERO_MEMORY(Adapter, sizeof(ASYNC_ADAPTER));

    Adapter->MiniportHandle = MiniportAdapterHandle;

    NdisOpenConfiguration(
                    &Status,
                    &ConfigHandle,
                    WrapperConfigurationContext);

    if (Status != NDIS_STATUS_SUCCESS) {

        return NDIS_STATUS_FAILURE;

    }

    //
    // Read if the default IrpStackSize is used for this adapter.
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &IrpStackSizeStr,
                    NdisParameterInteger);

    if ( Status == NDIS_STATUS_SUCCESS ) {

        irpStackSize=(UCHAR)ReturnedValue->ParameterData.IntegerData;

        DbgTracef(0,("This MAC Adapter has an irp stack size of %u.\n",irpStackSize));
    }

    //
    // Read if the default MaxFrameSize is used for this adapter.
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &MaxFrameSizeStr,
                    NdisParameterInteger);

    if ( Status == NDIS_STATUS_SUCCESS ) {

        maxFrameSize=ReturnedValue->ParameterData.IntegerData;

        DbgTracef(0,("This MAC Adapter has a max frame size of %u.\n",maxFrameSize));
    }

    //
    // Read if the default for frames per port is changed
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &FramesPerPortStr,
                    NdisParameterInteger);

    if ( Status == NDIS_STATUS_SUCCESS ) {

        framesPerPort=(USHORT)ReturnedValue->ParameterData.IntegerData;

        DbgTracef(0,("This MAC Adapter has frames per port set to: %u.\n",framesPerPort));
    }

    //
    // Read if the default for Xon Xoff is changed
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &XonXoffStr,
                    NdisParameterInteger);


    if (Status == NDIS_STATUS_SUCCESS) {

        xonXoff=(ULONG)ReturnedValue->ParameterData.IntegerData;
        DbgTracef(0,("This MAC Adapter has Xon/Xoff set to: %u.\n",xonXoff));
    }

    //
    // Read if the default for Timeout Base has changed
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &TimeoutBaseStr,
                    NdisParameterInteger);

    if ( Status == NDIS_STATUS_SUCCESS ) {

        timeoutBase = ReturnedValue->ParameterData.IntegerData;

        DbgTracef(0,("This MAC Adapter has TimeoutBase set to: %u.\n", timeoutBase));
    }

    //
    // Read if the default for Timeout Baud has changed
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &TimeoutBaudStr,
                    NdisParameterInteger);

    if ( Status == NDIS_STATUS_SUCCESS ) {

        timeoutBaud = ReturnedValue->ParameterData.IntegerData;

        DbgTracef(0,("This MAC Adapter has TimeoutBaud set to: %u.\n", timeoutBaud));
    }

    //
    // Read if the default for Timeout ReSync has changed
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &TimeoutReSyncStr,
                    NdisParameterInteger);

    if (Status == NDIS_STATUS_SUCCESS) {
        timeoutReSync=ReturnedValue->ParameterData.IntegerData;
        DbgTracef(0,("This MAC Adapter has TimeoutReSync set to: %u.\n",timeoutReSync));
    }

    NdisReadConfiguration(&Status,
                          &ReturnedValue,
                          ConfigHandle,
                          &WriteBufferingStr,
                          NdisParameterInteger);

    if (Status == NDIS_STATUS_SUCCESS) {
        WriteBufferingEnabled = ReturnedValue->ParameterData.IntegerData;
        DbgTracef(0,("This MAC Adapter has WriteBufferingEnabled set to: %u.\n", WriteBufferingEnabled));
    }
    
    //
    // Read if the default Extended Xon Xoff is changed
    //

    NdisReadConfiguration(
                    &Status,
                    &ReturnedValue,
                    ConfigHandle,
                    &ExtendedXOnXOffStr,
                    NdisParameterInteger);


    if (Status == NDIS_STATUS_SUCCESS) {

        extendedXOnXOff=(ULONG)ReturnedValue->ParameterData.IntegerData;
        DbgTracef(0,("This MAC Adapter has Extended Xon/Xoff set to: %u.\n",extendedXOnXOff));
    }
    
    NdisCloseConfiguration(ConfigHandle);

    NdisMSetAttributesEx(MiniportAdapterHandle,
                         Adapter,
                         (UINT)-1,
                         NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT  |
                         NDIS_ATTRIBUTE_DESERIALIZE             |
                         NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
                         NdisInterfaceInternal);

    //
    //  Initialize the ADAPTER structure here!!!
    //
    NdisAllocateSpinLock(&Adapter->Lock);
    Adapter->IrpStackSize       = irpStackSize;

    //
    // We double the max frame size for PPP byte stuffing.
    // We also tack on some PADDING just to be safe.
    //

    //
    // Changed by DigiBoard 10/06/1995
    //
    //    Adapter->MaxFrameSize       = maxFrameSize;
    Adapter->MaxFrameSize       = (maxFrameSize * 2) + PPP_PADDING + 100;

    Adapter->FramesPerPort      = (framesPerPort > 0) ?
                                  framesPerPort : DEFAULT_FRAMES_PER_PORT;

    Adapter->TimeoutBase        = timeoutBase;
    Adapter->TimeoutBaud        = timeoutBaud;
    Adapter->TimeoutReSync      = timeoutReSync;
    Adapter->WriteBufferingEnabled = WriteBufferingEnabled;
    InitializeListHead(&Adapter->ActivePorts);
    Adapter->ExtendedXOnXOff = extendedXOnXOff;

    //
    // Init the frame lookaside list.  DataSize is dependent
    // on compression compile option.
    //
    {
        ULONG   DataSize;

        DataSize = Adapter->MaxFrameSize;
    
        if (DataSize < DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE)
            DataSize = DEFAULT_EXPANDED_PPP_MAX_FRAME_SIZE;

        ExInitializeNPagedLookasideList(&Adapter->AsyncFrameList,
                                        NULL,
                                        NULL,
                                        0,
                                        sizeof(ASYNC_FRAME) +
                                        DataSize +
                                        sizeof(PVOID),
                                        ASYNC_FRAME_TAG,
                                        0);
    }

    //
    // Insert this "new" adapter into our list of all Adapters.
    //

    NdisAcquireSpinLock(&GlobalLock);

    GlobalAdapter = Adapter;
    GlobalAdapterCount++;

    NdisReleaseSpinLock(&GlobalLock);

#ifndef MY_DEVICE_OBJECT
    if (AsyncDeviceObject == NULL) {
        PDRIVER_DISPATCH DispatchTable[IRP_MJ_MAXIMUM_FUNCTION] = {NULL};
        NDIS_STRING SymbolicName = NDIS_STRING_CONST("\\DosDevices\\ASYNCMAC");
        NDIS_STRING Name = NDIS_STRING_CONST("\\Device\\ASYNCMAC");
        NTSTATUS    retStatus;


        DispatchTable[IRP_MJ_CREATE] = AsyncDriverCreate;
        DispatchTable[IRP_MJ_DEVICE_CONTROL] = AsyncDriverDispatch;
        DispatchTable[IRP_MJ_CLEANUP] = AsyncDriverCleanup;

        retStatus =
        NdisMRegisterDevice(NdisWrapperHandle,
                            &Name,
                            &SymbolicName,
                            DispatchTable,
                            &AsyncDeviceObject,
                            &AsyncDeviceHandle);

        if (retStatus == STATUS_SUCCESS) {
            AsyncDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        } else {
            AsyncDeviceObject = NULL;
        }
    }
#endif

    //
    //  Initialize the WAN info here.
    //
    Adapter->WanInfo.MaxFrameSize               = DEFAULT_PPP_MAX_FRAME_SIZE;
    Adapter->WanInfo.MaxTransmit                = 2;
    Adapter->WanInfo.HeaderPadding              = DEFAULT_PPP_MAX_FRAME_SIZE;
    Adapter->WanInfo.TailPadding                = 4 + sizeof(IO_STATUS_BLOCK);
    Adapter->WanInfo.MemoryFlags                = 0;
    Adapter->WanInfo.HighestAcceptableAddress   = HighestAcceptableMax;
    Adapter->WanInfo.Endpoints                  = 1000;
    Adapter->WanInfo.FramingBits                = PPP_ALL | SLIP_ALL;
    Adapter->WanInfo.DesiredACCM                = xonXoff;

    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
MpReconfigure(
    OUT PNDIS_STATUS    OpenErrorStatus,
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    )
{
    return (NDIS_STATUS_SUCCESS);

}

NDIS_STATUS
MpReset(
    OUT PBOOLEAN        AddressingReset,
    IN  NDIS_HANDLE     MiniportAdapterContext
    )
{
    *AddressingReset = FALSE;

    return (NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\read.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    _read.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/
#include "asyncall.h"

#define RAISEIRQL

#if DBG
ULONG UlFramesUp = 0;
#endif


#ifdef  LALALA
PVOID   CurrentWatchPoint=0;

static
VOID
AsyncSetBreakPoint(
    PVOID   LinearAddress) {

    ASSERT(CurrentWatchPoint == 0);
    CurrentWatchPoint = LinearAddress;

    _asm {
        mov eax, LinearAddress
        mov dr0, eax
        mov eax, dr7
        or  eax, 10303h
        mov dr7, eax
    }
}


static
VOID
AsyncRemoveBreakPoint(
    PVOID LinearAddress) {

    ASSERT(CurrentWatchPoint == LinearAddress);
    CurrentWatchPoint = 0;

    _asm {

        mov eax, dr7
        mov ebx, 10003h
        not ebx
        and eax, ebx
        mov dr7, eax

    }
}
#endif

//   the function below is called by an executive worker thread
//   to start reading frames.

NTSTATUS
AsyncStartReads(
    PASYNC_INFO pInfo
)

/*++



--*/

{
    UCHAR   eventChar;

    //
    //   Initialize locals.
    //

    //
    //  assign back ptr from frame to adapter
    //

    pInfo->AsyncFrame->Adapter = pInfo->Adapter;

    //
    //  assign other back ptr
    //

    pInfo->AsyncFrame->Info = pInfo;

    //
    //  set baud rate and timeouts
    //  we use a linkspeed of 0 to indicate
    //  no read interval timeout
    //

    SetSerialStuff(NULL, pInfo, 0);

    eventChar = PPP_FLAG_BYTE;

    if (pInfo->GetLinkInfo.RecvFramingBits & SLIP_FRAMING) {

        eventChar = SLIP_END_BYTE;
    }

    SerialSetEventChar(pInfo, eventChar);

    //
    //   We will wait on whenever we get the special PPP flag byte
    //   or whenever we get RLSD or DSR changes (for possible hang-up
    //   cases) or when the receive buffer is getting full.
    //

    SerialSetWaitMask(pInfo, pInfo->WaitMaskToUse) ;

    //
    //   For SLIP and PPP reads we use the AsyncPPPRead routine.
    //
    AsyncPPPRead(pInfo);

    return NDIS_STATUS_SUCCESS;
}


VOID
AsyncIndicateFragment(
    IN PASYNC_INFO  pInfo,
    IN ULONG        Error)
{

    PASYNC_ADAPTER      pAdapter=pInfo->Adapter;
    NDIS_MAC_FRAGMENT   AsyncFragment;

    AsyncFragment.NdisLinkContext = pInfo->NdisLinkContext;
    AsyncFragment.Errors = Error;


    //
    //  Tell the transport above (or really RasHub) that a frame
    //  was just dropped.  Give the endpoint when doing so.
    //
    NdisMIndicateStatus(
        pAdapter->MiniportHandle,
        NDIS_STATUS_WAN_FRAGMENT,       //  General Status
        &AsyncFragment,                 //  Specific Status (address)
        sizeof(NDIS_MAC_FRAGMENT));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\pppframe.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    pppframe.c

Abstract:

Author:

    Thomas J. Dimitri  (TommyD)

Environment:

Revision History:

--*/

#include "asyncall.h"

VOID
AssemblePPPFrame(
    PNDIS_WAN_PACKET    WanPacket)

{
    PUCHAR      pOldFrame;
    PUCHAR      pNewFrame;
    USHORT      crcData;
    UINT        dataSize;
    PASYNC_INFO pInfo;

    //
    // Initialize locals
    //

    pOldFrame = WanPacket->CurrentBuffer;

    pNewFrame = WanPacket->StartBuffer;

    //
    // for quicker access, get a copy of data length field
    //
    dataSize = WanPacket->CurrentLength;

    pInfo = WanPacket->MacReserved1;
                        

//
// Now we run through the entire frame and pad it FORWARDS...
//
// <------------- new frame -----------> (could be twice as large)
// +-----------------------------------+
// |                                 |x|
// +-----------------------------------+
//                                    ^
// <---- old frame -->                |
// +-----------------+                |
// |               |x|                |
// +-----------------+                |
//                  |                 |
//                  \-----------------/
//
// so that we don't overrun ourselves
//
//-----------------------------------------------------------------------
//
//         +----------+----------+----------+----------+------------
//         |   Flag   | Address  | Control  | Protocol | Information
//         | 01111110 | 11111111 | 00000011 | 16 bits  |      *
//         +----------+----------+----------+----------+------------
//                 ---+----------+----------+-----------------
//                    |   FCS    |   Flag   | Inter-frame Fill
//                    | 16 bits  | 01111110 | or next Address
//                 ---+----------+----------+-----------------
//
//
// Frame Check Sequence (FCS) Field
//
//   The Frame Check Sequence field is normally 16 bits (two octets).  The
//   use of other FCS lengths may be defined at a later time, or by prior
//   agreement.
//
//   The FCS field is calculated over all bits of the Address, Control,
//   Protocol and Information fields not including any start and stop bits
//   (asynchronous) and any bits (synchronous) or octets (asynchronous)
//   inserted for transparency.  This does not include the Flag Sequences
//   or the FCS field itself.  The FCS is transmitted with the coefficient
//   of the highest term first.
//
//      Note: When octets are received which are flagged in the Async-
//      Control-Character-Map, they are discarded before calculating the
//      FCS.  See the description in Appendix A.
//
//
//  RFC 1331                Point-to-Point Protocol                 May 1992
//  Transparency
//
//      On asynchronous links, a character stuffing procedure is used.
//      The Control Escape octet is defined as binary 01111101
//      (hexadecimal 0x7d) where the bit positions are numbered 87654321
//      (not 76543210, BEWARE).
//
//      After FCS computation, the transmitter examines the entire frame
//      between the two Flag Sequences.  Each Flag Sequence, Control
//      Escape octet and octet with value less than hexadecimal 0x20 which
//      is flagged in the Remote Async-Control-Character-Map is replaced
//      by a two octet sequence consisting of the Control Escape octet and
//      the original octet with bit 6 complemented (i.e., exclusive-or'd
//      with hexadecimal 0x20).
//
//      Prior to FCS computation, the receiver examines the entire frame
//      between the two Flag Sequences.  Each octet with value less than
//      hexadecimal 0x20 is checked.  If it is flagged in the Local
//      Async-Control-Character-Map, it is simply removed (it may have
//      been inserted by intervening data communications equipment).  For
//      each Control Escape octet, that octet is also removed, but bit 6
//      of the following octet is complemented.  A Control Escape octet
//      immediately preceding the closing Flag Sequence indicates an
//      invalid frame.
//
//         Note: The inclusion of all octets less than hexadecimal 0x20
//         allows all ASCII control characters [10] excluding DEL (Delete)
//         to be transparently communicated through almost all known data
//         communications equipment.
//
//
//      The transmitter may also send octets with value in the range 0x40
//      through 0xff (except 0x5e) in Control Escape format.  Since these
//      octet values are not negotiable, this does not solve the problem
//      of receivers which cannot handle all non-control characters.
//      Also, since the technique does not affect the 8th bit, this does
//      not solve problems for communications links that can send only 7-
//      bit characters.
//
//      A few examples may make this more clear.  Packet data is
//      transmitted on the link as follows:
//
//         0x7e is encoded as 0x7d, 0x5e.
//         0x7d is encoded as 0x7d, 0x5d.
//
//         0x01 is encoded as 0x7d, 0x21.
//
//      Some modems with software flow control may intercept outgoing DC1
//      and DC3 ignoring the 8th (parity) bit.  This data would be
//      transmitted on the link as follows:
//
//         0x11 is encoded as 0x7d, 0x31.
//         0x13 is encoded as 0x7d, 0x33.
//         0x91 is encoded as 0x7d, 0xb1.
//         0x93 is encoded as 0x7d, 0xb3.
//


    //
    // put CRC from FLAG byte to FLAG byte
    //
    crcData=CalcCRCPPP(pOldFrame,   // Skip FLAG
                       dataSize);   // All the way to end

    crcData ^= 0xFFFF;

    //
    // Do it the hard way to avoid little endian problems.
    //
    pOldFrame[dataSize]=(UCHAR)(crcData);
    pOldFrame[dataSize+1]=(UCHAR)(crcData >> 8);

    dataSize += 2;  // include two CRC bytes we just added

    *pNewFrame++ = PPP_FLAG_BYTE; // 0x7e - mark beginning of frame

    //
    // If we do not have a bitMask (common case), we use a faster loop
    //
    if (pInfo->ExtendedACCM[0] != 0) {
    
        //
        // loop to remove all control, ESC, and FLAG chars
        //
        while (dataSize--) {
            UCHAR c;

            c=*pOldFrame++; // get current byte in frame

            //
            // Check if we have to escape out this byte or not
            //
            if ( (0x01 << (c & 0x1F)) & pInfo->ExtendedACCM[c >> 5]) {
            
                *pNewFrame++ = PPP_ESC_BYTE;
                *pNewFrame++ = c ^ 0x20;

            } else {
    
                *pNewFrame++ = c;
            }
        }

    } else {

        //
        // loop to remove all ESC and FLAG chars
        //
        while (dataSize--) {
            UCHAR c;

            c=*pOldFrame++; // get current byte in frame

            //
            // Check if we have to escape out this byte or not
            //
            if (c == PPP_ESC_BYTE || c == PPP_FLAG_BYTE) {
            
                *pNewFrame++ = PPP_ESC_BYTE;
                *pNewFrame++ = c ^ 0x20;

            } else {
    
                *pNewFrame++ = c;
            }
        }

    }


    //
    // Mark end of frame
    //
    *pNewFrame++= PPP_FLAG_BYTE;

    //
    // Calc how many bytes we expanded to including CRC
    //
    WanPacket->CurrentLength = (ULONG)(pNewFrame - WanPacket->StartBuffer);

    //
    // Put in the adjusted length -- actual num of bytes to send
    //

    WanPacket->CurrentBuffer = WanPacket->StartBuffer;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\send.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    send.c

Abstract:


    NOTE: ZZZ There is a potential priority inversion problem when
    allocating the packet.  For nt it looks like we need to raise
    the irql to dpc when we start the allocation.

Author:

    Thomas J. Dimitri 8-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    Ray Patch (raypa)       04/13/94        Modified for new WAN wrapper.

--*/

#if DBG

#define __FILE_SIG__    'dneS'

#endif

#include "asyncall.h"
#include "globals.h"

//
//  Forward references.
//

extern
NTSTATUS
AsyncWriteCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PNDIS_WAN_PACKET WanPacket);

//=============================================================================
//  Function:
//
//      AsyncSend()
//
//  Description:
//
//      This function is the main entry point for transmitting data to the serial
//      driver. When entered, we get the MAC binding handle (a pointer to our
//      private data structure) and the WAN packet which we are going to send.
//      We don't bother queuing the frame, we simple allocate an IRP and ship
//      it to the serial driver and let him worry about it.
//
//  In Parameters:
//
//      NdisLinkContext - Pointer to the ASYNC_INFO structure.
//
//      Packet - WAN packet containing the data to be framed and shipped.
//
//  Out Parameters:
//
//      None.
//
//  Return status:
//
//      NDIS_STATUS_SUCCESS.
//=============================================================================

NDIS_STATUS
MpSend(
    IN NDIS_HANDLE      MacBindingHandle,
    IN NDIS_HANDLE      NdisLinkHandle,
    IN PNDIS_WAN_PACKET Packet)
{

    PASYNC_INFO         AsyncInfo;
    NDIS_STATUS         Status;

    DbgTracef(1,("AS\n"));

    //
    //  Get the open handle for this MAC binding.
    //

    AsyncInfo = (PASYNC_INFO) NdisLinkHandle;

    //
    //  First make sure this link is still up.
    //

    if (AsyncInfo->PortState == PORT_FRAMING &&
        (AsyncInfo->GetLinkInfo.SendFramingBits & 
         (PPP_FRAMING | SLIP_FRAMING)) != 0)
    {

        //
        //  Now we can send this frame.
        //
    
        Status = AsyncSendPacket(
                    NdisLinkHandle,
                    Packet);
    
        // For all Status values (PENDING, SUCCESS, and ERROR) the callback from Write will
        // do a sendcomplete indication so we always return PENDING.
        //
        Status = STATUS_PENDING ;
    }
    else
    {

        DbgTracef(-2,("AsyncSend: Link not found, dropping packet!\n"));

        Status = NDIS_STATUS_SUCCESS;
    }

    return Status;
}

//=============================================================================
//  Function:
//
//      AsyncSendPacket()
//
//  Description:
//      This function is called from AsyncSend() to send an IRP to the serial
//      driver. If this IRP pends, the the I/O complete routine will be called
//      later to complete the request.
//
//  In Parameters:
//
//      Packet - WAN packet containing the data to be framed and shipped.
//
//  Out Parameters:
//
//      None.
//
//  Return status:
//
//      NDIS_STATUS_SUCCESS.
//=============================================================================

NTSTATUS
AsyncSendPacket(
    IN PASYNC_INFO      AsyncInfo,
    IN PNDIS_WAN_PACKET WanPacket)

{
    NTSTATUS            Status;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    PFILE_OBJECT        FileObject;
    PDEVICE_OBJECT      DeviceObject;
    PASYNC_ADAPTER      Adapter;
    UCHAR               irpStackSize;

    //
    //  Initialize locals.
    //

    FileObject   = AsyncInfo->FileObject;

    DeviceObject = AsyncInfo->DeviceObject;

    Adapter = AsyncInfo->Adapter;

    irpStackSize = (UCHAR) Adapter->IrpStackSize;

    //
    //  Get irp from irp pool.
    //

    irp = IoAllocateIrp(DeviceObject->StackSize, (BOOLEAN)FALSE);

    //
    // The IO subsystem may be out of irps.
    //

    if (irp == NULL) {
        return(NDIS_STATUS_RESOURCES);
    }

    //
    // Tuck pointer to AsyncInfo for completion use
    //

    WanPacket->MacReserved1 = AsyncInfo;

    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = NULL;

    //
    // 8 byte align (also use end of packet for IOSB).
    //

    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;


    //
    //  Get a pointer to the stack location for the first driver.  This will be
    //  used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation(irp);

    irpSp->MajorFunction = IRP_MJ_WRITE;

    irpSp->FileObject = FileObject;

    if (FileObject->Flags & FO_WRITE_THROUGH) {

        irpSp->Flags = SL_WRITE_THROUGH;
    }

    //
    //  If this write operation is to be performed without any caching, set the
    //  appropriate flag in the IRP so no caching is performed.
    //

    if (FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

        irp->Flags |= (IRP_NOCACHE | IRP_WRITE_OPERATION);

    } else {

        irp->Flags |= IRP_WRITE_OPERATION;
    }

    //
    //  Assemble a RAS, PPP, SLIP frame type.
    //

    if (AsyncInfo->GetLinkInfo.SendFramingBits & PPP_FRAMING) {

        AssemblePPPFrame(WanPacket);

    } else

    if (AsyncInfo->GetLinkInfo.SendFramingBits & SLIP_FRAMING) {

        AssembleSLIPFrame(WanPacket);

    }

    irp->AssociatedIrp.SystemBuffer =
        WanPacket->CurrentBuffer;

    DbgTracef(0, ("Writing out %.2x %.2x %.2x %.2x %.2x\n",
        WanPacket->CurrentBuffer[0],
        WanPacket->CurrentBuffer[1],
        WanPacket->CurrentBuffer[2],
        WanPacket->CurrentBuffer[3],
        WanPacket->CurrentBuffer[4]));

    //
    //  Copy the caller's parameters to the service-specific portion of the IRP.
    //

    irpSp->Parameters.Write.Length = WanPacket->CurrentLength;

    irpSp->Parameters.Write.Key =  0;

    irpSp->Parameters.Write.ByteOffset = FileObject->CurrentByteOffset;

    //
    //  Setup IRP for callback.
    //

    IoSetCompletionRoutine(
        irp,                            //  irp to use
        AsyncWriteCompletionRoutine,    //  routine to call when irp is done
        WanPacket,                      //  context to pass routine
        TRUE,                           //  call on success
        TRUE,                           //  call on error
        TRUE);                          //  call on cancel


    //
    //  We DO NOT insert the packet at the head of the IRP list for the thread.
    //  because we do NOT really have an IoCompletionRoutine that does
    //  anything with the thread or needs to be in that thread's context.
    //

    GlobalXmitWentOut++;

    AsyncInfo->In++;
    AsyncInfo->Flags |= ASYNC_FLAG_SEND_PACKET;
    REF_ASYNCINFO(AsyncInfo, irp);

    //
    //  Now simply invoke the driver at its dispatch entry with the IRP.
    //

    Status = IoCallDriver(DeviceObject, irp);

    //  According to TonyE, the status for the serial driver should
    //  always be STATUS_PENDING.  DigiBoard usually STATUS_SUCCESS.

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\serial.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    serial.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/
#include "asyncall.h"

#define IopQueueThreadIrp( Irp ) {                      \
    KIRQL irql;                                         \
    KeRaiseIrql( (KIRQL)APC_LEVEL, &irql );             \
    InsertHeadList( &Irp->Tail.Overlay.Thread->IrpList, \
                    &Irp->ThreadListEntry );            \
    KeLowerIrql( irql );                                \
    }


VOID
InitSerialIrp(
    PIRP            irp,
    PASYNC_INFO     pInfo,
    ULONG           IoControlCode,
    ULONG           InputBufferLength)
{
    PIO_STACK_LOCATION  irpSp;
    PFILE_OBJECT    fileObject = pInfo->FileObject;

    irpSp = IoGetNextIrpStackLocation(irp);

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = NULL;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    irp->Flags = IRP_BUFFERED_IO;

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

    //
    // stuff in file object
    //
    irpSp->FileObject = fileObject ;

    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = InputBufferLength;
}

NTSTATUS
SerialIoSyncCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
{
    PASYNC_IO_CTX AsyncIoCtx = (PASYNC_IO_CTX)Context;

    DbgTracef(0,("SerialIoSyncCompletion returns 0x%.8x\n", Irp->IoStatus.Status));

    ASSERT(AsyncIoCtx->Sync == TRUE);

    AsyncIoCtx->IoStatus = Irp->IoStatus;

    KeSetEvent(&AsyncIoCtx->Event,      // Event
               1,                       // Priority
               (BOOLEAN)FALSE);         // Wait (does not follow)


    //
    // We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
SerialIoAsyncCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
{
    DbgTracef(0,("SerialIoAsyncCompletion returns 0x%.8x\n", Irp->IoStatus.Status));

    ASSERT(((PASYNC_IO_CTX)Context)->Sync == FALSE);

    //
    // Free the irp here.  Hopefully this has no disastrous
    // side effects such as the IO system trying to reference
    // the irp when we complete.
    
    IoFreeIrp(Irp);

    AsyncFreeIoCtx((PASYNC_IO_CTX)Context);

    //
    // We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//*
// Note: we ignore the irp passed in to work around a problem where the SET_QUEUE_SIZE ioctl
// is not completed synchronously
//
//*
VOID
SetSerialStuff(
    PIRP        unusedirp,
    PASYNC_INFO     pInfo,
    ULONG       linkSpeed)

{
    NTSTATUS        status;
    PIRP            irp ;
    PASYNC_IO_CTX   AsyncIoCtx;

    //
    // We deallocate the irp in SerialIoAsyncCompletionRoutine
    //
    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_SET_QUEUE_SIZE,
        sizeof(SERIAL_QUEUE_SIZE));


    AsyncIoCtx = AsyncAllocateIoCtx(FALSE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    AsyncIoCtx->SerialQueueSize.InSize=4096;
    AsyncIoCtx->SerialQueueSize.OutSize=4096;

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->SerialQueueSize;


    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoAsyncCompletionRoutine, // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(pInfo->DeviceObject, irp);

    DbgTracef(0,("IoctlSetQueueSize status 0x%.8x\n", status));

    SetSerialTimeouts(pInfo,linkSpeed);
}


VOID
CancelSerialRequests(
    PASYNC_INFO  pInfo)
/*++


--*/

{
    NTSTATUS        status;
    PASYNC_IO_CTX   AsyncIoCtx;
    PIRP            irp;

    //
    // For PPP we must clear the WAIT MASK if it exists
    //

    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_SET_WAIT_MASK,
        sizeof(ULONG));

    AsyncIoCtx = AsyncAllocateIoCtx(TRUE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    AsyncIoCtx->WaitMask = 0;
    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->WaitMask;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoSyncCompletionRoutine,  // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    KeClearEvent(&AsyncIoCtx->Event);

    status = IoCallDriver(pInfo->DeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&AsyncIoCtx->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = AsyncIoCtx->IoStatus.Status;
    }

    DbgTracef(0,("IoctlSerialWaitMask returned with 0x%.8x\n", status));

    if (status != STATUS_SUCCESS) {

        KeSetEvent(&pInfo->ClosingEvent,        //  Event
                   1,                           //  Priority
                   (BOOLEAN)FALSE);         //  Wait (does not follow)
    }

    InitSerialIrp(irp, pInfo, IOCTL_SERIAL_PURGE, sizeof(ULONG));

    RtlZeroMemory(&AsyncIoCtx->IoStatus, sizeof(IO_STATUS_BLOCK));

    // kill all read and write threads.
    AsyncIoCtx->SerialPurge = SERIAL_PURGE_TXABORT | SERIAL_PURGE_RXABORT;

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->SerialPurge;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoSyncCompletionRoutine,  // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel
    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    KeClearEvent(&AsyncIoCtx->Event);
    status = IoCallDriver(pInfo->DeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&AsyncIoCtx->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = AsyncIoCtx->IoStatus.Status;
    }

    if (status != STATUS_SUCCESS) {

        KeSetEvent(&pInfo->ClosingEvent,        //  Event
                   1,                           //  Priority
                   (BOOLEAN)FALSE);             //  Wait (does not follow)
    }

    IoFreeIrp(irp);
    AsyncFreeIoCtx(AsyncIoCtx);

    DbgTracef(0,("IoctlSerialPurge returned with 0x%.8x\n", status));
}

VOID
SetSerialTimeouts(
    PASYNC_INFO         pInfo,
    ULONG               linkSpeed)
/*++


--*/

{
    NTSTATUS            status;
    PIRP                irp;
    PASYNC_ADAPTER      pAdapter=pInfo->Adapter;
    PASYNC_IO_CTX       AsyncIoCtx;

    //
    // We deallocate the irp in SerialIoAsyncCompletionRoutine
    //
    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_SET_TIMEOUTS,
        sizeof(SERIAL_TIMEOUTS));

    AsyncIoCtx = AsyncAllocateIoCtx(FALSE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    //
    // The assumption here is that V.42bis is using 256 byte frames.
    // Thus, it takes (256000 / 8) / (linkspeed in 100's of bits per sec)
    // time in millisecs to get that frame across.
    //
    // 500 or 1/2 sec is the fudge factor for satellite delay on
    // a long distance call
    //

    //
    // If the linkSpeed is high, we assume we are trying to resync
    // so we set the timeout low.  linkSpeed is in 100s of bits per sec.
    //
    if (linkSpeed == 0) {
        //
        // return immediately (PPP or SLIP framing)
        //
        AsyncIoCtx->SerialTimeouts.ReadIntervalTimeout= MAXULONG;

    } else if (linkSpeed > 20000) {

        AsyncIoCtx->SerialTimeouts.ReadIntervalTimeout= pAdapter->TimeoutReSync;

    } else {

        AsyncIoCtx->SerialTimeouts.ReadIntervalTimeout=
            pAdapter->TimeoutBase + (pAdapter->TimeoutBaud / linkSpeed);
    }

    AsyncIoCtx->SerialTimeouts.ReadTotalTimeoutMultiplier=  0;          // none
    AsyncIoCtx->SerialTimeouts.ReadTotalTimeoutConstant=    0;          // none
    AsyncIoCtx->SerialTimeouts.WriteTotalTimeoutMultiplier= 4;          // 2400 baud
    AsyncIoCtx->SerialTimeouts.WriteTotalTimeoutConstant=   4000;       // 4 secs

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->SerialTimeouts;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoAsyncCompletionRoutine, // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(pInfo->DeviceObject, irp);

    DbgTracef(0,("IoctlSetSerialTimeouts returned 0x%.8x\n", status));
}


VOID
SerialSetEscapeChar(
    PASYNC_INFO         pInfo,
    UCHAR               EscapeChar) {

    NTSTATUS            status;
    PIRP                irp;
    PASYNC_IO_CTX   AsyncIoCtx;

    //
    // We deallocate the irp in SerialIoAsyncCompletionRoutine
    //
    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_LSRMST_INSERT,
        sizeof(UCHAR));

    AsyncIoCtx = AsyncAllocateIoCtx(FALSE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    AsyncIoCtx->EscapeChar = EscapeChar;

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->EscapeChar;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoAsyncCompletionRoutine, // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(pInfo->DeviceObject, irp);

    DbgTracef(0,("IoctlSetEscapeChar returned with 0x%.8x\n", status));
}


VOID
SerialSetWaitMask(
    PASYNC_INFO         pInfo,
    ULONG               WaitMask) {

    NTSTATUS            status;
    PIRP                irp;
    PASYNC_IO_CTX   AsyncIoCtx;

    //
    // We deallocate the irp in SerialIoAsyncCompletionRoutine
    //
    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_SET_WAIT_MASK,
        sizeof(ULONG));

    AsyncIoCtx = AsyncAllocateIoCtx(FALSE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    AsyncIoCtx->WaitMask = WaitMask;

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->WaitMask;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoAsyncCompletionRoutine, // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //
    status = IoCallDriver(pInfo->DeviceObject, irp);

    DbgTracef(0,("IoctlSetWaitMask returned with 0x%.8x\n", status));
}

VOID
SerialSetEventChar(
    PASYNC_INFO         pInfo,
    UCHAR               EventChar) {

    NTSTATUS            status;
    PIRP                irp;
    PASYNC_IO_CTX       AsyncIoCtx;

    //
    // We deallocate the irp in SerialIoAsyncCompletionRoutine
    //
    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_GET_CHARS,
        sizeof(SERIAL_CHARS));

    AsyncIoCtx = AsyncAllocateIoCtx(TRUE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->SerialChars;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoSyncCompletionRoutine,  // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    KeClearEvent(&AsyncIoCtx->Event);
    status = IoCallDriver(pInfo->DeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&AsyncIoCtx->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = AsyncIoCtx->IoStatus.Status;
    }

    DbgTracef(0,("IoctlGetChars returned with 0x%.8x\n", status));

    if (status != STATUS_SUCCESS) {
        IoFreeIrp(irp);
        AsyncFreeIoCtx(AsyncIoCtx);
        return;
    }

    AsyncIoCtx->SerialChars.EventChar = EventChar;
    AsyncIoCtx->Sync = FALSE;

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_SET_CHARS,
        sizeof(SERIAL_CHARS));

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoAsyncCompletionRoutine, // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(pInfo->DeviceObject, irp);

    DbgTracef(0,("IoctlSetChars returned with 0x%.8x\n", status));
}


VOID
SerialFlushReads(
    PASYNC_INFO         pInfo) {

    ULONG               serialPurge;
    NTSTATUS            status;
    PIRP                irp;
    PASYNC_IO_CTX   AsyncIoCtx;

    //
    // We deallocate the irp in SerialIoAsyncCompletionRoutine
    //
    irp=IoAllocateIrp(pInfo->DeviceObject->StackSize, (BOOLEAN)FALSE);

    if (irp == NULL) {
        return;
    }

    InitSerialIrp(
        irp,
        pInfo,
        IOCTL_SERIAL_PURGE,
        sizeof(ULONG));

    AsyncIoCtx = AsyncAllocateIoCtx(FALSE, pInfo);

    if (AsyncIoCtx == NULL) {
        IoFreeIrp(irp);
        return;
    }

    // kill read buffer
    AsyncIoCtx->SerialPurge=SERIAL_PURGE_RXCLEAR;

    irp->AssociatedIrp.SystemBuffer=&AsyncIoCtx->SerialPurge;

    IoSetCompletionRoutine(
            irp,                            // irp to use
            SerialIoAsyncCompletionRoutine, // routine to call when irp is done
            AsyncIoCtx,                     // context to pass routine
            TRUE,                           // call on success
            TRUE,                           // call on error
            TRUE);                          // call on cancel

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver(pInfo->DeviceObject, irp);
    DbgTracef(0,("IoctlPurge returned with 0x%.8x\n", status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\slipfram.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    slipframe.c

Abstract:

Author:

    Thomas J. Dimitri  (TommyD)

Environment:

Revision History:

    Ray Patch (raypa)       04/13/94        Modified for new WAN wrapper.

--*/

#include "asyncall.h"


VOID
AssembleSLIPFrame(
    PNDIS_WAN_PACKET pFrame)

{
	PUCHAR		pOldFrame;
	PUCHAR		pNewFrame;
	UINT		dataSize;
        UCHAR           c;

	//
	// Initialize locals
	//

    pOldFrame=pFrame->CurrentBuffer;

    pNewFrame  =pFrame->StartBuffer;

	//
	// for quicker access, get a copy of data length field
	//
	dataSize=pFrame->CurrentLength;

    //
    // Now we run through the entire frame and pad it FORWARDS...
    //
    // <------------- new frame -----------> (could be twice as large)
    // +-----------------------------------+
    // |                                 |x|
    // +-----------------------------------+
    //									  ^
    // <---- old frame -->	   	    	  |
    // +-----------------+				  |
    // |			   |x|                |
    // +-----------------+				  |
    //					|				  |
    //                  \-----------------/
    //
    //
    //
    //         192 is encoded as 219, 220
    //         219 is encoded as 219, 221
    //

	*pNewFrame++ = SLIP_END_BYTE; // 192 - mark beginning of frame

    //
    // loop to remove all 192 and 219 chars
    //

    while ( dataSize-- ) {

		c = *pOldFrame++;

		//
		// Check if we have to escape out this byte or not
		//

		switch (c) {

	    case SLIP_END_BYTE:

			*pNewFrame++ = SLIP_ESC_BYTE;
			*pNewFrame++ = SLIP_ESC_END_BYTE;
			break;

	    case SLIP_ESC_BYTE:
			*pNewFrame++ = SLIP_ESC_BYTE;
			*pNewFrame++ = SLIP_ESC_ESC_BYTE;
			break;

	    default:
			*pNewFrame++ = c;

		}
    }

    //
    //  Mark end of frame
    //
    *pNewFrame++ = SLIP_END_BYTE;

	//
	// Calc how many bytes we expanded to including CRC
	//
	pFrame->CurrentLength = (ULONG)(pNewFrame - pFrame->StartBuffer);

	//
	// Put in the adjusted length -- actual num of bytes to send
	//
	pFrame->CurrentBuffer = pFrame->StartBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\slipread.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    slipread.c

Abstract:


Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#if DBG

#define __FILE_SIG__    'pliS'

#endif

#include "asyncall.h"

NTSTATUS
AsyncWaitMaskCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);


NTSTATUS
AsyncPPPWaitMask(
    IN PASYNC_INFO Info);


NTSTATUS
AsyncSLIPCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)

/*++

    This is the IO Completion routine for ReadFrame.

--*/
{
    NTSTATUS        status;
    PASYNC_INFO     pInfo;
    ULONG           bytesReceived;

    PASYNC_FRAME    pFrame;
    PUCHAR          frameStart, frameEnd;
    PUCHAR          frameEnd2,frameStart2;
    LONG            bytesWanted;        // keep this a long ( < 0 is used)


    DeviceObject;       // prevent compiler warnings

    status = Irp->IoStatus.Status;
    bytesReceived=(ULONG)Irp->IoStatus.Information;

    IoFreeIrp(Irp);

    pInfo=Context;

    pFrame=pInfo->AsyncFrame;

    switch (status) {

    case STATUS_SUCCESS:


        //
        // Any bytes to process?  This can happen if
        // the WaitMask completes late and by the time
        // we process the read, another event character has come
        // in.
        //
        if (bytesReceived==0) {
            break;
        }

        //
        // Update num of bytes read total for this frame
        //
        pInfo->BytesRead = bytesReceived = pInfo->BytesRead + bytesReceived;

        //
        // Set frameEnd to last byte processed.  Initially,
        // we have processed nothing (i.e. processed up to
        // the start of the first byte).
        //
        frameStart=pFrame->Frame + PPP_PADDING;

PROCESS_FRAME:
        //
        // Now we have actuallyRead bytes unused
        // Also, we may have a complete frame.
        //
        while (*frameStart == SLIP_END_BYTE && --bytesReceived) {
            frameStart++;
        }

        //
        // If we reach here, there is no end FLAG
        //
        if (bytesReceived == 0) {
            break;
        }

        //
        // frameEnd is set to the first byte not yet processed.
        // If we are starting out, that is the first byte!
        //
        frameEnd=frameStart;

        //
        // Assume the start of the frame has the SLIP_END_BYTE
        // Look for the second SLIP_END_BYTE (end of frame)
        //
        while (*frameEnd != SLIP_END_BYTE && --bytesReceived) {
            frameEnd++;
        }

        //
        // if bytesReceived is 0, we got nothing
        //
        // NOTE: if BytesRead gets too high we trash the frame
        // because we could not find the FLAG_BYTE
        //
        if (bytesReceived==0) {
            break;
        }
        
        if (*(pFrame->Frame+PPP_PADDING) != SLIP_END_BYTE) {
            //
            // We had garbage at the start.  Remove the garbage.
            //

            pInfo->SerialStats.AlignmentErrors++;

            //
            //  Tell the transport above us that we dropped a packet
            //  Hopefully, it will quickly resync.
            //
            AsyncIndicateFragment(
                pInfo,
                WAN_ERROR_ALIGNMENT);

            goto NEXT_SLIP_FRAME;
        }

        //
        // Length of frame is frameEnd - frameStart
        //
        bytesWanted = (LONG)(frameEnd - frameStart);

        frameEnd2 = frameStart2 = frameStart;

        //
        // Replace back all control chars, ESC, and FLAG chars
        //
        while (bytesWanted-- > 0) {
            if ((*frameEnd2=*frameStart2++) == SLIP_ESC_BYTE) {

                //
                // We have not run the CRC check yet!!
                // We have be careful about sending bytesWanted
                // back to -1 on corrupted data
                //

                bytesWanted--;

                *frameEnd2 = SLIP_END_BYTE;

                if (*frameStart2++ == SLIP_ESC_ESC_BYTE) {
                    *frameEnd2 = SLIP_ESC_BYTE;
                }
            }

            frameEnd2++;
        }

        //
        // Change the bytesWanted field to what it normally is,
        // the length of the frame.
        //
        bytesWanted = (LONG)(frameEnd2 - frameStart);

        // Keep those stats up to date
        {
            KIRQL       irql;
            NTSTATUS    Status;
            PASYNC_ADAPTER  Adapter = pInfo->Adapter;

            KeRaiseIrql( (KIRQL)DISPATCH_LEVEL, &irql );

            //
            // Compressed TCP/IP packets must at least 3 bytes long
            //
            if (bytesWanted >= 3) {
        
                NdisMWanIndicateReceive(
                    &Status,
                    Adapter->MiniportHandle,
                    pInfo->NdisLinkContext,
                    frameStart,
                    bytesWanted);
    
                NdisMWanIndicateReceiveComplete(
                    Adapter->MiniportHandle,
                    pInfo->NdisLinkContext);

            } else {

                pInfo->SerialStats.AlignmentErrors++;

                //
                //  Tell the transport above us that we dropped a packet
                //  Hopefully, it will quickly resync.
                //
                AsyncIndicateFragment(
                    pInfo,
                    WAN_ERROR_ALIGNMENT);

                DbgTracef(-2,("SLIP: Frame too small %u\n", bytesWanted));
            }


            KeLowerIrql( irql );
        }

    NEXT_SLIP_FRAME:

        //
        // if bytesReceived == 0 no frame was found
        // thus we must keep the current frame and continue
        // processing
        //
        if (bytesReceived) {

            //
            // Calculate how much of what we received
            // just got passed up as a frame and move the
            // rest to the beginning.
            //
            frameStart=pFrame->Frame + PPP_PADDING;
            frameEnd2=frameStart + pInfo->BytesRead;
            pInfo->BytesRead =
                            bytesReceived = (LONG)(frameEnd2-frameEnd);

            ASYNC_MOVE_MEMORY(
                frameStart,         // dest
                frameEnd,           // src
                bytesReceived);     // length

            //
            // Need at least four bytes for a frame to exist
            //
            if (bytesReceived > 3) {
                goto PROCESS_FRAME;
            }
        }

        break;

    case STATUS_CANCELLED:
        // else this is an anomally!
        DbgTracef(-2,("---ASYNC: Status cancelled on read for unknown reason!!\n"));
        break;

    case STATUS_PENDING:
        DbgTracef(0,("---ASYNC: Status PENDING on read\n"));
        break;

    default:
        DbgTracef(-2,("---ASYNC: Unknown status 0x%.8x on read",status));
        break;

    }

    if(status == STATUS_SUCCESS)
    {
        AsyncPPPWaitMask(pInfo);
    }
    else if(pInfo->PortState == PORT_CLOSING ||
            pInfo->PortState == PORT_CLOSED)
    {
        KeSetEvent(&pInfo->ClosingEvent,
                   1, 
                   (BOOLEAN) FALSE);
    }


    //
    // Here we are at the end of processing this IRP so we go
    // ahead and post another read from the serial port.
    //
    pInfo->Flags &= ~(ASYNC_FLAG_SLIP_READ);
    DEREF_ASYNCINFO(pInfo, Irp);

    // We return STATUS_MORE_PROCESSING_REQUIRED so that the
    // IoCompletionRoutine will stop working on the IRP.
    return(STATUS_MORE_PROCESSING_REQUIRED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndistapi\private.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    private.h

Abstract:

    Private definitions for NdisTapi.sys

Author:

    Dan Knudson (DanKn)    20-Feb-1994

Revision History:

--*/


//
// Various definitions
//

typedef enum _PROVIDER_STATUS
{
    PROVIDER_STATUS_ONLINE,
    PROVIDER_STATUS_OFFLINE,
    PROVIDER_STATUS_PENDING_INIT,
    PROVIDER_STATUS_PENDING_REINIT,
    PROVIDER_STATUS_PENDING_LINE_CREATE
} PROVIDER_STATUS, *PPROVIDER_STATUS;


typedef NDIS_STATUS (*REQUEST_PROC)(NDIS_HANDLE, PNDIS_REQUEST);

typedef struct _DEVICE_INFO {
    ULONG       DeviceID;

    HTAPI_LINE  htLine;

    HDRV_LINE   hdLine;

} DEVICE_INFO, *PDEVICE_INFO;


typedef struct _PROVIDER_INFO
{
    struct _PROVIDER_INFO  *Next;

    PROVIDER_STATUS Status;

    NDIS_HANDLE     ProviderHandle;

    REQUEST_PROC    RequestProc;

    ULONG           ProviderID;

    ULONG           NumDevices;

    ULONG           DeviceIDBase;

    GUID            Guid;

    NDIS_WAN_MEDIUM_SUBTYPE MediaType;

    ULONG_PTR       TempID;

    ULONG           CreateCount;

    KEVENT          SyncEvent;

    PDEVICE_INFO    DeviceInfo;

} PROVIDER_INFO, *PPROVIDER_INFO;


typedef enum _NDISTAPI_STATUS
{
    NDISTAPI_STATUS_CONNECTED,
    NDISTAPI_STATUS_DISCONNECTED,
    NDISTAPI_STATUS_CONNECTING,
    NDISTAPI_STATUS_DISCONNECTING

} NDISTAPI_STATUS, *PNDISTAPI_STATUS;


typedef struct _KMDD_DEVICE_EXTENSION
{
    //
    // Pointer to a list of registered providers. (Some may actually
    // not be currently registered, but they were at one point so we've
    // saved a placeholder for them should they come back online at some
    // point.)
    //

    PPROVIDER_INFO  Providers;

    //
    // Whether TAPI has the the connection wrapper open
    //
    NDISTAPI_STATUS Status;

    ULONG           RefCount;
    //
    // Pointer to the NdisTapi device object
    //
    PDEVICE_OBJECT  DeviceObject;

    //
    // BaseID
    //
    ULONG   ProviderBaseID;

    //
    // The number of line devices we told told TAPI we supported when
    // it opened us (some of which may not actually be online at any
    // given time)
    //

    ULONG           NdisTapiNumDevices;

    //
    // Whether we have an outstanding provider init request
    //
    ULONG           Flags;
#define PENDING_LINECREATE      0x00000001
#define CLEANUP_INITIATED       0x00000002
#define EVENTIRP_CANCELED       0x00000004
#define REQUESTIRP_CANCELED     0x00000008
#define DUPLICATE_EVENTIRP      0x00000010
#define CANCELIRP_NOTFOUND      0x00000020

    //
    // Count of irps canceled through the cancel routine or
    // cleanup routine
    //
    ULONG           IrpsCanceledCount;

    //
    // Count of irps missing when a request is completed by
    // the underlying miniport
    //
    ULONG           MissingRequests;

    //
    // Used to key irp request queue
    //
    ULONG           ulRequestID;

    //
    // Value return to provider for next NEWCALL msg
    //

    ULONG           htCall;

    //
    // Outstanding get-events request
    //

    PIRP            EventsRequestIrp;

    //
    // List of events waiting for service by user-mode
    //
    LIST_ENTRY      ProviderEventList;
    ULONG           EventCount;         // Number of events in queue

    //
    // List of requests sent to the providers
    //
    LIST_ENTRY      ProviderRequestList;
    ULONG           RequestCount;       // Number of requests in queue

    PFILE_OBJECT    NCPAFileObject;

    //
    // Synchronizes access to the device extension following fields
    //
    KSPIN_LOCK      SpinLock;

} KMDD_DEVICE_EXTENSION, *PKMDD_DEVICE_EXTENSION;


typedef struct _PROVIDER_EVENT {
    //
    // List linkage
    //
    LIST_ENTRY  Linkage;

    //
    // Event
    //
    NDIS_TAPI_EVENT Event;

}PROVIDER_EVENT, *PPROVIDER_EVENT;

typedef struct _PROVIDER_REQUEST
{
    LIST_ENTRY      Linkage;        // Link into providerrequest list
                                    // ASSUMED to be first member!!!!
    PIRP            Irp;            // Original IRP
    PPROVIDER_INFO  Provider;       // Provider this is destined for
    ULONG           RequestID;      // unique identifier for request
    ULONG           Flags;          //
#define INTERNAL_REQUEST    0x00000001
    PVOID           Alignment1;
    NDIS_REQUEST    NdisRequest;    // NDIS_REQUEST storage
    PVOID           Alignment2;
    ULONG           Data[1];        // This field is a placeholder for an 
                                    // NDIS_TAPI_XXX structure, the first 
                                    // ULONG of which is always a request ID.
} PROVIDER_REQUEST, *PPROVIDER_REQUEST;


//
// Our global device extension
//

PKMDD_DEVICE_EXTENSION DeviceExtension;



#if DBG

//
// A var which determines the verboseness of the msgs printed by DBGOUT()
//
//

LONG NdisTapiDebugLevel = 0;

//
// DbgPrint wrapper
//

#define DBGOUT(arg) DbgPrt arg

#else

#define DBGOUT(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\asyncmac\write.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    _write.c

Abstract:

    This is the main file for the AsyncMAC Driver for the Remote Access
    Service.  This driver conforms to the NDIS 3.0 interface.

Author:

    Thomas J. Dimitri  (TommyD) 08-May-1992

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    Ray Patch (raypa)       04/13/94        Modified for new WAN wrapper.

--*/

#define RAISEIRQL

#include "asyncall.h"

#if DBG
ULONG UlFramesOut = 0;
#define __FILE_SIG__    'tirW'
#endif

//  asyncmac.c will define the global parameters.

ULONG   GlobalXmitCameBack  = 0;
ULONG   GlobalXmitCameBack2 = 0;
ULONG   GlobalXmitCameBack3 = 0;

//
//  The assemble frame routine is specific for RAS 1.0 and 2.0
//  frame formats.  It uses a 16 byte CRC at the end.
//

VOID
AsyncFrameRASXonXoff(
    PUCHAR pStartOfFrame,
    postamble *pPostamble,
    PASYNC_FRAME pFrame,
    UCHAR controlCastByte);

VOID
AsyncFrameRASNormal(
    PUCHAR pStartOfFrame,
    postamble *pPostamble,
    PASYNC_FRAME pFrame,
    UCHAR controlCastByte);


NTSTATUS
AsyncWriteCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,           //... Our device object.
    IN PIRP             Irp,                    //... I/O request packet.
    IN PNDIS_WAN_PACKET WanPacket               //... Completion context.
    )

/*++

    This is the IO Completion routine for WriteFrame.

    It is called when an I/O Write request has completed.

--*/
{
    NTSTATUS            Status;
    NTSTATUS            PacketStatus;
    PASYNC_INFO         AsyncInfo;

    //
    //  Make the compiler happy.
    //

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    //  Initialize locals.
    //

    AsyncInfo       = WanPacket->MacReserved1;

    PacketStatus    = NDIS_STATUS_FAILURE;

    Status          = Irp->IoStatus.Status;

    //
    // Free the irp used to send the packt to the serial driver
    //
    IoFreeIrp(Irp);

    //
    //  What was the outcome of the IRP.
    //

    switch ( Status ) {

    case STATUS_SUCCESS:
        PacketStatus = NDIS_STATUS_SUCCESS;
        break;

    case STATUS_TIMEOUT:
        DbgTracef(-2,("ASYNC: Status TIMEOUT on write\n"));
        break;

    case STATUS_CANCELLED:
        DbgTracef(-2,("ASYNC: Status CANCELLED on write\n"));
        break;

    case STATUS_PENDING:
        DbgTracef(0,("ASYNC: Status PENDING on write\n"));
        break;

    default:
        DbgTracef(-2,("ASYNC: Unknown status 0x%.8x on write", Status));
        break;

    }

    //
    //  Count this packet completion.
    //
    AsyncInfo->Out++;

    //
    // Tell the Wrapper that we have finally the packet has been sent
    //

    NdisMWanSendComplete(
            AsyncInfo->Adapter->MiniportHandle,
            WanPacket,
            PacketStatus);

    //
    //  We return STATUS_MORE_PROCESSING_REQUIRED so that the
    //  IoCompletionRoutine will stop working on the IRP.
    //
    AsyncInfo->Flags &= ~(ASYNC_FLAG_SEND_PACKET);
    DEREF_ASYNCINFO(AsyncInfo, Irp);
    
    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
AsyncGetFrameFromPool(
    IN  PASYNC_INFO     Info,
    OUT PASYNC_FRAME    *NewFrame )

/*++

--*/
{
    PASYNC_ADAPTER      Adapter=Info->Adapter;
    PASYNC_FRAME        pFrame;

    pFrame = (ASYNC_FRAME*)
        ExAllocateFromNPagedLookasideList(&Adapter->AsyncFrameList);

    if (pFrame == NULL) {
        *NewFrame = NULL;
        return NDIS_STATUS_RESOURCES;
    }

    //
    // increase by 16 for frame runover padding when we have to resync
    //
    pFrame->Frame =
        (PUCHAR)pFrame + sizeof(ASYNC_FRAME) + sizeof(PVOID);
    (ULONG_PTR)pFrame->Frame &= ~((ULONG_PTR)(sizeof(PVOID)-1));

    pFrame->FrameLength = Adapter->MaxFrameSize;

    //  assign back ptr from frame to adapter

    pFrame->Adapter=Adapter;

    //  setup another back ptr

    pFrame->Info=Info;

    *NewFrame = pFrame;

    return(NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\ccp.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ccp.c

Abstract:


Author:

    Thomas J. Dimitri (TommyD) 29-March-1994

Environment:

Revision History:


--*/


#include "wan.h"

        
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, WanInitECP)
#pragma alloc_text(INIT, WanInitVJ)
#endif

#define __FILE_SIG__    CCP_FILESIG

NDIS_STATUS
AllocateEncryptMemory(
    PCRYPTO_INFO    CryptoInfo
    );

NDIS_STATUS
AllocateCompressMemory(
    PBUNDLECB   BundleCB
    );

NTSTATUS
AllocateCryptoMSChapV1(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    );

NTSTATUS
AllocateCryptoMSChapV2(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    );

#ifdef EAP_ON
NTSTATUS
AllocateCryptoEap(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    );
#endif

NPAGED_LOOKASIDE_LIST   EncryptCtxList; // List of free encryption contexts
NPAGED_LOOKASIDE_LIST   CachedKeyList;  // List of free encryption contexts
#ifdef ENCRYPT_128BIT
NPAGED_LOOKASIDE_LIST   CachedKeyListLong;  // List of free encryption contexts
#endif

VOID
WanInitECP(
    VOID
)
{

    NdisInitializeNPagedLookasideList(&EncryptCtxList,
                                      NULL,
                                      NULL,
                                      0,
                                      ENCRYPTCTX_SIZE,
                                      ENCRYPTCTX_TAG,
                                      0);

    NdisInitializeNPagedLookasideList(&CachedKeyList,
                                      NULL,
                                      NULL,
                                      0,
                                      glCachedKeyCount * (sizeof(USHORT) + MAX_SESSIONKEY_SIZE),
                                      CACHEDKEY_TAG,
                                      0);

#ifdef ENCRYPT_128BIT
    NdisInitializeNPagedLookasideList(&CachedKeyListLong,
                                      NULL,
                                      NULL,
                                      0,
                                      glCachedKeyCount * (sizeof(USHORT) + MAX_USERSESSIONKEY_SIZE),
                                      CACHEDKEY_TAG,
                                      0);
#endif
}

VOID
WanDeleteECP(
    VOID
    )
{
    NdisDeleteNPagedLookasideList(&EncryptCtxList);
    NdisDeleteNPagedLookasideList(&CachedKeyList);
#ifdef ENCRYPT_128BIT
    NdisDeleteNPagedLookasideList(&CachedKeyListLong);
#endif
}


//
// Assumes the endpoint lock is held
//
NTSTATUS
WanAllocateECP(
    PBUNDLECB           BundleCB,
    PCOMPRESS_INFO      CompInfo,
    PCRYPTO_INFO        CryptoInfo,
    BOOLEAN             IsSend
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanAllocateECP: Enter"));

    //
    // Is encryption enabled?
    //

#ifdef ENCRYPT_128BIT
    if ((CompInfo->MSCompType &
        (NDISWAN_ENCRYPTION | NDISWAN_40_ENCRYPTION | 
         NDISWAN_56_ENCRYPTION | NDISWAN_128_ENCRYPTION))) {
#else
    if ((CompInfo->MSCompType &
        (NDISWAN_ENCRYPTION | NDISWAN_40_ENCRYPTION |
         NDISWAN_56_ENCRYPTION))) {
#endif
        if (CryptoInfo->Context == NULL) {

            Status = AllocateEncryptMemory(CryptoInfo);

            if (Status != NDIS_STATUS_SUCCESS) {
                NdisWanDbgOut(DBG_FAILURE, DBG_CCP, ("Can't allocate encryption key!"));
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
        
        do
        {
            CryptoInfo->Flags |=
                (CompInfo->Flags & CCP_IS_SERVER) ? CRYPTO_IS_SERVER : 0;
    
            if (CompInfo->AuthType == AUTH_USE_MSCHAPV1) {
                Status = AllocateCryptoMSChapV1(BundleCB,
                                                CompInfo,
                                                CryptoInfo,
                                                IsSend);
    
            } else if (CompInfo->AuthType == AUTH_USE_MSCHAPV2) {
                Status = AllocateCryptoMSChapV2(BundleCB,
                                                CompInfo,
                                                CryptoInfo,
                                                IsSend);
#ifdef EAP_ON
            } else if (CompInfo->AuthType == AUTH_USE_EAP) {
                Status = AllocateCryptoEap(BundleCB,
                                           CompInfo,
                                           CryptoInfo,
                                           IsSend);
#endif
            } else {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            if (!IsSend && CryptoInfo->CachedKeyBuffer == NULL) {

#ifdef DBG_ECP
    DbgPrint("NDISWAN: CompInfo = %p\n", CompInfo);
    DbgPrint("NDISWAN: CryptoInfo = %p\n", CryptoInfo);
    DbgPrint("NDISWAN: MSCompType = %0x\n", CompInfo->MSCompType);
    DbgPrint("NDISWAN: Flags = %0x\n", CryptoInfo->Flags);
    DbgPrint("NDISWAN: SessionKeyLength = %d\n", CryptoInfo->SessionKeyLength);
#endif

#ifdef ENCRYPT_128BIT
                if ((CompInfo->MSCompType & NDISWAN_128_ENCRYPTION)) 
                {
                    CryptoInfo->CachedKeyBuffer = NdisAllocateFromNPagedLookasideList(&CachedKeyListLong);
                }
                else
#endif
                {
                    CryptoInfo->CachedKeyBuffer = NdisAllocateFromNPagedLookasideList(&CachedKeyList);
                }

                if (CryptoInfo->CachedKeyBuffer == NULL) {
                    NdisWanDbgOut(DBG_FAILURE, DBG_CCP, ("Can't allocate cached key array!"));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
                else
                {
                    CryptoInfo->pCurrKey = (PCACHED_KEY)CryptoInfo->CachedKeyBuffer;
                    CryptoInfo->pLastKey = (PCACHED_KEY)((PUCHAR) CryptoInfo->CachedKeyBuffer + 
                        (glCachedKeyCount - 1) * (sizeof(USHORT)+ CryptoInfo->SessionKeyLength));
                    NdisFillMemory(CryptoInfo->CachedKeyBuffer, 
                        glCachedKeyCount * (sizeof(USHORT)+ CryptoInfo->SessionKeyLength), 
                        0xff);
                }
            }
        } while(FALSE);

        if (Status != STATUS_SUCCESS) {

            if (CryptoInfo->Context != NULL) {
                NdisFreeToNPagedLookasideList(&EncryptCtxList,
                                              CryptoInfo->Context);
                //
                // Clear so we know it is deallocated
                //
                CryptoInfo->Context =
                CryptoInfo->RC4Key= NULL;
            }

            if (CryptoInfo->CachedKeyBuffer != NULL) {
#ifdef ENCRYPT_128BIT
                if ((CompInfo->MSCompType & NDISWAN_128_ENCRYPTION)) 
                {
                    NdisFreeToNPagedLookasideList(&CachedKeyListLong, CryptoInfo->CachedKeyBuffer);
                }
                else
#endif
                {
                    NdisFreeToNPagedLookasideList(&CachedKeyList, CryptoInfo->CachedKeyBuffer);
                }
                CryptoInfo->CachedKeyBuffer = NULL;
                CryptoInfo->pCurrKey = CryptoInfo->pLastKey = NULL;
            }


            NdisWanDbgOut(DBG_FAILURE, DBG_CCP, ("Failed allocating Crypto Status %x!", Status));
            return (Status);
        }

        //
        // Next packet out is flushed
        //
        BundleCB->Flags |= RECV_PACKET_FLUSH;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanAllocateECP: Exit"));

    return(Status);
}

//
// Assumes the endpoint lock is held
//
VOID
WanDeallocateECP(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanDeallocateECP: Enter"));

    //
    // Deallocate encryption keys.
    //
    if (CryptoInfo->Context != NULL) {
        NdisFreeToNPagedLookasideList(&EncryptCtxList,
                                      CryptoInfo->Context);

        //
        // Clear so we know it is deallocated
        //
        CryptoInfo->Context =
        CryptoInfo->RC4Key= NULL;
    }

    if (CryptoInfo->CachedKeyBuffer != NULL) {
#ifdef ENCRYPT_128BIT
        if ((CompInfo->MSCompType & NDISWAN_128_ENCRYPTION)) 
        {
            NdisFreeToNPagedLookasideList(&CachedKeyListLong, CryptoInfo->CachedKeyBuffer);
        }
        else
#endif
        {
            NdisFreeToNPagedLookasideList(&CachedKeyList, CryptoInfo->CachedKeyBuffer);
        }
        CryptoInfo->CachedKeyBuffer = NULL;
        CryptoInfo->pCurrKey = CryptoInfo->pLastKey = NULL;
    }

    //
    // Clear the encrption bits
    //
#ifdef ENCRYPT_128BIT
    CompInfo->MSCompType &= ~(NDISWAN_ENCRYPTION | NDISWAN_40_ENCRYPTION | 
                              NDISWAN_56_ENCRYPTION | NDISWAN_128_ENCRYPTION);
#else
    CompInfo->MSCompType &= ~(NDISWAN_ENCRYPTION | NDISWAN_40_ENCRYPTION |
                              NDISWAN_56_ENCRYPTION);
#endif

    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanDeallocateCCP: Exit"));
}

NTSTATUS
AllocateCryptoMSChapV1(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    )
{
    if (CompInfo->MSCompType & NDISWAN_ENCRYPTION) {
        //
        // For legacy encryption we use the 8 byte LMSessionKey
        // for initiali encryption session key.  The first 256
        // packets will be sent using this without any salt
        // (the first 256 packets are using 64 bit encryption).
        // After the first 256 we will always salt the first 3
        // bytes of the encryption key so that we are doing 40
        // bit encryption.
        //
        CryptoInfo->SessionKeyLength = MAX_SESSIONKEY_SIZE;

        NdisMoveMemory(CryptoInfo->StartKey,
                       CompInfo->LMSessionKey,
                       CryptoInfo->SessionKeyLength);

        NdisMoveMemory(CryptoInfo->SessionKey,
                       CryptoInfo->StartKey,
                       CryptoInfo->SessionKeyLength);

    } else if (CompInfo->MSCompType & 
               (NDISWAN_40_ENCRYPTION | NDISWAN_56_ENCRYPTION)) {

        CryptoInfo->SessionKeyLength = MAX_SESSIONKEY_SIZE;

        //
        // For our new 40/56 bit encryption we will use SHA on the
        // 8 byte LMSessionKey to derive our intial 8 byte
        // encryption session key.
        //

        NdisMoveMemory(CryptoInfo->StartKey,
                       CompInfo->LMSessionKey,
                       CryptoInfo->SessionKeyLength);

        NdisMoveMemory(CryptoInfo->SessionKey,
                       CompInfo->LMSessionKey,
                       CryptoInfo->SessionKeyLength);

        GetNewKeyFromSHA(CryptoInfo);

        if (CompInfo->MSCompType & NDISWAN_40_ENCRYPTION) {
            //
            // Set the first 3 bytes to reduce to
            // 40 bits of random key
            //
            CryptoInfo->SessionKey[0] = 0xD1;
            CryptoInfo->SessionKey[1] = 0x26;
            CryptoInfo->SessionKey[2] = 0x9E;

        } else {

            //
            // Set the first byte to reduce to
            // 56 bits of random key
            //
            CryptoInfo->SessionKey[0] = 0xD1;
        }

#ifdef ENCRYPT_128BIT
    } else if (CompInfo->MSCompType & NDISWAN_128_ENCRYPTION) {

        CryptoInfo->SessionKeyLength = MAX_USERSESSIONKEY_SIZE;

        //
        // For our new 128 bit encryption we will use SHA on the
        // 16 byte NTUserSessionKey and the 8 byte Challenge to
        // derive our the intial 128 bit encryption session key.
        //
        NdisMoveMemory(CryptoInfo->StartKey,
                       CompInfo->UserSessionKey,
                       MAX_USERSESSIONKEY_SIZE);

        GetStartKeyFromSHA(CryptoInfo, CompInfo->Challenge);

        GetNewKeyFromSHA(CryptoInfo);
#endif
    }

    //
    // Initialize the rc4 send table
    //
    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
    ("RC4 encryption KeyLength %d", CryptoInfo->SessionKeyLength));
    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
    ("RC4 encryption Key %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x",
        CryptoInfo->SessionKey[0],
        CryptoInfo->SessionKey[1],
        CryptoInfo->SessionKey[2],
        CryptoInfo->SessionKey[3],
        CryptoInfo->SessionKey[4],
        CryptoInfo->SessionKey[5],
        CryptoInfo->SessionKey[6],
        CryptoInfo->SessionKey[7],
        CryptoInfo->SessionKey[8],
        CryptoInfo->SessionKey[9],
        CryptoInfo->SessionKey[10],
        CryptoInfo->SessionKey[11],
        CryptoInfo->SessionKey[12],
        CryptoInfo->SessionKey[13],
        CryptoInfo->SessionKey[14],
        CryptoInfo->SessionKey[15]));

    rc4_key(CryptoInfo->RC4Key,
            CryptoInfo->SessionKeyLength,
            CryptoInfo->SessionKey);

    return (STATUS_SUCCESS);
}

NTSTATUS
AllocateCryptoMSChapV2(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    )
{

    NdisMoveMemory(CryptoInfo->StartKey,
                   CompInfo->UserSessionKey,
                   sizeof(CryptoInfo->StartKey));

    if (CompInfo->MSCompType & NDISWAN_ENCRYPTION) {

        return(STATUS_UNSUCCESSFUL);

    } else if (CompInfo->MSCompType & 
               (NDISWAN_40_ENCRYPTION | NDISWAN_56_ENCRYPTION)) {

        CryptoInfo->SessionKeyLength = MAX_SESSIONKEY_SIZE;

#ifdef ENCRYPT_128BIT
    } else if (CompInfo->MSCompType & NDISWAN_128_ENCRYPTION) {

        CryptoInfo->SessionKeyLength = MAX_USERSESSIONKEY_SIZE;

#endif
    }

    GetMasterKey(CryptoInfo, CompInfo->NTResponse);

    //
    // Setup the first key
    //
    GetAsymetricStartKey(CryptoInfo, IsSend);

    GetNewKeyFromSHA(CryptoInfo);

    if (CompInfo->MSCompType & NDISWAN_40_ENCRYPTION) {
        //
        // Set the first 3 bytes to reduce to
        // 40 bits of random key
        //
        CryptoInfo->SessionKey[0] = 0xD1;
        CryptoInfo->SessionKey[1] = 0x26;
        CryptoInfo->SessionKey[2] = 0x9E;

    } else if (CompInfo->MSCompType & NDISWAN_56_ENCRYPTION) {

        //
        // Set the first byte to reduce to
        // 56 bits of random key
        //
        CryptoInfo->SessionKey[0] = 0xD1;
    }

    //
    // Initialize the rc4 send table
    //
    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
        ("RC4 encryption KeyLength %d", CryptoInfo->SessionKeyLength));

    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
        ("RC4 encryption Key %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x",
        CryptoInfo->SessionKey[0],CryptoInfo->SessionKey[1],
        CryptoInfo->SessionKey[2],CryptoInfo->SessionKey[3],
        CryptoInfo->SessionKey[4],CryptoInfo->SessionKey[5],
        CryptoInfo->SessionKey[6],CryptoInfo->SessionKey[7],
        CryptoInfo->SessionKey[8],CryptoInfo->SessionKey[9],
        CryptoInfo->SessionKey[10],CryptoInfo->SessionKey[11],
        CryptoInfo->SessionKey[12],CryptoInfo->SessionKey[13],
        CryptoInfo->SessionKey[14],CryptoInfo->SessionKey[15]));

    rc4_key(CryptoInfo->RC4Key,
            CryptoInfo->SessionKeyLength,
            CryptoInfo->SessionKey);

    return (STATUS_SUCCESS);
}

#ifdef EAP_ON
NTSTATUS
AllocateCryptoEap(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    )
{

    ULONG   KeySize;

    KeySize = CompInfo->EapKeyLength;

    if (CompInfo->MSCompType & NDISWAN_ENCRYPTION) {

        return(STATUS_UNSUCCESSFUL);

    } else if (CompInfo->MSCompType & 
               (NDISWAN_40_ENCRYPTION | NDISWAN_56_ENCRYPTION)) {

        //
        // Might need to pad this out.  Spec calls for padding
        // at the left (front) of the value
        //

        CryptoInfo->SessionKeyLength = MAX_SESSIONKEY_SIZE;

#ifdef ENCRYPT_128BIT
    } else if (CompInfo->MSCompType & NDISWAN_128_ENCRYPTION) {

        //
        // Might need to pad this out.  Spec calls for padding
        // at the left (front) of the value
        //

        CryptoInfo->SessionKeyLength = MAX_USERSESSIONKEY_SIZE;

#endif
    }

    NdisMoveMemory(CryptoInfo->StartKey,
                   CompInfo->EapKey,
                   CryptoInfo->SessionKeyLength);

    NdisMoveMemory(CryptoInfo->SessionKey,
                   CryptoInfo->StartKey,
                   CryptoInfo->SessionKeyLength);

    GetNewKeyFromSHA(CryptoInfo);

    if (CompInfo->MSCompType & NDISWAN_40_ENCRYPTION) {
        //
        // Set the first 3 bytes to reduce to
        // 40 bits of random key
        //
        CryptoInfo->SessionKey[0] = 0xD1;
        CryptoInfo->SessionKey[1] = 0x26;
        CryptoInfo->SessionKey[2] = 0x9E;

    } else if (CompInfo->MSCompType & NDISWAN_56_ENCRYPTION) {

        //
        // Set the first byte to reduce to
        // 56 bits of random key
        //
        CryptoInfo->SessionKey[0] = 0xD1;
    }

    //
    // Initialize the rc4 send table
    //
    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
        ("RC4 encryption KeyLength %d", CryptoInfo->SessionKeyLength));

    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
        ("RC4 encryption Key %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x",
        CryptoInfo->SessionKey[0],CryptoInfo->SessionKey[1],
        CryptoInfo->SessionKey[2],CryptoInfo->SessionKey[3],
        CryptoInfo->SessionKey[4],CryptoInfo->SessionKey[5],
        CryptoInfo->SessionKey[6],CryptoInfo->SessionKey[7],
        CryptoInfo->SessionKey[8],CryptoInfo->SessionKey[9],
        CryptoInfo->SessionKey[10],CryptoInfo->SessionKey[11],
        CryptoInfo->SessionKey[12],CryptoInfo->SessionKey[13],
        CryptoInfo->SessionKey[14],CryptoInfo->SessionKey[15]));

    rc4_key(CryptoInfo->RC4Key,
            CryptoInfo->SessionKeyLength,
            CryptoInfo->SessionKey);

    return (STATUS_SUCCESS);
}
#endif

NTSTATUS
WanAllocateCCP(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    BOOLEAN         IsSend
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanAllocateCCP: Enter"));

    if (CompInfo->MSCompType & NDISWAN_COMPRESSION) {
        ULONG   CompressSend;
        ULONG   CompressRecv;

        //
        // Get compression context sizes
        //
        if(BundleCB->SendCompInfo.MSCompType & NDISWAN_HISTORY_LESS)
        {
            CompressSend = sizeof(SendContext);
        }
        else 
        {
            CompressSend = sizeof(SendContext) + HISTORY_SIZE;
        }
        
        if(BundleCB->RecvCompInfo.MSCompType & NDISWAN_HISTORY_LESS)
        {
            CompressRecv = sizeof(RecvContext) + glMRRU; 
        }
        else 
        {
            CompressRecv = sizeof(RecvContext) + HISTORY_SIZE; 
        }
        
        if (IsSend) {

            if (BundleCB->SendCompressContext == NULL) {
                NdisWanAllocateMemory(&BundleCB->SendCompressContext, CompressSend, COMPCTX_TAG);

                //
                // If we can't allocate memory the machine is toast.
                // Forget about freeing anything up.
                //
                if (BundleCB->SendCompressContext == NULL) {
                    NdisWanDbgOut(DBG_FAILURE, DBG_CCP, ("Can't allocate compression!"));
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }

            ((SendContext*)BundleCB->SendCompressContext)->BundleFlags =
                (BundleCB->SendCompInfo.MSCompType & NDISWAN_HISTORY_LESS) ? DO_HISTORY_LESS : 0;
            
            initsendcontext (BundleCB->SendCompressContext);
            
        } else {

            if (BundleCB->RecvCompressContext == NULL) {
                NdisWanAllocateMemory(&BundleCB->RecvCompressContext, CompressRecv, COMPCTX_TAG);

                //
                // If we can't allocate memory the machine is toast.
                // Forget about freeing anything up.
                //
                if (BundleCB->RecvCompressContext == NULL) {
                    NdisWanDbgOut(DBG_FAILURE, DBG_CCP, ("Can't allocate decompression"));
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }

            if(BundleCB->RecvCompInfo.MSCompType & NDISWAN_HISTORY_LESS)
            {
                ((RecvContext*)BundleCB->RecvCompressContext)->BundleFlags = DO_HISTORY_LESS;
                ((RecvContext*)BundleCB->RecvCompressContext)->HistorySize = glMRRU;
            }
            else
            {
                ((RecvContext*)BundleCB->RecvCompressContext)->BundleFlags = 0;
                ((RecvContext*)BundleCB->RecvCompressContext)->HistorySize = HISTORY_SIZE;
            }
                                                   
            //
            // Initialize the decompression history table
            //
            initrecvcontext (BundleCB->RecvCompressContext);
            
        }

        Status = STATUS_SUCCESS;

        //
        // Next packet out is flushed
        //
        BundleCB->Flags |= RECV_PACKET_FLUSH;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanAllocateCCP: Exit"));

    return (Status);
}

VOID
WanDeallocateCCP(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    BOOLEAN         IsSend
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanDeallocateCCP: Enter"));

    if (IsSend) {
        if (BundleCB->SendCompressContext != NULL) {

            NdisWanFreeMemory(BundleCB->SendCompressContext);

            BundleCB->SendCompressContext= NULL;
        }
    } else {

        if (BundleCB->RecvCompressContext != NULL) {
            NdisWanFreeMemory(BundleCB->RecvCompressContext);

            BundleCB->RecvCompressContext= NULL;
        }
    }

    //
    // Clear the compression bits
    //
    CompInfo->MSCompType &= ~NDISWAN_COMPRESSION;

    
    NdisWanDbgOut(DBG_TRACE, DBG_CCP, ("WanDeallocateCCP: Exit"));
}

NDIS_STATUS
AllocateEncryptMemory(
    PCRYPTO_INFO    CryptoInfo
    )
{
    PUCHAR  Mem;

    Mem =
        NdisAllocateFromNPagedLookasideList(&EncryptCtxList);

    if (Mem == NULL) {
        return (NDIS_STATUS_FAILURE);
    }

    NdisZeroMemory(Mem, ENCRYPTCTX_SIZE);

    CryptoInfo->Context = Mem;
    Mem += (sizeof(A_SHA_CTX) + sizeof(PVOID));

    CryptoInfo->RC4Key = Mem;
    (ULONG_PTR)CryptoInfo->RC4Key &= ~((ULONG_PTR)sizeof(PVOID)-1);

    return(NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndistapi\ndistapi.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ndistapi.c

Abstract:

    This module contains the NdisTapi.sys implementation

Author:

    Dan Knudson (DanKn)    20-Feb-1994

Notes:

    (Future/outstanding issues)

    - stuff marked with "PnP" needs to be rev'd for plug 'n play support

Revision History:

--*/



#include "ndis.h"
#include "stdarg.h"
#include "stdio.h"
#include "ntddndis.h"
#include "ndistapi.h"
#include "private.h"
#include "intrface.h"


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
NdisTapiCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NdisTapiCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NdisTapiDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NdisTapiUnload(
    IN PDRIVER_OBJECT DriverObject
    );


#if DBG
VOID
DbgPrt(
    IN LONG  DbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    );
#endif

VOID
DoProviderInitComplete(
    PPROVIDER_REQUEST  ProviderRequest,
    NDIS_STATUS Status
    );

ULONG
GetLineEvents(
    PVOID   EventBuffer,
    ULONG   BufferSize
    );

BOOLEAN
SyncInitAllProviders(
    void
    );

VOID
DoIrpMjCloseWork(
    PIRP    Irp
    );

NDIS_STATUS
SendProviderInitRequest(
    PPROVIDER_INFO  Provider
    );

NDIS_STATUS
SendProviderShutdown(
    PPROVIDER_INFO  Provider,
    PKIRQL          oldIrql
    );

VOID
NdisTapiIndicateStatus(
    IN  ULONG_PTR   DriverHandle,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

VOID
DoLineOpenCompleteWork(
    PNDISTAPI_REQUEST   ndisTapiRequest,
    PPROVIDER_INFO      provider
    );

VOID
DoLineOpenWork(
    PNDISTAPI_REQUEST   ndisTapiRequest,
    PPROVIDER_INFO      provider
    );

NDIS_STATUS
VerifyProvider(
    PNDISTAPI_REQUEST   ndisTapiRequest,
    PPROVIDER_INFO      *provider
    );

NDIS_STATUS
VerifyLineClose(
    PNDISTAPI_REQUEST ndisTapiRequest,
    PPROVIDER_INFO     provider
    );

NTSTATUS
DoIoctlConnectWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    );

NTSTATUS
DoIoctlQuerySetWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    );

NTSTATUS
DoGetProviderEventsWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    );

NTSTATUS
DoLineCreateWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    );

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif

NPAGED_LOOKASIDE_LIST  ProviderEventLookaside;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/

{

    PDEVICE_OBJECT  deviceObject        = NULL;
    NTSTATUS        ntStatus;
    WCHAR           deviceNameBuffer[]  = L"\\Device\\NdisTapi";
    UNICODE_STRING  deviceNameUnicodeString;
    UNICODE_STRING  registryPath;


    DBGOUT ((2, "DriverEntry: enter"));

    //
    // Create a NON-EXCLUSIVE device, i.e. multiple threads at a time
    // can send i/o requests.
    //

    RtlInitUnicodeString (&deviceNameUnicodeString, deviceNameBuffer);

    ntStatus = IoCreateDevice(
        DriverObject,
        sizeof (KMDD_DEVICE_EXTENSION),
        &deviceNameUnicodeString,
        FILE_DEVICE_NDISTAPI,
        0,
        FALSE,
        &deviceObject
        );


    if (NT_SUCCESS(ntStatus))
    {
        //
        // Init the global & sero the extension
        //

        DeviceExtension =
            (PKMDD_DEVICE_EXTENSION) deviceObject->DeviceExtension;

        RtlZeroMemory(
            DeviceExtension,
            sizeof (KMDD_DEVICE_EXTENSION)
            );


        //
        // Create a NULL-terminated registry path & retrieve the registry
        // params (EventDataQueueLength)
        //

        registryPath.Buffer = ExAllocatePoolWithTag(
            PagedPool,
            RegistryPath->Length + sizeof(UNICODE_NULL),
            'IPAT'
            );

        if (!registryPath.Buffer)
        {
            DBGOUT((1, "DriverEntry: ExAllocPool for szRegistryPath failed"));

            ntStatus = STATUS_UNSUCCESSFUL;

            goto DriverEntry_err;
        }
        else
        {
            registryPath.Length = RegistryPath->Length;
            registryPath.MaximumLength =
                registryPath.Length + sizeof(UNICODE_NULL);

            RtlZeroMemory(
                registryPath.Buffer,
                registryPath.MaximumLength
                    );

            RtlMoveMemory(
                registryPath.Buffer,
                RegistryPath->Buffer,
                RegistryPath->Length
                );
        }

        ExFreePool (registryPath.Buffer);


        InitializeListHead(&DeviceExtension->ProviderEventList);

        ExInitializeNPagedLookasideList(&ProviderEventLookaside,
                                        NULL,
                                        NULL,
                                        0,
                                        sizeof(PROVIDER_EVENT),
                                        'IPAT',
                                        0);


        DeviceExtension->DeviceObject       = deviceObject;
        DeviceExtension->Status             = NDISTAPI_STATUS_DISCONNECTED;
        DeviceExtension->NdisTapiNumDevices = 0;
        DeviceExtension->htCall             = 0x80000001;

        KeInitializeSpinLock (&DeviceExtension->SpinLock);

        InitializeListHead(&DeviceExtension->ProviderRequestList);

        //
        // Create dispatch points for device control, create, close.
        //

        DriverObject->MajorFunction[IRP_MJ_CREATE]         =
        DriverObject->MajorFunction[IRP_MJ_CLOSE]          =
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = NdisTapiDispatch;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = NdisTapiCleanup;
        DriverObject->DriverUnload                         = NdisTapiUnload;
    }


    if (!NT_SUCCESS(ntStatus)) {

DriverEntry_err:

        //
        // Something went wrong, so clean up
        //

        DBGOUT((0, "init failed"));

        if (deviceObject)
        {

        while (!(IsListEmpty(&DeviceExtension->ProviderEventList))) {
            PPROVIDER_EVENT ProviderEvent;

            ProviderEvent = (PPROVIDER_EVENT)
                RemoveHeadList(&DeviceExtension->ProviderEventList);

            ExFreeToNPagedLookasideList(&ProviderEventLookaside, ProviderEvent);
        }

            IoDeleteDevice (deviceObject);
        }
    }


    DBGOUT ((2, "DriverEntry: exit"));

    return ntStatus;
}



VOID
NdisTapiCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    KIRQL   oldIrql;

    DBGOUT((2,"NdisTapiCancel: enter"));


    //
    // Release the cancel spinlock
    //

    IoReleaseCancelSpinLock (Irp->CancelIrql);


    //
    // Acquire the SpinLock & check to see if we're canceling a
    // pending get-events Irp
    //

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    do {

        DeviceExtension->IrpsCanceledCount++;

        if (Irp == DeviceExtension->EventsRequestIrp) {
            DeviceExtension->EventsRequestIrp = NULL;
            DeviceExtension->Flags |= EVENTIRP_CANCELED;
            break;
        }

        //
        // Try to remove request from our special
        // user-mode requests dev queue
        //
        if (!IsListEmpty(&DeviceExtension->ProviderRequestList)) {
            PLIST_ENTRY Entry;

            Entry = DeviceExtension->ProviderRequestList.Flink;

            while (Entry != &DeviceExtension->ProviderRequestList) {
                PPROVIDER_REQUEST   pReq;

                pReq = (PPROVIDER_REQUEST)Entry;

                if (pReq->Irp == Irp) {
                    RemoveEntryList(&pReq->Linkage);
                    DeviceExtension->RequestCount--;
                    DeviceExtension->Flags |= REQUESTIRP_CANCELED;
                    break;
                }

                Entry = Entry->Flink;
            }

            if (Entry == &DeviceExtension->ProviderRequestList) {
                DBGOUT((1,"NdisTapiCancel: Irp %p not in device queue?!?", Irp));
                DeviceExtension->Flags |= CANCELIRP_NOTFOUND;
            }
        }

    } while (FALSE);

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    //
    // Complete the request with STATUS_CANCELLED.
    //

    Irp->IoStatus.Status      = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DBGOUT((2,"NdisTapiCancel: completing irp=%p", Irp));
}



NTSTATUS
NdisTapiCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for cleanup requests.
    All requests queued are completed with STATUS_CANCELLED.

Arguments:

    DeviceObject - Pointer to device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    KIRQL   oldIrql;
    PNDISTAPI_REQUEST   ndisTapiRequest;
    PKDEVICE_QUEUE_ENTRY    packet;


    DBGOUT((2,"NdisTapiCleanup: enter"));


    //
    // Sync access to EventsRequestIrp by acquiring SpinLock
    //
    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    DeviceExtension->Flags |= CLEANUP_INITIATED;

    //
    // Check to see if there's a get-events request pending that needs
    // completing
    //
    if ((DeviceExtension->EventsRequestIrp != NULL) &&
        (DeviceExtension->EventsRequestIrp->Tail.Overlay.OriginalFileObject ==
        Irp->Tail.Overlay.OriginalFileObject)) {
        PIRP    LocalIrp;

        //
        // Acquire the cancel spinlock, remove the request from the
        // cancellable state, and free the cancel spinlock.
        //

        LocalIrp = DeviceExtension->EventsRequestIrp;
        if (IoSetCancelRoutine (LocalIrp, NULL) != NULL) {
            DeviceExtension->EventsRequestIrp = NULL;
            LocalIrp->IoStatus.Status      = STATUS_CANCELLED;
            LocalIrp->IoStatus.Information = 0;
            DeviceExtension->IrpsCanceledCount++;
            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
            DBGOUT((2,"NdisTapiCleanup: Completing EventRequestIrp %p", LocalIrp));
            IoCompleteRequest (LocalIrp, IO_NO_INCREMENT);
            KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);
        }
    }

    //
    // Cancel all outstanding QUERY/SET_INFO requests
    //
    if (!IsListEmpty(&DeviceExtension->ProviderRequestList)) {
        PPROVIDER_REQUEST   pReq;

        pReq = (PPROVIDER_REQUEST)
            DeviceExtension->ProviderRequestList.Flink;

        //
        // Until we have walked the entire list
        //
        while ((PVOID)pReq != (PVOID)&DeviceExtension->ProviderRequestList) {
            PIRP    LocalIrp;

            LocalIrp = pReq->Irp;

            //
            // If the current entry's irp has a fileobject that is
            // the same as the cleanup irp's fileobject then remove it
            // from the list and cancel it
            //
            if (LocalIrp->Tail.Overlay.OriginalFileObject ==
                Irp->Tail.Overlay.OriginalFileObject) {

                //
                // Remove the IRP from the cancelable state
                //

                if (IoSetCancelRoutine (LocalIrp, NULL) == NULL) {
                    //
                    // The irp has been canceled.  Let
                    // cancel routine cleanup.
                    //
                    pReq = 
                        (PPROVIDER_REQUEST)pReq->Linkage.Flink;

                    continue;
                }

                RemoveEntryList(&pReq->Linkage);
                DeviceExtension->RequestCount--;

                //
                // Set the status & info size values appropriately, & complete
                // the request
                //

                ndisTapiRequest = LocalIrp->AssociatedIrp.SystemBuffer;
                ndisTapiRequest->ulReturnValue = (ULONG) NDIS_STATUS_FAILURE;

                LocalIrp->IoStatus.Status = STATUS_CANCELLED;
                LocalIrp->IoStatus.Information = 0;
                DeviceExtension->IrpsCanceledCount++;

                KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
                DBGOUT((2,"NdisTapiCleanup: Completing ProviderRequestIrp %p", LocalIrp));
                IoCompleteRequest (LocalIrp, IO_NO_INCREMENT);
                KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

                pReq = (PPROVIDER_REQUEST)
                    DeviceExtension->ProviderRequestList.Flink;

            } else {
                pReq = (PPROVIDER_REQUEST)
                    pReq->Linkage.Flink;
            }
        }
    }

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    //
    // Complete the cleanup request with STATUS_SUCCESS.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DBGOUT((2,"NdisTapiCleanup: exit"));

    return(STATUS_SUCCESS);
}




NTSTATUS
NdisTapiDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )

/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/

{
    NTSTATUS    NtStatus;
    PVOID               ioBuffer;
    ULONG               inputBufferLength;
    ULONG               outputBufferLength;
    PIO_STACK_LOCATION  irpStack;

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //
    ioBuffer = 
        Irp->AssociatedIrp.SystemBuffer;

    inputBufferLength = 
        irpStack->Parameters.DeviceIoControl.InputBufferLength;

    outputBufferLength = 
        irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    switch (irpStack->MajorFunction) {
        case IRP_MJ_CREATE:
            DBGOUT ((2, "IRP_MJ_CREATE, Irp=%p", Irp));

            InterlockedIncrement(&DeviceExtension->RefCount);
            NtStatus = Irp->IoStatus.Status 
                = STATUS_SUCCESS;
            Irp->IoStatus.Information = 0;
            break;

        case IRP_MJ_CLOSE:
            DBGOUT ((2, "IRP_MJ_CLOSE, Irp=%p", Irp));

            DoIrpMjCloseWork(Irp);
            NtStatus = STATUS_SUCCESS;
            break;

        case IRP_MJ_DEVICE_CONTROL:

            switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
                case IOCTL_NDISTAPI_CONNECT:
                    DBGOUT ((2, "IOCTL_NDISTAPI_CONNECT, Irp=%p", Irp));
    
                    NtStatus = 
                        DoIoctlConnectWork(Irp,
                                           ioBuffer,
                                           inputBufferLength,
                                           outputBufferLength);
                    break;
    
                case IOCTL_NDISTAPI_QUERY_INFO:
                case IOCTL_NDISTAPI_SET_INFO:
                    DBGOUT ((2, "IOCTL_NDISTAPI_QUERY/SET_INFO, Irp=%p", Irp));
    
                    NtStatus = 
                        DoIoctlQuerySetWork(Irp,
                                            ioBuffer,
                                            inputBufferLength,
                                            outputBufferLength);
                    break;
    
                case IOCTL_NDISTAPI_GET_LINE_EVENTS:
                    DBGOUT ((2, "IOCTL_NDISTAPI_GET_LINE_EVENTS, Irp=%p", Irp));

                    NtStatus = 
                        DoGetProviderEventsWork(Irp,
                                                ioBuffer,
                                                inputBufferLength,
                                                outputBufferLength);
                    break;
    
                case IOCTL_NDISTAPI_CREATE:
                    DBGOUT ((2, "IOCTL_NDISTAPI_CREATE, Irp=%p", Irp));

                    NtStatus = 
                        DoLineCreateWork(Irp,
                                         ioBuffer,
                                         inputBufferLength,
                                         outputBufferLength);
                    break;

                default:
                    DBGOUT ((2, "Unknown IRP_MJ_DEVICE_CONTROL, Irp=%p", Irp));

                    NtStatus = Irp->IoStatus.Status = 
                        STATUS_INVALID_PARAMETER;
                    Irp->IoStatus.Information = 0;
                    break;
            }
            break;
    }

    if (NtStatus == STATUS_PENDING) {
        return (STATUS_PENDING);
    }

    ASSERT(NtStatus == Irp->IoStatus.Status);

    //
    // Unmark the irp pending since we are completing the
    // the irp below.
    //
    irpStack->Control &= ~SL_PENDING_RETURNED;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    DBGOUT((3, "NdisTapiDispatch: completed Irp=%p", Irp));

    return NtStatus;
}

VOID
NdisTapiUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/

{
    KIRQL                   oldIrql;
    PPROVIDER_INFO provider, nextProvider;


    DBGOUT ((2, "NdisTapiUnload: enter"));

    //
    // Delete the device object & sundry resources
    //

    while (!(IsListEmpty(&DeviceExtension->ProviderEventList))) {
        PPROVIDER_EVENT ProviderEvent;

        ProviderEvent = (PPROVIDER_EVENT)
            RemoveHeadList(&DeviceExtension->ProviderEventList);

        ExFreeToNPagedLookasideList(&ProviderEventLookaside, ProviderEvent);
    }

    ExDeleteNPagedLookasideList(&ProviderEventLookaside);

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    provider = DeviceExtension->Providers;

    while (provider != NULL)
    {
        nextProvider = provider->Next;

        ExFreePool (provider);

        provider = nextProvider;
    }

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    IoDeleteDevice (DriverObject->DeviceObject);

    DBGOUT ((2, "NdisTapiUnload: exit"));

    return;
}


VOID
NdisTapiRegisterProvider(
    IN  NDIS_HANDLE                 ProviderHandle,
    IN  PNDISTAPI_CHARACTERISTICS   Chars
    )
/*++

Routine Description:

    This func gets called by Ndis as a result of a Mac driver
    registering for Connection Wrapper services.

Arguments:



Return Value:


--*/

{
    KIRQL           oldIrql;
    BOOLEAN         sendRequest = FALSE;
    NDIS_STATUS     ndisStatus;
    PPROVIDER_INFO  provider, newProvider;


    DBGOUT ((2, "NdisTapiRegisterProvider: enter"));

    //
    // Grab the spin lock & add the new provider, and see whether to
    // send the provider an init request
    //
    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    //
    // See if this provider has already registered once.
    //
    provider = DeviceExtension->Providers;

    while (provider != NULL) {
        if (provider->Status == PROVIDER_STATUS_OFFLINE &&

            RtlCompareMemory(
                &provider->Guid,
                &Chars->Guid,
                sizeof(provider->Guid)) == sizeof(provider->Guid)) {
            DBGOUT((
                1,
                "Found a provider %p for Guid %4.4x-%2.2x-%2.2x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x",
                provider,
                provider->Guid.Data1,
                provider->Guid.Data2,
                provider->Guid.Data3,
                provider->Guid.Data4[0],
                provider->Guid.Data4[1],
                provider->Guid.Data4[2],
                provider->Guid.Data4[3],
                provider->Guid.Data4[4],
                provider->Guid.Data4[5],
                provider->Guid.Data4[6],
                provider->Guid.Data4[7]
                ));

            DBGOUT((
                1,
                "numDevices %d BaseID %d",
                provider->NumDevices,
                provider->DeviceIDBase
                ));

            provider->Status = PROVIDER_STATUS_PENDING_REINIT;
            provider->ProviderHandle = ProviderHandle;
            provider->RequestProc = Chars->RequestProc;
            provider->MediaType = Chars->MediaType;
            break;
        }

        provider = provider->Next;
    }

    if (provider == NULL) {
        //
        // Create a new provider instance
        //

        newProvider = ExAllocatePoolWithTag(
                NonPagedPoolCacheAligned,
                sizeof(PROVIDER_INFO),
                'IPAT'
                );

        if (!newProvider) {
            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
            return;
        }

        RtlZeroMemory(newProvider, sizeof(PROVIDER_INFO));

        newProvider->Status         = PROVIDER_STATUS_PENDING_INIT;
        newProvider->ProviderHandle = ProviderHandle;
        newProvider->RequestProc    = Chars->RequestProc;

        RtlMoveMemory(
            &newProvider->Guid,
            &Chars->Guid,
            sizeof(newProvider->Guid)
            );

        newProvider->MediaType      = Chars->MediaType;
        newProvider->Next           = NULL;

        DBGOUT((
            1,
            "New provider for Guid %4.4x-%2.2x-%2.2x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x",
            newProvider->Guid.Data1,
            newProvider->Guid.Data2,
            newProvider->Guid.Data3,
            newProvider->Guid.Data4[0],
            newProvider->Guid.Data4[1],
            newProvider->Guid.Data4[2],
            newProvider->Guid.Data4[3],
            newProvider->Guid.Data4[4],
            newProvider->Guid.Data4[5],
            newProvider->Guid.Data4[6],
            newProvider->Guid.Data4[7]
            ));

        //
        // Add the new provider, and see whether to send the 
        // provider an init request
        //

        if ((provider = DeviceExtension->Providers) == NULL) {
            DeviceExtension->Providers = newProvider;
        }
        else {
            while (provider->Next != NULL) {
                provider = provider->Next;
            }

            provider->Next = newProvider;
        }

        provider = newProvider;
    }


    //
    // The only case where we want to send off an init request to the
    // provider directly is when we are currently connected to TAPI,
    // and even then only when there are no other inits pending (since
    // we must synchronize inits due to calculation of DeviceIDBase)
    //

    if (DeviceExtension->Status == NDISTAPI_STATUS_CONNECTED) {
        //
        // TAPI is up.
        //
        // If TAPI already knows about this provider
        // go ahead and init the provider with it's current
        // DeviceIDBase.
        //
        // If TAPI does not know about this provider we
        // need to give TAPI an indication of a new device
        // coming on line.
        //
        if (provider->Status == PROVIDER_STATUS_PENDING_REINIT) {

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

            ndisStatus = 
                SendProviderInitRequest (provider);

            if (ndisStatus == NDIS_STATUS_PENDING) {
                //
                // Wait for completion routine to get called
                //

                KeWaitForSingleObject (&provider->SyncEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       (PTIME) NULL);
            }

            KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

            //
            // Get tapi to reset the state of these lines by
            // forcing a line_close...
            //
            if (provider->DeviceInfo != NULL) {
                PDEVICE_INFO    DeviceInfo;
                ULONG           i;
                
                for(i = 0, DeviceInfo = provider->DeviceInfo;
                    i < provider->NumDevices;
                    i++, DeviceInfo++) {
                    NDIS_TAPI_EVENT NdisTapiEvent;


                    RtlZeroMemory (&NdisTapiEvent, sizeof(NDIS_TAPI_EVENT));

                    if (DeviceInfo->htLine != (HTAPI_LINE)NULL)
                    {
                        NdisTapiEvent.htLine = DeviceInfo->htLine;
                        NdisTapiEvent.ulMsg = LINE_CLOSE;

                        KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

                        NdisTapiIndicateStatus((ULONG_PTR) provider,
                                               &NdisTapiEvent,
                                               sizeof (NDIS_TAPI_EVENT));

                        KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

                        DeviceInfo->htLine = (HTAPI_LINE)NULL;
                        DeviceInfo->hdLine = (HDRV_LINE)NULL;
                    }
                }
            }

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

        } else {

            NDIS_TAPI_EVENT NdisTapiEvent;

            ASSERT(provider->Status == PROVIDER_STATUS_PENDING_INIT);

            provider->Status = PROVIDER_STATUS_PENDING_LINE_CREATE;

            //
            // If there are no providers in the middle of doing
            // line_create's then we will kick off creates for this
            // provider.
            //
            // If we already have a line create pending on a provider
            // then we will wait until all of its line creates have
            // finished before we start sending them from
            // this one.
            //
            if (!(DeviceExtension->Flags & PENDING_LINECREATE)) {

                //
                // Do a LINE_CREATE so that we can get the starting
                // BaseID for this provider.  When TAPI calls us back
                // with ProviderCreateLineDevice we will have the
                // BaseDeviceID to use for this provider and we will
                // then init the provider.  Once we find out how many
                // devices the provider has we will alert TAPI of the
                // additional devices.
                //
                RtlZeroMemory(&NdisTapiEvent, sizeof(NDIS_TAPI_EVENT));

                provider->TempID = (ULONG_PTR)provider;

                DBGOUT((-1, 
                        "LINE_CREATE %d for provider %p",
                        provider->CreateCount,
                        provider->TempID
                        ));

                NdisTapiEvent.ulMsg = LINE_CREATE;
                NdisTapiEvent.ulParam1 = 0;
                NdisTapiEvent.ulParam2 = provider->TempID;
                NdisTapiEvent.ulParam3 = 0;

                DeviceExtension->Flags |= PENDING_LINECREATE;

                KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

                NdisTapiIndicateStatus((ULONG_PTR)provider, &NdisTapiEvent, sizeof(NDIS_TAPI_EVENT));
            }
            else
            {
                KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
            }
        }

        KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);
    }

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    ObReferenceObject(DeviceExtension->DeviceObject);
}



VOID
NdisTapiDeregisterProvider(
    IN  NDIS_HANDLE ProviderHandle
    )

/*++

Routine Description:

    This func...

    Note that this func does not send the provider a shutdown message,
    as an implicit shutdown is assumed when the provider deegisters.

Arguments:



Return Value:


--*/

{
    KIRQL           oldIrql;
    BOOLEAN         sendShutdownMsg = FALSE;
    PPROVIDER_INFO  provider, previousProvider;


    DBGOUT ((2, "NdisTapiDeregisterProvider: enter"));

    //
    // Grab the spin lock protecting the device extension
    //
    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    //
    // Find the provider instance corresponding to ProviderHandle
    //

    previousProvider = NULL;
    provider = DeviceExtension->Providers;

    while (provider != NULL &&
           provider->ProviderHandle != ProviderHandle) {
        
        previousProvider = provider;

        provider = provider->Next;
    }

    if (provider == NULL) {
        KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
        return;
    }

    if (provider->Status == PROVIDER_STATUS_ONLINE) {
        DeviceExtension->NdisTapiNumDevices -= provider->NumDevices;
    }

    //
    // Send the ProviderShutdown only if the provider
    // is not in PROVIDER_STATUS_OFFLINE. Otherwise
    // DoIrpMjCloseWork can end up sending 
    // Providershutdown on a removed adapter.
    //
    if(provider->Status != PROVIDER_STATUS_OFFLINE)
    {
        SendProviderShutdown (provider, &oldIrql);
        provider->Status = PROVIDER_STATUS_OFFLINE;
    }

    //
    // Do the right thing according to the current NdisTapi state
    //

    switch (DeviceExtension->Status)
    {
        case NDISTAPI_STATUS_CONNECTED:
        {
                UINT    i;

        //
        // Mark provider as offline
        //
        provider->Status = PROVIDER_STATUS_OFFLINE;
        provider->ProviderHandle = NULL;

#if 0
        if (provider->DeviceInfo != NULL) {
            PDEVICE_INFO    DeviceInfo;

            for(
                i = 0, DeviceInfo = provider->DeviceInfo;
                i < provider->NumDevices;
                i++, DeviceInfo++
                )
            {
                NDIS_TAPI_EVENT NdisTapiEvent;


                RtlZeroMemory (&NdisTapiEvent, sizeof(NDIS_TAPI_EVENT));

                if (DeviceInfo->htLine != (HTAPI_LINE)NULL)
                {
                    NdisTapiEvent.htLine = DeviceInfo->htLine;
                    NdisTapiEvent.ulMsg = LINE_CLOSE;

                    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

                    NdisTapiIndicateStatus((ULONG_PTR) provider,
                                           &NdisTapiEvent,
                                           sizeof (NDIS_TAPI_EVENT));

                    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

                    DeviceInfo->htLine = (HTAPI_LINE)NULL;
                }
            }
        }
#endif

        // PnP: what if providerInfo->State == PROVIDER_INIT_PENDING
        // PnP: what if providerInfo->State == PROVIDER_OFFLINE

        break;

        }

    case NDISTAPI_STATUS_DISCONNECTING:
    case NDISTAPI_STATUS_DISCONNECTED:

        //
        // Fix up pointers, remove provider from list
        //
        if (previousProvider == NULL) {
            DeviceExtension->Providers = provider->Next;
        } else {
            previousProvider->Next = provider->Next;
        }

        ExFreePool (provider);

        break;

    case NDISTAPI_STATUS_CONNECTING:

        // PnP: implement

        break;

    } // switch

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    ObDereferenceObject(DeviceExtension->DeviceObject);

    DBGOUT((2, "NdisTapiDeregisterProvider: exit"));
}



VOID
NdisTapiIndicateStatus(
    IN  ULONG_PTR   DriverHandle,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    )

/*++

Routine Description:

    This func gets called by Ndis when a miniport driver calls
    NdisIndicateStatus to notify us of an async event
    (i.e. new call, call state chg, dev state chg, etc.)

Arguments:



Return Value:


--*/

{
    PIRP    irp;
    KIRQL   oldIrql;
    ULONG   bytesInQueue;
    ULONG   bytesToMove;
    ULONG   moveSize;
    BOOLEAN satisfiedPendingEventsRequest = FALSE;
    PNDIS_TAPI_EVENT    ndisTapiEvent;
    PNDISTAPI_EVENT_DATA    ndisTapiEventData;


    DBGOUT((2,"NdisTapiIndicateStatus: enter"));


    bytesInQueue = StatusBufferSize;

    moveSize = 0;


    //
    // Sync event buf access by acquiring SpinLock
    //

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    //
    // The very first thing to do is check if this is a LINE_NEWCALL
    // indication.  If so, we need to generate a unique tapi call
    // handle, which will be both returned to the calling miniport
    // (for use in subsequent status indications) and passed up to
    // the tapi server.
    //
    // The algorithim for computing a unique "htCall" is to start
    // at the value 0x80000001, and perpetually increment by 2.  
    // Keeping the low bit set will allow the user-mode TAPI component
    // we talk to to distinguish between these incoming call handles
    // and outgoing call handles, the latter of which will always
    // have the low bit zero'd (since they're really pointers to heap).
    // We are again going to use the space between 0x80000001 and 0xFFFFFFFF
    // to identify our call handle.  This allows for a maximum of 1GB of
    // calls to be active at a time.  This is done to avoid a conflict
    // with ndiswan's connection table index.  A bug in the ddk doc's
    // had users providing the connectionid instead of ndiswan's context
    // in the line get id oid.  Ndiswan has to check both of these and
    // now that they overlap it can cause problems.  NdisWan will use
    // 0x00000000 - 0x80000000 for it's context values.
    //
    // In <= NT 4.0, valid values used to range between 0x80000000
    // and 0xffffffff, as we relied on the fact that user-mode
    // addresses always had the low bit zero'd.  (Not a valid
    // assumption anymore!)
    //

    ndisTapiEvent = StatusBuffer;

    if (ndisTapiEvent->ulMsg == LINE_NEWCALL)
    {
        ndisTapiEvent->ulParam2 = DeviceExtension->htCall;

        DeviceExtension->htCall++;
        DeviceExtension->htCall++;

        if (DeviceExtension->htCall < 0x80000000) {
            DeviceExtension->htCall = 0x80000001;
        }
    }


    //
    // Check of there is an outstanding request to satisfy
    //

    if (DeviceExtension->EventsRequestIrp) {

        ASSERT(IsListEmpty(&DeviceExtension->ProviderEventList));

        //
        // Acquire the cancel spinlock, remove the request from the
        // cancellable state, and free the cancel spinlock.
        //

        irp = DeviceExtension->EventsRequestIrp;

        if (IoSetCancelRoutine(irp, NULL) != NULL) {
            DeviceExtension->EventsRequestIrp = NULL;


            //
            // Copy as much of the input data possible from the input data
            // queue to the SystemBuffer to satisfy the read.
            //

            ndisTapiEventData = irp->AssociatedIrp.SystemBuffer;

            bytesToMove = ndisTapiEventData->ulTotalSize;

            moveSize = (bytesInQueue < bytesToMove) ? bytesInQueue : bytesToMove;

            RtlMoveMemory (
                ndisTapiEventData->Data,
                (PCHAR) StatusBuffer,
                moveSize
                );


            //
            // Set the flag so that we start the next packet and complete
            // this read request (with STATUS_SUCCESS) prior to return.
            //

            ndisTapiEventData->ulUsedSize = moveSize;

            irp->IoStatus.Status = STATUS_SUCCESS;

            irp->IoStatus.Information = sizeof(NDISTAPI_EVENT_DATA) + moveSize - 1;

            satisfiedPendingEventsRequest = TRUE;
        }

    } else {

        do {
            PPROVIDER_EVENT ProviderEvent;

            ProviderEvent =
                ExAllocateFromNPagedLookasideList(&ProviderEventLookaside);

            if (ProviderEvent == NULL) {
                break;
            }

            RtlMoveMemory(&ProviderEvent->Event, StatusBuffer, sizeof(NDIS_TAPI_EVENT));

            InsertTailList(&DeviceExtension->ProviderEventList,
                           &ProviderEvent->Linkage);

            DeviceExtension->EventCount++;

        } while ( FALSE );
    }

    //
    // Release the spinlock
    //

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);


    //
    // If we satisfied an outstanding get events request then complete it
    //

    if (satisfiedPendingEventsRequest) {
        IoCompleteRequest (irp, IO_NO_INCREMENT);

        DBGOUT((2, "NdisTapiIndicateStatus: completion req %p", irp));
    }


    DBGOUT((2,"NdisTapiIndicateStatus: exit"));

    return;
}

VOID
NdisTapiCompleteRequest(
    IN  NDIS_HANDLE     NdisHandle,
    IN  PNDIS_REQUEST   NdisRequest,
    IN  NDIS_STATUS     NdisStatus
    )

/*++

Routine Description:

    This func gets called by Ndis as a result of a Mac driver
    calling NdisCompleteRequest of one of our requests.

Arguments:



Return Value:


--*/

{
    PIRP                    Irp;
    KIRQL                   oldIrql;
    ULONG                   requestID;
    PNDISTAPI_REQUEST       ndisTapiRequest;
    PPROVIDER_REQUEST       providerRequest;
    PPROVIDER_REQUEST       tempReq;
    PIO_STACK_LOCATION      irpStack;

    DBGOUT ((2, "NdisTapiCompleteRequest: enter"));

    providerRequest =
        CONTAINING_RECORD(NdisRequest, PROVIDER_REQUEST, NdisRequest);

    do {
        if (providerRequest->Flags & INTERNAL_REQUEST) {

            //
            // This request originated from NdisTapi.sys
            //
            switch (NdisRequest->DATA.SET_INFORMATION.Oid) {
                case OID_TAPI_PROVIDER_INITIALIZE:
                    DBGOUT((3,
                            "NdisTapiCompleteRequest: ProviderInit - Provider=%p, reqID=%x, Status=%x",
                            providerRequest->Provider,
                            providerRequest->RequestID,
                            NdisStatus));

                    switch (DeviceExtension->Status) {
                        case NDISTAPI_STATUS_CONNECTED:
                        case NDISTAPI_STATUS_CONNECTING:

                            DoProviderInitComplete (providerRequest, NdisStatus);
                            break;

                        case NDISTAPI_STATUS_DISCONNECTED:
                        case NDISTAPI_STATUS_DISCONNECTING:
                        default:
                            break;

                    }
                    break;

                case OID_TAPI_PROVIDER_SHUTDOWN:
                    DBGOUT((3,
                            "NdisTapiCompleteRequest: ProviderShutdown - Provider=%p, reqID=%x, Status=%x",
                            providerRequest->Provider,
                            providerRequest->RequestID,
                            NdisStatus));
                    break;

                default:
                    DBGOUT((1, "NdisTapiCompleteRequest: unrecognized Oid"));

                    break;
            }

            break;
        }

        //
        // This is a request originating from TAPI
        //


        //
        // Acquire the SpinLock since we're going to be removing a
        // TAPI request from the queue, and it might not be the request
        // we're looking for. The primary concern is that we could (if
        // the request we're really looking for has been removed) remove
        // a synchrously-completed request that is about to be removed &
        // completed in NdisTapiDispatch, in which case we want to stick
        // the request back in the queue before NdisTapiDispatch tries
        // to remove it.
        //
        KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

        tempReq = 
            (PPROVIDER_REQUEST)DeviceExtension->ProviderRequestList.Flink;

        while ((PVOID)tempReq != (PVOID)&DeviceExtension->ProviderRequestList) {
            if (tempReq == providerRequest) {
                break;
            }

            tempReq = 
                (PPROVIDER_REQUEST)tempReq->Linkage.Flink;
        }

        if (tempReq != providerRequest) {
#if DBG
            DbgPrint("NDISTAPI: NdisTapiCompleteRequest: Request %p not found!\n", 
                providerRequest);
#endif
            DeviceExtension->MissingRequests++;

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
            break;
        }

        Irp = providerRequest->Irp;

        ndisTapiRequest = Irp->AssociatedIrp.SystemBuffer;

        ASSERT(providerRequest->RequestID == 
            *((ULONG *)ndisTapiRequest->Data));

        //
        // Remove the IRP from the cancelable state
        //
        if (IoSetCancelRoutine(Irp, NULL) == NULL) {
            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
            break;
        }

        RemoveEntryList(&providerRequest->Linkage);
        DeviceExtension->RequestCount--;

        KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

        DBGOUT((3,
                "NdisTapiCompleteRequest: Irp=%p, Oid=%x, devID=%d, reqID=%x, Status=%x",
                Irp,
                ndisTapiRequest->Oid,
                ndisTapiRequest->ulDeviceID,
                *((ULONG *)ndisTapiRequest->Data),
                  NdisStatus));

        //
        // Copy the relevant info back to the IRP
        //

        irpStack = IoGetCurrentIrpStackLocation (Irp);

        //
        // If this was a succesful QUERY_INFO request copy all the
        // data back to the tapi request buf & set
        // Irp->IoStatus.Information appropriately. Otherwise, we
        // just need to pass back the return value. Also mark irp
        // as successfully completed (regardless of actual op result)
        //

        if ((NdisRequest->RequestType == NdisRequestQueryInformation) &&
            (NdisStatus == NDIS_STATUS_SUCCESS)) {

            RtlMoveMemory(ndisTapiRequest->Data,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                ndisTapiRequest->ulDataSize);

            Irp->IoStatus.Information =
                irpStack->Parameters.DeviceIoControl.OutputBufferLength;
        } else {

            Irp->IoStatus.Information = sizeof (ULONG);
        }

        if((NdisRequest->RequestType == NdisRequestQueryInformation) &&
          (NdisRequest->DATA.QUERY_INFORMATION.Oid == OID_TAPI_OPEN)) {
        
            DoLineOpenCompleteWork(ndisTapiRequest,
                            providerRequest->Provider);
        }
        

        Irp->IoStatus.Status = STATUS_SUCCESS;

        ndisTapiRequest->ulReturnValue = NdisStatus;

        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } while (FALSE);

    ExFreePool (providerRequest);

    DBGOUT ((2, "NdisTapiCompleteRequest: exit"));
}


#if DBG
VOID
DbgPrt(
    IN LONG  DbgLevel,
    IN PUCHAR DbgMessage,
    IN ...
    )

/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/

{
    if (DbgLevel <= NdisTapiDebugLevel)
    {
        char    buf[256] = "NDISTAPI: ";
        va_list ap;

        va_start (ap, DbgMessage);

        vsprintf (&buf[10], DbgMessage, ap);

        strcat (buf, "\n");

        DbgPrint (buf);

        va_end(ap);
    }

    return;
}
#endif // DBG


VOID
DoProviderInitComplete(
    PPROVIDER_REQUEST  ProviderRequest,
    NDIS_STATUS Status
    )

/*++

Routine Description:



Arguments:

    ProviderInitRequest - pointer successfully completed init request

Return Value:



Note:

--*/

{
    PPROVIDER_INFO                  provider = ProviderRequest->Provider;
    PNDIS_TAPI_PROVIDER_INITIALIZE  providerInitData =
        (PNDIS_TAPI_PROVIDER_INITIALIZE) ProviderRequest->Data;
    KIRQL OldIrql;
    BOOLEAN fFreeDeviceInfo = FALSE;

    DBGOUT ((2, "DoProviderInitComplete: enter"));

    //
    // Wrap this in an exception handler in case the provider was
    // removed during an async completion
    //
    try
    {
        if (Status == NDIS_STATUS_SUCCESS) {

            provider->ProviderID = (ULONG)providerInitData->ulProviderID;
            
            // Just in case the provider reports a bigger ulNumLineDevs
            if(providerInitData->ulNumLineDevs > provider->NumDevices)
            {
                fFreeDeviceInfo = TRUE;
            }
            
            provider->NumDevices = providerInitData->ulNumLineDevs;

            KeAcquireSpinLock(&DeviceExtension->SpinLock, &OldIrql);

            DeviceExtension->NdisTapiNumDevices += provider->NumDevices;

            KeReleaseSpinLock(&DeviceExtension->SpinLock, OldIrql);

            provider->Status = PROVIDER_STATUS_ONLINE;

            if(provider->DeviceInfo && fFreeDeviceInfo)
            {
                ExFreePool (provider->DeviceInfo);
                provider->DeviceInfo = NULL;
            }
            
            if (provider->DeviceInfo == NULL) {
                provider->DeviceInfo = (PDEVICE_INFO)
                    ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof(DEVICE_INFO) * provider->NumDevices,
                        'IPAT'
                        );
            }

            if (provider->DeviceInfo != NULL) {
                PDEVICE_INFO    DeviceInfo;
                UINT    i;

                RtlZeroMemory(
                    provider->DeviceInfo,
                    sizeof(DEVICE_INFO) * provider->NumDevices
                    );

                for(i = 0, DeviceInfo = provider->DeviceInfo;
                    i < provider->NumDevices;
                    i++, DeviceInfo++) {
                    DeviceInfo->DeviceID = provider->DeviceIDBase + i;
                }
            }
        }

        //
        // Set the event which sync's miniport inits
        //

        KeSetEvent(&provider->SyncEvent,
                   0,
                   FALSE);

        DBGOUT((3,
                "providerID = 0x%x, numDevices = %d, BaseID = %d",
                provider->ProviderID,
                provider->NumDevices,
                provider->DeviceIDBase));
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        DBGOUT((1, "DoProviderInitComplete: provider invalid"));
    }

    DBGOUT ((2, "DoProviderInitComplete: exit"));
}


ULONG
GetLineEvents(
    PCHAR   EventBuffer,
    ULONG   BufferSize
    )

/*++

Routine Description:



Arguments:



Return Value:



Note:

    Assumes DeviceExtension->SpinLock held by caller.

--*/

{
    ULONG   BytesLeft;
    ULONG   BytesMoved;
    ULONG   EventCount;

    BytesLeft = BufferSize;
    BytesMoved = 0;
    EventCount = 0;

    while (!(IsListEmpty(&DeviceExtension->ProviderEventList))) {
        PPROVIDER_EVENT ProviderEvent;

        if (BytesLeft < sizeof(NDIS_TAPI_EVENT)) {
            break;
        }

        ProviderEvent = (PPROVIDER_EVENT)
            RemoveHeadList(&DeviceExtension->ProviderEventList);

        EventCount++;

        RtlMoveMemory(EventBuffer + BytesMoved,
                      (PUCHAR)&ProviderEvent->Event,
                      sizeof(NDIS_TAPI_EVENT));

        BytesMoved += sizeof(NDIS_TAPI_EVENT);
        BytesLeft -= sizeof(NDIS_TAPI_EVENT);

        ExFreeToNPagedLookasideList(&ProviderEventLookaside,
                                    ProviderEvent);
    }

    DeviceExtension->EventCount -= EventCount;

    DBGOUT((3, "GetLineEvents: Returned %d Events", EventCount));

    return (BytesMoved);
}


NDIS_STATUS
SendProviderInitRequest(
    PPROVIDER_INFO  Provider
    )

/*++

Routine Description:



Arguments:

    Provider - pointer to a PROVIDER_INFO representing provider to initialize

Return Value:



Note:

--*/

{
    KIRQL   oldIrql;
    NDIS_STATUS ndisStatus;
    PNDIS_REQUEST   NdisRequest;
    PPROVIDER_INFO  tmpProvider;
    PPROVIDER_REQUEST   providerRequest;
    PNDIS_TAPI_PROVIDER_INITIALIZE  providerInitData;

    DBGOUT ((2, "SendProviderInitRequest: enter"));

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    //
    // Determine the DeviceIDBase to be used for this provider
    //
    if (Provider->Status == PROVIDER_STATUS_PENDING_INIT) {

        Provider->DeviceIDBase = DeviceExtension->ProviderBaseID;
        tmpProvider = DeviceExtension->Providers;

        while (tmpProvider != NULL) {
            if (tmpProvider->Status != PROVIDER_STATUS_PENDING_INIT) {
                Provider->DeviceIDBase += tmpProvider->NumDevices;
            }

            tmpProvider = tmpProvider->Next;
        }
    }


    //
    // Create a provider init request
    //
    providerRequest = ExAllocatePoolWithTag(
        NonPagedPoolCacheAligned,
        sizeof(PROVIDER_REQUEST) + sizeof(NDIS_TAPI_PROVIDER_INITIALIZE) -
            sizeof(ULONG),
        'IPAT'
        );

    if (!providerRequest) {
        KeReleaseSpinLock(&DeviceExtension->SpinLock, oldIrql);

        return NDIS_STATUS_RESOURCES;
    }


    providerRequest->Irp = NULL;
    providerRequest->Flags = INTERNAL_REQUEST;
    providerRequest->Provider = Provider;
    NdisRequest = &providerRequest->NdisRequest;

    NdisRequest->RequestType = 
        NdisRequestQueryInformation;

    NdisRequest->DATA.SET_INFORMATION.Oid =
        OID_TAPI_PROVIDER_INITIALIZE;

    NdisRequest->DATA.SET_INFORMATION.InformationBuffer =
        providerRequest->Data;

    NdisRequest->DATA.SET_INFORMATION.InformationBufferLength =
        sizeof(NDIS_TAPI_PROVIDER_INITIALIZE);

    providerInitData                 =
        (PNDIS_TAPI_PROVIDER_INITIALIZE) providerRequest->Data;

    providerRequest->RequestID =
        providerInitData->ulRequestID = ++DeviceExtension->ulRequestID;

    providerInitData->ulDeviceIDBase = Provider->DeviceIDBase;

    KeInitializeEvent(&Provider->SyncEvent,
                      SynchronizationEvent,
                      FALSE);

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    //
    // Send the request
    //
    ndisStatus=
        (*Provider->RequestProc)
            (Provider->ProviderHandle,NdisRequest);

    if (ndisStatus != NDIS_STATUS_PENDING) {
        DoProviderInitComplete (providerRequest, ndisStatus);
        ExFreePool (providerRequest);
    }

    DBGOUT ((2, "SendProviderInitRequest: exit status %x", ndisStatus));

    return ndisStatus;
}


NDIS_STATUS
SendProviderShutdown(
    PPROVIDER_INFO  Provider,
    PKIRQL          oldIrql
    )

/*++

Routine Description:



Arguments:



Return Value:

    A pointer to the next provider in the global providers list

Note:

    Assumes DeviceExtension->SpinLock held by caller.

--*/

{
    NDIS_STATUS ndisStatus;
    PNDIS_REQUEST   NdisRequest;
    PPROVIDER_REQUEST   providerRequest;
    PNDIS_TAPI_PROVIDER_SHUTDOWN    providerShutdownData;

    DBGOUT ((2, "SendProviderShutdown: Provider=%p", Provider));

    //
    // Create a provider init request
    //
    providerRequest = 
        ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
            sizeof(PROVIDER_REQUEST) + sizeof(NDIS_TAPI_PROVIDER_SHUTDOWN) -
            sizeof(ULONG),
            'IPAT');

    if (!providerRequest) {
        return NDIS_STATUS_RESOURCES;
    }

    providerRequest->Irp = NULL;
    providerRequest->Flags = INTERNAL_REQUEST;
    providerRequest->Provider = Provider;
    NdisRequest = &providerRequest->NdisRequest;

    NdisRequest->RequestType = 
        NdisRequestSetInformation;

    NdisRequest->DATA.SET_INFORMATION.Oid =
        OID_TAPI_PROVIDER_SHUTDOWN;

    NdisRequest->DATA.SET_INFORMATION.InformationBuffer =
        providerRequest->Data;

    NdisRequest->DATA.SET_INFORMATION.InformationBufferLength =
        sizeof(NDIS_TAPI_PROVIDER_SHUTDOWN);

    providerShutdownData =
        (PNDIS_TAPI_PROVIDER_SHUTDOWN)providerRequest->Data;

    providerRequest->RequestID =
        providerShutdownData->ulRequestID = ++DeviceExtension->ulRequestID;

    KeReleaseSpinLock (&DeviceExtension->SpinLock, *oldIrql);

    //
    // Send the request
    //
    ndisStatus = 
        (*Provider->RequestProc)
            (Provider->ProviderHandle, NdisRequest);

    //
    // If request was completed synchronously then free the request
    // (otherwise it will get freed when the completion proc is called)
    //
    if (ndisStatus != NDIS_STATUS_PENDING) {
        ExFreePool (providerRequest);
    }

    DBGOUT ((2, "SendProviderShutdown: Status=%x", ndisStatus));

    KeAcquireSpinLock (&DeviceExtension->SpinLock, oldIrql);

    return ndisStatus;
}


BOOLEAN
SyncInitAllProviders(
    void
    )

/*++

Routine Description:

    This functions walks the list of registered providers and sends
    init requests to the providers in the PENDING_INIT state

Arguments:

    (none)

Return Value:

    TRUE if all registered providers initialized, or
    FALSE if there are more providers to initialze

Note:

--*/

{
    ULONG           numDevices = 0;
    NDIS_STATUS     ndisStatus;
    PPROVIDER_INFO  provider;
    KIRQL           oldIrql;


    DBGOUT((2, "SyncInitAllProviders: enter"));

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    provider = DeviceExtension->Providers;

    while (provider != NULL) {
        if (provider->Status == PROVIDER_STATUS_PENDING_INIT ||
            provider->Status == PROVIDER_STATUS_PENDING_REINIT ||
            provider->Status == PROVIDER_STATUS_PENDING_LINE_CREATE) {

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

            ndisStatus = SendProviderInitRequest (provider);

            if (ndisStatus == NDIS_STATUS_PENDING) {
                //
                // Wait for completion routine to get called
                //

                KeWaitForSingleObject (&provider->SyncEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       (PTIME) NULL
                                       );

            }

            KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);
        }

        provider = provider->Next;
    }


    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    DBGOUT((2, "SyncInitAllProviders: exit"));

    return TRUE;
}

VOID
DoIrpMjCloseWork(
    PIRP    Irp
    )
{
    KIRQL               oldIrql;

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    if (InterlockedDecrement(&DeviceExtension->RefCount) == 0) {

        if (DeviceExtension->Status == NDISTAPI_STATUS_CONNECTED) {
            PPROVIDER_INFO provider;

            DeviceExtension->Status =
                NDISTAPI_STATUS_DISCONNECTING;

            //
            // Send the providers a shutdown request
            //

            provider = DeviceExtension->Providers;

            while (provider != NULL) {

                switch (provider->Status) {
                    case PROVIDER_STATUS_ONLINE:

                        DeviceExtension->NdisTapiNumDevices -= provider->NumDevices;
                        SendProviderShutdown (provider, &oldIrql);

                        //
                        // fall thru...
                        //
                    case PROVIDER_STATUS_PENDING_INIT:
                    case PROVIDER_STATUS_PENDING_REINIT:

                        //
                        // Reset provider status
                        //
                        provider->Status = PROVIDER_STATUS_PENDING_INIT;
                        break;

                    case PROVIDER_STATUS_OFFLINE:
                        break;

                }

                provider = provider->Next;
            }

            DeviceExtension->Status = NDISTAPI_STATUS_DISCONNECTED;

            ASSERT(DeviceExtension->NdisTapiNumDevices == 0);
        }
    }

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
}

NTSTATUS
DoIoctlConnectWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    )
{
    KIRQL   oldIrql;
    ULONG   InfoSize;
    NTSTATUS    NtStatus;

    //
    // Someone's connecting. Make sure they passed us a valid
    // info buffer
    //
    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    do {

        if ((inputBufferLength < 2*sizeof(ULONG)) ||
            (outputBufferLength < sizeof(ULONG))) {

            DBGOUT ((3, "IOCTL_NDISTAPI_CONNECT: buffer too small"));
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            InfoSize = 0;
            break;
        }

        if (DeviceExtension->Status == NDISTAPI_STATUS_DISCONNECTED) {

            DeviceExtension->Status = NDISTAPI_STATUS_CONNECTING;

            DeviceExtension->ProviderBaseID =
                *((ULONG *) ioBuffer);

            DBGOUT ((1, "ProviderBaseID %d",
                     DeviceExtension->ProviderBaseID));
            //
            // Synchronously init all providers
            //
            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

            SyncInitAllProviders();

            KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);
        }

        //
        // Return the number of line devs
        //
        {
            ULONG OfflineCount;
            PPROVIDER_INFO provider;

            //
            // Since some providers might be temporarily offline
            // we need to tell tapi about them even though they
            // are not currently useable.  This keeps the tapi
            // deviceid space consistent.
            //
            OfflineCount = 0;

            provider = DeviceExtension->Providers;
            while (provider != NULL) {
                if (provider->Status == PROVIDER_STATUS_OFFLINE) {
                    OfflineCount += provider->NumDevices;
                }
                provider = provider->Next;
            }

            *((ULONG *) ioBuffer)=
                DeviceExtension->NdisTapiNumDevices + OfflineCount;
        }

        DeviceExtension->Status = NDISTAPI_STATUS_CONNECTED;

        KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

        InfoSize = sizeof(ULONG);
        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    Irp->IoStatus.Status = NtStatus;
    Irp->IoStatus.Information = InfoSize;

    return (NtStatus);
}

NTSTATUS
DoIoctlQuerySetWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    )
{
    KIRQL   oldIrql;
    ULONG   InfoSize;
    NTSTATUS    NtStatus;
    PPROVIDER_INFO  provider;
    NDIS_STATUS     ndisStatus;
    PNDIS_REQUEST   NdisRequest;
    PNDISTAPI_REQUEST   ndisTapiRequest;
    PPROVIDER_REQUEST   providerRequest;
    PIO_STACK_LOCATION  irpStack;

    do {
        ndisTapiRequest = ioBuffer;
        NtStatus = STATUS_SUCCESS;
        InfoSize = 0;

        //
        // Make sure input & output buffers are large enough
        //
        if ((inputBufferLength < sizeof (NDISTAPI_REQUEST))  ||

            (ndisTapiRequest->ulDataSize > 0x10000000) ||

            (inputBufferLength < (sizeof (NDISTAPI_REQUEST) +
                ndisTapiRequest->ulDataSize - sizeof (UCHAR)) ||

            (outputBufferLength < (sizeof (NDISTAPI_REQUEST) +
                ndisTapiRequest->ulDataSize - sizeof (UCHAR))))) {
            DBGOUT((-1, "NdisTapiDispatch: buffer to small!"));
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Verify we're connected, then check the device ID of the
        // incoming request against our list of online devices
        //
        ndisStatus = 
            VerifyProvider(ndisTapiRequest, &provider);

        if (ndisStatus != NDIS_STATUS_SUCCESS) {
            ndisTapiRequest->ulReturnValue = ndisStatus;
            InfoSize = sizeof(ULONG);
            break;
        }

        //
        // If this is a line_close, check to see if the line has
        // been opened before sending a line close oid
        //
        if(ndisTapiRequest->Oid == OID_TAPI_CLOSE) {

            ndisStatus = VerifyLineClose(ndisTapiRequest, provider);

            if(ndisStatus != NDIS_STATUS_SUCCESS)
            {
                ndisTapiRequest->ulReturnValue = ndisStatus;
                InfoSize = sizeof(ULONG);
                break;
            }
            
        }
        

        //
        // Create the providerRequest & submit it
        //
        providerRequest = 
            ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                sizeof(PROVIDER_REQUEST) + 
                ndisTapiRequest->ulDataSize -
                sizeof(ULONG),
                'IPAT');

        if (providerRequest == NULL) {
            DBGOUT((-1, "NdisTapiDispatch: unable to alloc request buf"));

            ndisTapiRequest->ulReturnValue = NDIS_STATUS_RESOURCES;
            InfoSize = sizeof (ULONG);
            break;
        }

        if (ndisTapiRequest->Oid == OID_TAPI_OPEN) {
            DoLineOpenWork(ndisTapiRequest, provider);
        }

        KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

        providerRequest->Flags = 0;
        providerRequest->Irp = Irp;
        providerRequest->Provider = provider;
        providerRequest->RequestID = 
            *((ULONG *)ndisTapiRequest->Data) = ++DeviceExtension->ulRequestID;

        RtlMoveMemory(providerRequest->Data, 
            ndisTapiRequest->Data, ndisTapiRequest->ulDataSize);

        NdisRequest = &providerRequest->NdisRequest;

        irpStack = IoGetCurrentIrpStackLocation (Irp);

        NdisRequest->RequestType =
            (irpStack->Parameters.DeviceIoControl.IoControlCode == 
             IOCTL_NDISTAPI_QUERY_INFO) ? NdisRequestQueryInformation : 
            NdisRequestSetInformation;

        NdisRequest->DATA.SET_INFORMATION.Oid =
            ndisTapiRequest->Oid;

        NdisRequest->DATA.SET_INFORMATION.InformationBuffer =
            providerRequest->Data;

        NdisRequest->DATA.SET_INFORMATION.InformationBufferLength =
            ndisTapiRequest->ulDataSize;

        DBGOUT((3,
                "DoIoctlQuerySetWork: Oid=%x, devID=%d, reqID=%x",
                ndisTapiRequest->Oid,
                ndisTapiRequest->ulDeviceID,
                *((ULONG *)ndisTapiRequest->Data)));

        //
        // Queue up this TAPI request in our request list.
        //
        InsertTailList(&DeviceExtension->ProviderRequestList, 
                       &providerRequest->Linkage);
        DeviceExtension->RequestCount++;

        KeReleaseSpinLock(&DeviceExtension->SpinLock, oldIrql);

        //
        // Mark the TAPI request pending and set the cancel routine        
        //
        IoMarkIrpPending(Irp);
        Irp->IoStatus.Status = STATUS_PENDING;
        IoSetCancelRoutine (Irp, NdisTapiCancel);

        //
        // Call the provider's request proc
        //
        ndisStatus = 
            (*provider->RequestProc)
                (provider->ProviderHandle, NdisRequest);

        //
        // If PENDING was returned then just exit & let the completion
        // routine handle the request completion
        //
        // NOTE: If pending was returned then the request may have
        //       already been completed, so DO NOT touch anything
        //       in the Irp (don't reference the pointer, etc.)
        //

        if (ndisStatus == NDIS_STATUS_PENDING) {
            DBGOUT((1, "DoIoctlQuerySetWork: exit Irp=%p, Status=%x",
                    Irp, STATUS_PENDING));

            return (STATUS_PENDING);
        }

        //
        // The provider request completed synchronously, so remove
        // the TAPI request from the device queue. We need to
        // synchronize access to this queue with the
        // SpinLock.
        //
        KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);
        do {
            PPROVIDER_REQUEST   pReq;

            pReq = (PPROVIDER_REQUEST)
                DeviceExtension->ProviderRequestList.Flink;

            while ((PVOID)pReq != (PVOID)&DeviceExtension->ProviderRequestList) {
                if (pReq == providerRequest) {
                    break;
                }

                pReq = (PPROVIDER_REQUEST)
                    pReq->Linkage.Flink;
            }

            if (pReq != providerRequest) {
                DBGOUT((0, "DoIoctlQuerySetWork - Request %p not found!", 
                    providerRequest));
                KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
                return (STATUS_PENDING);
            }

            Irp = providerRequest->Irp;

            ndisTapiRequest = Irp->AssociatedIrp.SystemBuffer;

            ASSERT(providerRequest->RequestID == 
                *((ULONG *)ndisTapiRequest->Data));

            //
            // Remove the IRP from the cancelable state
            //
            if (IoSetCancelRoutine(Irp, NULL) == NULL) {
                DBGOUT((0, "DoIoctlQuerySetWork - Irp %p has been canceled!", Irp));
                KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
                return (STATUS_PENDING);
            }

            RemoveEntryList(&providerRequest->Linkage);
            DeviceExtension->RequestCount--;

        } while (FALSE);
        KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

        //
        // If this was a succesful QUERY_INFO request copy all the
        // data back to the tapi request buf & set
        // Irp->IoStatus.Information appropriately. Otherwise, we
        // just need to pass back the return value.
        //

        if ((irpStack->Parameters.DeviceIoControl.IoControlCode == 
             IOCTL_NDISTAPI_QUERY_INFO) &&
            (ndisStatus == NDIS_STATUS_SUCCESS)) {

            RtlMoveMemory(ndisTapiRequest->Data,
                          providerRequest->Data,
                          ndisTapiRequest->ulDataSize);

            InfoSize =
                irpStack->Parameters.DeviceIoControl.OutputBufferLength;

        } else {
            InfoSize = sizeof (ULONG);
        }

        ndisTapiRequest->ulReturnValue = ndisStatus;

        //
        // Free the providerRequest
        //
        ExFreePool (providerRequest);

    } while (FALSE);

    Irp->IoStatus.Status = NtStatus;
    Irp->IoStatus.Information = InfoSize;

    DBGOUT((1, "DoIoctlQuerySetWork: exit Irp=%p, Status=%x",
            Irp, NtStatus));

    return (NtStatus);
}

VOID
DoLineOpenCompleteWork(
    PNDISTAPI_REQUEST ndisTapiRequest,
    PPROVIDER_INFO provider
    )
{
    DBGOUT((2, "DoLineOpenCompleteWork: Open Completed"));
    
    //
    // Now stash the hdLine for this deviceid
    //
    if (provider->DeviceInfo != NULL) {
        UINT    i;
        PDEVICE_INFO    DeviceInfo;
        PNDIS_TAPI_OPEN TapiOpen;

        TapiOpen = (PNDIS_TAPI_OPEN) ndisTapiRequest->Data;
        for(i = 0, DeviceInfo = provider->DeviceInfo;
            i < provider->NumDevices;
            i++, DeviceInfo++) {
            if (DeviceInfo->DeviceID == TapiOpen->ulDeviceID) {

                DeviceInfo->hdLine = TapiOpen->hdLine;

                DBGOUT((2, "Complete for open. stashing hdline=0x%x for device %d",
                            DeviceInfo->hdLine, DeviceInfo->DeviceID));
                
                break;
            }
        }
    }
}

VOID
DoLineOpenWork(
    PNDISTAPI_REQUEST   ndisTapiRequest,
    PPROVIDER_INFO      provider
    )
{
    KIRQL   oldIrql;
    PNDIS_TAPI_OPEN TapiOpen;
    PNDISTAPI_OPENDATA  OpenData;

    TapiOpen = (PNDIS_TAPI_OPEN) ndisTapiRequest->Data;

    if (ndisTapiRequest->ulDataSize >= sizeof(NDIS_TAPI_OPEN) +
                                       sizeof(NDISTAPI_OPENDATA)) {

        OpenData = (PNDISTAPI_OPENDATA)
            ((PUCHAR)ndisTapiRequest->Data + sizeof(NDIS_TAPI_OPEN));

        RtlMoveMemory(&OpenData->Guid, 
            &provider->Guid, sizeof(OpenData->Guid));

        OpenData->MediaType = provider->MediaType;
    }

    //
    // Now stash the htLine for this deviceid
    //
    if (provider->DeviceInfo != NULL) {
        UINT    i;
        PDEVICE_INFO    DeviceInfo;

        for(i = 0, DeviceInfo = provider->DeviceInfo;
            i < provider->NumDevices;
            i++, DeviceInfo++) {
            if (DeviceInfo->DeviceID == TapiOpen->ulDeviceID) {

                DeviceInfo->htLine = TapiOpen->htLine;

                DBGOUT((
                    1,
                    "Stash htLine - provider %p DeviceID %d htLine %x",
                        provider,
                        DeviceInfo->DeviceID,
                        DeviceInfo->htLine));
            }
        }
    }
}

NDIS_STATUS
VerifyLineClose(
    PNDISTAPI_REQUEST   ndisTapiRequest,
    PPROVIDER_INFO      provider
    )
{
    NDIS_STATUS ndisStatus = NDIS_STATUS_SUCCESS;
    
    if (provider->DeviceInfo != NULL) {
        UINT    i;
        PDEVICE_INFO    DeviceInfo;
        PNDIS_TAPI_CLOSE TapiClose;

        TapiClose = (PNDIS_TAPI_CLOSE) ndisTapiRequest->Data;
        for(i = 0, DeviceInfo = provider->DeviceInfo;
            i < provider->NumDevices;
            i++, DeviceInfo++) {
            if (DeviceInfo->hdLine == TapiClose->hdLine) {
                break;
            }
        }

        if(i == provider->NumDevices)
        {
            DBGOUT((2,"LINE_CLOSE: didn't find hdLine=0x%x",
                    TapiClose->hdLine));
            ndisStatus = NDISTAPIERR_DEVICEOFFLINE;
        }
        else
        {
            DBGOUT((2, "LINE_CLOSE: found hdLine=0x%x",
                        TapiClose->hdLine));
        }
    }

    return ndisStatus;
}

NDIS_STATUS
VerifyProvider(
    PNDISTAPI_REQUEST   ndisTapiRequest,
    PPROVIDER_INFO      *provider
    )
{
    KIRQL   oldIrql;
    PPROVIDER_INFO  pp;
    NDIS_STATUS     Status;
    ULONG           targetDeviceID;

    Status = NDIS_STATUS_SUCCESS;
    *provider = NULL;

    targetDeviceID = ndisTapiRequest->ulDeviceID;

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    do {

        if (DeviceExtension->Status != NDISTAPI_STATUS_CONNECTED) {
            DBGOUT((3, "VerifyProvider: unconnected, returning err"));

            Status = NDISTAPIERR_UNINITIALIZED;
            break;
        }

        pp = DeviceExtension->Providers;

        while (pp != NULL) {

            if ((pp->Status == PROVIDER_STATUS_ONLINE) &&
                (targetDeviceID >= pp->DeviceIDBase) &&
                (targetDeviceID <
                     pp->DeviceIDBase + pp->NumDevices)
                ) {

                break;
            }

            pp = pp->Next;
        }

        if (pp == NULL ||
            pp->ProviderHandle == NULL) {
            //
            // Set Irp->IoStatus.Information large enough that err code
            // gets copied back to user buffer
            //
            DBGOUT((3, "VerifyProvider: dev offline, returning err"));

            Status = NDISTAPIERR_DEVICEOFFLINE;
            break;
        }

        *provider = pp;

    } while (FALSE);

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    return (Status);
}

NTSTATUS
DoGetProviderEventsWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    )
{
    KIRQL   oldIrql;
    ULONG   InfoSize;
    NTSTATUS    NtStatus;
    PNDISTAPI_EVENT_DATA    ndisTapiEventData;

    ndisTapiEventData = ioBuffer;
    NtStatus = STATUS_SUCCESS;
    InfoSize = 0;

    //
    // Sync event buf access by acquiring SpinLock
    //
    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    do {

        if ((inputBufferLength < sizeof (NDISTAPI_EVENT_DATA))  ||
            (outputBufferLength < sizeof(NDISTAPI_EVENT_DATA)) ||
            ((outputBufferLength - 
             FIELD_OFFSET(NDISTAPI_EVENT_DATA, Data[0])) <
             ndisTapiEventData->ulTotalSize)) {

            NtStatus = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        if (DeviceExtension->Status != NDISTAPI_STATUS_CONNECTED) {
            DBGOUT((3, "DoGetProviderEventsWork: Status!=NDIS_STATUS_CONNECTED!"));
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        if (DeviceExtension->EventsRequestIrp != NULL) {
#if DBG
            DbgPrint("NDISTAPI: Attempt to set duplicate EventIrp o:%p, d:%p\n",
                DeviceExtension->EventsRequestIrp, Irp);
#endif
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // Inspect DeviceExtension to see if there's any data available
        //
        if (DeviceExtension->EventCount == 0) {

            //
            // Hold the request pending.  It remains in the cancelable
            // state.  When new line event input is received
            // (NdisTapiIndicateStatus) or generated (i.e.
            // LINEDEVSTATE_REINIT) the data will get copied & the
            // request completed.
            //
            ASSERT(DeviceExtension->EventsRequestIrp == NULL);

            DeviceExtension->EventsRequestIrp = Irp;

            IoMarkIrpPending(Irp);
            Irp->IoStatus.Status = STATUS_PENDING;
            IoSetCancelRoutine (Irp, NdisTapiCancel);

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

            DBGOUT((3, "DoGetProviderEventsWork: Pending Irp=%p", Irp));

            return(STATUS_PENDING);
        }

        //
        // There's line event data queued in our ring buffer. Grab as
        // much as we can & complete the request.
        //
        ndisTapiEventData->ulUsedSize = 
            GetLineEvents(ndisTapiEventData->Data,
                          ndisTapiEventData->ulTotalSize);

        InfoSize = 
            ndisTapiEventData->ulUsedSize + sizeof(NDISTAPI_EVENT_DATA) - 1;

        DBGOUT((3, "GetLineEvents: SyncComplete Irp=%p", Irp));

    } while (FALSE);

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);
    Irp->IoStatus.Status = NtStatus;
    Irp->IoStatus.Information = InfoSize;

    return (NtStatus);
}

NTSTATUS
DoLineCreateWork(
    PIRP    Irp,
    PVOID   ioBuffer,
    ULONG   inputBufferLength,
    ULONG   outputBufferLength
    )
{
    KIRQL   oldIrql;
    ULONG   InfoSize;
    NTSTATUS    NtStatus;
    PPROVIDER_INFO  provider;
    PNDISTAPI_CREATE_INFO   CreateInfo;

    InfoSize = 0;
    NtStatus = STATUS_SUCCESS;

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

    do {

        if (inputBufferLength < sizeof(CreateInfo)) {
            DBGOUT ((3, "IOCTL_NDISTAPI_CREATE: buffer too small"));
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        if (DeviceExtension->Status != NDISTAPI_STATUS_CONNECTED) {
            DBGOUT((3, "IOCTL_NDISTAPI_CREATE: while unconnected, returning err"));
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        CreateInfo = (PNDISTAPI_CREATE_INFO)ioBuffer;

        provider = DeviceExtension->Providers;

        while (provider != NULL) {
            if (provider->TempID == CreateInfo->TempID) {
                break;
            }
            provider = provider->Next;
        }

        if (provider == NULL) {
            DBGOUT((0, "IOCTL_NDISTAPI_CREATE: Provider not found %x", 
                    CreateInfo->TempID));
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        if (provider->Status == PROVIDER_STATUS_OFFLINE) {
            DBGOUT((0,  "IOCTL_CREATE - Provider %p invalid state %x", 
                    provider, provider->Status));
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        DBGOUT((1, "IOCTL_NDISTAPI_CREATE: provider %p ID %d", 
                provider, CreateInfo->DeviceID));

        if (provider->CreateCount == 0) {
            NDIS_STATUS     ndisStatus;

            //
            // Set the base ID
            //
            provider->DeviceIDBase =
                CreateInfo->DeviceID;

            //
            // Init the provider
            //

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

            ndisStatus = SendProviderInitRequest (provider);

            if (ndisStatus == NDIS_STATUS_PENDING) {
                //
                // Wait for completion routine to get called
                //

                KeWaitForSingleObject (&provider->SyncEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       (PTIME) NULL);
            }

            KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);
        }

        ASSERT(CreateInfo->DeviceID ==
            (provider->DeviceIDBase + provider->CreateCount));

        provider->CreateCount++;

        ASSERT(provider->CreateCount <= provider->NumDevices);

        if (provider->CreateCount == provider->NumDevices) {

            //
            // We have finished all of the line_creates for this
            // provider so find the next provider that needs to be
            // kick started.
            //
            provider = provider->Next;

            while (provider != NULL) {

                if (provider->Status == 
                    PROVIDER_STATUS_PENDING_LINE_CREATE) {
                    break;
                }

                provider = provider->Next;
            }
        }

        if (provider != NULL) {

            NDIS_TAPI_EVENT NdisTapiEvent;

            //
            // Do a LINE_CREATE for all additional devices
            // on this provider
            //
            RtlZeroMemory(&NdisTapiEvent, sizeof(NDIS_TAPI_EVENT));

            provider->TempID = (ULONG_PTR)provider;

            DBGOUT((
                -1,
                "LINE_CREATE %d for provider %p",
                provider->CreateCount,
                provider->TempID
                ));

            NdisTapiEvent.ulMsg = LINE_CREATE;
            NdisTapiEvent.ulParam1 = 0;
            NdisTapiEvent.ulParam2 = provider->TempID;
            NdisTapiEvent.ulParam3 = 0;

            KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

            NdisTapiIndicateStatus((ULONG_PTR) provider,
                                   &NdisTapiEvent,
                                   sizeof (NDIS_TAPI_EVENT));

            KeAcquireSpinLock (&DeviceExtension->SpinLock, &oldIrql);

        } else {

            DeviceExtension->Flags &= ~PENDING_LINECREATE;
        }

        InfoSize = sizeof(NDISTAPI_CREATE_INFO);

    } while (FALSE);

    KeReleaseSpinLock (&DeviceExtension->SpinLock, oldIrql);

    Irp->IoStatus.Status = NtStatus;
    Irp->IoStatus.Information = InfoSize;

    return (NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\adapter.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Adapter.h

Abstract:

    This file contains major data structures used by the NdisWan driver

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#ifndef _NDISWAN_ADAPTER_
#define _NDISWAN_ADAPTER_

//
// This is the control block for the NdisWan adapter that is created by the NDIS Wrapper
// making a call to NdisWanInitialize.
//
typedef struct _MINIPORTCB {
    LIST_ENTRY              Linkage;            // Used to link adapter into global list
    ULONG                   RefCount;           // Adapter reference count
    NDIS_HANDLE             MiniportHandle;     // Assigned in MiniportInitialize
    LIST_ENTRY              AfSapCBList;
    ULONG                   AfRefCount;
    LIST_ENTRY              ProtocolCBList;
    ULONG                   Flags;              // Flags
#define RESET_IN_PROGRESS       0x00000001
#define ASK_FOR_RESET           0x00000002
#define RECEIVE_COMPLETE        0x00000004
#define HALT_IN_PROGRESS        0x00000008
#define PROTOCOL_KEEPS_STATS    0x00000010
    NDIS_MEDIUM             MediumType;             // Medium type that we are emulating
    NDIS_HARDWARE_STATUS    HardwareStatus;         // Hardware status (????)
    NDIS_STRING             AdapterName;            // Adapter Name (????)
    UCHAR                   NetworkAddress[ETH_LENGTH_OF_ADDRESS];  // Ethernet address for this adapter
    UCHAR                   Reserved1[2];
    ULONG                   NumberofProtocols;
    USHORT                  ProtocolType;
    USHORT                  Reserved2;
    struct _PROTOCOLCB      *NbfProtocolCB;
    WAN_EVENT               HaltEvent;              // Async notification event
    NDIS_SPIN_LOCK          Lock;               // Structure access lock
#if DBG
    LIST_ENTRY              SendPacketList;
    LIST_ENTRY              RecvPacketList;
#endif
} MINIPORTCB, *PMINIPORTCB;

//
// This is the open block for each WAN Miniport adapter that NdisWan binds to through
// the NDIS Wrapper as a "protocol".
//
typedef struct _OPENCB {
    LIST_ENTRY              Linkage;            // Used to link adapter into global list
    ULONG                   RefCount;
    ULONG                   Flags;
#define OPEN_LEGACY         0x00000001
#define OPEN_CLOSING        0x00000002
#define CLOSE_SCHEDULED     0x00000004
#define SEND_RESOURCES      0x00000008
#define OPEN_IN_BIND        0x00000010
    UINT                    ActiveLinkCount;
    NDIS_HANDLE             BindingHandle;      // Binding handle
    NDIS_STRING             MiniportName;       // WAN Miniport name
    GUID                    Guid;               // Parsed GUID of this miniport
    NDIS_HANDLE             UnbindContext;
    NDIS_MEDIUM             MediumType;         // WAN Miniport medium type
    NDIS_WAN_MEDIUM_SUBTYPE MediumSubType;      // WAN Miniport medium subtype
    NDIS_WAN_HEADER_FORMAT  WanHeaderFormat;    // WAN Miniport header type
    NDIS_WORK_ITEM          WorkItem;
    WAN_EVENT               NotificationEvent;  // Async notification event for adapter operations (open, close, ...)
    NDIS_STATUS             NotificationStatus; // Notification status for async adapter events
    NDIS_WAN_INFO           WanInfo;            // WanInfo structure
    LIST_ENTRY              WanRequestList;
    LIST_ENTRY              AfSapCBList;
    LIST_ENTRY              AfSapCBClosing;
    ULONG                   BufferSize;
    ULONG                   SendResources;
    union {
        NPAGED_LOOKASIDE_LIST   WanPacketPool;      // Used if no memory flags set

        struct {
            PUCHAR              PacketMemory;   // Used if memory flags set
            ULONG               PacketMemorySize;
            SLIST_HEADER        WanPacketList;
        };
    };
    ULONG                   AfRegisteringCount;
    WAN_EVENT               AfRegisteringEvent;
    WAN_EVENT               InitEvent;
    NDIS_SPIN_LOCK          Lock;               // Structure access lock
    HANDLE                  NdisTapiKey;
#if DBG
    LIST_ENTRY              SendPacketList;
#endif
} OPENCB, *POPENCB;

#define MINIPORTCB_SIZE sizeof(MINIPORTCB)
#define OPENCB_SIZE     sizeof(OPENCB)

//
// Main control block for all global data
//
typedef struct _NDISWANCB {
    NDIS_SPIN_LOCK      Lock;                       // Structure access lock
    ULONG               RefCount;
    NDIS_HANDLE         NdisWrapperHandle;          // NDIS Wrapper handle
    NDIS_HANDLE         MiniportDriverHandle;       // Handle for this miniport
    NDIS_HANDLE         ProtocolHandle;             // Our protocol handle
    ULONG               NumberOfProtocols;          // Total number of protocols that we are bound to
    ULONG               NumberOfLinks;              // Total number of links for all WAN Miniport Adapters
    PDRIVER_OBJECT      pDriverObject;              // Pointer to the NT Driver Object
    PDEVICE_OBJECT      pDeviceObject;              // Pointer to the device object
    NDIS_HANDLE         DeviceHandle;
    PDRIVER_UNLOAD      NdisUnloadHandler;
    PIRP                HibernateEventIrp;
    PMINIPORTCB         PromiscuousAdapter;

#ifdef MY_DEVICE_OBJECT
    PDRIVER_DISPATCH    MajorFunction[IRP_MJ_MAXIMUM_FUNCTION+1];   // Device dispatch functions
#endif

}NDISWANCB, *PNDISWANCB;

#endif  // _NDISWAN_ADAPTER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\debug.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    debug.h
    
Abstract:

    This file contains data structures and defs used by the
    NdisWan driver for debugging
    
Author:

    Tony Bell   (TonyBe) January 18, 1997

Environment:

    Kernel Mode

Revision History:

    TonyBe      01/18/97        Created

--*/

#ifndef _NDISWAN_DEBUG_
#define _NDISWAN_DEBUG_

//
// OS specific structures
//
#ifdef NT

#endif
//
// end of OS specific structures
//

//
// Debugging
//
#define DBG_DEATH               1
#define DBG_CRITICAL_ERROR      2
#define DBG_FAILURE             4
#define DBG_INFO                6
#define DBG_TRACE               8
#define DBG_VERBOSE             10

#define DBG_INIT                0x00000001
#define DBG_MINIPORT            0x00000002
#define DBG_PROTOCOL            0x00000004
#define DBG_SEND                0x00000008
#define DBG_RECEIVE             0x00000010
#define DBG_IO                  0x00000020
#define DBG_MEMORY              0x00000040
#define DBG_VJ                  0x00000080
#define DBG_TAPI                0x00000100
#define DBG_CCP                 0x00000200
#define DBG_LOOPBACK            0x00000400
#define DBG_MULTILINK_RECV      0x00000800
#define DBG_MULTILINK_SEND      0x00001000
#define DBG_SEND_VJ             0x00002000
#define DBG_RECV_VJ             0x00004000
#define DBG_CL                  0x00008000
#define DBG_CM                  0x00010000
#define DBG_INDICATE            0x00020000
#define DBG_BACP                0x00040000
#define DBG_REQUEST             0x00080000
#define DBG_ALL                 0xFFFFFFFF

#define INIT_FILESIG            'tini'
#define MINIPORT_FILESIG        'inim'
#define PROTOCOL_FILESIG        'torp'
#define SEND_FILESIG            'dnes'
#define RECEIVE_FILESIG         'vcer'
#define IO_FILESIG              '  oi'
#define MEMORY_FILESIG          ' mem'
#define CCP_FILESIG             ' pcc'
#define CL_FILESIG              '  lc'
#define CM_FILESIG              '  mc'
#define INDICATE_FILESIG        'idni'
#define REQUEST_FILESIG         ' qer'
#define VJ_FILESIG              '  jv'
#define TAPI_FILESIG            'ipat'
#define LOOPBACK_FILESIG        'pool'
#define COMPRESS_FILESIG        'pmoc'
#define UTIL_FILESIG            'litu'

#define MAX_BYTE_DEPTH          2048

#if DBG

typedef struct _DBG_PACKET {
    LIST_ENTRY          Linkage;
    PVOID               Packet;
    ULONG               PacketType;
    struct _BUNDLECB    *BundleCB;
    ULONG               BundleState;
    ULONG               BundleFlags;
    struct _PROTOCOLCB  *ProtocolCB;
    ULONG               ProtocolState;
    struct _LINKCB      *LinkCB;
    ULONG               LinkState;
    ULONG               SendCount;
} DBG_PACKET, *PDBG_PACKET;

typedef enum DbgPktType {
    PacketTypeWan = 1,
    PacketTypeNdis
}DbgPktType;

typedef struct _DBG_PKT_CONTEXT {
    struct _BUNDLECB    *BundleCB;
    struct _PROTOCOLCB  *ProtocolCB;
    struct _LINKCB      *LinkCB;
    PVOID               Packet;
    DbgPktType          PacketType;
    PLIST_ENTRY         ListHead;
    PNDIS_SPIN_LOCK     ListLock;
} DBG_PKT_CONTEXT, *PDBG_PKT_CONTEXT;

typedef enum TRC_EVENT_TYPE {
    TrcEventSend = 1,
    TrcEventRecv
}TRC_EVENT_TYPE;

typedef struct _WAN_TRC_EVENT {
    LIST_ENTRY      Linkage;
    TRC_EVENT_TYPE  TrcType;
    WAN_TIME        TrcTimeStamp;
    ULONG           TrcInfoLength;
    PUCHAR          TrcInfo;
} WAN_TRC_EVENT, *PWAN_TRC_EVENT;

typedef enum SEND_TRC_TYPE {
    ProtocolQueue = 1,
    ProtocolSend,
    ProtocolSendComlete,
    FragmentSend,
    LinkSend,
    LinkSendComplete
} SEND_TRC_TYPE;

typedef struct _SEND_TRC_INFO {
    SEND_TRC_TYPE   SendTrcType;
    PNDIS_PACKET    NdisPacket;
    NDIS_HANDLE     BundleHandle;
    NDIS_HANDLE     ProtocolHandle;
    NDIS_HANDLE     LinkHandle;
    ULONG           SequenceNum;
} SEND_TRC_INFO, *PSEND_TRC_INFO;

#define NdisWanDbgOut(_DebugLevel, _DebugMask, _Out) {  \
    if ((glDebugLevel >= _DebugLevel) &&                \
        (_DebugMask & glDebugMask)) {                   \
        DbgPrint("NDISWAN: ");                          \
        DbgPrint _Out;                                  \
        DbgPrint("\n");                                 \
    }                                                   \
}

#undef ASSERT
#define ASSERT(exp) \
{                   \
    if (!(exp)) {   \
        DbgPrint("NDISWAN: ASSERTION FAILED! %s\n", #exp); \
        DbgPrint("NDISWAN: File: %s, Line: %d\n", __FILE__, __LINE__); \
        DbgBreakPoint(); \
    }               \
}

VOID
InsertDbgPacket(
    PDBG_PKT_CONTEXT    DbgContext
    );

BOOLEAN
RemoveDbgPacket(
    PDBG_PKT_CONTEXT    DbgContext
    );
    
#define INSERT_DBG_SEND(_pt, _ctxcb, _ppcb, _plcb, _p)      \
{                                                           \
    DBG_PKT_CONTEXT DbgContext;                             \
    DbgContext.Packet = (_p);                               \
    DbgContext.BundleCB = (_ppcb)->BundleCB;                \
    DbgContext.ProtocolCB = (_ppcb);                        \
    DbgContext.LinkCB = (_plcb);                            \
    if (_ctxcb != NULL) {                                   \
        DbgContext.PacketType = _pt;                        \
        DbgContext.ListHead = &(_ctxcb)->SendPacketList;    \
        DbgContext.ListLock = &(_ctxcb)->Lock;              \
        InsertDbgPacket(&DbgContext);                       \
    }                                                       \
}

#define REMOVE_DBG_SEND(_pt, _ctxcb, _p)                    \
{                                                           \
    DBG_PKT_CONTEXT DbgContext;                             \
    DbgContext.Packet = (_p);                               \
    if (_ctxcb != NULL) {                                   \
        DbgContext.PacketType = _pt;                        \
        DbgContext.ListHead = &(_ctxcb)->SendPacketList;    \
        DbgContext.ListLock = &(_ctxcb)->Lock;              \
        RemoveDbgPacket(&DbgContext);                       \
    }                                                       \
}

#define INSERT_DBG_RECV(_pt, _ctxcb, _ppcb, _plcb, _p)      \
{                                                           \
    DBG_PKT_CONTEXT DbgContext;                             \
    DbgContext.Packet = (_p);                               \
    DbgContext.BundleCB = NULL;                             \
    DbgContext.ProtocolCB = (_ppcb);                        \
    DbgContext.LinkCB = (_plcb);                            \
    if (_ctxcb != NULL) {                                   \
        DbgContext.PacketType = _pt;                        \
        DbgContext.ListHead = &(_ctxcb)->RecvPacketList;    \
        DbgContext.ListLock = &(_ctxcb)->Lock;              \
        InsertDbgPacket(&DbgContext);                       \
    }                                                       \
}

#define REMOVE_DBG_RECV(_pt, _ctxcb, _p)                    \
{                                                           \
    DBG_PKT_CONTEXT DbgContext;                             \
    DbgContext.Packet = (_p);                               \
    if (_ctxcb != NULL) {                                   \
        DbgContext.PacketType = _pt;                        \
        DbgContext.ListHead = &(_ctxcb)->RecvPacketList;    \
        DbgContext.ListLock = &(_ctxcb)->Lock;              \
        RemoveDbgPacket(&DbgContext);                       \
    }                                                       \
}

#define INSERT_RECV_EVENT(_c)                               \
{                                                           \
    reA[reI] = _c;                                          \
    LastIrpAction = _c;                                     \
    if (++reI >= 1024) {                                    \
        reI = 0;                                            \
    }                                                       \
}

#else   // If not built with debug

#define NdisWanDbgOut(_DebugLevel, _DebugMask, _Out)
#define INSERT_DBG_SEND(_pt, _ctxcb, _ppcb, _plcb, _p)
#define REMOVE_DBG_SEND(_pt, _ctxcb, _p)
#define INSERT_DBG_RECV(_pt, _ctxcb, _ppcb, _plcb, _p)
#define REMOVE_DBG_RECV(_pt, _ctxcb, _p)

#define INSERT_RECV_EVENT(_c)

#endif // end of !DBG

#endif // end of _NDISWAN_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\cm.c ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    cm.c

Abstract:

    This file contains the functions that implement the ndiswan
    NDIS 5.0 call manager interface.  These functions are used by the
    ndiswan miniport and NDIS 5.0 clients.

Author:

    Tony Bell   (TonyBe) January 9, 1997

Environment:

    Kernel Mode

Revision History:

    TonyBe      01/09/97        Created

--*/

#include "wan.h"
#include "traffic.h"
#include "ntddtc.h"

#define __FILE_SIG__    CM_FILESIG

NDIS_STATUS
CmCreateVc(
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     NdisVcHandle,
    OUT PNDIS_HANDLE    ProtocolVcContext
    )
{
    PCM_AFSAPCB AfSapCB = (PCM_AFSAPCB)ProtocolAfContext;
    PCM_VCCB    CmVcCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmCreateVc: Enter"));

    CmVcCB =
        NdisWanAllocateCmVcCB(AfSapCB, NdisVcHandle);

    if (CmVcCB == NULL) {
        return (NDIS_STATUS_RESOURCES);
    }

    *ProtocolVcContext = CmVcCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmCreateVc: Exit"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
CmDeleteVc(
    IN  NDIS_HANDLE     ProtocolVcContext
    )
{
    PCM_VCCB    CmVcCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmDeleteVc: Enter"));

    CmVcCB = (PCM_VCCB)ProtocolVcContext;

    ASSERT(CmVcCB->RefCount == 0);

    NdisWanFreeCmVcCB(CmVcCB);

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmDeleteVc: Exit"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
CmOpenAf(
    IN  NDIS_HANDLE             CallMgrBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             NdisAfHandle,
    OUT PNDIS_HANDLE            CallMgrAfContext
    )
{
    PMINIPORTCB MiniportCB = (PMINIPORTCB)CallMgrBindingContext;
    PCM_AFSAPCB AfSapCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmOpenAf: Enter"));

    if (AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_PPP) {
        return (NDIS_STATUS_FAILURE);
    }

    AfSapCB =
        NdisWanAllocateCmAfSapCB(MiniportCB);

    if (AfSapCB == NULL) {
        return (NDIS_STATUS_RESOURCES);
    }

    *CallMgrAfContext = (NDIS_HANDLE)AfSapCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmOpenAf: Exit"));

    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
CmCloseAf(
    IN  NDIS_HANDLE     CallMgrAfContext
    )
{
    PCM_AFSAPCB AfSapCB = (PCM_AFSAPCB)CallMgrAfContext;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmCloseAf: Enter"));

    NdisWanFreeCmAfSapCB(AfSapCB);

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmCloseAf: Exit"));

    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
CmRegisterSap(
    IN  NDIS_HANDLE             CallMgrAfContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    )
{
    PMINIPORTCB MiniportCB = (PMINIPORTCB)CallMgrAfContext;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmRegisterSap: Enter SapType %d", Sap->SapType));

    *CallMgrSapContext = CallMgrAfContext;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmRegisterSap: Exit"));

    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
CmDeregisterSap(
    IN  NDIS_HANDLE             CallMgrSapContext
    )
{
    PCM_AFSAPCB AfSapCB = (PCM_AFSAPCB)CallMgrSapContext;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmDeregisterSap: Enter"));


    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmDeregisterSap: Exit"));
    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
CmMakeCall(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    OUT PNDIS_HANDLE            CallMgrPartyContext OPTIONAL
    )
{
    PBUNDLECB   BundleCB;
    PPROTOCOLCB ProtocolCB;
    PCM_VCCB    CmVcCB;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParams;
    PCO_MEDIA_PARAMETERS    MediaParams;
    PCO_SPECIFIC_PARAMETERS SpecificParams;
    LPQOS_WAN_MEDIA QosMedia;
    LPQOS_OBJECT_HDR QoSObject;
    LONG    ParamsLength;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmMakeCall: Enter"));

    CmVcCB = (PCM_VCCB)CallMgrVcContext;

    CallMgrParams =
        CallParameters->CallMgrParameters;

    MediaParams =
        CallParameters->MediaParameters;

    SpecificParams = &MediaParams->MediaSpecific;

    if (SpecificParams->ParamType != PARAM_TYPE_GQOS_INFO) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_CM,
        ("CmMakeCall: Not a QOS Vc! ParamType %x", SpecificParams->ParamType));
        return (NDIS_STATUS_FAILURE);
    }

    QosMedia = (LPQOS_WAN_MEDIA)SpecificParams->Parameters;

    //
    // Need to check the flowspec for bandwidth
    //

    do {
        ULONG_PTR   BIndex, PIndex;

        //
        // Get the protocolcb
        //
        GetNdisWanIndices(QosMedia->LinkId, BIndex, PIndex);

        if (!IsBundleValid((NDIS_HANDLE)BIndex, 
                           TRUE, 
                           &BundleCB)) {

            Status = NDIS_STATUS_FAILURE;
            break;
        }

        AcquireBundleLock(BundleCB);

        PROTOCOLCB_FROM_PROTOCOLH(BundleCB, ProtocolCB, PIndex);

        if (ProtocolCB == NULL ||
            ProtocolCB == (PVOID)RESERVED_PROTOCOLCB ||
            ProtocolCB->State != PROTOCOL_ROUTED) {
            ReleaseBundleLock(BundleCB);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // If we don't have multilink or if we have encryption then we can not
        // do isslow
        //
        if (!(BundleCB->FramingInfo.SendFramingBits & PPP_MULTILINK_FRAMING) || 
            (BundleCB->SendFlags & DO_ENCRYPTION)) {
            CmVcCB->FlowClass = 0;
        } else {

            if (QosMedia->ISSLOW == 1) {
                CmVcCB->FlowClass = MAX_MCML;
                BundleCB->Flags |= QOS_ENABLED;
            } else {
                CmVcCB->FlowClass = 0;
            }
        }


#ifdef USE_QOS_WORKER
        NdisInitializeWorkItem(&BundleCB->QoSWorkItem,
                               QoSSendFragments,
                               BundleCB);
#endif

        SetBundleFlags(BundleCB);

        NdisWanDbgOut(DBG_INFO, DBG_CM, ("MakeCall Vc/Protocol %p/%p %d/%d",
            CmVcCB, ProtocolCB, CmVcCB->State, ProtocolCB->State));

        NdisWanDbgOut(DBG_INFO, DBG_CM, ("Setting FlowClass %x Isslow %d",
            CmVcCB->FlowClass, QosMedia->ISSLOW));

        REF_CMVCCB(CmVcCB);

        CmVcCB->ProtocolCB = ProtocolCB;

        InsertTailList(&ProtocolCB->VcList, &CmVcCB->Linkage);

        REF_PROTOCOLCB(ProtocolCB);

        ReleaseBundleLock(BundleCB);

        InterlockedExchange((PLONG)&CmVcCB->State, CMVC_ACTIVE);

        NdisMCmActivateVc(CmVcCB->NdisVcHandle, CallParameters);

    } while (FALSE);

    //
    // Deref for ref applied in IsBundleValid
    //
    DEREF_BUNDLECB(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmMakeCall: Exit"));

    return(Status);
}

NDIS_STATUS
CmCloseCall(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
    IN  PVOID                   CloseData           OPTIONAL,
    IN  UINT                    Size                OPTIONAL
    )
{
    PPROTOCOLCB ProtocolCB;
    PBUNDLECB   BundleCB;
    PCM_VCCB    CmVcCB;
    BOOLEAN     DisableQoS = TRUE;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmCloseCall: Enter"));

    CmVcCB = (PCM_VCCB)CallMgrVcContext;

    ProtocolCB =
        CmVcCB->ProtocolCB;

    BundleCB =
        ProtocolCB->BundleCB;

    AcquireBundleLock(BundleCB);

    if (CmVcCB->State != CMVC_CLOSE_DISPATCHED) {
        RemoveEntryList(&CmVcCB->Linkage);
    }

    //
    // Walk the Vc list and see if there are any
    // ISSLOW Vc's.  If there are not then disable QOS
    //
    {
        PCM_VCCB    _vc;

        _vc = (PCM_VCCB)ProtocolCB->VcList.Flink;

        while ((PVOID)_vc != (PVOID)&ProtocolCB->VcList) {
            if (_vc->FlowClass == MAX_MCML) {
                DisableQoS = FALSE;
                break;
            }
            _vc = (PCM_VCCB)_vc->Linkage.Flink;
        }
    }

    NdisWanDbgOut(DBG_INFO, DBG_CM, ("CloseCall Vc/Protocol %p/%p %d/%d",
        CmVcCB, ProtocolCB, CmVcCB->State, ProtocolCB->State));

    InterlockedExchange((PLONG)&CmVcCB->State, CMVC_CLOSING);

    DEREF_CMVCCB(CmVcCB);

    DEREF_PROTOCOLCB(ProtocolCB);

    if (DisableQoS && BundleCB != NULL) {

        BundleCB->Flags &= ~QOS_ENABLED;
    }

    ReleaseBundleLock(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmCloseCall: Exit"));

    return(NDIS_STATUS_PENDING);
}

NDIS_STATUS
CmModifyCallQoS(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    PCM_VCCB    CmVcCB;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParams;
    PCO_MEDIA_PARAMETERS    MediaParams;
    PCO_SPECIFIC_PARAMETERS SpecificParams;
    LPQOS_WAN_MEDIA QosMedia;
    LPQOS_OBJECT_HDR QoSObject;
    PBUNDLECB   BundleCB;
    PPROTOCOLCB ProtocolCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmModifyCallQos: Enter"));

    CmVcCB = (PCM_VCCB)CallMgrVcContext;

    CallMgrParams =
        CallParameters->CallMgrParameters;

    MediaParams =
        CallParameters->MediaParameters;

    SpecificParams = &MediaParams->MediaSpecific;

    if (SpecificParams->ParamType != PARAM_TYPE_GQOS_INFO) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_CM,
        ("CmMakeCall: Not a QOS Vc! ParamType %x", SpecificParams->ParamType));
        return (NDIS_STATUS_SUCCESS);
    }

    QosMedia = (LPQOS_WAN_MEDIA)SpecificParams->Parameters;

    ProtocolCB = CmVcCB->ProtocolCB;

    if (ProtocolCB == NULL) {
        return (NDIS_STATUS_SUCCESS);
    }

    BundleCB = ProtocolCB->BundleCB;

    if (BundleCB == NULL) {
        return (NDIS_STATUS_SUCCESS);
    }

    AcquireBundleLock(BundleCB);

    //
    // If we don't have multilink or if we have encryption then we can not
    // do isslow
    //
    if (!(BundleCB->FramingInfo.SendFramingBits & PPP_MULTILINK_FRAMING) || 
        (BundleCB->SendFlags & DO_ENCRYPTION)) 
    {
        CmVcCB->FlowClass = 0;
    } else {

        if (QosMedia->ISSLOW == 1) {
            CmVcCB->FlowClass = MAX_MCML;
            BundleCB->Flags |= QOS_ENABLED;
        } else {
            CmVcCB->FlowClass = 0;
            
            // Walk the Vc list and see if there are any
            // ISSLOW Vc's.  If there are not then disable QOS
            {
                PCM_VCCB    _vc;
                BOOLEAN     DisableQoS = TRUE;
        
                _vc = (PCM_VCCB)ProtocolCB->VcList.Flink;
        
                while ((PVOID)_vc != (PVOID)&ProtocolCB->VcList) {
                    if (_vc->FlowClass == MAX_MCML) {
                        DisableQoS = FALSE;
                        break;
                    }
                    _vc = (PCM_VCCB)_vc->Linkage.Flink;
                }
                
                if (DisableQoS) {
                    BundleCB->Flags &= ~QOS_ENABLED;
                }
            }
        }
    }
                              
    SetBundleFlags(BundleCB);

    ReleaseBundleLock(BundleCB);

    NdisWanDbgOut(DBG_DEATH, DBG_CM, ("Updating FlowClass %x for Vc/Protocol %p/%p, Isslow %d",
        CmVcCB->FlowClass, CmVcCB, CmVcCB->ProtocolCB, QosMedia->ISSLOW));

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmModifyCallQos: Exit"));
    return(NDIS_STATUS_SUCCESS);
}

VOID
CmIncomingCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmIncomingCallComplete: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmIncomingCallComplete: Exit"));
}

VOID
CmActivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmActivateVcComplete: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmActivateVcComplete: Exit"));
}

VOID
CmDeactivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmDeactivateVcComplete: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmDeactivateVcComplete: Exit"));
}

NDIS_STATUS
CmRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    )
{
    NDIS_STATUS Status;
    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmRequest: Enter"));

    Status =
    NdisWanCoOidProc((PMINIPORTCB)ProtocolAfContext,
                     (PCM_VCCB)ProtocolVcContext,
                     NdisRequest);

    NdisWanDbgOut(DBG_TRACE, DBG_CM, ("CmRequest: Exit Status: 0x%x", Status));
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\cl.c ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    cl.c

Abstract:

    This file contains the functions that implement the ndiswan
    NDIS 5.0 client interface.  These functions are used to interface
    with NDIS 5.0 miniports/call managers.

Author:

    Tony Bell   (TonyBe) January 9, 1997

Environment:

    Kernel Mode

Revision History:

    TonyBe      01/09/97        Created

--*/

//
// We want to initialize all of the global variables now!
//
#include "wan.h"
#include "atm.h"

#define __FILE_SIG__    CL_FILESIG

NDIS_STATUS
ClCreateVc(
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     NdisVcHandle,
    OUT PNDIS_HANDLE    ProtocolVcContext
    )
{
    PCL_AFSAPCB AfSapCB = (PCL_AFSAPCB)ProtocolAfContext;
    POPENCB     OpenCB = AfSapCB->OpenCB;
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCreateVc: Enter"));

    //
    // Get a linkcb
    //
    LinkCB = NdisWanAllocateLinkCB(OpenCB, 0);

    if (LinkCB == NULL) {

        //
        // Error getting LinkCB!
        //

        return (NDIS_STATUS_RESOURCES);
        
    }

    LinkCB->NdisLinkHandle = NdisVcHandle;
    LinkCB->ConnectionWrapperID = NdisVcHandle;
    LinkCB->AfSapCB = AfSapCB;

    //
    // Set some default values
    //
    LinkCB->RFlowSpec.PeakBandwidth =
    LinkCB->SFlowSpec.PeakBandwidth = 28800 / 8;

    LinkCB->SendWindow = OpenCB->WanInfo.MaxTransmit;

    //
    // Get a bundlecb
    //
    BundleCB = NdisWanAllocateBundleCB();

    if (BundleCB == NULL) {
        NdisWanFreeLinkCB(LinkCB);

        //
        // Error getting BundleCB!
        //
        return (NDIS_STATUS_RESOURCES);
    }

    //
    // Add LinkCB to BundleCB
    //
    AcquireBundleLock(BundleCB);

    AddLinkToBundle(BundleCB, LinkCB);

    ReleaseBundleLock(BundleCB);

    //
    // Place BundleCB in active connection table
    //
    if (NULL == InsertBundleInConnectionTable(BundleCB)) {
        //
        // Error inserting link in ConnectionTable
        //
        RemoveLinkFromBundle(BundleCB, LinkCB, FALSE);
        NdisWanFreeLinkCB(LinkCB);

        return (NDIS_STATUS_RESOURCES);
    }

    //
    // Place LinkCB in active connection table
    //
    if (NULL == InsertLinkInConnectionTable(LinkCB)) {
        //
        // Error inserting bundle in connectiontable
        //
        RemoveLinkFromBundle(BundleCB, LinkCB, FALSE);
        NdisWanFreeLinkCB(LinkCB);

        return (NDIS_STATUS_RESOURCES);
    }

    *ProtocolVcContext = LinkCB->hLinkHandle;

    NdisAcquireSpinLock(&AfSapCB->Lock);
    REF_CLAFSAPCB(AfSapCB);
    NdisReleaseSpinLock(&AfSapCB->Lock);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCreateVc: Exit"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
ClDeleteVc(
    IN  NDIS_HANDLE     ProtocolVcContext
    )
{
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;
    PCL_AFSAPCB AfSapCB;

    if (!IsLinkValid(ProtocolVcContext, FALSE, &LinkCB)) {

        NdisWanDbgOut(DBG_FAILURE, DBG_CL,
            ("NDISWAN: Possible double delete of VcContext %x\n",
            ProtocolVcContext));

        return (NDIS_STATUS_FAILURE);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClDeleteVc: Enter %p", LinkCB));

    NdisAcquireSpinLock(&LinkCB->Lock);

    AfSapCB = LinkCB->AfSapCB;

    //
    // For the ref applied in IsLinkValid.  We
    // don't have to use the full deref code here as we know the ref
    // applied at CreateVc will keep the link around.
    //
    LinkCB->RefCount--;

    //
    // For the createvc reference
    //
    DEREF_LINKCB_LOCKED(LinkCB);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClDeleteVc: Exit"));

    DEREF_CLAFSAPCB(AfSapCB);

    return(NDIS_STATUS_SUCCESS);
}

VOID
ClOpenAfComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     NdisAfHandle
    )
{
    PCL_AFSAPCB     AfSapCB = (PCL_AFSAPCB)ProtocolAfContext;
    POPENCB         OpenCB = AfSapCB->OpenCB;
    PCO_SAP         Sap;
    NDIS_HANDLE     SapHandle;
    UCHAR           SapBuffer[CLSAP_BUFFERSIZE];

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClOpenAfComplete: Enter %p %x", AfSapCB, Status));

    NdisAcquireSpinLock(&AfSapCB->Lock);

    AfSapCB->Flags &= ~(AF_OPENING);

    if (Status == NDIS_STATUS_SUCCESS) {

        AfSapCB->Flags |= 
            (AF_OPENED | SAP_REGISTERING);
        AfSapCB->AfHandle = NdisAfHandle;

        NdisReleaseSpinLock(&AfSapCB->Lock);

        //
        // If we successfully opened the AddressFamily we
        // need to register our SAP.
        //
        NdisAcquireSpinLock(&OpenCB->Lock);

        InsertHeadList(&OpenCB->AfSapCBList,
                       &AfSapCB->Linkage);

        NdisReleaseSpinLock(&OpenCB->Lock);

        Sap = (PCO_SAP)SapBuffer;
        //
        // Register our SAP
        //
        Sap->SapType = SAP_TYPE_NDISWAN_PPP;
        Sap->SapLength = sizeof(DEVICECLASS_NDISWAN_SAP);
        NdisMoveMemory(Sap->Sap,
            DEVICECLASS_NDISWAN_SAP,
            sizeof(DEVICECLASS_NDISWAN_SAP));

        Status =
        NdisClRegisterSap(AfSapCB->AfHandle,
                          AfSapCB,
                          Sap,
                          &SapHandle);

        if (Status != NDIS_STATUS_PENDING) {
            ClRegisterSapComplete(Status, AfSapCB, Sap, SapHandle);
        }

        NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
        ("ClRegisterSap SapHandle 0x%x status: 0x%x", SapHandle, Status));

    } else {

        AfSapCB->Flags |= AF_OPEN_FAILED;

        NdisReleaseSpinLock(&AfSapCB->Lock);
                   
        //
        // We failed to register the address family so free
        // associated memory.
        //
        NdisWanFreeClAfSapCB(AfSapCB);

        //
        // Since the open af was initiated from the notification
        // of a new af from ndis we have to decrement the af
        // registering count.
        //
        NdisAcquireSpinLock(&OpenCB->Lock);
        if (--OpenCB->AfRegisteringCount == 0) {
            NdisWanSetNotificationEvent(&OpenCB->AfRegisteringEvent);
        }
        NdisReleaseSpinLock(&OpenCB->Lock);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClOpenAfComplete: Exit"));
}

VOID
ClCloseAfComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolAfContext
    )
{
    PCL_AFSAPCB     AfSapCB = (PCL_AFSAPCB)ProtocolAfContext;
    POPENCB         OpenCB = AfSapCB->OpenCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCloseAfComplete: Enter %p %x", AfSapCB, Status));

    //
    // BUG 494260
    //  NDIS should not be invoking this deregister handler at a raised
    //  IRQL (i.e while holding a spinlock).  Bug 494260 documents this
    //  this issue.
    //  
    //  This assert has been commented out to prevent breaks on checked build.
    //  When 494260 is fixed, this ASSERT should be uncommented.
    //
    
    // ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    do {

        //
        // If the close attempt failed there must be another
        // thread that is already doing the close.  Let the
        // other thread cleanup the afsapcb.
        //
        if (Status != NDIS_STATUS_SUCCESS) {
            break;
        }

        NdisAcquireSpinLock(&AfSapCB->Lock);
        AfSapCB->Flags &= ~(AF_CLOSING);
        AfSapCB->Flags |= (AF_CLOSED);
        NdisReleaseSpinLock(&AfSapCB->Lock);

        NdisAcquireSpinLock(&OpenCB->Lock);

        RemoveEntryList(&AfSapCB->Linkage);

        NdisReleaseSpinLock(&OpenCB->Lock);

        NdisWanFreeClAfSapCB(AfSapCB);

    } while (FALSE);

    //
    // Refer comment above
    //
       
    // ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCloseAfComplete: Exit"));
}

VOID
ClRegisterSapComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolSapContext,
    IN  PCO_SAP         Sap,
    IN  NDIS_HANDLE     NdisSapHandle
    )
{
    PCL_AFSAPCB     AfSapCB = (PCL_AFSAPCB)ProtocolSapContext;
    POPENCB         OpenCB = AfSapCB->OpenCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClRegisterSapComplete: Enter %p %x", AfSapCB, Status));

    NdisAcquireSpinLock(&AfSapCB->Lock);
    AfSapCB->Flags &= ~(SAP_REGISTERING);

    if (Status == NDIS_STATUS_SUCCESS) {


        AfSapCB->Flags |= SAP_REGISTERED;
        AfSapCB->SapHandle = NdisSapHandle;

        NdisReleaseSpinLock(&AfSapCB->Lock);

    } else {

        //
        // We failed to register our sap so close the address family
        //
        AfSapCB->Flags &= ~(AF_OPENED);
        AfSapCB->Flags |= 
            (SAP_REGISTER_FAILED | AF_CLOSING);

        NdisReleaseSpinLock(&AfSapCB->Lock);

        NdisAcquireSpinLock(&OpenCB->Lock);

        RemoveEntryList(&AfSapCB->Linkage);

        InsertTailList(&OpenCB->AfSapCBClosing, &AfSapCB->Linkage);

        NdisReleaseSpinLock(&OpenCB->Lock);

        NdisClCloseAddressFamily(AfSapCB->AfHandle);

        if (Status != NDIS_STATUS_PENDING) {
            ClCloseAfComplete(Status, AfSapCB);
        }
    }

    //
    // Since the open af was initiated from the notification
    // of a new af from ndis we have to decrement the af
    // registering count.
    //
    NdisAcquireSpinLock(&OpenCB->Lock);
    if (--OpenCB->AfRegisteringCount == 0) {
        NdisWanSetNotificationEvent(&OpenCB->AfRegisteringEvent);
    }
    NdisReleaseSpinLock(&OpenCB->Lock);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClRegisterSapComplete: Exit"));
}

VOID
ClDeregisterSapComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolSapContext
    )
{
    PCL_AFSAPCB     AfSapCB = (PCL_AFSAPCB)ProtocolSapContext;
    POPENCB         OpenCB = AfSapCB->OpenCB;

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClDeregisterSapComplete: Enter %p %x", AfSapCB, Status));
    
    //
    // BUG 494260
    //  NDIS should not be invoking this deregister handler at a raised
    //  IRQL (i.e while holding a spinlock).  Bug 494260 documents this
    //  this issue.
    //  
    //  This assert has been commented out to prevent breaks on checked build.
    //  When 494260 is fixed, this ASSERT should be uncommented.
    //

    // ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    NdisAcquireSpinLock(&AfSapCB->Lock);

    ASSERT(AfSapCB->Flags & AF_OPENED);

    AfSapCB->Flags &= ~(AF_OPENED | SAP_DEREGISTERING);
    AfSapCB->Flags |= (AF_CLOSING);

    NdisReleaseSpinLock(&AfSapCB->Lock);

    Status =
        NdisClCloseAddressFamily(AfSapCB->AfHandle);

    if (Status != NDIS_STATUS_PENDING) {
        ClCloseAfComplete(Status, AfSapCB);
    }

    //
    // Refer comment above
    //
       
    // ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClDeregisterSapComplete: Exit"));
}

VOID
ClMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClMakeCallComplete: Enter %p %x", ProtocolVcContext, Status));

    DbgBreakPoint();

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClMakeCallComplete: Exit"));
}

VOID
ClModifyQoSComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClModifyQoSComplete: Enter %p %x", ProtocolVcContext, Status));

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClModifyQoSComplete: Exit"));
}

VOID
ClCloseCallComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  NDIS_HANDLE     ProtocolPartyContext OPTIONAL
    )
{

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCloseCallComplete: Enter %p %x", ProtocolVcContext, Status));

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCloseCallComplete: Exit"));

}

NDIS_STATUS
ClIncomingCall(
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    )
{
    PCL_AFSAPCB     AfSapCB = (PCL_AFSAPCB)ProtocolSapContext;
    PLINKCB         LinkCB;
    POPENCB         OpenCB = AfSapCB->OpenCB;
    PBUNDLECB       BundleCB;
    BOOLEAN         AtmUseLLC = FALSE;
    BOOLEAN         MediaBroadband = FALSE;
    PWAN_LINK_INFO  LinkInfo;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClIncomingCall: Enter %p %p", AfSapCB, ProtocolVcContext));

    do {

        if (!AreLinkAndBundleValid(ProtocolVcContext, 
                                   TRUE,
                                   &LinkCB, 
                                   &BundleCB)) {

            Status = NDIS_STATUS_FAILURE;
            break;
        }

        NdisAcquireSpinLock(&LinkCB->Lock);

        LinkCB->ClCallState = CL_CALL_CONNECTED;

        NdisReleaseSpinLock(&LinkCB->Lock);

        AcquireBundleLock(BundleCB);

        NdisMoveMemory(&LinkCB->SFlowSpec,
                       &CallParameters->CallMgrParameters->Transmit,
                       sizeof(FLOWSPEC));

        NdisMoveMemory(&LinkCB->RFlowSpec,
                       &CallParameters->CallMgrParameters->Receive,
                       sizeof(FLOWSPEC));

        if (LinkCB->SFlowSpec.PeakBandwidth == 0) {
            LinkCB->SFlowSpec.PeakBandwidth = 28800 / 8;
        }

        if (LinkCB->RFlowSpec.PeakBandwidth == 0) {
            LinkCB->RFlowSpec.PeakBandwidth = LinkCB->SFlowSpec.PeakBandwidth;
        }

        LinkInfo = &LinkCB->LinkInfo;

        //
        // Assume all CoNDIS miniports support PPP framing
        //
        LinkInfo->SendFramingBits =
        LinkInfo->RecvFramingBits = PPP_FRAMING;

        LinkCB->RecvHandler = ReceivePPP;

        if (OpenCB->MediumType == NdisMediumAtm ||

            (OpenCB->MediumType == NdisMediumWan &&
            (OpenCB->MediumSubType == NdisWanMediumAtm ||
             OpenCB->MediumSubType == NdisWanMediumPppoe)) ||

            (OpenCB->MediumType == NdisMediumCoWan &&
            (OpenCB->MediumSubType == NdisWanMediumAtm ||
             OpenCB->MediumSubType == NdisWanMediumPppoe))) {

            MediaBroadband = TRUE;

            LinkCB->RecvHandler = DetectBroadbandFraming;
        }

        if (MediaBroadband) {

            if (CallParameters->Flags & PERMANENT_VC) {

                //
                // Per TomF we are going to use NULL encap as
                // our default PVC encapsulation
                //
                if (gbAtmUseLLCOnPVC) {
                    AtmUseLLC = TRUE;

                }

            } else {
                //
                // If this is an ATM SVC we need to see
                // if the SVC needs LLC framing or not
                //
                if (gbAtmUseLLCOnSVC) {
                    AtmUseLLC = TRUE;

                } else {
                    ULONG           IeCount;
                    Q2931_IE UNALIGNED  *Ie;
                    ATM_BLLI_IE UNALIGNED  *Bli;
                    Q2931_CALLMGR_PARAMETERS    *cmparams;

                    cmparams = (Q2931_CALLMGR_PARAMETERS*)
                        &(CallParameters->CallMgrParameters->CallMgrSpecific.Parameters[0]);

                    Bli = NULL;
                    Ie = (Q2931_IE UNALIGNED *)&cmparams->InfoElements[0];
                    for (IeCount = 0;
                        IeCount < cmparams->InfoElementCount;
                        IeCount++) {

                        if (Ie->IEType == IE_BLLI) {
                            Bli = (ATM_BLLI_IE UNALIGNED*)&Ie->IE[0];
                            break;
                        }

                        Ie = (Q2931_IE UNALIGNED *)((ULONG_PTR)Ie + Ie->IELength);
                    }

                    if (Bli != NULL) {
                        AtmUseLLC = (Bli->Layer2Protocol == BLLI_L2_LLC);
                    }
                }
            }

            if (AtmUseLLC) {
                LinkInfo->SendFramingBits |= LLC_ENCAPSULATION;
                LinkInfo->RecvFramingBits |= LLC_ENCAPSULATION;
                LinkCB->RecvHandler = ReceiveLLC;
            }

            if (!(LinkInfo->SendFramingBits & LLC_ENCAPSULATION)) {
                LinkInfo->SendFramingBits |= PPP_COMPRESS_ADDRESS_CONTROL;
                LinkInfo->RecvFramingBits |= PPP_COMPRESS_ADDRESS_CONTROL;
            }
        }

        NdisWanDbgOut(DBG_TRACE, DBG_CL, ("SPeakBandwidth %d SendWindow %d",
            LinkCB->SFlowSpec.PeakBandwidth,
            LinkCB->SendWindow));

        if (CallParameters->Flags & PERMANENT_VC) {

            //
            // This is a PVC so we will disable idle data detection
            // thus allowing the connection to remain active
            //
            BundleCB->Flags |= DISABLE_IDLE_DETECT;
        }

        BundleCB->FramingInfo.RecvFramingBits =
        BundleCB->FramingInfo.SendFramingBits = PPP_FRAMING;

        UpdateBundleInfo(BundleCB);

        //
        // Deref for the ref applied by AreLinkAndBundleValid.  This
        // will release the BundleCB->Lock!
        //
        DEREF_BUNDLECB_LOCKED(BundleCB);

        //
        // Deref for the ref applied by AreLinkAndBundleValid.
        //
        DEREF_LINKCB(LinkCB);

    } while (0);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClIncomingCall: Exit"));

    return (Status);
}

VOID
ClIncomingCallQoSChange(
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    PLINKCB         LinkCB;
    PBUNDLECB       BundleCB;
    POPENCB         OpenCB;
    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClIncomingCallQoSChange: Enter %p", ProtocolVcContext));

    do {

        if (!AreLinkAndBundleValid(ProtocolVcContext,
                                   TRUE,
                                   &LinkCB,
                                   &BundleCB)) {
            break;
        }

        AcquireBundleLock(BundleCB);

        OpenCB = LinkCB->OpenCB;

        //
        // Do I need to pass this info to 5.0 Clients?????
        //

        NdisMoveMemory(&LinkCB->SFlowSpec,
                       &CallParameters->CallMgrParameters->Transmit,
                       sizeof(FLOWSPEC));

        NdisMoveMemory(&LinkCB->RFlowSpec,
                       &CallParameters->CallMgrParameters->Receive,
                       sizeof(FLOWSPEC));

        if (LinkCB->SFlowSpec.PeakBandwidth == 0) {
            LinkCB->SFlowSpec.PeakBandwidth = 28800 / 8;
        }

        if (LinkCB->RFlowSpec.PeakBandwidth == 0) {
            LinkCB->RFlowSpec.PeakBandwidth = LinkCB->SFlowSpec.PeakBandwidth;
        }

        UpdateBundleInfo(BundleCB);

        //
        // Deref for the ref applied by AreLinkAndBundleValid.  This will
        // release the BundleCB->Lock.
        //
        DEREF_BUNDLECB_LOCKED(BundleCB);

        //
        // Deref for the ref applied by AreLinkAndBundleValid.
        //
        DEREF_LINKCB(LinkCB);

    } while (0);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClIncomingCallQoSChange: Exit"));
}

VOID
ClIncomingCloseCall(
    IN  NDIS_STATUS     CloseStatus,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PVOID           CloseData   OPTIONAL,
    IN  UINT            Size        OPTIONAL
    )
{
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;
    PRECV_DESC  RecvDesc;
    NDIS_STATUS Status;
    ULONG       i;
    BOOLEAN     FreeBundle = FALSE;
    BOOLEAN     FreeLink = FALSE;

    NdisWanDbgOut(DBG_TRACE, DBG_CL,
        ("ClIncomingCloseCall: Enter %p %x", ProtocolVcContext, CloseStatus));

    do {

        if (!AreLinkAndBundleValid(ProtocolVcContext,
                                   TRUE,
                                   &LinkCB,
                                   &BundleCB)) {
#if DBG
            DbgPrint("NDISWAN: CloseCall after link has gone down VcContext %x\n",
                ProtocolVcContext);

            DbgBreakPoint();
#endif
            break;
        }

        NdisAcquireSpinLock(&LinkCB->Lock);

        //
        // Link is now going down
        //
        LinkCB->State = LINK_GOING_DOWN;

        if (LinkCB->VcRefCount == 0) {

            LinkCB->ClCallState = CL_CALL_CLOSED;

            NdisReleaseSpinLock(&LinkCB->Lock);

            Status =
                NdisClCloseCall(LinkCB->NdisLinkHandle,
                                NULL,
                                NULL,
                                0);

            if (Status != NDIS_STATUS_PENDING) {
                ClCloseCallComplete(Status,
                                    LinkCB,
                                    NULL);
            }

        } else {
            LinkCB->ClCallState = CL_CALL_CLOSE_PENDING;

            NdisReleaseSpinLock(&LinkCB->Lock);
        }

        NdisAcquireSpinLock(&IoRecvList.Lock);

        RecvDesc = (PRECV_DESC)IoRecvList.DescList.Flink;

        while ((PVOID)RecvDesc != (PVOID)&IoRecvList.DescList) {
            PRECV_DESC  Next;

            Next = (PRECV_DESC)RecvDesc->Linkage.Flink;

            if (RecvDesc->LinkCB == LinkCB) {

                RemoveEntryList(&RecvDesc->Linkage);

                LinkCB->RecvDescCount--;

                IoRecvList.ulDescCount--;

                NdisWanFreeRecvDesc(RecvDesc);
            }

            RecvDesc = Next;
        }

        NdisReleaseSpinLock(&IoRecvList.Lock);

        //
        // Flush the Bundle's fragment send queues that
        // have sends pending on this link
        //
        AcquireBundleLock(BundleCB);

        for (i = 0; i < MAX_MCML; i++) {
            PSEND_DESC SendDesc;
            PSEND_FRAG_INFO FragInfo;

            FragInfo = &BundleCB->SendFragInfo[i];

            SendDesc = (PSEND_DESC)FragInfo->FragQueue.Flink;

            while ((PVOID)SendDesc != (PVOID)&FragInfo->FragQueue) {

                if (SendDesc->LinkCB == LinkCB) {
                    PSEND_DESC  NextSendDesc;

                    NextSendDesc = (PSEND_DESC)SendDesc->Linkage.Flink;

                    RemoveEntryList(&SendDesc->Linkage);

                    FragInfo->FragQueueDepth--;

                    (*LinkCB->SendHandler)(SendDesc);

                    SendDesc = NextSendDesc;
                } else {
                    SendDesc = (PSEND_DESC)SendDesc->Linkage.Flink;
                }
            }
        }

        UpdateBundleInfo(BundleCB);

        ReleaseBundleLock(BundleCB);

        //
        // Deref's for the refs applied by AreLinkAndBundleValid.
        //
        DEREF_LINKCB(LinkCB);

        DEREF_BUNDLECB(BundleCB);

    } while (0);

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClIncomingCloseCall: Exit"));
}

VOID
ClCallConnected(
    IN  NDIS_HANDLE     ProtocolVcContext
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCallConnected: Enter %p", ProtocolVcContext));

    NdisWanDbgOut(DBG_TRACE, DBG_CL, ("ClCallConnected: Exit"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\global.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Global.h

Abstract:

    This file contains global structures for the NdisWan driver.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#ifndef _NDISWAN_GLOBAL_
#define _NDISWAN_GLOBAL_

extern NDISWANCB    NdisWanCB;                  // Global ndiswan control block

extern WAN_GLOBAL_LIST  MiniportCBList;         // List of NdisWan MiniportCB's

extern WAN_GLOBAL_LIST  OpenCBList;             // List of WAN Miniport structures

extern WAN_GLOBAL_LIST  ThresholdEventQueue;    // Queue to hold threshold events

extern IO_RECV_LIST    IoRecvList;

extern WAN_GLOBAL_LIST_EX   BonDWorkList;

extern WAN_GLOBAL_LIST_EX   DeferredWorkList;

#ifndef USE_QOS_WORKER
extern WAN_GLOBAL_LIST_EX  QoSWorkList;            // List of bundlecb's with QOS work
#endif

extern POOLDESC_LIST    PacketPoolList;             // List of free packet descs/ndispackets

extern NPAGED_LOOKASIDE_LIST    BundleCBList;       // List of free BundleCBs
    
extern NPAGED_LOOKASIDE_LIST    LinkProtoCBList;        // List of free LinkCBs
    
extern NPAGED_LOOKASIDE_LIST   SmallDataDescList;  // List of free small data descs
extern NPAGED_LOOKASIDE_LIST   LargeDataDescList;  // List of free small data descs

extern NPAGED_LOOKASIDE_LIST    WanRequestList;     // List of free WanRequest descs
    
extern NPAGED_LOOKASIDE_LIST    AfSapVcCBList;      // List of free protosapcb's

#if DBG
extern NPAGED_LOOKASIDE_LIST    DbgPacketDescList;
extern UCHAR                    reA[1024];
extern UCHAR                    LastIrpAction;
extern ULONG                    reI;
extern LIST_ENTRY               WanTrcList;
extern ULONG                    WanTrcCount;
#endif

extern PCONNECTION_TABLE    ConnectionTable;    // Pointer to connection table

extern PPROTOCOL_INFO_TABLE ProtocolInfoTable;  // Pointer to the PPP/Protocol value lookup table

extern NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress;

extern ULONG    glDebugLevel;                   // Trace Level values 0 - 10 (10 verbose)
extern ULONG    glDebugMask;                    // Trace bit mask
extern ULONG    glSendQueueDepth;               // # of seconds of send queue buffering
extern ULONG    glMaxMTU;                       // Maximum MTU of all protocols
extern ULONG    glMRU;                          // Maximum recv for a link
extern ULONG    glMRRU;                         // Maximum reconstructed recv for a bundle
extern ULONG    glLargeDataBufferSize;          // Size of databuffer
extern ULONG    glSmallDataBufferSize;          // Size of databuffer
extern ULONG    glTunnelMTU;                    // MTU for VPN's
extern ULONG    glMinFragSize;
extern ULONG    glMaxFragSize;
extern ULONG    glMinLinkBandwidth;
extern ULONG    glNdisTapiKey;
extern BOOLEAN  gbSniffLink;
extern BOOLEAN  gbDumpRecv;
extern BOOLEAN  gbHistoryless;
extern BOOLEAN  gbAtmUseLLCOnSVC;
extern BOOLEAN  gbAtmUseLLCOnPVC;
extern ULONG    glSendCount;
extern ULONG    glSendCompleteCount;
extern ULONG    glPacketPoolCount;
extern ULONG    glPacketPoolOverflow;
extern ULONG    glProtocolMaxSendPackets;
extern ULONG    glLinkCount;
extern ULONG    glConnectCount;
extern ULONG    glCachedKeyCount;
extern ULONG    glMaxOutOfOrderDepth;
extern PVOID    hSystemState;
extern BOOLEAN  gbIGMPIdle;
extern NDIS_RW_LOCK ConnTableLock;

#endif  // _NDISWAN_GLOBAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\compress.h ===
//************************************************************************
//            Microsoft Corporation
//          Copyright(c) Microsoft Corp., 1994
//
//
//  Revision history:
//  5/5/94        Created           gurdeep
//
//  This file uses 4 space tabs
//************************************************************************

#ifdef COMP_12K
#define HISTORY_SIZE        16000
#else
#define HISTORY_SIZE        (8192U) // Maximum back-pointer value, also used
#endif

#define MAX_HASH_OFFSET    60000
                
#define HISTORY_MAX     (HISTORY_SIZE -1) // Maximum back-pointer value, also used

#define HASH_TABLE_SIZE     4096

#define MAX_BACK_PTR        8511

#define MAX_COMPRESSFRAME_SIZE 1600

struct SendContext {

    int     CurrentIndex ;   // how far into the history buffer we are
    PUCHAR  ValidHistory ;   // how much of history is valid
    USHORT  HashOffset;
    ULONG   BundleFlags;

//  UCHAR   CompressBuffer[MAX_COMPRESSFRAME_SIZE] ;

    USHORT  HashTable[HASH_TABLE_SIZE];
    
    UCHAR   History [1] ;
} ;

typedef struct SendContext SendContext ;


struct RecvContext {

#if DBG

#define DEBUG_FENCE_VALUE   0xABABABAB
    ULONG       DebugFence;

#endif

    UCHAR   *CurrentPtr ;  // how far into the history buffer we are
    
    ULONG   BundleFlags;
    ULONG   HistorySize;
    
    UCHAR   History [1] ;
} ;

typedef struct RecvContext RecvContext ;


// Prototypes
//
UCHAR
compress (
    UCHAR   *CurrentBuffer,
    UCHAR   *CompOutBuffer,
    ULONG *CurrentLength,
    SendContext *context);

//UCHAR
//compress (
//       UCHAR  *CurrentBuffer,
//       ULONG *CurrentLength,
//       SendContext *context);

int
decompress (
    UCHAR *inbuf,
    int inlen,
    int start,
    UCHAR **output,
    int *outlen,
    RecvContext *context) ;

void initsendcontext (SendContext *) ;

void initrecvcontext (RecvContext *) ;

VOID
GetStartKeyFromSHA(
    PCRYPTO_INFO    CryptoInfo,
    PUCHAR  Challenge
    );

VOID
GetNewKeyFromSHA(
    PCRYPTO_INFO    CryptoInfo
    );

VOID
GetMasterKey(
    PCRYPTO_INFO    CryptoInfo,
    PUCHAR          NTResponse
    );

VOID
GetAsymetricStartKey(
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    );

//
// Other defines
//

#define COMPRESSION_PADDING 4

#define PACKET_FLUSHED      0x80
#define PACKET_AT_FRONT     0x40
#define PACKET_COMPRESSED   0x20
#define PACKET_ENCRYPTED    0x10


/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#define A_SHA_DIGEST_LEN 20

typedef struct {
  ULONG state[5];                                           /* state (ABCDE) */
  ULONG count[2];                              /* number of UCHARs, msb first */
  unsigned char buffer[64];                                  /* input buffer */
} A_SHA_COMM_CTX;

typedef void (A_SHA_TRANSFORM) (ULONG [5], unsigned char [64]);

void A_SHAInitCommon (A_SHA_COMM_CTX *);
void A_SHAUpdateCommon(A_SHA_COMM_CTX *, UCHAR *, ULONG, A_SHA_TRANSFORM *);
void A_SHAFinalCommon(A_SHA_COMM_CTX *, UCHAR[A_SHA_DIGEST_LEN],
              A_SHA_TRANSFORM *);

VOID ByteReverse(UNALIGNED ULONG* Out, ULONG* In, ULONG Count);

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    ULONG       FinishFlag;
    UCHAR       HashVal[A_SHA_DIGEST_LEN];
    A_SHA_COMM_CTX  commonContext;
} A_SHA_CTX;

void A_SHAInit(A_SHA_CTX *);
void A_SHAUpdate(A_SHA_CTX *, unsigned char *, unsigned int);
void A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif


/* F, G, H and I are basic SHA functions.
 */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) ((x) ^ (y) ^ (z))
#define H(x, y, z) (((x) & (y)) | ((x) & (z)) | ((y) & (z)))
#define I(x, y, z) ((x) ^ (y) ^ (z))

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
 */
#define ROUND(a, b, c, d, e, x, F, k) { \
    (e) += ROTATE_LEFT ((a), 5) + F ((b), (c), (d)) + (x) + k; \
    (b) = ROTATE_LEFT ((b), 30); \
  }
#define FF(a, b, c, d, e, x) ROUND (a, b, c, d, e, x, F, 0x5a827999);
#define GG(a, b, c, d, e, x) ROUND (a, b, c, d, e, x, G, 0x6ed9eba1);
#define HH(a, b, c, d, e, x) ROUND (a, b, c, d, e, x, H, 0x8f1bbcdc);
#define II(a, b, c, d, e, x) ROUND (a, b, c, d, e, x, I, 0xca62c1d6);

void SHATransform(ULONG [5], unsigned char [64]);
void SHAExpand(ULONG [80]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\compress.c ===
//************************************************************************
//            Microsoft Corporation
//          Copyright(c) Microsoft Corp., 1990-1992
//
//
//  Revision history:
//  5/5/94        Created           gurdeep
//
//************************************************************************

//#define COMP_12K

#include "wan.h"

#define __FILE_SIG__    COMPRESS_FILESIG

//#define DEBUG
CONST
unsigned long lookup_array1[256] = {
    0,      10276755,   20553510,   30830265,
    41107020,   51383775,   61660530,   71937285,
    82214040,   92490795,   102767550,  113044305,
    123321060,  133597815,  143874570,  154151325,
    164428080,  174704835,  184981590,  195258345,
    205535100,  215811855,  226088610,  236365365,
    246642120,  256918875,  267195630,  277472385,
    287749140,  298025895,  308302650,  318579405,
    328856160,  339132915,  349409670,  359686425,
    369963180,  380239935,  390516690,  400793445,
    411070200,  421346955,  431623710,  441900465,
    452177220,  462453975,  472730730,  483007485,
    493284240,  503560995,  513837750,  524114505,
    534391260,  544668015,  554944770,  565221525,
    575498280,  585775035,  596051790,  606328545,
    616605300,  626882055,  637158810,  647435565,
    657712320,  667989075,  678265830,  688542585,
    698819340,  709096095,  719372850,  729649605,
    739926360,  750203115,  760479870,  770756625,
    781033380,  791310135,  801586890,  811863645,
    822140400,  832417155,  842693910,  852970665,
    863247420,  873524175,  883800930,  894077685,
    904354440,  914631195,  924907950,  935184705,
    945461460,  955738215,  966014970,  976291725,
    986568480,  996845235,  1007121990, 1017398745,
    1027675500, 1037952255, 1048229010, 1058505765,
    1068782520, 1079059275, 1089336030, 1099612785,
    1109889540, 1120166295, 1130443050, 1140719805,
    1150996560, 1161273315, 1171550070, 1181826825,
    1192103580, 1202380335, 1212657090, 1222933845,
    1233210600, 1243487355, 1253764110, 1264040865,
    1274317620, 1284594375, 1294871130, 1305147885,
    1315424640, 1325701395, 1335978150, 1346254905,
    1356531660, 1366808415, 1377085170, 1387361925,
    1397638680, 1407915435, 1418192190, 1428468945,
    1438745700, 1449022455, 1459299210, 1469575965,
    1479852720, 1490129475, 1500406230, 1510682985,
    1520959740, 1531236495, 1541513250, 1551790005,
    1562066760, 1572343515, 1582620270, 1592897025,
    1603173780, 1613450535, 1623727290, 1634004045,
    1644280800, 1654557555, 1664834310, 1675111065,
    1685387820, 1695664575, 1705941330, 1716218085,
    1726494840, 1736771595, 1747048350, 1757325105,
    1767601860, 1777878615, 1788155370, 1798432125,
    1808708880, 1818985635, 1829262390, 1839539145,
    1849815900, 1860092655, 1870369410, 1880646165,
    1890922920, 1901199675, 1911476430, 1921753185,
    1932029940, 1942306695, 1952583450, 1962860205,
    1973136960, 1983413715, 1993690470, 2003967225,
    2014243980, 2024520735, 2034797490, 2045074245,
    2055351000, 2065627755, 2075904510, 2086181265,
    2096458020, 2106734775, 2117011530, 2127288285,
    2137565040, 2147841795, 2158118550, 2168395305,
    2178672060, 2188948815, 2199225570, 2209502325,
    2219779080, 2230055835, 2240332590, 2250609345,
    2260886100, 2271162855, 2281439610, 2291716365,
    2301993120, 2312269875, 2322546630, 2332823385,
    2343100140, 2353376895, 2363653650, 2373930405,
    2384207160, 2394483915, 2404760670, 2415037425,
    2425314180, 2435590935, 2445867690, 2456144445,
    2466421200, 2476697955, 2486974710, 2497251465,
    2507528220, 2517804975, 2528081730, 2538358485,
    2548635240, 2558911995, 2569188750, 2579465505,
    2589742260, 2600019015, 2610295770, 2620572525
};

/*
    for i = 0 to 255,
        lookup_array2[i] = lookup_array1[i] << 8;
*/
CONST
unsigned long lookup_array2[256] = {
    0,      2630849280, 966731264,  3597580544,
    1933462528, 269344512,  2900193792, 1236075776,
    3866925056, 2202807040, 538689024,  3169538304,
    1505420288, 4136269568, 2472151552, 808033536,
    3438882816, 1774764800, 110646784,  2741496064,
    1077378048, 3708227328, 2044109312, 379991296,
    3010840576, 1346722560, 3977571840, 2313453824,
    649335808,  3280185088, 1616067072, 4246916352,
    2582798336, 918680320,  3549529600, 1885411584,
    221293568,  2852142848, 1188024832, 3818874112,
    2154756096, 490638080,  3121487360, 1457369344,
    4088218624, 2424100608, 759982592,  3390831872,
    1726713856, 62595840,   2693445120, 1029327104,
    3660176384, 1996058368, 331940352,  2962789632,
    1298671616, 3929520896, 2265402880, 601284864,
    3232134144, 1568016128, 4198865408, 2534747392,
    870629376,  3501478656, 1837360640, 173242624,
    2804091904, 1139973888, 3770823168, 2106705152,
    442587136,  3073436416, 1409318400, 4040167680,
    2376049664, 711931648,  3342780928, 1678662912,
    14544896,   2645394176, 981276160,  3612125440,
    1948007424, 283889408,  2914738688, 1250620672,
    3881469952, 2217351936, 553233920,  3184083200,
    1519965184, 4150814464, 2486696448, 822578432,
    3453427712, 1789309696, 125191680,  2756040960,
    1091922944, 3722772224, 2058654208, 394536192,
    3025385472, 1361267456, 3992116736, 2327998720,
    663880704,  3294729984, 1630611968, 4261461248,
    2597343232, 933225216,  3564074496, 1899956480,
    235838464,  2866687744, 1202569728, 3833419008,
    2169300992, 505182976,  3136032256, 1471914240,
    4102763520, 2438645504, 774527488,  3405376768,
    1741258752, 77140736,   2707990016, 1043872000,
    3674721280, 2010603264, 346485248,  2977334528,
    1313216512, 3944065792, 2279947776, 615829760,
    3246679040, 1582561024, 4213410304, 2549292288,
    885174272,  3516023552, 1851905536, 187787520,
    2818636800, 1154518784, 3785368064, 2121250048,
    457132032,  3087981312, 1423863296, 4054712576,
    2390594560, 726476544,  3357325824, 1693207808,
    29089792,   2659939072, 995821056,  3626670336,
    1962552320, 298434304,  2929283584, 1265165568,
    3896014848, 2231896832, 567778816,  3198628096,
    1534510080, 4165359360, 2501241344, 837123328,
    3467972608, 1803854592, 139736576,  2770585856,
    1106467840, 3737317120, 2073199104, 409081088,
    3039930368, 1375812352, 4006661632, 2342543616,
    678425600,  3309274880, 1645156864, 4276006144,
    2611888128, 947770112,  3578619392, 1914501376,
    250383360,  2881232640, 1217114624, 3847963904,
    2183845888, 519727872,  3150577152, 1486459136,
    4117308416, 2453190400, 789072384,  3419921664,
    1755803648, 91685632,   2722534912, 1058416896,
    3689266176, 2025148160, 361030144,  2991879424,
    1327761408, 3958610688, 2294492672, 630374656,
    3261223936, 1597105920, 4227955200, 2563837184,
    899719168,  3530568448, 1866450432, 202332416,
    2833181696, 1169063680, 3799912960, 2135794944,
    471676928,  3102526208, 1438408192, 4069257472,
    2405139456, 741021440,  3371870720, 1707752704,
    43634688,   2674483968, 1010365952, 3641215232,
    1977097216, 312979200,  2943828480, 1279710464,
    3910559744, 2246441728, 582323712,  3213172992,
    1549054976, 4179904256, 2515786240, 851668224
};

/*
    for i = 0 to 255,
        lookup_array3[i] = lookup_array1[i] << 16;
*/
CONST
unsigned long lookup_array3[256] = {
    0,       3482517504,      2670067712,      1857617920,
    1045168128,  232718336,   3715235840,      2902786048,
    2090336256,  1277886464,      465436672,       3947954176,
    3135504384,  2323054592,      1510604800,      698155008,
    4180672512,  3368222720,      2555772928,      1743323136,
    930873344,   118423552,   3600941056,      2788491264,
    1976041472,  1163591680,      351141888,       3833659392,
    3021209600,  2208759808,      1396310016,      583860224,
    4066377728,  3253927936,      2441478144,      1629028352,
    816578560,   4128768,     3486646272,      2674196480,
    1861746688,  1049296896,      236847104,       3719364608,
    2906914816,  2094465024,      1282015232,      469565440,
    3952082944,  3139633152,      2327183360,      1514733568,
    702283776,   4184801280,      3372351488,      2559901696,
    1747451904,  935002112,   122552320,       3605069824,
    2792620032,  1980170240,      1167720448,      355270656,
    3837788160,  3025338368,      2212888576,      1400438784,
    587988992,   4070506496,      3258056704,      2445606912,
    1633157120,  820707328,   8257536,     3490775040,
    2678325248,  1865875456,      1053425664,      240975872,
    3723493376,  2911043584,      2098593792,      1286144000,
    473694208,   3956211712,      3143761920,      2331312128,
    1518862336,  706412544,   4188930048,      3376480256,
    2564030464,  1751580672,      939130880,       126681088,
    3609198592,  2796748800,      1984299008,      1171849216,
    359399424,   3841916928,      3029467136,      2217017344,
    1404567552,  592117760,   4074635264,      3262185472,
    2449735680,  1637285888,      824836096,       12386304,
    3494903808,  2682454016,      1870004224,      1057554432,
    245104640,   3727622144,      2915172352,      2102722560,
    1290272768,  477822976,   3960340480,      3147890688,
    2335440896,  1522991104,      710541312,       4193058816,
    3380609024,  2568159232,      1755709440,      943259648,
    130809856,   3613327360,      2800877568,      1988427776,
    1175977984,  363528192,   3846045696,      3033595904,
    2221146112,  1408696320,      596246528,       4078764032,
    3266314240,  2453864448,      1641414656,      828964864,
    16515072,    3499032576,      2686582784,      1874132992,
    1061683200,  249233408,   3731750912,      2919301120,
    2106851328,  1294401536,      481951744,       3964469248,
    3152019456,  2339569664,      1527119872,      714670080,
    4197187584,  3384737792,      2572288000,      1759838208,
    947388416,   134938624,   3617456128,      2805006336,
    1992556544,  1180106752,      367656960,       3850174464,
    3037724672,  2225274880,      1412825088,      600375296,
    4082892800,  3270443008,      2457993216,      1645543424,
    833093632,   20643840,    3503161344,      2690711552,
    1878261760,  1065811968,      253362176,       3735879680,
    2923429888,  2110980096,      1298530304,      486080512,
    3968598016,  3156148224,      2343698432,      1531248640,
    718798848,   4201316352,      3388866560,      2576416768,
    1763966976,  951517184,   139067392,       3621584896,
    2809135104,  1996685312,      1184235520,      371785728,
    3854303232,  3041853440,      2229403648,      1416953856,
    604504064,   4087021568,      3274571776,      2462121984,
    1649672192,  837222400,   24772608,    3507290112,
    2694840320,  1882390528,      1069940736,      257490944,
    3740008448,  2927558656,      2115108864,      1302659072,
    490209280,   3972726784,      3160276992,      2347827200,
    1535377408,  722927616,   4205445120,      3392995328,
    2580545536,  1768095744,      955645952,       143196160,
    3625713664,  2813263872,      2000814080,      1188364288,
    375914496,   3858432000,      3045982208,      2233532416,
    1421082624,  608632832,   4091150336,      3278700544
};

/*
    The key for the multiplicative hash function consists of 3 unsigned
    characters. They are composed (logically) by concatenating them i.e.
    the composed key = 2^16*c2 + 2^8*c2 + c3 and fits in 24 bits. The
    composed key is not actually computed here as we use the components
    to directly compute the hash function.

    The multiplicative hash function consists of taking the higher order
    12 bits (2^12 = 4096) of the lower order 24 bits of the product
    key * Multiplier where
        Multiplier = floor(A * pow(2.0, (double) w));
        double A = 0.6125423371;    (chosen according to Knuth)
        w = 24 (the key's width in bits)
    The algorithm for this is in Cormen/Leiserson/Rivest.

    To do the multplication efficiently, the product c*Multiplier is
    precomputed and stored in lookup_array1 (for all 256 possible c's).
    lookup_array2 and lookup_array3 contain the same data as lookup_array1
    but shifted left 8 and 16 bits respectively.

    MultHash1 is the mult hashing function. MultHash0 contains an older
    (slower but less space-efficient) version of the same function.
*/


#define MULTHASH1(c1,c2,c3) \
        ((lookup_array1[c1]+ \
          lookup_array2[c2]+ \
          lookup_array3[c3]  ) & 0x00fff000) >> 12


/*
USHORT  xorlookup1 [256] = {
        0x110, 0x120, 0x130, 0x140, 0x150, 0x160, 0x170, 0x180, // 0-7
        0x190, 0x1a0, 0x1b0, 0x1c0, 0x1d0, 0x1e0, 0x1f0, 0x100, // 8-15
        0x210, 0x220, 0x230, 0x240, 0x250, 0x260, 0x270, 0x280, // 16-23
        0x290, 0x2a0, 0x2b0, 0x2c0, 0x2d0, 0x2e0, 0x2f0, 0x200, // 24-31
        0x310, 0x320, 0x330, 0x340, 0x350, 0x360, 0x370, 0x380, // 32-39
        0x390, 0x3a0, 0x3b0, 0x3c0, 0x3d0, 0x3e0, 0x3f0, 0x300, // 40-47
        0x410, 0x420, 0x430, 0x440, 0x450, 0x460, 0x470, 0x480, // 48-55
        0x490, 0x4a0, 0x4b0, 0x4c0, 0x4d0, 0x4e0, 0x4f0, 0x400, // 56-63
        0x510, 0x520, 0x530, 0x540, 0x550, 0x560, 0x570, 0x580, // 64-71
        0x590, 0x5a0, 0x5b0, 0x5c0, 0x5d0, 0x5e0, 0x5f0, 0x500, // 72-79
        0x610, 0x620, 0x630, 0x640, 0x650, 0x660, 0x670, 0x680, // 80-87
        0x690, 0x6a0, 0x6b0, 0x6c0, 0x6d0, 0x6e0, 0x6f0, 0x600, // 88-95
        0x710, 0x720, 0x730, 0x740, 0x750, 0x760, 0x770, 0x780, // 96-103
        0x790, 0x7a0, 0x7b0, 0x7c0, 0x7d0, 0x7e0, 0x7f0, 0x700, // 104-111
        0x810, 0x820, 0x830, 0x840, 0x850, 0x860, 0x870, 0x880, // 112-119
        0x890, 0x8a0, 0x8b0, 0x8c0, 0x8d0, 0x8e0, 0x8f0, 0x800, // 120-127
        0x910, 0x920, 0x930, 0x940, 0x950, 0x960, 0x970, 0x980, // 128-135
        0x990, 0x9a0, 0x9b0, 0x9c0, 0x9d0, 0x9e0, 0x9f0, 0x900, // 136-143
        0xa10, 0xa20, 0xa30, 0xa40, 0xa50, 0xa60, 0xa70, 0xa80, // 144-151
        0xa90, 0xaa0, 0xab0, 0xac0, 0xad0, 0xae0, 0xaf0, 0xa00, // 152-159
        0xb10, 0xb20, 0xb30, 0xb40, 0xb50, 0xb60, 0xb70, 0xb80, // 160-167
        0xb90, 0xba0, 0xbb0, 0xbc0, 0xbd0, 0xbe0, 0xbf0, 0xb00, // 168-175
        0xc10, 0xc20, 0xc30, 0xc40, 0xc50, 0xc60, 0xc70, 0xc80, // 176-183
        0xc90, 0xca0, 0xcb0, 0xcc0, 0xcd0, 0xce0, 0xcf0, 0xc00, // 184-191
        0xd10, 0xd20, 0xd30, 0xd40, 0xd50, 0xd60, 0xd70, 0xd80, // 192-199
        0xd90, 0xda0, 0xdb0, 0xdc0, 0xdd0, 0xde0, 0xdf0, 0xd00, // 200-207
        0xe10, 0xe20, 0xe30, 0xe40, 0xe50, 0xe60, 0xe70, 0xe80, // 208-215
        0xe90, 0xea0, 0xeb0, 0xec0, 0xed0, 0xee0, 0xef0, 0xe00, // 216-223
        0xf10, 0xf20, 0xf30, 0xf40, 0xf50, 0xf60, 0xf70, 0xf80, // 224-231
        0xf90, 0xfa0, 0xfb0, 0xfc0, 0xfd0, 0xfe0, 0xff0, 0xf00, // 232-239
        0x010, 0x020, 0x030, 0x040, 0x050, 0x060, 0x070, 0x080, // 240-247
        0x090, 0x0a0, 0x0b0, 0x0c0, 0x0d0, 0x0e0, 0x0f0, 0x000 }; // 248-255


USHORT  xorlookup2 [256] = {
        0x101, 0x201, 0x301, 0x401, 0x501, 0x601, 0x701, 0x801, // 0-7
        0x901, 0xa01, 0xb01, 0xc01, 0xd01, 0xe01, 0xf01, 0x001, // 8-15
        0x102, 0x202, 0x302, 0x402, 0x502, 0x602, 0x702, 0x802, // 16-23
        0x902, 0xa02, 0xb02, 0xc02, 0xd02, 0xe02, 0xf02, 0x002, // 24-31
        0x103, 0x203, 0x303, 0x403, 0x503, 0x603, 0x703, 0x803, // 32-39
        0x903, 0xa03, 0xb03, 0xc03, 0xd03, 0xe03, 0xf03, 0x003, // 40-47
        0x104, 0x204, 0x304, 0x404, 0x504, 0x604, 0x704, 0x804, // 48-55
        0x904, 0xa04, 0xb04, 0xc04, 0xd04, 0xe04, 0xf04, 0x004, // 56-63
        0x105, 0x205, 0x305, 0x405, 0x505, 0x605, 0x705, 0x805, // 64-71
        0x905, 0xa05, 0xb05, 0xc05, 0xd05, 0xe05, 0xf05, 0x005, // 72-79
        0x106, 0x206, 0x306, 0x406, 0x506, 0x606, 0x706, 0x806, // 80-87
        0x906, 0xa06, 0xb06, 0xc06, 0xd06, 0xe06, 0xf06, 0x006, // 88-95
        0x107, 0x207, 0x307, 0x407, 0x507, 0x607, 0x707, 0x807, // 96-103
        0x907, 0xa07, 0xb07, 0xc07, 0xd07, 0xe07, 0xf07, 0x007, // 104-111
        0x108, 0x208, 0x308, 0x408, 0x508, 0x608, 0x708, 0x808, // 112-119
        0x908, 0xa08, 0xb08, 0xc08, 0xd08, 0xe08, 0xf08, 0x008, // 120-127
        0x109, 0x209, 0x309, 0x409, 0x509, 0x609, 0x709, 0x809, // 128-135
        0x909, 0xa09, 0xb09, 0xc09, 0xd09, 0xe09, 0xf09, 0x009, // 136-143
        0x10a, 0x20a, 0x30a, 0x40a, 0x50a, 0x60a, 0x70a, 0x80a, // 144-151
        0x90a, 0xa0a, 0xb0a, 0xc0a, 0xd0a, 0xe0a, 0xf0a, 0x00a, // 152-159
        0x10b, 0x20b, 0x30b, 0x40b, 0x50b, 0x60b, 0x70b, 0x80b, // 160-167
        0x90b, 0xa0b, 0xb0b, 0xc0b, 0xd0b, 0xe0b, 0xf0b, 0x00b, // 168-175
        0x10c, 0x20c, 0x30c, 0x40c, 0x50c, 0x60c, 0x70c, 0x80c, // 176-183
        0x90c, 0xa0c, 0xb0c, 0xc0c, 0xd0c, 0xe0c, 0xf0c, 0x00c, // 184-191
        0x10d, 0x20d, 0x30d, 0x40d, 0x50d, 0x60d, 0x70d, 0x80d, // 192-199
        0x90d, 0xa0d, 0xb0d, 0xc0d, 0xd0d, 0xe0d, 0xf0d, 0x00d, // 200-207
        0x10e, 0x20e, 0x30e, 0x40e, 0x50e, 0x60e, 0x70e, 0x80e, // 208-215
        0x90e, 0xa0e, 0xb0e, 0xc0e, 0xd0e, 0xe0e, 0xf0e, 0x00e, // 216-223
        0x10f, 0x20f, 0x30f, 0x40f, 0x50f, 0x60f, 0x70f, 0x80f, // 224-231
        0x90f, 0xa0f, 0xb0f, 0xc0f, 0xd0f, 0xe0f, 0xf0f, 0x00f, // 232-239
        0x000, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800, // 240-247
        0x900, 0xa00, 0xb00, 0xc00, 0xd00, 0xe00, 0xf00, 0x100 }; // 248-255

*/

/* Bitptrs point to the current byte. The current bit (i.e. next bit to be
 * stored) is masked off by the bit entry. When this reaches zero, it is
 * reset to 0x80 and the next byte is set up. The bytes are filled MSBit
 * first. */

/* Starts and sets the first byte to zero for the bitptr. */
#define bitptr_init(s)  pbyte = s; byte=0; bit = 16;

/* Sets up the byte part of the bitptr so that it is pointing to the byte after
 * the byte which had the last bit  put into it. */
#define bitptr_end() if (bit != 16) *pbyte++=(UCHAR)(byte >> 8);

/* Goes to the next bit, and byte if necessary. */
#define bitptr_next()                  \
        if (bit < 10) {                \
          *pbyte++=(UCHAR)(byte >> 8); \
          byte <<= 8;                  \
          bit = 16;                    \
        } else                         \
            bit-- ;

/*
#define bitptr_next()                  \
        bit--;                         \
        if (bit < 9) {                 \
          *pbyte++=(UCHAR)(byte >> 8); \
          byte <<= 8;                  \
          bit = 16;                    \
        }
*/


/*  Advances to the next bit, and byte if necessary, readjusting the bit. */
#define bitptr_advance()               \
        if (bit < 9) {                 \
          *pbyte++=(UCHAR)(byte >> 8); \
          bit+=8;                      \
          byte <<= 8;                  \
        }


/* BIT I/O FUNCTIONS *********************************************************/

/* These routines output most-significant-bit-first and the input will return
 * them MSB first, too. */

/* Outputs a one bit in the bit stream. */
#define out_bit_1() bit--; byte |= (1 << bit); bitptr_advance();
#define out_bit_0() bitptr_next();

/* TestBit; output 1 if that bit is set */
//#define tb(b,w,n) if ((w) & (n)) *pbyte |= bit; bitptr_next(b);

#define out_bits_2(w) bit-=2; byte|=(w << bit); bitptr_advance();
#define out_bits_3(w) bit-=3; byte|=(w << bit); bitptr_advance();
#define out_bits_4(w) bit-=4; byte|=(w << bit); bitptr_advance();
#define out_bits_5(w) bit-=5; byte|=(w << bit); bitptr_advance();
#define out_bits_6(w) bit-=6; byte|=(w << bit); bitptr_advance();
#define out_bits_7(w) bit-=7; byte|=(w << bit); bitptr_advance();

// #define out_bits_8(w) bit-=8; byte|=(w << bit); bit+=8; *pbyte++=(UCHAR)(byte >> 8); byte <<= 8;
#define out_bits_8(w) byte|=(w << (bit-8)); *pbyte++=(UCHAR)(byte >> 8); byte <<= 8;


/*
#define out_bits_9(w)              \
     if (bit > 9) {                \
       bit-=9; byte|=(w << bit);   \
       *pbyte++=(UCHAR)(byte >> 8);\
       bit+=8;                     \
       byte <<= 8;                 \
     } else {                      \
       bit=16; byte |= w;          \
       *pbyte++=(UCHAR)(byte >> 8); *pbyte++=(UCHAR)(byte); byte=0; \
     }
*/

#define out_bits_9(w)              \
     if (bit > 9) {                \
       byte|=(w << (bit-9));       \
       *pbyte++=(UCHAR)(byte >> 8);\
       bit--;                      \
       byte <<= 8;                 \
     } else {                      \
       bit=16; byte |= w;          \
       *pbyte++=(UCHAR)(byte >> 8); *pbyte++=(UCHAR)(byte); byte=0; \
     }


#define out_bits_10(w)             \
     if (bit > 10) {               \
       bit-=10; byte |= (w << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
     } else {                      \
       out_bits_2((w >> 8));       \
       out_bits_8((w & 0xFF));     \
     }

//
// Weird effect - if out_bits_9 used instead of out_bits_8,
// it's faster!  if (bit == 11) is faster than if (bit != 11).
//

#define out_bits_11(w)             \
     if (bit > 11) {               \
        bit-=11; byte |= (w << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
     } else {                      \
        if (bit == 11) {           \
          bit=16; byte |= w;       \
          *pbyte++=(UCHAR)(byte >> 8); *pbyte++=(UCHAR)(byte); byte=0; \
        } else {                   \
          bit=11-bit;              \
          byte|=(w >> bit);        \
          *pbyte++=(UCHAR)(byte >> 8); *pbyte++=(UCHAR)(byte); \
          bit=16-bit;              \
          byte=(w << bit);         \
        }                          \
     }


#define out_bits_12(w)             \
     if (bit > 12) {               \
        bit-=12; byte |= (w << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
     } else {                      \
        out_bits_4((w >> 8));      \
        out_bits_8((w & 0xFF));    \
     }
    
#define out_bits_13(w)             \
     if (bit > 13) {               \
        bit-=13; byte |= (w << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
     } else {                      \
        out_bits_5((w >> 8));      \
        out_bits_8((w & 0xFF));    \
     }

#define out_bits_14(w)             \
     if (bit > 14) {               \
        bit-=14; byte |= (w << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
     } else {                      \
        out_bits_6((w >> 8));      \
        out_bits_8((w & 0xFF));    \
     }


#define out_reserve_4()            \
     bit-=4; bitptr_advance();


/* Starts the given bit pointer */
#define inbit_start(s) pbyte = s; bit = 16; byte=(*pbyte << 8) + *(pbyte+1); pbyte++;
#define inbit_end()      if (bit != 16) pbyte++;    

#define in_bit_next()    if (bit < 9) {          \
                            bit=16;              \
                            byte <<=8;           \
                            byte |= *(++pbyte);  \
                         }


#define in_bit_advance() if (bit < 9) {          \
                            bit+=8;              \
                            byte <<=8;           \
                            byte |= *(++pbyte);  \
                         }

/* Returns non-zero in bitset if the next bit in the stream is a 1. */
#define in_bit()     bit--; bitset = (byte >> bit) & 1; in_bit_next()


#define in_bits_2(w) bit-=2; w = (byte >> bit) & 0x03;\
                     in_bit_advance();

#define in_bits_3(w) bit-=3; w = (byte >> bit) & 0x07;\
                     in_bit_advance();

#define in_bits_4(w) bit-=4; w = (byte >> bit) & 0x0F;\
                     in_bit_advance();

#define in_bits_5(w) bit-=5; w = (byte >> bit) & 0x1F;\
                     in_bit_advance();

#define in_bits_6(w) bit-=6; w = (byte >> bit) & 0x3F;\
                     in_bit_advance();

#define in_bits_7(w) bit-=7; w = (byte >> bit) & 0x7F;\
                     in_bit_advance();

#define in_bits_8(w) bit-=8; w = (byte >> bit) & 0xFF;\
                     bit+=8; byte <<=8; byte |= *(++pbyte);


#define in_bits_9(w) bit-=9; w = (byte >> bit) & 0x1FF;          \
                     bit+=8; byte <<=8; byte |= *(++pbyte);      \
                     in_bit_advance();

#define in_bits_10(w) if (bit > 10) {                            \
                        bit-=10; w = (byte >> bit) & 0x3FF;      \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                   \
                        in_bits_2(bitset);                       \
                        in_bits_8(w);                            \
                        w= w + (bitset << 8);                    \
                      }

#define in_bits_11(w) if (bit > 11) {                            \
                        bit-=11; w = (byte >> bit) & 0x7FF;      \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                   \
                        in_bits_3(bitset);                       \
                        in_bits_8(w);                            \
                        w= w + (bitset << 8);                    \
                      }


#define in_bits_12(w) if (bit > 12) {                            \
                        bit-=12; w = (byte >> bit) & 0xFFF;      \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                   \
                        in_bits_4(bitset);                       \
                        in_bits_8(w);                            \
                        w= w + (bitset << 8);                    \
                      }



#define in_bits_13(w)\
                      if (bit > 13) {                            \
                        bit-=13; w = (byte >> bit) & 0x1FFF;     \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                   \
                        in_bits_5(bitset);                       \
                        in_bits_8(w);                            \
                        w=w + (bitset << 8);                     \
                      }


#define in_bits_14(w)\
                      if (bit > 14) {                            \
                        bit-=14; w = (byte >> bit) & 0x3FFF;     \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                   \
                        in_bits_6(bitset);                       \
                        in_bits_8(w);                            \
                        w=w + (bitset << 8);                     \
                      }




UCHAR   SHApad1[40] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
UCHAR   SHApad2[40] = {0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
                       0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
                       0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
                       0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2};

PUCHAR  ClntSSrvR = "On the client side, this is the send key; on the server side, it is the receive key.";
PUCHAR  ClntRSrvS = "On the client side, this is the receive key; on the server side, it is the send key.";

#define ECP_STRING_LEN strlen(ClntSSrvR)

#ifdef DEBUG
char
ChPrint(UCHAR b)
{
    if (isprint(b))
        return (char)b;
    else
        return '.';
}
#endif

//* compress()
//
//  Function:   Main compression function.
//
//  Parameters:
//      IN  CurrentBuffer -> points to NDIS_WAN_PACKET with data to compress
//      OUT CompOutBuffer -> points to NDIS_WAN_PACKET to compress data to
//      IN  CurrentLength -> points to Length of data to compress
//      IN  context -> connection compress context
//
//  Returns:    Nothing
//
//  WARNING:    CODE IS HIGHLY OPTIMIZED FOR TIME.
//
//
UCHAR
compress (UCHAR *CurrentBuffer, UCHAR *CompOutBuffer, ULONG *CurrentLength, SendContext *context)
{
    int     copylen ;
    int     bit;
    int     byte;
    int     backptr ;
    int     cbMatch;
    int     hashvalue ;
    int     lookup1 ;
    UCHAR   *matchptr ;
    UCHAR   *pbyte;
    UCHAR   *historyptr, *historybaseptr ;
    UCHAR   *currentptr ;
    UCHAR   *endptr ;
    UCHAR   hashchar1;
    UCHAR   hashchar2;
    UCHAR   hashchar3;
    int     literal ;
    UCHAR   status=0;   // return flags
    PUCHAR  currentbuf ;
    USHORT  usBufferLength = (USHORT)*CurrentLength;
    register BOOLEAN bHistoryless;


    // Will this packet fit at the end of the history buffer?
    //
    if (((context->CurrentIndex + *CurrentLength) >= (HISTORY_MAX - 1 )) ||
        (context->CurrentIndex == 0)) {
        context->CurrentIndex = 0;   // Index into the history
        status |= PACKET_AT_FRONT;
    }

    if (0 == (context->BundleFlags & DO_HISTORY_LESS)) {
        historybaseptr = context->History;
        bHistoryless = FALSE;
    } else {
        ASSERT(0 == context->CurrentIndex);
        ASSERT(0 == context->ValidHistory);
        historybaseptr = CurrentBuffer;
        bHistoryless = TRUE;
    }
    
    //
    // we no longer need to save the non compressed data - tonybe 01-12-95
    //
//    RtlMoveMemory(context->CompressBuffer, CurrentBuffer, *CurrentLength) ;

    // Start out the bit pointing output
    //
    bitptr_init(CompOutBuffer);

    //
    // We are now compressing into an output buffer - tonybe 01-12-95
    //
//    bitptr_init(CurrentBuffer);

    historyptr = historybaseptr + context->CurrentIndex;

    currentptr = CurrentBuffer;

    //
    // we are now compressing from the currentbuffer - tonybe 01-12-95
    //
//    currentptr = context->CompressBuffer ;

    endptr = currentptr + *CurrentLength - 1;

    while (currentptr < (endptr-2)) {
        hashchar1 = *currentptr++ ;
        if(bHistoryless)
        {
            ASSERT(*historyptr == hashchar1);
            historyptr++;
        }
        else
        {
            *historyptr++ = hashchar1;
        }
        hashchar2 = *currentptr ;
        hashchar3 = *(currentptr+1) ;

        // "fast" hash function
        // hashvalue = (int)hashchar1 ^ xorlookup1[hashchar2] ^ xorlookup2[hashchar3];
        hashvalue = MULTHASH1(hashchar1, hashchar2, hashchar3) ;

        matchptr = historybaseptr + 
                    ((context->HashTable[hashvalue] >= context->HashOffset) ?
                     (context->HashTable[hashvalue] - context->HashOffset)  : 0);
            
        if (matchptr != (historyptr - 1))
            context->HashTable[hashvalue] = (USHORT)(historyptr - historybaseptr) + context->HashOffset;

        if (context->ValidHistory < historyptr)
            context->ValidHistory = historyptr;
            
        if (matchptr != historybaseptr && matchptr != (historyptr - 1) &&
            matchptr != historyptr  && (matchptr+1) <= context->ValidHistory &&
            *(matchptr-1) == hashchar1 && *matchptr == hashchar2 &&
            *(matchptr+1) == hashchar3) {

            backptr = ((int)(historyptr - matchptr)) & (HISTORY_SIZE - 1) ;

            if(bHistoryless)
            {
                ASSERT(*historyptr == hashchar2);
                ASSERT(*(historyptr + 1) == hashchar3);
                historyptr  +=2;
            }
            else
            {
                *historyptr++ = hashchar2 ;     // copy the other 2 chars
                *historyptr++ = hashchar3 ;     // copy the other 2 chars
            }
            currentptr  +=2 ;
            cbMatch = 3 ;           // length of match
            matchptr    +=2 ; // we have already matched 3

            while ((currentptr < endptr) && (matchptr <= context->ValidHistory) && (*matchptr == *currentptr)) {
                matchptr++ ;
                if(bHistoryless)
                {
                    ASSERT(*historyptr == *currentptr);
                    historyptr++;
                    currentptr++ ;
                }
                else
                {
                    *historyptr++ = *currentptr++ ;
                }
                cbMatch++ ;
            }

            // First output the backpointer
            //
            if (backptr >= 320) {
                backptr -= 320 ;
                out_bits_8((0xc000 + backptr) >> 8) ;   // 110 + 13 bits
                out_bits_8((backptr)) ;
            } else if (backptr < 64) {          // 1111 + 6 bits
                backptr += 0x3c0 ;
                out_bits_10(backptr);
            } else  {
                backptr += (0xE00 - 64);        // 1110 + 8 bits
                out_bits_12(backptr);
            }

            // output the length of the match encoding
            //
            switch (cbMatch) {
    
                case 3:
                    out_bit_0();    // length of 3 - most common
                    break;
    
                case 4:
                    out_bits_4(8);
                    break;
    
                case 5:
                    out_bits_4(9);
                    break;
    
                case 6:
                    out_bits_4(10);
                    break;
    
                case 7:
                    out_bits_4(11);
                    break;
    
                case 8:
                    out_bits_6(48);
                    break;
    
                case 9:
                    out_bits_6(49);
                    break;
    
                case 10:
                    out_bits_6(50);
                    break;
    
                case 11:
                    out_bits_6(51);
                    break;
    
                case 12:
                    out_bits_6(52);
                    break;
    
                case 13:
                    out_bits_6(53);
                    break;
    
                case 14:
                    out_bits_6(54);
                    break;
    
                case 15:
                    out_bits_6(55);
                    break;
    
                case 16:
                    out_bits_8(0xe0);
                    break;
    
                case 17:
                    out_bits_8(0xe1);
                    break;
    
                case 18:
                    out_bits_8(0xe2);
                    break;
    
                case 19:
                    out_bits_8(0xe3);
                    break;
    
                case 20:
                    out_bits_8(0xe4);
                    break;
    
                case 21:
                    out_bits_8(0xe5);
                    break;
    
                case 22:
                    out_bits_8(0xe6);
                    break;
    
                case 23:
                    out_bits_8(0xe7);
                    break;
    
                case 24:
                    out_bits_8(0xe8);
                    break;
    
                case 25:
                    out_bits_8(0xe9);
                    break;
    
                case 26:
                    out_bits_8(0xea);
                    break;
    
                case 27:
                    out_bits_8(0xeb);
                    break;
    
                case 28:
                    out_bits_8(0xec);
                    break;
    
                case 29:
                    out_bits_8(0xed);
                    break;
    
                case 30:
                    out_bits_8(0xee);
                    break;
    
                case 31:
                    out_bits_8(0xef);
                    break;
    
                default:
                    if (cbMatch < 64) {
                        out_bits_4(0xF) ;
                        cbMatch -= 32 ;
                        out_bits_6(cbMatch) ;
                    }
                    else if (cbMatch < 128) {
                        out_bits_5(0x1F) ;
                        cbMatch -= 64 ;
                        out_bits_7(cbMatch) ;
                    }
                    else if (cbMatch < 256) {
                        out_bits_6(0x3F) ;
                        cbMatch -= 128 ;
                        out_bits_8(cbMatch) ;
                    }
                    else if (cbMatch < 512) {
                        out_bits_7(0x7F) ;
                        cbMatch -= 256 ;
                        out_bits_9(cbMatch) ;
                    }
                    else if (cbMatch < 1024) {
                        out_bits_8(0xFF) ;
                        cbMatch -= 512 ;
                        out_bits_10(cbMatch) ;
                    }
                    else if (cbMatch < 2048) {
                        out_bits_9(0x1FF) ;
                        cbMatch -= 1024 ;
                        out_bits_11(cbMatch) ;
                    }
                    else if (cbMatch < 4096) {
                        out_bits_10(0x3FF) ;
                        cbMatch -= 2048 ;
                        out_bits_12(cbMatch) ;
                    }
                    else if (cbMatch < 8192) {
                        out_bits_11(0x7FF) ;
                        cbMatch -= 4096 ;
                        out_bits_13(cbMatch) ;
                    }
                    else  {             // 8192 and greater
                        out_bits_12(0xFFF) ;
                        cbMatch -= 8192 ;
                        out_bits_14(cbMatch) ;
                    }
                    break ;
            }

        } else {    // encode a literal

            // temp=literallookup[context->History[i-1]] ;
            literal= hashchar1 ;

            if (literal & 0x80) {
                literal += 0x80;
                out_bits_9(literal) ;
            } else {
                out_bits_8(literal) ;
            }

        }

    }  // while


    // get any remaining chars as literals
    while (currentptr <= endptr) {

        // temp=literallookup[context->History[i-1]] ;
        literal=*currentptr ;


        if (literal & 0x80) {
            literal += 0x80;
            out_bits_9(literal) ;
        } else {
            out_bits_8(literal) ;
        }
        
        if(bHistoryless)
        {
            ASSERT(*historyptr == *currentptr);
            historyptr ++;
            currentptr ++;
        }
        else
        {
            *historyptr++ = *currentptr++ ;
        }
    }


    bitptr_end() ;


    // Check if we had expansion instead of compression
    //
    if ((ULONG)(pbyte - CompOutBuffer) > *CurrentLength) { // expansion.

        //
        // We don't need to do this copy since we can just signal the outside world
        // that compression did not take place and the valid data is still in the
        // current buffer
        //
        // RtlMoveMemory(CompOutBuffer, CurrentBuffer, *CurrentLength) ;
        
        context->HashOffset = 0;
        if (!(context->BundleFlags & DO_HISTORY_LESS)) {
            memset (context->History, 0, HISTORY_SIZE + 1) ;
        }   
        memset (context->HashTable, 0, sizeof(context->HashTable)) ;
#ifdef COMP_12K
        status = 0 ;
#else
        status = PACKET_FLUSHED;
#endif
        context->CurrentIndex = HISTORY_SIZE+1 ; // this forces a start over next time

    } else {     // compression successful

        *CurrentLength = (ULONG)(pbyte - CompOutBuffer);

        //
        // the compressed data is now in CompOutBuffer - tonybe 01-12-95
        //
        //  *CurrentLength = pbyte - CurrentBuffer ;

        status |= PACKET_COMPRESSED ;
        context->CurrentIndex = (int)(historyptr - historybaseptr) ;
        
        if (context->BundleFlags & DO_HISTORY_LESS) {
            
            context->HashOffset += usBufferLength;
        }
    }


    return(status);
}

//* initsendcontext()
//
//  Function:   Initialize SendContext block
//
//  Parameters: IN  context -> connection compress context
//
//  Returns:    Nothing
//
//*
void
initsendcontext (SendContext *context)
{
    context->CurrentIndex = 0;   // Index into the history
    context->ValidHistory = 0 ;  // reset valid history

    if (((context->HashOffset > MAX_HASH_OFFSET) &&
                (context->BundleFlags & DO_HISTORY_LESS)) ||
                !(context->BundleFlags & DO_HISTORY_LESS)) {
     
        context->HashOffset = 0;
        memset (context->HashTable, 0, sizeof(context->HashTable));
    } 
    
    if(!(context->BundleFlags & DO_HISTORY_LESS)) {
        memset (context->History, 0, HISTORY_SIZE + 1) ;
    }
}



//* initrecvcontext()
//
//  Function:   Initialize RecvContext block
//
//  Parameters: IN  context -> connection decompress context
//
//  Returns:    Nothing
//
//*
void
initrecvcontext (RecvContext *context)
{
    context->CurrentPtr = context->History ;

#if DBG
    context->DebugFence = DEBUG_FENCE_VALUE;
#endif

    if(!(context->BundleFlags & DO_HISTORY_LESS)) {
        memset (context->History, 0, HISTORY_SIZE + 1) ;
    }

}



//* decompress()
//
//  Function:   de-compression function.
//
//  Parameters: IN     inbuf -> points to data to be uncompressed
//      IN     inlen -> length of data
//      IN     start -> flag indicating whether to start with a clean history buffer
//      OUT    output-> decompressed data
//      OUT    outlen-> lenght of decompressed data
//      IN     context -> connection decompress context
//
//  Returns:    TRUE  if decompress was successful
//              FALSE if it wasnt
//
//  WARNING:    CODE IS HIGHLY OPTIMIZED FOR TIME.
//
//*
int
decompress(
    UCHAR *inbuf,
    int inlen,
    int start,
    UCHAR **output,
    int *outlen,
    RecvContext *context)
{
    UCHAR   *inend;             // When we know we're done decompressing
    UCHAR   *outstart;          // Remember where in dbuf we started

    UCHAR   *current;

    int     backptr;            // Back pointer for copy items
    int     length;             // Where to copy from in dbuf

    UCHAR   *s1, *s2;

    int     bitset;
    int     bit;
    int     byte;
    UCHAR   *pbyte;
    UCHAR   *historyend = context->History + context->HistorySize;

    inend = inbuf + inlen ;
    
    if ((context->BundleFlags & DO_HISTORY_LESS) && start == 0) {
        return FALSE;   
    }

    //
    // Start out looking at the first bit
    //
    inbit_start(inbuf);

    if (start)      // start over clean?
    context->CurrentPtr = current = context->History ;
    else
    current = context->CurrentPtr ;

    //
    // Save our starting position
    //
    outstart = current;

    //
    // Decompress until we run out of input
    //
    while (pbyte < inend) {

    //
    // Jump on what to do with these three bits.
    //
    in_bits_3(length);

    switch (length) {

    case 0:
        in_bits_5(length) ;
        goto LITERAL ;

    case 1:
        in_bits_5(length) ;
        length += 32 ;
        goto LITERAL ;

    case 2:
        in_bits_5(length) ;
        length += 64 ;
        goto LITERAL ;

    case 3:
        in_bits_5(length) ;
        length += 96 ;
        goto LITERAL ;

    case 4:
        in_bits_6(length) ;
        length +=128 ;
        goto LITERAL ;

    case 5:
        in_bits_6(length) ;
        length +=192 ;
        goto LITERAL ;

    case 6:
        in_bits_13 (backptr) ;      // 110 - 14 bit offset
        backptr+=320 ;
        break ;

    case 7:
        in_bit() ;
        if (bitset) {
        in_bits_6(backptr) ;
        } else {
        in_bits_8(backptr) ;
        backptr+=64 ;
        }
        break ;
    }

    //
    // If we reach here, it's a copy item
    //

    //
    // Now get the length
    //

    in_bit() ;  // 1st length bit
    if (!bitset) {
        length = 3 ;
        goto DONE ;
    }

    in_bit() ;  // 2nd length bit
    if (!bitset) {
        in_bits_2 (length) ;
        length += 4 ;
        goto DONE ;
    }

    in_bit() ; // 3rd length bit
    if (!bitset) {
        in_bits_3 (length) ;
        length += 8 ;
        goto DONE ;
    }

    in_bit() ; // 4th length bit
    if (!bitset) {
        in_bits_4 (length) ;
        length += 16 ;
        goto DONE ;
    }

    in_bit() ; // 5th length bit
    if (!bitset) {
        in_bits_5 (length) ;
        length += 32 ;
        goto DONE ;
    }

    in_bit() ; // 6th length bit
    if (!bitset) {
        in_bits_6 (length) ;
        length += 64 ;
        goto DONE ;
    }

    in_bit() ; // 7th length bit
    if (!bitset) {
        in_bits_7 (length) ;
        length += 128 ;
        goto DONE ;
    }

    in_bit() ; // 8th length bit
    if (!bitset) {
        in_bits_8 (length) ;
        length += 256 ;
        goto DONE ;
    }

    in_bit() ; // 9th length bit
    if (!bitset) {
        in_bits_9 (length) ;
        length += 512 ;
        goto DONE ;
    }

    in_bit() ; // 10th length bit
    if (!bitset) {
        in_bits_10 (length) ;
        length += 1024 ;
        goto DONE ;
    }

    //
    // length cannot be greater than max packets size which is 1500
    //
#if DBG
    DbgPrint("NDISWAN: RAS Decompressor problem1: Possible data corruption\n");
#endif

    return FALSE ;


    DONE:
    //
    // Turn the backptr into an index location
    //
#ifdef COMP_12K
    s2 = current - backptr ;
#else
    if (context->BundleFlags & DO_HISTORY_LESS) {
        s2 = current - backptr ;
        if(s2 < context->History)
        {
            return FALSE;
        }
    }
    else {
        s2 = context->History + (((current - context->History) - backptr) & (HISTORY_SIZE -1)) ;
    }
#endif

    s1 = current;

    current += length;

    // if we are past the end of the history this is a bad sign: abort decompression
    //
    if (current >= historyend || (s2 + length) >= historyend) {
#if DBG
        DbgPrint("NDISWAN: RAS Decompressor problem2: Possible data corruption\n");
#endif
        return FALSE ;
    }

    // loop unrolled to handle lenght>backptr case
    //
    *s1=*s2;
    *(s1+1)=*(s2+1);
    s1+=2;
    s2+=2;
    length-=2;

    //
    // copy all the bytes
    //
    while (length) {
        *s1++=*s2++;
        length--;
    }

    //
    // We have another copy item, and no literals
    //
    continue;


    LITERAL:

    //
    // We have a literal
    //
    
    if (current >= historyend) {
#if DBG
        DbgPrint("NDISWAN: RAS Decompressor problem3: Possible data corruption\n");
#endif
        return FALSE ;
    }

    //*current++ = literallookup[length];
    *current++ = (UCHAR)length;

    } // while loop


    // End case:
    //
    if (current >= historyend) {
#if DBG
        DbgPrint("NDISWAN: RAS Decompressor problem4: Possible data corruption\n");
#endif
        return FALSE ;
    }

    if ((bit == 16) && (pbyte == inend)) {
    *current++ = *(pbyte -1) ;
    }

#if DBG
    if (context->DebugFence != DEBUG_FENCE_VALUE) {
        DbgPrint("Decompression Error!\n");
        DbgPrint("context %p, current %p, outstart %p\n", context, current, outstart);
        DbgPrint("inbuf %p, inlength %d, start %p\n", inbuf, inlen, start);
        DbgBreakPoint();
    }
#endif

    *outlen = (int)(current - outstart) ; // the length of decompressed data

    *output = context->CurrentPtr ;

    context->CurrentPtr = current ;

    return TRUE ;
}


//
// This function uses the 16 byte user session key and the 8 byte
// challenge to create an intial 16 byte encryption session key.
//
VOID
GetStartKeyFromSHA(
    PCRYPTO_INFO    CryptoInfo,
    PUCHAR          Challenge
    )
{
    UCHAR   Digest[A_SHA_DIGEST_LEN];
    UCHAR   SessionKeyChallenge[MAX_USERSESSIONKEY_SIZE + MAX_CHALLENGE_SIZE];

    NdisZeroMemory(Digest, A_SHA_DIGEST_LEN);

    //
    // Copy the start session key
    //
    NdisMoveMemory(SessionKeyChallenge,
                   CryptoInfo->StartKey,
                   MAX_USERSESSIONKEY_SIZE);

    //
    // Append the challenge
    //
    NdisMoveMemory((PUCHAR)(SessionKeyChallenge + MAX_USERSESSIONKEY_SIZE),
                   Challenge,
                   MAX_CHALLENGE_SIZE);

//
// SHAInit(context)
// SHAUpdate(context, sessionkey, sessionkeylength)
// SHAUpdate(context, sessionkeychallenge, sessionkeylength + challengelength)
// SHAFinal(context, digest)
//
// Start key is the first 16 bytes of the digest.
//
    A_SHAInit(CryptoInfo->Context);

    A_SHAUpdate(CryptoInfo->Context,
                CryptoInfo->StartKey,
                MAX_USERSESSIONKEY_SIZE);

    A_SHAUpdate(CryptoInfo->Context,
                SessionKeyChallenge,
                MAX_USERSESSIONKEY_SIZE + MAX_CHALLENGE_SIZE);

    A_SHAFinal(CryptoInfo->Context,
               Digest);

    NdisMoveMemory(CryptoInfo->StartKey,
                   Digest,
                   CryptoInfo->SessionKeyLength);

    NdisMoveMemory(CryptoInfo->SessionKey,
                   Digest,
                   CryptoInfo->SessionKeyLength);
}

VOID
GetNewKeyFromSHA(
    PCRYPTO_INFO    CryptoInfo
    )
{
    UCHAR   Digest[A_SHA_DIGEST_LEN];

    NdisZeroMemory(Digest, A_SHA_DIGEST_LEN);

    A_SHAInit(CryptoInfo->Context);
    A_SHAUpdate(CryptoInfo->Context,
                CryptoInfo->StartKey,
                CryptoInfo->SessionKeyLength);
    A_SHAUpdate(CryptoInfo->Context,
                SHApad1,
                40);
    A_SHAUpdate(CryptoInfo->Context,
                CryptoInfo->SessionKey,
                CryptoInfo->SessionKeyLength);
    A_SHAUpdate(CryptoInfo->Context,
                SHApad2,
                40);
    A_SHAFinal(CryptoInfo->Context,
               Digest);

    NdisMoveMemory(CryptoInfo->SessionKey,
                   Digest,
                   CryptoInfo->SessionKeyLength);
}

VOID
GetMasterKey(
    PCRYPTO_INFO    CryptoInfo,
    PUCHAR          NTResponse
    )
{
    UCHAR   Digest[A_SHA_DIGEST_LEN];
    PVOID   Context;

    NdisZeroMemory(Digest, A_SHA_DIGEST_LEN);

    Context = CryptoInfo->Context;

    A_SHAInit(Context);

#ifdef DEBUG_CCP
    {
    PUCHAR  Key;

    Key = CryptoInfo->StartKey;

    DbgPrint("GMK-UserSessionKey: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    Key = NTResponse;

    DbgPrint("GMK-NTResponse:     %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    DbgPrint("                    %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[16],Key[17],Key[18],Key[19],
        Key[20],Key[21],Key[22],Key[23]);
    }
#endif

    A_SHAUpdate(Context,
                CryptoInfo->StartKey,
                MAX_USERSESSIONKEY_SIZE);

    A_SHAUpdate(Context,
                NTResponse,
                MAX_NT_RESPONSE);

    A_SHAUpdate(Context,
                "This is the MPPE Master Key",
                27);

    A_SHAFinal(Context, Digest);

    NdisMoveMemory(CryptoInfo->StartKey,
                   Digest,
                   MAX_USERSESSIONKEY_SIZE);

#ifdef DEBUG_CCP
    {
    PUCHAR  Key;

    Key = CryptoInfo->StartKey;

    DbgPrint("MasterKey:      %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    }
#endif

}

VOID
GetAsymetricStartKey(
    PCRYPTO_INFO    CryptoInfo,
    BOOLEAN         IsSend
    )
{
    UCHAR   Digest[A_SHA_DIGEST_LEN];
    PVOID   Context;
    PUCHAR  s;

    NdisZeroMemory(Digest, A_SHA_DIGEST_LEN);

    Context = CryptoInfo->Context;

    if (IsSend) {
        if (CryptoInfo->Flags & CRYPTO_IS_SERVER) {
            s = ClntRSrvS;
        } else {
            s = ClntSSrvR;
        }
    } else {
        if (CryptoInfo->Flags & CRYPTO_IS_SERVER) {
            s = ClntSSrvR;
        } else {
            s = ClntRSrvS;
        }
    }

#ifdef DEBUG_CCP
    {
    PUCHAR  Key;

    Key = CryptoInfo->StartKey;

    DbgPrint("GASK-StartKey: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    DbgPrint("GASK-String: %s\n", s);
    }
#endif

    A_SHAInit(Context);

    A_SHAUpdate(Context,
                CryptoInfo->StartKey,
                MAX_USERSESSIONKEY_SIZE);

    A_SHAUpdate(Context,SHApad1,40);

    A_SHAUpdate(Context,s,strlen(s));

    A_SHAUpdate(Context,SHApad2,40);

    A_SHAFinal(Context,Digest);

    NdisMoveMemory(CryptoInfo->StartKey,
                   Digest,
                   CryptoInfo->SessionKeyLength);

    NdisMoveMemory(CryptoInfo->SessionKey,
                   Digest,
                   CryptoInfo->SessionKeyLength);

#ifdef DEBUG_CCP
    {
    PUCHAR  Key;

    Key = CryptoInfo->StartKey;

    DbgPrint("%s %s AsymetricKey: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        (CryptoInfo->Flags & CRYPTO_IS_SERVER) ? "Server" : "Client",
        (IsSend) ? "Send" : "Recv",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    }
#endif
}

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

/* SHA initialization. Begins an SHA operation, writing a new context.
 */
void A_SHAInitCommon (context)
A_SHA_COMM_CTX *context;
{
  context->count[0] = context->count[1] = 0;

  /* Load magic initialization constants.
   */
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
  context->state[4] = 0xc3d2e1f0;
}

/* SHA block update operation. Continues an SHA message-digest
     operation, processing another message block, and updating the
     context.
 */
void A_SHAUpdateCommon (context, partIn, partInLen, Transform)
A_SHA_COMM_CTX *context;
unsigned char *partIn;
ULONG partInLen;
A_SHA_TRANSFORM *Transform;
{
  unsigned int bufferLen;

  /* Compute length of buffer */
  bufferLen = (unsigned int)(context->count[1] & 0x3f);

  /* Update number of bytes */
  if ((context->count[1] += partInLen) < partInLen)
    context->count[0]++;

  /* If previous input in buffer, buffer new input and transform if
       possible.
   */
  if (bufferLen > 0 && bufferLen + partInLen >= 64) {
    NdisMoveMemory(context->buffer+bufferLen, partIn, 64-bufferLen);
    partIn += (64-bufferLen);
    partInLen -= (64-bufferLen);
    (*Transform) (context->state, context->buffer);
    bufferLen = 0;
  }

  /* Transform directly from input.
   */
  while (partInLen >= 64) {
    (*Transform) (context->state, partIn);
    partIn += 64;
    partInLen -= 64;
  }

  /* Buffer remaining input */
  NdisMoveMemory((context->buffer+bufferLen), partIn, partInLen);
}

/* SHA finalization. Ends an SHA message-digest operation, writing
     the message digest and zeroizing the context.
 */
void A_SHAFinalCommon (context, digest, Transform)
A_SHA_COMM_CTX *context;
unsigned char digest[A_SHA_DIGEST_LEN];
A_SHA_TRANSFORM *Transform;
{
  ULONG bitCount[2];
  unsigned char pad[72];
  unsigned int padLen;

  /* Compute padding: 80 00 00 ... 00 00 <bit count>
   */
  padLen = 64 - (unsigned int)(context->count[1] & 0x3f);
  if (padLen <= 8)
    padLen += 64;
  pad[0] = 0x80;
  NdisZeroMemory(pad+1, padLen-7);
  bitCount[0] = (context->count[0] << 3) | (context->count[1] >> 29);
  bitCount[1] = context->count[1] << 3;
  ByteReverse ((UNALIGNED ULONG*)(pad+padLen-8), bitCount, 2);

  /* Digest padding */
  A_SHAUpdateCommon (context, pad, padLen, Transform);

  /* Store digest */
  ByteReverse ((UNALIGNED ULONG*)digest, context->state, 5);

  /* Restart the context */
  A_SHAInitCommon (context);
}

void A_SHAInit (A_SHA_CTX *context)
{
  A_SHAInitCommon (&context->commonContext);
}

void A_SHAUpdate (context, partIn, partInLen)
A_SHA_CTX *context;
unsigned char *partIn;
unsigned int partInLen;
{
  A_SHAUpdateCommon (&context->commonContext, partIn, partInLen, SHATransform);
}

void A_SHAFinal (context, digest)
A_SHA_CTX *context;
unsigned char digest[A_SHA_DIGEST_LEN];
{
  A_SHAFinalCommon (&context->commonContext, digest, SHATransform);
}

void SHATransform (state, block)
ULONG state[5];
unsigned char block[64];
{
  ULONG a = state[0], b = state[1], c = state[2], d = state[3],
    e = state[4], x[80];

  ByteReverse (x, (ULONG*)block, 16);
  SHAExpand (x);

  /* Round 1 */
  FF (a, b, c, d, e, x[ 0]);
  FF (e, a, b, c, d, x[ 1]);
  FF (d, e, a, b, c, x[ 2]);
  FF (c, d, e, a, b, x[ 3]);
  FF (b, c, d, e, a, x[ 4]);
  FF (a, b, c, d, e, x[ 5]);
  FF (e, a, b, c, d, x[ 6]);
  FF (d, e, a, b, c, x[ 7]);
  FF (c, d, e, a, b, x[ 8]);
  FF (b, c, d, e, a, x[ 9]);
  FF (a, b, c, d, e, x[10]);
  FF (e, a, b, c, d, x[11]);
  FF (d, e, a, b, c, x[12]);
  FF (c, d, e, a, b, x[13]);
  FF (b, c, d, e, a, x[14]);
  FF (a, b, c, d, e, x[15]);
  FF (e, a, b, c, d, x[16]);
  FF (d, e, a, b, c, x[17]);
  FF (c, d, e, a, b, x[18]);
  FF (b, c, d, e, a, x[19]);

  /* Round 2 */
  GG (a, b, c, d, e, x[20]);
  GG (e, a, b, c, d, x[21]);
  GG (d, e, a, b, c, x[22]);
  GG (c, d, e, a, b, x[23]);
  GG (b, c, d, e, a, x[24]);
  GG (a, b, c, d, e, x[25]);
  GG (e, a, b, c, d, x[26]);
  GG (d, e, a, b, c, x[27]);
  GG (c, d, e, a, b, x[28]);
  GG (b, c, d, e, a, x[29]);
  GG (a, b, c, d, e, x[30]);
  GG (e, a, b, c, d, x[31]);
  GG (d, e, a, b, c, x[32]);
  GG (c, d, e, a, b, x[33]);
  GG (b, c, d, e, a, x[34]);
  GG (a, b, c, d, e, x[35]);
  GG (e, a, b, c, d, x[36]);
  GG (d, e, a, b, c, x[37]);
  GG (c, d, e, a, b, x[38]);
  GG (b, c, d, e, a, x[39]);

  /* Round 3 */
  HH (a, b, c, d, e, x[40]);
  HH (e, a, b, c, d, x[41]);
  HH (d, e, a, b, c, x[42]);
  HH (c, d, e, a, b, x[43]);
  HH (b, c, d, e, a, x[44]);
  HH (a, b, c, d, e, x[45]);
  HH (e, a, b, c, d, x[46]);
  HH (d, e, a, b, c, x[47]);
  HH (c, d, e, a, b, x[48]);
  HH (b, c, d, e, a, x[49]);
  HH (a, b, c, d, e, x[50]);
  HH (e, a, b, c, d, x[51]);
  HH (d, e, a, b, c, x[52]);
  HH (c, d, e, a, b, x[53]);
  HH (b, c, d, e, a, x[54]);
  HH (a, b, c, d, e, x[55]);
  HH (e, a, b, c, d, x[56]);
  HH (d, e, a, b, c, x[57]);
  HH (c, d, e, a, b, x[58]);
  HH (b, c, d, e, a, x[59]);

  /* Round 4 */
  II (a, b, c, d, e, x[60]);
  II (e, a, b, c, d, x[61]);
  II (d, e, a, b, c, x[62]);
  II (c, d, e, a, b, x[63]);
  II (b, c, d, e, a, x[64]);
  II (a, b, c, d, e, x[65]);
  II (e, a, b, c, d, x[66]);
  II (d, e, a, b, c, x[67]);
  II (c, d, e, a, b, x[68]);
  II (b, c, d, e, a, x[69]);
  II (a, b, c, d, e, x[70]);
  II (e, a, b, c, d, x[71]);
  II (d, e, a, b, c, x[72]);
  II (c, d, e, a, b, x[73]);
  II (b, c, d, e, a, x[74]);
  II (a, b, c, d, e, x[75]);
  II (e, a, b, c, d, x[76]);
  II (d, e, a, b, c, x[77]);
  II (c, d, e, a, b, x[78]);
  II (b, c, d, e, a, x[79]);

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
  state[4] += e;

  /* Zeroize potentially sensitive information.
   */
  NdisZeroMemory((void *)x, sizeof (x));
}

/* Expands x[0..15] into x[16..79], according to the recurrence
     x[i] = x[i-3] ^ x[i-8] ^ x[i-14] ^ x[i-16].
 */
void SHAExpand (x)
ULONG x[80];
{
  unsigned int i;
  ULONG        tmp;

  for (i = 16; i < 80; i++)
  {
    tmp = x[i-3] ^ x[i-8] ^ x[i-14] ^ x[i-16];
    x[i] = (tmp << 1) | (tmp >> 31);
  }
}

VOID
ByteReverse(
    UNALIGNED ULONG *Out,
    ULONG   *In,
    ULONG   Count
    )
{
    ULONG   i;
    ULONG   Value;

    for (i = 0; i < Count; i++) {
        Value = (ULONG)(In[i] << 16) | (In[i] >> 16);
        Out[i] = ((Value & 0xFF00FF00L) >> 8) | ((Value & 0x00FF00FFL) << 8);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\indicate.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Indicate.c

Abstract:

    This file contains procedures to handle indications from the
    WAN Miniport drivers.


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "wan.h"

#define __FILE_SIG__    INDICATE_FILESIG

VOID
NdisWanLineUpIndication(
    POPENCB     OpenCB,
    PUCHAR      Buffer,
    ULONG       BufferSize
    )
/*++

Routine Name:

    NdisWanLineupIndication

Routine Description:

    This routine is called when a WAN Miniport driver has a new connetion
    become active or when the status of an active connection changes.  If
    this is a new connection the routine creates a LinkCB, and a BundleCB
    for the new connection.  If this is for an already active connetion the
    connection info is updated.

Arguments:

Return Values:

    None

--*/
{
    PLINKCB     LinkCB = NULL;
    PBUNDLECB   BundleCB = NULL;
    NDIS_STATUS Status;
    PNDIS_MAC_LINE_UP   LineUpInfo = (PNDIS_MAC_LINE_UP)Buffer;
    BOOLEAN             EmptyList;

    if (BufferSize < sizeof(NDIS_MAC_LINE_UP)) {
        return;
    }

    //
    // Is this for a new connetion?
    //
    if (LineUpInfo->NdisLinkContext == NULL) {

        //
        // This is a new connection!
        //

        //
        // Get a linkcb
        //
        LinkCB = NdisWanAllocateLinkCB(OpenCB, LineUpInfo->SendWindow);

        if (LinkCB == NULL) {

            //
            // Error getting LinkCB!
            //

            return;
            
        }

        LinkCB->NdisLinkHandle = LineUpInfo->NdisLinkHandle;
        LinkCB->ConnectionWrapperID = LineUpInfo->ConnectionWrapperID;

        //
        // Get a bundlecb
        //
        BundleCB = NdisWanAllocateBundleCB();

        if (BundleCB == NULL) {

            //
            // Error getting BundleCB!
            //

            NdisWanFreeLinkCB(LinkCB);

            return;
        }

        AcquireBundleLock(BundleCB);

        //
        // Copy LineUpInfo to Link LineUpInfo
        //
/*      NdisMoveMemory((PUCHAR)&LinkCB->LineUpInfo,
                       (PUCHAR)LineUpInfo,
                       sizeof(NDIS_MAC_LINE_UP));
*/
        //
        // If a linkspeed is not reported we are
        // assuming 28.8K as the slowest...
        //
        if (LineUpInfo->LinkSpeed == 0) {
            LineUpInfo->LinkSpeed = 288;
        }

        //
        // Take 1/100bps to Bps without rolling over
        //
        {
            ULONGLONG   temp;
            ULONG       value;

            temp = LineUpInfo->LinkSpeed;
            temp *= 100;
            temp /= 8;

            //
            // Check for rollover
            //
            value = (ULONG)temp;

            if (value == 0) {
                value = 0xFFFFFFFF/8;
            }

            LinkCB->SFlowSpec.TokenRate =
            LinkCB->SFlowSpec.PeakBandwidth =
            LinkCB->RFlowSpec.TokenRate =
            LinkCB->RFlowSpec.PeakBandwidth = (ULONG)value;
        }

        LinkCB->SFlowSpec.MaxSduSize =
            (OpenCB->WanInfo.MaxFrameSize > glMaxMTU) ?
            glMaxMTU : OpenCB->WanInfo.MaxFrameSize;

        LinkCB->RFlowSpec.MaxSduSize = glMRRU;

        //
        // Add LinkCB to BundleCB
        //
        AddLinkToBundle(BundleCB, LinkCB);

        ReleaseBundleLock(BundleCB);

        //
        // Place BundleCB in active connection table
        //
        if (NULL == InsertBundleInConnectionTable(BundleCB)) {
            //
            // Error inserting link in ConnectionTable
            //
            RemoveLinkFromBundle(BundleCB, LinkCB, FALSE);
            NdisWanFreeLinkCB(LinkCB);

            return;
        }
    
        //
        // Place LinkCB in active connection table
        //
        if (NULL == InsertLinkInConnectionTable(LinkCB)) {
            //
            // Error inserting bundle in connectiontable
            //
            RemoveLinkFromBundle(BundleCB, LinkCB, FALSE);
            NdisWanFreeLinkCB(LinkCB);
            
            return;
        }

        LineUpInfo->NdisLinkContext = LinkCB->hLinkHandle;

    } else {

        do {

            //
            // This is an already existing connetion
            //
            if (!AreLinkAndBundleValid(LineUpInfo->NdisLinkContext,
                                       TRUE,
                                       &LinkCB,
                                       &BundleCB)) {
#if DBG
                DbgPrint("NDISWAN: LineUp on unknown LinkContext %x\n",
                    LineUpInfo->NdisLinkContext);
                DbgBreakPoint();
#endif
                break;
            }

            AcquireBundleLock(BundleCB);
    
            if (LineUpInfo->LinkSpeed == 0) {
                LineUpInfo->LinkSpeed = 288;
            }
    
            //
            // Take 1/100bps to Bps
            //
            {
                ULONGLONG   temp;
        
                temp = LineUpInfo->LinkSpeed;
                temp *= 100;
                temp /= 8;
        
                LinkCB->SFlowSpec.TokenRate =
                LinkCB->SFlowSpec.PeakBandwidth =
                LinkCB->RFlowSpec.TokenRate =
                LinkCB->RFlowSpec.PeakBandwidth = (ULONG)temp;
            }
    
            LinkCB->SendWindow = (LineUpInfo->SendWindow > OpenCB->WanInfo.MaxTransmit ||
                                  LineUpInfo->SendWindow == 0) ?
                                  OpenCB->WanInfo.MaxTransmit : LineUpInfo->SendWindow;

            //
            // If the new sendwindow is set smaller then the
            // current # of outstanding frames then we have to
            // close the sendwindow for the link and reduce the
            // number of sending links that the bundle sees.
            //
            // If the new sendwindow is set larger then the
            // current # of outstanding frames and the sendwindow
            // is currently closed, we need to open the sendwindow
            // and increase the number of sending links that the
            // bundle sees.
            //
            if (LinkCB->LinkActive) {
                if (LinkCB->SendWindow <= LinkCB->OutstandingFrames) {
                    if (LinkCB->SendWindowOpen) {
                        LinkCB->SendWindowOpen = FALSE;
                        BundleCB->SendingLinks -= 1;
                    }
                } else if (!LinkCB->SendWindowOpen) {
                    LinkCB->SendWindowOpen = TRUE;
                    BundleCB->SendingLinks += 1;
                }
            }

            //
            // Update BundleCB info
            //
            UpdateBundleInfo(BundleCB);
    
            //
            // Deref's for the ref's applied when we mapped the
            // context into the control blocks
            //
            DEREF_BUNDLECB_LOCKED(BundleCB);
            DEREF_LINKCB(LinkCB);

        } while ( 0 );
    }
}


VOID
NdisWanLineDownIndication(
    POPENCB     OpenCB,
    PUCHAR      Buffer,
    ULONG       BufferSize
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PNDIS_MAC_LINE_DOWN LineDownInfo = (PNDIS_MAC_LINE_DOWN)Buffer;
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;
    PRECV_DESC  RecvDesc;
    ULONG       i;

    if (!AreLinkAndBundleValid(LineDownInfo->NdisLinkContext,
                               TRUE,
                               &LinkCB,
                               &BundleCB)) {
#if DBG
        DbgPrint("NDISWAN: LineDown on unknown LinkContext %x\n",
            LineDownInfo->NdisLinkContext);
        DbgBreakPoint();
#endif

        return;
    }

    //
    // Link is now going down
    //
    NdisAcquireSpinLock(&LinkCB->Lock);

    LinkCB->State = LINK_GOING_DOWN;

    //
    // Deref for the ref applied in AreLinkAndBundleValid.  We don't
    // have to go through the full deref code as we know that the
    // ref applied at lineup will hold the block around.
    //
    LinkCB->RefCount--;

    NdisReleaseSpinLock(&LinkCB->Lock);

    NdisAcquireSpinLock(&IoRecvList.Lock);

    RecvDesc = (PRECV_DESC)IoRecvList.DescList.Flink;

    while ((PVOID)RecvDesc != (PVOID)&IoRecvList.DescList) {
        PRECV_DESC  Next;

        Next = (PRECV_DESC)RecvDesc->Linkage.Flink;

        if (RecvDesc->LinkCB == LinkCB) {

            RemoveEntryList(&RecvDesc->Linkage);

            LinkCB->RecvDescCount--;

            IoRecvList.ulDescCount--;

            NdisWanFreeRecvDesc(RecvDesc);
        }

        RecvDesc = Next;
    }

    NdisReleaseSpinLock(&IoRecvList.Lock);

    //
    // Flush the Bundle's fragment send queues that
    // have sends pending on this link
    //
    AcquireBundleLock(BundleCB);

    for (i = 0; i < MAX_MCML; i++) {
        PSEND_DESC SendDesc;
        PSEND_FRAG_INFO FragInfo;

        FragInfo = &BundleCB->SendFragInfo[i];

        SendDesc = (PSEND_DESC)FragInfo->FragQueue.Flink;

        while ((PVOID)SendDesc != (PVOID)&FragInfo->FragQueue) {

            if (SendDesc->LinkCB == LinkCB) {
                PSEND_DESC  NextSendDesc;

                NextSendDesc = (PSEND_DESC)SendDesc->Linkage.Flink;

                RemoveEntryList(&SendDesc->Linkage);

                FragInfo->FragQueueDepth--;

                (*LinkCB->SendHandler)(SendDesc);

                SendDesc = NextSendDesc;
            } else {
                SendDesc = (PSEND_DESC)SendDesc->Linkage.Flink;
            }
        }
    }

    UpdateBundleInfo(BundleCB);

    ReleaseBundleLock(BundleCB);

    //
    // For the ref from the lineup
    //
    DEREF_LINKCB(LinkCB);

    //
    // Deref for the ref applied in AreLinkAndBundleValid
    //
    DEREF_BUNDLECB(BundleCB);
}


VOID
NdisWanFragmentIndication(
    POPENCB OpenCB,
    PUCHAR  Buffer,
    ULONG   BufferSize
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       Errors;
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;

    PNDIS_MAC_FRAGMENT FragmentInfo =
        (PNDIS_MAC_FRAGMENT)Buffer;

    if (!AreLinkAndBundleValid(FragmentInfo->NdisLinkContext,
                               TRUE,
                               &LinkCB,
                               &BundleCB)) {
#if DBG
    DbgPrint("NDISWAN: Status indication after link has gone down LinkContext %x\n",
                     FragmentInfo->NdisLinkContext);
            DbgBreakPoint();
#endif
        return;
    }

    Errors = FragmentInfo->Errors;

    AcquireBundleLock(BundleCB);

    if (Errors & WAN_ERROR_CRC) {
        LinkCB->Stats.CRCErrors++;
        BundleCB->Stats.CRCErrors++;
    }

    if (Errors & WAN_ERROR_FRAMING) {
        LinkCB->Stats.FramingErrors++;
        BundleCB->Stats.FramingErrors++;
    }

    if (Errors & WAN_ERROR_HARDWAREOVERRUN) {
        LinkCB->Stats.SerialOverrunErrors++;
        BundleCB->Stats.SerialOverrunErrors++;
    }

    if (Errors & WAN_ERROR_BUFFEROVERRUN) {
        LinkCB->Stats.BufferOverrunErrors++;
        BundleCB->Stats.BufferOverrunErrors++;
    }

    if (Errors & WAN_ERROR_TIMEOUT) {
        LinkCB->Stats.TimeoutErrors++;
        BundleCB->Stats.TimeoutErrors++;
    }

    if (Errors & WAN_ERROR_ALIGNMENT) {
        LinkCB->Stats.AlignmentErrors++;
        BundleCB->Stats.AlignmentErrors++;
    }

    //
    // Deref's for the ref's applied in AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);
}

VOID
NdisCoWanFragmentIndication(
    PLINKCB     LinkCB,
    PBUNDLECB   BundleCB,
    PUCHAR      Buffer,
    ULONG       BufferSize
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   Errors;
    PNDIS_WAN_CO_FRAGMENT FragmentInfo =
        (PNDIS_WAN_CO_FRAGMENT)Buffer;

    Errors = FragmentInfo->Errors;

    AcquireBundleLock(BundleCB);

    if (Errors & WAN_ERROR_CRC) {
        LinkCB->Stats.CRCErrors++;
        BundleCB->Stats.CRCErrors++;
    }

    if (Errors & WAN_ERROR_FRAMING) {
        LinkCB->Stats.FramingErrors++;
        BundleCB->Stats.FramingErrors++;
    }

    if (Errors & WAN_ERROR_HARDWAREOVERRUN) {
        LinkCB->Stats.SerialOverrunErrors++;
        BundleCB->Stats.SerialOverrunErrors++;
    }

    if (Errors & WAN_ERROR_BUFFEROVERRUN) {
        LinkCB->Stats.BufferOverrunErrors++;
        BundleCB->Stats.BufferOverrunErrors++;
    }

    if (Errors & WAN_ERROR_TIMEOUT) {
        LinkCB->Stats.TimeoutErrors++;
        BundleCB->Stats.TimeoutErrors++;
    }

    if (Errors & WAN_ERROR_ALIGNMENT) {
        LinkCB->Stats.AlignmentErrors++;
        BundleCB->Stats.AlignmentErrors++;
    }

    ReleaseBundleLock(BundleCB);
}

VOID
NdisCoWanLinkParamChange(
    PLINKCB     LinkCB,
    PBUNDLECB   BundleCB,
    PUCHAR      Buffer,
    ULONG       BufferSize
    )
{
    PWAN_CO_LINKPARAMS  LinkParams =
        (PWAN_CO_LINKPARAMS)Buffer;

    if (BufferSize < sizeof(WAN_CO_LINKPARAMS)) {
        return;
    }

    AcquireBundleLock(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_INDICATE,
        ("LinkParamChange: SendWindow %d XmitSpeed %d RecvSpeed %d",
        LinkParams->SendWindow, LinkParams->TransmitSpeed, LinkParams->ReceiveSpeed));

    LinkCB->SendWindow = LinkParams->SendWindow;

    //
    // If the new sendwindow is set smaller then the
    // current # of outstanding frames then we have to
    // close the sendwindow for the link and reduce the
    // number of sending links that the bundle sees.
    //
    // If the new sendwindow is set larger then the
    // current # of outstanding frames and the sendwindow
    // is currently closed, we need to open the sendwindow
    // and increase the number of sending links that the
    // bundle sees.
    //
    if (LinkCB->LinkActive) {
        if (LinkCB->SendWindow <= LinkCB->OutstandingFrames) {
            if (LinkCB->SendWindowOpen) {
                LinkCB->SendWindowOpen = FALSE;
                BundleCB->SendingLinks -= 1;
            }
        } else if (!LinkCB->SendWindowOpen) {
            LinkCB->SendWindowOpen = TRUE;
            BundleCB->SendingLinks += 1;
        }
    }

    LinkCB->SFlowSpec.PeakBandwidth =
        LinkParams->TransmitSpeed;

    LinkCB->RFlowSpec.PeakBandwidth =
        LinkParams->ReceiveSpeed;

    if (LinkCB->SFlowSpec.PeakBandwidth == 0) {
        LinkCB->SFlowSpec.PeakBandwidth = 28800 / 8;
    }

    if (LinkCB->RFlowSpec.PeakBandwidth == 0) {
        LinkCB->RFlowSpec.PeakBandwidth = LinkCB->SFlowSpec.PeakBandwidth;
    }

    UpdateBundleInfo(BundleCB);

    ReleaseBundleLock(BundleCB);
}

VOID
UpdateBundleInfo(
    PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

    Expects the BundleCB->Lock to be held!

Arguments:

Return Values:

--*/
{
    PLINKCB LinkCB;
    ULONG       SlowestSSpeed, FastestSSpeed;
    ULONG       SlowestRSpeed, FastestRSpeed;
    PPROTOCOLCB ProtocolCB;
    PFLOWSPEC   BSFlowSpec, BRFlowSpec;
    ULONG       i;
    ULONG       SmallestSDU;
    LIST_ENTRY  TempList;

    BSFlowSpec = &BundleCB->SFlowSpec;
    BRFlowSpec = &BundleCB->RFlowSpec;

    SlowestSSpeed = FastestSSpeed = 0;
    SlowestRSpeed = FastestRSpeed = 0;
    SmallestSDU = 0;
    BSFlowSpec->TokenRate = 0;
    BSFlowSpec->PeakBandwidth = 0;
    BRFlowSpec->TokenRate = 0;
    BRFlowSpec->PeakBandwidth = 0;
    BundleCB->SendWindow = 0;
    BundleCB->State = BUNDLE_GOING_DOWN;

    if (BundleCB->ulLinkCBCount != 0) {
        //
        // Currently only using the SendSide FastestSpeed so
        // just get it from the head of the list.
        //
        FastestSSpeed =
            ((PLINKCB)(BundleCB->LinkCBList.Flink))->SFlowSpec.PeakBandwidth;
        SmallestSDU =
            ((PLINKCB)(BundleCB->LinkCBList.Flink))->SFlowSpec.MaxSduSize;

        //
        // If a link has a speed that is less than the minimum
        // link bandwidth (% of the fastests link speed) it is flaged
        // as not sending and does not count as a sending link.
        //

        BundleCB->SendingLinks = 0;
        BundleCB->SendResources = 0;

        for (LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
            (PVOID)LinkCB != (PVOID)&BundleCB->LinkCBList;
            LinkCB = (PLINKCB)LinkCB->Linkage.Flink) {
            ULONGLONG   n, d, temp;
            PFLOWSPEC   LSFlowSpec = &LinkCB->SFlowSpec;
            PFLOWSPEC   LRFlowSpec = &LinkCB->RFlowSpec;

            if (LinkCB->State == LINK_UP) {
                BundleCB->State = BUNDLE_UP;
            }

            n = LSFlowSpec->PeakBandwidth;
            n *= 100;
            d = FastestSSpeed;
            temp = n/d;


            LinkCB->LinkActive = ((ULONG)temp > glMinLinkBandwidth) ?
                TRUE : FALSE;

            if (LinkCB->LinkActive) {

                BundleCB->SendResources += LinkCB->SendResources;
                BundleCB->SendWindow += LinkCB->SendWindow;
                if (LinkCB->SendWindowOpen) {
                    BundleCB->SendingLinks += 1;
                }

                BSFlowSpec->PeakBandwidth += LSFlowSpec->PeakBandwidth;
                BRFlowSpec->PeakBandwidth += LRFlowSpec->PeakBandwidth;
            }

            if (LinkCB->SFlowSpec.MaxSduSize < SmallestSDU) {
                SmallestSDU = LinkCB->SFlowSpec.MaxSduSize;
            }
        }

        BundleCB->SFlowSpec.MaxSduSize = SmallestSDU;

        //
        // Now calculate the % bandwidth that each links contributes to the
        // bundle.  If a link has a speed that is less than the minimum
        // link bandwidth (% of the fastests link speed) it is flaged
        // as not sending and does not count as a sending link.
        //
        for (LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
            (PVOID)LinkCB != (PVOID)&BundleCB->LinkCBList;
            LinkCB = (PLINKCB)LinkCB->Linkage.Flink) {
            ULONGLONG   n, d, temp;
            PFLOWSPEC   LSFlowSpec = &LinkCB->SFlowSpec;
            PFLOWSPEC   LRFlowSpec = &LinkCB->RFlowSpec;

            //
            // Do sending side
            //
            n = LSFlowSpec->PeakBandwidth;
            n *= 100;
            d = BSFlowSpec->PeakBandwidth;
            temp = n/d;

            LinkCB->SBandwidth = (temp > 0) ? (ULONG)temp : 1;

            //
            // Do receiving side
            //
            n = LRFlowSpec->PeakBandwidth;
            n *= 100;
            d = BRFlowSpec->PeakBandwidth;
            temp = n/d;

            LinkCB->RBandwidth = (temp > 0) ? (ULONG)temp : 1;

        }

        BundleCB->NextLinkToXmit = 
            (PLINKCB)BundleCB->LinkCBList.Flink;

        //
        // Update the BandwidthOnDemand information
        //
        if (BundleCB->Flags & BOND_ENABLED) {
            PBOND_INFO  BonDInfo;
            ULONGLONG   SecondsInSamplePeriod;
            ULONGLONG   BytesPerSecond;
            ULONGLONG   BytesInSamplePeriod;
            ULONGLONG   temp;

            BonDInfo = BundleCB->SUpperBonDInfo;

            SecondsInSamplePeriod =
                BonDInfo->ulSecondsInSamplePeriod;

            BytesPerSecond =
                BundleCB->SFlowSpec.PeakBandwidth;

            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;

            temp = BonDInfo->usPercentBandwidth;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            BonDInfo = BundleCB->SLowerBonDInfo;

            SecondsInSamplePeriod =
                BonDInfo->ulSecondsInSamplePeriod;

            BytesPerSecond =
                BundleCB->SFlowSpec.PeakBandwidth;

            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;

            temp = BonDInfo->usPercentBandwidth;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            BonDInfo = BundleCB->RUpperBonDInfo;

            SecondsInSamplePeriod =
                BonDInfo->ulSecondsInSamplePeriod;

            BytesPerSecond =
                BundleCB->RFlowSpec.PeakBandwidth;

            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;

            temp = BonDInfo->usPercentBandwidth;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            BonDInfo = BundleCB->RLowerBonDInfo;

            SecondsInSamplePeriod =
                BonDInfo->ulSecondsInSamplePeriod;

            BytesPerSecond =
                BundleCB->RFlowSpec.PeakBandwidth;

            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;

            temp = BonDInfo->usPercentBandwidth;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;
        }
    }

    //
    // We need to do a new lineup to all routed protocols
    //
    ProtocolCB = (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;

    InitializeListHead(&TempList);

    while ((PVOID)ProtocolCB != (PVOID)&BundleCB->ProtocolCBList) {

        REF_PROTOCOLCB(ProtocolCB);

        InsertHeadList(&TempList, &ProtocolCB->RefLinkage);

        ProtocolCB = 
            (PPROTOCOLCB)ProtocolCB->Linkage.Flink;
    }

    while (!IsListEmpty(&TempList)) {
        PLIST_ENTRY Entry;

        Entry =
            RemoveHeadList(&TempList);

        ProtocolCB = CONTAINING_RECORD(Entry, PROTOCOLCB, RefLinkage);

        if (BundleCB->State == BUNDLE_UP) {
            ReleaseBundleLock(BundleCB);

            DoLineUpToProtocol(ProtocolCB);

            AcquireBundleLock(BundleCB);
        } else {
            //
            // Our link count has gone to 0.  This means 
            // that we can not send any packets.  Flush the 
            // queues and don't accept any more sends from 
            // the transports.
            //
            FlushProtocolPacketQueue(ProtocolCB);
        }

        DEREF_PROTOCOLCB(ProtocolCB);
    }
}


VOID
AddLinkToBundle(
    IN  PBUNDLECB   BundleCB,
    IN  PLINKCB     LinkCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    UINT    Class;

    //
    // Insert the links so that they are ordered with the fastest
    // sending link at the head of the list
    //
    if (IsListEmpty(&BundleCB->LinkCBList) ||
        (LinkCB->SFlowSpec.PeakBandwidth >=
        ((PLINKCB)(BundleCB->LinkCBList.Flink))->SFlowSpec.PeakBandwidth)) {

        //
        // The list was either empty or this link is a bigger pipe
        // than anything else on the bundle
        //
        InsertHeadList(&BundleCB->LinkCBList, &LinkCB->Linkage);

    } else if ((LinkCB->SFlowSpec.PeakBandwidth <=
        ((PLINKCB)(BundleCB->LinkCBList.Blink))->SFlowSpec.PeakBandwidth)) {

        //
        // This link is a smaller pipe than anything else
        // on the bundle.
        //
        InsertTailList(&(BundleCB->LinkCBList), &(LinkCB->Linkage));

    } else {
        PLINKCB Current, Next;
        BOOLEAN Inserted = FALSE;

        //
        // We need to find where this link belongs in the list!
        //
        Current = (PLINKCB)BundleCB->LinkCBList.Flink;
        Next = (PLINKCB)Current->Linkage.Flink;

        while ((PVOID)Next != (PVOID)&BundleCB->LinkCBList) {

            if (LinkCB->SFlowSpec.PeakBandwidth <= Current->SFlowSpec.PeakBandwidth &&
                LinkCB->SFlowSpec.PeakBandwidth >= Next->SFlowSpec.PeakBandwidth) {

                LinkCB->Linkage.Flink = (PLIST_ENTRY)Next;
                LinkCB->Linkage.Blink = (PLIST_ENTRY)Current;

                Current->Linkage.Flink =
                Next->Linkage.Blink =
                    (PLIST_ENTRY)LinkCB;
                
                Inserted = TRUE;
                break;
            }

            Current = Next;
            Next = (PLINKCB)Next->Linkage.Flink;
        }

        if (!Inserted) {
            InsertTailList(&(BundleCB->LinkCBList), &(LinkCB->Linkage));
        }
    }

    BundleCB->ulLinkCBCount++;

    LinkCB->BundleCB = BundleCB;

    for (Class = 0; Class < MAX_MCML; Class++) {
        PLINK_RECV_INFO     LinkRecvInfo;
        PBUNDLE_RECV_INFO   BundleRecvInfo;

        LinkRecvInfo = &LinkCB->RecvInfo[Class];
        BundleRecvInfo = &BundleCB->RecvInfo[Class];

        LinkRecvInfo->LastSeqNumber =
            BundleRecvInfo->MinSeqNumber;
    }

    //
    // Update BundleCB info
    //
    UpdateBundleInfo(BundleCB);

    REF_BUNDLECB(BundleCB);
}

VOID
RemoveLinkFromBundle(
    IN  PBUNDLECB   BundleCB,
    IN  PLINKCB     LinkCB,
    IN  BOOLEAN     Locked
    )
/*++

Routine Name:

Routine Description:

    Expects the BundleCB->Lock to be held!  Returns with the
    lock released!

Arguments:

Return Values:

--*/
{

    if (!Locked) {
        AcquireBundleLock(BundleCB);
    }

    //
    // Remove link from the bundle
    //
    RemoveEntryList(&LinkCB->Linkage);

    LinkCB->BundleCB = NULL;

    BundleCB->ulLinkCBCount--;
    BundleCB->SendingLinks--;

    //
    // Update BundleCB info
    //
    UpdateBundleInfo(BundleCB);

    //
    // Deref for ref applied when we added this linkcb to
    // the bundle
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\isdn.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

	isdn.h

Abstract:

	This module defines the structures, macros, and manifests available
	to ISDN aware components.

Author:

	Tony Bell - tonybe@microsoft.com

Revision History:

	Initial Version - January 1997

--*/

#ifndef _ISDN_H
#define _ISDN_H

#endif

//
// Define Q.931 SAP.  This is registered by clients that want to
// accept incoming calls from a call manager that has registered
// the Q.931 address family
//

//
// Define Q.931 CO_CALL_PARAMETERS
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\init.c ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This is the initialization file for the NdisWan driver.  This driver
    is a shim between the protocols, where it conforms to the NDIS 3.1/NDIS 5.0
    Miniport interface specs, and the miniport drivers, where it exports
    the NDIS 3.1 WAN Extensions for Miniports and NDIS 5.0 Call Manager/Miniport
    interfaces (it looks like a NDIS 3.1 protocol to NDIS 3.1 WAN Miniport drivers
    and a NDIS 5.0 client to NDIS 5.0 miniports).

Author:

    Tony Bell   (TonyBe) January 9, 1997

Environment:

    Kernel Mode

Revision History:

    TonyBe      01/09/97        Created

--*/


#include "wan.h"

#define __FILE_SIG__    INIT_FILESIG

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, NdisWanReadRegistry)
#pragma alloc_text(INIT, DoProtocolInit)
#pragma alloc_text(INIT, DoMiniportInit)
#endif

EXPORT
VOID
NdisTapiRegisterProvider(
    IN  NDIS_HANDLE,
    IN  PNDISTAPI_CHARACTERISTICS
    );

//
// We want to initialize all of the global variables now!
//

//
// Globals
//
NDISWANCB   NdisWanCB;                      // Global control block for NdisWan

WAN_GLOBAL_LIST MiniportCBList;             // List of NdisWan MiniportCB's

WAN_GLOBAL_LIST OpenCBList;                 // List of WAN Miniport structures

WAN_GLOBAL_LIST ThresholdEventQueue;        // Global thresholdevent queue

IO_RECV_LIST    IoRecvList;

WAN_GLOBAL_LIST_EX  BonDWorkList;

WAN_GLOBAL_LIST_EX  DeferredWorkList;

POOLDESC_LIST   PacketPoolList;             // List of free packet descs/ndispackets

NPAGED_LOOKASIDE_LIST   BundleCBList;       // List of free BundleCBs

NPAGED_LOOKASIDE_LIST   LinkProtoCBList;    // List of free LinkCBs

NPAGED_LOOKASIDE_LIST   SmallDataDescList;  // List of free small data descs
NPAGED_LOOKASIDE_LIST   LargeDataDescList;  // List of free small data descs


NPAGED_LOOKASIDE_LIST   WanRequestList;     // List of free WanRequest descs

NPAGED_LOOKASIDE_LIST   AfSapVcCBList;      // List of free afsapcb's

#if DBG
NPAGED_LOOKASIDE_LIST   DbgPacketDescList;
UCHAR                   reA[1024] = {0};
UCHAR                   LastIrpAction;
ULONG                   reI = 0;
LIST_ENTRY              WanTrcList;
ULONG                   WanTrcCount;
#endif

ULONG   glDebugLevel;                   // Trace Level values 0 - 10 (10 verbose)
ULONG   glDebugMask;                    // Trace bit mask
ULONG   glSendQueueDepth;               // # of seconds of send queue buffering
ULONG   glMaxMTU = DEFAULT_MTU;         // Maximum MTU of all protocols
ULONG   glMRU;                          // Maximum recv for a link
ULONG   glMRRU;                         // Maximum reconstructed recv for a bundle
ULONG   glSmallDataBufferSize;          // Size of databuffer
ULONG   glLargeDataBufferSize;          // Size of databuffer
ULONG   glTunnelMTU;                    // MTU to be used over a VPN
ULONG   glMinFragSize;
ULONG   glMaxFragSize;
ULONG   glMinLinkBandwidth;
BOOLEAN gbSniffLink = FALSE;
BOOLEAN gbDumpRecv = FALSE;
BOOLEAN gbHistoryless = TRUE;
BOOLEAN gbIGMPIdle = TRUE;
BOOLEAN gbAtmUseLLCOnSVC = FALSE;
BOOLEAN gbAtmUseLLCOnPVC = FALSE;
ULONG   glSendCount = 0;
ULONG   glSendCompleteCount = 0;
ULONG   glPacketPoolCount;
ULONG   glPacketPoolOverflow;
ULONG   glProtocolMaxSendPackets;
ULONG   glLinkCount;
ULONG   glConnectCount;
ULONG   glCachedKeyCount = 16;
ULONG   glMaxOutOfOrderDepth = 128;
ULONG   glNdisTapiKey = 0;
PVOID   hSystemState = NULL;
NDIS_RW_LOCK    ConnTableLock;

PCONNECTION_TABLE   ConnectionTable = NULL; // Pointer to connection table

PPROTOCOL_INFO_TABLE    ProtocolInfoTable = NULL; // Pointer to the PPP/Protocol lookup table

NDIS_PHYSICAL_ADDRESS   HighestAcceptableAddress = NDIS_PHYSICAL_ADDRESS_CONST(-1, -1);

#ifdef NT

VOID
NdisWanUnload(
    PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++
Routine Name:

    DriverEntry

Routine Description:

    This is the NT OS specific driver entry point.  It kicks off initialization
    for the driver.  We return from this routine only after NdisWan has installed
    itself as: a Miniport driver, a "transport" to the WAN Miniport drivers, and
    has been bound to the WAN Miniport drivers.

Arguments:

    DriverObject - NT OS specific Object
    RegistryPath - NT OS specific pointer to registry location for NdisWan

Return Values:

    STATUS_SUCCESS
    STATUS_FAILURE

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    NDIS_STRING NdisTapiName = NDIS_STRING_CONST("NdisTapi");

    NdisZeroMemory(&NdisWanCB, sizeof(NdisWanCB));

    glDebugLevel = DBG_CRITICAL_ERROR;
    glDebugMask = DBG_ALL;

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DriverEntry: Enter"));

    NdisMInitializeWrapper(&(NdisWanCB.NdisWrapperHandle),
                           DriverObject,
                           RegistryPath,
                           NULL);

    Status = NdisWanCreateProtocolInfoTable();

    if (Status != NDIS_STATUS_SUCCESS) {

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                      ("NdisWanCreatePPPProtocolTable Failed! Status: 0x%x - %s",
                      Status, NdisWanGetNdisStatus(Status)));

        return (STATUS_UNSUCCESSFUL);
    }

    NdisWanReadRegistry(RegistryPath);

    //
    // Initialize globals
    //
    NdisAllocateSpinLock(&NdisWanCB.Lock);

    NdisWanCB.pDriverObject = DriverObject;

    NdisZeroMemory(&MiniportCBList, sizeof(WAN_GLOBAL_LIST));
    InitializeListHead(&(MiniportCBList.List));
    NdisAllocateSpinLock(&MiniportCBList.Lock);

    NdisZeroMemory(&OpenCBList, sizeof(WAN_GLOBAL_LIST));
    InitializeListHead(&(OpenCBList.List));
    NdisAllocateSpinLock(&OpenCBList.Lock);

    NdisZeroMemory(&ThresholdEventQueue, sizeof(WAN_GLOBAL_LIST));
    InitializeListHead(&(ThresholdEventQueue.List));
    NdisAllocateSpinLock(&ThresholdEventQueue.Lock);

    NdisZeroMemory(&PacketPoolList, sizeof(POOLDESC_LIST));
    InitializeListHead(&PacketPoolList.List);
    NdisAllocateSpinLock(&PacketPoolList.Lock);

    NdisZeroMemory(&IoRecvList, sizeof(IO_RECV_LIST));
    InitializeListHead(&IoRecvList.IrpList);
    InitializeListHead(&IoRecvList.DescList);
    NdisAllocateSpinLock(&IoRecvList.Lock);

    KeInitializeTimerEx(&IoRecvList.Timer, NotificationTimer);
    KeInitializeDpc(&IoRecvList.Dpc, IoRecvIrpWorker, NULL);

    NdisZeroMemory(&BonDWorkList, sizeof(WAN_GLOBAL_LIST_EX));
    InitializeListHead(&BonDWorkList.List);
    NdisAllocateSpinLock(&BonDWorkList.Lock);
    KeInitializeTimerEx(&BonDWorkList.Timer, NotificationTimer);
    KeInitializeDpc(&BonDWorkList.Dpc, BonDWorker, NULL);

    NdisZeroMemory(&DeferredWorkList, sizeof(WAN_GLOBAL_LIST_EX));
    InitializeListHead(&DeferredWorkList.List);
    NdisAllocateSpinLock(&DeferredWorkList.Lock);
    KeInitializeTimerEx(&DeferredWorkList.Timer, NotificationTimer);
    KeInitializeDpc(&DeferredWorkList.Dpc, DeferredWorker, NULL);

    //
    // Is depth used by the OS?
    //
    NdisInitializeNPagedLookasideList(&BundleCBList,
                                      NULL,
                                      NULL,
                                      0,
                                      BUNDLECB_SIZE,
                                      BUNDLECB_TAG,
                                      0);

    NdisInitializeNPagedLookasideList(&LinkProtoCBList,
                                      NULL,
                                      NULL,
                                      0,
                                      LINKPROTOCB_SIZE,
                                      LINKPROTOCB_TAG,
                                      0);

    //
    // Calculated from the following:
    // MAX_FRAME_SIZE + PROTOCOL_HEADER_LENGTH + sizeof(PVOID) + (MAX_FRAME_SIZE + 7)/8
    //
    {
        ULONG   Size = (glMaxMTU > glMRRU) ? glMaxMTU : glMRRU;

        glLargeDataBufferSize = 
            Size + PROTOCOL_HEADER_LENGTH + 
            sizeof(PVOID) + ((Size + 7)/8);
        glLargeDataBufferSize &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        glSmallDataBufferSize = glLargeDataBufferSize/2 + sizeof(PVOID);
        glSmallDataBufferSize &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        NdisInitializeNPagedLookasideList(&SmallDataDescList,
                                          AllocateDataDesc,
                                          FreeDataDesc,
                                          0,
                                          DATADESC_SIZE + 
                                          glSmallDataBufferSize,
                                          SMALLDATADESC_TAG,
                                          0);

        NdisInitializeNPagedLookasideList(&LargeDataDescList,
                                          AllocateDataDesc,
                                          FreeDataDesc,
                                          0,
                                          DATADESC_SIZE + 
                                          glLargeDataBufferSize,
                                          LARGEDATADESC_TAG,
                                          0);
    }

    NdisInitializeNPagedLookasideList(&WanRequestList,
                                      NULL,
                                      NULL,
                                      0,
                                      sizeof(WAN_REQUEST),
                                      WANREQUEST_TAG,
                                      0);


    NdisInitializeNPagedLookasideList(&AfSapVcCBList,
                                      NULL,
                                      NULL,
                                      0,
                                      AFSAPVCCB_SIZE,
                                      AFSAPVCCB_TAG,
                                      0);

    NdisInitializeReadWriteLock(&ConnTableLock);

#if DBG
    NdisInitializeNPagedLookasideList(&DbgPacketDescList,
                                      NULL,
                                      NULL,
                                      0,
                                      sizeof(DBG_PACKET),
                                      DBGPACKET_TAG,
                                      0);
    InitializeListHead(&WanTrcList);
    WanTrcCount = 0;
#endif

    WanInitECP();
    WanInitVJ();

    //
    // Initialzie as a "Protocol" to the WAN Miniport drivers
    //
    Status = DoProtocolInit(RegistryPath);

    if (Status != NDIS_STATUS_SUCCESS) {

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                      ("DoProtocolInit Failed! Status: 0x%x - %s",
                      Status, NdisWanGetNdisStatus(Status)));

        goto DriverEntryError;
    }

    //
    // Initialize as a Miniport driver to the transports
    //
    Status = DoMiniportInit();

    if (Status != NDIS_STATUS_SUCCESS) {

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                      ("DoMiniportInit Failed! Status: 0x%x - %s",
                      Status, NdisWanGetNdisStatus(Status)));

        goto DriverEntryError;
    }

    //
    // Open the miniports
    //
#if 0
    NdisWanBindMiniports(RegistryPath);
#endif

    //
    // Allocate and initialize the ConnectionTable
    //
    Status =
        NdisWanCreateConnectionTable(NdisWanCB.NumberOfLinks);

    if (Status != NDIS_STATUS_SUCCESS) {

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                      ("NdisWanInitConnectionTable Failed! Status: 0x%x - %s",
                      Status, NdisWanGetNdisStatus(Status)));

        goto DriverEntryError;

    }


    //
    // Initialize the Ioctl interface
    //
#ifdef MY_DEVICE_OBJECT
    {
        NDIS_STRING SymbolicName = NDIS_STRING_CONST("\\DosDevices\\NdisWan");
        NDIS_STRING Name = NDIS_STRING_CONST("\\Device\\NdisWan");
        ULONG   i;

        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
    
            NdisWanCB.MajorFunction[i] = (PVOID)DriverObject->MajorFunction[i];
            DriverObject->MajorFunction[i] = NdisWanIrpStub;
        }
    
        DriverObject->MajorFunction[IRP_MJ_CREATE] = NdisWanCreate;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = NdisWanIoctl;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP] = NdisWanCleanup;
    //  DriverObject->MajorFunction[IRP_MJ_PNP_POWER] = NdisWanPnPPower;
        NdisWanCB.NdisUnloadHandler = DriverObject->DriverUnload;
        DriverObject->DriverUnload = (PVOID)NdisWanUnload;
    
        IoCreateDevice(DriverObject,
                       sizeof(LIST_ENTRY),
                       &Name,
                       FILE_DEVICE_NDISWAN,
                       0,
                       FALSE,
                       (PDEVICE_OBJECT*)&NdisWanCB.pDeviceObject);
    
        NdisWanDbgOut(DBG_INFO, DBG_INIT,
                      ("IoCreateSymbolicLink: %ls -> %ls",
                                SymbolicName.Buffer, Name.Buffer));
    
        ((PDEVICE_OBJECT)NdisWanCB.pDeviceObject)->Flags |= DO_BUFFERED_IO;
    
        IoCreateSymbolicLink(&SymbolicName,
                             &Name);
    }
#endif

    NdisMRegisterUnloadHandler(NdisWanCB.NdisWrapperHandle,
                               NdisWanUnload);

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DriverEntry: Exit"));

    return (STATUS_SUCCESS);

    //
    // An error occured so we need to cleanup things
    //
DriverEntryError:

    NdisWanGlobalCleanup();

    //
    // Terminate the wrapper
    //
    NdisTerminateWrapper(NdisWanCB.NdisWrapperHandle,
                         NdisWanCB.pDriverObject);

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DriverEntry: Exit Error!"));

    return (STATUS_UNSUCCESSFUL);
    
}

VOID
NdisWanUnload(
    PDRIVER_OBJECT DriverObject
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("NdisWanUnload: Entry!"));

    NdisWanGlobalCleanup();

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("NdisWanUnload: Exit!"));
}

VOID
NdisWanReadRegistry(
    IN  PUNICODE_STRING RegistryPath
    )
/*++

Routine Name:

    NdisWanReadRegistry

Routine Description:

    This routine will read the registry values for NdisWan.  These values only
    need to be read once for all adapters as their information is global.

Arguments:

    WrapperConfigurationContext - Handle to registry key where NdisWan information
                                  is stored.

Return Values:

    None

--*/
{
    NDIS_STATUS Status;
    PWSTR       ParameterKey = L"NdisWan\\Parameters";
    PWSTR       MinFragmentSizeKeyWord = L"MinimumFragmentSize";
    PWSTR       MaxFragmentSizeKeyWord = L"MaximumFragmentSize";
    PWSTR       LinkBandwidthKeyWord = L"MinimumLinkBandwidth";
    PWSTR       CachedKeyCountKeyWord = L"CachedKeyCount";
    PWSTR       MaxOutOfOrderDepthKeyWord = L"MaxOutOfOrderDepth";
    PWSTR       DebugLevelKeyWord = L"DebugLevel";
    PWSTR       DebugMaskKeyWord = L"DebugMask";
    PWSTR       NumberOfPortsKeyWord = L"NumberOfPorts";
    PWSTR       PacketPoolCountKeyWord = L"NdisPacketPoolCount";
    PWSTR       PacketPoolOverflowKeyWord = L"NdisPacketPoolOverflow";
    PWSTR       ProtocolMaxSendPacketsKeyWord = L"ProtocolMaxSendPackets";
    PWSTR       SniffLinkKeyWord = L"SniffLink";
    PWSTR       SendQueueDepthKeyWord = L"SendQueueDepth";
    PWSTR       MRUKeyWord = L"MRU";
    PWSTR       MRRUKeyWord = L"MRRU";
    PWSTR       TunnelMTUKeyWord = L"TunnelMTU";
    PWSTR       HistorylessKeyWord = L"Historyless";
    PWSTR       AtmUseLLCOnSVCKeyWord = L"AtmUseLLCOnSVC";
    PWSTR       AtmUseLLCOnPVCKeyWord = L"AtmUseLLCOnPVC";
    PWSTR       IGMPIdleKeyWord = L"IGMPIdle";
    ULONG       GenericULong;
    RTL_QUERY_REGISTRY_TABLE    QueryTable[6];

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("NdisWanReadRegistry: Enter"));

    //
    // First setup the protocol id table
    //
    {
        PWSTR   ProtocolsKey = L"NdisWan\\Parameters\\Protocols\\";
        PWSTR   ProtocolKeyWord = L"ProtocolType";
        PWSTR   PPPKeyWord = L"PPPProtocolType";
        PWSTR   ProtocolMTUKeyWord = L"ProtocolMTU";
        PWSTR   TunnelMTUKeyword = L"TunnelMTU";
        PWSTR   QueueDepthKeyword = L"PacketQueueDepth";
        ULONG   i, Generic1, Generic2;
        PROTOCOL_INFO   ProtocolInfo;
        UNICODE_STRING  uni1;

        NdisInitUnicodeString(&uni1, ProtocolsKey);

        NdisZeroMemory(QueryTable, sizeof(QueryTable));

        //
        // Read the ProtocolType parameter MULTI_SZ
        //
        QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
        QueryTable[0].Name = ProtocolKeyWord;
        QueryTable[0].EntryContext = &Generic1;
        QueryTable[0].DefaultType = 0;

        //
        // Read the PPPProtocolType parameter MULTI_SZ
        //
        QueryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[1].Name = PPPKeyWord;
        QueryTable[1].EntryContext = &Generic2;
        QueryTable[1].DefaultType = 0;

        //
        // Read the ProtocolMTU parameter DWORD
        //
        QueryTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[2].Name = ProtocolMTUKeyWord;
        QueryTable[2].EntryContext = &ProtocolInfo.MTU;
        QueryTable[2].DefaultType = 0;

        //
        // Read the ProtocolMTU parameter DWORD
        //
        QueryTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[3].Name = TunnelMTUKeyWord;
        QueryTable[3].EntryContext = &ProtocolInfo.TunnelMTU;
        QueryTable[3].DefaultType = 0;

        //
        // Read the PacketQueueDepth parameter DWORD
        //
        QueryTable[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[4].Name = QueueDepthKeyword;
        QueryTable[4].EntryContext = &ProtocolInfo.PacketQueueDepth;
        QueryTable[4].DefaultType = 0;

        for (i = 0; i < 32; i++) {
            WCHAR   Buffer[512] = {0};
            WCHAR   Buffer2[256] = {0};
            UNICODE_STRING  uni2;
            UNICODE_STRING  IndexString;

            uni2.Buffer = Buffer;
            uni2.MaximumLength = sizeof(Buffer);
            uni2.Length = uni1.Length;
            RtlCopyUnicodeString(&uni2, &uni1);
            IndexString.Buffer = Buffer2;
            IndexString.MaximumLength = sizeof(Buffer2);
            RtlIntegerToUnicodeString(i, 10, &IndexString);
            RtlAppendUnicodeStringToString(&uni2, &IndexString);

            NdisZeroMemory(&ProtocolInfo, sizeof(ProtocolInfo));

            Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                            uni2.Buffer,
                                            QueryTable,
                                            NULL,
                                            NULL);
            if (Status == STATUS_SUCCESS) {
                ProtocolInfo.ProtocolType = (USHORT)Generic1;
                ProtocolInfo.PPPId = (USHORT)Generic2;
                ProtocolInfo.Flags = PROTOCOL_UNBOUND;
                SetProtocolInfo(&ProtocolInfo);
            }
        }
    }

    //
    // Read the MinFragmentSize parameter DWORD
    //
    glMinFragSize = DEFAULT_MIN_FRAG_SIZE;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = MinFragmentSizeKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'MinimumFragmentSize' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong > 0) {
        glMinFragSize = GenericULong;
    }

    //
    // Read the MaxFragmentSize parameter DWORD
    //
    glMaxFragSize = glMaxMTU;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = MaxFragmentSizeKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'MaximumFragmentSize' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong > 0 &&
        GenericULong < glMaxMTU) {
        glMaxFragSize = GenericULong;
    }

    if (glMaxFragSize < glMinFragSize) {
        glMinFragSize = glMaxFragSize;
    }

    //
    // Read the MinimumLinkBandwidth parameter DWORD
    //
    glMinLinkBandwidth = 25;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = LinkBandwidthKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'MinimumLinkBandwidth' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong <= 100) {
        glMinLinkBandwidth = GenericULong;
    }

    //
    // Read the NumberOfPorts parameter DWORD
    //
    NdisWanCB.NumberOfLinks = 250;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = NumberOfPortsKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'NumberOfPorts' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong > 0) {
        NdisWanCB.NumberOfLinks = GenericULong;
    }

    //
    // Read the NdisPacketPoolCount parameter DWORD
    //
    glPacketPoolCount = 100;
//  glPacketPoolCount = 1;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = PacketPoolCountKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'NdisPacketPoolCount' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong > 0) {
        glPacketPoolCount = GenericULong;
    }

    //
    // Read the NdisPacketPoolOverflow parameter DWORD
    //
//  glPacketPoolOverflow = PAGE_SIZE / (sizeof(NDIS_PACKET) + sizeof(NDISWAN_PROTOCOL_RESERVED));
    glPacketPoolOverflow = 0;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = PacketPoolOverflowKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'NdisPacketPoolOverflow' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong > 0) {
        glPacketPoolOverflow = GenericULong;
    }

    //
    // Read the ProtocolMaxSendPackets parameter DWORD
    //
    glProtocolMaxSendPackets = 5;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = ProtocolMaxSendPacketsKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'ProtocolMaxSendPackets' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS &&
        GenericULong > 0) {
        glProtocolMaxSendPackets = GenericULong;
    }

    //
    // Read the CachedKeyCount parameter DWORD
    //
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = CachedKeyCountKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'CachedKeyCount' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glCachedKeyCount = GenericULong;
    }

    //
    // Read the MaxOutOfOrderDepth parameter DWORD
    //
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = MaxOutOfOrderDepthKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'MaxOutOfOrderDepth' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glMaxOutOfOrderDepth = GenericULong;
    }

    //
    // Read the DebugLevel parameter DWORD
    //
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = DebugLevelKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'DebugLevel' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glDebugLevel = GenericULong;
    }

    //
    // Read the DebugIdentifier parameter DWORD
    //
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = DebugMaskKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'DebugMask' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glDebugMask = GenericULong;
    }

    //
    // Read the SniffLink parameter DWORD
    //
    gbSniffLink = FALSE;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = SniffLinkKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'SniffLink' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        gbSniffLink = (GenericULong == 0) ? FALSE : TRUE;
    }

    //
    // Read the SendQueueDepth parameter DWORD
    //
    glSendQueueDepth = 2;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = SendQueueDepthKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'SendQueueDepth' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glSendQueueDepth = (GenericULong == 0) ? 2 : GenericULong;
    }

    //
    // Read the MRU parameter DWORD
    //
    glMRU = DEFAULT_MRU;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = MRUKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'MRU' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glMRU = (GenericULong == 0) ? DEFAULT_MRU : GenericULong;
    }

    //
    // Read the MRRU parameter DWORD
    //
    glMRRU = DEFAULT_MRRU;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = MRRUKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'MRRU' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glMRRU = (GenericULong == 0) ? DEFAULT_MRRU : GenericULong;
    }

    //
    // Read the TunnelMTU parameter DWORD
    //
    glTunnelMTU = DEFAULT_TUNNEL_MTU;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = TunnelMTUKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'TunnelMTU' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        glTunnelMTU = (GenericULong == 0) ? DEFAULT_TUNNEL_MTU : GenericULong;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("NdisWanReadRegistry: Exit"));

    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    gbHistoryless = TRUE;
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = HistorylessKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);
    
    NdisWanDbgOut(DBG_INFO, DBG_INIT,
        ("RtlQueryRegistry - 'Historyless' Status: 0x%x", Status));
    
    if (Status == NDIS_STATUS_SUCCESS) {
        gbHistoryless = (GenericULong) ? TRUE : FALSE;
    }

    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = AtmUseLLCOnSVCKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);
    
    NdisWanDbgOut(DBG_INFO, DBG_INIT,
        ("RtlQueryRegistry - 'AtmUseLLCOnSVC' Status: 0x%x", Status));
    
    if (Status == NDIS_STATUS_SUCCESS) {
            gbAtmUseLLCOnSVC = (GenericULong) ? TRUE : FALSE;
    }

    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = AtmUseLLCOnPVCKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);
    
    NdisWanDbgOut(DBG_INFO, DBG_INIT,
        ("RtlQueryRegistry - 'AtmUseLLCOnPVC' Status: 0x%x", Status));
    
    if (Status == NDIS_STATUS_SUCCESS) {
            gbAtmUseLLCOnPVC = (GenericULong) ? TRUE : FALSE;
    }

    //
    // Read the IGMPIdle parameter DWORD
    //
    gbIGMPIdle = TRUE;
    NdisZeroMemory(QueryTable, sizeof(QueryTable));
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = IGMPIdleKeyWord;
    QueryTable[0].EntryContext = (PVOID)&GenericULong;
    QueryTable[0].DefaultType = 0;
    Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                    ParameterKey,
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    NdisWanDbgOut(DBG_INFO, DBG_INIT,
                  ("RtlQueryRegistry - 'IGMPIdle' Status: 0x%x",
                  Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        gbIGMPIdle = (GenericULong == 0) ? FALSE : TRUE;
    }
}

#endif      // NT specific code



NDIS_STATUS
DoMiniportInit(
    VOID
    )
/*++

Routine Name:

    DoMiniportInit

Routine Description:

    This routines registers NdisWan as a Miniport driver with the NDIS wrapper.
    The wrapper will now call NdisWanInitialize once for each adapter instance
    of NdisWan that is in the registry.

Arguments:

    None

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_BAD_VERSION
    NDIS_STATUS_FAILURE

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    NDIS_MINIPORT_CHARACTERISTICS   MiniportChars;

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DoMiniportInit: Enter"));

    NdisZeroMemory(&MiniportChars, sizeof(MiniportChars));

    MiniportChars.MajorNdisVersion = 5;
    MiniportChars.MinorNdisVersion = 0;

    //
    // NDIS 3.0 handlers
    //
    MiniportChars.HaltHandler = MPHalt;
    MiniportChars.InitializeHandler = MPInitialize;
//  MiniportChars.QueryInformationHandler = MPQueryInformation;
    MiniportChars.ReconfigureHandler = MPReconfigure;
    MiniportChars.ResetHandler = MPReset;
//  MiniportChars.SetInformationHandler = MPSetInformation;

    //
    // We are providing a sendpackets handlers so
    // we don't need the regular send handler
    //
    MiniportChars.SendHandler = NULL;

    //
    // We are going to indicate packets so we
    // don't need a transfer data handler
    //
    MiniportChars.TransferDataHandler = NULL;

    //
    // Since we don't have any hardware to worry about we will
    // not handle any of the interrupt stuff!
    //
    MiniportChars.DisableInterruptHandler = NULL;
    MiniportChars.EnableInterruptHandler = NULL;
    MiniportChars.HandleInterruptHandler = NULL;
    MiniportChars.ISRHandler = NULL;

    //
    // We will disable the check for hang timeout so we do not
    // need a check for hang handler!
    //
    MiniportChars.CheckForHangHandler = NULL;

    //
    // NDIS 4.0 handlers
    //
    MiniportChars.ReturnPacketHandler = MPReturnPacket;
    MiniportChars.SendPacketsHandler = MPSendPackets;

    //
    // unused
    //
    MiniportChars.AllocateCompleteHandler = NULL;

    //
    // NDIS 5.0 handlers
    //
    MiniportChars.CoCreateVcHandler = MPCoCreateVc;
    MiniportChars.CoDeleteVcHandler = MPCoDeleteVc;
    MiniportChars.CoActivateVcHandler = MPCoActivateVc;
    MiniportChars.CoDeactivateVcHandler = MPCoDeactivateVc;
    MiniportChars.CoSendPacketsHandler = MPCoSendPackets;
    MiniportChars.CoRequestHandler = MPCoRequest;

    Status = NdisMRegisterMiniport(NdisWanCB.NdisWrapperHandle,
                                   &MiniportChars,
                                   sizeof(MiniportChars));

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DoMiniportInit: Exit %x", Status));

    return (Status);
}



NDIS_STATUS
DoProtocolInit(
    IN  PUNICODE_STRING RegistryPath
    )
/*++

Routine Name:

    DoProtocolInit

Routine Description:

    This function registers NdisWan as a protocol with the NDIS wrapper.

Arguments:

    None

Return Values:

    NDIS_STATUS_BAD_CHARACTERISTICS
    NDIS_STATUS_BAD_VERSION
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_SUCCESS

--*/
{
    NDIS_PROTOCOL_CHARACTERISTICS ProtocolChars;
    NDIS_STATUS Status;
//  NDIS_STRING NdisWanName = NDIS_STRING_CONST("NdisWanProto");
    NDIS_STRING NdisWanName = NDIS_STRING_CONST("NdisWan");

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DoProtocolInit: Enter"));

    NdisZeroMemory(&ProtocolChars, sizeof(ProtocolChars));

    ProtocolChars.Name.Length = NdisWanName.Length;
    ProtocolChars.Name.Buffer = (PVOID)NdisWanName.Buffer;

    ProtocolChars.MajorNdisVersion = 5;
    ProtocolChars.MinorNdisVersion = 0;

    //
    // NDIS 3.0 handlers
    //
    ProtocolChars.OpenAdapterCompleteHandler = ProtoOpenAdapterComplete;
    ProtocolChars.CloseAdapterCompleteHandler = ProtoCloseAdapterComplete;
    ProtocolChars.WanSendCompleteHandler = ProtoWanSendComplete;
    ProtocolChars.TransferDataCompleteHandler = NULL;
    ProtocolChars.ResetCompleteHandler = ProtoResetComplete;
    ProtocolChars.RequestCompleteHandler = ProtoRequestComplete;
    ProtocolChars.WanReceiveHandler = ProtoWanReceiveIndication;
    ProtocolChars.ReceiveCompleteHandler = ProtoReceiveComplete;
    ProtocolChars.StatusHandler = ProtoIndicateStatus;
    ProtocolChars.StatusCompleteHandler = ProtoIndicateStatusComplete;

    //
    // NDIS 4.0 handlers
    //
    ProtocolChars.ReceivePacketHandler = NULL;

    //
    // PnP handlers
    //
    ProtocolChars.BindAdapterHandler = ProtoBindAdapter;
    ProtocolChars.UnbindAdapterHandler = ProtoUnbindAdapter;
    ProtocolChars.PnPEventHandler = ProtoPnPEvent;
    ProtocolChars.UnloadHandler = ProtoUnload;

    //
    // NDIS 5.0 handlers
    //
    ProtocolChars.CoSendCompleteHandler = ProtoCoSendComplete;
    ProtocolChars.CoStatusHandler = ProtoCoIndicateStatus;
    ProtocolChars.CoReceivePacketHandler = ProtoCoReceivePacket;
    ProtocolChars.CoAfRegisterNotifyHandler = ProtoCoAfRegisterNotify;

    NdisRegisterProtocol(&Status,
                         &NdisWanCB.ProtocolHandle,
                         (PNDIS_PROTOCOL_CHARACTERISTICS)&ProtocolChars,
                         sizeof(NDIS_PROTOCOL_CHARACTERISTICS) + ProtocolChars.Name.Length);

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("DoProtocolInit: Exit"));

    return (Status);
}

VOID
SetProtocolInfo(
    IN  PPROTOCOL_INFO ProtocolInfo
    )
/*++

Routine Name:

    InsertProtocolInfo

Routine Description:

    This routine takes a information about a protocol and inserts it
    into the appropriate lookup table.

Arguments:


Return Values:

--*/
{
    ULONG   i;
    ULONG   ArraySize;
    PPROTOCOL_INFO  InfoArray;

    if (ProtocolInfo->ProtocolType == 0) {
        return;
    }

    NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

    ArraySize = ProtocolInfoTable->ulArraySize;

    //
    // First check to see if this value is already in the array
    //
    for (i = 0, InfoArray = ProtocolInfoTable->ProtocolInfo;
         i < ArraySize; i++, InfoArray++) {
        if (InfoArray->ProtocolType == ProtocolInfo->ProtocolType) {
            //
            // This protocol is already in the table
            // update values if they are valid (0 is invalid)
            //
            if (ProtocolInfo->PPPId != 0) {
                InfoArray->PPPId = ProtocolInfo->PPPId;
            }
            if (ProtocolInfo->TunnelMTU != 0) {
                InfoArray->TunnelMTU = ProtocolInfo->TunnelMTU;
            }
            if (ProtocolInfo->MTU != 0) {
                InfoArray->MTU = ProtocolInfo->MTU;
                if (InfoArray->MTU < InfoArray->TunnelMTU) {
                    InfoArray->TunnelMTU = InfoArray->MTU;
                }
            }
            if (ProtocolInfo->MTU > glMaxMTU) {
                glMaxMTU = ProtocolInfo->MTU;
            }
            if (ProtocolInfo->PacketQueueDepth != 0) {
                InfoArray->PacketQueueDepth =
                    ProtocolInfo->PacketQueueDepth;
            }
            if (ProtocolInfo->Flags != 0) {
                //
                // Is this a bind notification?
                //
                if (ProtocolInfo->Flags & PROTOCOL_BOUND) {
                    if (InfoArray->Flags & PROTOCOL_UNBOUND) {
                        InfoArray->Flags &= ~PROTOCOL_UNBOUND;
                        InfoArray->Flags |=
                            (PROTOCOL_BOUND | PROTOCOL_EVENT_OCCURRED);
                        ProtocolInfoTable->Flags |= PROTOCOL_EVENT_OCCURRED;
                    } else if ((InfoArray->Flags & PROTOCOL_BOUND) &&
                               (ProtocolInfo->ProtocolType == PROTOCOL_IP)) {
                        //
                        // This means we were unbound and then
                        // bound again without our miniport being
                        // halted (layered driver insertion i.e psched).
                        // Currently this only interferes with rasman
                        // if the protocol is IP.
                        // We need to tell ras about two events,
                        // the unbind and the bind.
                        //
                        InfoArray->Flags |=
                            (PROTOCOL_BOUND | 
                             PROTOCOL_REBOUND |
                             PROTOCOL_EVENT_OCCURRED);
                        ProtocolInfoTable->Flags |= PROTOCOL_EVENT_OCCURRED;

                    }
                }

                //
                // is this an unbind notification?
                //
                if (ProtocolInfo->Flags & PROTOCOL_UNBOUND) {
                    if (InfoArray->Flags & PROTOCOL_BOUND) {
                        InfoArray->Flags &= ~(PROTOCOL_BOUND | PROTOCOL_REBOUND);
                        InfoArray->Flags |=
                            (PROTOCOL_UNBOUND | PROTOCOL_EVENT_OCCURRED);
                        ProtocolInfoTable->Flags |= PROTOCOL_EVENT_OCCURRED;
                    }
                }
            }

            if (ProtocolInfoTable->Flags & PROTOCOL_EVENT_OCCURRED &&
                !(ProtocolInfoTable->Flags & PROTOCOL_EVENT_SIGNALLED)) {

                if (ProtocolInfoTable->EventIrp != NULL) {
                    PIRP    Irp;

                    Irp = ProtocolInfoTable->EventIrp;

                    if (IoSetCancelRoutine(Irp, NULL)) {

                        ProtocolInfoTable->EventIrp = NULL;
                        ProtocolInfoTable->Flags |= PROTOCOL_EVENT_SIGNALLED;

                        NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

                        Irp->IoStatus.Status = STATUS_SUCCESS;
                        Irp->IoStatus.Information = 0;

                        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

                        NdisAcquireSpinLock(&ProtocolInfoTable->Lock);
                    }
                }
            }

            break;
        }
    }
    
    //
    // We did not find the value in the array so
    // we will add it at the 1st available spot
    //
    if (i >= ArraySize) {
    
        for (i = 0, InfoArray = ProtocolInfoTable->ProtocolInfo;
             i < ArraySize; i++, InfoArray++) {
            //
            // We are looking for an empty slot to add
            // the new values to the table
            //
            if (InfoArray->ProtocolType == 0) {
                *InfoArray = *ProtocolInfo;
                if (ProtocolInfo->MTU > glMaxMTU) {
                    glMaxMTU = ProtocolInfo->MTU;
                }
                break;
            }
        }
    }

    NdisReleaseSpinLock(&ProtocolInfoTable->Lock);
}

BOOLEAN
GetProtocolInfo(
    IN OUT  PPROTOCOL_INFO ProtocolInfo
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   i;
    ULONG   ArraySize;
    PPROTOCOL_INFO  InfoArray;
    BOOLEAN ReturnValue = FALSE;

    NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

    ArraySize = ProtocolInfoTable->ulArraySize;

    for (i = 0, InfoArray = ProtocolInfoTable->ProtocolInfo;
         i < ArraySize; i++, InfoArray++) {

        if (InfoArray->ProtocolType == ProtocolInfo->ProtocolType) {
            *ProtocolInfo = *InfoArray;
            ReturnValue = TRUE;
            break;
        }
    }

    NdisReleaseSpinLock(&ProtocolInfoTable->Lock);
    return (ReturnValue);
}

NDIS_HANDLE
InsertLinkInConnectionTable(
    IN  PLINKCB LinkCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   Index, i;
    PLINKCB *LinkArray;
    NDIS_STATUS Status;
    LOCK_STATE  LockState;

    NdisAcquireReadWriteLock(&ConnTableLock, TRUE, &LockState);

    if (ConnectionTable->ulNumActiveLinks >
        (ConnectionTable->ulArraySize - 1)/2) {
        //
        // We need to grow the table!
        //
        Status =
        NdisWanCreateConnectionTable(ConnectionTable->ulArraySize +
                                    (ConnectionTable->ulArraySize * 2));

        if (Status != NDIS_STATUS_SUCCESS) {
            NdisReleaseReadWriteLock(&ConnTableLock, &LockState);
            return (NULL);
        }
    }

    //
    // We are doing a linear search for an empty spot in
    // the link array
    //
    LinkArray = ConnectionTable->LinkArray;
    i = ConnectionTable->ulArraySize;
    Index = (ConnectionTable->ulNextLink == 0) ?
            1 : ConnectionTable->ulNextLink;
    do {

        if (LinkArray[Index] == NULL) {
            LinkArray[Index] = LinkCB;
            LinkCB->hLinkHandle = (NDIS_HANDLE)ULongToPtr(Index);
            ConnectionTable->ulNextLink = (Index+1) % ConnectionTable->ulArraySize;
            InterlockedIncrement(&glLinkCount);
            if (ConnectionTable->ulNumActiveLinks == 0) {
                hSystemState =
                PoRegisterSystemState(NULL, ES_SYSTEM_REQUIRED | ES_CONTINUOUS);
            }
            ConnectionTable->ulNumActiveLinks++;
            InsertTailList(&ConnectionTable->LinkList, 
                           &LinkCB->ConnTableLinkage);
            break;
        }
        Index = (Index+1) % ConnectionTable->ulArraySize;
        Index = (Index == 0) ? 1 : Index;
        i--;
    } while ( i );

    if (i == 0) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
            ("InsertLinkCB: ConnectionTable is full!"));
        Index = 0;      
    }

    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

    return ((NDIS_HANDLE)ULongToPtr(Index));
}

VOID
RemoveLinkFromConnectionTable(
    IN  PLINKCB LinkCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG    Index = PtrToUlong(LinkCB->hLinkHandle);
    PLINKCB *LinkArray;
    LOCK_STATE  LockState;

    NdisAcquireReadWriteLock(&ConnTableLock, TRUE, &LockState);

    LinkArray = ConnectionTable->LinkArray;
    
    do {

        if (Index == 0 || Index > ConnectionTable->ulArraySize) {
            NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                ("RemoveLinkCB: Invalid LinkHandle! Handle: %d\n", Index));
            ASSERT(0);
            break;
        }

        if (LinkArray[Index] == NULL) {
            NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                ("RemoveLinkCB: LinkCB not in connection table! LinkCB: %p\n", LinkCB));
            ASSERT(0);
            break;          
        }

        ASSERT(LinkCB == LinkArray[Index]);

        LinkArray[Index] = NULL;
    
        RemoveEntryList(&LinkCB->ConnTableLinkage);

        ConnectionTable->ulNumActiveLinks--;

        if (ConnectionTable->ulNumActiveLinks == 0) {
            PoUnregisterSystemState(hSystemState);
            hSystemState = NULL;
        }

    } while ( 0 );

    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);
}

NDIS_HANDLE
InsertBundleInConnectionTable(
    IN  PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   Index,i;
    PBUNDLECB   *BundleArray;
    NDIS_STATUS Status;
    LOCK_STATE  LockState;

    NdisAcquireReadWriteLock(&ConnTableLock, TRUE, &LockState);

    if (ConnectionTable->ulNumActiveBundles >
        (ConnectionTable->ulArraySize - 1)/2) {
        //
        // We need to grow the table!
        //
        Status =
            NdisWanCreateConnectionTable(ConnectionTable->ulArraySize +
                                        (ConnectionTable->ulArraySize * 2));

        if (Status != NDIS_STATUS_SUCCESS) {
            NdisReleaseReadWriteLock(&ConnTableLock, &LockState);
            return (NULL);
        }
    }

    //
    // We are doing a linear search for an empty spot in
    // the link array
    //
    BundleArray = ConnectionTable->BundleArray;
    i = ConnectionTable->ulArraySize;
    Index = (ConnectionTable->ulNextBundle == 0) ?
            1 : ConnectionTable->ulNextBundle;
    do {

        if (BundleArray[Index] == NULL) {
            BundleArray[Index] = BundleCB;
            ConnectionTable->ulNumActiveBundles++;
            BundleCB->hBundleHandle = (NDIS_HANDLE)ULongToPtr(Index);
            InsertTailList(&ConnectionTable->BundleList, &BundleCB->Linkage);
            ConnectionTable->ulNextBundle = (Index+1) % ConnectionTable->ulArraySize;
            break;
        }
        Index = (Index+1) % ConnectionTable->ulArraySize;
        Index = (Index == 0) ? 1 : Index;
        i--;
    } while ( i );

    if (i == 0) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
            ("InsertBundleCB: ConnectionTable is full!"));
        Index = 0;      
    }

    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

    return ((NDIS_HANDLE)ULongToPtr(Index));
}

VOID
RemoveBundleFromConnectionTable(
    IN  PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG        Index = PtrToUlong(BundleCB->hBundleHandle);
    PBUNDLECB   *BundleArray;
    LOCK_STATE  LockState;

    NdisAcquireReadWriteLock(&ConnTableLock, TRUE, &LockState);

    BundleArray = ConnectionTable->BundleArray;

    do {

        if (Index == 0 || Index > ConnectionTable->ulArraySize) {
            NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                ("RemoveBundleCB: Invalid BundleHandle! Handle: %d\n", Index));
            ASSERT(0);
            break;
        }

        if (BundleArray[Index] == NULL) {
            NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                ("RemoveBundleCB: BundleCB not in connection table! BundleCB: %p\n", BundleCB));
            ASSERT(0);
            break;          
        }

        ASSERT(BundleCB == BundleArray[Index]);

        RemoveEntryList(&BundleCB->Linkage);

        BundleArray[Index] = NULL;
    
        ConnectionTable->ulNumActiveBundles--;

    } while ( 0 );

    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);
}

VOID
NdisWanGlobalCleanup(
    VOID
    )
/*++

Routine Name:

    NdisWanGlobalCleanup

Routine Description:
    This routine is responsible for cleaning up all allocated resources.

Arguments:

    None

Return Values:

    None

--*/
{
    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("GlobalCleanup - Enter"));

    //
    // Stop all timers
    //

    //
    // Complete all outstanding requests
    //

    if (NdisWanCB.ProtocolHandle != NULL) {
        NDIS_STATUS Status;

        ASSERT(OpenCBList.ulCount == 0);

        NdisDeregisterProtocol(&Status,
                               NdisWanCB.ProtocolHandle);
        NdisWanCB.ProtocolHandle = NULL;
    }

    WanDeleteECP();
    WanDeleteVJ();

    //
    // Free all of the BundleCB's
    //

    //
    // Free all of the LinkCB's
    //

    ASSERT(IsListEmpty(&MiniportCBList.List));
    ASSERT(IsListEmpty(&OpenCBList.List));

    NdisFreeSpinLock(&MiniportCBList.Lock);
    NdisFreeSpinLock(&OpenCBList.Lock);
    NdisFreeSpinLock(&ThresholdEventQueue.Lock);
    NdisFreeSpinLock(&PacketPoolList.Lock);
    NdisFreeSpinLock(&IoRecvList.Lock);
    NdisDeleteNPagedLookasideList(&BundleCBList);
    NdisDeleteNPagedLookasideList(&LinkProtoCBList);
    NdisDeleteNPagedLookasideList(&LargeDataDescList);
    NdisDeleteNPagedLookasideList(&SmallDataDescList);
    NdisDeleteNPagedLookasideList(&WanRequestList);
    NdisDeleteNPagedLookasideList(&AfSapVcCBList);

#if DBG
    NdisDeleteNPagedLookasideList(&DbgPacketDescList);
#endif

    //
    // Free globals
    //
    if (ConnectionTable != NULL) {
        NdisWanFreeMemory(ConnectionTable);
        ConnectionTable = NULL;
    }

    if (ProtocolInfoTable != NULL) {
        NdisWanFreeMemory(ProtocolInfoTable);
        ProtocolInfoTable = NULL;
    }

    //
    // Free packet pool
    //
    NdisAcquireSpinLock(&PacketPoolList.Lock);

    while (!IsListEmpty(&PacketPoolList.List)) {
        PPOOL_DESC  PoolDesc;

        PoolDesc =
            (PPOOL_DESC)RemoveHeadList(&PacketPoolList.List);
    
        ASSERT(PoolDesc->AllocatedCount == 0);
            
        NdisFreePacketPool(PoolDesc->PoolHandle);

        NdisWanFreeMemory(PoolDesc);
    }

    NdisReleaseSpinLock(&PacketPoolList.Lock);

    NdisFreeSpinLock(&PacketPoolList.Lock);

#ifdef MY_DEVICE_OBJECT
    if (NdisWanCB.pDeviceObject != NULL) {
        NDIS_STRING SymbolicName = NDIS_STRING_CONST("\\DosDevices\\NdisWan");

        IoDeleteSymbolicLink(&SymbolicName);
        IoDeleteDevice(NdisWanCB.pDeviceObject);
        NdisWanCB.pDeviceObject = NULL;
    }
#else
    if (NdisWanCB.pDeviceObject != NULL) {
        NdisMDeregisterDevice(NdisWanCB.DeviceHandle);
        NdisWanCB.pDeviceObject = NULL;
    }
#endif

    NdisFreeSpinLock(&NdisWanCB.Lock);

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("GlobalCleanup - Exit"));
}

#if DBG     // Debug

PUCHAR
NdisWanGetNdisStatus(
    NDIS_STATUS GeneralStatus
    )
/*++

Routine Name:

    NdisWanGetNdisStatus

Routine Description:

    This routine returns a pointer to the string describing the NDIS error
    denoted by GeneralStatus

Arguments:

    GeneralStatus - The NDIS status you wish to make readable

Return Values:

    Returns a pointer to a string describing GeneralStatus

--*/
{
    static NDIS_STATUS Status[] = {
        NDIS_STATUS_SUCCESS,
        NDIS_STATUS_PENDING,

        NDIS_STATUS_ADAPTER_NOT_FOUND,
        NDIS_STATUS_ADAPTER_NOT_OPEN,
        NDIS_STATUS_ADAPTER_NOT_READY,
        NDIS_STATUS_ADAPTER_REMOVED,
        NDIS_STATUS_BAD_CHARACTERISTICS,
        NDIS_STATUS_BAD_VERSION,
        NDIS_STATUS_CLOSING,
        NDIS_STATUS_DEVICE_FAILED,
        NDIS_STATUS_FAILURE,
        NDIS_STATUS_INVALID_DATA,
        NDIS_STATUS_INVALID_LENGTH,
        NDIS_STATUS_INVALID_OID,
        NDIS_STATUS_INVALID_PACKET,
        NDIS_STATUS_MULTICAST_FULL,
        NDIS_STATUS_NOT_INDICATING,
        NDIS_STATUS_NOT_RECOGNIZED,
        NDIS_STATUS_NOT_RESETTABLE,
        NDIS_STATUS_NOT_SUPPORTED,
        NDIS_STATUS_OPEN_FAILED,
        NDIS_STATUS_OPEN_LIST_FULL,
        NDIS_STATUS_REQUEST_ABORTED,
        NDIS_STATUS_RESET_IN_PROGRESS,
        NDIS_STATUS_RESOURCES,
        NDIS_STATUS_UNSUPPORTED_MEDIA
    };
    static PUCHAR String[] = {
        "SUCCESS",
        "PENDING",

        "ADAPTER_NOT_FOUND",
        "ADAPTER_NOT_OPEN",
        "ADAPTER_NOT_READY",
        "ADAPTER_REMOVED",
        "BAD_CHARACTERISTICS",
        "BAD_VERSION",
        "CLOSING",
        "DEVICE_FAILED",
        "FAILURE",
        "INVALID_DATA",
        "INVALID_LENGTH",
        "INVALID_OID",
        "INVALID_PACKET",
        "MULTICAST_FULL",
        "NOT_INDICATING",
        "NOT_RECOGNIZED",
        "NOT_RESETTABLE",
        "NOT_SUPPORTED",
        "OPEN_FAILED",
        "OPEN_LIST_FULL",
        "REQUEST_ABORTED",
        "RESET_IN_PROGRESS",
        "RESOURCES",
        "UNSUPPORTED_MEDIA"
    };

    static UCHAR BadStatus[] = "UNDEFINED";
#define StatusCount (sizeof(Status)/sizeof(NDIS_STATUS))
    INT i;

    for (i=0; i<StatusCount; i++)
        if (GeneralStatus == Status[i])
            return String[i];
    return BadStatus;
#undef StatusCount
}
#endif      // End Debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\loopback.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Loopback.c

Abstract:

    This file contains the procedures for doing loopback of send
    packets for ndiswan.  Loopback is being done in NdisWan because
    the NDIS wrapper could not meet all of the needs of NdisWan.

Author:

    Tony Bell   (TonyBe) January 25, 1996

Environment:

    Kernel Mode

Revision History:

    TonyBe  01/25/96    Created

--*/

#include "wan.h"

#define __FILE_SIG__    LOOPBACK_FILESIG

VOID
NdisWanIndicateLoopbackPacket(
    PMINIPORTCB     MiniportCB,
    PNDIS_PACKET    NdisPacket
    )
{
    ULONG           BytesCopied, PacketLength;
    PRECV_DESC      RecvDesc;
    PNDIS_PACKET    LocalNdisPacket;
    PNDIS_BUFFER    NdisBuffer;
    NDIS_STATUS     Status;
    PCM_VCCB        CmVcCB;
    KIRQL           OldIrql;

    NdisWanDbgOut(DBG_TRACE, DBG_LOOPBACK, ("NdisWanIndicateLoopbackPacket: Enter"));
    NdisWanDbgOut(DBG_INFO, DBG_LOOPBACK, ("MiniportCB: 0x%p, NdisPacket: 0x%p",
               MiniportCB, NdisPacket));

    NdisQueryPacket(NdisPacket,
                    NULL,
                    NULL,
                    NULL,
                    &PacketLength);

    RecvDesc = 
        NdisWanAllocateRecvDesc(PacketLength);

    if (RecvDesc == NULL) {
        return;
    }

    NdisWanCopyFromPacketToBuffer(NdisPacket,
                                  0,
                                  PacketLength,
                                  RecvDesc->StartBuffer,
                                  &BytesCopied);

    ASSERT(BytesCopied == PacketLength);

    if (MiniportCB->ProtocolType == PROTOCOL_IP) {
        UCHAR   x[ETH_LENGTH_OF_ADDRESS];
        //
        // If this is IP we are going to assume
        // that wanarp has set the appropriate
        // bit requiring ndiswan to loopback the
        // packet so we must switch the src/dest
        // contexts.
        ETH_COPY_NETWORK_ADDRESS(x, &RecvDesc->StartBuffer[6]);
        ETH_COPY_NETWORK_ADDRESS(&RecvDesc->StartBuffer[6], 
                                 &RecvDesc->StartBuffer[0]);
        ETH_COPY_NETWORK_ADDRESS(&RecvDesc->StartBuffer[0], x);
    }

    RecvDesc->CurrentLength = PacketLength;

    LocalNdisPacket = 
        RecvDesc->NdisPacket;

    NdisBuffer =
        RecvDesc->NdisBuffer;

    //
    // Attach the buffers
    //
    NdisAdjustBufferLength(NdisBuffer,
                           RecvDesc->CurrentLength);

    NdisRecalculatePacketCounts(LocalNdisPacket);

    CmVcCB =
        PMINIPORT_RESERVED_FROM_NDIS(NdisPacket)->CmVcCB;

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    NDIS_SET_PACKET_STATUS(LocalNdisPacket, NDIS_STATUS_RESOURCES);

    INSERT_DBG_RECV(PacketTypeNdis, MiniportCB, NULL, NULL, LocalNdisPacket);

    //
    // Indicate the packet
    //
    if (CmVcCB != NULL) {

        NdisMCoIndicateReceivePacket(CmVcCB->NdisVcHandle,
                                     &LocalNdisPacket,
                                     1);
    } else {

        NdisMIndicateReceivePacket(MiniportCB->MiniportHandle,
                                   &LocalNdisPacket,
                                   1);
    }

    KeLowerIrql(OldIrql);

#if DBG
    Status = NDIS_GET_PACKET_STATUS(LocalNdisPacket);

    ASSERT(Status == NDIS_STATUS_RESOURCES);
#endif

    REMOVE_DBG_RECV(PacketTypeNdis, MiniportCB, LocalNdisPacket);

    NdisWanFreeRecvDesc(RecvDesc);

    NdisWanDbgOut(DBG_TRACE, DBG_LOOPBACK, ("NdisWanIndicateLoopbackPacket: Exit"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\oidadd.h ===
//
// Information that applies to all VC's
// on this adapter.
//
// Struct: NDIS_WAN_CO_GET_INFO
//
#define OID_WAN_CO_GET_INFO				0x04010180

//
// Set VC specific PPP framing information.
//
// Struct: NDIS_WAN_CO_SET_LINK_INFO
//
#define OID_WAN_CO_SET_LINK_INFO		0x04010181

//
// Get VC specific PPP framing information.
//
// Struct: NDIS_WAN_CO_GET_LINK_INFO
//
#define OID_WAN_CO_GET_LINK_INFO		0x04010182

//
// Get VC specific PPP compression information
//
// Struct: NDIS_WAN_CO_GET_COMP_INFO
//
#define OID_WAN_CO_GET_COMP_INFO		0x04010280

//
// Set VC specific PPP compression information
//
// Struct: NDIS_WAN_CO_SET_COMP_INFO
//
#define OID_WAN_CO_SET_COMP_INFO		0x04010281

//
// Get VC specific statistics
//
// Struct: NDIS_WAN_CO_GET_STATS_INFO
//
#define OID_WAN_CO_GET_STATS_INFO		0x04010282

//
// Other OID's NdisWan will call...
//
//////////////////////////////////////////////////////
// OID_GEN_MAXIMUM_SEND_PACKETS:
//
// This will be used as the SendWindow between NdisWan
// and the miniport.  The query applies to all VC's on
// the AddressFamily.
//
//////////////////////////////////////////////////////
// OID_GEN_MAXIMUM_TOTAL_SIZE:
//
// This is used to query the largest send that a
// miniport can accept.  The query applies to all VC's
// on the AddressFamily.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\miniport.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Miniport.c

Abstract:

    This file contains the procedures that makeup most of the NDIS 3.1
    Miniport interface.


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "wan.h"

#define __FILE_SIG__    MINIPORT_FILESIG

//
// Local function prototypes
//

//
// End local function prototypes
//

VOID
MPHalt(
    IN  NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Name:

    MPHalt

Routine Description:

    This routine free's all resources for the adapter.

Arguments:

    MiniportAdapterContext - AdapterContext that is given to the wrapper in
                             NdisMSetAttributes call.  Is our MiniportCB.

Return Values:

    None

--*/
{
    PMINIPORTCB MiniportCB = (PMINIPORTCB)MiniportAdapterContext;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPHalt: Enter"));
    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MiniportCB: 0x%x", MiniportCB));

    //
    // Make sure that there are no ProtocolCB's
    // running over this miniport!  If so we
    // need to do a linedown to them.
    //
    NdisAcquireSpinLock(&MiniportCB->Lock);

    MiniportCB->Flags |= HALT_IN_PROGRESS;

    while (!IsListEmpty(&MiniportCB->ProtocolCBList)) {
        PLIST_ENTRY le;
        PPROTOCOLCB ProtocolCB;
        PBUNDLECB   BundleCB;
        ProtocolState   OldState;

        le = MiniportCB->ProtocolCBList.Flink;

        ProtocolCB =(PPROTOCOLCB)
            CONTAINING_RECORD(le, PROTOCOLCB, MiniportLinkage);

        NdisReleaseSpinLock(&MiniportCB->Lock);

        BundleCB = ProtocolCB->BundleCB;

        AcquireBundleLock(BundleCB);

        OldState = ProtocolCB->State;

        ProtocolCB->State = PROTOCOL_UNROUTING;
        BundleCB->SendMask &= ~ProtocolCB->SendMaskBit;
    
        //
        // Flush the protocol packet queues.  This could cause us
        // to complete frames to ndis out of order.  Ndis should
        // handle this.
        //
        FlushProtocolPacketQueue(ProtocolCB);
    
        //
        // If the protocols refcount goes to zero
        // we need to do a linedown and cleanup
        //
        if ((--ProtocolCB->RefCount == 0) &&
            (OldState == PROTOCOL_ROUTED)) {

            DoLineDownToProtocol(ProtocolCB);

            //
            // Returns with bundlecb->lock released
            //
            RemoveProtocolCBFromBundle(ProtocolCB);

            ReleaseBundleLock(BundleCB);

            NdisWanFreeProtocolCB(ProtocolCB);

        } else {

            ReleaseBundleLock(BundleCB);

            NdisWanWaitForSyncEvent(&MiniportCB->HaltEvent);

            NdisWanClearSyncEvent(&MiniportCB->HaltEvent);
        }

        NdisAcquireSpinLock(&MiniportCB->Lock);
    }

    NdisReleaseSpinLock(&MiniportCB->Lock);

    DEREF_MINIPORTCB(MiniportCB);

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPHalt: Exit"));
}

NDIS_STATUS
MPInitialize(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN  PNDIS_MEDIUM    MediumArray,
    IN  UINT            MediumArraySize,
    IN  NDIS_HANDLE     MiniportAdapterHandle,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    )
/*++

Routine Name:

    MPInitialize

Routine Description:

    This routine is called after NdisWan registers itself as a Miniport driver.
    It is responsible for installing NdisWan as a Miniport driver, creating
    adapter control blocks for each adapter NdisWan exposes (should only be 1),
    and initializing all adapter specific variables


Arguments:

    OpenErrorStatus - Returns information about the error if this function
                      returns NDIS_STATUS_OPEN_ERROR. Used for TokenRing.

    SelectedMediumIndex - An index into the MediumArray that specifies the
                          medium type of this driver. Should be WAN or 802.3

    MediumArray - An array of medium types supported by the NDIS library

    MediumArraySize - Size of the medium array

    MiniportAdapterHandle - Handle assigned by the NDIS library that defines
                            this miniport driver.  Used as handle in subsequent
                            calls to the NDIS library.

    WrapperConfigurationContext - Handle used to read configuration information
                                  from the registry

Return Values:

    NDIS_STATUS_ADAPTER_NOT_FOUND
    NDIS_STATUS_FAILURE
    NDIS_STATUS_NOT_ACCEPTED
    NDIS_STATUS_OPEN_ERROR
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_UNSUPPORTED_MEDIA

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PMINIPORTCB MiniportCB;
    UINT        Index;
    NDIS_HANDLE ConfigHandle;
    ULONG       NetworkAddressLength;
#ifdef NT
    LARGE_INTEGER   TickCount, SystemTime;
#endif

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPInitialize: Enter"));

    //
    // We have to be type 802.3 to the ndis wrapper, but the
    // wrapper will expose us to the transports as type wan.
    //
    for (Index = 0; Index < MediumArraySize; Index++) {

        if (MediumArray[Index] == NdisMedium802_3) {
            break;
        }
    }

    //
    // We don't have a match so we are screwed
    //
    if (Index == MediumArraySize) {
        return (NDIS_STATUS_UNSUPPORTED_MEDIA);
    }

    *SelectedMediumIndex = Index;

    //
    // Allocate and initialize miniport adapter structure
    //
#ifdef MINIPORT_NAME
    MiniportCB = NdisWanAllocateMiniportCB(&((PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle))->MiniportName);
#else
    MiniportCB = NdisWanAllocateMiniportCB(NULL);
#endif

    if (MiniportCB == NULL) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MINIPORT,
                     ("Error Creating MiniportCB!"));
        return (NDIS_STATUS_FAILURE);
    }

#ifndef MY_DEVICE_OBJECT
    if (NdisWanCB.pDeviceObject == NULL) {
        PDRIVER_DISPATCH DispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1];
        NDIS_STRING SymbolicName = NDIS_STRING_CONST("\\DosDevices\\NdisWan");
        NDIS_STRING Name = NDIS_STRING_CONST("\\Device\\NdisWan");
        ULONG   i;
        NTSTATUS    retStatus;


        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
    
            DispatchTable[i] = NdisWanIrpStub;
        }
    
        DispatchTable[IRP_MJ_CREATE] = NdisWanCreate;
        DispatchTable[IRP_MJ_DEVICE_CONTROL] = NdisWanIoctl;
        DispatchTable[IRP_MJ_CLEANUP] = NdisWanCleanup;

        retStatus =
        NdisMRegisterDevice(NdisWanCB.NdisWrapperHandle,
                            &Name,
                            &SymbolicName,
                            DispatchTable,
                            &NdisWanCB.pDeviceObject,
                            &NdisWanCB.DeviceHandle);

        if (retStatus == STATUS_SUCCESS) {
            NdisWanCB.pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        } else {
            NdisWanCB.pDeviceObject = NULL;
        }
    }
#endif

    NdisMSetAttributesEx(MiniportAdapterHandle,
                         MiniportCB,
                         (UINT)-1,
//
// KyleB says that the following two defines are redundant if
// the miniport is deserialized.
//
//                       NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT   |
//                       NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER     |
                         NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT  |
                         NDIS_ATTRIBUTE_DESERIALIZE             |
                         NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
                         NdisInterfaceInternal);

    MiniportCB->MediumType = MediumArray[Index];
    MiniportCB->RefCount = 0;
    MiniportCB->MiniportHandle = MiniportAdapterHandle;

    //
    // Read per miniport instance data
    //
    NdisOpenConfiguration(&Status,
                          &ConfigHandle,
                          WrapperConfigurationContext);

    if (Status == NDIS_STATUS_SUCCESS) {
        
        NdisReadNetworkAddress(&Status,
                               (PVOID*)&(MiniportCB->NetworkAddress),
                               &NetworkAddressLength,
                               ConfigHandle);

        NdisCloseConfiguration(ConfigHandle);

        if (Status != NDIS_STATUS_SUCCESS ||
            NetworkAddressLength != ETH_LENGTH_OF_ADDRESS) {

            goto BuildAddress;
            
        }


    } else {

BuildAddress:

#ifdef NT

        KeQueryTickCount(&TickCount);
        KeQuerySystemTime(&SystemTime);

        MiniportCB->NetworkAddress[0] = (UCHAR)((TickCount.LowPart >> 16) ^
                                                (SystemTime.LowPart >> 16)) &
                                                0xFE;

        MiniportCB->NetworkAddress[1] = (UCHAR)((TickCount.LowPart >> 8) ^
                                                (SystemTime.LowPart >> 8));

        //
        // The following 4 bytes will be filled in at lineup time
        //
        MiniportCB->NetworkAddress[2] = ' ';
        MiniportCB->NetworkAddress[3] = 'R';
        MiniportCB->NetworkAddress[4] = 'A';
        MiniportCB->NetworkAddress[5] = 'S';
#endif

    }

    //
    // Register our connection manager address family for this
    // miniport
    //
    {

    CO_ADDRESS_FAMILY   CoAddressFamily;
    NDIS_CALL_MANAGER_CHARACTERISTICS CmCharacteristics;

    NdisZeroMemory(&CmCharacteristics,
                   sizeof(NDIS_CALL_MANAGER_CHARACTERISTICS));

    CoAddressFamily.AddressFamily = CO_ADDRESS_FAMILY_PPP;
    CoAddressFamily.MajorVersion = NDISWAN_MAJOR_VERSION;
    CoAddressFamily.MinorVersion = NDISWAN_MINOR_VERSION;

    CmCharacteristics.MajorVersion = NDISWAN_MAJOR_VERSION;
    CmCharacteristics.MinorVersion = NDISWAN_MINOR_VERSION;

    CmCharacteristics.CmCreateVcHandler = CmCreateVc;
    CmCharacteristics.CmDeleteVcHandler = CmDeleteVc;

    CmCharacteristics.CmOpenAfHandler = CmOpenAf;
    CmCharacteristics.CmCloseAfHandler = CmCloseAf;
    CmCharacteristics.CmRegisterSapHandler = CmRegisterSap;
    CmCharacteristics.CmDeregisterSapHandler = CmDeregisterSap;
    CmCharacteristics.CmMakeCallHandler = CmMakeCall;
    CmCharacteristics.CmCloseCallHandler = CmCloseCall;
    CmCharacteristics.CmIncomingCallCompleteHandler = CmIncomingCallComplete;
    CmCharacteristics.CmAddPartyHandler = NULL;
    CmCharacteristics.CmDropPartyHandler = NULL;
    CmCharacteristics.CmActivateVcCompleteHandler = CmActivateVcComplete;
    CmCharacteristics.CmDeactivateVcCompleteHandler = CmDeactivateVcComplete;
    CmCharacteristics.CmModifyCallQoSHandler = CmModifyCallQoS;
    CmCharacteristics.CmRequestHandler = CmRequest;
    CmCharacteristics.CmRequestCompleteHandler = ProtoCoRequestComplete;


    NdisMCmRegisterAddressFamily(MiniportCB->MiniportHandle,
                                 &CoAddressFamily,
                                 &CmCharacteristics,
                                 sizeof(NDIS_CALL_MANAGER_CHARACTERISTICS));
    }

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPInitialize: Exit"));

    REF_MINIPORTCB(MiniportCB);

    return (NDIS_STATUS_SUCCESS);
}

#if 0
NDIS_STATUS
MPQueryInformation(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PMINIPORTCB MiniportCB = (PMINIPORTCB)MiniportAdapterContext;
    NDIS_REQUEST    NdisRequest;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPQueryInformation: Enter Oid: 0x%x", Oid));

    NdisWanInterlockedInc(&MiniportCB->RefCount);

    NdisRequest.RequestType =
        NdisRequestQueryInformation;

    NdisRequest.DATA.QUERY_INFORMATION.Oid =
        Oid;

    NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer =
        InformationBuffer;

    NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength =
        InformationBufferLength;

    NdisRequest.DATA.QUERY_INFORMATION.BytesWritten =
        *BytesWritten;

    NdisRequest.DATA.QUERY_INFORMATION.BytesNeeded =
        *BytesNeeded;

    Status = NdisWanOidProc(MiniportCB, &NdisRequest);

    *BytesWritten = NdisRequest.DATA.QUERY_INFORMATION.BytesWritten;
    *BytesNeeded = NdisRequest.DATA.QUERY_INFORMATION.BytesNeeded;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPQueryInformation: Exit Status: %x", Status));

    NdisWanInterlockedDec(&MiniportCB->RefCount);

    return (Status);
}
#endif

NDIS_STATUS
MPReconfigure(
    OUT PNDIS_STATUS    OpenErrorStatus,
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PMINIPORTCB MiniportCB = (PMINIPORTCB)MiniportAdapterContext;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPReconfigure: Enter"));

    NdisWanInterlockedInc(&MiniportCB->RefCount);

    NdisWanInterlockedDec(&MiniportCB->RefCount);

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPReconfigure: Exit"));
    return (Status);
}

NDIS_STATUS
MPReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PMINIPORTCB MiniportCB = (PMINIPORTCB)MiniportAdapterContext;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPReset: Enter"));

    *AddressingReset = FALSE;

    NdisWanInterlockedInc(&MiniportCB->RefCount);

    NdisAcquireSpinLock(&MiniportCB->Lock);

    MiniportCB->Flags &= ~ASK_FOR_RESET;

    NdisReleaseSpinLock(&MiniportCB->Lock);

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPReset: Exit"));

    NdisWanInterlockedDec(&MiniportCB->RefCount);

    return (Status);
}

#if 0
NDIS_STATUS
MPSetInformation(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PMINIPORTCB MiniportCB = (PMINIPORTCB)MiniportAdapterContext;
    NDIS_REQUEST    NdisRequest;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPSetInformation: Enter Oid: 0x%x", Oid));

    NdisWanInterlockedInc(&MiniportCB->RefCount);

    NdisRequest.RequestType =
        NdisRequestSetInformation;

    NdisRequest.DATA.SET_INFORMATION.Oid =
        Oid;

    NdisRequest.DATA.SET_INFORMATION.InformationBuffer =
        InformationBuffer;

    NdisRequest.DATA.SET_INFORMATION.InformationBufferLength =
        InformationBufferLength;

    NdisRequest.DATA.SET_INFORMATION.BytesRead =
        *BytesWritten;

    NdisRequest.DATA.SET_INFORMATION.BytesNeeded =
        *BytesNeeded;

    Status = NdisWanOidProc(MiniportCB, &NdisRequest);

    *BytesWritten = NdisRequest.DATA.SET_INFORMATION.BytesRead;
    *BytesNeeded = NdisRequest.DATA.SET_INFORMATION.BytesNeeded;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPSetInformation: Exit"));

    NdisWanInterlockedDec(&MiniportCB->RefCount);

    return (Status);
}
#endif

VOID
MPReturnPacket(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PNDIS_PACKET    Packet
    )
{
    PNDISWAN_PROTOCOL_RESERVED  pres;
    PMINIPORTCB     MiniportCB;
    PNDIS_BUFFER    NdisBuffer;
    PRECV_DESC  RecvDesc;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("MPReturnPacket: Enter Packet %p", Packet));

    pres = PPROTOCOL_RESERVED_FROM_NDIS(Packet);

    MiniportCB = (PMINIPORTCB)MiniportAdapterContext;

    RecvDesc = pres->RecvDesc;

    REMOVE_DBG_RECV(PacketTypeNdis, MiniportCB, Packet);

    NdisWanFreeRecvDesc(RecvDesc);

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("MPReturnPacket: Exit"));
}

VOID
MPSendPackets(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PPNDIS_PACKET   PacketArray,
    IN  UINT            NumberOfPackets
    )
{
    ULONG   i;
    PMINIPORTCB MiniportCB = (PMINIPORTCB)MiniportAdapterContext;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("MPSendPackets: Enter"));

    for (i = 0; i < NumberOfPackets; i++) {
        PNDIS_PACKET    NdisPacket = PacketArray[i];

        PMINIPORT_RESERVED_FROM_NDIS(NdisPacket)->CmVcCB = NULL;

        NdisWanQueueSend(MiniportCB,
                         NdisPacket);
        
    }

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("MPSendPackets: Exit"));
}

NDIS_STATUS
MPCoCreateVc(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     NdisVcHandle,
    OUT PNDIS_HANDLE    MiniportVcContext
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoCreateVc: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoCreateVc: Exit"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
MPCoDeleteVc(
    IN  NDIS_HANDLE MiniportVcContext
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoDeleteVc: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoDeleteVc: Exit"));
    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
MPCoActivateVc(
    IN  NDIS_HANDLE             MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoActivateVc: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoActivateVc: Exit"));
    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
MPCoDeactivateVc(
    IN  NDIS_HANDLE MiniportVcContext
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoDeactivateVc: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoDeactivateVc: Exit"));
    return (NDIS_STATUS_SUCCESS);
}

VOID
MPCoSendPackets(
    IN  NDIS_HANDLE     MiniportVcContext,
    IN  PPNDIS_PACKET   PacketArray,
    IN  UINT            NumberOfPackets
    )
{
    ULONG   i;
    PCM_VCCB    CmVcCB  = (PCM_VCCB)MiniportVcContext;
    PCM_AFSAPCB AfSapCB = CmVcCB->AfSapCB;
    PMINIPORTCB MiniportCB = AfSapCB->MiniportCB;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("MPCoSendPackets: Enter"));

    if (CmVcCB->State != CMVC_ACTIVE) {

        for (i = 0; i < NumberOfPackets; i++) {
            PNDIS_PACKET    NdisPacket = PacketArray[i];

            NdisMCoSendComplete(NDIS_STATUS_FAILURE,
                                CmVcCB->NdisVcHandle,
                                NdisPacket);
        }

        return;
    }

    for (i = 0; i < NumberOfPackets; i++) {
        PNDIS_PACKET    NdisPacket = PacketArray[i];

        REF_CMVCCB(CmVcCB);

        PMINIPORT_RESERVED_FROM_NDIS(NdisPacket)->CmVcCB = CmVcCB;

        NdisWanQueueSend(MiniportCB,
                         NdisPacket);
        
    }

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("MPCoSendPackets: Exit"));
}

NDIS_STATUS
MPCoRequest(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             MiniportVcContext   OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    )
{
    NDIS_STATUS Status;
    PCM_VCCB    CmVcCB;

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoRequest: Enter Oid: 0x%x",
        NdisRequest->DATA.QUERY_INFORMATION.Oid));

    CmVcCB = (PCM_VCCB)MiniportVcContext;

    Status =
        NdisWanCoOidProc((PMINIPORTCB)MiniportAdapterContext,
                         CmVcCB,
                         NdisRequest);

    NdisWanDbgOut(DBG_TRACE, DBG_MINIPORT, ("MPCoRequest: Exit Status: 0x%x", Status));

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\memory.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Ndiswan.c

Abstract:

    This is the initialization file for the NdisWan driver.  This driver
    is a shim between the protocols, where it conforms to the NDIS 3.1
    Miniport interface spec, and the WAN Miniport drivers, where it exports
    the WAN Extensions for Miniports (it looks like a protocol to the WAN
    Miniport drivers).

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "wan.h"

#define __FILE_SIG__    MEMORY_FILESIG

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, NdisWanCreateProtocolInfoTable)
#endif

EXPORT
VOID
NdisTapiDeregisterProvider(
    IN  NDIS_HANDLE
    );

//
// Local function prototypes
//
PVOID
AllocateWanPacket(
    IN  POOL_TYPE   PoolType,
    IN  SIZE_T      NumberOfBytes,
    IN  ULONG       Tag
    );

VOID
FreeWanPacket(
    PVOID   WanPacket
    );

//
// End local function prototypes
//

PMINIPORTCB
NdisWanAllocateMiniportCB(
    IN  PNDIS_STRING    AdapterName
    )
/*++

Routine Name:

    NdisWanAllocateMiniportCB

Routine Description:

    This routine creates and initializes an MiniportCB

Arguments:

Return Values:

--*/
{
    PMINIPORTCB LocalMiniportCB;
    ULONG       ulAllocationSize, i;

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanCreateMiniportCB: Enter"));

    //
    // Allocate and zero out the memory block
    //
    NdisWanAllocateMemory(&LocalMiniportCB, MINIPORTCB_SIZE, MINIPORTCB_TAG);

    if (LocalMiniportCB == NULL) {

        return (NULL);
    }

    NdisZeroMemory(LocalMiniportCB, MINIPORTCB_SIZE);

    //
    // setup the new control block
    //
    NdisAllocateSpinLock(&LocalMiniportCB->Lock);

#ifdef MINIPORT_NAME
    NdisWanAllocateAdapterName(&LocalMiniportCB->AdapterName, AdapterName);
#endif

#if DBG
    InitializeListHead(&LocalMiniportCB->SendPacketList);
    InitializeListHead(&LocalMiniportCB->RecvPacketList);
#endif

    InitializeListHead(&LocalMiniportCB->ProtocolCBList);
    InitializeListHead(&LocalMiniportCB->AfSapCBList);

    NdisWanInitializeSyncEvent(&LocalMiniportCB->HaltEvent);
    NdisWanClearSyncEvent(&LocalMiniportCB->HaltEvent);

    //
    // Add to global list
    //
    InsertTailGlobalList(MiniportCBList, &(LocalMiniportCB->Linkage));

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("%ls MiniportCB: 0x%x, Number: %d",
                         LocalMiniportCB->AdapterName.Buffer, LocalMiniportCB, MiniportCBList.ulCount));

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanCreateMiniportCB: Exit"));

    return (LocalMiniportCB);
}

VOID
NdisWanFreeMiniportCB(
    IN  PMINIPORTCB pMiniportCB
    )
/*++

Routine Name:

    NdisWanFreeMiniportCB

Routine Description:

    This frees a MiniportCB

Arguments:

    pMiniportCB - Pointer to to the MiniportCB that is being destroyed

Return Values:

    None

--*/
{
    PMINIPORTCB mcb;
    BOOLEAN     Found = FALSE;

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanFreeMiniportCB: Enter"));
    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("MiniportCB: 0x%x", pMiniportCB));

#ifdef MINIPORT_NAME
    NdisWanFreeNdisString(&pMiniportCB->AdapterName);
#endif

    NdisFreeSpinLock(&pMiniportCB->Lock);

    NdisAcquireSpinLock(&MiniportCBList.Lock);

    RemoveEntryList(&pMiniportCB->Linkage);

    MiniportCBList.ulCount--;

    //
    // Walk the miniportcb list and see if this is the only
    // instance of this protocol.  If it is we need to notify
    // user-mode that a protocol has been removed.
    //
    mcb = (PMINIPORTCB)MiniportCBList.List.Flink;

    while ((PVOID)mcb != (PVOID)&MiniportCBList.List) {
        if (mcb->ProtocolType == pMiniportCB->ProtocolType) {
            Found = TRUE;
            break;
        }

        mcb = (PMINIPORTCB)mcb->Linkage.Flink;
    }

    NdisReleaseSpinLock(&MiniportCBList.Lock);

    if (Found == FALSE) {
        PROTOCOL_INFO  pinfo;

        NdisZeroMemory(&pinfo, sizeof(pinfo));
        pinfo.ProtocolType = pMiniportCB->ProtocolType;
        pinfo.Flags = PROTOCOL_UNBOUND;
        SetProtocolInfo(&pinfo);
    }

    NdisWanFreeMemory(pMiniportCB);

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanFreeMiniportCB: Exit"));
}

POPENCB
NdisWanAllocateOpenCB(
    IN  PUNICODE_STRING BindName
    )
/*++

Routine Name:

    NdisWanAllocateOpenCB

Routine Description:

    This routine creates and initializes a OpenCB

Arguments:

    BindName - Pointer to an NDIS_STRING that has the name of the WAN Miniport
               that will be used in the NdisOpenAdapter call when we bind to
               the WAN Miniport.

Return Values:

--*/
{
    POPENCB pOpenCB;
    ULONG   ulAllocationSize;
    USHORT  i;

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanCreateOpenCB: Enter"));
    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("BindName: %ls", BindName));

    //
    // Allocate memory for OpenCB
    //
    NdisWanAllocateMemory(&pOpenCB, OPENCB_SIZE, OPENCB_TAG);

    if (pOpenCB == NULL) {
        return (NULL);
    }

    NdisZeroMemory(pOpenCB, OPENCB_SIZE);
    NdisWanInitializeNotificationEvent(&pOpenCB->InitEvent);

    //
    // Parse out the GUID for this miniport
    //


    //
    // Setup new control block
    //
    NdisWanAllocateMemory(&pOpenCB->MiniportName.Buffer, BindName->MaximumLength, NDISSTRING_TAG);
    pOpenCB->MiniportName.MaximumLength = BindName->MaximumLength;
    pOpenCB->MiniportName.Length = BindName->Length;
    RtlCopyUnicodeString(&pOpenCB->MiniportName, BindName);

    //
    // Go to the end of the string and work back until we find
    // the first "{".  Now start parsing the string converting
    // and copying from WCHAR to CHAR all digits until we hit
    // the closing "}".
    //
    for (i = pOpenCB->MiniportName.Length/sizeof(WCHAR); i > 0; i--) {
        if (pOpenCB->MiniportName.Buffer[i-1] == (WCHAR)L'{') {
            break;
        }
    }

    if (i != 0) {
        NDIS_STRING Src;

        Src.Length =
            BindName->Length - ((i-1)*sizeof(WCHAR));
        Src.MaximumLength =
            BindName->Length - ((i-1)*sizeof(WCHAR));
        Src.Buffer = &BindName->Buffer[i-1];

        RtlGUIDFromString(&Src, &pOpenCB->Guid);
    }

    NdisAllocateSpinLock(&pOpenCB->Lock);
    InitializeListHead(&pOpenCB->AfSapCBList);
    InitializeListHead(&pOpenCB->AfSapCBClosing);
    InitializeListHead(&pOpenCB->WanRequestList);

#if DBG
    InitializeListHead(&pOpenCB->SendPacketList);
#endif

    //
    // Put OpenCB on global list
    //
    InsertTailGlobalList(OpenCBList, &(pOpenCB->Linkage));

    pOpenCB->RefCount = 1;

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("WanMiniport %ls OpenCB: 0x%x",
                                      pOpenCB->MiniportName.Buffer, pOpenCB));
    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanCreateOpenCB: Exit"));

    return(pOpenCB);
}

VOID
NdisWanFreeOpenCB(
    IN  POPENCB pOpenCB
    )
/*++

Routine Name:

    NdisWanFreeOpenCB

Routine Description:

    This routine frees a OpenCB

Arguments:

    pOpenCB - Pointer to the OpenCB that is being destroyed

Return Values:

    None

--*/
{
    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanFreeOpenCB: Enter - OpenCB: 0x%p", pOpenCB));

    if (pOpenCB->Flags & OPEN_LEGACY &&
        pOpenCB->Flags & SEND_RESOURCES) {
        NdisWanFreeSendResources(pOpenCB);
    }

    //
    // Remove from OpenCB global list
    //
    RemoveEntryGlobalList(OpenCBList, &(pOpenCB->Linkage));

    //
    // Free the memory allocated for the NDIS_STRING
    //
    NdisWanFreeNdisString(&pOpenCB->MiniportName);

    //
    // Free the memory allocated for the control block
    //
    NdisWanFreeMemory(pOpenCB);

    NdisWanDbgOut(DBG_TRACE, DBG_MEMORY, ("NdisWanFreeOpenCB: Exit"));
}

PPROTOCOLCB
NdisWanAllocateProtocolCB(
    IN  PNDISWAN_ROUTE  Route
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PPROTOCOLCB     LocalProtocolCB;
    PUCHAR          AllocatedMemory;
    PROTOCOL_INFO   ProtocolInfo = {0};

    LocalProtocolCB =
        NdisAllocateFromNPagedLookasideList(&LinkProtoCBList);

    if (LocalProtocolCB == NULL) {
        return(NULL);
    }

    NdisZeroMemory(LocalProtocolCB, PROTOCOLCB_SIZE);

    LocalProtocolCB->Signature = PROTOCB_SIG;

    if (Route->ulBufferLength > 0) {
        NdisWanAllocateMemory(&AllocatedMemory,
                              Route->ulBufferLength,
                              PROTOCOLCB_TAG);
    
        if (AllocatedMemory == NULL) {
            NdisFreeToNPagedLookasideList(&LinkProtoCBList, LocalProtocolCB);
            return (NULL);
        }

        LocalProtocolCB->LineUpInfo = AllocatedMemory;
    }

    //
    // Copy the bindingname
    //
    if (Route->usBindingNameLength != 0) {
        USHORT  usBindingNameLength;
        WCHAR   BindingName[MAX_NAME_LENGTH+1] = {0};

        usBindingNameLength = Route->usBindingNameLength;

        //
        // We will limit the binding name string to 256 wchars
        //
        if (usBindingNameLength > (MAX_NAME_LENGTH * sizeof(WCHAR))) {
            usBindingNameLength = MAX_NAME_LENGTH * sizeof(WCHAR);
        } 

        NdisMoveMemory((PUCHAR)BindingName, 
                       (PUCHAR)Route->BindingName,
                       usBindingNameLength);
                               
        BindingName[usBindingNameLength/sizeof(WCHAR)] = L'\0';            

        NdisWanStringToNdisString(&LocalProtocolCB->BindingName, BindingName);
    }


    if (Route->usDeviceNameLength != 0) {
        USHORT  usDeviceNameLength;

        usDeviceNameLength = Route->usDeviceNameLength;

        //
        // We will limit the binding name string to 256 wchars
        //
        if (usDeviceNameLength > (MAX_NAME_LENGTH * sizeof(WCHAR))) {
            usDeviceNameLength = (MAX_NAME_LENGTH * sizeof(WCHAR));
        }

        NdisWanAllocateMemory(&(LocalProtocolCB->InDeviceName.Buffer),
                              usDeviceNameLength,
                              NDISSTRING_TAG);

        if (LocalProtocolCB->InDeviceName.Buffer != NULL) {

            LocalProtocolCB->InDeviceName.MaximumLength = usDeviceNameLength;
            LocalProtocolCB->InDeviceName.Length        = usDeviceNameLength;

            NdisMoveMemory((PUCHAR)LocalProtocolCB->InDeviceName.Buffer,
                          (PUCHAR)Route->DeviceName,
                          usDeviceNameLength);
        }

    }

    //
    // Copy over the protocol info
    //
    LocalProtocolCB->ulLineUpInfoLength = Route->ulBufferLength;
    if (Route->ulBufferLength != 0) {
        NdisMoveMemory(LocalProtocolCB->LineUpInfo,
                       Route->Buffer,
                       Route->ulBufferLength);
    }
    
    //
    // Setup the protocol type
    //
    LocalProtocolCB->ProtocolType = Route->usProtocolType;
    
    //
    // Get the PPP protocol value for this protocol type
    //
    ProtocolInfo.ProtocolType = Route->usProtocolType;

    if (GetProtocolInfo(&ProtocolInfo) != TRUE) {

        if (LocalProtocolCB->BindingName.Length != 0) {
            NdisWanFreeNdisString(&LocalProtocolCB->BindingName);
        }

        if (LocalProtocolCB->LineUpInfo != NULL) {
            NdisWanFreeMemory(LocalProtocolCB->LineUpInfo);
        }

        if (LocalProtocolCB->InDeviceName.Length != 0) {
            NdisWanFreeMemory(LocalProtocolCB->InDeviceName.Buffer);
        }

        NdisFreeToNPagedLookasideList(&LinkProtoCBList, LocalProtocolCB);
        return (NULL);
    }

    InitializeListHead(&LocalProtocolCB->VcList);
    NdisWanInitializeSyncEvent(&LocalProtocolCB->UnrouteEvent);

    LocalProtocolCB->PPPProtocolID = ProtocolInfo.PPPId;
    LocalProtocolCB->MTU = ProtocolInfo.MTU;
    LocalProtocolCB->TunnelMTU = ProtocolInfo.TunnelMTU;
    LocalProtocolCB->State = PROTOCOL_ROUTING;
    LocalProtocolCB->RefCount = 1;

    switch (Route->usProtocolType) {
        case PROTOCOL_IP:
            LocalProtocolCB->NonIdleDetectFunc = IpIsDataFrame;
            break;
        case PROTOCOL_IPX:
            LocalProtocolCB->NonIdleDetectFunc = IpxIsDataFrame;
            break;
        case PROTOCOL_NBF:
            LocalProtocolCB->NonIdleDetectFunc = NbfIsDataFrame;
            break;
        default:
            LocalProtocolCB->NonIdleDetectFunc = NULL;
            break;
    }
    
    NdisWanGetSystemTime(&LocalProtocolCB->LastNonIdleData);

    return(LocalProtocolCB);
}

VOID
NdisWanFreeProtocolCB(
    IN  PPROTOCOLCB ProtocolCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{

#if DBG
    {
        ULONG i;

        for (i = 0; i < MAX_MCML; i++) {
            ASSERT(ProtocolCB->PacketQueue[i].HeadQueue == NULL);
            ASSERT(ProtocolCB->PacketQueue[i].TailQueue == NULL);
        }

    }
#endif

    if (ProtocolCB->InDeviceName.Length != 0) {
        NdisWanFreeMemory(ProtocolCB->InDeviceName.Buffer);
    }

    if (ProtocolCB->OutDeviceName.Length != 0) {
        NdisWanFreeNdisString(&ProtocolCB->OutDeviceName);
    }

    if (ProtocolCB->BindingName.Length != 0) {
        NdisWanFreeNdisString(&ProtocolCB->BindingName);
    }

    if (ProtocolCB->LineUpInfo != NULL) {
        NdisWanFreeMemory(ProtocolCB->LineUpInfo);
    }

    NdisFreeSpinLock(&ProtocolCB->Lock);

    NdisFreeToNPagedLookasideList(&LinkProtoCBList, ProtocolCB);
}

PLINKCB
NdisWanAllocateLinkCB(
    IN  POPENCB OpenCB,
    IN  ULONG   SendWindow
    )
/*++

Routine Name:

    NdisWanGetLinkCB

Routine Description:

    This function returns a pointer to a LinkCB.  The LinkCB is either retrieved
    from the WanAdapters free list or, if this list is empty, it is allocated.

Arguments:

    OpenCB - Pointer to the WanAdapter control block that this Link is
                   associated with

Return Values:

    None

--*/
{
    PLINKCB LocalLinkCB;

    //
    // Figure out how much we need to allocate
    //

    LocalLinkCB =
        NdisAllocateFromNPagedLookasideList(&LinkProtoCBList);

    if (LocalLinkCB == NULL) {
        
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY, ("Error allocating memory for LinkCB"));

        return (NULL);
    }

    NdisZeroMemory(LocalLinkCB, LINKCB_SIZE);

    //
    // Initialize the control block
    //
    NdisWanInitializeSyncEvent(&LocalLinkCB->OutstandingFramesEvent);

    LocalLinkCB->Signature = LINKCB_SIG;
    LocalLinkCB->hLinkContext = NULL;
    LocalLinkCB->State = LINK_UP;
    LocalLinkCB->OpenCB = OpenCB;
    LocalLinkCB->OutstandingFrames = 0;
    LocalLinkCB->SendWindowOpen = TRUE;
    LocalLinkCB->SBandwidth = 100;
    LocalLinkCB->RBandwidth = 100;
    LocalLinkCB->SFlowSpec.MaxSduSize = glMaxMTU;
    LocalLinkCB->RFlowSpec.MaxSduSize = glMRRU;

    LocalLinkCB->LinkInfo.HeaderPadding = OpenCB->WanInfo.HeaderPadding;
    LocalLinkCB->LinkInfo.TailPadding = OpenCB->WanInfo.TailPadding;
    LocalLinkCB->LinkInfo.SendACCM =
    LocalLinkCB->LinkInfo.RecvACCM = OpenCB->WanInfo.DesiredACCM;
    LocalLinkCB->LinkInfo.MaxSendFrameSize = glMaxMTU;
    LocalLinkCB->LinkInfo.MaxRecvFrameSize = glMRU;

    if (OpenCB->Flags & OPEN_LEGACY) {
        LocalLinkCB->SendHandler = SendOnLegacyLink;
    } else {
        LocalLinkCB->SendHandler = SendOnLink;
    }

    if (OpenCB->MediumType == NdisMediumAtm ||

        (OpenCB->MediumType == NdisMediumWan &&
        (OpenCB->MediumSubType == NdisWanMediumAtm ||
         OpenCB->MediumSubType == NdisWanMediumPppoe)) ||

        (OpenCB->MediumType == NdisMediumCoWan &&
        (OpenCB->MediumSubType == NdisWanMediumAtm ||
         OpenCB->MediumSubType == NdisWanMediumPppoe))) {

        LocalLinkCB->RecvHandler = DetectBroadbandFraming;

        LocalLinkCB->LinkInfo.SendFramingBits = 
            PPP_FRAMING | PPP_COMPRESS_ADDRESS_CONTROL;

        LocalLinkCB->LinkInfo.RecvFramingBits = 
            PPP_FRAMING | PPP_COMPRESS_ADDRESS_CONTROL;

    } else {

        LocalLinkCB->RecvHandler = DetectFraming;
    }

    LocalLinkCB->SendWindow =
        (SendWindow == 0 || SendWindow > OpenCB->WanInfo.MaxTransmit) ?
        OpenCB->WanInfo.MaxTransmit : SendWindow;

    if (LocalLinkCB->SendWindow == 0) {
        LocalLinkCB->SendWindow = 1;
    }

    if (OpenCB->Flags & OPEN_LEGACY) {
        LocalLinkCB->SendResources = OpenCB->SendResources;
    } else {
        LocalLinkCB->SendResources = 1000;
    }

    NdisAllocateSpinLock(&LocalLinkCB->Lock);

    LocalLinkCB->RefCount = 1;

    REF_OPENCB(OpenCB);

    InterlockedIncrement(&OpenCB->ActiveLinkCount);

    return (LocalLinkCB);
}


VOID
NdisWanFreeLinkCB(
    PLINKCB LinkCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    POPENCB pOpenCB = LinkCB->OpenCB;

    ASSERT(LinkCB->OutstandingFrames == 0);

    LinkCB->State = LINK_DOWN;

    NdisFreeSpinLock(&LocalLinkCB->Lock);

    NdisFreeToNPagedLookasideList(&LinkProtoCBList, LinkCB);

    InterlockedDecrement(&pOpenCB->ActiveLinkCount);

    DEREF_OPENCB(pOpenCB);
}

NDIS_STATUS
NdisWanAllocateSendResources(
    POPENCB OpenCB
    )
/*++

Routine Name:

    NdisWanAllocateSendResources

Routine Description:

    Allocates all resources (SendDescriptors, WanPackets, ...)
    required for sending data.  Should be called at line up time.

Arguments:

    LinkCB - Pointer to the linkcb that the send resources will be attached to.
    SendWindow - Maximum number of sends that this link can handle

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_RESOURCES

--*/
{
    ULONG   SendWindow;
    ULONG   Endpoints;
    ULONG   NumberOfPackets;
    ULONG   BufferSize;
    ULONG   WanPacketSize;
    PNDIS_WAN_PACKET    WanPacket;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    do {

        //
        // We have to have atleast of sendwindow+1 of packets for
        // each link on the open.  In the case of MCML we need
        // this amount for each fragment queue and for the
        // single non-fragment queue. So this leaves  us with...
        //
        //
        // SendWindow + 1 + (glMaxMTU/glMinFragSize * MAX_MCML) *
        // number of links on the open
        //
        SendWindow = OpenCB->WanInfo.MaxTransmit;
        Endpoints = OpenCB->WanInfo.Endpoints;

        //
        // Sendwindow
        //
        NumberOfPackets = SendWindow;

        //
        // We keep track of how many fragmenting resources we have
        // available for each link
        //
        NumberOfPackets += ((glMaxMTU/glMinFragSize) * MAX_MCML);
        OpenCB->SendResources = NumberOfPackets;

        //
        // Add one for compression data manipulation
        //
        NumberOfPackets += 1;

        //
        // multiplied by the # of links on this open
        //
        NumberOfPackets *= Endpoints;

        //
        // The size of the buffer that we create is
        //
        BufferSize = OpenCB->WanInfo.MaxFrameSize +
                     OpenCB->WanInfo.HeaderPadding +
                     OpenCB->WanInfo.TailPadding +
                     40 + sizeof(PVOID);

        //
        // We assume compression is always on so we pad out 12%
        // incase the compressor expands.  I don't know where the
        // 12% figure comes from.
        //
        BufferSize += (OpenCB->WanInfo.MaxFrameSize + 7) / 8;

        //
        // Make sure that the buffer is dword aligned.
        //
        BufferSize &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        OpenCB->BufferSize = BufferSize;

        WanPacketSize = 
            sizeof(DATA_DESC) + sizeof(NDIS_WAN_PACKET) + 
            3*sizeof(PVOID) + BufferSize;

        //
        // If this device needs some special memory flags
        // we need to allocate memory for it's WanPackets now.
        // Otherwise we will intialize a lookaside list and
        // retrieve the packets as needed.

        if (OpenCB->WanInfo.MemoryFlags == 0) {


            NdisInitializeNPagedLookasideList(&OpenCB->WanPacketPool,
                                              AllocateWanPacket,
                                              FreeWanPacket,
                                              0,
                                              WanPacketSize,
                                              WANPACKET_TAG,
                                              0);

        } else {
            ULONG   PacketMemorySize;
            PUCHAR  PacketMemory;
            ULONG   n;

            PacketMemorySize = 
                WanPacketSize * NumberOfPackets;

            //
            // Allocate the memory for the wan packet buffer pool
            //
            NdisAllocateMemory(&PacketMemory,
                               PacketMemorySize,
                               OpenCB->WanInfo.MemoryFlags,
                               OpenCB->WanInfo.HighestAcceptableAddress);

            if (PacketMemory == NULL) {
                NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY, ("Error allocating memory for BufferPool, AllocationSize: %d",
                                 PacketMemorySize));

                Status  = NDIS_STATUS_RESOURCES;
                break;
            }

            OpenCB->PacketMemory = PacketMemory;
            OpenCB->PacketMemorySize = PacketMemorySize;
            NdisInitializeSListHead(&OpenCB->WanPacketList);

            for (n = 0; n < NumberOfPackets; n++) {
                PDATA_DESC  DataDesc;

                //
                // Point to the DataDesc
                //
                DataDesc = 
                    (PDATA_DESC)PacketMemory;

                PacketMemory =
                    ((PUCHAR)(DataDesc + 1) + sizeof(PVOID));

                (ULONG_PTR)PacketMemory &= 
                    ~((ULONG_PTR)sizeof(PVOID) - 1);

                // 
                // Point to the WanPacket
                //
                WanPacket = 
                    (PNDIS_WAN_PACKET)PacketMemory;

                PacketMemory = 
                    ((PUCHAR)(WanPacket + 1) + sizeof(PVOID));

                (ULONG_PTR)PacketMemory &= 
                    ~((ULONG_PTR)sizeof(PVOID) - 1);

                //
                // Point to the begining of the data buffer
                //
                WanPacket->StartBuffer = PacketMemory;
                WanPacket->EndBuffer = 
                    PacketMemory + BufferSize - sizeof(PVOID);

                NdisInterlockedPushEntrySList(&OpenCB->WanPacketList,
                                              (PSLIST_ENTRY)DataDesc,
                                              &OpenCB->Lock);

                PacketMemory += BufferSize + sizeof(PVOID);
                (ULONG_PTR)PacketMemory &=
                    ~((ULONG_PTR)sizeof(PVOID) - 1);
            }
        }

    } while ( FALSE );

    if (Status == NDIS_STATUS_SUCCESS) {
        OpenCB->Flags |= SEND_RESOURCES;
    }

    return (Status);
}

VOID
NdisWanFreeSendResources(
    POPENCB OpenCB
    )
/*++

Routine Name:

    NdisWanFreeSendResources

Routine Description:

    This routine removes the WanPackets from this opencb's send list
    and free's the memory allocated for these packets.  Should be called
    when we are cleaningup an opencb.

Arguments:

    OpenCB - Pointer to the opencb that the resources are being freed from.

Return Values:

    None

--*/
{
    PUCHAR              PacketMemory;
    ULONG               PacketMemorySize, Flags;

    PacketMemory = OpenCB->PacketMemory;
    PacketMemorySize = OpenCB->PacketMemorySize;
    Flags = OpenCB->WanInfo.MemoryFlags;

    if (OpenCB->WanInfo.MemoryFlags == 0) {
        NdisDeleteNPagedLookasideList(&OpenCB->WanPacketPool);
        return;
    }

    //
    // Remove the packets from the wan packet pool
    //
    for (; ;) {
        PDATA_DESC  DataDesc;

        DataDesc = (PDATA_DESC)
            NdisInterlockedPopEntrySList(&OpenCB->WanPacketList,
                                         &OpenCB->Lock);

        if (DataDesc == NULL) {
            break;
        }
    }

    ASSERT(NdisQueryDepthSList(&OpenCB->WanPacketList) == 0);

    //
    // Free the block of memory allocated for this send
    //
    if (PacketMemory != NULL) {
        NdisFreeMemory(OpenCB->PacketMemory,
                       OpenCB->PacketMemorySize,
                       OpenCB->Flags);
    }
}

PBUNDLECB
NdisWanAllocateBundleCB(
    VOID
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PBUNDLECB   LocalBundleCB = NULL;
    PWSTR   IOName = L"I/O ProtocolCB";
    PPROTOCOLCB ProtocolCB;
    PSAMPLE_TABLE   SampleTable;
    PBOND_INFO      BonDInfo;
    UINT    Class;
    PUCHAR  pMem;

    //
    // Allocation size is the size of the control block plus the size
    // of a table of pointers to protocolcb's that might be routed to
    // this bundle.
    //
    pMem =
        NdisAllocateFromNPagedLookasideList(&BundleCBList);

    if (pMem == NULL) {
        return (NULL);
    }

    NdisZeroMemory(pMem, BUNDLECB_SIZE);

    LocalBundleCB = (PBUNDLECB)pMem;

    pMem += sizeof(BUNDLECB) + sizeof(PVOID);

    //
    // This is the memory used for the I/O protocolcb
    //
    (PUCHAR)ProtocolCB = pMem;
    (ULONG_PTR)ProtocolCB &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    pMem += sizeof(PROTOCOLCB) + sizeof(PVOID);

    //
    // This is the protocolcb table
    //
    (PUCHAR)LocalBundleCB->ProtocolCBTable = pMem;

    (ULONG_PTR)LocalBundleCB->ProtocolCBTable &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pMem += (MAX_PROTOCOLS * sizeof(PPROTOCOLCB)) + sizeof(PVOID);

    //
    // Initialize the BundleCB
    //
    NdisAllocateSpinLock(&LocalBundleCB->Lock);
    InitializeListHead(&LocalBundleCB->LinkCBList);

    for (Class = 0; Class < MAX_MCML; Class++) {
        PRECV_DESC  RecvDescHole;
        PSEND_FRAG_INFO FragInfo;
        PBUNDLE_RECV_INFO   RecvInfo;

        FragInfo = &LocalBundleCB->SendFragInfo[Class];
        RecvInfo = &LocalBundleCB->RecvInfo[Class];

        InitializeListHead(&FragInfo->FragQueue);
        FragInfo->MinFragSize = glMinFragSize;
        FragInfo->MaxFragSize = glMaxFragSize;

        InitializeListHead(&RecvInfo->AssemblyList);

        //
        // Init the recv hole desc
        //
        RecvDescHole =
            NdisWanAllocateRecvDesc(0);
    
        if (RecvDescHole == NULL) {
            UINT    i;

            for (i = 0; i < MAX_MCML; i++) {
                RecvInfo = &LocalBundleCB->RecvInfo[i];

                if (RecvInfo->RecvDescHole != NULL) {
                    NdisWanFreeRecvDesc(RecvInfo->RecvDescHole);
                    
                }
            }

            NdisFreeToNPagedLookasideList(&BundleCBList, LocalBundleCB);

            return (NULL);
        }
    
        RecvDescHole->Flags = MULTILINK_HOLE_FLAG;

        RecvInfo->RecvDescHole = RecvDescHole;
        InsertHeadList(&RecvInfo->AssemblyList, &RecvDescHole->Linkage);
        RecvInfo->AssemblyCount++;
    }

    InitializeListHead(&LocalBundleCB->ProtocolCBList);
    NdisWanInitializeSyncEvent(&LocalBundleCB->OutstandingFramesEvent);
    LocalBundleCB->State = BUNDLE_UP;
    LocalBundleCB->FramingInfo.MaxRSendFrameSize = glMaxMTU;
    LocalBundleCB->FramingInfo.MaxRRecvFrameSize = glMRRU;
    LocalBundleCB->SFlowSpec.MaxSduSize = glMaxMTU;
    LocalBundleCB->RFlowSpec.MaxSduSize = glMRRU;
    NdisWanGetSystemTime(&LocalBundleCB->LastNonIdleData);
    LocalBundleCB->SendCompInfo.CompType =
    LocalBundleCB->RecvCompInfo.CompType = COMPTYPE_NONE;

    //
    // Add the protocolcb to the bundle's table and list
    //
    ProtocolCB->ProtocolType = PROTOCOL_PRIVATE_IO;
    ProtocolCB->PPPProtocolID = PPP_PROTOCOL_PRIVATE_IO;
    ProtocolCB->BundleCB = LocalBundleCB;
    ProtocolCB->State = PROTOCOL_ROUTED;
    NdisWanStringToNdisString(&ProtocolCB->InDeviceName, IOName);
    LocalBundleCB->IoProtocolCB = ProtocolCB;

    return (LocalBundleCB);
}

VOID
NdisWanFreeBundleCB(
    IN  PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    UINT            Class;
    PPROTOCOLCB     IoProtocolCB;
    PPACKET_QUEUE   PacketQueue;

    FlushAssemblyLists(BundleCB);

    if (BundleCB->Flags & BOND_ENABLED) {
        RemoveEntryGlobalList(BonDWorkList, &BundleCB->BonDLinkage);
    }

    //
    // Free the hole place holders
    //
    for (Class = 0; Class < MAX_MCML; Class++) {
        PBUNDLE_RECV_INFO   RecvInfo =
            &BundleCB->RecvInfo[Class];

        ASSERT(RecvInfo->RecvDescHole != NULL);
        
        NdisWanFreeRecvDesc(RecvInfo->RecvDescHole);
        RecvInfo->RecvDescHole = NULL;
    }

#if 0
    KeCancelTimer(&BundleCB->BonDTimer);
#endif

    IoProtocolCB = BundleCB->IoProtocolCB;
    PacketQueue = &IoProtocolCB->PacketQueue[MAX_MCML];

    ASSERT(IsPacketQueueEmpty(PacketQueue));

    //
    // If we have ppp packets queued we need
    // to flush them and free the memory!
    //
    while (!IsPacketQueueEmpty(PacketQueue)) {
        PNDIS_PACKET     Packet;

        Packet =
            RemoveHeadPacketQueue(PacketQueue)

        CompleteNdisPacket(IoProtocolCB->MiniportCB,
                           IoProtocolCB,
                           Packet);
    }

    sl_compress_terminate(&BundleCB->VJCompress);

    if (BundleCB->Flags & SEND_CCP_ALLOCATED) {

        WanDeallocateCCP(BundleCB,
                         &BundleCB->SendCompInfo,
                         TRUE);
        BundleCB->Flags &= ~SEND_CCP_ALLOCATED;
    }

    if (BundleCB->Flags & RECV_CCP_ALLOCATED) {
        WanDeallocateCCP(BundleCB,
                         &BundleCB->RecvCompInfo,
                         FALSE);
        BundleCB->Flags &= ~RECV_CCP_ALLOCATED;
    }

    if (BundleCB->Flags & SEND_ECP_ALLOCATED) {
        WanDeallocateECP(BundleCB,
                         &BundleCB->SendCompInfo,
                         &BundleCB->SendCryptoInfo);
        BundleCB->Flags &= ~SEND_ECP_ALLOCATED;
    }

    if (BundleCB->Flags & RECV_ECP_ALLOCATED) {
        WanDeallocateECP(BundleCB,
                         &BundleCB->RecvCompInfo,
                         &BundleCB->RecvCryptoInfo);
        BundleCB->Flags &= ~RECV_ECP_ALLOCATED;
    }

    if (BundleCB->BonDAllocation != NULL) {
        NdisWanFreeMemory(BundleCB->BonDAllocation);
        BundleCB->BonDAllocation = NULL;
    }

    BundleCB->State = BUNDLE_DOWN;

    NdisFreeSpinLock(&BundleCB->Lock);

    NdisWanFreeNdisString(&BundleCB->IoProtocolCB->InDeviceName);

    NdisFreeToNPagedLookasideList(&BundleCBList, BundleCB);
}


NDIS_STATUS
NdisWanCreateProtocolInfoTable(
    VOID
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG       ulAllocationSize = 0;
    PUCHAR      AllocatedMemory;
    PROTOCOL_INFO   ProtocolInfo;

    //
    // Allocate ProtocolLookupTable.  This table is used to match protocol values
    // with their corresponding PPP Protocol values.  The table size is set to
    // MAX_PROTOCOLS.
    //
    ulAllocationSize = sizeof(PROTOCOL_INFO_TABLE) +
                     (sizeof(PROTOCOL_INFO) * MAX_PROTOCOLS);
    

    NdisWanAllocateMemory(&AllocatedMemory, ulAllocationSize, PROTOCOLTABLE_TAG);

    if (AllocatedMemory == NULL) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY,
               ("Failed allocating memory for ProtocolLookupTable! TableSize: %d",
               ulAllocationSize));

        return (NDIS_STATUS_RESOURCES);     
    }

    ProtocolInfoTable = (PPROTOCOL_INFO_TABLE)AllocatedMemory;

    //
    // Save the allocation size
    //
    ProtocolInfoTable->ulAllocationSize = ulAllocationSize;

    //
    // Store the array size.  This should be read from the registry
    //
    ProtocolInfoTable->ulArraySize = MAX_PROTOCOLS;

    NdisAllocateSpinLock(&ProtocolInfoTable->Lock);

    //
    // Setup the pointer to the ProtocolValue array
    //
    AllocatedMemory += sizeof(PROTOCOL_INFO_TABLE);
    ProtocolInfoTable->ProtocolInfo = (PPROTOCOL_INFO)(AllocatedMemory);

    //
    // Insert default values for Netbuei, IP, IPX
    //
    ProtocolInfo.ProtocolType = PROTOCOL_PRIVATE_IO;
    ProtocolInfo.PPPId = PPP_PROTOCOL_PRIVATE_IO;
    ProtocolInfo.MTU = DEFAULT_MTU;
    ProtocolInfo.TunnelMTU = DEFAULT_MTU;
    ProtocolInfo.PacketQueueDepth = DEFAULT_PACKETQUEUE_DEPTH;
    ProtocolInfo.Flags = PROTOCOL_UNBOUND;
    SetProtocolInfo(&ProtocolInfo);

    ProtocolInfo.ProtocolType = PROTOCOL_IP;
    ProtocolInfo.PPPId = PPP_PROTOCOL_IP;
    ProtocolInfo.MTU = DEFAULT_MTU;
    ProtocolInfo.TunnelMTU = DEFAULT_TUNNEL_MTU;
    ProtocolInfo.PacketQueueDepth = DEFAULT_PACKETQUEUE_DEPTH;
    ProtocolInfo.Flags = PROTOCOL_UNBOUND;
    SetProtocolInfo(&ProtocolInfo);

    ProtocolInfo.ProtocolType = PROTOCOL_IPX;
    ProtocolInfo.PPPId = PPP_PROTOCOL_IPX;
    ProtocolInfo.MTU = DEFAULT_MTU;
    ProtocolInfo.TunnelMTU = DEFAULT_MTU;
    ProtocolInfo.PacketQueueDepth = DEFAULT_PACKETQUEUE_DEPTH;
    ProtocolInfo.Flags = PROTOCOL_UNBOUND;
    SetProtocolInfo(&ProtocolInfo);

    ProtocolInfo.ProtocolType = PROTOCOL_NBF;
    ProtocolInfo.PPPId = PPP_PROTOCOL_NBF;
    ProtocolInfo.MTU = DEFAULT_MTU;
    ProtocolInfo.TunnelMTU = DEFAULT_MTU;
    ProtocolInfo.PacketQueueDepth = DEFAULT_PACKETQUEUE_DEPTH;
    ProtocolInfo.Flags = PROTOCOL_UNBOUND;
    SetProtocolInfo(&ProtocolInfo);

    ProtocolInfo.ProtocolType = PROTOCOL_APPLETALK;
    ProtocolInfo.PPPId = PPP_PROTOCOL_APPLETALK;
    ProtocolInfo.MTU = DEFAULT_MTU;
    ProtocolInfo.TunnelMTU = DEFAULT_MTU;
    ProtocolInfo.PacketQueueDepth = DEFAULT_PACKETQUEUE_DEPTH;
    ProtocolInfo.Flags = PROTOCOL_UNBOUND;
    SetProtocolInfo(&ProtocolInfo);

    return (Status);

}

VOID
NdisWanDestroyProtocolInfoTable(
    VOID
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NdisFreeSpinLock(&ProtocolInfoTable->Lock);

    NdisWanFreeMemory(ProtocolInfoTable);
}

NDIS_STATUS
NdisWanCreateConnectionTable(
    ULONG   TableSize
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       ulAllocationSize = 0;
    ULONG       ulArraySize;
    PUCHAR      AllocatedMemory;
    PCONNECTION_TABLE   NewTable;

    //
    // Since we skip the first place in the tables we increase the
    // size by one.
    //
    ulArraySize = TableSize + 1;

    //
    // Allocate the Bundle and Link Arrays based on the number of possible connections
    // that we have in the system.  This should be grown if we get called
    // to reinitialize and gain new ports.
    //
    ulAllocationSize = sizeof(CONNECTION_TABLE) +
                     (sizeof(PBUNDLECB) * ulArraySize) +
                     (sizeof(PLINKCB) * ulArraySize);

    NdisWanAllocateMemory(&AllocatedMemory, ulAllocationSize, CONNECTIONTABLE_TAG);

    if (AllocatedMemory == NULL) {

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY,
               ("Failed allocating memory for ConnectionTable! Size: %d, Links: %d",
               ulAllocationSize, TableSize));

        return (NDIS_STATUS_RESOURCES);
    }

    NewTable = (PCONNECTION_TABLE)AllocatedMemory;

    //
    // This is the amount of memory we allocated
    //
    NewTable->ulAllocationSize = ulAllocationSize;
    NewTable->ulArraySize = TableSize;
    NewTable->ulNextLink =
    NewTable->ulNextBundle = 1;
    InitializeListHead(&NewTable->BundleList);
    InitializeListHead(&NewTable->LinkList);

    //
    // Setup pointer to the linkcb array
    //
    AllocatedMemory += sizeof(CONNECTION_TABLE);
    NewTable->LinkArray = (PLINKCB*)(AllocatedMemory);
    
    //
    // Setup the pointer to the bundlecb array
    //
    AllocatedMemory += (sizeof(PLINKCB) * ulArraySize);
    NewTable->BundleArray = (PBUNDLECB*)(AllocatedMemory);

    if (ConnectionTable != NULL) {
        PCONNECTION_TABLE   FreeTable;

        //
        // We must be growing the table.  This will be
        // called with the current connectiontable lock
        // held!
        //
        NewTable->ulNumActiveLinks = ConnectionTable->ulNumActiveLinks;
        NewTable->ulNumActiveBundles = ConnectionTable->ulNumActiveBundles;
        NewTable->ulNextLink = ConnectionTable->ulNextLink;
        NewTable->ulNextBundle = ConnectionTable->ulNextBundle;

        NdisMoveMemory((PUCHAR)NewTable->LinkArray,
                       (PUCHAR)ConnectionTable->LinkArray,
                       ConnectionTable->ulArraySize * sizeof(PLINKCB));

        NdisMoveMemory((PUCHAR)NewTable->BundleArray,
                       (PUCHAR)ConnectionTable->BundleArray,
                       ConnectionTable->ulArraySize * sizeof(PBUNDLECB));

        while (!IsListEmpty(&ConnectionTable->BundleList)) {
            PBUNDLECB   BundleCB;

            BundleCB = (PBUNDLECB)RemoveHeadList(&ConnectionTable->BundleList);
            InsertTailList(&NewTable->BundleList, &BundleCB->Linkage);
        }

        while (!IsListEmpty(&ConnectionTable->LinkList)) {
            PLIST_ENTRY Entry;
            PLINKCB     LinkCB;

            Entry = RemoveHeadList(&ConnectionTable->LinkList);
            LinkCB = 
                (PLINKCB)CONTAINING_RECORD(Entry, LINKCB, ConnTableLinkage);
            InsertTailList(&NewTable->LinkList, &LinkCB->ConnTableLinkage);

        }

        FreeTable = ConnectionTable;
        ConnectionTable = NewTable;

        //
        // Destroy the old table
        //
        NdisWanFreeMemory(FreeTable);


    } else {
        ConnectionTable = NewTable;
    }

    return (NDIS_STATUS_SUCCESS);
}

PNDIS_PACKET
NdisWanAllocateNdisPacket(
    ULONG   MagicNumber
    )
{
    PNDIS_PACKET    ReturnPacket = NULL;
    PPOOL_DESC      PoolDesc;
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    ULONG           i;
    PSINGLE_LIST_ENTRY  p = NULL;
    PNDISWAN_PROTOCOL_RESERVED  pres;

    NdisAcquireSpinLock(&PacketPoolList.Lock);

    //
    // Walk the pool desc list and try to allocate a packet
    //
    PoolDesc = (PPOOL_DESC)PacketPoolList.List.Flink;

    while (PoolDesc != (PPOOL_DESC)&PacketPoolList.List) {

        p = PopEntryList(&PoolDesc->Head);

        if (p != NULL) {
            break;
        }
        
        PoolDesc = (PPOOL_DESC)PoolDesc->Linkage.Flink;
    }

    if (p == NULL) {
        //
        // We have walked the pool list and did not find any
        // free packets on any of the free pools, so allocate
        // a new pool and get a packet from it.
        //
        NdisWanAllocatePriorityMemory(&PoolDesc, 
                                      sizeof(POOL_DESC), 
                                      POOLDESC_TAG,
                                      NormalPoolPriority);

        if (PoolDesc == NULL) {
            NdisReleaseSpinLock(&PacketPoolList.Lock);
            return (NULL);
        }

        NdisAllocatePacketPoolEx(&Status,
                                 &PoolDesc->PoolHandle,
                                 glPacketPoolCount,
                                 0,
                                 sizeof(NDISWAN_PROTOCOL_RESERVED));

        if (Status != NDIS_STATUS_SUCCESS) {
            NdisWanFreeMemory(PoolDesc);
            NdisReleaseSpinLock(&PacketPoolList.Lock);
            return (NULL);
        }

        for (i = 0; i < glPacketPoolCount; i++) {
            PNDIS_PACKET    np;

            NdisAllocatePacket(&Status,
                               &np,
                               PoolDesc->PoolHandle);

            ASSERT(np != NULL);

            pres = PPROTOCOL_RESERVED_FROM_NDIS(np);

            PushEntryList(&PoolDesc->Head, &pres->SLink);

            PoolDesc->FreeCount++;
        }

        InsertTailList(&PacketPoolList.List, &PoolDesc->Linkage);

        PacketPoolList.TotalDescCount++;
        PacketPoolList.FreeCount += PoolDesc->FreeCount;

        if (PacketPoolList.TotalDescCount >
            PacketPoolList.MaxDescCount) {
            
            PacketPoolList.MaxDescCount = PacketPoolList.TotalDescCount;
        }

        p = PopEntryList(&PoolDesc->Head);
    }

    ASSERT(p != NULL);

    pres = CONTAINING_RECORD(p, NDISWAN_PROTOCOL_RESERVED, SLink);
    ReturnPacket = CONTAINING_RECORD(pres, NDIS_PACKET, ProtocolReserved);

    NdisReinitializePacket(ReturnPacket);

    PoolDesc->AllocatedCount++;
    PoolDesc->FreeCount--;
    ASSERT((PoolDesc->AllocatedCount + PoolDesc->FreeCount) == glPacketPoolCount);

    if (PoolDesc->AllocatedCount >
        PoolDesc->MaxAllocatedCount) {

        PoolDesc->MaxAllocatedCount =
            PoolDesc->AllocatedCount;
    }

    PacketPoolList.AllocatedCount++;
    PacketPoolList.FreeCount--;

#if DBG
{
    PPOOL_DESC  pdesc;
    ULONG       FreeCount, AllocatedCount;

    pdesc = (PPOOL_DESC)PacketPoolList.List.Flink;

    FreeCount = AllocatedCount = 0;

    while ((PVOID)pdesc != (PVOID)&PacketPoolList.List) {
        FreeCount += pdesc->FreeCount;
        AllocatedCount += pdesc->AllocatedCount;
        pdesc = (PPOOL_DESC)pdesc->Linkage.Flink;
    }

    if (PacketPoolList.AllocatedCount != AllocatedCount ||
        PacketPoolList.FreeCount != FreeCount){
        DbgPrint("NDISWAN: AllocatePacket - PacketPool counts out of sync!\n");
        DbgBreakPoint();
    }

#if 0
    if (PacketPoolList.AllocatedCount > 200) {
        DbgPrint("NDISWAN: AllocatePacket - Over 200 outstanding packets!\n");
        DbgBreakPoint();
    }
#endif

}
#endif

    if (PacketPoolList.AllocatedCount >
        PacketPoolList.MaxAllocatedCount) {

        PacketPoolList.MaxAllocatedCount =
            PacketPoolList.AllocatedCount;
    }
    
    pres->MagicNumber = MagicNumber;
    pres->PoolDesc = PoolDesc;

    NDIS_SET_PACKET_HEADER_SIZE(ReturnPacket, 
                                MAC_HEADER_LENGTH);

    NDIS_SET_PACKET_STATUS(ReturnPacket, 
                           NDIS_STATUS_SUCCESS);

    NdisReleaseSpinLock(&PacketPoolList.Lock);

    return (ReturnPacket);
}

VOID
NdisWanFreeNdisPacket(
    PNDIS_PACKET    NdisPacket
    )
{
    PNDISWAN_PROTOCOL_RESERVED  pres;
    PPOOL_DESC      PoolDesc;
    PNDIS_BUFFER    NdisBuffer;
    PUCHAR          DataBuffer;

    pres = PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket);

    ASSERT(pres->MagicNumber == MAGIC_INTERNAL_ALLOC ||
           pres->MagicNumber == MAGIC_INTERNAL_IO ||
           pres->MagicNumber == MAGIC_INTERNAL_SEND ||
           pres->MagicNumber == MAGIC_INTERNAL_RECV ||
           pres->MagicNumber == MAGIC_INTERNAL_ALLOC);

    PoolDesc = pres->PoolDesc;

    NdisAcquireSpinLock(&PacketPoolList.Lock);

#if DBG
{
    PPOOL_DESC  pdesc;

    pdesc = (PPOOL_DESC)PacketPoolList.List.Flink;

    while ((PVOID)pdesc != (PVOID)&PacketPoolList.List) {

        if (PoolDesc == pdesc) {
            //
            // We found the correct pool
            //
            break;
        }

        pdesc = (PPOOL_DESC)pdesc->Linkage.Flink;
    }

    if((PVOID)PoolDesc == (PVOID)&PacketPoolList.List){
        DbgPrint("NDISWAN: FreePacket PoolDesc %x not on PacketPoolList!\n",
                 PoolDesc);
        DbgBreakPoint();
    }
}
#endif

    PushEntryList(&PoolDesc->Head, &pres->SLink);

    PoolDesc->AllocatedCount--;
    PoolDesc->FreeCount++;

    ASSERT((PoolDesc->AllocatedCount + PoolDesc->FreeCount) == glPacketPoolCount);

    PacketPoolList.AllocatedCount--;
    PacketPoolList.FreeCount++;

#if DBG
{
    PPOOL_DESC  pdesc;
    ULONG       FreeCount, AllocatedCount;

    pdesc = (PPOOL_DESC)PacketPoolList.List.Flink;

    FreeCount = AllocatedCount = 0;

    while ((PVOID)pdesc != (PVOID)&PacketPoolList.List) {
        FreeCount += pdesc->FreeCount;
        AllocatedCount += pdesc->AllocatedCount;


        pdesc = (PPOOL_DESC)pdesc->Linkage.Flink;
    }

    if (PacketPoolList.AllocatedCount != AllocatedCount ||
        PacketPoolList.FreeCount != FreeCount){
        DbgPrint("NDISWAN: FreePacket - PacketPool counts out of sync!\n");
        DbgBreakPoint();
    }
}
#endif

    //
    // If all of the packets have been returned to this pool desc
    // and this is not the only pool desc then free it!
    //
    if (PoolDesc->AllocatedCount == 0 &&
        PacketPoolList.TotalDescCount > 1 &&
        PacketPoolList.FreeCount > PoolDesc->FreeCount) {
        PSINGLE_LIST_ENTRY  p = NULL;

        RemoveEntryList(&PoolDesc->Linkage);

        PacketPoolList.TotalDescCount--;
        PacketPoolList.FreeCount -= PoolDesc->FreeCount;

        p = PopEntryList(&PoolDesc->Head);

        while (p != NULL) {
            PNDIS_PACKET    ReturnPacket;

            pres = CONTAINING_RECORD(p, NDISWAN_PROTOCOL_RESERVED, SLink);
            ReturnPacket = CONTAINING_RECORD(pres, NDIS_PACKET, ProtocolReserved);

            NdisFreePacket(ReturnPacket);

            p = PopEntryList(&PoolDesc->Head);
        }

        NdisFreePacketPool(PoolDesc->PoolHandle);
        NdisWanFreeMemory(PoolDesc);
    }

    NdisReleaseSpinLock(&PacketPoolList.Lock);
}

PVOID
AllocateDataDesc(
    POOL_TYPE   PoolType,
    SIZE_T      NumberOfBytes,
    ULONG       Tag
    )
/*++

Routine Name:

    AllocateDataDesc

Routine Description:

    This routine is called by the lookasidelist manager if there are not
    any descriptors available.  It will allocated memory for: DATA_DESC,
    NDIS_BUFFER, NDIS_PACKET, and a block of memory of size.
    
Arguments:

Return Values:

--*/
{
    PDATA_DESC      DataDesc;
    PUCHAR          DataBuffer;
    NDIS_STATUS     Status;

    NdisWanAllocatePriorityMemory(&DataDesc, 
                                  NumberOfBytes, 
                                  Tag,
                                  NormalPoolPriority);

    if (DataDesc == NULL) {
        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY,
                      ("AllocateDataDesc failed! Size %d",
                      NumberOfBytes));
        return (NULL);
    }

    DataBuffer = 
        ((PUCHAR)(DataDesc + 1) + sizeof(PVOID));
    (ULONG_PTR)DataBuffer &= 
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    DataDesc->DataBuffer = DataBuffer;

    DataDesc->DataBufferLength = 
        (ULONG)(((PUCHAR)DataDesc + NumberOfBytes) - DataBuffer);

    // This is not portable to Win95!  I need to allocate a buffer
    // pool and use a valid handle.
    //
    NdisAllocateBuffer(&Status, 
                       &DataDesc->NdisBuffer, 
                       NULL,
                       DataDesc->DataBuffer,
                       DataDesc->DataBufferLength);

    if (Status != NDIS_STATUS_SUCCESS) {

        NdisWanFreeMemory(DataDesc);

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY,
                      ("NdisAllocateBuffer failed! DataBufferSize %d",
                      DataDesc->DataBufferLength));
        return (NULL);
    }

    DataDesc->NdisPacket =
        NdisWanAllocateNdisPacket(MAGIC_INTERNAL_ALLOC);

    if (DataDesc->NdisPacket == NULL) {

        NdisFreeBuffer(DataDesc->NdisBuffer);

        NdisWanFreeMemory(DataDesc);

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_MEMORY,
                      ("NdisWanAllocateNdisPacket failed! DataBufferSize %d"));

        return (NULL);
    }

    NdisChainBufferAtFront(DataDesc->NdisPacket,
                           DataDesc->NdisBuffer);

    return(DataDesc);
}

VOID
FreeDataDesc(
    PVOID   Buffer
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PDATA_DESC      DataDesc;

    DataDesc = (PDATA_DESC)Buffer;

    NdisReinitializePacket(DataDesc->NdisPacket);

    NdisWanFreeNdisPacket(DataDesc->NdisPacket);

    NdisFreeBuffer(DataDesc->NdisBuffer);

    NdisWanFreeMemory(Buffer);
}

PRECV_DESC
NdisWanAllocateRecvDesc(
    ULONG   SizeNeeded
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PDATA_DESC  DataDesc;
    PRECV_DESC  RecvDesc;
    ULONG       Length;
    PNPAGED_LOOKASIDE_LIST  LookasideList;

    if (SizeNeeded > glLargeDataBufferSize) {
        DbgPrint("NDISWAN: Error Allocating RecvDesc Size %d\n",
                 SizeNeeded);
        return (NULL);
    } else if (SizeNeeded > glSmallDataBufferSize) {
        LookasideList = &LargeDataDescList;
    } else {
        LookasideList = &SmallDataDescList;
    }

    DataDesc =
        NdisAllocateFromNPagedLookasideList(LookasideList);

    if (DataDesc == NULL) {
        return (NULL);
    }

    PPROTOCOL_RESERVED_FROM_NDIS(DataDesc->NdisPacket)->MagicNumber =
        MAGIC_INTERNAL_RECV;

    DataDesc->LookasideList = LookasideList;
    RecvDesc = &DataDesc->RecvDesc;

    NdisZeroMemory(RecvDesc, sizeof(RECV_DESC));

    RecvDesc->Signature = RECVDESC_SIG;
    RecvDesc->DataBuffer =
        DataDesc->DataBuffer;
    RecvDesc->NdisBuffer =
        DataDesc->NdisBuffer;
    RecvDesc->NdisPacket =
        DataDesc->NdisPacket;

    NdisQueryBuffer(RecvDesc->NdisBuffer,
                    &RecvDesc->StartBuffer,
                    &Length);

    RecvDesc->CurrentBuffer = 
        RecvDesc->StartBuffer + MAC_HEADER_LENGTH + PROTOCOL_HEADER_LENGTH;

    return (RecvDesc);
}

VOID
NdisWanFreeRecvDesc(
    PRECV_DESC  RecvDesc
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PDATA_DESC      DataDesc;
    PNDIS_BUFFER    NdisBuffer;
    PNDIS_PACKET    NdisPacket;
    PNPAGED_LOOKASIDE_LIST  LookasideList;

    if (RecvDesc->OriginalPacket != NULL) {

        NdisReturnPackets(&RecvDesc->OriginalPacket, 1);
        RecvDesc->OriginalPacket = NULL;
    }

    DataDesc = 
        CONTAINING_RECORD(RecvDesc, DATA_DESC, RecvDesc);

    NdisBuffer = 
        DataDesc->NdisBuffer;

    NdisPacket =
        DataDesc->NdisPacket;

    LookasideList = 
        DataDesc->LookasideList;

#if DBG
    {
    ULONG           BufferCount;

    NdisQueryPacket(NdisPacket,
                    NULL,
                    &BufferCount,
                    NULL,
                    NULL);

    ASSERT(BufferCount == 1);
    }
#endif

    NdisAdjustBufferLength(NdisBuffer, 
                           DataDesc->DataBufferLength);

    NdisRecalculatePacketCounts(NdisPacket);

    NDIS_SET_PACKET_HEADER_SIZE(NdisPacket, 
                                MAC_HEADER_LENGTH);

    NDIS_SET_PACKET_STATUS(NdisPacket, 
                           NDIS_STATUS_SUCCESS);

    ASSERT(PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->MagicNumber == MAGIC_INTERNAL_RECV);

    NdisFreeToNPagedLookasideList(LookasideList, DataDesc);
}

PSEND_DESC
NdisWanAllocateSendDesc(
    PLINKCB LinkCB,
    ULONG   SizeNeeded
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    POPENCB     OpenCB;
    PSEND_DESC  SendDesc;

    //
    // Need to determine if this link represents a legacy
    // wan miniport or a NDIS 5.0 miniport and get the
    // appropriate buffer descriptor.
    //
    OpenCB = LinkCB->OpenCB;

    if (OpenCB->Flags & OPEN_LEGACY) {
        PDATA_DESC          DataDesc;
        PNDIS_WAN_PACKET    WanPacket;

        //
        // Get a buffer desriptor off of the open block
        //
        if (OpenCB->WanInfo.MemoryFlags == 0) {
            PNPAGED_LOOKASIDE_LIST  LookasideList;

            LookasideList = &OpenCB->WanPacketPool;
    
            DataDesc = 
                NdisAllocateFromNPagedLookasideList(LookasideList);

            if (DataDesc == NULL) {
                return(NULL);
            }

            DataDesc->LookasideList = LookasideList;

            WanPacket = (PNDIS_WAN_PACKET)
                ((PUCHAR)(DataDesc + 1) + sizeof(PVOID));

            (ULONG_PTR)WanPacket &=
                ~((ULONG_PTR)sizeof(PVOID) - 1);

            //
            // Point to the begining of the data.
            //
            WanPacket->StartBuffer = 
                ((PUCHAR)(WanPacket + 1) + sizeof(PVOID));

            (ULONG_PTR)WanPacket->StartBuffer &=
                ~((ULONG_PTR)sizeof(PVOID) - 1);

            WanPacket->EndBuffer = WanPacket->StartBuffer +
                                   OpenCB->BufferSize - sizeof(PVOID);
    
        } else {
            DataDesc = (PDATA_DESC)
                NdisInterlockedPopEntrySList(&OpenCB->WanPacketList,
                                             &OpenCB->Lock);
    
            if (DataDesc == NULL) {
                return (NULL);
            }
        }

        SendDesc = &DataDesc->SendDesc;
        NdisZeroMemory(SendDesc, sizeof(SEND_DESC));

        SendDesc->Signature = SENDESC_SIG;
        SendDesc->LinkCB = LinkCB;
        SendDesc->WanPacket = WanPacket;

        WanPacket->CurrentBuffer =
            WanPacket->StartBuffer + OpenCB->WanInfo.HeaderPadding;

        SendDesc->StartBuffer =
            WanPacket->CurrentBuffer;


    } else {
        PDATA_DESC  DataDesc;
        ULONG       Length;
        PNPAGED_LOOKASIDE_LIST  LookasideList;

        if (SizeNeeded > glLargeDataBufferSize) {
            DbgPrint("NDISWAN: Error Allocating SendDesc Size %d\n",
                     SizeNeeded);
            return (NULL);
        } else if (SizeNeeded > glSmallDataBufferSize) {
            LookasideList = &LargeDataDescList;
        } else {
            LookasideList = &SmallDataDescList;
        }

        DataDesc =
            NdisAllocateFromNPagedLookasideList(LookasideList);

        if (DataDesc == NULL) {
            return (NULL);
        }

        DataDesc->LookasideList = LookasideList;

        PPROTOCOL_RESERVED_FROM_NDIS(DataDesc->NdisPacket)->MagicNumber =
            MAGIC_INTERNAL_SEND;

        SendDesc = &DataDesc->SendDesc;
        NdisZeroMemory(SendDesc, sizeof(SEND_DESC));

        SendDesc->Signature = SENDESC_SIG;
        SendDesc->LinkCB = LinkCB;
        SendDesc->NdisPacket =
            DataDesc->NdisPacket;
        SendDesc->NdisBuffer =
            DataDesc->NdisBuffer;

        NdisQueryBuffer(SendDesc->NdisBuffer,
                        &SendDesc->StartBuffer,
                        &Length);
    }

    LinkCB->SendResources -= 1;
    LinkCB->BundleCB->SendResources -= 1;

    return (SendDesc);
}

VOID
NdisWanFreeSendDesc(
    PSEND_DESC  SendDesc
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    POPENCB     OpenCB;
    PDATA_DESC  DataDesc;
    PLINKCB     LinkCB;
    PNPAGED_LOOKASIDE_LIST  LookasideList;

    LinkCB =
        SendDesc->LinkCB;

    OpenCB = LinkCB->OpenCB;

    DataDesc = 
        CONTAINING_RECORD(SendDesc, DATA_DESC, SendDesc);

    LookasideList = DataDesc->LookasideList;

    if (OpenCB->Flags & OPEN_LEGACY) {

        if (OpenCB->WanInfo.MemoryFlags == 0) {

            NdisFreeToNPagedLookasideList(LookasideList, DataDesc);

        } else {

            NdisInterlockedPushEntrySList(&OpenCB->WanPacketList,
                                          (PSLIST_ENTRY)DataDesc,
                                          &OpenCB->Lock);
        }

    } else {
        PNDIS_BUFFER    NdisBuffer;
        PNDIS_PACKET    NdisPacket;

        NdisBuffer = 
            DataDesc->NdisBuffer;

        NdisPacket =
            DataDesc->NdisPacket;

#if DBG
        {
        ULONG           BufferCount;

        NdisQueryPacket(NdisPacket,
                        NULL,
                        &BufferCount,
                        NULL,
                        NULL);

        ASSERT(BufferCount == 1);
        }
#endif

        NdisAdjustBufferLength(NdisBuffer,
                               DataDesc->DataBufferLength);

        NdisRecalculatePacketCounts(NdisPacket);

        NDIS_SET_PACKET_HEADER_SIZE(NdisPacket, 
                                    MAC_HEADER_LENGTH);

        NDIS_SET_PACKET_STATUS(NdisPacket, 
                               NDIS_STATUS_SUCCESS);

        ASSERT(PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->MagicNumber == MAGIC_INTERNAL_SEND);

        NdisFreeToNPagedLookasideList(LookasideList, DataDesc);
    }

    LinkCB->SendResources += 1;
    LinkCB->BundleCB->SendResources += 1;
}

PCL_AFSAPCB
NdisWanAllocateClAfSapCB(
    POPENCB             OpenCB,
    PCO_ADDRESS_FAMILY  AddressFamily
    )
{
    PCL_AFSAPCB AfSapCB;

    AfSapCB =
        NdisAllocateFromNPagedLookasideList(&AfSapVcCBList);

    if (AfSapCB == NULL) {
        return (NULL);
    }

    NdisZeroMemory(AfSapCB, sizeof(CL_AFSAPCB));

    AfSapCB->Signature = CLAFSAP_SIG;
    AfSapCB->OpenCB = OpenCB;

    AfSapCB->Af.AddressFamily = AddressFamily->AddressFamily;
    AfSapCB->Af.MajorVersion = AddressFamily->MajorVersion;
    AfSapCB->Af.MinorVersion = AddressFamily->MinorVersion;

    AfSapCB->RefCount = 1;
    AfSapCB->Flags = AF_OPENING;

    return (AfSapCB);
}

VOID
NdisWanFreeClAfSapCB(
    PCL_AFSAPCB AfSapCB
    )
{
    NdisFreeToNPagedLookasideList(&AfSapVcCBList,
                                  AfSapCB);
}

PCM_AFSAPCB
NdisWanAllocateCmAfSapCB(
    PMINIPORTCB MiniportCB
    )
{
    PCM_AFSAPCB AfSapCB;

    AfSapCB =
    NdisAllocateFromNPagedLookasideList(&AfSapVcCBList);

    if (AfSapCB == NULL) {
        return (NULL);
    }

    NdisZeroMemory(AfSapCB, sizeof(CM_AFSAPCB));

    AfSapCB->Signature = CMAFSAP_SIG;
    AfSapCB->MiniportCB = MiniportCB;

    REF_MINIPORTCB(MiniportCB);

    NdisAcquireSpinLock(&MiniportCB->Lock);

    InsertHeadList(&MiniportCB->AfSapCBList,
                   &AfSapCB->Linkage);

    NdisWanInitializeNotificationEvent(&AfSapCB->NotificationEvent);

    NdisWanInterlockedInc(&MiniportCB->AfRefCount);

    NdisReleaseSpinLock(&MiniportCB->Lock);

    return (AfSapCB);
}

VOID
NdisWanFreeCmAfSapCB(
    PCM_AFSAPCB AfSapCB
    )
{
    PMINIPORTCB MiniportCB  = AfSapCB->MiniportCB;

    NdisAcquireSpinLock(&MiniportCB->Lock);

    NdisWanInterlockedDec(&MiniportCB->AfRefCount);

    RemoveEntryList(&AfSapCB->Linkage);

    NdisReleaseSpinLock(&MiniportCB->Lock);

    DEREF_MINIPORTCB(MiniportCB);

    NdisFreeToNPagedLookasideList(&AfSapVcCBList,
                                  AfSapCB);
}

PCM_VCCB
NdisWanAllocateCmVcCB(
    PCM_AFSAPCB AfSapCB,
    NDIS_HANDLE NdisVcHandle
    )
{
    PCM_VCCB    CmVcCB;

    CmVcCB =
        NdisAllocateFromNPagedLookasideList(&AfSapVcCBList);

    if (CmVcCB == NULL) {
        return (NULL);
    }

    NdisZeroMemory(CmVcCB, sizeof(CM_VCCB));

    CmVcCB->AfSapCB = AfSapCB;
    CmVcCB->Signature = CMVC_SIG;
    CmVcCB->NdisVcHandle = NdisVcHandle;

    return (CmVcCB);
}

VOID
NdisWanFreeCmVcCB(
    PCM_VCCB    CmVcCB
    )
{
    NdisFreeToNPagedLookasideList(&AfSapVcCBList, CmVcCB);
}

NDIS_STATUS
AllocateIoNdisPacket(
    ULONG           SizeNeeded,
    PNDIS_PACKET    *NdisPacket,
    PNDIS_BUFFER    *NdisBuffer, 
    PUCHAR          *DataBuffer
    )
/*++

Routine Name:
    
    AllocateIoNdisPacket
    
Routine Description:

    This routine will alocate a packet used to send a PPP control
    packet over a wan endpoint.  The routine is written with the
    assumption that there will only ever be a single NDIS_BUFFER
    attached to the packet.  This buffer is attached immediately
    to the front of the packet.  Before calling a miniport the
    NDIS_BUFFER must have it's length adjusted and the packet must
    recalculate all counts.

Arguments:

Return Values:

--*/
{
    PDATA_DESC  DataDesc;
    ULONG       Length;
    PNPAGED_LOOKASIDE_LIST  LookasideList;

    if (SizeNeeded > glLargeDataBufferSize) {

        DbgPrint("NDISWAN: Error Allocating IoNdisPacket Size %d\n",
                 SizeNeeded);
        return (NDIS_STATUS_FAILURE);
    } else if (SizeNeeded > glSmallDataBufferSize) {
        LookasideList = &LargeDataDescList;
    } else {
        LookasideList = &SmallDataDescList;
    }

    DataDesc =
        NdisAllocateFromNPagedLookasideList(LookasideList);

    if (DataDesc == NULL) {
        return (NDIS_STATUS_RESOURCES);
    }

    DataDesc->LookasideList = LookasideList;

    *NdisPacket =
        DataDesc->NdisPacket;

    PPROTOCOL_RESERVED_FROM_NDIS(DataDesc->NdisPacket)->MagicNumber =
        MAGIC_INTERNAL_IO;

    PPROTOCOL_RESERVED_FROM_NDIS(DataDesc->NdisPacket)->DataDesc =
        DataDesc;

    *NdisBuffer =
        DataDesc->NdisBuffer;

    NdisQueryBuffer(DataDesc->NdisBuffer,
                    &DataDesc->DataBuffer,
                    &Length);
    *DataBuffer =
        DataDesc->DataBuffer;

    return (NDIS_STATUS_SUCCESS);
}

VOID
FreeIoNdisPacket(
    PNDIS_PACKET    NdisPacket
)
/*++

Routine Name:

    FreeIoNdisPacket
    
Routine Description:

    This routine will free a packet used to send a PPP control
    packet over a wan endpoint.  The routine is written with the
    assumption that there will only ever be a single NDIS_BUFFER
    attached to the packet.  This buffer does not have to be
    explicitly removed from the packet here as a pointer to it
    is stored in the DATA_DESC itself and will be freed when
    the DATA_DESC is freed.

Arguments:

Return Values:

--*/
{
    PDATA_DESC      DataDesc;
    PNDIS_BUFFER    NdisBuffer;
    PNPAGED_LOOKASIDE_LIST  LookasideList;

    DataDesc = 
        PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->DataDesc;

    ASSERT(PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->MagicNumber == MAGIC_INTERNAL_IO);

    LookasideList = 
        DataDesc->LookasideList;

    NdisAdjustBufferLength(DataDesc->NdisBuffer,
                           DataDesc->DataBufferLength);

    NdisRecalculatePacketCounts(NdisPacket);

    NDIS_SET_PACKET_HEADER_SIZE(NdisPacket, 
                                MAC_HEADER_LENGTH);

    NDIS_SET_PACKET_STATUS(NdisPacket, 
                           NDIS_STATUS_SUCCESS);

    NdisFreeToNPagedLookasideList(LookasideList, DataDesc);
}

PVOID
AllocateWanPacket(
    IN  POOL_TYPE   PoolType,
    IN  SIZE_T      NumberOfBytes,
    IN  ULONG       Tag
    )
{
    PVOID   pMem;

    NdisWanAllocatePriorityMemory(&pMem,
                                  NumberOfBytes,
                                  Tag,
                                  NormalPoolPriority);

    return(pMem);
}

VOID
FreeWanPacket(
    PVOID   WanPacket
    )
{
    NdisWanFreeMemory(WanPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\packet.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    packet.h
    
Abstract:

    This file contains data structures used by the NdisWan driver
    to define ndis packet particulars.
    


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      02/11/97

--*/

#ifndef _NDISWAN_PACKETS_
#define _NDISWAN_PACKETS_

#define MAGIC_EXTERNAL_RECV     '!RxE'
#define MAGIC_EXTERANL_SEND     '!SxE'
#define MAGIC_INTERNAL_IO       '!InI'
#define MAGIC_INTERNAL_SEND     '!SnI'      
#define MAGIC_INTERNAL_RECV     '!RnI'
#define MAGIC_INTERNAL_ALLOC    '!AnI'

//
// The first 16 bytes of the protocol reserved section
// of a ndis packet indicated to ndiswan by a miniport
// belong to ndiswan
//
typedef struct _NDISWAN_RECV_RESERVED {
    LIST_ENTRY  Linkage;
    ULONG       MagicNumber;
    ULONG       NdisPacket;
} NDISWAN_RECV_RESERVED, *PNDISWAN_RECV_RESERVED;

//
// When ndiswan indicates a ndis packet to a protocol
// the first 16 bytes of the protocol reseved belong to
// the transport.  NdisWan will store its information
// beyond this area.
//
typedef struct _NDISWAN_PROTOCOL_RESERVED {
    UCHAR               Reserved[16];   // 16 bytes reserved for the protocol
    union {
        SINGLE_LIST_ENTRY   SLink;
        ULONG               MagicNumber;
    };
    struct _POOL_DESC   *PoolDesc;
    struct _LINKCB      *LinkCB;

    union {
        struct _RECV_DESC   *RecvDesc;
        struct _SEND_DESC   *SendDesc;
        struct _DATA_DESC   *DataDesc;
    };
} NDISWAN_PROTOCOL_RESERVED, *PNDISWAN_PROTOCOL_RESERVED;

typedef struct _NDISWAN_MINIPORT_RESERVED {
    union {
        PNDIS_PACKET    Next;
        ULONG           RefCount;   // Used to count number of fragments
    };
    struct _CM_VCCB *CmVcCB;
} NDISWAN_MINIPORT_RESERVED, *PNDISWAN_MINIPORT_RESERVED;

typedef struct _POOLDESC_LIST {
    LIST_ENTRY      List;
    NDIS_SPIN_LOCK  Lock;
    ULONG           TotalDescCount;
    ULONG           MaxDescCount;
    ULONG           AllocatedCount;
    ULONG           MaxAllocatedCount;
    ULONG           FreeCount;
} POOLDESC_LIST, *PPOOLDESC_LIST;

typedef struct _POOL_DESC {
    LIST_ENTRY          Linkage;
    SINGLE_LIST_ENTRY   Head;
    NDIS_HANDLE         PoolHandle;
    ULONG               AllocatedCount;
    ULONG               MaxAllocatedCount;
    ULONG               FreeCount;
} POOL_DESC, *PPOOL_DESC;

typedef struct _PACKET_QUEUE {
    PNDIS_PACKET    HeadQueue;      // Queue of ndis packets
                                        // waiting to be sent
    PNDIS_PACKET    TailQueue;      // Last packet on the queue

    ULONG           ByteDepth;
    ULONG           MaxByteDepth;
    ULONG           PacketDepth;
    ULONG           MaxPacketDepth;
    ULONG           DumpedPacketCount;
    ULONG           DumpedByteCount;
    LONG            OutstandingFrags;
} PACKET_QUEUE, *PPACKET_QUEUE;

#endif // end of _NDISWAN_PACKETS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\io.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    io.c

Abstract:

    This file contains the procedures to process I/O requests from
    a User Mode entity.  All OS dependent I/O interface functions
    will be conditionally coded, and will be responsible for translating
    the I/O functions from the OS format to buffers that are useable by
    the main I/O handling routine.


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe  06/06/95    Created


--*/

#include "wan.h"

#define __FILE_SIG__    IO_FILESIG

//
// Local function prototypes
//

NTSTATUS
ExecuteIo(
    IN  ULONG   ulFuncCode,
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    );

NTSTATUS
MapConnectionId(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetBundleHandle(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
ActivateRoute(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
BundleLink(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetBandwidthOnDemand(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetThresholdEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
IoSendPacket(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
IoReceivePacket(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
FlushReceivePacket(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetStatistics(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetLinkInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetLinkInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetCompressionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetCompressionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetVJInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetVJInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetIdleTime(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetBandwidthUtilization(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetWanInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    );

NTSTATUS
DeactivateRoute(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetDriverInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetProtocolEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetProtocolEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
IoGetProtocolInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetHibernateEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
UnmapConnectionId(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

VOID
CancelIoReceivePackets(
    VOID
    );

VOID
AddProtocolCBToBundle(
    PPROTOCOLCB ProtocolCB,
    PBUNDLECB   BundleCB
    );

NDIS_HANDLE
AssignProtocolCBHandle(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB
    );

VOID
FreeProtocolCBHandle(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB
    );

NTSTATUS
NotImplemented(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    );
//
// These functions are not used by RASMAN hence are disabled to reduce attack surface.
//
    
#if 0

NTSTATUS
SetFriendlyName(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
EnumLinksInBundle(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
SetProtocolPriority(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);
      
NTSTATUS
SetEncryptionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetEncryptionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);
      
NTSTATUS
SetDebugInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
EnumActiveBundles(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
FlushThresholdEvents(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
FlushHibernateEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
EnumProtocolUtilization(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
FlushProtocolEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);

NTSTATUS
GetBundleInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
);
      
#endif

//
// End of local function prototypes
//
CONST
IO_DISPATCH_TABLE   IoDispatchTable[] =
{
    {FUNC_MAP_CONNECTION_ID     , MapConnectionId},
    {FUNC_GET_BUNDLE_HANDLE     , GetBundleHandle},
    {FUNC_SET_FRIENDLY_NAME     , NotImplemented},  //SetFriendlyName},
    {FUNC_ROUTE                 , ActivateRoute},
    {FUNC_ADD_LINK_TO_BUNDLE    , BundleLink},
    {FUNC_ENUM_LINKS_IN_BUNDLE  , NotImplemented},  //EnumLinksInBundle},
    {FUNC_SET_PROTOCOL_PRIORITY , NotImplemented},  //SetProtocolPriority},
    {FUNC_SET_BANDWIDTH_ON_DEMAND, SetBandwidthOnDemand},
    {FUNC_SET_THRESHOLD_EVENT   , SetThresholdEvent},
    {FUNC_FLUSH_THRESHOLD_EVENTS, NotImplemented},  //FlushThresholdEvents},
    {FUNC_SEND_PACKET           , IoSendPacket},
    {FUNC_RECEIVE_PACKET        , IoReceivePacket},
    {FUNC_FLUSH_RECEIVE_PACKETS , FlushReceivePacket},
    {FUNC_GET_STATS             , GetStatistics},
    {FUNC_SET_LINK_INFO         , SetLinkInfo},
    {FUNC_GET_LINK_INFO         , GetLinkInfo},
    {FUNC_SET_COMPRESSION_INFO  , SetCompressionInfo},
    {FUNC_GET_COMPRESSION_INFO  , GetCompressionInfo},
    {FUNC_SET_BRIDGE_INFO       , NotImplemented},
    {FUNC_GET_BRIDGE_INFO       , NotImplemented},
    {FUNC_SET_VJ_INFO           , SetVJInfo},
    {FUNC_GET_VJ_INFO           , GetVJInfo},
    {FUNC_SET_CIPX_INFO         , NotImplemented},
    {FUNC_GET_CIPX_INFO         , NotImplemented},
    {FUNC_SET_ENCRYPTION_INFO   , NotImplemented},  //SetEncryptionInfo},
    {FUNC_GET_ENCRYPTION_INFO   , NotImplemented},  //GetEncryptionInfo},
    {FUNC_SET_DEBUG_INFO        , NotImplemented},  //SetDebugInfo},
    {FUNC_ENUM_ACTIVE_BUNDLES   , NotImplemented},  //EnumActiveBundles},
    {FUNC_GET_NDISWANCB         , NotImplemented},
    {FUNC_GET_MINIPORTCB        , NotImplemented},
    {FUNC_GET_OPENCB            , NotImplemented},
    {FUNC_GET_BANDWIDTH_UTILIZATION, GetBandwidthUtilization},
    {FUNC_ENUM_PROTOCOL_UTILIZATION, NotImplemented},   //EnumProtocolUtilization},
    {FUNC_ENUM_MINIPORTCB       , NotImplemented},
    {FUNC_ENUM_OPENCB           , NotImplemented},
    {FUNC_GET_WAN_INFO          , GetWanInfo},
    {FUNC_GET_IDLE_TIME         , GetIdleTime},
    {FUNC_UNROUTE               , DeactivateRoute},
    {FUNC_GET_DRIVER_INFO       , GetDriverInfo},
    {FUNC_SET_PROTOCOL_EVENT    , SetProtocolEvent},
    {FUNC_GET_PROTOCOL_EVENT    , GetProtocolEvent},
    {FUNC_FLUSH_PROTOCOL_EVENT  , NotImplemented},  //FlushProtocolEvent},
    {FUNC_GET_PROTOCOL_INFO     , IoGetProtocolInfo},
    {FUNC_SET_HIBERNATE_EVENT   , SetHibernateEvent},
    {FUNC_FLUSH_HIBERNATE_EVENT , NotImplemented},  //FlushHibernateEvent},
    {FUNC_GET_BUNDLE_INFO       , NotImplemented},  //GetBundleInfo},
    {FUNC_UNMAP_CONNECTION_ID   , UnmapConnectionId}
};

#define MAX_FUNC_CODES  sizeof(IoDispatchTable)/sizeof(IO_DISPATCH_TABLE)

#ifdef NT

NTSTATUS
NdisWanIoctl(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS    Status, ReturnStatus;
    ULONG   ulBytesWritten = 0;

    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Ioctl Function Code
    //
    ULONG   ulFuncCode = (pIrpSp->Parameters.DeviceIoControl.IoControlCode >> 2) & 0x00000FFF ;
    ULONG   ulDeviceType = (pIrpSp->Parameters.DeviceIoControl.IoControlCode >> 16) & 0x0000FFFF;
    ULONG   ulMethod = pIrpSp->Parameters.DeviceIoControl.IoControlCode & 0x00000003;

    //
    // Input buffer, Output buffer, and lengths
    //
    PUCHAR  pInputBuffer = pIrp->AssociatedIrp.SystemBuffer;
    PUCHAR  pOutputBuffer = pInputBuffer;
    ULONG   ulInputBufferLength = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    ULONG   ulOutputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    // 
    // if this is win64 make sure the calling process is 64bit
    // since this interface is only used by rasman and rasman
    // will always be 64bit on 64bit systems we will not bother
    // with thunking.  if the process is not a 64bit process get
    // out.
#ifdef _WIN64
    if (IoIs32bitProcess(pIrp)) {

        pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        return (STATUS_NOT_SUPPORTED);
    }
#endif

//  NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanIoctl: FunctionCode: 0x%x, MajorFunction: 0x%x, DeviceType: 0x%x",
//                  ulFuncCode, pIrpSp->MajorFunction, ulDeviceType));
    
#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if ((pIrpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
        (ulDeviceType != FILE_DEVICE_NDISWAN) ||
        (ulMethod != METHOD_BUFFERED) ||
        (pDeviceObject != NdisWanCB.pDeviceObject)) {

        if (NdisWanCB.MajorFunction[pIrpSp->MajorFunction] == NULL) {
            pIrp->IoStatus.Information = 0;
            pIrp->IoStatus.Status = STATUS_SUCCESS;
        
            IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
        
            return(STATUS_SUCCESS);
            
        }

        return(NdisWanCB.MajorFunction[pIrpSp->MajorFunction](pDeviceObject, pIrp));
    }
#else
    if (pIrpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL ||
        ulDeviceType != FILE_DEVICE_NETWORK ||
        ulMethod != METHOD_BUFFERED) {

        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        return (STATUS_NOT_SUPPORTED);
    }
#endif

    //
    // If this is a function code that requires an irp to be pended and completed
    // later, we need to queue the irp up somewhere.  In order for this to be somewhat
    // portable we will pass the irp in as the input buffer and store it in a
    // a structure that it has it's own linkage for queueing.
    //
    if ((ulFuncCode == FUNC_SET_THRESHOLD_EVENT) ||
        (ulFuncCode == FUNC_RECEIVE_PACKET) ||
        (ulFuncCode == FUNC_SET_PROTOCOL_EVENT) ||
        (ulFuncCode == FUNC_SET_HIBERNATE_EVENT)) {

        pInputBuffer = (PUCHAR)pIrp;
    }

    Status = ExecuteIo(ulFuncCode,
                       pInputBuffer,
                       ulInputBufferLength,
                       pOutputBuffer,
                       ulOutputBufferLength,
                       &ulBytesWritten);


//  NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanIoctl: Status: 0x%x, BytesWritten: %d",
//                  Status, ulBytesWritten));

    switch (Status) {
        case STATUS_SUCCESS:
            ReturnStatus = Status;
            pIrp->IoStatus.Information = ulBytesWritten;
            break;

        case STATUS_PENDING:
            return(Status);

        case STATUS_INFO_LENGTH_MISMATCH:
            //
            // See if this was a request to get size needed for
            // ioctl.
            //
            if (ulOutputBufferLength >= sizeof(ULONG)) {
            
                *(PULONG)pOutputBuffer = ulBytesWritten;
                ulBytesWritten = sizeof(ULONG);
                pIrp->IoStatus.Information = sizeof(ULONG);
            } else {
                pIrp->IoStatus.Information = 0;
            }
            ReturnStatus = Status = 
                STATUS_SUCCESS;
            break;

        default:
            if (Status < 0xC0000000) {
                Status = 
                ReturnStatus = STATUS_UNSUCCESSFUL;
            } else {
                ReturnStatus = Status;
            }
            pIrp->IoStatus.Information = 0;
            break;
    }

    pIrp->IoStatus.Status = Status;

    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return(ReturnStatus);
}

NTSTATUS
NdisWanIrpStub(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    // NdisWanDbgOut(DBG_VERBOSE, DBG_IO, ("NdisWanIrpStub: Entry"));

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if (pDeviceObject != NdisWanCB.pDeviceObject &&
        NdisWanCB.MajorFunction[pIrpSp->MajorFunction] != NULL) {

        NdisWanDbgOut(DBG_VERBOSE, DBG_IO, ("NdisWanIrpStub: Exit1"));

        return(NdisWanCB.MajorFunction[pIrpSp->MajorFunction](pDeviceObject, pIrp));
    }

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    NdisWanDbgOut(DBG_VERBOSE, DBG_IO, ("NdisWanIrpStub: Exit2"));

    return (STATUS_SUCCESS);
#else

    pIrp->IoStatus.Information = 0;

    pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    // NdisWanDbgOut(DBG_VERBOSE, DBG_IO, ("NdisWanIrpStub: Exit2"));

    return (STATUS_NOT_SUPPORTED);
#endif

}


NTSTATUS
NdisWanCreate(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Name:

    NdisWanCreate

Routine Description:

    This routine is called when an app (rasman) opens ndiswan.

Arguments:

Return Values:

--*/
{
    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCreate: Entry"));

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if (pDeviceObject != NdisWanCB.pDeviceObject &&
        NdisWanCB.MajorFunction[pIrpSp->MajorFunction] != NULL) {

        NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCreate: Exit1"));

        return(NdisWanCB.MajorFunction[pIrpSp->MajorFunction](pDeviceObject, pIrp));
    }
#endif

    if (InterlockedIncrement(&NdisWanCB.RefCount) == 1) {
        ULONG   i;
        ULONG   ArraySize;
        PPROTOCOL_INFO  InfoArray;
        BOOLEAN bEvent = FALSE;

        //
        // This is the first guy!
        //
        NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

        ArraySize = ProtocolInfoTable->ulArraySize;

        for (i = 0, InfoArray = ProtocolInfoTable->ProtocolInfo;
             i < ArraySize; i++, InfoArray++) {

            if (InfoArray->ProtocolType != 0) {
                InfoArray->Flags |= PROTOCOL_EVENT_OCCURRED;
                bEvent = TRUE;
            }
        }

        if (bEvent) {
            ProtocolInfoTable->Flags |= PROTOCOL_EVENT_OCCURRED;
        }

        NdisReleaseSpinLock(&ProtocolInfoTable->Lock);
    }

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCreate: Exit2"));

    return (STATUS_SUCCESS);
}

NTSTATUS
NdisWanCleanup(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Name:

    NdisWanCleanup

Routine Description:

    This routine is called when all apps (rasman) that have opened
    ndiswan have gone away.  If ndiswan is still routed to any
    transports it will complete all sends and do linedowns to
    cleanup.

Arguments:

Return Values:

--*/
{
    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCleanup: Entry"));

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if (pDeviceObject != NdisWanCB.pDeviceObject &&
        NdisWanCB.MajorFunction[pIrpSp->MajorFunction] != NULL) {

        NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCleanup: Exit1"));

        return(NdisWanCB.MajorFunction[pIrpSp->MajorFunction](pDeviceObject, pIrp));
    }
#endif

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    InterlockedDecrement(&NdisWanCB.RefCount);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCleanup: Exit2"));

    return (STATUS_SUCCESS);
}

NTSTATUS
NdisWanPnPPower(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    //
    // Get current Irp stack location
    //
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanPnPPower: Entry"));

#ifdef MY_DEVICE_OBJECT
    //
    // Make sure that this is for us
    //
    if (pDeviceObject != NdisWanCB.pDeviceObject &&
        NdisWanCB.MajorFunction[pIrpSp->MajorFunction] != NULL) {

        NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanPnPPower: Exit1"));

        return(NdisWanCB.MajorFunction[pIrpSp->MajorFunction](pDeviceObject, pIrp));
    }
#endif

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    PoStartNextPowerIrp(pIrp);

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanPnPPower: Exit2"));

    return (STATUS_SUCCESS);
}

VOID
NdisWanCancelRoutine(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    BOOLEAN Found = FALSE;
    PLIST_ENTRY Entry;
    ULONG       CopySize = 0;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("NdisWanCancelRoutine: Irp 0x%p", pIrp));

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    do {

        //
        // Is this the hibernate event irp?
        //
        NdisAcquireSpinLock(&NdisWanCB.Lock);

        if (pIrp == NdisWanCB.HibernateEventIrp) {
            NdisWanCB.HibernateEventIrp = NULL;
            Found = TRUE;
        }

        NdisReleaseSpinLock(&NdisWanCB.Lock);

        if (Found) {
            break;
        }

        //
        // Is this the protocol event irp?
        //
        NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

        if (pIrp == ProtocolInfoTable->EventIrp) {
            ProtocolInfoTable->EventIrp = NULL;
            Found = TRUE;
        }

        NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

        if (Found) {
            break;
        }

        //
        // We need to walk the async event queue looking for
        // the async event that this irp is associated with
        //
        NdisAcquireSpinLock(&IoRecvList.Lock);

        for (Entry = IoRecvList.IrpList.Flink;
            Entry != &IoRecvList.IrpList;
            Entry = Entry->Flink) {

            PIRP MyIrp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

            if (MyIrp == (PVOID)pIrp) {

                IoRecvList.ulIrpCount--;

                //
                // Remove from the list
                //
                RemoveEntryList(Entry);

                Found = TRUE;

                ((PNDISWAN_IO_PACKET)(pIrp->AssociatedIrp.SystemBuffer))->usHandleType = CANCELEDHANDLE;

                INSERT_RECV_EVENT('c');

                CopySize = sizeof(NDISWAN_IO_PACKET);

                IoRecvList.LastIrp = pIrp;
                IoRecvList.LastIrpStatus = STATUS_SUCCESS;
                IoRecvList.LastCopySize = CopySize;

                IoRecvList.LastPacketNumber =
                    ((PNDISWAN_IO_PACKET)(pIrp->AssociatedIrp.SystemBuffer))->PacketNumber;

                break;
            }
        }

        NdisReleaseSpinLock(&IoRecvList.Lock);

        if (Found) {
            break;
        }

        NdisAcquireSpinLock(&ThresholdEventQueue.Lock);

        for (Entry = ThresholdEventQueue.List.Flink;
            Entry != &ThresholdEventQueue.List;
            Entry = Entry->Flink) {

            PIRP MyIrp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

            if (MyIrp == (PVOID)pIrp) {

                ThresholdEventQueue.ulCount--;

                //
                // Remove from the list
                //
                RemoveEntryList(Entry);

                Found = TRUE;
                break;
            }
        }

        NdisReleaseSpinLock(&ThresholdEventQueue.Lock);

    } while (FALSE);


    //
    // Complete the irp
    //
    pIrp->Cancel = TRUE;
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = CopySize;
    
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    
}

#endif

NTSTATUS
ExecuteIo(
    IN  ULONG   ulFuncCode,
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("ExecuteIo: FuncCode 0x%x", ulFuncCode));

    if (ulFuncCode < MAX_FUNC_CODES) {

        Status = (*IoDispatchTable[ulFuncCode].Function)(pInputBuffer,
                                                         ulInputBufferLength,
                                                         pOutputBuffer,
                                                         ulOutputBufferLength,
                                                         pulBytesWritten);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("ExecuteIo: Status 0x%x", Status));

    return (Status);
}

NTSTATUS
MapConnectionId(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    MapConnectionId

Routine Description:

    This functions takes a WAN Wrapper connection id, finds the corresponding
    LinkCB and BundleCB, and returns handles to these CB's.

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_MAP_CONNECTION_ID

    ulInputBufferLength - Length of input buffer should be sizeof(NDISWAN_MAP_CONNECTION_ID)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_MAP_CONNNECTION_ID

    ulOutputBufferLength - Length of output buffer should be sizeof(NDISWAN_MAP_CONNECTION_ID)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here

Return Values:

    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INFO_LENGTH_MISMATCH
    STATUS_SUCCESS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNDISWAN_MAP_CONNECTION_ID In = (PNDISWAN_MAP_CONNECTION_ID)pInputBuffer;
    PNDISWAN_MAP_CONNECTION_ID Out = (PNDISWAN_MAP_CONNECTION_ID)pOutputBuffer;
    ULONG   SizeNeeded = sizeof(NDISWAN_MAP_CONNECTION_ID);
    ULONG       i;
    POPENCB OpenCB = NULL;
    PLINKCB  LinkCB = NULL;
    PBUNDLECB   BundleCB = NULL;
    LOCK_STATE  LockState;
    ULONG       Count;
    BOOLEAN     Found = FALSE;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("MapConnectionId:"));

    *pulBytesWritten = SizeNeeded;

    if (ulInputBufferLength < SizeNeeded ||
        ulOutputBufferLength < SizeNeeded) {

        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("MapConnectionId: Buffer to small: Size: %d, SizeNeeded %d",
                      ulOutputBufferLength, SizeNeeded));

        return (STATUS_INFO_LENGTH_MISMATCH);
    }

    ASSERT(In->hLinkContext != NULL);

    do {
    
        //
        // Find the linkcb that has this connection id and return
        // both the linkcb index and the bundlecb index
        //
        NdisAcquireReadWriteLock(&ConnTableLock, FALSE, &LockState);

        do {
            ULONG   index;
            PLIST_ENTRY le;

            if (PtrToUlong(In->hConnectionID) < ConnectionTable->ulArraySize) {
                //
                // This might be my handle and thus a direct index
                //
                LinkCB = *(ConnectionTable->LinkArray +
                           PtrToUlong(In->hConnectionID));

                if ((LinkCB != NULL) &&
                    (LinkCB->hLinkContext == NULL)) {
                    Found = TRUE;
                    break;
                }
            }

            //
            // The connectionid was not my handle so find the 
            // correct linkcb in the connection table.  Walk
            // the list backward.
            //
            le = ConnectionTable->LinkList.Blink;

            while (le != &ConnectionTable->LinkList) {

                LinkCB = 
                    CONTAINING_RECORD(le, LINKCB, ConnTableLinkage);

                if (LinkCB != NULL &&
                    In->hConnectionID == LinkCB->ConnectionWrapperID &&
                    LinkCB->hLinkContext == NULL) {
                    Found = TRUE;
                    break;
                }

                le = le->Blink;
            }

        } while (FALSE);

        if (!Found) {

            NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

            break;
        }

        NdisDprAcquireSpinLock(&LinkCB->Lock);

        if (LinkCB->State != LINK_UP) {

            Found = FALSE;

            NdisDprReleaseSpinLock(&LinkCB->Lock);

            NdisReleaseReadWriteLock(&ConnTableLock, &LockState);
            break;
        }
    
        BundleCB = LinkCB->BundleCB;

        //
        // We have found the right link, return the link and bundle handles
        //
        Out->hLinkHandle = LinkCB->hLinkHandle;
        Out->hBundleHandle = BundleCB->hBundleHandle;

        LinkCB->hLinkContext = In->hLinkContext;
        BundleCB->hBundleContext = In->hBundleContext;

        REF_LINKCB(LinkCB);

        //
        // Copy the friendly name to the link
        //
        {
            ULONG   CopyLength;

            CopyLength = (ulInputBufferLength - 
                 FIELD_OFFSET(NDISWAN_MAP_CONNECTION_ID, szName[0]));

            CopyLength = (CopyLength > In->ulNameLength) ?
                In->ulNameLength : CopyLength;

            CopyLength = (CopyLength > MAX_NAME_LENGTH) ?
                MAX_NAME_LENGTH : CopyLength;

            NdisMoveMemory(LinkCB->Name, In->szName, CopyLength);
            LinkCB->Name[MAX_NAME_LENGTH - 1] = '\0';
        }

        OpenCB = LinkCB->OpenCB;

        NdisDprReleaseSpinLock(&LinkCB->Lock);

        //
        // If this link has some recv's pending because
        // we did not have a context mapped yet, we could
        // get into a state where our recv's stall.  We
        // will kick start this by scheduling a routine
        // to complete the pending recv's.
        //
        NdisDprAcquireSpinLock(&IoRecvList.Lock);

        if (LinkCB->RecvDescCount != 0){

            if (!IoRecvList.TimerScheduled) {
                WAN_TIME    TimeOut;

                IoRecvList.TimerScheduled = TRUE;
                NdisWanInitWanTime(&TimeOut, 15);
                KeSetTimer(&IoRecvList.Timer,
                           TimeOut,
                           &IoRecvList.Dpc);
            }
        }

        NdisDprReleaseSpinLock(&IoRecvList.Lock);

        NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

    } while ( 0 );

    if (!Found) {
        //
        // We did not find a match to the connection id
        //
        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("MapConnectionId: ConnectionId not found! ConnectionId: 0x%x",
                      In->hConnectionID));

        *pulBytesWritten = 0;
        Status = NDISWAN_ERROR_INVALID_HANDLE;
    }

    if (OpenCB != NULL) {
        //
        // Wait for initialization to complete
        //
        NdisWanWaitForNotificationEvent(&OpenCB->InitEvent);
    }

    return (Status);
}


NTSTATUS
GetBundleHandle(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    GetBundleHandle

Routine Description:

    This function takes a handle to a linkcb and returns the handle to the bundlecb
    that the linkcb belongs to

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_GET_BUNDLE_HANDLE

    ulInputBufferLength - Length of the input buffer should be sizeof(NDISWAN_GET_BUNDLE_HANDLE)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_GET_BUNDLE_HANDLE

    ulOutputBufferLength - Length of the output buffer should be sizeof(NDISWAN_GET_BUNDLE_HANDLE)

Return Values:

    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INFO_LENGTH_MISMATCH
    STATUS_SUCCESS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNDISWAN_GET_BUNDLE_HANDLE In = (PNDISWAN_GET_BUNDLE_HANDLE)pInputBuffer;
    PNDISWAN_GET_BUNDLE_HANDLE Out = (PNDISWAN_GET_BUNDLE_HANDLE)pOutputBuffer;
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_BUNDLE_HANDLE);
    PLINKCB     LinkCB = NULL;
    PBUNDLECB   BundleCB = NULL;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetBundleHandle:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulInputBufferLength < SizeNeeded ||
            ulOutputBufferLength < SizeNeeded) {
            
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetBundleHandle: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
    
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
    
        if (!AreLinkAndBundleValid(In->hLinkHandle, 
                                   TRUE, 
                                   &LinkCB, 
                                   &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO,
                ("GetBundleHandle: Invalid LinkHandle: 0x%x", In->hLinkHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        //
        // Get the bundle handle that this link belongs to
        //
        Out->hBundleHandle = BundleCB->hBundleHandle;


    } while ( 0 );

    //
    // Derefs for the refs applied in AreLinkAndBundleValid
    //
    DEREF_LINKCB(LinkCB);
    DEREF_BUNDLECB(BundleCB);

    return (Status);
}

NTSTATUS
ActivateRoute(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    ActivateRoute

Routine Description:

    This function routes the bundle given by hbundlehandle to
    the protocol give by usprotocoltype.

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_ACTIVATE_ROUTE

    ulInputBufferLength - Length of input buffer should be sizeof(NDISWAN_ACTIVATE_ROUTE)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_ACTIVATE_ROUTE

    ulOutputBufferLength - Length of output buffer should be sizeof(NDISWAN_ACTIVATE_ROUTE)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here

Return Values:

    NDISWAN_ERROR_ALREADY_ROUTED
    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INSUFFICIENT_RESOURCES
    STATUS_INFO_LENGTH_MISMATCH

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNDISWAN_ROUTE In = (PNDISWAN_ROUTE)pInputBuffer;
    PNDISWAN_ROUTE  Out = (PNDISWAN_ROUTE)pOutputBuffer;
    ULONG   SizeNeeded = sizeof(NDISWAN_ROUTE);
    ULONG   AllocationSize, i;
    PBUNDLECB   BundleCB = NULL;
    BOOLEAN RouteExists = FALSE;
    PPROTOCOLCB ProtocolCB;
    NDIS_HANDLE hProto;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("ActivateRoute:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulInputBufferLength < SizeNeeded ||
            ulOutputBufferLength < SizeNeeded ||
            In->usBindingNameLength > MAX_NAME_LENGTH ||
            In->ulBufferLength > ulInputBufferLength - FIELD_OFFSET(NDISWAN_ROUTE, Buffer)) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("ActivateRoute: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
    
        //
        // If this is a valid bundle
        //
        if (!IsBundleValid(In->hBundleHandle, 
                           TRUE, 
                           &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("ActivateRoute: Invalid BundleHandle: 0x%x, ProtocolType: 0x%x",
                          In->hBundleHandle, In->usProtocolType));
    
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        AcquireBundleLock(BundleCB);

        //
        // Create and initialize a ProtocolCB for this new route
        //
        ProtocolCB =
            NdisWanAllocateProtocolCB(In);
    
        if (ProtocolCB == NULL) {
            //
            // Memory allocation failed
            //
            ReleaseBundleLock(BundleCB);
    
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    
        //
        // Assign a handle for this protocolcb
        //
        hProto =
            AssignProtocolCBHandle(BundleCB, ProtocolCB);

        if (hProto == (NDIS_HANDLE)MAX_PROTOCOLS) {
    
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("ActivateRoute: No room in ProtocolCB Table: ProtocolType: 0x%2.2x",
                          ProtocolCB->ProtocolType));

            ProtocolCB->State = PROTOCOL_UNROUTING;

            NdisWanFreeProtocolCB(ProtocolCB);

            ReleaseBundleLock(BundleCB);

            Status = NDISWAN_ERROR_NO_ROUTE;
            break;
        }
    
        //
        // Do a new lineup to protocol
        //
        ReleaseBundleLock(BundleCB);
    
        Status = DoNewLineUpToProtocol(ProtocolCB);
    
        if (Status == NDIS_STATUS_SUCCESS) {
    
            Out->usDeviceNameLength =
            (ProtocolCB->OutDeviceName.Length > MAX_NAME_LENGTH) ?
            MAX_NAME_LENGTH : ProtocolCB->OutDeviceName.Length;
    
            NdisMoveMemory(&Out->DeviceName[0],
                           ProtocolCB->OutDeviceName.Buffer,
                           Out->usDeviceNameLength);
    
            //
            // Insert the protocolcb in the bundle's protocolcb table
            // and list.
            //
            AddProtocolCBToBundle(ProtocolCB, BundleCB);

        } else {
    
            AcquireBundleLock(BundleCB);

            FreeProtocolCBHandle(BundleCB, ProtocolCB);

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("ActivateRoute: Error during LineUp to ProtocolType: 0x%x",
                          ProtocolCB->ProtocolType));

            ProtocolCB->State = PROTOCOL_UNROUTING;

            NdisWanFreeProtocolCB(ProtocolCB);

            ReleaseBundleLock(BundleCB);
        }

    } while ( 0 );

    //
    // Deref for ref applied by IsBundleValid
    //
    DEREF_BUNDLECB(BundleCB);

    return (Status);
}


NTSTATUS
BundleLink(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    BundleLink

Routine Description:

    This function bundles the link given by hLinkHandle to the bundle given
    by hBundlehandle.  The resources used by the bundle that the link used
    to belong to are freed.

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_ADD_LINK_TO_BUNDLE

    ulInputBufferLength - Length of input buffer should be sizeof(NDISWAN_ADD_LINK_TO_BUNDLE)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_ADD_LINK_TO_BUNDLE

    ulOutputBufferLength - Length of output buffer should be sizeof(NDISWAN_ADD_LINK_TO_BUNDLE)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here

Return Values:

    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INFO_LENGTH_MISMATCH

--*/
{
    ULONG       SizeNeeded = sizeof(NDISWAN_ADD_LINK_TO_BUNDLE);
    PLINKCB     LinkCB = NULL;
    PBUNDLECB   OldBundleCB = NULL, NewBundleCB = NULL;
    NTSTATUS    Status = STATUS_SUCCESS;
    PPROTOCOLCB     IoProtocolCB;
    PPACKET_QUEUE   PacketQueue;
    PACKET_QUEUE    TempPacketQueue;

    PNDISWAN_ADD_LINK_TO_BUNDLE In =
        (PNDISWAN_ADD_LINK_TO_BUNDLE)pInputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("BundleLink:"));

    *pulBytesWritten = 0;

    do {

        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("BundleLink: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
    
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!AreLinkAndBundleValid(In->hLinkHandle, 
                                   TRUE,
                                   &LinkCB, 
                                   &OldBundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("BundleLink: Invalid LinkHandle: 0x%x",
                          In->hLinkHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        if (!IsBundleValid(In->hBundleHandle, 
                           TRUE,
                           &NewBundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("BundleLink: Invalid NewBundleCB: 0x%p, OldBundleCB: 0x%p",
                          NewBundleCB, OldBundleCB));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        if (NewBundleCB == OldBundleCB) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("BundleLink: Invalid NewBundleCB: 0x%p, OldBundleCB: 0x%p",
                          NewBundleCB, OldBundleCB));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        AcquireBundleLock(OldBundleCB);
    
        ASSERT(OldBundleCB->ulLinkCBCount == 1);
        ASSERT(OldBundleCB->ulNumberOfRoutes == 0);
    
        OldBundleCB->State = BUNDLE_GOING_DOWN;
    
        if (OldBundleCB->OutstandingFrames != 0) {
    
            NdisWanClearSyncEvent(&OldBundleCB->OutstandingFramesEvent);
    
            OldBundleCB->Flags |= FRAMES_PENDING_EVENT;
    
            ReleaseBundleLock(OldBundleCB);
    
            NdisWanWaitForSyncEvent(&OldBundleCB->OutstandingFramesEvent);
    
            AcquireBundleLock(OldBundleCB);

        }

        //
        // Remove any ppp packets that might be on the old bundle
        // queue so we can move them to the new bundle.
        //

        IoProtocolCB = OldBundleCB->IoProtocolCB;
        PacketQueue = &IoProtocolCB->PacketQueue[MAX_MCML];

        NdisZeroMemory(&TempPacketQueue, sizeof(TempPacketQueue));

        if (!IsPacketQueueEmpty(PacketQueue)) {

            while (!IsPacketQueueEmpty(PacketQueue)) {
                PNDIS_PACKET     Packet;
                UINT            PacketLength;
                
                Packet =
                    RemoveHeadPacketQueue(PacketQueue);

                NdisQueryPacket(Packet,
                                NULL,
                                NULL,
                                NULL,
                                &PacketLength);

                InsertTailPacketQueue(&TempPacketQueue, 
                                      Packet, 
                                      PacketLength);
            }
        }
    
        //
        // Remove the link from the old bundle.  This returns
        // with the OldBundleCB lock released!
        //
        RemoveLinkFromBundle(OldBundleCB, LinkCB, TRUE);
    
        AcquireBundleLock(NewBundleCB);
    
        //
        // Add the link to the new bundle
        //
        AddLinkToBundle(NewBundleCB, LinkCB);

        SetBundleFlags(NewBundleCB);

        //
        // If there were any ppp packets on the old bundle
        // queue we can now place them on the new bundle.
        //
        if (!IsPacketQueueEmpty(&TempPacketQueue)) {

            IoProtocolCB = NewBundleCB->IoProtocolCB;
            PacketQueue = &IoProtocolCB->PacketQueue[MAX_MCML];

            while (!IsPacketQueueEmpty(&TempPacketQueue)) {
                PNDIS_PACKET     Packet;
                UINT            PacketLength;

                Packet =
                    RemoveHeadPacketQueue(&TempPacketQueue)

                NdisQueryPacket(Packet,
                                NULL,
                                NULL,
                                NULL,
                                &PacketLength);

                InsertTailPacketQueue(PacketQueue,
                                      Packet,
                                      PacketLength);
            }
        }

        ReleaseBundleLock(NewBundleCB);

    } while ( 0 );

    //
    // Derefs for the refs applied by AreLinkAndBundleValid
    //
    DEREF_LINKCB(LinkCB);
    DEREF_BUNDLECB(OldBundleCB);

    //
    // Deref for the ref applied by IsBundleValid
    //
    DEREF_BUNDLECB(NewBundleCB);

    return (Status);
}

NTSTATUS
SetBandwidthOnDemand(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    SetBandwidthOnDemand

Routine Description:

    This function sets the bandwidth on demand parameters for the bundle given by
    hbundlehandle.

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_SET_BANDWIDTH_ON_DEMAND

    ulInputBufferLength - Length of input buffer should be sizeof(NDISWAN_SET_BANDWIDTH_ON_DEMAND)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_SET_BANDWIDTH_ON_DEMAND

    ulOutputBufferLength - Length of output buffer should be sizeof(NDISWAN_SET_BANDWIDTH_ON_DEMAND)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here

Return Values:

    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INFO_LENGTH_MISMATCH

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PBUNDLECB BundleCB = NULL;
    ULONG   SizeNeeded = sizeof(NDISWAN_SET_BANDWIDTH_ON_DEMAND);
    PNDISWAN_SET_BANDWIDTH_ON_DEMAND In = (PNDISWAN_SET_BANDWIDTH_ON_DEMAND)pInputBuffer;
    WAN_TIME    Temp1, Temp2;
    ULONGLONG   SecondsInSamplePeriod;
    ULONGLONG   BytesPerSecond;
    ULONGLONG   BytesInSamplePeriod;
    ULONGLONG   temp;
    ULONG       LowestSamplePeriod = 0;
    PBOND_INFO      BonDInfo;
    PSAMPLE_TABLE   SampleTable;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetBandwidthOnDemand:"));

    *pulBytesWritten = 0;

    if (ulInputBufferLength < SizeNeeded) {
        
        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetBandwidthOnDemand: Buffer to small: Size: %d, SizeNeeded %d",
                      ulInputBufferLength, SizeNeeded));
        *pulBytesWritten = SizeNeeded;
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // If this is a valid bundle handle
    //
    if (!IsBundleValid(In->hBundleHandle, 
                       TRUE,
                       &BundleCB)) {

        NdisWanDbgOut(DBG_FAILURE, DBG_IO,
            ("SetBandwidthOnDemand: Invalid BundleHandle: 0x%x",
                In->hBundleHandle));

        return NDISWAN_ERROR_INVALID_HANDLE;
    }
    
    do {
        AcquireBundleLock(BundleCB);

        if (BundleCB->BonDAllocation == NULL) {
            PUCHAR  pMem;

            NdisWanAllocatePriorityMemory(&pMem,
                                          BONDALLOC_SIZE,
                                          BONDALLOC_TAG,
                                          LowPoolPriority);

            if (pMem == NULL) {

                // ReleaseBundleLock(BundleCB);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            BundleCB->BonDAllocation = pMem;

            BundleCB->SUpperBonDInfo = (PBOND_INFO)pMem;

            pMem += (sizeof(BOND_INFO) + sizeof(PVOID));
            (ULONG_PTR)pMem &= ~((ULONG_PTR)sizeof(PVOID) - 1);
            BundleCB->SLowerBonDInfo = (PBOND_INFO)pMem;

            pMem += (sizeof(BOND_INFO) + sizeof(PVOID));
            (ULONG_PTR)pMem &= ~((ULONG_PTR)sizeof(PVOID) - 1);
            BundleCB->RUpperBonDInfo = (PBOND_INFO)pMem;

            pMem += (sizeof(BOND_INFO) + sizeof(PVOID));
            (ULONG_PTR)pMem &= ~((ULONG_PTR)sizeof(PVOID) - 1);
            BundleCB->RLowerBonDInfo = (PBOND_INFO)pMem;

            BonDInfo = BundleCB->SUpperBonDInfo;
            BonDInfo->DataType = TRANSMIT_DATA;
            BonDInfo->usPercentBandwidth = 0xFFFF;

            SampleTable = &BonDInfo->SampleTable;
            SampleTable->ulSampleArraySize = SAMPLE_ARRAY_SIZE;

            BonDInfo = BundleCB->SLowerBonDInfo;
            BonDInfo->DataType = TRANSMIT_DATA;
            BonDInfo->usPercentBandwidth = 0xFFFF;
            SampleTable = &BonDInfo->SampleTable;
            SampleTable->ulSampleArraySize = SAMPLE_ARRAY_SIZE;

            BonDInfo = BundleCB->RUpperBonDInfo;
            BonDInfo->DataType = RECEIVE_DATA;
            BonDInfo->usPercentBandwidth = 0xFFFF;

            SampleTable = &BonDInfo->SampleTable;
            SampleTable->ulSampleArraySize = SAMPLE_ARRAY_SIZE;

            BonDInfo = BundleCB->RLowerBonDInfo;
            BonDInfo->DataType = RECEIVE_DATA;
            BonDInfo->usPercentBandwidth = 0xFFFF;
            SampleTable = &BonDInfo->SampleTable;
            SampleTable->ulSampleArraySize = SAMPLE_ARRAY_SIZE;
        }
    
        if (In->usLowerXmitThreshold > 0) {
            BonDInfo = BundleCB->SLowerBonDInfo;
            SampleTable = &BonDInfo->SampleTable;

            //
            // One second is the smallest sample period we support!
            //
            if (In->ulLowerXmitSamplePeriod < 1000) {
                In->ulLowerXmitSamplePeriod = 1000;
            }

    
            //
            // We need to init the sample period in 100 nanoseconds
            //
            NdisWanInitWanTime(&Temp1, MILS_TO_100NANOS);
            NdisWanInitWanTime(&Temp2, In->ulLowerXmitSamplePeriod);
            NdisWanMultiplyWanTime(&SampleTable->SamplePeriod,
                                   &Temp1,&Temp2);
    
            //
            // The sample rate is the sample period divided by the number of
            // samples in the sample array
            //
            NdisWanInitWanTime(&Temp1, SampleTable->ulSampleArraySize);
            NdisWanDivideWanTime(&SampleTable->SampleRate,
                                 &SampleTable->SamplePeriod,
                                 &Temp1);
    
            //
            // Convert %bandwidth to Bytes/SamplePeriod
            // 100bsp * 100 / 8 = BytesPerSecond
            // BytesPerSecond * SecondsInSamplePeriod = BytesInSamplePeriod
            // BytesInSamplePeriod * %Bandwidth / 100 = BytesInSamplePeriod
            //
            SecondsInSamplePeriod = BonDInfo->ulSecondsInSamplePeriod =
                In->ulLowerXmitSamplePeriod / 1000;
        
            BytesPerSecond =
                BundleCB->SFlowSpec.PeakBandwidth;
        
            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;

            BonDInfo->ulBytesInSamplePeriod = BytesInSamplePeriod;
        
            BonDInfo->usPercentBandwidth = In->usLowerXmitThreshold;
    
            temp = In->usLowerXmitThreshold;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            if (BonDInfo->State == BonDSignaled) {
                BonDInfo->State = BonDIdle;
            }
    
            NdisWanGetSystemTime(&BonDInfo->StartTime);
    
            if (In->ulLowerXmitSamplePeriod < LowestSamplePeriod ||
                LowestSamplePeriod == 0) {
                LowestSamplePeriod = In->ulLowerXmitSamplePeriod;
            }
        }
    
        if (In->usUpperXmitThreshold > 0) {
            BonDInfo = BundleCB->SUpperBonDInfo;
            SampleTable = &BonDInfo->SampleTable;
    
            //
            // One second is the smallest sample period we support!
            //
            if (In->ulUpperXmitSamplePeriod < 1000) {
                In->ulUpperXmitSamplePeriod = 1000;
            }

            //
            // We need to init the sample period in 100 nanoseconds
            //
            NdisWanInitWanTime(&Temp1, MILS_TO_100NANOS);
            NdisWanInitWanTime(&Temp2, In->ulUpperXmitSamplePeriod);
            NdisWanMultiplyWanTime(&SampleTable->SamplePeriod,
                                   &Temp1,
                                   &Temp2);
    
            //
            // The sample rate is the sample period divided by the number of
            // samples in the sample array
            //
            NdisWanInitWanTime(&Temp1, SampleTable->ulSampleArraySize);
            NdisWanDivideWanTime(&SampleTable->SampleRate,
                                 &SampleTable->SamplePeriod,
                                 &Temp1);
    
            //
            // Convert %bandwidth to Bytes/SamplePeriod
            // 100bsp * 100 / 8 = BytesPerSecond
            // BytesPerSecond * SecondsInSamplePeriod = BytesInSamplePeriod
            // BytesInSamplePeriod * %Bandwidth / 100 = BytesInSamplePeriod
            //
            SecondsInSamplePeriod = BonDInfo->ulSecondsInSamplePeriod =
                In->ulUpperXmitSamplePeriod / 1000;
        
            BytesPerSecond =
                BundleCB->SFlowSpec.PeakBandwidth;
        
            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;
        
            BonDInfo->ulBytesInSamplePeriod = 
                (ULONG)BytesInSamplePeriod;

            BonDInfo->usPercentBandwidth = In->usUpperXmitThreshold;
    
            temp = In->usUpperXmitThreshold;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            if (BonDInfo->State == BonDSignaled) {
                BonDInfo->State = BonDIdle;
            }
            NdisWanGetSystemTime(&BonDInfo->StartTime);
    
            if (In->ulUpperXmitSamplePeriod < LowestSamplePeriod ||
                LowestSamplePeriod == 0) {
                LowestSamplePeriod = In->ulUpperXmitSamplePeriod;
            }
        }
    
        if (In->usLowerRecvThreshold > 0) {
            BonDInfo = BundleCB->RLowerBonDInfo;
            SampleTable = &BonDInfo->SampleTable;
    
            //
            // One second is the smallest sample period we support!
            //
            if (In->ulLowerRecvSamplePeriod < 1000) {
                In->ulLowerRecvSamplePeriod = 1000;
            }

            //
            // We need to init the sample period in 100 nanoseconds
            //
            NdisWanInitWanTime(&Temp1, MILS_TO_100NANOS);
            NdisWanInitWanTime(&Temp2, In->ulLowerRecvSamplePeriod);
            NdisWanMultiplyWanTime(&SampleTable->SamplePeriod,
                                   &Temp1,&Temp2);
    
            //
            // The sample rate is the sample period divided by the number of
            // samples in the sample array
            //
            NdisWanInitWanTime(&Temp1, SampleTable->ulSampleArraySize);
            NdisWanDivideWanTime(&SampleTable->SampleRate,
                                 &SampleTable->SamplePeriod,
                                 &Temp1);
    
            //
            // Convert %bandwidth to Bytes/SamplePeriod
            // 100bsp * 100 / 8 = BytesPerSecond
            // BytesPerSecond * SecondsInSamplePeriod = BytesInSamplePeriod
            // BytesInSamplePeriod * %Bandwidth / 100 = BytesInSamplePeriod
            //
            SecondsInSamplePeriod = BonDInfo->ulSecondsInSamplePeriod =
                In->ulLowerRecvSamplePeriod / 1000;
        
            BytesPerSecond =
                BundleCB->RFlowSpec.PeakBandwidth;
        
            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;
        
            BonDInfo->ulBytesInSamplePeriod = BytesInSamplePeriod;

            BonDInfo->usPercentBandwidth = In->usLowerRecvThreshold;

            temp = In->usLowerRecvThreshold;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            if (BonDInfo->State == BonDSignaled) {
                BonDInfo->State = BonDIdle;
            }
            NdisWanGetSystemTime(&BonDInfo->StartTime);
    
            if (In->ulLowerRecvSamplePeriod < LowestSamplePeriod ||
                LowestSamplePeriod == 0) {
                LowestSamplePeriod = In->ulLowerRecvSamplePeriod;
            }
        }
    
        if (In->usUpperRecvThreshold > 0) {
            BonDInfo = BundleCB->RUpperBonDInfo;
            SampleTable = &BonDInfo->SampleTable;
    
            //
            // One second is the smallest sample period we support!
            //
            if (In->ulUpperRecvSamplePeriod < 1000) {
                In->ulUpperRecvSamplePeriod = 1000;
            }

            //
            // We need to init the sample period in 100 nanoseconds
            //
            NdisWanInitWanTime(&Temp1, MILS_TO_100NANOS);
            NdisWanInitWanTime(&Temp2, In->ulUpperRecvSamplePeriod);
            NdisWanMultiplyWanTime(&SampleTable->SamplePeriod,
                                   &Temp1,
                                   &Temp2);
    
            //
            // The sample rate is the sample period divided by the number of
            // samples in the sample array
            //
            NdisWanInitWanTime(&Temp1, SampleTable->ulSampleArraySize);
            NdisWanDivideWanTime(&SampleTable->SampleRate,
                                 &SampleTable->SamplePeriod,
                                 &Temp1);
    
            //
            // Convert %bandwidth to Bytes/SamplePeriod
            // 100bsp * 100 / 8 = BytesPerSecond
            // BytesPerSecond * SecondsInSamplePeriod = BytesInSamplePeriod
            // BytesInSamplePeriod * %Bandwidth / 100 = BytesInSamplePeriod
            //
            SecondsInSamplePeriod = BonDInfo->ulSecondsInSamplePeriod =
                In->ulUpperRecvSamplePeriod / 1000;
        
            BytesPerSecond =
                BundleCB->RFlowSpec.PeakBandwidth;
        
            BytesInSamplePeriod =
                BytesPerSecond * SecondsInSamplePeriod;
        
            BonDInfo->ulBytesInSamplePeriod = BytesInSamplePeriod;

            BonDInfo->usPercentBandwidth = In->usUpperRecvThreshold;
    
            temp = In->usUpperRecvThreshold;
            temp *= BytesInSamplePeriod;
            temp /= 100;

            BonDInfo->ulBytesThreshold = (ULONG)temp;

            if (BonDInfo->State == BonDSignaled) {
                BonDInfo->State = BonDIdle;
            }
            NdisWanGetSystemTime(&BonDInfo->StartTime);
    
            if (In->ulUpperRecvSamplePeriod < LowestSamplePeriod ||
                LowestSamplePeriod == 0) {
                LowestSamplePeriod = In->ulUpperRecvSamplePeriod;
            }
        }
    
#if 0
        //
        // I want to set a periodic timer with a period equal to
        // the smallest non-zero period
        //
        if (LowestSamplePeriod != 0) {
            LARGE_INTEGER   FireTime;
    
            BundleCB->TimerPeriod = LowestSamplePeriod/10;
    
            FireTime.QuadPart = Int32x32To64(BundleCB->TimerPeriod, -10000);
            KeSetTimerEx(&BundleCB->BonDTimer,
                         FireTime,
                         BundleCB->TimerPeriod,
                         &BundleCB->TimerDpc);
        }
#endif
        if (!(BundleCB->Flags & BOND_ENABLED) &&
            (LowestSamplePeriod != 0)) {
            
            InsertTailGlobalListEx(BonDWorkList, &BundleCB->BonDLinkage, 1000, 1000);

            BundleCB->Flags |= BOND_ENABLED;
        }

    } while ( 0 );

    //
    // Deref for ref applied by IsBundleValid.  This release the
    // BundleCB->Lock.
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);

    return (Status);
}


#ifdef NT
NTSTATUS
SetThresholdEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    SetThresholdEvent

Routine Description:

    This function queues up an asyncevent for bandwidth on demand
    events.

Arguments:

    pInputBuffer - Pointer to the input structure that should be WAN_ASYNC_EVENT

    ulInputBufferLength - Length of input buffer should be sizeof(WAN_ASYNC_EVENT)

    pOutputBuffer - Pointer to the output structure that should be WAN_ASYNC_EVENT

    ulOutputBufferLength - Length of output buffer should be sizeof(WAN_ASYNC_EVENT)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here


Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_SET_THRESHOLD_EVENT);
    PIRP    pIrp = (PIRP)pInputBuffer;
    KIRQL   Irql;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetThresholdEvent:"));

    *pulBytesWritten = 0;

    if (ulOutputBufferLength < SizeNeeded) {
        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetThresholdEvent: Buffer to small: Size: %d, SizeNeeded %d",
                      ulInputBufferLength, SizeNeeded));
        *pulBytesWritten = SizeNeeded;
        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    //
    // The IRP was pended so setup a cancel routine and let the
    // i/o subsystem know about the pend.
    //
    IoMarkIrpPending(pIrp);

    NdisAcquireSpinLock(&ThresholdEventQueue.Lock);
    //
    // Setup the structure
    //
    InsertTailList(&ThresholdEventQueue.List, &(pIrp->Tail.Overlay.ListEntry));

    ThresholdEventQueue.ulCount++;

    if (ThresholdEventQueue.ulCount > ThresholdEventQueue.ulMaxCount) {
        ThresholdEventQueue.ulMaxCount = ThresholdEventQueue.ulCount;
    }

    IoSetCancelRoutine(pIrp, NdisWanCancelRoutine);

    NdisReleaseSpinLock(&ThresholdEventQueue.Lock);

    return (STATUS_PENDING);
}
#endif

NTSTATUS
IoSendPacket(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   SizeNeeded = sizeof(NDISWAN_IO_PACKET);
    PNDISWAN_IO_PACKET In = (PNDISWAN_IO_PACKET)pInputBuffer;
    PLINKCB LinkCB = NULL;
    PBUNDLECB   BundleCB = NULL;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("IoSendPacket:"));

    *pulBytesWritten = 0;

    do {
        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_SEND, ("IoSendPacket: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (ulInputBufferLength - SizeNeeded > glLargeDataBufferSize ||
            In->usHeaderSize > glLargeDataBufferSize || 
            In->usPacketSize > glLargeDataBufferSize) {
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if ((LONG)ulInputBufferLength - FIELD_OFFSET(NDISWAN_IO_PACKET, PacketData) <
            (LONG)(In->usHeaderSize + In->usPacketSize)) {
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (In->usHandleType == LINKHANDLE) {
        
            if (!AreLinkAndBundleValid(In->hHandle, 
                                       TRUE,
                                       &LinkCB, 
                                       &BundleCB)) {

                NdisWanDbgOut(DBG_FAILURE, DBG_SEND, ("IoSendPacket: Invalid Handle: 0x%x, HandleType: 0x%x",
                              In->hHandle, In->usHandleType));
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }

            AcquireBundleLock(BundleCB);

        } else {

            if (!IsBundleValid(In->hHandle, 
                               TRUE,
                               &BundleCB)) {

                NdisWanDbgOut(DBG_FAILURE, DBG_SEND, ("IoSendPacket: Invalid Handle: 0x%x, HandleType: 0x%x",
                              In->hHandle, In->usHandleType));
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }
        
            AcquireBundleLock(BundleCB);

            if (BundleCB->ulLinkCBCount == 0) {

                NdisWanDbgOut(DBG_FAILURE, DBG_SEND, ("IoSendPacket: Invalid Handle: 0x%x, HandleType: 0x%x",
                              In->hHandle, In->usHandleType));
    
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }

            LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;

            //
            // LinkCB's lock can be acquired while BundleCB's lock
            // is held
            //
            NdisDprAcquireSpinLock(&LinkCB->Lock);

            if (LinkCB->State != LINK_UP) {
                NdisWanDbgOut(DBG_FAILURE, DBG_SEND, ("IoSendPacket: Invalid Handle: 0x%x, HandleType: 0x%x",
                              In->hHandle, In->usHandleType));
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                NdisDprReleaseSpinLock(&LinkCB->Lock);
                LinkCB = NULL;
                break;
            }

            REF_LINKCB(LinkCB);

            NdisDprReleaseSpinLock(&LinkCB->Lock);
        }

#if 0
        if (LinkCB->Stats.FramesTransmitted == 0) {
            if (In->PacketData[0] != 0xC0 ||
                In->PacketData[1] != 0x21 ||
                In->PacketData[2] != 0x01) {
                DbgPrint("NDISWAN: IOSP-FirstFrame not LCP ConfigReq bcb %p, lcb %p\n",
                         BundleCB, LinkCB);
                DbgBreakPoint();
            }
        }
#endif
        //
        // Queue an Ndis Packet for this send
        //
        Status = 
            BuildIoPacket(LinkCB, BundleCB, In, FALSE);
    
    } while ( 0 );

    //
    // Derefs for the refs applied above
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);

    return (Status);
}


#ifdef NT
NTSTATUS
IoReceivePacket(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_IO_PACKET) + 1500;
    PIRP    Irp = (PIRP)pInputBuffer;
    PIO_STACK_LOCATION  IrpSp;
    PNDISWAN_IO_PACKET  IoPacket;
    PRECV_DESC          RecvDesc;
    KIRQL               Irql;
    PLINKCB             LinkCB;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("IoReceivePacket:"));

    if (SizeNeeded > ulOutputBufferLength) {
        NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE, ("IoReceivePacket: Buffer to small: Size: %d, SizeNeeded %d",
                      ulOutputBufferLength, SizeNeeded));
        *pulBytesWritten = SizeNeeded;
        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    //
    // Do we have any receive's buffered up that
    // can be completed?
    //
    NdisAcquireSpinLock(&IoRecvList.Lock);

    RecvDesc = (PRECV_DESC)IoRecvList.DescList.Flink;

    while ((PVOID)RecvDesc != (PVOID)&IoRecvList.DescList) {

        LinkCB = RecvDesc->LinkCB;

        NdisDprAcquireSpinLock(&LinkCB->Lock);

        if ((LinkCB->hLinkContext != NULL)) {
            break;
        }

        NdisDprReleaseSpinLock(&LinkCB->Lock);

        RecvDesc = (PRECV_DESC)RecvDesc->Linkage.Flink;
    }

    IoMarkIrpPending(Irp);

    if ((PVOID)RecvDesc != (PVOID)&IoRecvList.DescList) {
        LONG        BufferLength, DataLength, CopySize;

        RemoveEntryList(&RecvDesc->Linkage);

        IoRecvList.ulDescCount--;

        LinkCB->RecvDescCount--;

        NdisDprReleaseSpinLock(&LinkCB->Lock);

        INSERT_RECV_EVENT('s');

        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        BufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
        DataLength = BufferLength - sizeof(NDISWAN_IO_PACKET) + 1;

        CopySize = (RecvDesc->CurrentLength > DataLength) ?
            DataLength : RecvDesc->CurrentLength;

        IoPacket = Irp->AssociatedIrp.SystemBuffer;

        IoPacket->hHandle = LinkCB->hLinkContext;
        IoPacket->usHandleType = LINKHANDLE;
        IoPacket->usHeaderSize = 14;
        IoPacket->usPacketSize = (USHORT)CopySize;
        IoPacket->usPacketFlags = 0;

        NdisMoveMemory(IoPacket->PacketData,
                       RecvDesc->CurrentBuffer,
                       CopySize);
#if DBG
        if (gbDumpRecv) {
            INT i;
            for (i = 0; i < RecvDesc->CurrentLength; i++) {
                if (i % 16 == 0) {
                    DbgPrint("\n");
                }
                DbgPrint("%x ", RecvDesc->CurrentBuffer[i]);
            }
            DbgPrint("\n");
        }
#endif

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(NDISWAN_IO_PACKET) - 1 + CopySize;

        IoRecvList.LastPacketNumber = IoPacket->PacketNumber;
        IoRecvList.LastIrp = Irp;
        IoRecvList.LastIrpStatus = STATUS_SUCCESS;
        IoRecvList.LastCopySize = (ULONG)Irp->IoStatus.Information;

        ASSERT((LONG_PTR)Irp->IoStatus.Information > 0);

        NdisReleaseSpinLock(&IoRecvList.Lock);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        NdisWanFreeRecvDesc(RecvDesc);

    } else {

        //
        // We did not have anything buffered so lets queue
        //

        //
        // The IRP was pended so setup a cancel routine and let the
        // i/o subsystem know about the pend.
        //

        //
        // Setup the structure
        //
        InsertTailList(&IoRecvList.IrpList, &(Irp->Tail.Overlay.ListEntry));

        IoRecvList.ulIrpCount++;

        IoSetCancelRoutine(Irp, NdisWanCancelRoutine);

        INSERT_RECV_EVENT('i');

        NdisReleaseSpinLock(&IoRecvList.Lock);
    }

    return (NDIS_STATUS_PENDING);
}

VOID
IoRecvIrpWorker(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Arg1,
    PVOID   Arg2
    )
{
    PLIST_ENTRY         Entry;
    PNDISWAN_IO_PACKET  IoPacket;
    PIO_STACK_LOCATION  IrpSp;
    PIRP                Irp;
    PRECV_DESC          RecvDesc;
    KIRQL               Irql;
    LONG                BufferLength, DataLength, CopySize;
    PLINKCB             LinkCB = NULL;

    NdisAcquireSpinLock(&IoRecvList.Lock);

    do {

        IoRecvList.TimerScheduled = FALSE;

        //
        // Do we have any irps that we can complete?
        //
        if (IoRecvList.ulIrpCount == 0) {
            break;
        }

        //
        // Do we have any receive's buffered up?
        //
        RecvDesc = (PRECV_DESC)IoRecvList.DescList.Flink;

        while ((PVOID)RecvDesc != (PVOID)&IoRecvList.DescList) {

            LinkCB = RecvDesc->LinkCB;

            NdisDprAcquireSpinLock(&LinkCB->Lock);

            if (LinkCB->hLinkContext != NULL) {
                break;
            }

            NdisDprReleaseSpinLock(&LinkCB->Lock);

            RecvDesc = (PRECV_DESC)RecvDesc->Linkage.Flink;
        }

        if ((PVOID)RecvDesc == (PVOID)&IoRecvList.DescList) {

            if (!IoRecvList.TimerScheduled) {
                WAN_TIME    TimeOut;

                IoRecvList.TimerScheduled = TRUE;
                NdisWanInitWanTime(&TimeOut, 15);
                KeSetTimer(&IoRecvList.Timer,
                           TimeOut,
                           &IoRecvList.Dpc);
            }

            break;
        }

        Entry = IoRecvList.IrpList.Flink;
        Irp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);
        if (!IoSetCancelRoutine(Irp, NULL)) {
            break;
        }

        //
        // Get the recvdesc
        //
        RemoveEntryList(&RecvDesc->Linkage);

        IoRecvList.ulDescCount--;

        LinkCB->RecvDescCount--;

        RemoveHeadList(&IoRecvList.IrpList);

        IoRecvList.ulIrpCount--;

        INSERT_RECV_EVENT('w');

        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        BufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
        DataLength = BufferLength - sizeof(NDISWAN_IO_PACKET);

        CopySize = (RecvDesc->CurrentLength > DataLength) ?
            DataLength : RecvDesc->CurrentLength;

        IoPacket = Irp->AssociatedIrp.SystemBuffer;

        IoPacket->hHandle = LinkCB->hLinkContext;
        IoPacket->usHandleType = LINKHANDLE;
        IoPacket->usHeaderSize = 14;
        IoPacket->usPacketSize = (USHORT)CopySize;
        IoPacket->usPacketFlags = 0;

        NdisDprReleaseSpinLock(&LinkCB->Lock);

        NdisReleaseSpinLock(&IoRecvList.Lock);

#if DBG
        if (gbDumpRecv) {
            INT i;
            for (i = 0; i < RecvDesc->CurrentLength; i++) {
                if (i % 16 == 0) {
                    DbgPrint("\n");
                }
                DbgPrint("%x ", RecvDesc->CurrentBuffer[i]);
            }
            DbgPrint("\n");
        }
#endif

        NdisMoveMemory(IoPacket->PacketData,
                       RecvDesc->CurrentBuffer,
                       CopySize);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(NDISWAN_IO_PACKET) - 1 + CopySize;

        IoRecvList.LastPacketNumber = IoPacket->PacketNumber;
        IoRecvList.LastIrp = Irp;
        IoRecvList.LastIrpStatus = STATUS_SUCCESS;
        IoRecvList.LastCopySize = (ULONG)Irp->IoStatus.Information;

        ASSERT((LONG_PTR)Irp->IoStatus.Information > 0);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        NdisWanFreeRecvDesc(RecvDesc);

        NdisAcquireSpinLock(&IoRecvList.Lock);

    } while (FALSE);

    NdisReleaseSpinLock(&IoRecvList.Lock);
}

#endif


NTSTATUS
FlushReceivePacket(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("FlushReceivePacket:"));

    *pulBytesWritten = 0;

    CancelIoReceivePackets();

    return (STATUS_SUCCESS);
}


NTSTATUS
GetStatistics(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_STATS);
    PNDISWAN_GET_STATS  In = (PNDISWAN_GET_STATS)pInputBuffer;
    PNDISWAN_GET_STATS  Out = (PNDISWAN_GET_STATS)pOutputBuffer;
    PBUNDLECB   BundleCB = NULL;
    PLINKCB     LinkCB = NULL;

    NdisWanDbgOut(DBG_VERBOSE, DBG_IO, ("GetStatistics:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulOutputBufferLength < SizeNeeded) {
    
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetStatistics: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
    
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        NdisZeroMemory(&Out->Stats, sizeof(Out->Stats));
    
        if (In->usHandleType == LINKHANDLE) {
    
            //
            // Looking for link stats
            //
            if (!AreLinkAndBundleValid(In->hHandle, 
                                       FALSE,
                                       &LinkCB, 
                                       &BundleCB)) {

                NdisWanDbgOut(DBG_INFO, DBG_IO, ("GetStatistics: Invalid LinkHandle: 0x%x",
                              In->hHandle));
    
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }

            AcquireBundleLock(BundleCB);

            //
            // At this point we have a valid bundlecb and linkcb
            //

            //
            // Copy the stats over
            //
            NdisMoveMemory((PUCHAR)&Out->Stats.LinkStats,
                           (PUCHAR)&LinkCB->Stats,
                           sizeof(WAN_STATS));


            //
            // Copy the stats over
            //
            NdisMoveMemory((PUCHAR)&Out->Stats.BundleStats,
                           (PUCHAR)&BundleCB->Stats,
                           sizeof(WAN_STATS));

        } else if (In->usHandleType == BUNDLEHANDLE) {

            //
            // Looking for bundle stats
            //
            if (!IsBundleValid(In->hHandle, 
                               FALSE,
                               &BundleCB)) {

                NdisWanDbgOut(DBG_INFO, DBG_IO, ("GetStatistics: Invalid BundleHandle: 0x%x",
                              In->hHandle));
    
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }

            AcquireBundleLock(BundleCB);

            //
            // At this point we have a valid bundlecb
            //

            //
            // Copy the stats over
            //
            NdisMoveMemory((PUCHAR)&Out->Stats.BundleStats,
                           (PUCHAR)&BundleCB->Stats,
                           sizeof(WAN_STATS));
        } else {
            Status = NDISWAN_ERROR_INVALID_HANDLE_TYPE;
            break;
        }

        //
        // If we only have one protocol bound see if
        // it is keeping stats
        //
        if (BundleCB->ulNumberOfRoutes == 1) {
            PPROTOCOLCB ProtocolCB;
            PMINIPORTCB MiniportCB;

            ProtocolCB =
                (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;

            MiniportCB = ProtocolCB->MiniportCB;

            if (MiniportCB->Flags & PROTOCOL_KEEPS_STATS) {
                NDIS_WAN_GET_STATS  WanStats;

                ReleaseBundleLock(BundleCB);

                NdisZeroMemory(&WanStats, sizeof(NDIS_WAN_GET_STATS));

                ETH_COPY_NETWORK_ADDRESS(WanStats.LocalAddress, ProtocolCB->TransportAddress);

                NdisMoveMemory((PUCHAR)&WanStats.BytesSent,
                               (PUCHAR)&Out->Stats.BundleStats,
                               sizeof(WAN_STATS));

                NdisMIndicateStatus(MiniportCB->MiniportHandle,
                                    NDIS_STATUS_WAN_GET_STATS,
                                    &WanStats,
                                    sizeof(NDIS_WAN_GET_STATS));

                NdisMoveMemory((PUCHAR)&Out->Stats.LinkStats,
                               (PUCHAR)&WanStats.BytesSent,
                               sizeof(WAN_STATS));

                NdisMoveMemory((PUCHAR)&Out->Stats.BundleStats,
                               (PUCHAR)&WanStats.BytesSent,
                               sizeof(WAN_STATS));

                AcquireBundleLock(BundleCB);

            }
        }

    } while ( 0 );

    //
    // Derefs for the refs applied above
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (Status);
}


NTSTATUS
SetLinkInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           SizeNeeded = sizeof(NDISWAN_SET_LINK_INFO);
    WAN_REQUEST     WanRequest;
    PNDISWAN_SET_LINK_INFO  In = (PNDISWAN_SET_LINK_INFO)pInputBuffer;
    PWAN_LINK_INFO  LinkInfo;
    POPENCB         OpenCB;
    PLINKCB         TempLinkCB,LinkCB = NULL;
    PBUNDLECB       BundleCB = NULL;
    BOOLEAN         MediaBroadband = FALSE;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetLinkInfo:"));

    *pulBytesWritten = 0;

    do {

        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetLinkInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!AreLinkAndBundleValid(In->hLinkHandle, 
                                   TRUE,
                                   &LinkCB, 
                                   &BundleCB)) {

            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        LinkInfo = &LinkCB->LinkInfo;
        OpenCB = LinkCB->OpenCB;

        if (OpenCB->MediumType == NdisMediumAtm ||

            (OpenCB->MediumType == NdisMediumWan &&
            (OpenCB->MediumSubType == NdisWanMediumAtm ||
             OpenCB->MediumSubType == NdisWanMediumPppoe)) ||

            (OpenCB->MediumType == NdisMediumCoWan &&
            (OpenCB->MediumSubType == NdisWanMediumAtm ||
             OpenCB->MediumSubType == NdisWanMediumPppoe))) {

            MediaBroadband = TRUE;
        }

        //
        // Wait for initialization to complete
        //
        NdisWanWaitForNotificationEvent(&OpenCB->InitEvent);

        WanRequest.Type = SYNC;
        WanRequest.Origin = NDISWAN;
        NdisWanInitializeNotificationEvent(&WanRequest.NotificationEvent);
        WanRequest.OpenCB = OpenCB;
    
        if (OpenCB->Flags & OPEN_LEGACY) {
            NDIS_WAN_SET_LINK_INFO  WanMiniportLinkInfo;
    
            NdisZeroMemory(&WanMiniportLinkInfo, sizeof (NDIS_WAN_SET_LINK_INFO));
        
            //
            // Copy into buffer to be sent to WAN Miniport this
            // skips over the LinkHandle in the NDIS_WAN_SET_LINK_INFO
            // structure.
            //
            WanMiniportLinkInfo.NdisLinkHandle = LinkCB->NdisLinkHandle;
            WanMiniportLinkInfo.MaxSendFrameSize = In->LinkInfo.MaxSendFrameSize;
            WanMiniportLinkInfo.MaxRecvFrameSize = In->LinkInfo.MaxRecvFrameSize;
            WanMiniportLinkInfo.SendFramingBits = In->LinkInfo.SendFramingBits;
            WanMiniportLinkInfo.RecvFramingBits = In->LinkInfo.RecvFramingBits;
            WanMiniportLinkInfo.SendCompressionBits = In->LinkInfo.SendCompressionBits;
            WanMiniportLinkInfo.RecvCompressionBits = In->LinkInfo.RecvCompressionBits;
            WanMiniportLinkInfo.SendACCM = In->LinkInfo.SendACCM;
            WanMiniportLinkInfo.RecvACCM = In->LinkInfo.RecvACCM;
        
            //
            // Submit this to the WAN Miniport
            //
            WanRequest.NdisRequest.RequestType = 
                NdisRequestSetInformation;

            WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid = 
                OID_WAN_SET_LINK_INFO;

            WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer = 
                &WanMiniportLinkInfo;

            WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 
                sizeof(NDIS_WAN_SET_LINK_INFO);
        
            NdisWanSubmitNdisRequest(OpenCB, &WanRequest);
        
        } else {
            NDIS_WAN_CO_SET_LINK_INFO   WanMiniportLinkInfo;

            NdisAcquireSpinLock(&LinkCB->Lock);

            if (LinkCB->ClCallState == CL_CALL_CONNECTED) {

                //
                // Ref so that we don't allow the
                // vc to go away.
                //
                LinkCB->VcRefCount++;

                NdisReleaseSpinLock(&LinkCB->Lock);

                NdisZeroMemory(&WanMiniportLinkInfo, sizeof (NDIS_WAN_CO_SET_LINK_INFO));

                //
                // Copy into buffer to be sent to WAN Miniport this
                // skips over the LinkHandle in the NDIS_WAN_SET_LINK_INFO
                // structure.
                //
                WanMiniportLinkInfo.MaxSendFrameSize = In->LinkInfo.MaxSendFrameSize;
                WanMiniportLinkInfo.MaxRecvFrameSize = In->LinkInfo.MaxRecvFrameSize;
                WanMiniportLinkInfo.SendFramingBits = In->LinkInfo.SendFramingBits;
                WanMiniportLinkInfo.RecvFramingBits = In->LinkInfo.RecvFramingBits;
                WanMiniportLinkInfo.SendCompressionBits = In->LinkInfo.SendCompressionBits;
                WanMiniportLinkInfo.RecvCompressionBits = In->LinkInfo.RecvCompressionBits;
                WanMiniportLinkInfo.SendACCM = In->LinkInfo.SendACCM;
                WanMiniportLinkInfo.RecvACCM = In->LinkInfo.RecvACCM;

                //
                // Submit this to the WAN Miniport
                //
                WanRequest.NdisRequest.RequestType = 
                    NdisRequestSetInformation;

                WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid = 
                    OID_WAN_CO_SET_LINK_INFO;

                WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer = 
                    &WanMiniportLinkInfo;

                WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 
                    sizeof(NDIS_WAN_CO_SET_LINK_INFO);

                WanRequest.AfHandle = NULL;
                WanRequest.VcHandle = LinkCB->NdisLinkHandle;

                NdisWanSubmitNdisRequest(OpenCB, &WanRequest);

                NdisAcquireSpinLock(&LinkCB->Lock);

                DerefVc(LinkCB);

                NdisReleaseSpinLock(&LinkCB->Lock);

            } else {

                NdisReleaseSpinLock(&LinkCB->Lock);
            }
        }
    
        //
        // Copy info into our linkcb
        //
        AcquireBundleLock(BundleCB);
    
        ASSERT(In->LinkInfo.SendFramingBits != 0);
        ASSERT(In->LinkInfo.RecvFramingBits != 0);

        //
        // If we are using broadband the we must preserve the LLC and
        // ADDRESS_CONTROL framing bits.
        //
        if (MediaBroadband) {
            LinkInfo->SendFramingBits |= In->LinkInfo.SendFramingBits;
            LinkInfo->RecvFramingBits |= In->LinkInfo.RecvFramingBits;
        } else {
            LinkInfo->SendFramingBits = In->LinkInfo.SendFramingBits;
            LinkInfo->RecvFramingBits = In->LinkInfo.RecvFramingBits;
        }

        LinkCB->SFlowSpec.MaxSduSize = 
        LinkInfo->MaxSendFrameSize = In->LinkInfo.MaxSendFrameSize;

        if (OpenCB->WanInfo.MaxFrameSize < LinkCB->SFlowSpec.MaxSduSize) {
            LinkCB->SFlowSpec.MaxSduSize = OpenCB->WanInfo.MaxFrameSize;
        }

        LinkCB->RFlowSpec.MaxSduSize = 
        LinkInfo->MaxRecvFrameSize = In->LinkInfo.MaxRecvFrameSize;

        LinkInfo->SendCompressionBits = In->LinkInfo.SendCompressionBits;
        LinkInfo->RecvCompressionBits = In->LinkInfo.RecvCompressionBits;
        LinkInfo->SendACCM = In->LinkInfo.SendACCM;
        LinkInfo->RecvACCM = In->LinkInfo.RecvACCM;
        LinkInfo->MaxRRecvFrameSize = In->LinkInfo.MaxRRecvFrameSize;
        LinkInfo->MaxRSendFrameSize = In->LinkInfo.MaxRSendFrameSize;
    
        if (LinkInfo->RecvFramingBits & LLC_ENCAPSULATION) {
            LinkCB->RecvHandler = ReceiveLLC;
        } else if (LinkInfo->RecvFramingBits & PPP_FRAMING) {
            LinkCB->RecvHandler = ReceivePPP;
        } else if (LinkInfo->RecvFramingBits & RAS_FRAMING) {
            LinkCB->RecvHandler = ReceiveRAS;
        } else if (LinkInfo->RecvFramingBits & SLIP_FRAMING) {
            LinkCB->RecvHandler = ReceiveSLIP;
        } else if (LinkInfo->RecvFramingBits & (ARAP_V1_FRAMING | ARAP_V2_FRAMING)) {
            LinkCB->RecvHandler = ReceiveARAP;
        } else {
            if (MediaBroadband) {
                LinkCB->RecvHandler = DetectBroadbandFraming;
            } else {
                LinkCB->RecvHandler = DetectFraming;
            }
        }
    

        //
        // We need to set our bundle framing based on the framing for
        // each link in the bundle so we will walk the linkcb list
        // and | in each link's framing bits into the bundle.
        //
        //
        BundleCB->FramingInfo.SendFramingBits = 0;
        BundleCB->FramingInfo.RecvFramingBits = 0;
    
        for (TempLinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
            (PVOID)TempLinkCB != (PVOID)&BundleCB->LinkCBList;
            TempLinkCB = (PLINKCB)TempLinkCB->Linkage.Flink) {
    
            BundleCB->FramingInfo.SendFramingBits |= TempLinkCB->LinkInfo.SendFramingBits;
            BundleCB->FramingInfo.RecvFramingBits |= TempLinkCB->LinkInfo.RecvFramingBits;
        }
    
        BundleCB->FramingInfo.MaxRSendFrameSize = LinkInfo->MaxRSendFrameSize;
    
        //
        // Since I use the receive frame size for memory allocation.
        //
        BundleCB->FramingInfo.MaxRRecvFrameSize = (LinkInfo->MaxRRecvFrameSize) ?
                                                      LinkInfo->MaxRRecvFrameSize : glMRRU;

        //
        // If VJ header compression has been negotiated allocate
        // and initialize resources.
        //
        if (BundleCB->FramingInfo.SendFramingBits & SLIP_VJ_COMPRESSION ||
            BundleCB->FramingInfo.SendFramingBits & SLIP_VJ_AUTODETECT ||
            BundleCB->FramingInfo.RecvFramingBits & SLIP_VJ_COMPRESSION ||
            BundleCB->FramingInfo.RecvFramingBits & SLIP_VJ_AUTODETECT) {
    
            Status = sl_compress_init(&BundleCB->VJCompress, MAX_VJ_STATES);
    
            if (Status != NDIS_STATUS_SUCCESS) {
                NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("Error allocating VJ Info!"));
            }
        }
    
        //
        // Configure multilink variables if needed
        //
        if (BundleCB->FramingInfo.SendFramingBits & PPP_MULTILINK_FRAMING) {
            if (BundleCB->FramingInfo.SendFramingBits & PPP_SHORT_SEQUENCE_HDR_FORMAT) {
                BundleCB->SendSeqMask = SHORT_SEQ_MASK;
                BundleCB->SendSeqTest = TEST_SHORT_SEQ;
            } else {
                BundleCB->SendSeqMask = LONG_SEQ_MASK;
                BundleCB->SendSeqTest = TEST_LONG_SEQ;
            }
        }
            
        if (BundleCB->FramingInfo.RecvFramingBits & PPP_MULTILINK_FRAMING) {
            if (BundleCB->FramingInfo.RecvFramingBits & PPP_SHORT_SEQUENCE_HDR_FORMAT) {
                BundleCB->RecvSeqMask = SHORT_SEQ_MASK;
                BundleCB->RecvSeqTest = TEST_SHORT_SEQ;
            } else {
                BundleCB->RecvSeqMask = LONG_SEQ_MASK;
                BundleCB->RecvSeqTest = TEST_LONG_SEQ;
            }
        }

        SetBundleFlags(BundleCB);

        UpdateBundleInfo(BundleCB);
    
    } while ( 0 );

    //
    // Derefs for the refs applied by AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (Status);
}


NTSTATUS
GetLinkInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_LINK_INFO);
    PNDISWAN_GET_LINK_INFO  In = (PNDISWAN_GET_LINK_INFO)pInputBuffer;
    PNDISWAN_GET_LINK_INFO  Out = (PNDISWAN_GET_LINK_INFO)pOutputBuffer;
    PLINKCB         LinkCB = NULL;
    PWAN_LINK_INFO  LinkInfo;
    POPENCB         OpenCB;
    WAN_REQUEST     WanRequest;
    union {
        NDIS_WAN_GET_LINK_INFO      Mp;
        NDIS_WAN_CO_GET_LINK_INFO   Co;
    } WanMiniportLinkInfo;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetLinkInfo:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetLinkInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!IsLinkValid(In->hLinkHandle, 
                         TRUE,
                         &LinkCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetLinkInfo: Invalid LinkHandle: 0x%x",
                          In->hLinkHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        LinkInfo = &LinkCB->LinkInfo;
        OpenCB = LinkCB->OpenCB;

        WanRequest.Type = SYNC;
        WanRequest.Origin = NDISWAN;
        NdisWanInitializeNotificationEvent(&WanRequest.NotificationEvent);
        WanRequest.OpenCB = OpenCB;
        NdisZeroMemory(&WanMiniportLinkInfo, 
                       sizeof (WanMiniportLinkInfo));
    
        if (OpenCB->Flags & OPEN_LEGACY) {

            BOOLEAN MediaBroadband = FALSE;

            if (OpenCB->MediumType == NdisMediumAtm ||

                (OpenCB->MediumType == NdisMediumWan &&
                (OpenCB->MediumSubType == NdisWanMediumAtm ||
                 OpenCB->MediumSubType == NdisWanMediumPppoe))) {

                MediaBroadband = TRUE;
            }
    
            //
            // Setup the link context for this request
            //
            WanMiniportLinkInfo.Mp.NdisLinkHandle = 
                LinkCB->NdisLinkHandle;
        
            //
            // Submit this to the WAN Miniport
            //
            WanRequest.NdisRequest.RequestType = 
                NdisRequestQueryInformation;

            WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid = 
                OID_WAN_GET_LINK_INFO;

            WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer = 
                &WanMiniportLinkInfo.Mp;

            WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 
                sizeof(NDIS_WAN_GET_LINK_INFO);
        
            Status = NdisWanSubmitNdisRequest(OpenCB, &WanRequest);
        
            if (Status == NDIS_STATUS_SUCCESS) {

                LinkInfo->MaxSendFrameSize = 
                    WanMiniportLinkInfo.Mp.MaxSendFrameSize;
                LinkInfo->MaxRecvFrameSize = 
                    WanMiniportLinkInfo.Mp.MaxRecvFrameSize;

                //
                // If we are using broadband the we must preserve the LLC and
                // ADDRESS_CONTROL framing bits.
                //
                if (MediaBroadband) {
                    LinkInfo->SendFramingBits |= 
                        WanMiniportLinkInfo.Mp.SendFramingBits;
                        
                    LinkInfo->RecvFramingBits |= 
                        WanMiniportLinkInfo.Mp.RecvFramingBits;
                } else {
                    LinkInfo->SendFramingBits = 
                        WanMiniportLinkInfo.Mp.SendFramingBits;
                    LinkInfo->RecvFramingBits = 
                        WanMiniportLinkInfo.Mp.RecvFramingBits;
                }
                    
                LinkInfo->SendCompressionBits = 
                    WanMiniportLinkInfo.Mp.SendCompressionBits;
                LinkInfo->RecvCompressionBits = 
                    WanMiniportLinkInfo.Mp.RecvCompressionBits;
                LinkInfo->SendACCM = 
                    WanMiniportLinkInfo.Mp.SendACCM;
                LinkInfo->RecvACCM = 
                    WanMiniportLinkInfo.Mp.RecvACCM;
            }

        } else {

            NdisAcquireSpinLock(&LinkCB->Lock);

            if (LinkCB->ClCallState == CL_CALL_CONNECTED) {

                //
                // Ref so that we don't allow the
                // vc to go away.
                //
                LinkCB->VcRefCount++;

                NdisReleaseSpinLock(&LinkCB->Lock);

                //
                // Submit this to the WAN Miniport
                //
                WanRequest.NdisRequest.RequestType = 
                    NdisRequestQueryInformation;

                WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid = 
                    OID_WAN_CO_GET_LINK_INFO;

                WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer = 
                    &WanMiniportLinkInfo.Co;

                WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength = 
                    sizeof(NDIS_WAN_CO_GET_LINK_INFO);

                WanRequest.AfHandle = NULL;
                WanRequest.VcHandle = LinkCB->NdisLinkHandle;

                Status = NdisWanSubmitNdisRequest(OpenCB, &WanRequest);

                NdisAcquireSpinLock(&LinkCB->Lock);

                DerefVc(LinkCB);

                NdisReleaseSpinLock(&LinkCB->Lock);

                if (Status == NDIS_STATUS_SUCCESS) {

                    LinkInfo->MaxSendFrameSize = 
                        WanMiniportLinkInfo.Co.MaxSendFrameSize;
                    LinkInfo->MaxRecvFrameSize = 
                        WanMiniportLinkInfo.Co.MaxRecvFrameSize;
                    LinkInfo->SendFramingBits = 
                        WanMiniportLinkInfo.Co.SendFramingBits;
                    LinkInfo->RecvFramingBits = 
                        WanMiniportLinkInfo.Co.RecvFramingBits;
                    LinkInfo->SendCompressionBits = 
                        WanMiniportLinkInfo.Co.SendCompressionBits;
                    LinkInfo->RecvCompressionBits = 
                        WanMiniportLinkInfo.Co.RecvCompressionBits;
                    LinkInfo->SendACCM = 
                        WanMiniportLinkInfo.Co.SendACCM;
                    LinkInfo->RecvACCM = 
                        WanMiniportLinkInfo.Co.RecvACCM;
                }

            } else {

                NdisReleaseSpinLock(&LinkCB->Lock);
            }
        }
    
        Status = NDIS_STATUS_SUCCESS;

        //
        // Fill Recv and Send MRRU
        //
        LinkInfo->MaxRSendFrameSize = glMaxMTU;
    
        LinkInfo->MaxRRecvFrameSize = glMRRU;
    
        NdisMoveMemory(&Out->LinkInfo,
                       LinkInfo,
                       sizeof(WAN_LINK_INFO));

        Out->hLinkHandle = LinkCB->hLinkHandle;

    } while ( 0 );

    //
    // Deref for ref applied by IsLinkValid
    //
    DEREF_LINKCB(LinkCB);

    return (Status);
}


NTSTATUS
SetCompressionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   SizeNeeded = sizeof(NDISWAN_SET_COMPRESSION_INFO);
    PNDISWAN_SET_COMPRESSION_INFO   In = (PNDISWAN_SET_COMPRESSION_INFO)pInputBuffer;
    PLINKCB         LinkCB = NULL;
    PBUNDLECB       BundleCB = NULL;
    POPENCB         OpenCB;
    WAN_REQUEST WanRequest;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetCompressionInfo:"));

    *pulBytesWritten = 0;

    do {
        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetCompressionInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!AreLinkAndBundleValid(In->hLinkHandle, 
                                   TRUE,
                                   &LinkCB, 
                                   &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetCompressionInfo: Invalid LinkHandle: 0x%x",
                          In->hLinkHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        OpenCB = LinkCB->OpenCB;
    
#ifdef DEBUG_CCP
{
    PCOMPRESS_INFO  CompInfo;
    PUCHAR          Key;

    CompInfo = &In->SendCapabilities;
    DbgPrint("==>NdisWan: Set Send CompressInfo\n");

    DbgPrint("MSCompType:      %x\n", CompInfo->MSCompType);
    DbgPrint("AuthType:        %x\n", CompInfo->AuthType);
    DbgPrint("Flags:           %x\n", CompInfo->Flags);

    CompInfo = &In->RecvCapabilities;
    DbgPrint("==>NdisWan: Set Recv CompressInfo\n");

    DbgPrint("MSCompType:      %x\n", CompInfo->MSCompType);
    DbgPrint("AuthType:        %x\n", CompInfo->AuthType);
    DbgPrint("Flags:           %x\n", CompInfo->Flags);
}
#endif
        AcquireBundleLock(BundleCB);
    
        BundleCB->SendCompInfo.Flags =
            In->SendCapabilities.Flags;

        BundleCB->RecvCompInfo.Flags =
            In->RecvCapabilities.Flags;

        if (In->SendCapabilities.Flags & CCP_SET_KEYS) {

            BundleCB->SendCompInfo.AuthType =
                In->SendCapabilities.AuthType;

            NdisMoveMemory(&BundleCB->SendCompInfo.LMSessionKey,
                           &In->SendCapabilities.LMSessionKey,
                           sizeof(BundleCB->SendCompInfo.LMSessionKey));

            NdisMoveMemory(&BundleCB->SendCompInfo.UserSessionKey,
                           &In->SendCapabilities.UserSessionKey,
                           sizeof(BundleCB->SendCompInfo.UserSessionKey));

            NdisMoveMemory(&BundleCB->SendCompInfo.Challenge,
                           &In->SendCapabilities.Challenge,
                           sizeof(BundleCB->SendCompInfo.Challenge));

            NdisMoveMemory(&BundleCB->SendCompInfo.NTResponse,
                           &In->SendCapabilities.NTResponse,
                           sizeof(BundleCB->SendCompInfo.NTResponse));
#ifdef EAP_ON
            NdisMoveMemory(&BundleCB->SendCompInfo.EapKey,
                           &In->SendCapabilities.EapKey,
                           sizeof(BundleCB->SendCompInfo.EapKey));
#endif

#ifdef DEBUG_CCP
{
    PCOMPRESS_INFO  CompInfo;
    PUCHAR          Key;

    CompInfo = &BundleCB->SendCompInfo;

    Key = CompInfo->LMSessionKey;
    DbgPrint("Send KeyInfo\n");
    DbgPrint("LMSession Key:   %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->UserSessionKey;
    DbgPrint("UserSession Key: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    Key = CompInfo->Challenge;
    DbgPrint("Challenge:       %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->NTResponse;
    DbgPrint("NTResponse:      %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    DbgPrint("                 %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[16],Key[17],Key[18],Key[19],
        Key[20],Key[21],Key[22],Key[23]);

#ifdef EAP_ON
{
    ULONG   KeyLength, i;

    Key = CompInfo->EapKey;
    KeyLength = sizeof(CompInfo->EapKey);
    i = 0;

    DbgPrint("Eap Key:\n");
    while (i <= KeyLength-16) {
        DbgPrint("%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
            Key[i],Key[i+1],Key[i+2],Key[i+3],
            Key[i+4],Key[i+5],Key[i+6],Key[i+7],
            Key[i+8],Key[i+9],Key[i+10],Key[i+11],
            Key[i+12],Key[i+13],Key[i+14],Key[i+15]);
        i += 16;
    }
}
#endif

}
#endif
        }

        if (In->RecvCapabilities.Flags & CCP_SET_KEYS) {

            BundleCB->RecvCompInfo.AuthType =
                In->RecvCapabilities.AuthType;

            NdisMoveMemory(&BundleCB->RecvCompInfo.LMSessionKey,
                           &In->RecvCapabilities.LMSessionKey,
                           sizeof(BundleCB->RecvCompInfo.LMSessionKey));

            NdisMoveMemory(&BundleCB->RecvCompInfo.UserSessionKey,
                           &In->RecvCapabilities.UserSessionKey,
                           sizeof(BundleCB->RecvCompInfo.UserSessionKey));

            NdisMoveMemory(&BundleCB->RecvCompInfo.Challenge,
                           &In->RecvCapabilities.Challenge,
                           sizeof(BundleCB->RecvCompInfo.Challenge));

            NdisMoveMemory(&BundleCB->RecvCompInfo.NTResponse,
                           &In->RecvCapabilities.NTResponse,
                           sizeof(BundleCB->RecvCompInfo.NTResponse));
#ifdef EAP_ON
            NdisMoveMemory(&BundleCB->RecvCompInfo.EapKey,
                           &In->RecvCapabilities.EapKey,
                           sizeof(BundleCB->RecvCompInfo.EapKey));
#endif


#ifdef DEBUG_CCP
{
    PCOMPRESS_INFO  CompInfo;
    PUCHAR          Key;

    CompInfo = &BundleCB->RecvCompInfo;

    Key = CompInfo->LMSessionKey;
    DbgPrint("Recv KeyInfo\n");
    DbgPrint("LMSession Key:   %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->UserSessionKey;
    DbgPrint("UserSession Key: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    Key = CompInfo->Challenge;
    DbgPrint("Challenge:       %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->NTResponse;
    DbgPrint("NTResponse:      %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    DbgPrint("                 %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[16],Key[17],Key[18],Key[19],
        Key[20],Key[21],Key[22],Key[23]);

#ifdef EAP_ON
{
    ULONG   KeyLength, i;

    Key = CompInfo->EapKey;
    KeyLength = sizeof(CompInfo->EapKey);
    i = 0;

    DbgPrint("Eap Key:\n");
    while (i <= KeyLength-16) {
        DbgPrint("%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
            Key[i],Key[i+1],Key[i+2],Key[i+3],
            Key[i+4],Key[i+5],Key[i+6],Key[i+7],
            Key[i+8],Key[i+9],Key[i+10],Key[i+11],
            Key[i+12],Key[i+13],Key[i+14],Key[i+15]);
        i += 16;
    }
}
#endif
}
#endif
        }

        do {

            if (In->SendCapabilities.Flags & CCP_SET_COMPTYPE) {

                BundleCB->SendCompInfo.MSCompType =
                    In->SendCapabilities.MSCompType;

                do {

                    if (!(BundleCB->Flags & SEND_CCP_ALLOCATED)) {

                        BundleCB->SCoherencyCounter = 0;

                        BundleCB->Flags |= SEND_CCP_ALLOCATED;

                        Status = WanAllocateCCP(BundleCB,
                                                &BundleCB->SendCompInfo,
                                                TRUE);

                        if (Status != STATUS_SUCCESS) {
                            break;
                        }
                    }

                    if (!(BundleCB->Flags & SEND_ECP_ALLOCATED)) {

                        BundleCB->SCoherencyCounter = 0;
                        BundleCB->Flags |= SEND_ECP_ALLOCATED;

                        Status = WanAllocateECP(BundleCB,
                                                &BundleCB->SendCompInfo,
                                                &BundleCB->SendCryptoInfo,
                                                TRUE);

                        if (Status != STATUS_SUCCESS) {
                            break;
                        }
                    }

                } while (FALSE);

                if (Status != STATUS_SUCCESS) {
                    break;
                }
            }

            if (In->RecvCapabilities.Flags & CCP_SET_COMPTYPE) {

                BundleCB->RecvCompInfo.MSCompType =
                    In->RecvCapabilities.MSCompType;

                do {

                    if (!(BundleCB->Flags & RECV_CCP_ALLOCATED)) {
                        BundleCB->RCoherencyCounter = 0;
                        BundleCB->LastRC4Reset = 0;
                        BundleCB->CCPIdentifier = 0;

                        BundleCB->Flags |= RECV_CCP_ALLOCATED;

                        Status = WanAllocateCCP(BundleCB,
                                                &BundleCB->RecvCompInfo,
                                                FALSE);

                        if (Status != STATUS_SUCCESS) {
                            break;
                        }
                    }

                    if (!(BundleCB->Flags & RECV_ECP_ALLOCATED)) {
                        BundleCB->RCoherencyCounter = 0;
                        BundleCB->LastRC4Reset = 0;
                        BundleCB->CCPIdentifier = 0;

                        BundleCB->Flags |= RECV_ECP_ALLOCATED;

                        Status = WanAllocateECP(BundleCB,
                                                &BundleCB->RecvCompInfo,
                                                &BundleCB->RecvCryptoInfo,
                                                FALSE);

                        if (Status != STATUS_SUCCESS) {
                            break;
                        }
                    }

                } while (FALSE);

                if (Status != STATUS_SUCCESS) {
                    break;
                }
            }

        } while (FALSE);

        if (Status != STATUS_SUCCESS) {
            if (BundleCB->Flags & SEND_CCP_ALLOCATED) {
                BundleCB->Flags &= ~SEND_CCP_ALLOCATED;
                WanDeallocateCCP(BundleCB,
                                 &BundleCB->SendCompInfo,
                                 TRUE);
            }

            if (BundleCB->Flags & RECV_CCP_ALLOCATED) {
                BundleCB->Flags &= ~RECV_CCP_ALLOCATED;
                WanDeallocateCCP(BundleCB,
                                 &BundleCB->RecvCompInfo,
                                 FALSE);
            }

            if (BundleCB->Flags & SEND_ECP_ALLOCATED) {
                BundleCB->Flags &= ~SEND_ECP_ALLOCATED;
                WanDeallocateECP(BundleCB,
                                 &BundleCB->SendCompInfo,
                                 &BundleCB->SendCryptoInfo);
            }

            if (BundleCB->Flags & RECV_ECP_ALLOCATED) {
                BundleCB->Flags &= ~RECV_ECP_ALLOCATED;
                WanDeallocateECP(BundleCB,
                                 &BundleCB->RecvCompInfo,
                                 &BundleCB->RecvCryptoInfo);
            }
        }

        if (In->SendCapabilities.Flags & CCP_PAUSE_DATA) {

            BundleCB->Flags |= PAUSE_DATA;

        } else {

            BundleCB->Flags &= ~PAUSE_DATA;

            if (!(BundleCB->Flags & DEFERRED_WORK_QUEUED)) {

                //
                // Need to kick off sends again!
                //
                REF_BUNDLECB(BundleCB);
                BundleCB->Flags |= DEFERRED_WORK_QUEUED;
                InsertTailGlobalListEx(DeferredWorkList,
                                       &BundleCB->DeferredLinkage,
                                       15,
                                       0);

            }
        }

        SetBundleFlags(BundleCB);
    
    } while ( 0 );

    //
    // Derefs for the refs applied in AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (Status);
}


NTSTATUS
GetCompressionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_COMPRESSION_INFO);
    PNDISWAN_GET_COMPRESSION_INFO In = (PNDISWAN_GET_COMPRESSION_INFO)pInputBuffer;
    PNDISWAN_GET_COMPRESSION_INFO Out = (PNDISWAN_GET_COMPRESSION_INFO)pOutputBuffer;
    PLINKCB         LinkCB = NULL;
    PBUNDLECB       BundleCB = NULL;
    POPENCB         OpenCB;
    ULONG   i;
    WAN_REQUEST WanRequest;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetCompressionInfo:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulInputBufferLength < SizeNeeded ||
            ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetCompressionInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!AreLinkAndBundleValid(In->hLinkHandle, 
                                   TRUE,
                                   &LinkCB, 
                                   &BundleCB)) {

            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
    
        OpenCB = LinkCB->OpenCB;

        Out->SendCapabilities.CompType = COMPTYPE_NONE;
        Out->SendCapabilities.CompLength = 0;
        Out->RecvCapabilities.CompType = COMPTYPE_NONE;
        Out->RecvCapabilities.CompLength = 0;

        AcquireBundleLock(BundleCB);
    
        //
        // Fill in the ndiswan specific stuff
        //
        NdisMoveMemory(Out->SendCapabilities.LMSessionKey,
                       BundleCB->SendCompInfo.LMSessionKey,
                       sizeof(Out->SendCapabilities.LMSessionKey));
    
        NdisMoveMemory(Out->SendCapabilities.UserSessionKey,
                       BundleCB->SendCompInfo.UserSessionKey,
                       sizeof(Out->SendCapabilities.UserSessionKey));
    
        NdisMoveMemory(Out->SendCapabilities.Challenge,
                       BundleCB->SendCompInfo.Challenge,
                       sizeof(Out->SendCapabilities.Challenge));
    
        NdisMoveMemory(Out->SendCapabilities.NTResponse,
                       BundleCB->SendCompInfo.NTResponse,
                       sizeof(Out->SendCapabilities.NTResponse));
#ifdef EAP_ON
        NdisMoveMemory(Out->SendCapabilities.EapKey,
                       BundleCB->SendCompInfo.EapKey,
                       sizeof(Out->SendCapabilities.EapKey));

        Out->SendCapabilities.EapKeyLength =
            BundleCB->SendCompInfo.EapKeyLength;
#endif

        NdisMoveMemory(Out->RecvCapabilities.LMSessionKey,
                       BundleCB->RecvCompInfo.LMSessionKey,
                       sizeof(Out->RecvCapabilities.LMSessionKey));
    
        NdisMoveMemory(Out->RecvCapabilities.UserSessionKey,
                       BundleCB->RecvCompInfo.UserSessionKey,
                       sizeof(Out->RecvCapabilities.UserSessionKey));
    
        NdisMoveMemory(Out->RecvCapabilities.Challenge,
                       BundleCB->RecvCompInfo.Challenge,
                       sizeof(Out->RecvCapabilities.Challenge));
    
        NdisMoveMemory(Out->RecvCapabilities.NTResponse,
                       BundleCB->RecvCompInfo.NTResponse,
                       sizeof(Out->RecvCapabilities.NTResponse));
#ifdef EAP_ON
        NdisMoveMemory(Out->RecvCapabilities.EapKey,
                       BundleCB->RecvCompInfo.EapKey,
                       sizeof(Out->RecvCapabilities.EapKey));

        Out->RecvCapabilities.EapKeyLength =
            BundleCB->RecvCompInfo.EapKeyLength;
#endif
        //
        // We will set encryption capabilities based on session key
        // availability and auth type being used.
        //

        // Set send side capabilities
        //
        Out->SendCapabilities.MSCompType = NDISWAN_COMPRESSION;
    
        if (BundleCB->SendCompInfo.AuthType == AUTH_USE_MSCHAPV1) {

            for (i = 0; i < sizeof(Out->SendCapabilities.LMSessionKey); i++) {
                if (Out->SendCapabilities.LMSessionKey[i] != 0) {

                    Out->SendCapabilities.MSCompType |= 
                        (NDISWAN_ENCRYPTION | 
                         NDISWAN_40_ENCRYPTION | 
                         NDISWAN_56_ENCRYPTION);
                    break;
                }
            }

#ifdef ENCRYPT_128BIT
            for (i = 0; i < sizeof(Out->SendCapabilities.UserSessionKey); i++) {
                if (Out->SendCapabilities.UserSessionKey[i] != 0) {

                    Out->SendCapabilities.MSCompType |= 
                        (NDISWAN_128_ENCRYPTION);
                    break;
                }
            }
#endif
        } else if (BundleCB->SendCompInfo.AuthType == AUTH_USE_MSCHAPV2) {

            for (i = 0; i < sizeof(Out->SendCapabilities.UserSessionKey); i++) {
                if (Out->SendCapabilities.UserSessionKey[i] != 0) {

                    Out->SendCapabilities.MSCompType |= 
                        (NDISWAN_40_ENCRYPTION |
                         NDISWAN_56_ENCRYPTION);

#ifdef ENCRYPT_128BIT
                    Out->SendCapabilities.MSCompType |= 
                        (NDISWAN_128_ENCRYPTION);
#endif
                    break;
                }

            }
#ifdef EAP_ON
        } else if (BundleCB->SendCompInfo.AuthType == AUTH_USE_EAP) {

            for (i = 0; i < sizeof(Out->SendCapabilities.EapKey); i++) {

                if (Out->SendCapabilities.EapKey[i] != 0) {

                    Out->SendCapabilities.MSCompType |= 
                        (NDISWAN_40_ENCRYPTION |
                         NDISWAN_56_ENCRYPTION);

#ifdef ENCRYPT_128BIT
                    Out->SendCapabilities.MSCompType |= 
                        (NDISWAN_128_ENCRYPTION);
#endif
                    break;
                }
            }
#endif
        }
    
        // Set send side capabilities
        //
        Out->RecvCapabilities.MSCompType = NDISWAN_COMPRESSION;

        if (BundleCB->RecvCompInfo.AuthType == AUTH_USE_MSCHAPV1) {

            for (i = 0; i < sizeof(Out->RecvCapabilities.LMSessionKey); i++) {
                if (Out->RecvCapabilities.LMSessionKey[i] != 0) {
                    Out->RecvCapabilities.MSCompType |= 
                        (NDISWAN_ENCRYPTION | 
                         NDISWAN_40_ENCRYPTION |
                         NDISWAN_56_ENCRYPTION);
                    break;
                }
            }


#ifdef ENCRYPT_128BIT
            for (i = 0; i < sizeof(Out->RecvCapabilities.UserSessionKey); i++) {
                if (Out->RecvCapabilities.UserSessionKey[i] != 0) {
    
                    Out->RecvCapabilities.MSCompType |= 
                        (NDISWAN_128_ENCRYPTION);
                    break;
                }
            }
#endif

        } else if (BundleCB->RecvCompInfo.AuthType == AUTH_USE_MSCHAPV2) {

            for (i = 0; i < sizeof(Out->RecvCapabilities.UserSessionKey); i++) {
                if (Out->RecvCapabilities.UserSessionKey[i] != 0) {

                    Out->RecvCapabilities.MSCompType |=
                        (NDISWAN_40_ENCRYPTION |
                         NDISWAN_56_ENCRYPTION);

#ifdef ENCRYPT_128BIT
                    Out->RecvCapabilities.MSCompType |= 
                        (NDISWAN_128_ENCRYPTION);
#endif
                    break;
                }
            }
#ifdef EAP_ON
        } else if (BundleCB->RecvCompInfo.AuthType == AUTH_USE_EAP) {

            for (i = 0; i < sizeof(Out->RecvCapabilities.EapKey); i++) {
                if (Out->RecvCapabilities.EapKey[i] != 0) {

                    Out->RecvCapabilities.MSCompType |=
                        (NDISWAN_40_ENCRYPTION |
                         NDISWAN_56_ENCRYPTION);

#ifdef ENCRYPT_128BIT
                    Out->RecvCapabilities.MSCompType |= 
                        (NDISWAN_128_ENCRYPTION);
#endif
                    break;
                }
            }
#endif
        }

    
        if (gbHistoryless &&
            (OpenCB->MediumSubType == NdisWanMediumPPTP ||
            OpenCB->MediumSubType == NdisWanMediumL2TP)) {

            Out->SendCapabilities.MSCompType |= NDISWAN_HISTORY_LESS;
            Out->RecvCapabilities.MSCompType |= NDISWAN_HISTORY_LESS;
        }
    
    
#ifdef DEBUG_CCP
{
    PCOMPRESS_INFO  CompInfo;
    PUCHAR          Key;

    CompInfo = &Out->SendCapabilities;
    DbgPrint("NdisWan: Get Send CompressInfo\n");

    DbgPrint("MSCompType:      %x\n", CompInfo->MSCompType);
    DbgPrint("AuthType:        %x\n", CompInfo->AuthType);
    DbgPrint("Flags:           %x\n", CompInfo->Flags);

    Key = CompInfo->LMSessionKey;
    DbgPrint("LMSession Key:   %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->UserSessionKey;
    DbgPrint("UserSession Key: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    Key = CompInfo->Challenge;
    DbgPrint("Challenge:       %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->NTResponse;
    DbgPrint("NTResponse:      %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);
    DbgPrint("                 %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[16],Key[17],Key[18],Key[19],
        Key[20],Key[21],Key[22],Key[23]);
}
#endif

#ifdef DEBUG_CCP
{
    PCOMPRESS_INFO  CompInfo;
    PUCHAR          Key;

    CompInfo = &Out->RecvCapabilities;
    DbgPrint("NdisWan: Get Receive CompressInfo\n");

    DbgPrint("MSCompType:      %x\n", CompInfo->MSCompType);
    DbgPrint("AuthType:        %x\n", CompInfo->AuthType);
    DbgPrint("Flags:           %x\n", CompInfo->Flags);

    Key = CompInfo->LMSessionKey;
    DbgPrint("LMSession Key:   %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->UserSessionKey;
    DbgPrint("UserSession Key: %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);

    Key = CompInfo->Challenge;
    DbgPrint("Challenge:       %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7]);

    Key = CompInfo->NTResponse;
    DbgPrint("NTResponse:      %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[0],Key[1],Key[2],Key[3],
        Key[4],Key[5],Key[6],Key[7],
        Key[8],Key[9],Key[10],Key[11],
        Key[12],Key[13],Key[14],Key[15]);
    DbgPrint("                 %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x\n",
        Key[16],Key[17],Key[18],Key[19],
        Key[20],Key[21],Key[22],Key[23]);
}
#endif

    } while ( 0 );
        
    //
    // Derefs for the refs applied in AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (Status);
}


NTSTATUS
SetVJInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    PLINKCB     LinkCB = NULL;
    PBUNDLECB   BundleCB = NULL;
    ULONG       SizeNeeded = sizeof(NDISWAN_SET_VJ_INFO);
    PNDISWAN_SET_VJ_INFO    In = (PNDISWAN_SET_VJ_INFO)pInputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetVJInfo:"));

    *pulBytesWritten = 0;

    do {

        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetVJInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!AreLinkAndBundleValid(In->hLinkHandle, 
                                   TRUE,
                                   &LinkCB, 
                                   &BundleCB)) {

            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        AcquireBundleLock(BundleCB);
    
        NdisMoveMemory(&BundleCB->RecvVJInfo,
                       &In->RecvCapabilities,
                       sizeof(VJ_INFO));
    
        if (In->RecvCapabilities.IPCompressionProtocol == 0x2D) {
    
            if (In->RecvCapabilities.MaxSlotID < MAX_VJ_STATES) {
    
                Status = sl_compress_init(&BundleCB->VJCompress,
                         (UCHAR)(In->RecvCapabilities.MaxSlotID + 1));
                
                if (Status != NDIS_STATUS_SUCCESS) {
                    NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("Error allocating VJ Info!"));
                }
            }
        }
    
        NdisMoveMemory(&BundleCB->SendVJInfo,
                       &In->SendCapabilities,
                       sizeof(VJ_INFO));
    
        if (In->SendCapabilities.IPCompressionProtocol == 0x2D) {
    
            if (In->SendCapabilities.MaxSlotID < MAX_VJ_STATES) {
    
                Status = sl_compress_init(&BundleCB->VJCompress,
                         (UCHAR)(In->SendCapabilities.MaxSlotID + 1));
                
                if (Status != NDIS_STATUS_SUCCESS) {
                    NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("Error allocating VJ Info!"));
                }
            }
            
        }

        SetBundleFlags(BundleCB);
    
    } while ( 0 );

    //
    // Derefs for the refs applied in AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (Status);
}


NTSTATUS
GetVJInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       SizeNeeded = sizeof(NDISWAN_GET_VJ_INFO);
    PLINKCB     LinkCB = NULL;
    POPENCB     OpenCB = NULL;
    NTSTATUS    Status = STATUS_SUCCESS;
    PNDISWAN_GET_VJ_INFO    In = (PNDISWAN_GET_VJ_INFO)pInputBuffer;
    PNDISWAN_GET_VJ_INFO    Out = (PNDISWAN_GET_VJ_INFO)pOutputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetVJInfo:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetVJInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!IsLinkValid(In->hLinkHandle, 
                         TRUE,
                         &LinkCB)) {

            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

        OpenCB = LinkCB->OpenCB;
    
        if (OpenCB->MediumSubType == NdisWanMediumPPTP ||
            OpenCB->MediumSubType == NdisWanMediumL2TP) {
            Out->SendCapabilities.IPCompressionProtocol =
            Out->RecvCapabilities.IPCompressionProtocol = 0;
        } else {
            Out->SendCapabilities.IPCompressionProtocol =
            Out->RecvCapabilities.IPCompressionProtocol = 0x2D;
        }
    
        Out->SendCapabilities.MaxSlotID =
        Out->RecvCapabilities.MaxSlotID = MAX_VJ_STATES - 1;
    
        Out->SendCapabilities.CompSlotID =
        Out->RecvCapabilities.CompSlotID = 1;

    } while ( 0 );

    //
    // Deref for ref applied by IsLinkValid
    //
    DEREF_LINKCB(LinkCB);

    return (Status);
}

NTSTATUS
GetBandwidthUtilization(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       SizeNeeded = sizeof(NDISWAN_GET_BANDWIDTH_UTILIZATION);
    PBUNDLECB   BundleCB = NULL;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    PNDISWAN_GET_BANDWIDTH_UTILIZATION In =
        (PNDISWAN_GET_BANDWIDTH_UTILIZATION)pInputBuffer;

    PNDISWAN_GET_BANDWIDTH_UTILIZATION Out =
        (PNDISWAN_GET_BANDWIDTH_UTILIZATION)pOutputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetBandwidthUtilization: Enter"));

    *pulBytesWritten = 0;
    if (ulInputBufferLength < sizeof(In->hBundleHandle) ||
        ulOutputBufferLength < SizeNeeded) {

        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetBandwidthUtilization: Buffer to small: Size: %d, SizeNeeded %d",
                      ulOutputBufferLength, SizeNeeded));

        *pulBytesWritten = SizeNeeded;
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    if (!IsBundleValid(In->hBundleHandle, 
                       FALSE,
                       &BundleCB)) {

        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetBandwidthUtilization: Invalid BundleHandle: 0x%x",
                      In->hBundleHandle));
        return NDISWAN_ERROR_INVALID_HANDLE;
    }
    
    do {
        ULONGLONG   MaxByteCount, temp;

        AcquireBundleLock(BundleCB);

        if(BundleCB->SUpperBonDInfo == NULL ||
          BundleCB->RUpperBonDInfo == NULL)
        {
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
            
        MaxByteCount = BundleCB->SUpperBonDInfo->ulBytesInSamplePeriod;
        temp = 0;
        if (MaxByteCount != 0) {
            temp = BundleCB->SUpperBonDInfo->SampleTable.ulCurrentSampleByteCount;
            temp *= 100;
            temp /= MaxByteCount;
        }
        Out->ulUpperXmitUtil = (ULONG)temp;

        MaxByteCount = BundleCB->SLowerBonDInfo->ulBytesInSamplePeriod;
        temp = 0;
        if (MaxByteCount != 0) {
            temp = BundleCB->SLowerBonDInfo->SampleTable.ulCurrentSampleByteCount;
            temp *= 100;
            temp /= MaxByteCount;
        }
        Out->ulLowerXmitUtil = (ULONG)temp;

        MaxByteCount = BundleCB->RUpperBonDInfo->ulBytesInSamplePeriod;
        temp = 0;
        if (MaxByteCount != 0) {
            temp = BundleCB->RUpperBonDInfo->SampleTable.ulCurrentSampleByteCount;
            temp *= 100;
            temp /= MaxByteCount;
        }
        Out->ulUpperRecvUtil = (ULONG)temp;

        MaxByteCount = BundleCB->RLowerBonDInfo->ulBytesInSamplePeriod;
        temp = 0;
        if (MaxByteCount != 0) {
            temp = BundleCB->RLowerBonDInfo->SampleTable.ulCurrentSampleByteCount;
            temp *= 100;
            temp /= MaxByteCount;
        }
        Out->ulLowerRecvUtil = (ULONG)temp;

        *pulBytesWritten = SizeNeeded;

    } while (FALSE);

    //
    // Deref for ref applied by IsBundleValid.  This releases
    // the BundleCB->Lock.
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);

    return (Status);
}

NTSTATUS
GetWanInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_WAN_INFO);
    PNDISWAN_GET_WAN_INFO In = (PNDISWAN_GET_WAN_INFO)pInputBuffer;
    PNDISWAN_GET_WAN_INFO Out = (PNDISWAN_GET_WAN_INFO)pOutputBuffer;
    POPENCB OpenCB;
    PLINKCB LinkCB = NULL;
    NTSTATUS    Status = STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetWanInfo:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetWanInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
    
        if (!IsLinkValid(In->hLinkHandle, 
                         FALSE,
                         &LinkCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetWanInfo: Invalid LinkHandle: 0x%x",
                          In->hLinkHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
    
        OpenCB = LinkCB->OpenCB;
    
        Out->WanInfo.MaxFrameSize = OpenCB->WanInfo.MaxFrameSize;
        Out->WanInfo.MaxTransmit = OpenCB->WanInfo.MaxTransmit;
        Out->WanInfo.FramingBits = OpenCB->WanInfo.FramingBits;
        Out->WanInfo.DesiredACCM = OpenCB->WanInfo.DesiredACCM;
        Out->WanInfo.MaxReconstructedFrameSize = glMRRU;
        Out->WanInfo.LinkSpeed = LinkCB->SFlowSpec.PeakBandwidth*8;

    } while ( 0 );

    //
    // Deref for ref applied by IsLinkValid
    //
    DEREF_LINKCB(LinkCB);

    return (Status);
}

NTSTATUS
GetIdleTime(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
)
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       SizeNeeded = sizeof(NDISWAN_GET_IDLE_TIME);
    PNDISWAN_GET_IDLE_TIME  In  = (PNDISWAN_GET_IDLE_TIME)pInputBuffer;
    PNDISWAN_GET_IDLE_TIME  Out = (PNDISWAN_GET_IDLE_TIME)pOutputBuffer;
    PBUNDLECB   BundleCB = NULL;
    PPROTOCOLCB ProtocolCB = NULL;
    WAN_TIME    CurrentTime, Diff, OneSecond;
    WAN_TIME    LastNonIdleData;
    NTSTATUS    Status = STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetIdleTime:"));

    *pulBytesWritten = SizeNeeded;

    do {
        if (ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetIdleTime: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!IsBundleValid(In->hBundleHandle, 
                           FALSE,
                           &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetIdleTime: Invalid BundleHandle: 0x%x",
                          In->hBundleHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
    
        AcquireBundleLock(BundleCB);

        if (BundleCB->Flags & DISABLE_IDLE_DETECT) {
            
            Out->ulSeconds = 0;
            break;
        }
    
        //
        // If this is for the bundle
        //
        if (In->usProtocolType == BUNDLE_IDLE_TIME) {
            LastNonIdleData = BundleCB->LastNonIdleData;
        } else {
    
            //
            // Find the protocol type
            //
            for (ProtocolCB = (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;
                (PVOID)ProtocolCB != (PVOID)&BundleCB->ProtocolCBList;
                ProtocolCB = (PPROTOCOLCB)ProtocolCB->Linkage.Flink) {
    
                if (ProtocolCB->ProtocolType == In->usProtocolType) {
                    break;
                }
            }
    
            if ((PVOID)ProtocolCB == (PVOID)&BundleCB->ProtocolCBList) {
                NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetIdleTime: Invalid ProtocolType: 0x%x",
                              In->usProtocolType));
                Status = NDISWAN_ERROR_NO_ROUTE;
                break;
            }
    
            LastNonIdleData = ProtocolCB->LastNonIdleData;
        }
    
        NdisWanGetSystemTime(&CurrentTime);
        NdisWanCalcTimeDiff(&Diff, &CurrentTime, &LastNonIdleData);
        NdisWanInitWanTime(&OneSecond, ONE_SECOND);
        NdisWanDivideWanTime(&CurrentTime, &Diff, &OneSecond);
    
        Out->ulSeconds = CurrentTime.LowPart;
    
    } while ( 0 );

    //
    // Deref for ref applied by IsBundleValid.  This releases the
    // BundleCB->Lock.
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);

    return (Status);
}

NTSTATUS
DeactivateRoute(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    DeactivateRoute

Routine Description:

    This function unroutes the protocol given by usprotocoltype
    from the bundle given by hbundlehandle.

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_UNROUTE

    ulInputBufferLength - Length of input buffer should be sizeof(NDISWAN_UNROUTE)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_UNROUTE

    ulOutputBufferLength - Length of output buffer should be sizeof(NDISWAN_UNROUTE)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here

Return Values:

    NDISWAN_ERROR_ALREADY_ROUTED
    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INSUFFICIENT_RESOURCES
    STATUS_INFO_LENGTH_MISMATCH

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNDISWAN_UNROUTE In = (PNDISWAN_UNROUTE)pInputBuffer;
    PNDISWAN_UNROUTE    Out = (PNDISWAN_UNROUTE)pOutputBuffer;
    ULONG   SizeNeeded = sizeof(NDISWAN_UNROUTE);
    ULONG   AllocationSize, i;
    PBUNDLECB   BundleCB = NULL;
    BOOLEAN RouteExists = FALSE;
    BOOLEAN FreeBundle = FALSE;
    PPROTOCOLCB ProtocolCB;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("DeactivateRoute:"));

    *pulBytesWritten = 0;

    do {

        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("DeactivateRoute: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
    
        if (!IsBundleValid(In->hBundleHandle, FALSE, &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("DeactivateRoute: Invalid BundleHandle: 0x%x, ProtocolType: 0x%x",
                          In->hBundleHandle, In->usProtocolType));
    
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
    
        //
        // This is a call to unroute
        //
        AcquireBundleLock(BundleCB);

        //
        // Find the protocolcb for this route
        //
        //
        for (ProtocolCB = (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;
            (PVOID)ProtocolCB != (PVOID)&BundleCB->ProtocolCBList;
            ProtocolCB = (PPROTOCOLCB)ProtocolCB->Linkage.Flink) {
    
            //
            // If we already have a route to this protocol type
            // flag it as already existing
            //
            if (ProtocolCB->ProtocolType == In->usProtocolType) {
                RouteExists = TRUE;
                break;
            }
            
        }

        if (!RouteExists) {
            //
            // A route already exists for this protocoltype
            //
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("DeactivateRoute: Route does not exist: ProtocolType: 0x%2.2x",
                          In->usProtocolType));
            
            Status = NDISWAN_ERROR_NOT_ROUTED;
            break;
        }
    
    
        //
        // If the protocol is already unrouting because
        // of a halt on the protocols miniportcb we
        // will just get the out!
        //
        if (ProtocolCB->State == PROTOCOL_UNROUTING) {
            break;
        }

        ProtocolCB->State = PROTOCOL_UNROUTING;
        BundleCB->SendMask &= ~ProtocolCB->SendMaskBit;

        //
        // Flush the protocol packet queues.  This could cause us
        // to complete frames to ndis out of order.  Ndis should
        // handle this.
        //
        FlushProtocolPacketQueue(ProtocolCB);

        //
        // If we have any outstanding Vc's we need to dispatch
        // incoming close calls to them
        //
        while (!IsListEmpty(&ProtocolCB->VcList)) {
            PLIST_ENTRY Entry;
            PCM_VCCB    CmVcCB;

            Entry = RemoveHeadList(&ProtocolCB->VcList);

            CmVcCB = (PCM_VCCB)CONTAINING_RECORD(Entry, CM_VCCB, Linkage);

            if (CmVcCB->State == CMVC_ACTIVE) {

                InterlockedExchange((PLONG)&CmVcCB->State, CMVC_CLOSE_DISPATCHED);

                ReleaseBundleLock(BundleCB);

                NdisCmDispatchIncomingCloseCall(NDIS_STATUS_SUCCESS,
                                                CmVcCB->NdisVcHandle,
                                                NULL,
                                                0);

                AcquireBundleLock(BundleCB);
            }
        }

        DEREF_PROTOCOLCB(ProtocolCB);

        ReleaseBundleLock(BundleCB);

        NdisWanWaitForSyncEvent(&ProtocolCB->UnrouteEvent);

        AcquireBundleLock(BundleCB);

        DoLineDownToProtocol(ProtocolCB);

        NdisWanFreeProtocolCB(ProtocolCB);

    } while ( 0 );

    //
    // Deref for ref applied by IsBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);

    return (Status);
}

NTSTATUS
GetDriverInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   SizeNeeded = sizeof(NDISWAN_DRIVER_INFO);
    PNDISWAN_DRIVER_INFO Out = (PNDISWAN_DRIVER_INFO)pOutputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetDriverInfo:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulOutputBufferLength < SizeNeeded) {
            
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        NdisZeroMemory(Out, ulOutputBufferLength);

#ifdef ENCRYPT_128BIT
        Out->DriverCaps = NDISWAN_128BIT_ENABLED;
#else
        Out->DriverCaps = 0;
#endif

    } while ( 0 );

    return (Status);

}

NTSTATUS
SetProtocolEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PIRP        Irp = (PIRP)pInputBuffer;
    NTSTATUS    Status = STATUS_PENDING;
    KIRQL       Irql;

    NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

    do {

        if ((ProtocolInfoTable->Flags & PROTOCOL_EVENT_OCCURRED) &&
            !(ProtocolInfoTable->Flags & PROTOCOL_EVENT_SIGNALLED)) {
            //
            // An event occurred but we did not signal so
            // signal now!
            //
            ProtocolInfoTable->Flags |= PROTOCOL_EVENT_SIGNALLED;
            *pulBytesWritten = 0;
            Status = STATUS_SUCCESS;
            break;

        }

        if (ProtocolInfoTable->EventIrp != NULL) {
            *pulBytesWritten = 0;
            Status = STATUS_SUCCESS;
            break;

        }

        ProtocolInfoTable->EventIrp = Irp;

        IoMarkIrpPending(Irp);

        IoSetCancelRoutine(Irp, NdisWanCancelRoutine);

        Status = STATUS_PENDING;

    } while (FALSE);

    NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

    return (Status);
}

NTSTATUS
GetProtocolEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PNDISWAN_GET_PROTOCOL_EVENT Out =
        (PNDISWAN_GET_PROTOCOL_EVENT)pOutputBuffer;
    PPROTOCOL_INFO  InfoArray;
    ULONG       ArraySize;
    ULONG       SizeNeeded = sizeof(NDISWAN_GET_PROTOCOL_EVENT);
    NTSTATUS    Status = STATUS_SUCCESS;
    UINT        i, j;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetProtocolEvent:"));

    *pulBytesWritten = 0;

    NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

    ArraySize = ProtocolInfoTable->ulArraySize;

    do {

        if (ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetProtocolEvent: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        *pulBytesWritten = sizeof(NDISWAN_GET_PROTOCOL_EVENT);

        NdisZeroMemory(Out, sizeof(NDISWAN_GET_PROTOCOL_EVENT));

        j = 0;

        for (i = 0, InfoArray = ProtocolInfoTable->ProtocolInfo;
            i < ArraySize;
            i++, InfoArray++) {

            if (InfoArray->Flags & PROTOCOL_EVENT_OCCURRED) {

                PPROTOCOL_EVENT oevent = &Out->ProtocolEvent[j];

                oevent->usProtocolType = InfoArray->ProtocolType;

                if (InfoArray->Flags & PROTOCOL_REBOUND) {
                    //
                    // This means we were unbound and then
                    // bound again without our miniport being
                    // halted.  We need to tell ras about two events,
                    // the unbind and the bind.
                    //
                    InfoArray->Flags &= ~(PROTOCOL_REBOUND |
                                          PROTOCOL_EVENT_OCCURRED);

                    oevent->ulFlags = PROTOCOL_REMOVED;

                    Out->ulNumProtocols++;

                    j++;

                    if (j < MAX_PROTOCOLS) {

                        oevent = &Out->ProtocolEvent[j];

                        oevent->usProtocolType = InfoArray->ProtocolType;

                        oevent->ulFlags = PROTOCOL_ADDED;

                        Out->ulNumProtocols++;

                        j++;
                    }


                } else {

                    oevent->ulFlags = (InfoArray->Flags & PROTOCOL_BOUND) ?
                        PROTOCOL_ADDED : PROTOCOL_REMOVED;

                    InfoArray->Flags &= ~PROTOCOL_EVENT_OCCURRED;

                    Out->ulNumProtocols++;

                    j++;
                }

                if (j == MAX_PROTOCOLS) {
                    break;
                }
            }
        }

        ProtocolInfoTable->Flags &=
            ~(PROTOCOL_EVENT_OCCURRED | PROTOCOL_EVENT_SIGNALLED);

    } while (FALSE);

    NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

    return (Status);
}


NTSTATUS
IoGetProtocolInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       SizeNeeded = sizeof(NDISWAN_GET_PROTOCOL_INFO);
    PNDISWAN_GET_PROTOCOL_INFO Out =
        (PNDISWAN_GET_PROTOCOL_INFO)pOutputBuffer;

    do {
        ULONG   i = 0;
        ULONG   j = 0;
        PMINIPORTCB MiniportCB;
        ULONG       ArraySize;
        PPROTOCOL_INFO  InfoArray;

        *pulBytesWritten = SizeNeeded;

        if (ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("IoGetProtocolInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

        ArraySize = ProtocolInfoTable->ulArraySize;

        for (i = 0, InfoArray = ProtocolInfoTable->ProtocolInfo;
            i < ArraySize;
            i++, InfoArray++) {

            if (InfoArray->Flags & PROTOCOL_BOUND) {
                Out->ProtocolInfo[j].ProtocolType = InfoArray->ProtocolType;
                Out->ProtocolInfo[j].PPPId = InfoArray->PPPId;
                Out->ProtocolInfo[j].MTU = InfoArray->MTU;
                Out->ProtocolInfo[j].TunnelMTU = InfoArray->TunnelMTU;
                Out->ProtocolInfo[j].PacketQueueDepth = InfoArray->PacketQueueDepth;

                j++;
            }
        }

        NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

        Out->ulNumProtocols = j;

    } while (FALSE);

    return (Status);
}

NTSTATUS
SetHibernateEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PIRP        Irp = (PIRP)pInputBuffer;
    NTSTATUS    Status = STATUS_PENDING;
    KIRQL       Irql;

    NdisAcquireSpinLock(&NdisWanCB.Lock);

    do {

        if (NdisWanCB.HibernateEventIrp != NULL) {
            *pulBytesWritten = 0;
            Status = STATUS_SUCCESS;
            break;

        }

        NdisWanCB.HibernateEventIrp = Irp;

        IoMarkIrpPending(Irp);

        IoSetCancelRoutine(Irp, NdisWanCancelRoutine);

        Status = STATUS_PENDING;

    } while (FALSE);

    NdisReleaseSpinLock(&NdisWanCB.Lock);

    return (Status);
}

NTSTATUS
UnmapConnectionId(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       SizeNeeded = sizeof(NDISWAN_UNMAP_CONNECTION_ID);
    NTSTATUS    Status = STATUS_SUCCESS;
    LOCK_STATE  LockState;
    PNDISWAN_UNMAP_CONNECTION_ID In = 
        (PNDISWAN_UNMAP_CONNECTION_ID)pInputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("UnmapConnectionId:"));

    *pulBytesWritten = 0;

    do {
        PLINKCB     LinkCB = NULL;

        if (ulInputBufferLength < SizeNeeded) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("UnmapConnectionId: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));

            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        //
        // Validate the link handle
        //
        if (IsLinkValid(In->hLinkHandle, FALSE, &LinkCB)) {

            NdisAcquireSpinLock(&LinkCB->Lock);


            //
            // Remove the ref applied to the link at mapconnectionid time.
            // We don't have to use the full deref code as the ref applied
            // in IsLinkValid will keep the link around.
            //
            LinkCB->RefCount--;

            //
            // Remove the ref applied by IsLinkValid
            //
            DEREF_LINKCB_LOCKED(LinkCB);
        } else {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, 
                          ("UnmapConnectionId: Invalid LinkHandle %x",
                          In->hLinkHandle));

            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }

    } while (FALSE);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("UnmapConnectionId:"));

    return (Status);
}

VOID
CancelIoReceivePackets(
    VOID
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
#ifdef NT
    PIRP    pIrp;
    PLIST_ENTRY Entry;

    NdisAcquireSpinLock(&IoRecvList.Lock);

    while (!IsListEmpty(&IoRecvList.IrpList)) {

        Entry = RemoveHeadList(&IoRecvList.IrpList);
        IoRecvList.ulIrpCount--;
        
        INSERT_RECV_EVENT('c');

        pIrp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

        if (!IoSetCancelRoutine(pIrp, NULL)) {
            //
            // Irp is being canceled so let 
            // cancel routine complete it
            //
            continue;
        }

        pIrp->Cancel = TRUE;
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = sizeof(NDISWAN_IO_PACKET);

        ((PNDISWAN_IO_PACKET)(pIrp->AssociatedIrp.SystemBuffer))->usHandleType = CANCELEDHANDLE;

        IoRecvList.LastIrp = pIrp;
        IoRecvList.LastIrpStatus = STATUS_CANCELLED;
        IoRecvList.LastCopySize = (ULONG)pIrp->IoStatus.Information;

        IoRecvList.LastPacketNumber =
            ((PNDISWAN_IO_PACKET)(pIrp->AssociatedIrp.SystemBuffer))->PacketNumber;


        NdisReleaseSpinLock(&IoRecvList.Lock);

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        NdisAcquireSpinLock(&IoRecvList.Lock);
    }
    
    NdisReleaseSpinLock(&IoRecvList.Lock);

#endif // End #ifdef NT

}

VOID
AddProtocolCBToBundle(
    PPROTOCOLCB ProtocolCB,
    PBUNDLECB   BundleCB
    )
/*++

Routine Name:

    AddProtocolCBToBundle

Routine Description:

    This routine adds the protocolcb to the bundlecb protocollist and
    protocoltable.  It also assigns the protocolcb's handle (index into
    the table) and set's the initial priority of all of the protocols
    on the list.

Arguments:

    ProtocolCB - Pointer to the protocol control block
    BundleCB - Pointer to the bundle control block

Return Values:

    None

--*/
{
    ULONG   i, InitialByteQuota;
    ULONG   InitialPriority;

    AcquireBundleLock(BundleCB);

    //
    // Add to list
    //
    InsertTailList(&BundleCB->ProtocolCBList, &ProtocolCB->Linkage);

    //
    // Insert in table
    //
    ASSERT(BundleCB->ProtocolCBTable[(ULONG_PTR)ProtocolCB->ProtocolHandle] ==
           (PPROTOCOLCB)RESERVED_PROTOCOLCB);

    BundleCB->ProtocolCBTable[(ULONG_PTR)ProtocolCB->ProtocolHandle] =
        ProtocolCB;

    BundleCB->ulNumberOfRoutes++;

    //
    // Setup the send mask for this protocolcb
    //
    ProtocolCB->SendMaskBit = BundleCB->SendMask + 0x00000001;
    BundleCB->SendMask = (BundleCB->SendMask << 1) | 0x00000001;

    ProtocolCB->State = PROTOCOL_ROUTED;

    if (BundleCB->NextProtocol == NULL) {
        BundleCB->NextProtocol = ProtocolCB;
    }

    REF_BUNDLECB(BundleCB);

    ReleaseBundleLock(BundleCB);
}

VOID
RemoveProtocolCBFromBundle(
    PPROTOCOLCB ProtocolCB
    )
{
    PBUNDLECB   BundleCB = ProtocolCB->BundleCB;

    //
    // If this protocolcb was not yet inserted in
    // the table just return.
    //
    if (BundleCB->ProtocolCBTable[(ULONG_PTR)ProtocolCB->ProtocolHandle] !=
        ProtocolCB) {
        
        return;
    }

    RemoveEntryList(&ProtocolCB->Linkage);

    BundleCB->ProtocolCBTable[(ULONG_PTR)ProtocolCB->ProtocolHandle] = NULL;
    BundleCB->ulNumberOfRoutes--;

    if (BundleCB->NextProtocol == ProtocolCB) {

        BundleCB->NextProtocol =
            (PPROTOCOLCB)ProtocolCB->Linkage.Flink;

        if ((PVOID)BundleCB->NextProtocol ==
            (PVOID)&BundleCB->ProtocolCBList) {

            if (BundleCB->ulNumberOfRoutes != 0) {

                //
                // If we are back to the head of the list
                // but there are still routes get the next.
                //
                BundleCB->NextProtocol =
                    (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;

            } else {

                //
                // No more routes left...
                //
                BundleCB->NextProtocol = NULL;
            }
        }
    }

    //
    // Deref for the ref applied when the protocolcb was
    // added to the bundle.  Don't need to do the entire
    // bundlecb ref code here.
    //
    BundleCB->RefCount--;
}

VOID
CompleteThresholdEvent(
    PBUNDLECB   BundleCB,
    ULONG       DataType,
    ULONG       ThresholdType
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
#ifdef NT
    PLIST_ENTRY Entry;
    PIRP    pIrp;
    PNDISWAN_SET_THRESHOLD_EVENT    ThresholdEvent;

    NdisAcquireSpinLock(&ThresholdEventQueue.Lock);

    if (IsListEmpty(&ThresholdEventQueue.List)) {
        NdisReleaseSpinLock(&ThresholdEventQueue.Lock);
        return;
    }

    Entry = RemoveHeadList(&ThresholdEventQueue.List);
    ThresholdEventQueue.ulCount--;

    pIrp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

    if (IoSetCancelRoutine(pIrp, NULL)) {

        pIrp->IoStatus.Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = sizeof(NDISWAN_SET_THRESHOLD_EVENT);

        ThresholdEvent = (PNDISWAN_SET_THRESHOLD_EVENT)pIrp->AssociatedIrp.SystemBuffer;
        ThresholdEvent->hBundleContext = BundleCB->hBundleContext;
        ThresholdEvent->ulThreshold = ThresholdType;
        ThresholdEvent->ulDataType = DataType;

        NdisReleaseSpinLock(&ThresholdEventQueue.Lock);

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        NdisAcquireSpinLock(&ThresholdEventQueue.Lock);
    }

    NdisReleaseSpinLock(&ThresholdEventQueue.Lock);

#endif // End #ifdef NT
}

VOID
FlushProtocolPacketQueue(
    PPROTOCOLCB ProtocolCB
    )
{
    ULONG       Class;
    PBUNDLECB   BundleCB;

    BundleCB = ProtocolCB->BundleCB;

    for (Class = 0; Class <= MAX_MCML; Class++) {
        PPACKET_QUEUE   PacketQueue;

        PacketQueue = &ProtocolCB->PacketQueue[Class];

        while (!IsPacketQueueEmpty(PacketQueue)) {
            PNDIS_PACKET    NdisPacket;
    
            NdisPacket =
                RemoveHeadPacketQueue(PacketQueue);
    
            ReleaseBundleLock(BundleCB);

            //
            // Complete the NdisPacket
            //
            CompleteNdisPacket(ProtocolCB->MiniportCB,
                               ProtocolCB,
                               NdisPacket);

            AcquireBundleLock(BundleCB);
        }
    }

}

NDIS_HANDLE
AssignProtocolCBHandle(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB
    )
{
    ULONG   i;

    //
    // Find the first unused slot in the table
    //
    for (i = 0; i < MAX_PROTOCOLS; i++) {
        if (BundleCB->ProtocolCBTable[i] == NULL) {
            ProtocolCB->ProtocolHandle = (NDIS_HANDLE)ULongToPtr(i);
            ProtocolCB->BundleCB = BundleCB;
            BundleCB->ProtocolCBTable[i] = (PPROTOCOLCB)RESERVED_PROTOCOLCB;
            break;
        }
    }

    //
    // If there is no room in the inn return
    // i == MAX_PROTOCOLS which flags as an error.
    //

    return((NDIS_HANDLE)ULongToPtr(i));
}

VOID
FreeProtocolCBHandle(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB
    )
{

    ASSERT(BundleCB->ProtocolCBTable[(ULONG_PTR)ProtocolCB->ProtocolHandle] ==
          (PPROTOCOLCB)RESERVED_PROTOCOLCB);

    ASSERT((ULONG_PTR)ProtocolCB->ProtocolHandle < MAX_PROTOCOLS);

    BundleCB->ProtocolCBTable[(ULONG_PTR)ProtocolCB->ProtocolHandle] = NULL;
}

VOID
SetBundleFlags(
    PBUNDLECB   BundleCB
    )
{
    BundleCB->SendFlags = ((BundleCB->SendCompInfo.MSCompType & NDISWAN_COMPRESSION) &&
                          (BundleCB->SendCompressContext != NULL)) ? DO_COMPRESSION : 0;

    BundleCB->SendFlags |=
        (BundleCB->SendCompInfo.MSCompType & NDISWAN_HISTORY_LESS) ? DO_HISTORY_LESS : 0;

    if (BundleCB->SendCryptoInfo.RC4Key != NULL) {
        if (BundleCB->SendCompInfo.MSCompType & NDISWAN_ENCRYPTION) {
            BundleCB->SendFlags |= (DO_ENCRYPTION | DO_LEGACY_ENCRYPTION);
        } else if (BundleCB->SendCompInfo.MSCompType & NDISWAN_40_ENCRYPTION) {
            BundleCB->SendFlags |= (DO_ENCRYPTION | DO_40_ENCRYPTION);
        } else if (BundleCB->SendCompInfo.MSCompType & NDISWAN_56_ENCRYPTION) {
            BundleCB->SendFlags |= (DO_ENCRYPTION | DO_56_ENCRYPTION);
        }
#ifdef ENCRYPT_128BIT
        else if (BundleCB->SendCompInfo.MSCompType & NDISWAN_128_ENCRYPTION) {
            BundleCB->SendFlags |= (DO_ENCRYPTION | DO_128_ENCRYPTION);
        }
#endif
    }

    BundleCB->SendFlags |=
        (BundleCB->SendVJInfo.IPCompressionProtocol == 0x2D &&
         BundleCB->VJCompress != NULL) ? DO_VJ : 0;

    BundleCB->SendFlags |=
        ((BundleCB->FramingInfo.SendFramingBits & PPP_MULTILINK_FRAMING) &&
         ((BundleCB->ulLinkCBCount > 1) || (BundleCB->Flags & QOS_ENABLED))) ?
        DO_MULTILINK : 0;

    BundleCB->SendFlags |=
        (BundleCB->FramingInfo.SendFramingBits & NBF_PRESERVE_MAC_ADDRESS) ?
        SAVE_MAC_ADDRESS : 0;

    BundleCB->RecvFlags = ((BundleCB->RecvCompInfo.MSCompType & NDISWAN_COMPRESSION) &&
                          (BundleCB->RecvCompressContext != NULL)) ? DO_COMPRESSION : 0;

    BundleCB->RecvFlags |=
        (BundleCB->RecvCompInfo.MSCompType & NDISWAN_HISTORY_LESS) ? DO_HISTORY_LESS : 0;

    if (BundleCB->RecvCryptoInfo.RC4Key != NULL) {
        if (BundleCB->RecvCompInfo.MSCompType & NDISWAN_ENCRYPTION) {
            BundleCB->RecvFlags |= (DO_ENCRYPTION | DO_LEGACY_ENCRYPTION);
        } else if (BundleCB->RecvCompInfo.MSCompType & NDISWAN_40_ENCRYPTION) {
            BundleCB->RecvFlags |= (DO_ENCRYPTION | DO_40_ENCRYPTION);
        } else if (BundleCB->RecvCompInfo.MSCompType & NDISWAN_56_ENCRYPTION) {
            BundleCB->RecvFlags |= (DO_ENCRYPTION | DO_56_ENCRYPTION);
        }
#ifdef ENCRYPT_128BIT
        else if (BundleCB->RecvCompInfo.MSCompType & NDISWAN_128_ENCRYPTION) {
            BundleCB->RecvFlags |= (DO_ENCRYPTION | DO_128_ENCRYPTION);
        }
#endif
    }

    BundleCB->RecvFlags |=
        (BundleCB->RecvVJInfo.IPCompressionProtocol == 0x2D &&
         BundleCB->VJCompress != NULL) ? DO_VJ : 0;

    BundleCB->RecvFlags |=
        ((BundleCB->FramingInfo.RecvFramingBits & PPP_MULTILINK_FRAMING) &&
         ((BundleCB->ulLinkCBCount > 1) || (BundleCB->Flags & QOS_ENABLED))) ?
        DO_MULTILINK : 0;

    BundleCB->RecvFlags |=
        (BundleCB->FramingInfo.SendFramingBits & NBF_PRESERVE_MAC_ADDRESS) ?
        SAVE_MAC_ADDRESS : 0;

}

NTSTATUS
NotImplemented(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{

    return (STATUS_NOT_IMPLEMENTED);
}

#if 0

NTSTATUS
SetFriendlyName(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    SetFriendlyName

Routine Description:

    Sets the friendly name of either a bundlecb or a linkcb

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_SET_FRIENDLY_NAME

    ulInputBufferLength - Length of the input buffer should be sizeof(NDISWAN_SET_FRIENDLY_NAME)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_SET_FRIENDLY_NAME

    ulOutputBufferLength - Length of the output buffer should be sizeof(NDISWAN_SET_FRIENDLY_NAME)

Return Values:

    NDISWAN_ERROR_INVALID_HANDLE_TYPE
    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INFO_LENGTH_MISMATCH
    STATUS_SUCCESS
--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       SizeNeeded = sizeof(NDISWAN_SET_FRIENDLY_NAME);
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;
    PUCHAR      Dest;
    ULONG       CopyLength;

    PNDISWAN_SET_FRIENDLY_NAME In =
        (PNDISWAN_SET_FRIENDLY_NAME)pInputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetFriendlyName:"));

    *pulBytesWritten = 0;

    do {

        if (ulInputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetFriendlyName: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, SizeNeeded));
            *pulBytesWritten = SizeNeeded;
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
    
        if (In->usHandleType == LINKHANDLE) {
            //
            // Is this a link handle
            //

            if (!IsLinkValid(In->hHandle, 
                             TRUE, 
                             &LinkCB)) {

                NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetFriendlyName: Invalid LinkHandle: %x",
                              In->hHandle));
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }

            NdisAcquireSpinLock(&LinkCB->Lock);

            Dest = LinkCB->Name;

            CopyLength = In->ulNameLength;

            if (ulInputBufferLength - FIELD_OFFSET(NDISWAN_SET_FRIENDLY_NAME, szName) < CopyLength) {
                CopyLength =
                    ulInputBufferLength - FIELD_OFFSET(NDISWAN_SET_FRIENDLY_NAME, szName);
            }

            if (CopyLength > MAX_NAME_LENGTH) {
                CopyLength = MAX_NAME_LENGTH;
            }

            NdisMoveMemory(Dest,
                           In->szName,
                           CopyLength);

            //
            // Deref for the ref applied by IsLinkValid
            //
            DEREF_LINKCB_LOCKED(LinkCB);
                
        } else if (In->usHandleType == BUNDLEHANDLE) {

            //
            // Or a bundle handle
            //
            if (!IsBundleValid(In->hHandle, 
                               TRUE, 
                               &BundleCB)) {

                NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetFriendlyName: Invalid BundleHandle: 0x%x",
                              In->hHandle));
                Status = NDISWAN_ERROR_INVALID_HANDLE;
                break;
            }

            AcquireBundleLock(BundleCB);

            Dest = BundleCB->Name;

            CopyLength = In->ulNameLength;

            if (ulInputBufferLength - FIELD_OFFSET(NDISWAN_SET_FRIENDLY_NAME, szName) < CopyLength) {
                CopyLength =
                    ulInputBufferLength - FIELD_OFFSET(NDISWAN_SET_FRIENDLY_NAME, szName);
            }

            if (CopyLength > MAX_NAME_LENGTH) {
                CopyLength = MAX_NAME_LENGTH;
            }

            NdisMoveMemory(Dest,
                           In->szName,
                           CopyLength);

            //
            // Deref for the ref applied by IsBundleValid
            //
            DEREF_BUNDLECB_LOCKED(BundleCB);

        } else {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("SetFriendlyName: Invalid HandleType: 0x%x",
                          In->usHandleType));
            Status = NDISWAN_ERROR_INVALID_HANDLE_TYPE;
            break;
        }
    
    } while ( 0 );


    return (Status);
}


NTSTATUS
EnumLinksInBundle(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG       SizeNeeded = 0;
    ULONG       i;
    PBUNDLECB   BundleCB = NULL;
    PLINKCB     LinkCB;
    NTSTATUS    Status = STATUS_SUCCESS;

    PNDISWAN_ENUM_LINKS_IN_BUNDLE In =
        (PNDISWAN_ENUM_LINKS_IN_BUNDLE)pInputBuffer;

    PNDISWAN_ENUM_LINKS_IN_BUNDLE Out =
        (PNDISWAN_ENUM_LINKS_IN_BUNDLE)pOutputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("EnumLinksInBundle:"));

    do {

        if (ulInputBufferLength < sizeof(NDISWAN_ENUM_LINKS_IN_BUNDLE)) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("EnumLinksInBundle: Buffer to small: Size: %d, SizeNeeded %d",
                          ulInputBufferLength, sizeof(NDISWAN_ENUM_LINKS_IN_BUNDLE)));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (!IsBundleValid(In->hBundleHandle, 
                           TRUE, 
                           &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("EnumLinksInBundle: Invalid BundleHandle: 0x%x",
                          In->hBundleHandle));
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
        
        AcquireBundleLock(BundleCB);
    
        SizeNeeded = sizeof(NDISWAN_ENUM_LINKS_IN_BUNDLE) +
                    (sizeof(NDIS_HANDLE) * BundleCB->ulLinkCBCount);
        
        *pulBytesWritten = SizeNeeded;

        if (ulOutputBufferLength < SizeNeeded) {
            
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("EnumLinksInBundle: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        Out->ulNumberOfLinks = BundleCB->ulLinkCBCount;
    
        //
        // Walk the list of linkcb's and put the handle for each
        // cb in the output handle array
        //
        i = 0;
        for (LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
             (PVOID)LinkCB != (PVOID)&BundleCB->LinkCBList;
             LinkCB = (PLINKCB)LinkCB->Linkage.Flink) {
    
            Out->hLinkHandleArray[i++] = LinkCB->hLinkHandle;
        }
    
    } while ( 0 );

    //
    // Deref for ref applied by IsBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
            
    return (Status);
}


NTSTATUS
SetProtocolPriority(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

    SetProtocolPriority

Routine Description:

    This function sets the the priority, given by uspriority, for the
    protocol given by usprotocoltype on the bundle given by hbundlehandle.

Arguments:

    pInputBuffer - Pointer to the input structure that should be NDISWAN_SET_PROTOCOL_PRIORITY

    ulInputBufferLength - Length of input buffer should be sizeof(NDISWAN_SET_PROTOCOL_PRIORITY)

    pOutputBuffer - Pointer to the output structure that should be NDISWAN_SET_PROTOCOL_PRIORITY

    ulOutputBufferLength - Length of output buffer should be sizeof(NDISWAN_SET_PROTOCOL_PRIORITY)

    pulBytesWritten - Then number of bytes written to the output buffer is returned here

Return Values:

    NDISWAN_ERROR_INVALID_HANDLE
    STATUS_INFO_LENGTH_MISMATCH

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SizeNeeded = sizeof(NDISWAN_SET_PROTOCOL_PRIORITY);
    PNDISWAN_SET_PROTOCOL_PRIORITY In = (PNDISWAN_SET_PROTOCOL_PRIORITY)pInputBuffer;
    PBUNDLECB BundleCB = NULL;
    PPROTOCOLCB ProtocolCB;
    ULONG   BytesPerSecond;

    *pulBytesWritten = 0;

    return (STATUS_SUCCESS);
}

VOID
CancelThresholdEvents(
    VOID
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
#ifdef NT
    KIRQL   Irql;
    PIRP    pIrp;
    PLIST_ENTRY Entry;


    NdisAcquireSpinLock(&ThresholdEventQueue.Lock);

    while (!IsListEmpty(&ThresholdEventQueue.List)) {

        Entry = RemoveHeadList(&ThresholdEventQueue.List);
        ThresholdEventQueue.ulCount--;

        pIrp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

        if (!IoSetCancelRoutine(pIrp, NULL)) {
            //
            // Irp is being canceled so let
            // cancel routine handle it.
            //
            continue;
        }

        NdisReleaseSpinLock(&ThresholdEventQueue.Lock);

        pIrp->Cancel = TRUE;
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = 0;

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

        NdisAcquireSpinLock(&ThresholdEventQueue.Lock);
    }

    NdisReleaseSpinLock(&ThresholdEventQueue.Lock);

#endif // End #ifdef NT
}
    
NTSTATUS
FlushThresholdEvents(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("FlushThresholdEvents:"));

    *pulBytesWritten = 0;

    CancelThresholdEvents();

    return (STATUS_SUCCESS);
}

NTSTATUS
SetEncryptionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_SET_ENCRYPTION_INFO);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetEncryptionInfo:"));

    *pulBytesWritten = 0;

    if (ulInputBufferLength < SizeNeeded) {
        
        *pulBytesWritten = SizeNeeded;
        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    return (STATUS_NOT_IMPLEMENTED);
}


NTSTATUS
GetEncryptionInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_ENCRYPTION_INFO);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetEncryptionInfo:"));

    *pulBytesWritten = SizeNeeded;

    if (ulOutputBufferLength < SizeNeeded) {
        
        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    return (STATUS_NOT_IMPLEMENTED);
}

NTSTATUS
SetDebugInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PNDISWAN_SET_DEBUG_INFO pDebugInfo = (PNDISWAN_SET_DEBUG_INFO)pInputBuffer;
    ULONG   SizeNeeded = sizeof(NDISWAN_SET_DEBUG_INFO);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetDebugInfo: OldLevel: 0x%x OldMask: 0x%x",
                                     glDebugLevel, glDebugMask));

    *pulBytesWritten = 0;

    if (ulInputBufferLength < SizeNeeded) {
        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("Buffer to small: Size: %d, SizeNeeded %d",
                      ulInputBufferLength, SizeNeeded));
        *pulBytesWritten = SizeNeeded;
        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    glDebugLevel = pDebugInfo->ulDebugLevel;
    glDebugMask = pDebugInfo->ulDebugMask;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("SetDebugInfo: NewLevel: 0x%x NewMask: 0x%x",
                                     glDebugLevel, glDebugMask));

    return (STATUS_SUCCESS);
}

NTSTATUS
EnumProtocolUtilization(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_ENUM_PROTOCOL_UTILIZATION);

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("EnumProtocolUtilization:"));

    *pulBytesWritten = SizeNeeded;

    if (ulOutputBufferLength < SizeNeeded) {
        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("EnumProtocolUtilization: Buffer to small: Size: %d, SizeNeeded %d",
                      ulOutputBufferLength, SizeNeeded));
        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    return (STATUS_NOT_IMPLEMENTED);
}

NTSTATUS
EnumActiveBundles(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_ENUM_ACTIVE_BUNDLES);
    PNDISWAN_ENUM_ACTIVE_BUNDLES    Out = (PNDISWAN_ENUM_ACTIVE_BUNDLES)pOutputBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetNumActiveBundles:"));

    *pulBytesWritten = SizeNeeded;

    if (ulOutputBufferLength < SizeNeeded) {
        NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetNumActiveBundles: Buffer to small: Size: %d, SizeNeeded %d",
                      ulOutputBufferLength, SizeNeeded));

        return(STATUS_INFO_LENGTH_MISMATCH);
    }

    //
    // Does this information need to be protected by the lock?
    // I would hate to have things get slowed for this call!
    //
    Out->ulNumberOfActiveBundles = ConnectionTable->ulNumActiveBundles;

    return (STATUS_SUCCESS);
}

NTSTATUS
FlushProtocolEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PIRP    Irp;
    KIRQL   Irql;

    *pulBytesWritten = 0;

    NdisAcquireSpinLock(&ProtocolInfoTable->Lock);

    Irp = ProtocolInfoTable->EventIrp;

    if ((Irp != NULL) &&
        IoSetCancelRoutine(Irp, NULL)) {

        ProtocolInfoTable->EventIrp = NULL;

        Irp->Cancel = TRUE;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;

        NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        NdisAcquireSpinLock(&ProtocolInfoTable->Lock);
    }

    NdisReleaseSpinLock(&ProtocolInfoTable->Lock);

    return (STATUS_SUCCESS);
}

NTSTATUS
FlushHibernateEvent(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PIRP    Irp;
    KIRQL   Irql;

    *pulBytesWritten = 0;

    NdisAcquireSpinLock(&NdisWanCB.Lock);

    Irp = NdisWanCB.HibernateEventIrp;

    if ((Irp != NULL) &&
        IoSetCancelRoutine(Irp, NULL)) {

        NdisWanCB.HibernateEventIrp = NULL;

        Irp->Cancel = TRUE;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;

        NdisReleaseSpinLock(&NdisWanCB.Lock);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        NdisAcquireSpinLock(&NdisWanCB.Lock);
    }

    NdisReleaseSpinLock(&NdisWanCB.Lock);

    return (STATUS_SUCCESS);
}

NTSTATUS
GetBundleInfo(
    IN  PUCHAR  pInputBuffer,
    IN  ULONG   ulInputBufferLength,
    IN  PUCHAR  pOutputBuffer,
    IN  ULONG   ulOutputBufferLength,
    OUT PULONG  pulBytesWritten
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   SizeNeeded = sizeof(NDISWAN_GET_BUNDLE_INFO);
    PNDISWAN_GET_BUNDLE_INFO In = (PNDISWAN_GET_BUNDLE_INFO)pInputBuffer;
    PNDISWAN_GET_BUNDLE_INFO Out = (PNDISWAN_GET_BUNDLE_INFO)pOutputBuffer;
    POPENCB OpenCB;
    PBUNDLECB   BundleCB = NULL;
    NTSTATUS    Status = STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_IO, ("GetWanInfo:"));

    *pulBytesWritten = SizeNeeded;

    do {

        if (ulInputBufferLength < SizeNeeded ||
            ulOutputBufferLength < SizeNeeded) {
            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetBundleInfo: Buffer to small: Size: %d, SizeNeeded %d",
                          ulOutputBufferLength, SizeNeeded));
            Status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
    
        if (!IsBundleValid(In->hBundleHandle, 
                           FALSE,
                           &BundleCB)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_IO, ("GetBundleInfo: Invalid Bundle Handle: 0x%x",
                          In->hBundleHandle));
            *pulBytesWritten = 0;
            Status = NDISWAN_ERROR_INVALID_HANDLE;
            break;
        }
    
        AcquireBundleLock(BundleCB);

        Out->BundleInfo.SendFramingBits =
            BundleCB->FramingInfo.SendFramingBits;
        Out->BundleInfo.SendBundleSpeed =
            BundleCB->SFlowSpec.PeakBandwidth*8;
        Out->BundleInfo.SendMSCompType =
            BundleCB->SendCompInfo.MSCompType;
        Out->BundleInfo.SendAuthType =
            BundleCB->SendCompInfo.AuthType;


        Out->BundleInfo.RecvFramingBits =
            BundleCB->FramingInfo.RecvFramingBits;
        Out->BundleInfo.RecvBundleSpeed =
            BundleCB->RFlowSpec.PeakBandwidth*8;
        Out->BundleInfo.RecvMSCompType =
            BundleCB->RecvCompInfo.MSCompType;
        Out->BundleInfo.RecvAuthType =
            BundleCB->RecvCompInfo.AuthType;

    } while ( 0 );

    //
    // Deref for ref applied by IsBundleValid.  This releases
    // the BundleCB->Lock
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);

    return (Status);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\protocol.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Protocol.c

Abstract:

    This file contains the procedures that makeup most of the NDIS 4.0/5.0
    Protocol interface.  This interface is what NdisWan exposes to the
    WAN Miniports below.  NdisWan is not really a protocol and does not
    do TDI, but is a shim that sits between the protocols and the
    WAN Miniport drivers.


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "wan.h"

#define __FILE_SIG__    PROTOCOL_FILESIG

#ifdef DBG_SENDARRAY
extern UCHAR SendArray[];
extern ULONG __si;
#endif

EXPORT
VOID
NdisTapiRegisterProvider(
    IN  NDIS_HANDLE,
    IN  PNDISTAPI_CHARACTERISTICS
    );

EXPORT
VOID
NdisTapiDeregisterProvider(
    IN  NDIS_HANDLE
    );

EXPORT
VOID
NdisTapiIndicateStatus(
    IN  NDIS_HANDLE BindingContext,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferLength
);

//
// Local functions...
//

VOID
CompleteSendDesc(
    PSEND_DESC  SendDesc,
    NDIS_STATUS Status
    );

VOID
CloseWanAdapterWorker(
    PNDIS_WORK_ITEM WorkItem,
    POPENCB pOpenCB
    );

#if 0
ULONG
CalcPPPHeaderLength(
    ULONG   FramingBits,
    ULONG   Flags
    );

#endif    

//
// Common functions used by both 4.0 and 5.0 miniports
//

NDIS_STATUS
ProtoOpenWanAdapter(
    IN  POPENCB pOpenCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS     Status, OpenErrorStatus;
    ULONG           SelectedMediumIndex;
    NDIS_MEDIUM     MediumArray[] = {NdisMediumWan, NdisMediumAtm, NdisMediumCoWan};

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoOpenAdapter: Enter - AdapterName %ls", pOpenCB->MiniportName.Buffer));

    //
    // This is the only initialization of this event
    //
    NdisWanInitializeNotificationEvent(&pOpenCB->NotificationEvent);

    NdisOpenAdapter(&Status,
                    &OpenErrorStatus,
                    &(pOpenCB->BindingHandle),
                    &SelectedMediumIndex,
                    MediumArray,
                    sizeof(MediumArray) / sizeof(NDIS_MEDIUM),
                    NdisWanCB.ProtocolHandle,
                    (NDIS_HANDLE)pOpenCB,
                    &(pOpenCB->MiniportName),
                    0,
                    NULL);

    if (Status == NDIS_STATUS_PENDING) {

        NdisWanWaitForNotificationEvent(&pOpenCB->NotificationEvent);

        Status = pOpenCB->NotificationStatus;

        NdisWanClearNotificationEvent(&pOpenCB->NotificationEvent);
    }

    if (Status == NDIS_STATUS_SUCCESS) {
        pOpenCB->MediumType = MediumArray[SelectedMediumIndex];
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoOpenAdapter: Exit"));

    return (Status);
}

//
// Enter with the opencb->lock held, exit with the lock released!
//
NDIS_STATUS
ProtoCloseWanAdapter(
    IN  POPENCB pOpenCB
)
{
    NDIS_STATUS Status;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoCloseWanAdapter: Enter %p", pOpenCB));

    pOpenCB->Flags |= OPEN_CLOSING;

    NdisReleaseSpinLock(&pOpenCB->Lock);

    //
    // NdisCloseAdapter must be called at IRQL PASSIVE_LEVEL!
    //
    if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

        NdisAcquireSpinLock(&pOpenCB->Lock);

        ASSERT(!(pOpenCB->Flags & CLOSE_SCHEDULED));

        NdisInitializeWorkItem(&pOpenCB->WorkItem,
                               CloseWanAdapterWorker,
                               pOpenCB);

        NdisScheduleWorkItem(&pOpenCB->WorkItem);

        pOpenCB->Flags |= CLOSE_SCHEDULED;

        NdisReleaseSpinLock(&pOpenCB->Lock);

        return (NDIS_STATUS_PENDING);
    }


    NdisCloseAdapter(&Status,
                     pOpenCB->BindingHandle);

    if (Status != NDIS_STATUS_PENDING) {
        ProtoCloseAdapterComplete(pOpenCB, Status);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoCloseWanAdapter: Exit"));

    return(Status);
}

VOID
CloseWanAdapterWorker(
    PNDIS_WORK_ITEM WorkItem,
    POPENCB pOpenCB
    )
{
    NDIS_STATUS Status;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("CloseWanAdapterWorker: Enter %p", pOpenCB));

    NdisCloseAdapter(&Status,
                     pOpenCB->BindingHandle);

    if (Status != NDIS_STATUS_PENDING) {
        ProtoCloseAdapterComplete(pOpenCB, Status);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("CloseWanAdapterWorker: Exit"));
}

VOID
ProtoOpenAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status,
    IN  NDIS_STATUS OpenErrorStatus
    )
/*++

Routine Name:

    ProtoOpenAdapterComplete

Routine Description:

    This function is called upon completion of an open of a miniport.
    The status of the openadapter call is stored and the notification
    event is signalled.

Arguments:

Return Values:

--*/
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoOpenAdapterComplete: Enter - OpenCB 0x%p", pOpenCB));

    pOpenCB->NotificationStatus = Status;

    NdisWanSetNotificationEvent(&pOpenCB->NotificationEvent);

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoOpenAdapterComplete: Exit"));
}

VOID
ProtoCloseAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    )
/*++

Routine Name:

    ProtoCloseAdapterComplete

Routine Description:

    This function is called upon completion of a close of a miniport.
    The status of the closeadapter call is stored and the notification
    event is signalled.

Arguments:

Return Values:

--*/
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoCloseAdapterComplete: Enter - OpenCB %p", pOpenCB));

    if (pOpenCB->UnbindContext != NULL) {
        NdisCompleteUnbindAdapter(pOpenCB->UnbindContext, Status);
    }

    if (pOpenCB->Flags & OPEN_IN_BIND) {
        //
        // We are attempting to close the adapter from
        // within our bind handler.  Per AliD we must wait
        // for the close to finish before we can return
        // from the bind handler thus we have to special case
        // this code and not free the OpenCB here.
        //
        NdisWanSetNotificationEvent(&pOpenCB->NotificationEvent);
    } else {
        NdisWanFreeOpenCB(pOpenCB);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoCloseAdapterComplete: Exit"));
}

VOID
ProtoResetComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    )
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoResetComplete: Enter - OpenCB %p", pOpenCB));

    pOpenCB->NotificationStatus = Status;

    NdisWanSetNotificationEvent(&pOpenCB->NotificationEvent);

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoResetComplete: Exit"));
}

VOID
ProtoReceiveComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    )
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;
    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProtoIndicateStatus: Enter - OpenCB %8.x8\n", pOpenCB));

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProtoIndicateStatus: Exit"));
}

VOID
ProtoIndicateStatus(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    )
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;

    switch (GeneralStatus) {
        case NDIS_STATUS_WAN_LINE_UP:
            NdisWanLineUpIndication(pOpenCB,
                                    StatusBuffer,
                                    StatusBufferSize);
            break;

        case NDIS_STATUS_WAN_LINE_DOWN:
            NdisWanLineDownIndication(pOpenCB,
                                      StatusBuffer,
                                      StatusBufferSize);
            break;

        case NDIS_STATUS_WAN_FRAGMENT:
            NdisWanFragmentIndication(pOpenCB,
                                      StatusBuffer,
                                      StatusBufferSize);
            break;

        case NDIS_STATUS_TAPI_INDICATION:
            NdisWanTapiIndication(pOpenCB,
                                  StatusBuffer,
                                  StatusBufferSize);

            break;

        default:
            NdisWanDbgOut(DBG_INFO, DBG_PROTOCOL, ("Unknown Status Indication: 0x%x", GeneralStatus));
            break;
    }

}

VOID
ProtoIndicateStatusComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    )
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;
}

VOID
ProtoWanSendComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_WAN_PACKET    WanPacket,
    IN  NDIS_STATUS         Status
    )
{
    PSEND_DESC  SendDesc;
    PLINKCB     LinkCB, RefLinkCB;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("ProtoWanSendComplete: Enter - WanPacket %p", WanPacket));

    //
    // Get info from the WanPacket
    //
    SendDesc = (PSEND_DESC)WanPacket->ProtocolReserved1;

    LinkCB = SendDesc->LinkCB;

    if (!IsLinkValid(LinkCB->hLinkHandle, FALSE, &RefLinkCB)) {

        NdisWanDbgOut(DBG_FAILURE, DBG_CL,
            ("NDISWAN: SendComplete after link has gone down NdisContext %p\n",
             LinkCB));

        return;
    }

    REMOVE_DBG_SEND(PacketTypeWan, LinkCB->OpenCB, WanPacket);

    ASSERT(RefLinkCB == LinkCB);

    NdisAcquireSpinLock(&LinkCB->Lock);

    CompleteSendDesc(SendDesc, Status);

    //
    // Deref for the ref applied in IsLinkValid
    //
    DEREF_LINKCB(LinkCB);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("ProtoWanSendComplete: Exit"));
}

NDIS_STATUS
ProtoWanReceiveIndication(
    IN  NDIS_HANDLE NdisLinkHandle,
    IN  PUCHAR      Packet,
    IN  ULONG       PacketSize
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PLINKCB     LinkCB = NULL;
    PBUNDLECB   BundleCB = NULL;
    PUCHAR      DataBuffer;
    ULONG       DataBufferSize;
    ULONG       BytesCopied;
    PNDIS_PACKET    NdisPacket;
    PNDIS_BUFFER    NdisBuffer;
    PRECV_DESC      RecvDesc;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProtoWanReceiveIndication: Enter - Context %x", NdisLinkHandle));

    do {

        if (!AreLinkAndBundleValid(NdisLinkHandle, 
                                   TRUE,
                                   &LinkCB, 
                                   &BundleCB)) {
#if DBG
            DbgPrint("NDISWAN: Recv after link has gone down LinkContext %x\n",
                     NdisLinkHandle);
#endif

            break;
        }
    
        AcquireBundleLock(BundleCB);
        
        //
        // Make sure we don't try to process a receive indication
        // that is larger then our max data buffer size
        // winse 26544
        //

        if (PacketSize > glMRU) {
            break;
        }

        //
        // Build a receive descriptor for this receive.  We have
        // to allocate with a large size because this packet might
        // be compressed.
        //
        RecvDesc = 
            NdisWanAllocateRecvDesc(glLargeDataBufferSize);
    
        if (RecvDesc == NULL) {
            break;
        }
    
        //
        // Update the bandwidth on demand sample array with the latest send.
        // If we need to notify someone of a bandwidth event do it.
        //
        if (BundleCB->Flags & BOND_ENABLED) {
            UpdateBandwidthOnDemand(BundleCB->RUpperBonDInfo, PacketSize);
            CheckUpperThreshold(BundleCB);
            UpdateBandwidthOnDemand(BundleCB->RLowerBonDInfo, PacketSize);
            CheckLowerThreshold(BundleCB);
        }
    
        RecvDesc->CopyRequired = TRUE;
        RecvDesc->CurrentBuffer = Packet;
        RecvDesc->CurrentLength = PacketSize;
        RecvDesc->LinkCB = LinkCB;
        RecvDesc->BundleCB = BundleCB;
    
        //
        // Indicate to netmon if we are sniffing at
        // the link level
        //
        if (gbSniffLink &&
            (NdisWanCB.PromiscuousAdapter != NULL)) {
    
            //
            // Indicate a packet to netmon
            //
            IndicatePromiscuousRecv(BundleCB, RecvDesc, RECV_LINK);
        }
    
        //
        // Add up the statistics
        //
        LinkCB->Stats.BytesReceived += RecvDesc->CurrentLength;
        LinkCB->Stats.FramesReceived++;
        BundleCB->Stats.BytesReceived += RecvDesc->CurrentLength;
    
        LinkCB->Flags |= LINK_IN_RECV;
        BundleCB->Flags |= BUNDLE_IN_RECV;

        Status = (*LinkCB->RecvHandler)(LinkCB, RecvDesc);
    
        BundleCB->Flags &= ~BUNDLE_IN_RECV;
        LinkCB->Flags &= ~LINK_IN_RECV;

        if (Status != NDIS_STATUS_PENDING) {
            NdisWanFreeRecvDesc(RecvDesc);
        }

    } while ( 0 );

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProtoWanReceiveIndication: Exit"));


    //
    // Deref's for the ref's applied in AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (NDIS_STATUS_SUCCESS);
}

VOID
ProtoRequestComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_REQUEST   NdisRequest,
    IN  NDIS_STATUS     Status
    )
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;
    PWAN_REQUEST pWanRequest;

    pWanRequest = CONTAINING_RECORD(NdisRequest,
                                    WAN_REQUEST,
                                    NdisRequest);

    NdisWanDbgOut(DBG_VERBOSE, DBG_REQUEST, ("ProtoRequestComplete: Enter - pWanRequest: 0x%p", pWanRequest));

    pWanRequest->NotificationStatus = Status;

    switch (pWanRequest->Origin) {
    case NDISWAN:
        NdisWanSetNotificationEvent(&pWanRequest->NotificationEvent);
        break;

    default:
        ASSERT(pWanRequest->Origin == NDISTAPI);
        NdisWanTapiRequestComplete(pOpenCB, pWanRequest);
        break;

    }

    NdisWanDbgOut(DBG_VERBOSE, DBG_REQUEST, ("ProtoRequestComplete: Exit"));
}

VOID
ProtoBindAdapter(
    OUT PNDIS_STATUS    Status,
    IN  NDIS_HANDLE     BindContext,
    IN  PNDIS_STRING    DeviceName,
    IN  PVOID           SystemSpecific1,
    IN  PVOID           SystemSpecific2
    )
/*++

Routine Name:

    ProtoBindAdapter

Routine Description:

    This function is called by the NDIS wrapper to tell NdisWan
    to bind to an underlying miniport.  NdisWan will open the
    miniport and query information on the device.

Arguments:

    Status      -   Return status
    BindContext -   Used in NdisBindAdapterComplete
    DeviceName  -   Name of device we are opening
    SS1         -   Used in NdisOpenProtocolConfig
    SS2         -   Reserved

Return Values:

--*/
{
    POPENCB         pOpenCB;
    
    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoBindAdapter - Enter %ls", DeviceName->Buffer));

    pOpenCB = NdisWanAllocateOpenCB(DeviceName);

    if (pOpenCB == NULL) {
        *Status = NDIS_STATUS_RESOURCES;
        return;
    }

    pOpenCB->Flags |= OPEN_IN_BIND;

    NdisWanInitializeNotificationEvent(&pOpenCB->InitEvent);

    *Status = ProtoOpenWanAdapter(pOpenCB);

    if (*Status != NDIS_STATUS_SUCCESS) {

        RemoveEntryGlobalList(OpenCBList, &pOpenCB->Linkage);

        NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_INIT, ("Failed to bind to %ls! Error 0x%x - %s",
        pOpenCB->MiniportName.Buffer, *Status, NdisWanGetNdisStatus(*Status)));

        NdisWanFreeOpenCB(pOpenCB);

        return;
    }

    //
    // Figure out if this is a legacy wan miniport.
    //
    if (pOpenCB->MediumType == NdisMediumWan) {
        pOpenCB->Flags |= OPEN_LEGACY;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_INIT, ("Successful Binding to %s miniport %ls!",
        (pOpenCB->Flags & OPEN_LEGACY) ? "Legacy" : "NDIS 5.0",
        pOpenCB->MiniportName.Buffer));

    //
    // Get the wan medium subtype
    //
    {
        WAN_REQUEST WanRequest;
    
        NdisZeroMemory(&WanRequest, sizeof(WanRequest));
        WanRequest.Type = SYNC;
        WanRequest.Origin = NDISWAN;
        WanRequest.OpenCB = pOpenCB;
        NdisWanInitializeNotificationEvent(&WanRequest.NotificationEvent);

        WanRequest.NdisRequest.RequestType =
            NdisRequestQueryInformation;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid =
            OID_WAN_MEDIUM_SUBTYPE;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer =
            &pOpenCB->MediumSubType;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(pOpenCB->MediumSubType);
    
        *Status = NdisWanSubmitNdisRequest(pOpenCB, &WanRequest);

        if (*Status != NDIS_STATUS_SUCCESS) {
            NdisWanDbgOut(DBG_FAILURE, DBG_INIT, ("Error returned from OID_WAN_MEDIUM_SUBTYPE! Error 0x%x - %s",
            *Status, NdisWanGetNdisStatus(*Status)));
            pOpenCB->MediumSubType = NdisWanMediumHub;
            *Status = NDIS_STATUS_SUCCESS;
        }
    }

    if (pOpenCB->Flags & OPEN_LEGACY) {
        NDIS_WAN_INFO   WanInfo;
        WAN_REQUEST WanRequest;
    
        //
        // This is a legacy wan miniport
        //

        NdisZeroMemory(&WanRequest, sizeof(WanRequest));
        WanRequest.Type = SYNC;
        WanRequest.Origin = NDISWAN;
        WanRequest.OpenCB = pOpenCB;
        NdisWanInitializeNotificationEvent(&WanRequest.NotificationEvent);

        //
        // Get more info...
        //
        NdisZeroMemory(&WanInfo, sizeof(WanInfo));

        WanRequest.NdisRequest.RequestType =
            NdisRequestQueryInformation;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid =
            OID_WAN_GET_INFO;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer =
            &WanInfo;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(WanInfo);
    
        *Status = NdisWanSubmitNdisRequest(pOpenCB, &WanRequest);

        if (*Status != NDIS_STATUS_SUCCESS) {
            NDIS_STATUS CloseStatus;

            NdisWanDbgOut(DBG_FAILURE, DBG_INIT, ("Error returned from OID_WAN_GET_INFO! Error 0x%x - %s",
            *Status, NdisWanGetNdisStatus(*Status)));

            NdisAcquireSpinLock(&pOpenCB->Lock);

            pOpenCB->Flags |= OPEN_CLOSING;

            NdisWanInitializeNotificationEvent(&pOpenCB->NotificationEvent);

            NdisReleaseSpinLock(&pOpenCB->Lock);

            NdisCloseAdapter(&CloseStatus,
                             pOpenCB->BindingHandle);

            if (CloseStatus == NDIS_STATUS_PENDING) {

                NdisWanWaitForNotificationEvent(&pOpenCB->NotificationEvent);
            }

            NdisWanFreeOpenCB(pOpenCB);

            return;
        }
    
        NdisMoveMemory(&pOpenCB->WanInfo, &WanInfo, sizeof(NDIS_WAN_INFO));

        if (pOpenCB->WanInfo.MaxTransmit == 0) {
            pOpenCB->WanInfo.MaxTransmit = 1;
        }

        if (pOpenCB->WanInfo.Endpoints == 0) {
            pOpenCB->WanInfo.Endpoints = 1000;
        }
    
        *Status = NdisWanAllocateSendResources(pOpenCB);

        if (*Status != NDIS_STATUS_SUCCESS) {
            NDIS_STATUS CloseStatus;

            NdisWanDbgOut(DBG_FAILURE, DBG_INIT, ("Error returned from AllocateSendResources! Error 0x%x - %s",
            *Status, NdisWanGetNdisStatus(*Status)));

            NdisAcquireSpinLock(&pOpenCB->Lock);

            pOpenCB->Flags |= OPEN_CLOSING;

            NdisWanInitializeNotificationEvent(&pOpenCB->NotificationEvent);

            NdisReleaseSpinLock(&pOpenCB->Lock);

            NdisCloseAdapter(&CloseStatus,
                             pOpenCB->BindingHandle);

            if (CloseStatus == NDIS_STATUS_PENDING) {

                NdisWanWaitForNotificationEvent(&pOpenCB->NotificationEvent);
            }

            NdisWanFreeOpenCB(pOpenCB);

            return;
        }

        //
        // Tell tapi about this device
        //
        if (pOpenCB->WanInfo.FramingBits & TAPI_PROVIDER) {
            NDISTAPI_CHARACTERISTICS    Chars;
            ULONG NdisTapiKey;

            NdisMoveMemory(&Chars.Guid,
                           &pOpenCB->Guid,
                           sizeof(Chars.Guid));

            Chars.MediaType = pOpenCB->MediumSubType;
            Chars.RequestProc = NdisWanTapiRequestProc;

            //
            // Note that since there are typically very few
            // (< 10) wan miniports, just having an incrementing
            // counter will do. There is a pathological case where
            // one of the miniports can be added and removed a billion
            // times so that the counter wraps around and clashes with
            // an existing miniport - this is not even a stress scenario.
            //

            NdisTapiKey = NdisWanInterlockedInc(
                            &glNdisTapiKey);
                            
            pOpenCB->NdisTapiKey = UlongToHandle(NdisTapiKey);

            NdisTapiRegisterProvider(pOpenCB->NdisTapiKey, &Chars);
        }

    } else {
        //
        // This is a 5.0 miniport! We will do init work
        // when a call manager registers for this!
        //
    }

    pOpenCB->Flags &= ~OPEN_IN_BIND;

    NdisWanSetNotificationEvent(&pOpenCB->InitEvent);

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoBindAdapter - Exit"));
}

VOID
ProtoUnbindAdapter(
    OUT PNDIS_STATUS    Status,
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  NDIS_HANDLE     UnbindContext
    )
{
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;
    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoUnbindAdapter: Enter - OpenCB %p", pOpenCB));

    NdisAcquireSpinLock(&pOpenCB->Lock);

    while (pOpenCB->AfRegisteringCount != 0) {
        NdisReleaseSpinLock(&pOpenCB->Lock);
        NdisWanWaitForNotificationEvent(&pOpenCB->AfRegisteringEvent);
        NdisAcquireSpinLock(&pOpenCB->Lock);
    }

    if (!(pOpenCB->Flags & OPEN_LEGACY)) {

        while (!IsListEmpty(&pOpenCB->AfSapCBList)) {
            PCL_AFSAPCB AfSapCB;
            NDIS_STATUS RetStatus;

            AfSapCB = 
                (PCL_AFSAPCB)RemoveHeadList(&pOpenCB->AfSapCBList);

            InsertTailList(&pOpenCB->AfSapCBClosing, &AfSapCB->Linkage);
    
            NdisReleaseSpinLock(&pOpenCB->Lock);

            NdisAcquireSpinLock(&AfSapCB->Lock);

            AfSapCB->Flags |= AFSAP_REMOVED_UNBIND;

            DEREF_CLAFSAPCB_LOCKED(AfSapCB);

            NdisAcquireSpinLock(&pOpenCB->Lock);
        }
    }

    pOpenCB->UnbindContext = UnbindContext;

    NdisReleaseSpinLock(&pOpenCB->Lock);

    if (pOpenCB->WanInfo.FramingBits & TAPI_PROVIDER) {
        NdisTapiDeregisterProvider(pOpenCB->NdisTapiKey);
    }

    DEREF_OPENCB(pOpenCB);

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoUnbindAdapter: Exit"));

    *Status = NDIS_STATUS_PENDING;
}

VOID
ProtoUnload(
    VOID
    )
{
    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoUnload: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoUnload: Exit"));
}

NDIS_STATUS
ProtoPnPEvent(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNET_PNP_EVENT  NetPnPEvent
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    POPENCB pOpenCB = (POPENCB)ProtocolBindingContext;

    if (pOpenCB == NULL) {
        return (NDIS_STATUS_SUCCESS);
    }

    switch (NetPnPEvent->NetEvent) {
    case NetEventSetPower:
        {
        NET_DEVICE_POWER_STATE PowerState;

        PowerState = *((NET_DEVICE_POWER_STATE*)NetPnPEvent->Buffer);

        NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
            ("ProtoPnPEvent: OpenCB %p %s State %d",
                pOpenCB, "SetPower", PowerState));

        switch (PowerState) {
        case NetDeviceStateD0:
            break;
        case NetDeviceStateD1:
        case NetDeviceStateD2:
        case NetDeviceStateD3:

            //
            // If this is the open on asyncmac I do not want it to be closed.
            // I will succeed the set power which should keep ndis from
            // unbinding me.  If this is an open on any other miniport
            // I will return not supported so that I will get unbound from
            // the miniport.  This is required for correct tapi behavior.
            //
            if (pOpenCB->MediumType == NdisMediumWan &&
                pOpenCB->MediumSubType == NdisWanMediumSerial &&
                !(pOpenCB->WanInfo.FramingBits & TAPI_PROVIDER)) {
                Status = NDIS_STATUS_SUCCESS;
            } else {
                Status = NDIS_STATUS_NOT_SUPPORTED;
            }

            //
            // In the case of a Critical Power event we will not
            // receive a Query so we must tear the connection down
            // directly from the Set.
            //
            // If we have any active connections signal rasman to
            // tear them down.
            //
            if (InterlockedCompareExchange(&pOpenCB->ActiveLinkCount, 0, 0)) {
                PIRP    Irp;

                NdisAcquireSpinLock(&NdisWanCB.Lock);
                Irp = NdisWanCB.HibernateEventIrp;

                if ((Irp != NULL) &&
                    IoSetCancelRoutine(Irp, NULL)){

                    NdisWanCB.HibernateEventIrp = NULL;

                    NdisReleaseSpinLock(&NdisWanCB.Lock);

                    //
                    // The irp is not being canceled so
                    // lets do it!
                    //

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = 0;

                    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

                    NdisAcquireSpinLock(&NdisWanCB.Lock);
                }

                NdisReleaseSpinLock(&NdisWanCB.Lock);
            }
            break;

        default:
            break;
        }

        }
        break;

    case NetEventQueryPower:
        {
        NET_DEVICE_POWER_STATE PowerState;

        PowerState = *((NET_DEVICE_POWER_STATE*)NetPnPEvent->Buffer);

        NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
            ("ProtoPnPEvent: OpenCB %p %s State %d",
                pOpenCB, "QueryPower", PowerState));
        //
        // If there is an active connection
        // on this binding refuse to go away
        //
        switch (PowerState) {
        case NetDeviceStateD0:
            break;
        case NetDeviceStateD1:
        case NetDeviceStateD2:
        case NetDeviceStateD3:

            //
            // If we have any active connections signal rasman to
            // tear them down.
            //
            if (InterlockedCompareExchange(&pOpenCB->ActiveLinkCount, 0, 0)) {
                PIRP    Irp;

                NdisAcquireSpinLock(&NdisWanCB.Lock);
                Irp = NdisWanCB.HibernateEventIrp;

                if ((Irp != NULL) &&
                    IoSetCancelRoutine(Irp, NULL)) {

                    NdisWanCB.HibernateEventIrp = NULL;
                    NdisReleaseSpinLock(&NdisWanCB.Lock);

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = 0;

                    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

                    NdisAcquireSpinLock(&NdisWanCB.Lock);
                }

                NdisReleaseSpinLock(&NdisWanCB.Lock);
            }
            break;

        default:
            break;
        }

        }
        break;

    case NetEventQueryRemoveDevice:
    case NetEventCancelRemoveDevice:
    case NetEventReconfigure:
    case NetEventBindList:
    default:
        break;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoPnPEvent: Exit"));
    return (Status);
}

VOID
ProtoCoSendComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PNDIS_PACKET    Packet
    )
{
    PLINKCB         LinkCB;
    PBUNDLECB       BundleCB;
    PSEND_DESC      SendDesc;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND,
        ("ProtoCoSendComplete: Enter - VC %p Packet: %p", ProtocolVcContext, Packet));

    if (!IsLinkValid(ProtocolVcContext, FALSE, &LinkCB)) {

        NdisWanDbgOut(DBG_FAILURE, DBG_CL,
            ("NDISWAN: SendComplete after link has gone down ProtocolVcContext %p\n",
             LinkCB));

        return;
    }

    REMOVE_DBG_SEND(PacketTypeNdis, LinkCB->OpenCB, Packet);

    //
    // Get Info from the NdisPacket
    //
    SendDesc = PPROTOCOL_RESERVED_FROM_NDIS(Packet)->SendDesc;

    NdisAcquireSpinLock(&LinkCB->Lock);

    ASSERT(SendDesc->LinkCB == LinkCB);

    CompleteSendDesc(SendDesc, Status);

    NdisAcquireSpinLock(&LinkCB->Lock);

    //
    // Remove ref that keeps the vc around
    //
    DerefVc(LinkCB);

    //
    // Deref for the ref applied in IsLinkValid
    //
    DEREF_LINKCB_LOCKED(LinkCB);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("ProtoCoSendComplete: Exit"));
}

VOID
ProtoCoIndicateStatus(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext   OPTIONAL,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    )
{
    POPENCB     pOpenCB = (POPENCB)ProtocolBindingContext;
    PLINKCB     LinkCB;
    PBUNDLECB   BundleCB;

    if (!AreLinkAndBundleValid(ProtocolVcContext, 
                               TRUE,
                               &LinkCB, 
                               &BundleCB)) {

        return;
    }

    switch (GeneralStatus) {
    case NDIS_STATUS_WAN_CO_FRAGMENT:
        NdisCoWanFragmentIndication(LinkCB,
                                    BundleCB,
                                    StatusBuffer,
                                    StatusBufferSize);

        break;

    case NDIS_STATUS_WAN_CO_LINKPARAMS:
        NdisCoWanLinkParamChange(LinkCB,
                                 BundleCB,
                                 StatusBuffer,
                                 StatusBufferSize);

    default:
        NdisWanDbgOut(DBG_INFO, DBG_PROTOCOL,
            ("Unknown Status Indication: 0x%x", GeneralStatus));
        break;
    }

    //
    // Deref's for ref's applied in AreLinkAndBundleValid
    //
    DEREF_LINKCB(LinkCB);
    DEREF_BUNDLECB(BundleCB);
}

UINT
ProtoCoReceivePacket(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PNDIS_PACKET    Packet
    )
{
    POPENCB         pOpenCB = (POPENCB)ProtocolBindingContext;
    PLINKCB         LinkCB = NULL;
    PBUNDLECB       BundleCB = NULL;
    NDIS_STATUS     Status;
    ULONG           BufferCount;
    LONG            PacketSize;
    PNDIS_BUFFER    FirstBuffer;
    PRECV_DESC      RecvDesc;
    UINT            RefCount = 0;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE,
        ("ProtoCoReceivePacket: Enter - OpenCB %p", pOpenCB));

    do {

        if (!AreLinkAndBundleValid(ProtocolVcContext,
                                   TRUE,
                                   &LinkCB,
                                   &BundleCB)) {
            break;
        }

#if DBG
        NdisAcquireSpinLock(&LinkCB->Lock);

        if (LinkCB->ClCallState != CL_CALL_CONNECTED) {
            DbgPrint("NDISWAN: Vc not fully active but indicating data!\n");
        }

        NdisReleaseSpinLock(&LinkCB->Lock);
#endif

        AcquireBundleLock(BundleCB);

        NdisQueryPacket(Packet,
                        NULL,
                        &BufferCount,
                        &FirstBuffer,
                        &PacketSize);

        if (PacketSize > (LONG)glMRU) {
            break;
        }

        PRECV_RESERVED_FROM_NDIS(Packet)->MagicNumber = MAGIC_EXTERNAL_RECV;

        RecvDesc = 
            NdisWanAllocateRecvDesc(glLargeDataBufferSize);

        if (RecvDesc == NULL) {
            break;
        }

        RecvDesc->LinkCB = LinkCB;
        RecvDesc->BundleCB = BundleCB;

        //
        // If the packet has only one buffer we are happy, if not
        // we have to allocate our own ndis packet and buffers
        // and copy the data from the miniports packet into our packet
        //
        if (BufferCount > 1 ||
            NDIS_GET_PACKET_STATUS(Packet) == NDIS_STATUS_RESOURCES) {

            RecvDesc->CurrentBuffer = RecvDesc->StartBuffer +
                                      MAC_HEADER_LENGTH +
                                      PROTOCOL_HEADER_LENGTH;

            //
            // Copy from the miniports packet to my packet
            //
            NdisWanCopyFromPacketToBuffer(Packet,
                                          0,
                                          PacketSize,
                                          RecvDesc->CurrentBuffer,
                                          &RecvDesc->CurrentLength);

            ASSERT(PacketSize == RecvDesc->CurrentLength);

        } else {
            NdisQueryBuffer(FirstBuffer,
                            &RecvDesc->CurrentBuffer,
                            &RecvDesc->CurrentLength);

            ASSERT(PacketSize == RecvDesc->CurrentLength);

            RecvDesc->CopyRequired = TRUE;

            RecvDesc->OriginalPacket = Packet;

            RefCount = 1;
        }

        //
        // Indicate to netmon if we are sniffing at
        // the link level
        //
        if (gbSniffLink &&
            (NdisWanCB.PromiscuousAdapter != NULL)) {

            //
            // Indicate a packet to netmon
            //
            IndicatePromiscuousRecv(BundleCB, RecvDesc, RECV_LINK);
        }

        //
        // Update the bandwidth on demand sample array with the latest send.
        // If we need to notify someone of a bandwidth event do it.
        //
        if (BundleCB->Flags & BOND_ENABLED) {
            UpdateBandwidthOnDemand(BundleCB->RUpperBonDInfo, PacketSize);
            CheckUpperThreshold(BundleCB);
            UpdateBandwidthOnDemand(BundleCB->RLowerBonDInfo, PacketSize);
            CheckLowerThreshold(BundleCB);
        }

        //
        // Add up the statistics
        //
        LinkCB->Stats.BytesReceived += RecvDesc->CurrentLength;
        LinkCB->Stats.FramesReceived++;
        BundleCB->Stats.BytesReceived += RecvDesc->CurrentLength;

        Status = (*LinkCB->RecvHandler)(LinkCB, RecvDesc);

        if (Status != NDIS_STATUS_PENDING) {
            RecvDesc->OriginalPacket = NULL;
            NdisWanFreeRecvDesc(RecvDesc);
            RefCount = 0;
        }

        NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProtoCoReceivePacket: Exit"));

    } while (0);

    //
    // Deref's for ref's applied by AreLinkAndBundleValid
    //
    DEREF_BUNDLECB_LOCKED(BundleCB);
    DEREF_LINKCB(LinkCB);

    return (RefCount);
}

NDIS_STATUS
ProtoCoRequest(
    IN  NDIS_HANDLE         ProtocolAfContext,
    IN  NDIS_HANDLE         ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE         ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST    NdisRequest
    )
{
    PCL_AFSAPCB AfSapCB = (PCL_AFSAPCB)ProtocolAfContext;
    NDIS_OID Oid;

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, ("ProtoCoRequest: Enter - AfContext %p", ProtocolAfContext));

    if (NdisRequest->RequestType == NdisRequestQueryInformation) {
        Oid = NdisRequest->DATA.QUERY_INFORMATION.Oid;
    } else {
        Oid = NdisRequest->DATA.SET_INFORMATION.Oid;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, ("Oid - %x", Oid));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    switch (Oid) {
        case OID_CO_AF_CLOSE:
            {
            POPENCB OpenCB;
            PCL_AFSAPCB tAfSapCB;

            OpenCB = AfSapCB->OpenCB;

            NdisAcquireSpinLock(&OpenCB->Lock);

            while (OpenCB->AfRegisteringCount != 0) {
                NdisReleaseSpinLock(&OpenCB->Lock);
                NdisWanWaitForNotificationEvent(&OpenCB->AfRegisteringEvent);
                NdisAcquireSpinLock(&OpenCB->Lock);
            }

            for (tAfSapCB = (PCL_AFSAPCB)OpenCB->AfSapCBList.Flink;
                (PVOID)tAfSapCB != (PVOID)&OpenCB->AfSapCBList;
                tAfSapCB = (PCL_AFSAPCB)AfSapCB->Linkage.Flink) {

                if (tAfSapCB == AfSapCB) {
                    break;
                }
            }

            if ((PVOID)tAfSapCB == (PVOID)&OpenCB->AfSapCBList) {
                NdisWanDbgOut(DBG_FAILURE, DBG_REQUEST, \
                              ("ProtoCoRequest: Af %p not on OpenCB %p list!", \
                               AfSapCB, OpenCB));

                NdisReleaseSpinLock(&OpenCB->Lock);

                break;
            }

            RemoveEntryList(&AfSapCB->Linkage);

            InsertTailList(&OpenCB->AfSapCBClosing,
                           &AfSapCB->Linkage);

            NdisReleaseSpinLock(&OpenCB->Lock);

            NdisAcquireSpinLock(&AfSapCB->Lock);

            ASSERT(!(AfSapCB->Flags & AFSAP_REMOVED_FLAGS));
            ASSERT(AfSapCB->Flags & SAP_REGISTERED);

            AfSapCB->Flags |= AFSAP_REMOVED_REQUEST;

            DEREF_CLAFSAPCB_LOCKED(AfSapCB);

            }
            break;

        default:
            break;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, ("ProtoCoRequest: Exit"));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return (NDIS_STATUS_SUCCESS);
}

VOID
ProtoCoRequestComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE     ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST   NdisRequest
    )
{
    PCL_AFSAPCB AfSapCB = (PCL_AFSAPCB)ProtocolAfContext;
    PWAN_REQUEST pWanRequest;
    POPENCB     pOpenCB;

    pWanRequest = CONTAINING_RECORD(NdisRequest,
                                    WAN_REQUEST,
                                    NdisRequest);

    pOpenCB = pWanRequest->OpenCB;

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, ("ProtoCoRequestComplete: Enter - WanRequest 0x%p", pWanRequest));

    pWanRequest->NotificationStatus = Status;

    switch (pWanRequest->Origin) {
    case NDISWAN:
        NdisWanSetNotificationEvent(&pWanRequest->NotificationEvent);
        break;

    default:
        ASSERT(pWanRequest->Origin == NDISTAPI);
        NdisWanTapiRequestComplete(pOpenCB, pWanRequest);
        break;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, ("ProtoCoRequestComplete: Exit"));
}

VOID
ProtoCoAfRegisterNotify(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily
    )
{
    POPENCB OpenCB = (POPENCB)ProtocolBindingContext;
    NDIS_CLIENT_CHARACTERISTICS ClCharacteristics;
    PCL_AFSAPCB     AfSapCB;
    NDIS_STATUS     Status;
    ULONG           GenericUlong;
    NDIS_HANDLE     AfHandle;
    WAN_REQUEST     WanRequest;
    NDIS_WAN_CO_INFO    WanInfo;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
    ("ProtoCoAfRegisterNotify: Enter - OpenCB %p AfType: %x", OpenCB, AddressFamily->AddressFamily));

    //
    // If this is a proxied address family we are interested,
    // so open the address family, register a sap and return success.
    //
    if (AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_TAPI) {
        NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
        ("ProtoCoAfRegisterNotify: Af not tapi do not open!"));
        return;
    }

    NdisAcquireSpinLock(&OpenCB->Lock);

    for (AfSapCB = (PCL_AFSAPCB)OpenCB->AfSapCBList.Flink;
        (PVOID)AfSapCB != (PVOID)&OpenCB->AfSapCBList;
        AfSapCB = (PCL_AFSAPCB)AfSapCB->Linkage.Flink) {

        if (AfSapCB->Af.AddressFamily == AddressFamily->AddressFamily) {
            //
            // we already have this addressfamily on this open block.
            //
            NdisReleaseSpinLock(&OpenCB->Lock);
            return;
        }
    }

    AfSapCB = 
        NdisWanAllocateClAfSapCB(OpenCB, AddressFamily);

    if (AfSapCB == NULL) {
        NdisReleaseSpinLock(&OpenCB->Lock);
        return;
    }

    //
    // Use this crude mechanism to keep us from unbinding while in the
    // middle of af notification.  The count is cleaned up either in
    // openafcomplete (if open failed) or in registersapcomplete.
    //
    if (OpenCB->AfRegisteringCount == 0) {
        NdisWanInitializeNotificationEvent(&OpenCB->AfRegisteringEvent);
    }

    OpenCB->AfRegisteringCount++;

    NdisReleaseSpinLock(&OpenCB->Lock);

    //
    // Open the address family
    //
    NdisZeroMemory(&ClCharacteristics, sizeof(NDIS_CLIENT_CHARACTERISTICS));

    ClCharacteristics.MajorVersion = NDISWAN_MAJOR_VERSION;
    ClCharacteristics.MinorVersion = NDISWAN_MINOR_VERSION;
    ClCharacteristics.ClCreateVcHandler = ClCreateVc;
    ClCharacteristics.ClDeleteVcHandler = ClDeleteVc;
    ClCharacteristics.ClRequestHandler = ProtoCoRequest;
    ClCharacteristics.ClRequestCompleteHandler = ProtoCoRequestComplete;
    ClCharacteristics.ClOpenAfCompleteHandler = ClOpenAfComplete;
    ClCharacteristics.ClCloseAfCompleteHandler = ClCloseAfComplete;
    ClCharacteristics.ClRegisterSapCompleteHandler = ClRegisterSapComplete;
    ClCharacteristics.ClDeregisterSapCompleteHandler = ClDeregisterSapComplete;
    ClCharacteristics.ClMakeCallCompleteHandler = ClMakeCallComplete;
    ClCharacteristics.ClModifyCallQoSCompleteHandler = ClModifyQoSComplete;
    ClCharacteristics.ClCloseCallCompleteHandler = ClCloseCallComplete;
    ClCharacteristics.ClAddPartyCompleteHandler = NULL;
    ClCharacteristics.ClDropPartyCompleteHandler = NULL;
    ClCharacteristics.ClIncomingCallHandler = ClIncomingCall;
    ClCharacteristics.ClIncomingCallQoSChangeHandler = ClIncomingCallQoSChange;
    ClCharacteristics.ClIncomingCloseCallHandler = ClIncomingCloseCall;
    ClCharacteristics.ClIncomingDropPartyHandler = NULL;
    ClCharacteristics.ClCallConnectedHandler        = ClCallConnected;

    Status =
    NdisClOpenAddressFamily(OpenCB->BindingHandle,
                            AddressFamily,
                            AfSapCB,
                            &ClCharacteristics,
                            sizeof(NDIS_CLIENT_CHARACTERISTICS),
                            &AfHandle);

    if (Status != NDIS_STATUS_PENDING) {
        ClOpenAfComplete(Status, AfSapCB, AfHandle);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
    ("ClOpenAddressFamily AfHandle 0x%x status: 0x%x", AfSapCB->AfHandle, Status));

    //
    // Do some OID's to the miniport.  This is a
    // CoNDIS miniport and are destined for the 
    // miniport so AfHandle and VcHandle = NULL!
    //
    NdisZeroMemory(&WanRequest, sizeof(WanRequest));

    WanRequest.Type = SYNC;
    WanRequest.Origin = NDISWAN;
    WanRequest.OpenCB = OpenCB;
    WanRequest.AfHandle = NULL;
    WanRequest.VcHandle = NULL;
    NdisWanInitializeNotificationEvent(&WanRequest.NotificationEvent);

    //
    // Get more info...
    //
    WanRequest.NdisRequest.RequestType =
        NdisRequestQueryInformation;

    WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid =
        OID_WAN_CO_GET_INFO;

    WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer =
        &WanInfo;

    WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength =
        sizeof(WanInfo);

    Status = NdisWanSubmitNdisRequest(OpenCB, &WanRequest);

    if (Status == NDIS_STATUS_SUCCESS) {
        OpenCB->WanInfo.MaxFrameSize = WanInfo.MaxFrameSize;
        OpenCB->WanInfo.MaxTransmit = WanInfo.MaxSendWindow;
        OpenCB->WanInfo.FramingBits = WanInfo.FramingBits;
        OpenCB->WanInfo.DesiredACCM = WanInfo.DesiredACCM;
        NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL,
            ("CO_GET_INFO: FrameSize %d SendWindow %d",
            WanInfo.MaxFrameSize, WanInfo.MaxSendWindow));
    } else {

        //
        // This guy will get default framing behaviour
        //
        OpenCB->WanInfo.FramingBits = PPP_FRAMING;
        OpenCB->WanInfo.DesiredACCM = 0;

        //
        // Find the send window
        //
        WanRequest.NdisRequest.RequestType =
            NdisRequestQueryInformation;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid =
            OID_GEN_MAXIMUM_SEND_PACKETS;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer =
            &GenericUlong;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(ULONG);

        Status = NdisWanSubmitNdisRequest(OpenCB, &WanRequest);

        OpenCB->WanInfo.MaxTransmit = (Status == NDIS_STATUS_SUCCESS &&
                                        GenericUlong > 0) ? GenericUlong : 10;

        //
        // Find the max transmit size
        //
        WanRequest.NdisRequest.RequestType =
            NdisRequestQueryInformation;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.Oid =
            OID_GEN_MAXIMUM_TOTAL_SIZE;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer =
            &GenericUlong;

        WanRequest.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(ULONG);

        Status = NdisWanSubmitNdisRequest(OpenCB, &WanRequest);

        OpenCB->WanInfo.MaxFrameSize = (Status == NDIS_STATUS_SUCCESS) ?
                                        GenericUlong : 1500;

    }

    OpenCB->WanInfo.Endpoints = 1000;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("ProtoCoAfRegisterNotify: Exit"));
}

NDIS_STATUS
DoNewLineUpToProtocol(
    PPROTOCOLCB ProtocolCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PMINIPORTCB MiniportCB;
    NDIS_STATUS Status;
    PBUNDLECB   BundleCB = ProtocolCB->BundleCB;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("DoNewLineupToProtocol: Enter"));

    do {

        NdisAcquireSpinLock(&MiniportCBList.Lock);

        //
        // Find the adapter that this lineup is for.  Look for the adapter
        // that has the appropriate protocoltype.  If it is NBF we need
        // to look for a specific adapter.
        //
        for (MiniportCB = (PMINIPORTCB)MiniportCBList.List.Flink;
            (PVOID)MiniportCB != (PVOID)&MiniportCBList.List;
            MiniportCB = (PMINIPORTCB)MiniportCB->Linkage.Flink) {

            if (MiniportCB->ProtocolType == ProtocolCB->ProtocolType) {

                if (ProtocolCB->ProtocolType != PROTOCOL_NBF) {
                    break;
                }

                //
                // Must be NBF so verify the AdapterName!!!
                //
                if (NdisEqualUnicodeString(&MiniportCB->AdapterName,&ProtocolCB->BindingName, FALSE)) {
                    break;
                }
            }
        }

        if ((PVOID)MiniportCB == (PVOID)&MiniportCBList.List) {
            //
            // The adapter was not found...
            //
            NdisWanDbgOut(DBG_FAILURE, DBG_PROTOCOL, ("Adapter not found!"));

            NdisReleaseSpinLock(&MiniportCBList.Lock);

            Status = NDISWAN_ERROR_NO_ROUTE;

            break;
        }

        ASSERT(MiniportCB->ProtocolType == ProtocolCB->ProtocolType);

        ETH_COPY_NETWORK_ADDRESS(ProtocolCB->NdisWanAddress, MiniportCB->NetworkAddress);

        FillNdisWanIndices(ProtocolCB->NdisWanAddress,
                           BundleCB->hBundleHandle,
                           ProtocolCB->ProtocolHandle);

        NdisZeroMemory(ProtocolCB->TransportAddress, 6);

        NdisAcquireSpinLock(&MiniportCB->Lock);

        InsertTailList(&MiniportCB->ProtocolCBList,
                       &ProtocolCB->MiniportLinkage);

        ProtocolCB->MiniportCB = MiniportCB;

        REF_MINIPORTCB(MiniportCB);

        NdisReleaseSpinLock(&MiniportCB->Lock);

        NdisReleaseSpinLock(&MiniportCBList.Lock);

        Status = DoLineUpToProtocol(ProtocolCB);

        if (Status != NDIS_STATUS_SUCCESS) {

            NdisAcquireSpinLock(&MiniportCBList.Lock);

            NdisAcquireSpinLock(&MiniportCB->Lock);

            RemoveEntryList(&ProtocolCB->MiniportLinkage);

            if (MiniportCB->Flags & HALT_IN_PROGRESS) {
                NdisWanSetSyncEvent(&MiniportCB->HaltEvent);
            }

            NdisReleaseSpinLock(&MiniportCB->Lock);

            NdisReleaseSpinLock(&MiniportCBList.Lock);

            DEREF_MINIPORTCB(MiniportCB);
        }

    } while (FALSE);

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("DoNewLineupToProtocols: Exit"));

    return (Status);
}

NDIS_STATUS
DoLineUpToProtocol(
    IN  PPROTOCOLCB ProtocolCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   AllocationSize;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PNDIS_WAN_LINE_UP LineUpInfo;
    PMINIPORTCB MiniportCB = ProtocolCB->MiniportCB;
    PBUNDLECB   BundleCB = ProtocolCB->BundleCB;
    KIRQL       OldIrql;

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("DoLineupToProtocol: Enter"));

    ASSERT(MiniportCB != NULL);

    AllocationSize = sizeof(NDIS_WAN_LINE_UP) +
                     ProtocolCB->ulLineUpInfoLength +
                     (sizeof(WCHAR) * (MAX_NAME_LENGTH + 1) +
                     (2 * sizeof(PVOID)));

    NdisWanAllocateMemory(&LineUpInfo, AllocationSize, LINEUPINFO_TAG);

    if (LineUpInfo != NULL) {
        ULONG LineUpHandle = ProtocolCB->ulTransportHandle;
        
        //
        // Needs to be in 1/100bps, we store in Bps
        //
        LineUpInfo->LinkSpeed = BundleCB->SFlowSpec.PeakBandwidth * 8 / 100;

        //
        // Set the MTU for this protocol
        //
        {
            POPENCB OpenCB = BundleCB->NextLinkToXmit->OpenCB;

            //
            // If this connection is running over a VPN we will downsize
            // the MTU
            //
            if ((OpenCB->MediumSubType == NdisWanMediumPPTP ||
                 OpenCB->MediumSubType == NdisWanMediumL2TP)) {
                LineUpInfo->MaximumTotalSize = ProtocolCB->TunnelMTU;
            } else {
                LineUpInfo->MaximumTotalSize = ProtocolCB->MTU;
            }

            if (LineUpInfo->MaximumTotalSize > BundleCB->SFlowSpec.MaxSduSize) {
                LineUpInfo->MaximumTotalSize = 
                    BundleCB->SFlowSpec.MaxSduSize;
            }

#if 0            
            //
            // Figure out the size of the ppp header...
            //
            BundleCB->FramingInfo.PPPHeaderLength = 
                CalcPPPHeaderLength(BundleCB->FramingInfo.SendFramingBits,
                                    BundleCB->SendFlags);

            if (LineUpInfo->MaximumTotalSize > BundleCB->FramingInfo.PPPHeaderLength) {
                LineUpInfo->MaximumTotalSize -= BundleCB->FramingInfo.PPPHeaderLength;
            } else {
                LineUpInfo->MaximumTotalSize = 0;
            }
#endif        
        }

        LineUpInfo->Quality = NdisWanReliable;
        LineUpInfo->SendWindow = (USHORT)BundleCB->SendWindow;
        LineUpInfo->ProtocolType = ProtocolCB->ProtocolType;
        LineUpInfo->DeviceName.Length = ProtocolCB->InDeviceName.Length;
        LineUpInfo->DeviceName.MaximumLength = MAX_NAME_LENGTH + 1;
        LineUpInfo->DeviceName.Buffer = (PWCHAR)((PUCHAR)LineUpInfo +
                                                 sizeof(NDIS_WAN_LINE_UP) + 
                                                 sizeof(PVOID));
        (ULONG_PTR)LineUpInfo->DeviceName.Buffer &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        if (ProtocolCB->InDeviceName.Length != 0) {

            NdisMoveMemory(LineUpInfo->DeviceName.Buffer,
                           ProtocolCB->InDeviceName.Buffer,
                           ProtocolCB->InDeviceName.Length);
        }


        LineUpInfo->ProtocolBuffer = (PUCHAR)LineUpInfo +
                                     sizeof(NDIS_WAN_LINE_UP) +
                                     (sizeof(WCHAR) * (MAX_NAME_LENGTH + 1) +
                                     sizeof(PVOID));
        (ULONG_PTR)LineUpInfo->ProtocolBuffer &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        //
        //
        // The Remote address (DEST address in a send) is what we use to
        // mutilplex sends across our single adapter/binding context.
        // The address has the following format:
        //
        // XX XX XX YY YY ZZ
        //
        // XX = Randomly generated OUI
        // YY = Index into the active bundle connection table to get bundlecb
        // ZZ = Index into the protocol table of a bundle to get protocolcb
        //
        ETH_COPY_NETWORK_ADDRESS(LineUpInfo->RemoteAddress,ProtocolCB->NdisWanAddress);
        ETH_COPY_NETWORK_ADDRESS(LineUpInfo->LocalAddress,ProtocolCB->TransportAddress);

        //
        // Fill in the protocol specific information
        //
        LineUpInfo->ProtocolBufferLength = ProtocolCB->ulLineUpInfoLength;
        if (ProtocolCB->ulLineUpInfoLength > 0) {
            NdisMoveMemory(LineUpInfo->ProtocolBuffer,
                           ProtocolCB->LineUpInfo,
                           ProtocolCB->ulLineUpInfoLength);
        }

//        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

        // DbgPrint("LineUp: %x, MTU %d\n",
        //    LineUpInfo->ProtocolType, LineUpInfo->MaximumTotalSize);

        //
        // Do the line up indication
        //
        NdisMIndicateStatus(MiniportCB->MiniportHandle,
                            NDIS_STATUS_WAN_LINE_UP,
                            LineUpInfo,
                            AllocationSize);

//        KeLowerIrql(OldIrql);

        //
        // Update protocol queue depth
        //
        {
            PROTOCOL_INFO   ProtocolInfo = {0};
            ULONG           ByteDepth;
            ULONG           i;

            AcquireBundleLock(BundleCB);

            ProtocolInfo.ProtocolType = ProtocolCB->ProtocolType;
            GetProtocolInfo(&ProtocolInfo);

            //
            // Set the send queue byte depth.
            //
            ByteDepth =
                ProtocolInfo.PacketQueueDepth;

            //
            // If the byte depth is less then 4
            // full packets, then set it to 4 full
            // packets.
            //
            if (ByteDepth < (ProtocolInfo.MTU * 4)) {
                ByteDepth = ProtocolInfo.MTU * 4;
            }

            for (i = 0; i <= MAX_MCML; i++) {
                ProtocolCB->PacketQueue[i].MaxByteDepth =
                    ByteDepth;
            }

            ReleaseBundleLock(BundleCB);
        }

        //
        // If this was the first line up for this protocolcb and
        // this lineup was answered we need to collect some info
        //
        if (ProtocolCB->ulTransportHandle == 0) {

            *((ULONG UNALIGNED *)(&LineUpHandle)) =
                *((ULONG UNALIGNED *)(&LineUpInfo->LocalAddress[2]));

            if (LineUpHandle != 0) {

                AcquireBundleLock(BundleCB);

                ETH_COPY_NETWORK_ADDRESS(ProtocolCB->TransportAddress, LineUpInfo->LocalAddress);

                ProtocolCB->ulTransportHandle = LineUpHandle;

                if (LineUpInfo->DeviceName.Length != 0) {
                    NdisWanStringToNdisString(&ProtocolCB->OutDeviceName,
                                              LineUpInfo->DeviceName.Buffer);
                }

                ReleaseBundleLock(BundleCB);

                //
                // If this is an nbf adapter
                //
                if (ProtocolCB->ProtocolType == (USHORT)PROTOCOL_NBF) {
        
                    ASSERT(MiniportCB->ProtocolType == (USHORT)PROTOCOL_NBF);
        
                    MiniportCB->NbfProtocolCB = ProtocolCB;
                }

            } else {
                Status = NDISWAN_ERROR_NO_ROUTE;
            }
        }

        NdisWanFreeMemory(LineUpInfo);

    } else {

        Status = NDIS_STATUS_RESOURCES;
    }

    NdisWanDbgOut(DBG_TRACE, DBG_PROTOCOL, ("DoLineupToProtocol: Exit"));

    return (Status);
}

NDIS_STATUS
DoLineDownToProtocol(
    PPROTOCOLCB ProtocolCB
    )
{
    NDIS_WAN_LINE_DOWN  WanLineDown;
    PNDIS_WAN_LINE_DOWN LineDownInfo = &WanLineDown;

    PMINIPORTCB         MiniportCB = ProtocolCB->MiniportCB;
    PBUNDLECB           BundleCB = ProtocolCB->BundleCB;

    KIRQL   OldIrql;

    //
    // The Remote address (DEST address) is what we use to mutilplex
    // sends across our single adapter/binding context.  The address
    // has the following format:
    //
    // XX XX YY YY YY YY
    //
    // XX = Randomly generated OUI
    // YY = ProtocolCB
    //
    ETH_COPY_NETWORK_ADDRESS(LineDownInfo->RemoteAddress, ProtocolCB->NdisWanAddress);
    ETH_COPY_NETWORK_ADDRESS(LineDownInfo->LocalAddress, ProtocolCB->TransportAddress);

    //
    // If this is an nbf adapter
    //
    if (ProtocolCB->ProtocolType == PROTOCOL_NBF) {

        MiniportCB->NbfProtocolCB = NULL;
    }

    ProtocolCB->ulTransportHandle = 0;
    ProtocolCB->State = PROTOCOL_UNROUTED;

    ReleaseBundleLock(BundleCB);

    NdisMIndicateStatus(MiniportCB->MiniportHandle,
                        NDIS_STATUS_WAN_LINE_DOWN,
                        LineDownInfo,
                        sizeof(NDIS_WAN_LINE_DOWN));

    NdisAcquireSpinLock(&MiniportCB->Lock);

    RemoveEntryList(&ProtocolCB->MiniportLinkage);

    if (MiniportCB->Flags & HALT_IN_PROGRESS) {
        NdisWanSetSyncEvent(&MiniportCB->HaltEvent);
    }

    NdisReleaseSpinLock(&MiniportCB->Lock);

    DEREF_MINIPORTCB(MiniportCB);

    AcquireBundleLock(BundleCB);

    return (NDIS_STATUS_SUCCESS);
}

VOID
CompleteSendDesc(
    PSEND_DESC  SendDesc,
    NDIS_STATUS Status
    )
{
    PLINKCB         LinkCB;
    PBUNDLECB       BundleCB;
    PPROTOCOLCB     ProtocolCB;
    PNDIS_PACKET    OriginalPacket;
    BOOLEAN         FreeLink = FALSE, FreeBundle = FALSE;
    BOOLEAN         LegacyLink;
    PULONG          pulRefCount;
    PCM_VCCB        CmVcCB;
    INT             Class;
    ULONG           DescFlags;

    LinkCB = SendDesc->LinkCB;
    ProtocolCB = SendDesc->ProtocolCB;
    OriginalPacket = SendDesc->OriginalPacket;
    Class = SendDesc->Class;
    DescFlags = SendDesc->Flags;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND,
        ("SendDesc: 0x%p, OriginalPacket: 0x%p, Status: %x",
        SendDesc, OriginalPacket, Status));

    NdisWanFreeSendDesc(SendDesc);

    //
    // Bundle that this link is on
    //
    BundleCB = LinkCB->BundleCB;

    //
    // Deref for the ref applied when a senddesc
    // was retrieved for this link. We don't need to do
    // the full deref here because we are keeping the
    // link from going away with the ref applied when
    // we got the sendcomplete.
    //
    --LinkCB->RefCount;

#ifdef DBG_SENDARRAY
{
    SendArray[__si] = 'c';
    if (++__si == MAX_BYTE_DEPTH) {
        __si = 0;
    }
}
#endif

    NdisReleaseSpinLock(&LinkCB->Lock);

    AcquireBundleLock(BundleCB);

    LegacyLink = (LinkCB->OpenCB->Flags & OPEN_LEGACY) ? 1 : 0;

    //
    // If the sendwindow is currently full, this completion
    // opens the sendwindow.
    //
    if (LinkCB->OutstandingFrames == LinkCB->SendWindow) {
        LinkCB->SendWindowOpen = TRUE;
        if (LinkCB->LinkActive) {
            BundleCB->SendingLinks++;
        }
    }

    LinkCB->OutstandingFrames--;

    if (DescFlags & SEND_DESC_FRAG) {
        InterlockedDecrement(&ProtocolCB->PacketQueue[Class].OutstandingFrags);
    }

    pulRefCount =
        &(PMINIPORT_RESERVED_FROM_NDIS(OriginalPacket)->RefCount);

    ASSERT(*pulRefCount > 0);

    //
    // See if the reference count is zero, if it is not
    // we just return.
    //
    if (InterlockedDecrement(pulRefCount) != 0) {

        SendPacketOnBundle(BundleCB);

        return;
    }

    ReleaseBundleLock(BundleCB);

    //
    // Complete this NdisPacket back to the transport
    //
    NDIS_SET_PACKET_STATUS(OriginalPacket, Status);
    CompleteNdisPacket(ProtocolCB->MiniportCB,
                       ProtocolCB,
                       OriginalPacket);

    AcquireBundleLock(BundleCB);

    BundleCB->OutstandingFrames--;

    if ((BundleCB->Flags & FRAMES_PENDING_EVENT) &&
        (BundleCB->OutstandingFrames == 0)) {

        NdisWanSetSyncEvent(&BundleCB->OutstandingFramesEvent);
    }

    //
    // Called with bundle lock help but returns with lock released
    //
    SendPacketOnBundle(BundleCB);

    //
    // Deref for ref applied when sent a packet to be framed.
    //
    DEREF_BUNDLECB(BundleCB);
}

#if 0
ULONG
CalcPPPHeaderLength(
    ULONG   FramingBits,
    ULONG   Flags
    )
{
    ULONG   HeaderLength = 0;

    if (FramingBits & PPP_FRAMING) {

        if (!(FramingBits & PPP_COMPRESS_ADDRESS_CONTROL)) {
            //
            // If there is no address/control compression
            // we need a pointer and a length
            //

            if (FramingBits & LLC_ENCAPSULATION) {
                HeaderLength += 4;
            } else {
                HeaderLength += 2;
            }
        }

        //
        // If this is not from our private I/O interface we will
        // build the rest of the header.
        //
        if (FramingBits & PPP_MULTILINK_FRAMING) {

            if (!(FramingBits & PPP_COMPRESS_PROTOCOL_FIELD)) {
                //
                // No protocol compression
                //
                HeaderLength += 1;
            }

            HeaderLength += 1;

            if (!(FramingBits & PPP_SHORT_SEQUENCE_HDR_FORMAT)) {
                //
                // We are using long sequence number
                //
                HeaderLength += 2;
            }

            HeaderLength += 2;
        }

        if (Flags & (DO_COMPRESSION | DO_ENCRYPTION)) {
            //
            // We are doing compression/encryption so we need
            // a length
            //

            //
            // It appears that legacy ras (< NT 4.0) requires that
            // the PPP protocol field in a compressed packet not
            // be compressed, ie has to have the leading 0x00
            //
            if (!(FramingBits & PPP_COMPRESS_PROTOCOL_FIELD)) {
                //
                // No protocol compression
                //
                HeaderLength += 1;
            }

            //
            // Add protocol and coherency bytes
            //
            HeaderLength += 3;
        }


        if (!(FramingBits & PPP_COMPRESS_PROTOCOL_FIELD) ||
            (Flags & (DO_COMPRESSION | DO_ENCRYPTION))) {
            HeaderLength += 1;
        }

        HeaderLength += 1;

    } else if (FramingBits & RAS_FRAMING) {
        //
        // If this is old ras framing:
        //
        // Alter the framing so that 0xFF 0x03 is not added
        // and that the first byte is 0xFD not 0x00 0xFD
        //
        // So basically, a RAS compression looks like
        // <0xFD> <2 BYTE COHERENCY> <NBF DATA FIELD>
        //
        // Whereas uncompressed looks like
        // <NBF DATA FIELD> which always starts with 0xF0
        //
        // If this is ppp framing:
        //
        // A compressed frame will look like (before address/control
        // - multilink is added)
        // <0x00> <0xFD> <2 Byte Coherency> <Compressed Data>
        //
        if (Flags & (DO_COMPRESSION | DO_ENCRYPTION)) {

            //
            // Coherency bytes
            //
            HeaderLength += 3;
        }
    }

    // DbgPrint("PPPHeaderLength %d\n", HeaderLength);

    return (HeaderLength);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\request.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Request.c

Abstract:


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe  06/06/95    Created

--*/

#include "wan.h"

#define __FILE_SIG__    REQUEST_FILESIG

static UINT CoSupportedOids[] =
{
    OID_GEN_CO_SUPPORTED_LIST,
    OID_GEN_CO_HARDWARE_STATUS,
    OID_GEN_CO_MEDIA_SUPPORTED,
    OID_GEN_CO_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_CO_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_CO_VENDOR_ID,
    OID_GEN_CO_VENDOR_DESCRIPTION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_CO_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_CO_PROTOCOL_OPTIONS,
    OID_GEN_CO_MAC_OPTIONS,
    OID_GEN_CO_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_CO_VENDOR_DRIVER_VERSION,
    OID_GEN_CO_MINIMUM_LINK_SPEED,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_WAN_PERMANENT_ADDRESS,
    OID_WAN_CURRENT_ADDRESS,
    OID_WAN_QUALITY_OF_SERVICE,
    OID_WAN_MEDIUM_SUBTYPE,
    OID_WAN_PROTOCOL_TYPE,
    OID_WAN_HEADER_FORMAT,
    OID_WAN_LINE_COUNT,
    OID_QOS_ISSLOW_FRAGMENT_SIZE
};

NDIS_STATUS
NdisWanCoOidProc(
    IN  PMINIPORTCB         pMiniportCB,
    IN  PCM_VCCB            CmVcCB OPTIONAL,
    IN OUT PNDIS_REQUEST    NdisRequest
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    NDIS_MEDIUM MediumType;
    ULONG       GenericULong = 0, i;
    USHORT      GenericUShort = 0;
    UCHAR       GenericArray[6];
    PVOID       MoveSource = (PVOID)&GenericULong;
    ULONG       MoveBytes = sizeof(ULONG);
    NDIS_HARDWARE_STATUS    HardwareStatus;
    ULONG       Filter = 0, Oid, OidCat;
    ULONG       InformationBufferLength;
    PUCHAR      InformationBuffer;
    PROTOCOL_INFO   ProtocolInfo = {0};


    Oid = NdisRequest->DATA.QUERY_INFORMATION.Oid;
    OidCat = Oid & 0xFF000000;
    InformationBufferLength =
        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength;
    InformationBuffer =
        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;

    NdisAcquireSpinLock(&pMiniportCB->Lock);

    //
    // We will break the OID's down into smaller categories
    //
    switch (OidCat) {

        //
        // Swith on General Oid's
        //
        case OID_CO_GEN:
            switch (Oid) {
                case OID_GEN_CO_SUPPORTED_LIST:
                    MoveSource = (PVOID)CoSupportedOids;
                    MoveBytes = sizeof(CoSupportedOids);
                    break;

                case OID_GEN_CO_HARDWARE_STATUS:
                    HardwareStatus = pMiniportCB->HardwareStatus;
                    MoveSource = (PVOID)&HardwareStatus;
                    MoveBytes = sizeof(HardwareStatus);
                    break;

                case OID_GEN_CO_MEDIA_SUPPORTED:
                case OID_GEN_CO_MEDIA_IN_USE:
                    MediumType = pMiniportCB->MediumType;
                    MoveSource = (PVOID)&MediumType;
                    MoveBytes = sizeof(MediumType);
                    break;

                case OID_GEN_MAXIMUM_LOOKAHEAD:
                case OID_GEN_CURRENT_LOOKAHEAD:
                    GenericULong = glMRRU;
                    break;
    
                case OID_GEN_MAXIMUM_FRAME_SIZE:
                    ProtocolInfo.ProtocolType = pMiniportCB->ProtocolType;
                    GetProtocolInfo(&ProtocolInfo);
                    GenericULong =
                        (ProtocolInfo.MTU == 0) ? glMaxMTU : ProtocolInfo.MTU;
                    break;

                case OID_GEN_MAXIMUM_TOTAL_SIZE:
                    ProtocolInfo.ProtocolType = pMiniportCB->ProtocolType;
                    GetProtocolInfo(&ProtocolInfo);
                    GenericULong =
                        (ProtocolInfo.MTU == 0) ? glMaxMTU : ProtocolInfo.MTU;
                    GenericULong += 14;
                    break;

                case OID_GEN_CO_LINK_SPEED:
                    //
                    // Who knows what the initial link speed is?
                    // This should not be called, right?
                    //
                    GenericULong = (ULONG)288;
                    break;

                case OID_GEN_TRANSMIT_BUFFER_SPACE:
                case OID_GEN_RECEIVE_BUFFER_SPACE:
                    ProtocolInfo.ProtocolType = pMiniportCB->ProtocolType;
                    GetProtocolInfo(&ProtocolInfo);
                    GenericULong =
                        (ProtocolInfo.MTU == 0) ?
                        (ULONG)(glMaxMTU * MAX_OUTSTANDING_PACKETS) :
                        (ULONG)(ProtocolInfo.MTU * MAX_OUTSTANDING_PACKETS);
                    break;
    
                case OID_GEN_TRANSMIT_BLOCK_SIZE:
                    ProtocolInfo.ProtocolType = pMiniportCB->ProtocolType;
                    GetProtocolInfo(&ProtocolInfo);
                    GenericULong =
                        (ProtocolInfo.MTU == 0) ? glMaxMTU : ProtocolInfo.MTU;
                    break;
    
                case OID_GEN_RECEIVE_BLOCK_SIZE:
                    GenericULong = glMRRU;
                    break;

                case OID_GEN_CO_VENDOR_ID:
                    GenericULong = 0xFFFFFFFF;
                    MoveBytes = 3;
                    break;

                case OID_GEN_CO_VENDOR_DESCRIPTION:
                    MoveSource = (PVOID)"NdisWan Adapter";
                    MoveBytes = 16;
                    break;

                case OID_GEN_CURRENT_PACKET_FILTER:
                    if (NdisRequest->RequestType == NdisRequestSetInformation) {
                        if (InformationBufferLength > 3) {
                            NdisMoveMemory(&Filter, InformationBuffer, 4);
    
                            NdisAcquireSpinLock(&NdisWanCB.Lock);
                            if (Filter &
                                (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) {
                                NdisWanCB.PromiscuousAdapter = pMiniportCB;
                            } else if (NdisWanCB.PromiscuousAdapter == pMiniportCB) {
                                NdisWanCB.PromiscuousAdapter = NULL;
                            }
    
                            NdisReleaseSpinLock(&NdisWanCB.Lock);

                        } else {
                            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                            NdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
                            NdisRequest->DATA.SET_INFORMATION.BytesNeeded = 4;
                        }
                    }
                    break;

                case OID_GEN_CO_DRIVER_VERSION:
                    GenericUShort = 0x0500;
                    MoveSource = (PVOID)&GenericUShort;
                    MoveBytes = sizeof(USHORT);
                    break;

                case OID_GEN_CO_MAC_OPTIONS:
                    GenericULong = (ULONG)(NDIS_MAC_OPTION_RECEIVE_SERIALIZED |
                                           NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                                           NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA |
                                           NDIS_MAC_OPTION_RESERVED |
                                           NDIS_MAC_OPTION_NDISWAN);
                    break;

                case OID_GEN_CO_MEDIA_CONNECT_STATUS:
                    GenericULong = (ULONG)NdisMediaStateConnected;
                    break;

                case OID_GEN_CO_XMIT_PDUS_OK:
                    //
                    // 
                    //
                    break;

                case OID_GEN_CO_RCV_PDUS_OK:
                    //
                    // 
                    //
                    break;

                case OID_GEN_CO_XMIT_PDUS_ERROR:
                    //
                    // 
                    //
                    break;

                case OID_GEN_CO_RCV_PDUS_ERROR:
                    //
                    // 
                    //
                    break;

                case OID_GEN_CO_RCV_PDUS_NO_BUFFER:
                    //
                    // 
                    //
                    break;

                case OID_GEN_CO_TRANSMIT_QUEUE_LENGTH:
                    //
                    // 
                    //
                    break;

                default:
                    Status = NDIS_STATUS_INVALID_OID;
                    break;
            }
            break;

        //
        // Switch on ethernet media specific Oid's
        //
        case OID_802_3:
            switch (Oid) {
                case OID_802_3_PERMANENT_ADDRESS:
                case OID_802_3_CURRENT_ADDRESS:
                    ETH_COPY_NETWORK_ADDRESS(GenericArray, pMiniportCB->NetworkAddress);
                    MoveSource = (PVOID)GenericArray;
                    MoveBytes = ETH_LENGTH_OF_ADDRESS;
                    break;

                case OID_802_3_MULTICAST_LIST:
                    MoveBytes = 0;
                    break;

                case OID_802_3_MAXIMUM_LIST_SIZE:
                    GenericULong = 1;
                    break;

                default:
                    Status = NDIS_STATUS_INVALID_OID;
                    break;
            }
            break;

        //
        // Switch on WAN specific Oid's
        //
        case OID_WAN:
            switch (Oid) {
                case OID_WAN_PERMANENT_ADDRESS:
                case OID_WAN_CURRENT_ADDRESS:
                    ETH_COPY_NETWORK_ADDRESS(GenericArray, pMiniportCB->NetworkAddress);
                    MoveSource = (PVOID)GenericArray;
                    MoveBytes = ETH_LENGTH_OF_ADDRESS;
                    break;

                case OID_WAN_QUALITY_OF_SERVICE:
                    GenericULong = NdisWanReliable;
                    break;

                case OID_WAN_MEDIUM_SUBTYPE:
                    GenericULong = NdisWanMediumHub;
                    break;

                case OID_WAN_PROTOCOL_TYPE:
                    {
                        PMINIPORTCB mcb;
                        BOOLEAN     Found = FALSE;

                        if (InformationBufferLength > 5) {

                            pMiniportCB->ProtocolType =
                            (((PUCHAR)InformationBuffer)[4] << 8) |
                            ((PUCHAR)InformationBuffer)[5];

                            pMiniportCB->NumberofProtocols++;
                            MoveBytes = 6;

                            NdisReleaseSpinLock(&pMiniportCB->Lock);
                            //
                            // Walk the miniportcb list and see if this is the only
                            // instance of this protocol.  If it is we need to notify
                            // user-mode that a new protocol is available.
                            //
                            NdisAcquireSpinLock(&MiniportCBList.Lock);

                            mcb = (PMINIPORTCB)MiniportCBList.List.Flink;

                            while ((PVOID)mcb != (PVOID)&MiniportCBList.List) {
                                if (mcb != pMiniportCB) {

                                    if (mcb->ProtocolType ==
                                        pMiniportCB->ProtocolType) {
                                        Found = TRUE;
                                    }
                                }

                                mcb = (PMINIPORTCB)mcb->Linkage.Flink;
                            }

                            NdisReleaseSpinLock(&MiniportCBList.Lock);

                            if (Found == FALSE) {
                                PROTOCOL_INFO   pinfo;

                                NdisZeroMemory(&pinfo, sizeof(pinfo));
                                pinfo.ProtocolType = pMiniportCB->ProtocolType;
                                pinfo.Flags = PROTOCOL_BOUND;
                                SetProtocolInfo(&pinfo);
                            }

                            NdisAcquireSpinLock(&pMiniportCB->Lock);

                        } else {
                            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                            NdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
                            NdisRequest->DATA.SET_INFORMATION.BytesNeeded = 6;
                        }
                    }
                    break;

                case OID_WAN_HEADER_FORMAT:
                    GenericULong = NdisWanHeaderEthernet;
                    break;

                case OID_WAN_LINE_COUNT:
                    GenericULong = NdisWanCB.NumberOfLinks;
                    break;

                case OID_WAN_PROTOCOL_CAPS:
                    do {
                        PNDIS_WAN_PROTOCOL_CAPS pcaps;

                        if (InformationBufferLength < sizeof(NDIS_WAN_PROTOCOL_CAPS)) {
                            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                            NdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
                            NdisRequest->DATA.SET_INFORMATION.BytesNeeded =
                                sizeof(NDIS_WAN_PROTOCOL_CAPS);
                            break;
                        }

                        pcaps = (PNDIS_WAN_PROTOCOL_CAPS)InformationBuffer;

                        if (pcaps->Flags & WAN_PROTOCOL_KEEPS_STATS) {
                            pMiniportCB->Flags |= PROTOCOL_KEEPS_STATS;
                        }

                        MoveBytes = sizeof(NDIS_WAN_PROTOCOL_CAPS);

                    } while (FALSE);
                    break;

                default:
                    Status = NDIS_STATUS_INVALID_OID;
                    break;
            }
            break;

        case OID_PNP:
            switch (Oid) {
            case OID_PNP_CAPABILITIES:
                break;
            case OID_PNP_SET_POWER:
                break;
            case OID_PNP_QUERY_POWER:
                break;
            case OID_PNP_ENABLE_WAKE_UP:
                break;
            default:
                Status = NDIS_STATUS_INVALID_OID;
                break;
            }
            break;

        case OID_QOS:
            switch (Oid) {
                case OID_QOS_ISSLOW_FRAGMENT_SIZE:

                    do {
                        PBUNDLECB   BundleCB;
                        PSEND_FRAG_INFO FragInfo;

                        if (InformationBufferLength < 4) {
                            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                            NdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
                            NdisRequest->DATA.SET_INFORMATION.BytesNeeded = 4;
                            break;
                        }

                        if (((PLONG)InformationBuffer)[0] < 0) {
                            Status = NDIS_STATUS_INVALID_DATA;
                            NdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
                            NdisRequest->DATA.SET_INFORMATION.BytesNeeded = 4;
                            break;
                        }

                        if (((PULONG)InformationBuffer)[0] == 0) {
                            Status = NDIS_STATUS_INVALID_DATA;
                            NdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
                            NdisRequest->DATA.SET_INFORMATION.BytesNeeded = 4;
                            break;
                        }

                        if (CmVcCB == NULL) {

                            if (((PULONG)InformationBuffer)[0] < glMaxFragSize) {
                                glMaxFragSize = ((PULONG)InformationBuffer)[0];
                            }

                            if (glMaxFragSize < glMinFragSize) {
                                glMinFragSize = glMaxFragSize;
                            }

                        } else {
                            BundleCB = CmVcCB->ProtocolCB->BundleCB;

                            AcquireBundleLock(BundleCB);

                            FragInfo = &BundleCB->SendFragInfo[0];

                            if (((PULONG)InformationBuffer)[0] < FragInfo->MaxFragSize) {

                                FragInfo->MaxFragSize =
                                    ((PULONG)InformationBuffer)[0];
                            }

                            if (FragInfo->MaxFragSize < glMinFragSize) {
                                FragInfo->MaxFragSize = glMinFragSize;
                            }

                            if (FragInfo->MaxFragSize > glMaxFragSize) {
                                FragInfo->MaxFragSize = glMaxFragSize;
                            }

                            ReleaseBundleLock(BundleCB);

                        }


                        MoveBytes = 4;

                    } while (FALSE);

                    break;

                default:
                    Status = NDIS_STATUS_INVALID_OID;
                    break;
            }
            break;

        default:
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    if (Status == NDIS_STATUS_SUCCESS) {

        if (NdisRequest->RequestType == NdisRequestSetInformation) {
            NdisRequest->DATA.SET_INFORMATION.BytesRead = MoveBytes;
        } else if (NdisRequest->RequestType == NdisRequestQueryInformation ||
                   NdisRequest->RequestType == NdisRequestQueryStatistics) {
            
            if (MoveBytes > InformationBufferLength) {
    
                //
                // Not enough room in the information buffer
                //
                NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded =
                    MoveBytes;
    
                Status = NDIS_STATUS_INVALID_LENGTH;
    
            } else {
    
                NdisRequest->DATA.QUERY_INFORMATION.BytesWritten =
                    MoveBytes;
    
                NdisMoveMemory(InformationBuffer,
                               MoveSource,
                               MoveBytes);
            }
        } else {
            Status = NDIS_STATUS_INVALID_OID;
        }
    }

    NdisReleaseSpinLock(&pMiniportCB->Lock);

    return (Status);
}

NDIS_STATUS
NdisWanSubmitNdisRequest(
    IN  POPENCB         pOpenCB,
    IN  PWAN_REQUEST    WanRequest
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status;
    BOOLEAN     SyncRequest;
    BOOLEAN     fNdisTapi = !!(WanRequest->Origin == NDISTAPI);

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, ("SubmitNdisRequest: Enter - WanRequest %p", WanRequest));

    //
    // If the request is coming from ndistapi the opencb is already 
    // referenced and check for closing already made
    // 
    if(!fNdisTapi)
    {
        NdisAcquireSpinLock(&pOpenCB->Lock);

        if (pOpenCB->Flags & OPEN_CLOSING) {

            NdisReleaseSpinLock(&pOpenCB->Lock);

            return (NDIS_STATUS_FAILURE);
        }

        REF_OPENCB(pOpenCB);

        NdisReleaseSpinLock(&pOpenCB->Lock);
    }

    SyncRequest = (WanRequest->Type == SYNC);

    if (pOpenCB->Flags & OPEN_LEGACY ||
        WanRequest->VcHandle == NULL) {
        NdisRequest(&Status,
                    pOpenCB->BindingHandle,
                    &WanRequest->NdisRequest);
    } else {
        Status =
        NdisCoRequest(pOpenCB->BindingHandle,
                      WanRequest->AfHandle,
                      WanRequest->VcHandle,
                      NULL,
                      &WanRequest->NdisRequest);
    }

    //
    // We will only wait for request that are to complete
    // synchronously with respect to this function.  We will
    // wait here for completion.
    //
    if ((SyncRequest == TRUE) &&
        (Status == NDIS_STATUS_PENDING)) {

        NdisWanWaitForNotificationEvent(&WanRequest->NotificationEvent);

        Status = WanRequest->NotificationStatus;

        NdisWanClearNotificationEvent(&WanRequest->NotificationEvent);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_REQUEST, 
                  ("SubmitNdisRequest: Exit Status 0x%x", Status));

    if(!fNdisTapi)
    {
        DEREF_OPENCB(pOpenCB);
    }

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\sources.inc ===
SOURCES_USED=..\sources.inc
TARGETTYPE=DRIVER

C_DEFINES=$(C_DEFINES) -DNT -DNDIS50 -DNDIS50_MINIPORT -D_WAN50_ \
    -DNDIS_MINIPORT_DRIVER -DBINARY_COMPATIBLE=0 -D_PNP_POWER_ \
    -DUSE_RW_CONNTBLLOCK -DEAP_ON
    
PRECOMPILED_INCLUDE=..\wan.h
PRECOMPILED_PCH=wan.pch
PRECOMPILED_OBJ=wan.obj

TARGETLIBS=\
    $(DDK_LIB_PATH)\ndis.lib \
    $(DS_LIB_PATH)\rsa32.lib \
    ..\..\ndistapi\$(O)\ndistapi.lib

INCLUDES=..;..\..\inc;..\..\..\inc;$(DS_INC_PATH)\crypto

SOURCES=\
    ..\ccp.c \
    ..\cl.c \
    ..\cm.c \
    ..\compress.c \
    ..\indicate.c \
    ..\init.c \
    ..\io.c \
    ..\loopback.c \
    ..\memory.c \
    ..\miniport.c \
    ..\ndiswan.rc \
    ..\protocol.c \
    ..\receive.c \
    ..\request.c \
    ..\send.c \
    ..\tapi.c \
    ..\util.c \
    ..\vjslip.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\receive.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Receive.c

Abstract:

    This file contains the procedures for handling a receive indication from
    a Wan Miniport link, bound to the lower interface of NdisWan, and passing
    the data on to a protocol, bound to the upper interface of NdisWan.  The
    upper interface of NdisWan conforms to the NDIS 3.1 Miniport specification.
    The lower interface of NdisWan conforms to the NDIS 3.1 Extentions for
    Wan Miniport drivers.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe  06/06/95    Created

--*/

#include "wan.h"

#define __FILE_SIG__    RECEIVE_FILESIG

VOID
DoMultilinkProcessing(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

VOID
UpdateMinRecvSeqNumber(
    PBUNDLECB   BundleCB,
    UINT        Class
    );

VOID
TryToAssembleFrame(
    PBUNDLECB   BundleCB,
    UINT        Class
    );

NDIS_STATUS
ProcessPPPFrame(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    );

NDIS_STATUS
IndicateRecvPacket(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    );

BOOLEAN
DoVJDecompression(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    );

BOOLEAN
DoDecompDecryptProcessing(
    PBUNDLECB   BundleCB,
    PUCHAR      *DataPointer,
    PLONG       DataLength
    );

VOID
DoCompressionReset(
    PBUNDLECB   BundleCB
    );

VOID
FlushRecvDescWindow(
    PBUNDLECB   BundleCB,
    UINT        Class
    );

VOID
FindHoleInRecvList(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc,
    UINT        Class
    );

BOOLEAN
GetProtocolFromPPPId(
    PBUNDLECB   BundleCB,
    USHORT      Id,
    PPROTOCOLCB *ProtocolCB
    );

#ifdef NT

NDIS_STATUS
CompleteIoRecvPacket(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    );

#endif

NDIS_STATUS
DetectBroadbandFraming(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    PUCHAR      FramePointer;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("DetectFraming: Enter"));

    FramePointer = RecvDesc->CurrentBuffer;

    if (*FramePointer == 0xFE && *(FramePointer + 1) == 0xFE &&
        *(FramePointer + 2) == 0x03 && *(FramePointer + 3) == 0xCF) {
            LinkCB->LinkInfo.RecvFramingBits =
            LinkCB->LinkInfo.SendFramingBits =
                PPP_FRAMING | LLC_ENCAPSULATION;

            LinkCB->RecvHandler = ReceiveLLC;

    } else {

        LinkCB->LinkInfo.RecvFramingBits =
        LinkCB->LinkInfo.SendFramingBits = 
            PPP_FRAMING | PPP_COMPRESS_ADDRESS_CONTROL;

        LinkCB->RecvHandler = ReceivePPP;
    }

    Status = (*LinkCB->RecvHandler)(LinkCB, RecvDesc);

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("DetectFraming: Exit Status %x",Status));

    return (Status);
}


NDIS_STATUS
DetectFraming(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    PUCHAR      FramePointer;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("DetectFraming: Enter"));

    ASSERT(LinkCB->LinkInfo.RecvFramingBits == 0x00);

    FramePointer = RecvDesc->CurrentBuffer;

    //
    // If we are in framing detect mode figure it out
    //
    if (LinkCB->LinkInfo.RecvFramingBits == 0 ||
        LinkCB->LinkInfo.SendFramingBits == 0) {

        if (*FramePointer == 0xFF && *(FramePointer + 1) == 0x03) {
            LinkCB->LinkInfo.RecvFramingBits =
            LinkCB->LinkInfo.SendFramingBits = PPP_FRAMING;
            LinkCB->RecvHandler = ReceivePPP;
        } else if (*FramePointer == 0x01 && *(FramePointer + 1) == 0x1B &&
                   *(FramePointer + 2) == 0x02){
            LinkCB->LinkInfo.RecvFramingBits =
            LinkCB->LinkInfo.SendFramingBits = ARAP_V2_FRAMING;
            LinkCB->RecvHandler = ReceiveARAP;
        } else if (*FramePointer == 0x16 && *(FramePointer + 1) == 0x10 &&
                   *(FramePointer + 2) == 0x02){
            LinkCB->LinkInfo.RecvFramingBits =
            LinkCB->LinkInfo.SendFramingBits = ARAP_V1_FRAMING;
            LinkCB->RecvHandler = ReceiveARAP;
        } else if (*FramePointer == 0xFE && *(FramePointer + 1) == 0xFE &&
                   *(FramePointer + 2) == 0x03 &&
                   *(FramePointer + 3) == 0xCF) {
            LinkCB->LinkInfo.RecvFramingBits =
            LinkCB->LinkInfo.SendFramingBits =
                PPP_FRAMING | LLC_ENCAPSULATION;
            LinkCB->RecvHandler = ReceiveLLC;
        } else {
            LinkCB->LinkInfo.RecvFramingBits =
            LinkCB->LinkInfo.SendFramingBits = RAS_FRAMING;
            LinkCB->RecvHandler = ReceiveRAS;
        }

        if (BundleCB->FramingInfo.RecvFramingBits == 0x00) {

            if (LinkCB->LinkInfo.RecvFramingBits & PPP_FRAMING) {
                BundleCB->FramingInfo.RecvFramingBits =
                BundleCB->FramingInfo.SendFramingBits = PPP_FRAMING;
            } else if (LinkCB->LinkInfo.RecvFramingBits & ARAP_V1_FRAMING) {
                BundleCB->FramingInfo.RecvFramingBits =
                BundleCB->FramingInfo.SendFramingBits = ARAP_V1_FRAMING;
            } else if (LinkCB->LinkInfo.RecvFramingBits & ARAP_V2_FRAMING) {
                BundleCB->FramingInfo.RecvFramingBits =
                BundleCB->FramingInfo.SendFramingBits = ARAP_V2_FRAMING;
            } else if (LinkCB->LinkInfo.RecvFramingBits & RAS_FRAMING) {
                BundleCB->FramingInfo.RecvFramingBits =
                BundleCB->FramingInfo.SendFramingBits = RAS_FRAMING;
            } else {
                NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE,
                    ("DetectFraming Failed! 0x%2.2x 0x%2.2x 0x%2.2x",
                    FramePointer[0], FramePointer[1], FramePointer[2]));
                return (NDIS_STATUS_SUCCESS);
            }
        }

    } else {
        NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE,
            ("FramingBits set but still in detect 0x%x 0x%x",
            LinkCB->LinkInfo.RecvFramingBits,
            LinkCB->LinkInfo.SendFramingBits));
        return (NDIS_STATUS_SUCCESS);
    }

    Status = (*LinkCB->RecvHandler)(LinkCB, RecvDesc);

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("DetectFraming: Exit Status %x",Status));

    return (Status);
}

NDIS_STATUS
ReceivePPP(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    PBUNDLECB       BundleCB = LinkCB->BundleCB;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PUCHAR          FramePointer = RecvDesc->CurrentBuffer;
    LONG            FrameLength = RecvDesc->CurrentLength;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceivePPP: Enter"));

    //
    // Remove the address/control part of the PPP header
    //
    if (*FramePointer == 0xFF) {
        FramePointer += 2;
        FrameLength -= 2;
    }

    if (FrameLength <= 0) {
        Status = NDIS_STATUS_FAILURE;
        goto RECEIVE_PPP_EXIT;
    }

    //
    // If multilink framing is set and this is a multilink frame
    // send to the multilink processor!
    //
    if ((LinkCB->LinkInfo.RecvFramingBits & PPP_MULTILINK_FRAMING) &&
        ((*FramePointer == 0x3D) ||
         (*FramePointer == 0x00) && (*(FramePointer + 1) == 0x3D)) ) {

        //
        // Remove multilink protocol id
        //
        if (*FramePointer & 1) {
            FramePointer++;
            FrameLength--;
        } else {
            FramePointer += 2;
            FrameLength -= 2;
        }

        if (FrameLength <= 0) {
            Status = NDIS_STATUS_FAILURE;
            goto RECEIVE_PPP_EXIT;
        }

        RecvDesc->CurrentBuffer = FramePointer;
        RecvDesc->CurrentLength = FrameLength;

        DoMultilinkProcessing(LinkCB, RecvDesc);

        Status = NDIS_STATUS_PENDING;

        goto RECEIVE_PPP_EXIT;
    }

    RecvDesc->CurrentBuffer = FramePointer;
    RecvDesc->CurrentLength = FrameLength;

    Status = ProcessPPPFrame(BundleCB, RecvDesc);

RECEIVE_PPP_EXIT:

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceivePPP: Exit Status %x", Status));

    return (Status);
}

NDIS_STATUS
ReceiveSLIP(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    PBUNDLECB       BundleCB = LinkCB->BundleCB;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PUCHAR          FramePointer = RecvDesc->CurrentBuffer;
    ULONG           FrameLength = RecvDesc->CurrentLength;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveSLIP: Enter"));

    ASSERT(BundleCB->FramingInfo.RecvFramingBits & SLIP_FRAMING);

    BundleCB->Stats.FramesReceived++;


    if (!DoVJDecompression(BundleCB,    // Bundle
                           RecvDesc)) { // RecvDesc

        goto RECEIVE_SLIP_EXIT;
    }

    Status = IndicateRecvPacket(BundleCB, RecvDesc);

RECEIVE_SLIP_EXIT:

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveSLIP: Exit Status %x", Status));

    return (Status);
}

NDIS_STATUS
ReceiveRAS(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    PBUNDLECB       BundleCB = LinkCB->BundleCB;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PUCHAR          FramePointer = RecvDesc->CurrentBuffer;
    LONG            FrameLength = RecvDesc->CurrentLength;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveRAS: Enter"));

    ASSERT(BundleCB->FramingInfo.RecvFramingBits & RAS_FRAMING);

    BundleCB->Stats.FramesReceived++;

    // For normal NBF frames, first byte is always the DSAP
    // i.e 0xF0 followed by SSAP 0xF0 or 0xF1
    //
    //
    if (*FramePointer == 14) {

        //
        // Compression reset!
        //
        DoCompressionReset(BundleCB);

        goto RECEIVE_RAS_EXIT;
    }

    if (*FramePointer == 0xFD) {

        //
        // Skip over 0xFD
        //
        FramePointer++;
        FrameLength--;

        //
        // Decompress as if an NBF PPP Packet
        //
        if (!DoDecompDecryptProcessing(BundleCB,
                                       &FramePointer,
                                       &FrameLength)){

            //
            // There was an error get out!
            //
            goto RECEIVE_RAS_EXIT;
        }
    }

    //
    // Make frame look like an NBF PPP packet
    //
    RecvDesc->ProtocolID = PPP_PROTOCOL_NBF;
    RecvDesc->CurrentLength = FrameLength;
    RecvDesc->CurrentBuffer = FramePointer;

    Status = IndicateRecvPacket(BundleCB, RecvDesc);

RECEIVE_RAS_EXIT:

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveRAS: Exit Status %x",Status));

    return (Status);
}

NDIS_STATUS
ReceiveARAP(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveARAP: Enter"));

    ASSERT(BundleCB->FramingInfo.RecvFramingBits & ARAP_FRAMING);

    BundleCB->Stats.FramesReceived++;

    RecvDesc->ProtocolID = PPP_PROTOCOL_APPLETALK;

    Status = IndicateRecvPacket(BundleCB, RecvDesc);

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveARAP: Exit Status %x",Status));

    return (Status);
}

NDIS_STATUS
ReceiveLLC(
   PLINKCB          LinkCB,
   PRECV_DESC       RecvDesc
   )
{
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PUCHAR          FramePointer = RecvDesc->CurrentBuffer;
    LONG            FrameLength = RecvDesc->CurrentLength;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveLLC: Enter"));

    //
    // Skip over LLC
    //
    if (FrameLength < 4) {

    }
    if (*FramePointer != 0xFE || *(FramePointer + 1) != 0xFE ||
        *(FramePointer + 2) != 0x03 || *(FramePointer + 3) != 0xCF) {
        LinkCB->LinkInfo.RecvFramingBits = 0;
        LinkCB->RecvHandler = DetectBroadbandFraming;
        return (NDIS_STATUS_FAILURE);
    }

    FramePointer += 4;
    FrameLength -= 4;

    if (FrameLength <= 0) {
        return (NDIS_STATUS_FAILURE);
    }

    RecvDesc->CurrentBuffer = FramePointer;
    RecvDesc->CurrentLength = FrameLength;

    Status = ProcessPPPFrame(BundleCB, RecvDesc);

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveLLC: Exit Status %x",Status));

    return (Status);
}


NDIS_STATUS
ReceiveForward(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
{
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveForward: Enter"));
    BundleCB->Stats.FramesReceived++;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ReceiveForward: Exit Status %x",Status));
    return (Status);
}

NDIS_STATUS
ProcessPPPFrame(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    )
{
    USHORT      PPPProtocolID;
    PUCHAR      FramePointer = RecvDesc->CurrentBuffer;
    LONG        FrameLength = RecvDesc->CurrentLength;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProcessPPPFrame: Enter"));

    BundleCB->Stats.FramesReceived++;

    //
    // Get the PPP Protocol id
    // 0xC1 is SPAP - Shiva hack!
    //
    if ((*FramePointer & 1) &&
        (*FramePointer != 0xC1) &&
        (*FramePointer != 0xCF)) {

        //
        // Field is compressed
        //
        PPPProtocolID = *FramePointer;
        FramePointer++;
        FrameLength--;

    } else {

        //
        // Field is not compressed
        //
        PPPProtocolID = (*FramePointer << 8) | *(FramePointer + 1);
        FramePointer += 2;
        FrameLength -= 2;
    }

    if (FrameLength <= 0) {
        
        goto PROCESS_PPP_EXIT;
    }

#if 0
    if (BundleCB->Stats.FramesReceived == 1) {
        if (PPPProtocolID != 0xC021) {
            DbgPrint("NDISWAN: Non-LCP first frame! %x %x\n",
                     BundleCB, RecvDesc);
            DbgBreakPoint();
        }
    }
#endif

    //
    // Is this a compressed frame?
    //
    if (PPPProtocolID == PPP_PROTOCOL_COMPRESSION) {

        if (!DoDecompDecryptProcessing(BundleCB,
                                       &FramePointer,
                                       &FrameLength)){

            goto PROCESS_PPP_EXIT;
        }

        //
        // Get the new PPPProtocolID
        //
        if ((*FramePointer & 1) && (FrameLength > 0)) {

            //
            // Field is compressed
            //

            PPPProtocolID = *FramePointer;
            FramePointer++;
            FrameLength--;

        } else if (FrameLength > 1) {
                
            PPPProtocolID = (*FramePointer << 8) | *(FramePointer + 1);
            FramePointer += 2;
            FrameLength -= 2;

        } else {
            //
            // Invalid frame!
            //
            NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE, ("Invalid FrameLen %d", FrameLength));
            goto PROCESS_PPP_EXIT;
        }

    //end of PPP_PROTOCOL_COMPRESSED
    } else if ((PPPProtocolID == PPP_PROTOCOL_COMP_RESET) &&
               (*FramePointer == 14)) {

        if (NdisWanCB.PromiscuousAdapter != NULL) {

            UCHAR       Header[] = {' ', 'R', 'E', 'C', 'V', 0xFF};
            PUCHAR      HeaderPointer;
            USHORT      ProtocolID;
            
            RecvDesc->ProtocolID = PPPProtocolID;
            RecvDesc->CurrentBuffer = FramePointer;
            RecvDesc->CurrentLength = FrameLength;

            HeaderPointer = 
                RecvDesc->StartBuffer;

            ProtocolID = RecvDesc->ProtocolID;

            //
            // Fill the frame out, and queue the data
            //
            NdisMoveMemory(HeaderPointer,
                           Header,
                           sizeof(Header));

            NdisMoveMemory(&HeaderPointer[6],
                           Header,
                           sizeof(Header));

            HeaderPointer[5] =
            HeaderPointer[11] = (UCHAR)RecvDesc->LinkCB->hLinkHandle;

            HeaderPointer[12] = (UCHAR)(ProtocolID >> 8);
            HeaderPointer[13] = (UCHAR)ProtocolID;

            NdisMoveMemory(HeaderPointer + 14,
                           RecvDesc->CurrentBuffer,
                           RecvDesc->CurrentLength);

            RecvDesc->CurrentBuffer = RecvDesc->StartBuffer;
            RecvDesc->CurrentLength += 14;

            //
            // Queue the packet on the promiscous adapter
            //
            IndicatePromiscuousRecv(BundleCB, RecvDesc, RECV_BUNDLE_PPP);
        }

        //
        // Compression reset!
        //
        DoCompressionReset(BundleCB);

        goto PROCESS_PPP_EXIT;

    // end of compression reset
    } else {

        //
        // If we have negotiated encryption and we receive non-encrypted data
        // that is not a ppp control packet we will dump the frame!
        //
        if ((BundleCB->RecvFlags & DO_ENCRYPTION) &&
            (PPPProtocolID < 0x8000)) {

            NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE, ("Received non-encrypted data with encryption negotiated!"));
            goto PROCESS_PPP_EXIT;
        }
    }
    

    RecvDesc->ProtocolID = PPPProtocolID;
    RecvDesc->CurrentLength = FrameLength;
    RecvDesc->CurrentBuffer = FramePointer;

    //
    // If this is slip or if the ProtocolID == PPP_PROTOCOL_COMPRESSED_TCP ||
    // ProtocolID == PPP_PROTOCOL_UNCOMPRESSED_TCP
    //
    if ((BundleCB->RecvFlags & DO_VJ) &&
        ((PPPProtocolID == PPP_PROTOCOL_COMPRESSED_TCP) ||
        (PPPProtocolID == PPP_PROTOCOL_UNCOMPRESSED_TCP))) {

        if (!DoVJDecompression(BundleCB,    // Bundle
                               RecvDesc)) { // RecvDesc

            goto PROCESS_PPP_EXIT;
        }
    }

    Status = IndicateRecvPacket(BundleCB, RecvDesc);

PROCESS_PPP_EXIT:

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("ProcessPPPFrame: Exit Status 0x%x", Status));

    return (Status);
}

NDIS_STATUS
IndicateRecvPacket(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    )
{
    PNDIS_PACKET    NdisPacket;
    PPROTOCOLCB     ProtocolCB;
    PMINIPORTCB     MiniportCB;
    USHORT          PPPProtocolID = RecvDesc->ProtocolID;
    PUCHAR          FramePointer = RecvDesc->CurrentBuffer;
    ULONG           FrameLength = RecvDesc->CurrentLength;
    PUCHAR          HeaderBuffer = RecvDesc->StartBuffer;
    NDIS_STATUS     Status = NDIS_STATUS_PENDING;
    PCM_VCCB        CmVcCB = NULL;
    KIRQL           OldIrql;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("IndicateRecvPacket: Enter"));

    if ((PPPProtocolID >= 0x8000) ||
        (BundleCB->ulNumberOfRoutes == 0)) {


        //
        // Either this frame is an LCP, NCP or we have no routes yet.
        // Indicate to PPP engine.
        //
        Status = CompleteIoRecvPacket(BundleCB, RecvDesc);

        return (Status);
    }

    if (!GetProtocolFromPPPId(BundleCB,
                              PPPProtocolID,
                              &ProtocolCB)) {

        return (NDIS_STATUS_SUCCESS);
    }

    REF_PROTOCOLCB(ProtocolCB);

    if (!IsListEmpty(&ProtocolCB->VcList)) {
        CmVcCB = (PCM_VCCB)ProtocolCB->VcList.Flink;
        REF_CMVCCB(CmVcCB);
    }

    MiniportCB = ProtocolCB->MiniportCB;

    //
    // We found a valid protocol to indicate this frame to!
    //

    //
    // We need to get a data buffer, a couple a ndis buffer, and
    // a ndis packet to indicate to the protocol
    //

    //
    // Fill the WanHeader dest address with the transports context
    //
    ETH_COPY_NETWORK_ADDRESS(HeaderBuffer, ProtocolCB->TransportAddress);

    if (PPPProtocolID == PPP_PROTOCOL_NBF) {

        //
        // For nbf fill the length field
        //
        HeaderBuffer[12] = (UCHAR)(FrameLength >> 8);
        HeaderBuffer[13] = (UCHAR)FrameLength;

        if (!(BundleCB->FramingInfo.RecvFramingBits & NBF_PRESERVE_MAC_ADDRESS)) {
            goto USE_OUR_ADDRESS;
        }

        //
        // For nbf and preserve mac address option (SHIVA_FRAMING)
        // we keep the source address.
        //
        ETH_COPY_NETWORK_ADDRESS(&HeaderBuffer[6], FramePointer + 6);

        FramePointer += 12;
        FrameLength -= 12;

        //
        // For nbf fill the length field
        //
        HeaderBuffer[12] = (UCHAR)(FrameLength >> 8);
        HeaderBuffer[13] = (UCHAR)FrameLength;

    } else {

        //
        // For other protocols fill the protocol type
        //
        HeaderBuffer[12] = (UCHAR)(ProtocolCB->ProtocolType >> 8);
        HeaderBuffer[13] = (UCHAR)ProtocolCB->ProtocolType;

        //
        // Use our address for the src address
        //
USE_OUR_ADDRESS:
        ETH_COPY_NETWORK_ADDRESS(&HeaderBuffer[6], ProtocolCB->NdisWanAddress);
    }

    if (FrameLength > BundleCB->FramingInfo.MaxRRecvFrameSize ||
        FrameLength + RecvDesc->HeaderLength > BundleCB->FramingInfo.MaxRRecvFrameSize) {
        NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("DataLen %d + HdrLen %d > MRRU %d",
        FrameLength, RecvDesc->HeaderLength, BundleCB->FramingInfo.MaxRRecvFrameSize));

        goto INDICATE_RECV_PACKET_EXIT;
    }

    RecvDesc->HeaderLength += MAC_HEADER_LENGTH;

    //
    // Build the NdisPacket
    // USE RtlMoveMemory because memory ranges may overlap.  NdisMoveMemory
    // actually does an rtlcopymemory which does not handle overlapping
    // src/dest ranges.
    //
    RtlMoveMemory(HeaderBuffer + RecvDesc->HeaderLength,
                  FramePointer,
                  FrameLength);

    RecvDesc->CurrentBuffer = HeaderBuffer;
    RecvDesc->CurrentLength = 
        RecvDesc->HeaderLength + FrameLength;

    if (NdisWanCB.PromiscuousAdapter != NULL) {
    
        //
        // Queue the packet on the promiscous adapter
        //
        IndicatePromiscuousRecv(BundleCB, 
                                RecvDesc, 
                                RECV_BUNDLE_DATA);
    }

    NdisPacket = 
        RecvDesc->NdisPacket;

    PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->RecvDesc = 
        RecvDesc;

    NdisAdjustBufferLength(RecvDesc->NdisBuffer,
                           RecvDesc->CurrentLength);

    NdisRecalculatePacketCounts(NdisPacket);

    //
    // Check for non-idle data
    //
    if (ProtocolCB->NonIdleDetectFunc != NULL) {
        PUCHAR  PHeaderBuffer = HeaderBuffer + MAC_HEADER_LENGTH;

        if (TRUE == ProtocolCB->NonIdleDetectFunc(PHeaderBuffer,
                                                  RecvDesc->HeaderLength + FrameLength,
                                                  RecvDesc->HeaderLength + FrameLength)) {
            NdisWanGetSystemTime(&ProtocolCB->LastNonIdleData);
            BundleCB->LastNonIdleData = ProtocolCB->LastNonIdleData;
        }
    } else {
        NdisWanGetSystemTime(&ProtocolCB->LastNonIdleData);
        BundleCB->LastNonIdleData = ProtocolCB->LastNonIdleData;
    }

    ReleaseBundleLock(BundleCB);

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    INSERT_DBG_RECV(PacketTypeNdis, 
                    MiniportCB, 
                    ProtocolCB, 
                    RecvDesc->LinkCB, 
                    NdisPacket);

    //
    // Indicate the packet
    //
    if (CmVcCB != NULL) {

        NdisMCoIndicateReceivePacket(CmVcCB->NdisVcHandle,
                                     &NdisPacket,
                                     1);

        DEREF_CMVCCB(CmVcCB);

    } else {

        NdisMIndicateReceivePacket(MiniportCB->MiniportHandle,
                                   &NdisPacket,
                                   1);
    }

    KeLowerIrql(OldIrql);

    AcquireBundleLock(BundleCB);

INDICATE_RECV_PACKET_EXIT:

    DEREF_PROTOCOLCB(ProtocolCB);

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("IndicateRecvPacket: Exit Status %x",Status));

    return (Status);
}


VOID
DoMultilinkProcessing(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    )
/*++

Routine Name:

Routine Description:

Arguments:

                           0 1 2 3 4 5 6 7 8 9 1 1 1 1 1 1
                                               0 1 2 3 4 5
                          +-+-+-+-+------------------------+
    Short Sequence Number |B|E|0|0|    Sequence Number     |
                          +-+-+-+-+------------------------+
                          |             Data               |
                          +--------------------------------+

                          +-+-+-+-+-+-+-+-+----------------+
    Long Sequence Number  |B|E|0|0|0|0|0|0|Sequence Number |
                          +-+-+-+-+-+-+-+-+----------------+
                          |        Sequence Number         |
                          +--------------------------------+
                          |            Data                |
                          +--------------------------------+
                        
    MCML                  +-+-+-+-+------------------------+
    Short Sequence Number |B|E|Cls|    Sequence Number     |
                          +-+-+-+-+------------------------+
                          |             Data               |
                          +--------------------------------+

    MCML                  +-+-+-+-+-+-+-+-+----------------+
    Long Sequence Number  |B|E| Class |0|0|Sequence Number |
                          +-+-+-+-+-+-+-+-+----------------+
                          |        Sequence Number         |
                          +--------------------------------+
                          |            Data                |
                          +--------------------------------+
                        

Return Values:

--*/
{
    BOOLEAN Inserted = FALSE;
    ULONG   BundleFraming;
    ULONG   SequenceNumber, Flags;
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    PUCHAR      FramePointer = RecvDesc->CurrentBuffer;
    LONG        FrameLength = RecvDesc->CurrentLength;
    PRECV_DESC  RecvDescHole;
    UINT        Class = 0;
    PBUNDLE_RECV_INFO   BundleRecvInfo;
    PLINK_RECV_INFO     LinkRecvInfo;

    //
    // Get the flags
    //
    Flags = *FramePointer & MULTILINK_FLAG_MASK;

    //
    // Get the sequence number
    //
    if (BundleCB->FramingInfo.RecvFramingBits &
        PPP_SHORT_SEQUENCE_HDR_FORMAT) {
        //
        // Short sequence format
        //
        SequenceNumber =
            ((*FramePointer & 0x0F) << 8) | *(FramePointer + 1);

        if (BundleCB->FramingInfo.RecvFramingBits &
            PPP_MC_MULTILINK_FRAMING) {
            Class =
                ((*FramePointer & MCML_SHORTCLASS_MASK) >> 4);
        }

        FramePointer += 2;
        FrameLength -= 2;


    } else {

        //
        // Long sequence format
        //
        SequenceNumber = (*(FramePointer + 1) << 16) |
                         (*(FramePointer + 2) << 8)  |
                         *(FramePointer + 3);

        if (BundleCB->FramingInfo.RecvFramingBits &
            PPP_MC_MULTILINK_FRAMING) {
            Class =
                ((*FramePointer & MCML_LONGCLASS_MASK) >> 2);
        }

        FramePointer += 4;
        FrameLength -= 4;
    }

    if (Class >= MAX_MCML) {
        LinkCB->Stats.FramingErrors++;
        BundleCB->Stats.FramingErrors++;
        return;
    }

    BundleRecvInfo = &BundleCB->RecvInfo[Class];
    LinkRecvInfo = &LinkCB->RecvInfo[Class];

    if (FrameLength <= 0) {
        LinkCB->Stats.FramingErrors++;
        LinkRecvInfo->FragmentsLost++;

        BundleCB->Stats.FramingErrors++;
        BundleRecvInfo->FragmentsLost++;
        return;
    }

    RecvDescHole = BundleRecvInfo->RecvDescHole;

    NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV,
    ("r %x %x h: %x l: %d",SequenceNumber, Flags, RecvDescHole->SequenceNumber, LinkCB->hLinkHandle));

    //
    // Is the new receive sequence number smaller that the last
    // sequence number received on this link?  If so the increasing seq
    // number rule has been violated and we need to toss this one.
    //
    if (SEQ_LT(SequenceNumber,
               LinkRecvInfo->LastSeqNumber,
               BundleCB->RecvSeqTest)) {

        LinkCB->Stats.FramingErrors++;
        LinkRecvInfo->FragmentsLost++;

        BundleCB->Stats.FramingErrors++;
        BundleRecvInfo->FragmentsLost++;

        NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
        ("dl s: %x %x lr: %x", SequenceNumber, Flags,
        LinkRecvInfo->LastSeqNumber));

        NdisWanFreeRecvDesc(RecvDesc);
        return;
        
    }

    //
    // Is the new receive sequence number smaller than the hole?  If so
    // we received a fragment across a slow link after it has been flushed
    //
    if (SEQ_LT(SequenceNumber,
               RecvDescHole->SequenceNumber,
               BundleCB->RecvSeqTest)) {

        LinkCB->Stats.FramingErrors++;
        LinkRecvInfo->FragmentsLost++;

        BundleCB->Stats.FramingErrors++;
        BundleRecvInfo->FragmentsLost++;

        NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
        ("db s: %x %x h: %x", SequenceNumber, Flags,
        RecvDescHole->SequenceNumber));

        NdisWanFreeRecvDesc(RecvDesc);
        return;
    }

    //
    // Initialize the recv desc
    //
    RecvDesc->Flags |= Flags;
    RecvDesc->SequenceNumber =
    LinkRecvInfo->LastSeqNumber = SequenceNumber;

    if (RecvDesc->CopyRequired) {
        PUCHAR  StartData = 
            RecvDesc->StartBuffer + MAC_HEADER_LENGTH + PROTOCOL_HEADER_LENGTH;

        NdisMoveMemory(StartData,
                       FramePointer,
                       FrameLength);

        FramePointer = StartData;

        RecvDesc->CopyRequired = FALSE;
    }

    RecvDesc->CurrentBuffer = FramePointer;
    RecvDesc->CurrentLength = FrameLength;

    //
    // If this fills the hole
    //
    if (SEQ_EQ(SequenceNumber, RecvDescHole->SequenceNumber)) {

        //
        // Insert the hole filler in the current holes spot
        //
        RecvDesc->Linkage.Blink = (PLIST_ENTRY)RecvDescHole->Linkage.Blink;
        RecvDesc->Linkage.Flink = (PLIST_ENTRY)RecvDescHole->Linkage.Flink;

        RecvDesc->Linkage.Blink->Flink =
        RecvDesc->Linkage.Flink->Blink = (PLIST_ENTRY)RecvDesc;

        //
        // Find the next hole
        //
        FindHoleInRecvList(BundleCB, RecvDesc, Class);

        NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("r1"));

    } else {

        PRECV_DESC  BeginDesc, EndDesc;

        //
        // This does not fill a hole so we need to insert it into
        // the list at the right spot.  This spot will be someplace
        // between the hole and the end of the list.
        //
        BeginDesc = RecvDescHole;
        EndDesc = (PRECV_DESC)BeginDesc->Linkage.Flink;

        while ((PVOID)EndDesc != (PVOID)&BundleRecvInfo->AssemblyList) {

            //
            // Calculate the absolute delta between the begining sequence
            // number and the sequence number we are looking to insert.
            //
            ULONG   DeltaBegin =
                    ((RecvDesc->SequenceNumber - BeginDesc->SequenceNumber) &
                    BundleCB->RecvSeqMask);
            
            //
            // Calculate the absolute delta between the begining sequence
            // number and the end sequence number.
            //
            ULONG   DeltaEnd =
                    ((EndDesc->SequenceNumber - BeginDesc->SequenceNumber) &
                    BundleCB->RecvSeqMask);

            //
            // If the delta from the begin to current is less than
            // the delta from the end to current it is time to insert
            //
            if (DeltaBegin < DeltaEnd) {
                PLIST_ENTRY Flink, Blink;

                //
                // Insert the desc
                //
                RecvDesc->Linkage.Flink = (PLIST_ENTRY)EndDesc;
                RecvDesc->Linkage.Blink = (PLIST_ENTRY)BeginDesc;
                BeginDesc->Linkage.Flink =
                EndDesc->Linkage.Blink = (PLIST_ENTRY)RecvDesc;

                Inserted = TRUE;

                NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("r2"));
                break;

            } else {

                //
                // Get next pair of descriptors
                //
                BeginDesc = EndDesc;
                EndDesc = (PRECV_DESC)EndDesc->Linkage.Flink;
            }
        }

        if (!Inserted) {
            
            //
            // If we are here we have fallen through and we need to
            // add this at the end of the list
            //
            InsertTailList(&BundleRecvInfo->AssemblyList, &RecvDesc->Linkage);

            NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("r3"));
        }
    }

    //
    // Another recvdesc has been placed on the assembly list.
    //
    BundleRecvInfo->AssemblyCount++;

    //
    // Update the bundles minimum recv sequence number.  This is
    // used to detect lost fragments.
    //
    UpdateMinRecvSeqNumber(BundleCB, Class);

    //
    // See if we can complete some frames!!!!
    //
    TryToAssembleFrame(BundleCB, Class);

    //
    // Check for lost fragments.  If the minimum recv sequence number
    // over the bundle is greater than the hole sequence number we have
    // lost a fragment and need to flush the assembly list until we find
    // the first begin fragment after the hole.
    //
    if (SEQ_GT(BundleRecvInfo->MinSeqNumber,
               RecvDescHole->SequenceNumber,
               BundleCB->RecvSeqTest)) {

        NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
            ("min %x > h %x b %p",
             BundleRecvInfo->MinSeqNumber,
             RecvDescHole->SequenceNumber,
             BundleCB));

        do {

            //
            // Flush the recv desc assembly window.
            //
            FlushRecvDescWindow(BundleCB, Class);

        } while (SEQ_GT(BundleRecvInfo->MinSeqNumber,
                        RecvDescHole->SequenceNumber,
                        BundleCB->RecvSeqTest));
    }

    //
    // If the number of recvdesc's is starting to stack up
    // we may have a link that is not sending so flush
    //
    if (BundleRecvInfo->AssemblyCount >
        (MAX_RECVDESC_COUNT + BundleCB->ulLinkCBCount)) {
        
        NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
        ("%x AssemblyCount %d > %d", BundleCB,
         BundleRecvInfo->AssemblyCount, MAX_RECVDESC_COUNT + BundleCB->ulLinkCBCount));

        //
        // Flush the recv desc assembly window.
        //
        FlushRecvDescWindow(BundleCB, Class);
    }
}

VOID
UpdateMinRecvSeqNumber(
    PBUNDLECB   BundleCB,
    UINT        Class
    )
{
    PBUNDLE_RECV_INFO   BundleRecvInfo;
    PLINK_RECV_INFO     LinkRecvInfo;
    PLINKCB LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;

    BundleRecvInfo = &BundleCB->RecvInfo[Class];
    LinkRecvInfo = &LinkCB->RecvInfo[Class];

    NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV,
    ("MinReceived c %x", BundleRecvInfo->MinSeqNumber));

    BundleRecvInfo->MinSeqNumber = LinkRecvInfo->LastSeqNumber;

    for (LinkCB = (PLINKCB)LinkCB->Linkage.Flink;
        (PVOID)LinkCB != (PVOID)&BundleCB->LinkCBList;
        LinkCB = (PLINKCB)LinkCB->Linkage.Flink) {
        LinkRecvInfo = &LinkCB->RecvInfo[Class];

        if (SEQ_LT(LinkRecvInfo->LastSeqNumber,
                   BundleRecvInfo->MinSeqNumber,
                   BundleCB->RecvSeqTest)) {
            BundleRecvInfo->MinSeqNumber = LinkRecvInfo->LastSeqNumber;
        }
    }

    NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV,
    ("MinReceived n %x", BundleRecvInfo->MinSeqNumber));
}

VOID
FindHoleInRecvList(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc,
    UINT        Class
    )
/*++

Routine Name:

Routine Description:

    We want to start at the spot where the current hole was removed
    from and look for adjoining recv desc's in the list who have
    sequence numbers that differ by more than 1.

Arguments:

Return Values:

--*/
{
    PRECV_DESC  NextRecvDesc, RecvDescHole;
    ULONG       SequenceNumber;
    PLIST_ENTRY RecvList;
    PBUNDLE_RECV_INFO   BundleRecvInfo;

    BundleRecvInfo = &BundleCB->RecvInfo[Class];

    RecvDescHole = BundleRecvInfo->RecvDescHole;

    RecvList = &BundleRecvInfo->AssemblyList;

    NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV,
    ("h: %x", RecvDescHole->SequenceNumber));

    if (IsListEmpty(RecvList)) {
        //
        // Set the new sequence number
        //
        RecvDescHole->SequenceNumber += 1;
        RecvDescHole->SequenceNumber &= BundleCB->RecvSeqMask;

        //
        // Put the hole back on the list
        //
        InsertHeadList(RecvList, &RecvDescHole->Linkage);

    } else {

        //
        // Walk the list looking for two descriptors that have
        // sequence numbers differing by more than 1 or until we
        // get to the end of the list
        //
        NextRecvDesc = (PRECV_DESC)RecvDesc->Linkage.Flink;
        SequenceNumber = RecvDesc->SequenceNumber;

        while (((PVOID)NextRecvDesc != (PVOID)RecvList) &&
               (((NextRecvDesc->SequenceNumber - RecvDesc->SequenceNumber) &
               BundleCB->RecvSeqMask) == 1)) {
            
            RecvDesc = NextRecvDesc;
            NextRecvDesc = (PRECV_DESC)RecvDesc->Linkage.Flink;
            SequenceNumber = RecvDesc->SequenceNumber;
        }

        RecvDescHole->SequenceNumber = SequenceNumber + 1;
        RecvDescHole->SequenceNumber &= BundleCB->RecvSeqMask;

        RecvDescHole->Linkage.Flink = (PLIST_ENTRY)NextRecvDesc;
        RecvDescHole->Linkage.Blink = (PLIST_ENTRY)RecvDesc;

        RecvDesc->Linkage.Flink =
        NextRecvDesc->Linkage.Blink =
            (PLIST_ENTRY)RecvDescHole;
    }

    NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("nh: %x", RecvDescHole->SequenceNumber));
}

VOID
FlushRecvDescWindow(
    IN  PBUNDLECB   BundleCB,
    IN  UINT        Class
    )
/*++

Routine Name:

    FlushRecvDescWindow

Routine Description:

    This routine is called to flush recv desc's from the assembly list when
    a fragment loss is detected.  The idea is to flush fragments until we find
    a begin fragment that has a sequence number >= the minimum received fragment
    on the bundle.

Arguments:

--*/
{
    PRECV_DESC  RecvDescHole;
    PRECV_DESC  TempDesc=NULL;
    PBUNDLE_RECV_INFO   BundleRecvInfo;

    BundleRecvInfo = &BundleCB->RecvInfo[Class];

    RecvDescHole = BundleRecvInfo->RecvDescHole;

    //
    // Remove all recvdesc's until we find the hole
    //
    // To avoid passing a uninitialized TempDesc to FindHoleInRecvList
    ASSERT(!IsListEmpty(&BundleRecvInfo->AssemblyList)); 
    while (!IsListEmpty(&BundleRecvInfo->AssemblyList)) {

        TempDesc = (PRECV_DESC)
            RemoveHeadList(&BundleRecvInfo->AssemblyList);

        if (TempDesc == RecvDescHole) {
            break;
        }

        BundleRecvInfo->FragmentsLost++;

        BundleRecvInfo->AssemblyCount--;

        NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
        ("flw %x %x h: %x", TempDesc->SequenceNumber,
        TempDesc->Flags, RecvDescHole->SequenceNumber));

        NdisWanFreeRecvDesc(TempDesc);
    }

    BundleCB->Stats.FramingErrors++;

    //
    // Now flush all recvdesc's until we find a begin fragment that has a
    // sequence number >= M or the list is empty.
    //
    while (!IsListEmpty(&BundleRecvInfo->AssemblyList)) {

        TempDesc = (PRECV_DESC)
            BundleRecvInfo->AssemblyList.Flink;

        if (TempDesc->Flags & MULTILINK_BEGIN_FRAME) {
            break;
        }

        NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
        ("flw %x %x h: %x", TempDesc->SequenceNumber,
        TempDesc->Flags, RecvDescHole->SequenceNumber));

        RecvDescHole->SequenceNumber = TempDesc->SequenceNumber;

        RemoveHeadList(&BundleRecvInfo->AssemblyList);

        BundleRecvInfo->AssemblyCount--;
        BundleRecvInfo->FragmentsLost++;

        NdisWanFreeRecvDesc(TempDesc);
        TempDesc = NULL;
    }

    //
    // Now reinsert the hole desc.
    //
    NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
    ("h: %x", RecvDescHole->SequenceNumber));

    FindHoleInRecvList(BundleCB, TempDesc, Class);

    NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
    ("nh: %x", RecvDescHole->SequenceNumber));

    //
    // See if we can complete some frames!!!!
    //
    TryToAssembleFrame(BundleCB, Class);
}

VOID
FlushAssemblyLists(
    IN  PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PRECV_DESC  RecvDesc;
    UINT        Class;

    for (Class = 0; Class < MAX_MCML; Class++) {
        PBUNDLE_RECV_INFO RecvInfo = &BundleCB->RecvInfo[Class];
        
        while (!IsListEmpty(&RecvInfo->AssemblyList)) {
    
            RecvDesc = (PRECV_DESC)RemoveHeadList(&RecvInfo->AssemblyList);
            RecvInfo->AssemblyCount--;
            if (RecvDesc->Flags != MULTILINK_HOLE_FLAG) {
                NdisWanFreeRecvDesc(RecvDesc);
            }
        }
    }
}

VOID
TryToAssembleFrame(
    PBUNDLECB   BundleCB,
    UINT        Class
    )
/*++

Routine Name:

    TryToAssembleFrame

Routine Description:

    The goal here is to walk the recv list looking for a full frame
    (BeginFlag, EndFlag, no holes in between).  If we do not have a
    full frame we return FALSE.

    If we have a full frame we remove each desc from the assembly list
    copying the data into the first desc and returning all of the desc's
    except the first one to the free pool.  Once all of the data had been
    collected we process the frame.  After the frame has been processed
    we return the first desc to the free pool.

Arguments:

Return Values:

--*/
{
    PRECV_DESC  RecvDesc, RecvDescHole;
    PUCHAR      DataPointer;
    LINKCB      LinkCB;
    PBUNDLE_RECV_INFO   BundleRecvInfo;

    BundleRecvInfo = &BundleCB->RecvInfo[Class];

    RecvDesc = (PRECV_DESC)BundleRecvInfo->AssemblyList.Flink;
    RecvDescHole = BundleRecvInfo->RecvDescHole;

TryToAssembleAgain:

    while ((RecvDesc != RecvDescHole) &&
           (RecvDesc->Flags & MULTILINK_BEGIN_FRAME)) {

        PRECV_DESC  NextRecvDesc = (PRECV_DESC)RecvDesc->Linkage.Flink;

        DataPointer = RecvDesc->CurrentBuffer + RecvDesc->CurrentLength;

        while ((NextRecvDesc != RecvDescHole) &&
               !(RecvDesc->Flags & MULTILINK_END_FRAME)) {

            RemoveEntryList(&NextRecvDesc->Linkage);
            BundleRecvInfo->AssemblyCount--;

            ASSERT(NextRecvDesc != RecvDescHole);
            ASSERT(RecvDesc != RecvDescHole);

            NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("c 0x%x -> 0x%x",
            NextRecvDesc->SequenceNumber, RecvDesc->SequenceNumber));

            NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("fl 0x%x -> 0x%x",
            NextRecvDesc->Flags, RecvDesc->Flags));

            NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("l %d -> %d",
            NextRecvDesc->CurrentLength, RecvDesc->CurrentLength));

            //
            // Update recvdesc info
            //
            RecvDesc->Flags |= NextRecvDesc->Flags;
            RecvDesc->SequenceNumber = NextRecvDesc->SequenceNumber;
            RecvDesc->CurrentLength += NextRecvDesc->CurrentLength;

            //
            // Make sure we don't assemble something too big!
            //
            if (RecvDesc->CurrentLength > (LONG)glMRRU) {

                NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
                ("Max receive size exceeded!"));

                //
                // Return the recv desc's
                //
                RemoveEntryList(&RecvDesc->Linkage);
                BundleRecvInfo->AssemblyCount--;

                BundleCB->Stats.FramingErrors++;

                NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
                ("dumping %x %x h: %x", RecvDesc->SequenceNumber,
                RecvDesc->Flags, RecvDescHole->SequenceNumber));

                NdisWanFreeRecvDesc(RecvDesc);

                NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
                ("dumping %x %x h: %x", NextRecvDesc->SequenceNumber,
                NextRecvDesc->Flags, RecvDescHole->SequenceNumber));

                NdisWanFreeRecvDesc(NextRecvDesc);

                //
                // Start at the list head and flush until we find either the hole
                // or a new begin fragment.
                //
                RecvDesc = (PRECV_DESC)BundleRecvInfo->AssemblyList.Flink;

                while (RecvDesc != RecvDescHole &&
                    !(RecvDesc->Flags & MULTILINK_BEGIN_FRAME)) {
                    
                    RemoveHeadList(&BundleRecvInfo->AssemblyList);
                    BundleRecvInfo->AssemblyCount--;

                    NdisWanDbgOut(DBG_FAILURE, DBG_MULTILINK_RECV,
                    ("dumping %x %x h: %x", RecvDesc->SequenceNumber,
                    RecvDesc->Flags, RecvDescHole->SequenceNumber));

                    NdisWanFreeRecvDesc(RecvDesc);
                }

                goto TryToAssembleAgain;
            }

            NdisMoveMemory(DataPointer,
                           NextRecvDesc->CurrentBuffer,
                           NextRecvDesc->CurrentLength);

            DataPointer += NextRecvDesc->CurrentLength;

            NdisWanFreeRecvDesc(NextRecvDesc);

            NextRecvDesc = (PRECV_DESC)RecvDesc->Linkage.Flink;
        }

        //
        // We hit a hole before completion of the frame.
        // Get out.
        //
        if (!IsCompleteFrame(RecvDesc->Flags)) {
            return;
        }

        //
        // If we made it here we must have a begin flag, end flag, and
        // no hole in between. Let's build a frame.
        //
        RecvDesc = (PRECV_DESC)
            RemoveHeadList(&BundleRecvInfo->AssemblyList);

        BundleRecvInfo->AssemblyCount--;

        NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_RECV, ("a %x %x", RecvDesc->SequenceNumber, RecvDesc->Flags));

        RecvDesc->LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;

        if (NDIS_STATUS_PENDING != ProcessPPPFrame(BundleCB, RecvDesc)) {
            NdisWanFreeRecvDesc(RecvDesc);
        }

        RecvDesc = (PRECV_DESC)BundleRecvInfo->AssemblyList.Flink;

    } // end of while MULTILINK_BEGIN_FRAME
}

BOOLEAN
DoVJDecompression(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    )
{
    ULONG   BundleFraming;
    PUCHAR  FramePointer = RecvDesc->CurrentBuffer;
    LONG    FrameLength = RecvDesc->CurrentLength;
    UCHAR   VJCompType = 0;
    BOOLEAN DoDecomp = FALSE;
    BOOLEAN VJDetect = FALSE;

    BundleFraming = BundleCB->FramingInfo.RecvFramingBits;

    if (BundleFraming & SLIP_FRAMING) {

        VJCompType = *FramePointer & 0xF0;

        //
        // If the packet is compressed the header has to be atleast 3 bytes long.
        // If this is a regular IP packet we do not decompress it.
        //
        if ((FrameLength > 2) && (VJCompType != TYPE_IP)) {

            if (VJCompType & 0x80) {

                VJCompType = TYPE_COMPRESSED_TCP;
                
            } else if (VJCompType == TYPE_UNCOMPRESSED_TCP) {

                *FramePointer &= 0x4F;
            }

            //
            // If framing is set for detection, in order for this to be a good
            // frame for detection we need a type of UNCOMPRESSED_TCP and a
            // frame that is atleast 40 bytes long.
            //
            VJDetect = ((BundleFraming & SLIP_VJ_AUTODETECT) &&
                        (VJCompType == TYPE_UNCOMPRESSED_TCP) &&
                        (FrameLength > 39));

            if ((BundleFraming & SLIP_VJ_COMPRESSION) || VJDetect) {

                //
                // If VJ compression is set or if we are in
                // autodetect and this looks like a reasonable
                // frame
                //
                DoDecomp = TRUE;
                
            }
        }

    // end of SLIP_FRAMING
    } else {

        //
        // Must be PPP framing
        //
        if (RecvDesc->ProtocolID == PPP_PROTOCOL_COMPRESSED_TCP) {
            VJCompType = TYPE_COMPRESSED_TCP;
        } else {
            VJCompType = TYPE_UNCOMPRESSED_TCP;
        }

        DoDecomp = TRUE;
    }

    if (DoDecomp) {
        PUCHAR  HeaderBuffer;
        LONG    PostCompSize, PreCompSize;

        PreCompSize = RecvDesc->CurrentLength;

        HeaderBuffer =
            RecvDesc->StartBuffer + MAC_HEADER_LENGTH;

        if ((PostCompSize = sl_uncompress_tcp(&RecvDesc->CurrentBuffer,
                                              &RecvDesc->CurrentLength,
                                              HeaderBuffer,
                                              &RecvDesc->HeaderLength,
                                              VJCompType,
                                              BundleCB->VJCompress)) == 0) {
            
            NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE, ("Error in sl_uncompress_tcp!"));
            return(FALSE);
        }

        if (VJDetect) {
            BundleCB->FramingInfo.RecvFramingBits |= SLIP_VJ_COMPRESSION;
            BundleCB->FramingInfo.SendFramingBits |= SLIP_VJ_COMPRESSION;
        }

        ASSERT(PostCompSize == RecvDesc->HeaderLength + RecvDesc->CurrentLength);

#if DBG
        if (VJCompType == TYPE_COMPRESSED_TCP) {
            ASSERT(RecvDesc->HeaderLength > 0);
            NdisWanDbgOut(DBG_TRACE, DBG_RECV_VJ,("rvj b %d a %d",(RecvDesc->HeaderLength - (PostCompSize-PreCompSize)), RecvDesc->HeaderLength));
        }
#endif

        //
        // Calculate how much expansion we had
        //
        BundleCB->Stats.BytesReceivedCompressed +=
            (RecvDesc->HeaderLength - (PostCompSize - PreCompSize));

        BundleCB->Stats.BytesReceivedUncompressed += RecvDesc->HeaderLength;

    }

    RecvDesc->ProtocolID = PPP_PROTOCOL_IP;

    return(TRUE);
}

#define SEQ_TYPE_IN_ORDER           1
#define SEQ_TYPE_AFTER_EXPECTED     2
#define SEQ_TYPE_BEFORE_EXPECTED    3


BOOLEAN
DoDecompDecryptProcessing(
    PBUNDLECB   BundleCB,
    PUCHAR      *DataPointer,
    PLONG       DataLength
    )
{
    USHORT              Coherency, CurrCoherency;
    ULONG               Flags;
    PWAN_STATS          BundleStats;
    PUCHAR              FramePointer = *DataPointer;
    LONG                FrameLength = *DataLength;

    ULONG               PacketSeqType;
    LONG                OutOfOrderDepth;
    LONG                NumberMissed = 0;


    Flags = BundleCB->RecvFlags;

    BundleStats = &BundleCB->Stats;

    if (Flags & (DO_COMPRESSION | DO_ENCRYPTION)) {
        PUCHAR  SessionKey = BundleCB->RecvCryptoInfo.SessionKey;
        ULONG   SessionKeyLength = BundleCB->RecvCryptoInfo.SessionKeyLength;
        PVOID   RecvRC4Key = BundleCB->RecvCryptoInfo.RC4Key;
        PVOID   RecvCompressContext = BundleCB->RecvCompressContext;
        BOOLEAN SyncCoherency = FALSE;

        //
        // Get the coherency counter
        //
        Coherency = (*FramePointer << 8) | *(FramePointer + 1);
        FramePointer += 2;
        FrameLength -= 2;

        if (FrameLength <= 0) {
            goto RESYNC;
        }

        if (!(Flags & DO_HISTORY_LESS))
        {
            // history-based
            if (SEQ_LT(Coherency & 0x0FFF,
                BundleCB->RCoherencyCounter & 0x0FFF,
                0x0800)) {
                //
                // We received a sequence number that is less then the
                // expected sequence number so we must be way out of sync
                //
                NdisWanDbgOut(DBG_CRITICAL_ERROR, DBG_RECEIVE,
                    ("Recv old frame!!!! b %p rc %x < ec %x!!!!", BundleCB, Coherency & 0x0FFF,
                    BundleCB->RCoherencyCounter & 0x0FFF));
                goto RESYNC;
            }
        }
        else
        {
            // history-less
            if((Coherency & 0x0FFF) == (BundleCB->RCoherencyCounter & 0x0FFF)) 
            {
                PacketSeqType = SEQ_TYPE_IN_ORDER;
            }
            else
            {
                if (SEQ_GT(Coherency & 0x0FFF,
                    BundleCB->RCoherencyCounter & 0x0FFF,
                    0x0800)) 
                {
                    PacketSeqType = SEQ_TYPE_BEFORE_EXPECTED;
                    NumberMissed = ((Coherency & 0x0FFF) - (BundleCB->RCoherencyCounter & 0x0FFF)) & 0x0FFF;
                    ASSERT(NumberMissed > 0);
                }
                else 
                {
                    OutOfOrderDepth = ((BundleCB->RCoherencyCounter & 0x0FFF) - (Coherency & 0x0FFF)) & 0x0FFF;
                    if(OutOfOrderDepth <= (LONG)glMaxOutOfOrderDepth)
                    {
                        PacketSeqType = SEQ_TYPE_AFTER_EXPECTED;
                    }
                    else
                    {
                        //
                        // We received a sequence number that is either too earlier or too later
                        //
                        NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE,
                            ("Recv frame way out of order! b %p rc %x < ec %x!!!!", BundleCB, Coherency & 0x0FFF,
                            BundleCB->RCoherencyCounter & 0x0FFF));
                        return (FALSE);
                    }
                }
            }
        }

        //
        // See if this is a flush packet
        //
        if (Coherency & (PACKET_FLUSHED << 8)) {

            NdisWanDbgOut(DBG_INFO, DBG_RECEIVE,
            ("Recv Packet Flushed 0x%x", (Coherency & 0x0FFF)));

            SyncCoherency = TRUE;

            if ((Flags & DO_ENCRYPTION) &&
                !(Flags & DO_HISTORY_LESS)) {
        
                //
                // Re-Init the rc4 receive table
                //
                rc4_key(RecvRC4Key,
                        SessionKeyLength,
                        SessionKey);
            }
        
            if (Flags & DO_COMPRESSION) {
        
                //
                // Initialize the decompression history table
                //
                initrecvcontext(RecvCompressContext);
            }
        }  // end of packet flushed

        //
        // If we are in history-less mode and we get out of sync
        // we need to recreate all of the interim encryption
        // keys that we missed, cache the keys 
        // When a packet comes in later, look for the cached key 
        //
        if ((Flags & DO_HISTORY_LESS) &&
            PacketSeqType != SEQ_TYPE_IN_ORDER) {
            ULONG       count;
            LONG        index;
            PCACHED_KEY pKey;

            if(PacketSeqType == SEQ_TYPE_AFTER_EXPECTED)
            {
                if (Coherency & (PACKET_ENCRYPTED << 8)) 
                {
                    // This packet is encrypted
                    if (!(Flags & DO_ENCRYPTION)) {
                        //
                        // We are not configured to decrypt
                        //
                        return (FALSE);
                    }

                    // Find the cached key for this packet
                    pKey = BundleCB->RecvCryptoInfo.pCurrKey;
                    for(count = 0; count < glCachedKeyCount; count++)
                    {
                        // Walk through the keys
                        if(pKey > (PCACHED_KEY)BundleCB->RecvCryptoInfo.CachedKeyBuffer)
                        {
                            pKey = (PCACHED_KEY)((PUCHAR)pKey - (sizeof(USHORT)+ SessionKeyLength));
                        }
                        else
                        {
                            pKey = (PCACHED_KEY)BundleCB->RecvCryptoInfo.pLastKey;
                        }

                        if(pKey->Coherency == (Coherency & 0x0FFF))
                        {
                            //
                            // Re-Init the rc4 receive table
                            //
                            rc4_key(RecvRC4Key,
                                    SessionKeyLength,
                                    pKey->SessionKey);
                            pKey->Coherency = 0xffff;       // avoid duplication
                            
                            //
                            // Decrypt the data!
                            //
                            rc4(RecvRC4Key,
                                FrameLength,
                                FramePointer);

                            goto DECOMPRESS_DATA;
                        }
                    }

                    // Can't recover this packet, drop it
                    return (FALSE);
                }

                goto DECOMPRESS_DATA;
            }

            // This packet comes earlier than expected

            SyncCoherency = TRUE;

            if (Flags & DO_ENCRYPTION) {

#ifdef DBG_ECP
            DbgPrint("NDISWAN: Missed %d frames, regening keys...\n", NumberMissed);
            DbgPrint("NDISWAN: resync b %p rc %x ec %x\n", BundleCB, Coherency & 0x0FFF,
                BundleCB->RCoherencyCounter & 0x0FFF);
#endif

                CurrCoherency = BundleCB->RCoherencyCounter & 0x0FFF;
    
                while (NumberMissed--) {
                    
                    if (Flags & DO_LEGACY_ENCRYPTION) {
                        
                        //
                        // Change the session key
                        //
                        SessionKey[3] += 1;
                        SessionKey[4] += 3;
                        SessionKey[5] += 13;
                        SessionKey[6] += 57;
                        SessionKey[7] += 19;
    
                    } else {
    
                        //
                        // Change the session key
                        //
                        GetNewKeyFromSHA(&BundleCB->RecvCryptoInfo);
                    }
    
    
                    //
                    // We use rc4 to scramble and recover a new key
                    //
    
                    //
                    // Re-initialize the rc4 receive table to the
                    // intermediate value
                    //
                    rc4_key(RecvRC4Key, SessionKeyLength, SessionKey);
                
                    //
                    // Scramble the existing session key
                    //
                    rc4(RecvRC4Key, SessionKeyLength, SessionKey);
    
                    if (Flags & DO_40_ENCRYPTION) {
                        
                        //
                        // If this is 40 bit encryption we need to fix
                        // the first 3 bytes of the key.
                        //
                        SessionKey[0] = 0xD1;
                        SessionKey[1] = 0x26;
                        SessionKey[2] = 0x9E;
                
                    } else if (Flags & DO_56_ENCRYPTION) {
                        //
                        // If this is 56 bit encryption we need to fix
                        // the first byte of the key.
                        //
                        SessionKey[0] = 0xD1;
                    }
    
                    if(NumberMissed < (LONG)glCachedKeyCount)
                    {
                        BundleCB->RecvCryptoInfo.pCurrKey->Coherency = CurrCoherency;
                        NdisMoveMemory(BundleCB->RecvCryptoInfo.pCurrKey->SessionKey, 
                            SessionKey,
                            SessionKeyLength);
    
                        if(BundleCB->RecvCryptoInfo.pCurrKey < BundleCB->RecvCryptoInfo.pLastKey)
                        {
                            BundleCB->RecvCryptoInfo.pCurrKey = (PCACHED_KEY)((PUCHAR)BundleCB->RecvCryptoInfo.pCurrKey + 
                                sizeof(USHORT) + SessionKeyLength);
                            ASSERT(BundleCB->RecvCryptoInfo.pCurrKey <= BundleCB->RecvCryptoInfo.pLastKey);
                        }
                        else
                        {
                            BundleCB->RecvCryptoInfo.pCurrKey = (PCACHED_KEY)BundleCB->RecvCryptoInfo.CachedKeyBuffer;
                        }
                    }
    
                    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
                    ("RC4 Recv encryption KeyLength %d", BundleCB->RecvCryptoInfo.SessionKeyLength));
                    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
                    ("RC4 Recv encryption Key %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x",
                        BundleCB->RecvCryptoInfo.SessionKey[0],
                        BundleCB->RecvCryptoInfo.SessionKey[1],
                        BundleCB->RecvCryptoInfo.SessionKey[2],
                        BundleCB->RecvCryptoInfo.SessionKey[3],
                        BundleCB->RecvCryptoInfo.SessionKey[4],
                        BundleCB->RecvCryptoInfo.SessionKey[5],
                        BundleCB->RecvCryptoInfo.SessionKey[6],
                        BundleCB->RecvCryptoInfo.SessionKey[7],
                        BundleCB->RecvCryptoInfo.SessionKey[8],
                        BundleCB->RecvCryptoInfo.SessionKey[9],
                        BundleCB->RecvCryptoInfo.SessionKey[10],
                        BundleCB->RecvCryptoInfo.SessionKey[11],
                        BundleCB->RecvCryptoInfo.SessionKey[12],
                        BundleCB->RecvCryptoInfo.SessionKey[13],
                        BundleCB->RecvCryptoInfo.SessionKey[14],
                        BundleCB->RecvCryptoInfo.SessionKey[15]));
    
                    // Re-initialize the rc4 receive table to the
                    // scrambled session key
                    //
                    rc4_key(RecvRC4Key, SessionKeyLength, SessionKey);
    
                    if(CurrCoherency < (USHORT)0x0FFF)
                    {
                        ++CurrCoherency;
                    }
                    else
                    {
                        CurrCoherency = 0;
                    }
                }
            }
        }

        if (SyncCoherency) {
            if ((BundleCB->RCoherencyCounter & 0x0FFF) >
                (Coherency & 0x0FFF)) {
                BundleCB->RCoherencyCounter += 0x1000;
            }
            
            BundleCB->RCoherencyCounter &= 0xF000;
            BundleCB->RCoherencyCounter |= (Coherency & 0x0FFF);
        }

        if ((Coherency & 0x0FFF) == (BundleCB->RCoherencyCounter & 0x0FFF)) {

            //
            // We are still in sync
            //

            BundleCB->RCoherencyCounter++;

            if (Coherency & (PACKET_ENCRYPTED << 8)) {

                //
                // This packet is encrypted
                //

                if (!(Flags & DO_ENCRYPTION)) {
                    //
                    // We are not configured to decrypt
                    //
                    return (FALSE);
                }

                //
                // Check for history less
                //

                if ((Flags & DO_HISTORY_LESS) ||
                    (BundleCB->RCoherencyCounter - BundleCB->LastRC4Reset)
                     >= 0x100) {
            
                    //
                    // It is time to change encryption keys
                    //
            
                    //
                    // Always align last reset on 0x100 boundary so as not to
                    // propagate error!
                    //
                    BundleCB->LastRC4Reset =
                        BundleCB->RCoherencyCounter & 0xFF00;
            
                    //
                    // Prevent ushort rollover
                    //
                    if ((BundleCB->LastRC4Reset & 0xF000) == 0xF000) {
                        BundleCB->LastRC4Reset &= 0x0FFF;
                        BundleCB->RCoherencyCounter &= 0x0FFF;
                    }

                    if (Flags & DO_LEGACY_ENCRYPTION) {
                        
                        //
                        // Change the session key
                        //
                        SessionKey[3] += 1;
                        SessionKey[4] += 3;
                        SessionKey[5] += 13;
                        SessionKey[6] += 57;
                        SessionKey[7] += 19;

                    } else {

                        //
                        // Change the session key
                        //
                        GetNewKeyFromSHA(&BundleCB->RecvCryptoInfo);
                    }


                    //
                    // We use rc4 to scramble and recover a new key
                    //

                    //
                    // Re-initialize the rc4 receive table to the
                    // intermediate value
                    //
                    rc4_key(RecvRC4Key, SessionKeyLength, SessionKey);
                
                    //
                    // Scramble the existing session key
                    //
                    rc4(RecvRC4Key, SessionKeyLength, SessionKey);

                    //
                    // If this is 40 bit encryption we need to fix
                    // the first 3 bytes of the key.
                    //

                    if (Flags & DO_40_ENCRYPTION) {
                        
                        //
                        // If this is 40 bit encryption we need to fix
                        // the first 3 bytes of the key.
                        //
                        SessionKey[0] = 0xD1;
                        SessionKey[1] = 0x26;
                        SessionKey[2] = 0x9E;
                
                    } else if (Flags & DO_56_ENCRYPTION) {
                        //
                        // If this is 56 bit encryption we need to fix
                        // the first byte of the key.
                        //
                        SessionKey[0] = 0xD1;
                    }

                    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
                    ("RC4 Recv encryption KeyLength %d", BundleCB->RecvCryptoInfo.SessionKeyLength));
                    NdisWanDbgOut(DBG_TRACE, DBG_CCP,
                    ("RC4 Recv encryption Key %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x",
                        BundleCB->RecvCryptoInfo.SessionKey[0],
                        BundleCB->RecvCryptoInfo.SessionKey[1],
                        BundleCB->RecvCryptoInfo.SessionKey[2],
                        BundleCB->RecvCryptoInfo.SessionKey[3],
                        BundleCB->RecvCryptoInfo.SessionKey[4],
                        BundleCB->RecvCryptoInfo.SessionKey[5],
                        BundleCB->RecvCryptoInfo.SessionKey[6],
                        BundleCB->RecvCryptoInfo.SessionKey[7],
                        BundleCB->RecvCryptoInfo.SessionKey[8],
                        BundleCB->RecvCryptoInfo.SessionKey[9],
                        BundleCB->RecvCryptoInfo.SessionKey[10],
                        BundleCB->RecvCryptoInfo.SessionKey[11],
                        BundleCB->RecvCryptoInfo.SessionKey[12],
                        BundleCB->RecvCryptoInfo.SessionKey[13],
                        BundleCB->RecvCryptoInfo.SessionKey[14],
                        BundleCB->RecvCryptoInfo.SessionKey[15]));

                    // Re-initialize the rc4 receive table to the
                    // scrambled session key
                    //
                    rc4_key(RecvRC4Key, SessionKeyLength, SessionKey);
            
            
                } // end of reset encryption key
            
                //
                // Decrypt the data!
                //
                rc4(RecvRC4Key,
                    FrameLength,
                    FramePointer);
                
            } // end of encryption


DECOMPRESS_DATA:

            if (Coherency & (PACKET_COMPRESSED << 8)) {

                //
                // This packet is compressed!
                //
                if (!(Flags & DO_COMPRESSION)) {
                    //
                    // We are not configured to decompress
                    //
                    return (FALSE);
                }

                //
                // Add up bundle stats
                //
                BundleStats->BytesReceivedCompressed += FrameLength;

                if (decompress(FramePointer,
                               FrameLength,
                               ((Coherency & (PACKET_AT_FRONT << 8)) >> 8),
                               &FramePointer,
                               &FrameLength,
                               RecvCompressContext) == FALSE) {

#if DBG
                    DbgPrint("dce1 %x\n", Coherency);
#endif
                    //
                    // Error decompressing!
                    //
                    if (!(Flags & DO_HISTORY_LESS)) {
                        BundleCB->RCoherencyCounter--;
                    }
                    goto RESYNC;

                }

                if (FrameLength <= 0 ||
                    FrameLength > (LONG)glMRRU) {
#if DBG
                    DbgPrint("dce2 %d %x\n", FrameLength, Coherency);
#endif
                    //
                    // Error decompressing!
                    //
                    if (!(Flags & DO_HISTORY_LESS)) {
                        BundleCB->RCoherencyCounter--;
                    }
                    goto RESYNC;
                    
                }

                BundleStats->BytesReceivedUncompressed += FrameLength;
                
            } // end of compression

        } else { // end of insync
RESYNC:


            NdisWanDbgOut(DBG_FAILURE, DBG_RECEIVE, ("oos r %x, e %x\n", (Coherency & 0x0FFF),
                     (BundleCB->RCoherencyCounter & 0x0FFF)));

            if (!(Flags & DO_HISTORY_LESS)) {

                //
                // We are out of sync!
                //
                do {
                    PLINKCB             LinkCB;
                    PNDISWAN_IO_PACKET  IoPacket;

                    if (BundleCB->ulLinkCBCount == 0) {
                        break;
                    }

                    NdisWanAllocateMemory(&IoPacket, 
                                          sizeof(NDISWAN_IO_PACKET) + 100, 
                                          IOPACKET_TAG);

                    if (IoPacket == NULL) {
                        break;
                    }

                    LinkCB = 
                        (PLINKCB)BundleCB->LinkCBList.Flink;

                    NdisDprAcquireSpinLock(&LinkCB->Lock);

                    if (LinkCB->State != LINK_UP) {
                        NdisDprReleaseSpinLock(&LinkCB->Lock);
                        NdisWanFreeMemory(IoPacket);
                        break;
                    }

                    REF_LINKCB(LinkCB);

                    NdisDprReleaseSpinLock(&LinkCB->Lock);

                    IoPacket->hHandle = BundleCB->hBundleHandle;
                    IoPacket->usHandleType = BUNDLEHANDLE;
                    IoPacket->usHeaderSize = 0;
                    IoPacket->usPacketSize = 6;
                    IoPacket->usPacketFlags = 0;
                    IoPacket->PacketData[0] = 0x80;
                    IoPacket->PacketData[1] = 0xFD;
                    IoPacket->PacketData[2] = 14;
                    IoPacket->PacketData[3] = (UCHAR)BundleCB->CCPIdentifier++;
                    IoPacket->PacketData[4] = 0x00;
                    IoPacket->PacketData[5] = 0x04;

                    LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;

                    BuildIoPacket(LinkCB, BundleCB, IoPacket, FALSE);

                    NdisWanFreeMemory(IoPacket);

                } while (FALSE);
            }

            return (FALSE);

        } // end of out of sync

    } else { // end of DoCompEncrypt

        //
        // For some reason we were not able to
        // decrypt/decompress!
        //
        return (FALSE);
    }

    *DataPointer = FramePointer;
    *DataLength = FrameLength;

    return (TRUE);
}

VOID
DoCompressionReset(
    PBUNDLECB   BundleCB
    )
{
    if (BundleCB->RecvCompInfo.MSCompType != 0) {
    
        //
        // The next outgoing packet will flush
        //
        BundleCB->Flags |= RECV_PACKET_FLUSH;
    }
}

VOID
NdisWanReceiveComplete(
    IN  NDIS_HANDLE NdisLinkContext
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("NdisWanReceiveComplete: Enter"));

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("NdisWanReceiveComplete: Exit"));
}

BOOLEAN
IpIsDataFrame(
    PUCHAR  HeaderBuffer,
    ULONG   HeaderBufferLength,
    ULONG   TotalLength
    )
{
    UINT        tcpheaderlength ;
    UINT        ipheaderlength ;
    UCHAR       *tcppacket;
    UCHAR       *ippacket = HeaderBuffer;
    UCHAR       SrcPort, DstPort;
    IPV4Header UNALIGNED *ipheader = (IPV4Header UNALIGNED *) HeaderBuffer;


#define TYPE_IGMP   2
    if (ipheader->ip_p == TYPE_IGMP) {

        if (gbIGMPIdle) {
            return FALSE;
        }

        return TRUE;
    }

    SrcPort = (UCHAR) *(ippacket + ((*ippacket & 0x0f)*4) + 1);
    DstPort = (UCHAR) *(ippacket + ((*ippacket & 0x0f)*4) + 3);

    if (DstPort == 53) {
        //
        // UDP/TCP port 53 - DNS
        //
        return FALSE;
    }

#define TYPE_UDP  17

#define UDPPACKET_SRC_PORT_137(x) ((UCHAR) *(x + ((*x & 0x0f)*4) + 1) == 137)
#define UDPPACKET_SRC_PORT_138(x) ((UCHAR) *(x + ((*x & 0x0f)*4) + 1) == 138)

    if (ipheader->ip_p == TYPE_UDP) {

        if ((SrcPort == 137) ||
            (SrcPort == 138)) {
    
            //
            // UDP port 137 - NETBIOS Name Service
            // UDP port 138 - NETBIOS Datagram Service
            //
            return FALSE ;
    
        } else {
    
            return TRUE ;
    
        }
    }

#define TYPE_TCP 6
#define TCPPACKET_SRC_OR_DEST_PORT_139(x,y) (((UCHAR) *(x + y + 1) == 139) || ((UCHAR) *(x + y + 3) == 139))

    //
    // TCP packets with SRC | DEST == 139 which are ACKs (0 data) or Session Alives
    // are considered as idle
    //
    if (ipheader->ip_p == TYPE_TCP) {

        ipheaderlength = ((UCHAR)*ippacket & 0x0f)*4 ;
        tcppacket = ippacket + ipheaderlength ;
        tcpheaderlength = (*(tcppacket + 10) >> 4)*4 ;

        //
        // If this is a PPTP keepalive packet then ignore
        //
        if (DstPort == 1723) {
            UNALIGNED PPTP_HEADER *PptpHeader;

            PptpHeader = (UNALIGNED PPTP_HEADER*)(tcppacket+tcpheaderlength);

            if (PptpHeader->PacketType == 1 &&
                (PptpHeader->MessageType == 5 ||
                 PptpHeader->MessageType == 6)) {

                return FALSE;

            }

            return TRUE;
        }

        if (!((SrcPort == 139) || (DstPort == 139)))
            return TRUE ;

        //
        //  NetBT traffic
        //
    
        //
        // if zero length tcp packet - this is an ACK on 139 - filter this.
        //
        if (TotalLength == (ipheaderlength + tcpheaderlength))
            return FALSE ;
    
        //
        // Session alives are also filtered.
        //
        if ((UCHAR) *(tcppacket+tcpheaderlength) == 0x85)
            return FALSE ;

        //
        // If this is a PPTP keep alive then ignore
        //

    }

    //
    // all other ip traffic is valid traffic
    //
    return TRUE ;
}

BOOLEAN
IpxIsDataFrame(
    PUCHAR  HeaderBuffer,
    ULONG   HeaderBufferLength,
    ULONG   TotalLength
    )
{

/*++

Routine Description:

    This routine is called when a frame is received on a WAN
    line. It returns TRUE unless:

    - The frame is from the RIP socket
    - The frame is from the SAP socket
    - The frame is a netbios keep alive
    - The frame is an NCP keep alive

Arguments:

    HeaderBuffer - points to a contiguous buffer starting at the IPX header.

    HeaderBufferLength - Length of the header buffer (could be same as totallength)

    TotalLength  - the total length of the frame

Return Value:

    TRUE - if this is a connection-based packet.

    FALSE - otherwise.

--*/

    IPX_HEADER UNALIGNED * IpxHeader = (IPX_HEADER UNALIGNED *)HeaderBuffer;
    USHORT SourceSocket;

    //
    // First get the source socket.
    //
    SourceSocket = IpxHeader->SourceSocket;

    //
    // Not connection-based
    //
    if ((SourceSocket == RIP_SOCKET) ||
        (SourceSocket == SAP_SOCKET)) {

         return FALSE;

    }

    //
    // See if there are at least two more bytes to look at.
    //
    if (TotalLength >= sizeof(IPX_HEADER) + 2) {

        if (SourceSocket == NB_SOCKET) {

            UCHAR ConnectionControlFlag;
            UCHAR DataStreamType;
            USHORT TotalDataLength;

            //
            // ConnectionControlFlag and DataStreamType will always follow
            // IpxHeader
            //
            ConnectionControlFlag = ((PUCHAR)(IpxHeader+1))[0];
            DataStreamType = ((PUCHAR)(IpxHeader+1))[1];

            //
            // If this is a SYS packet with or without a request for ACK and
            // has session data in it.
            //
            if (((ConnectionControlFlag == 0x80) || (ConnectionControlFlag == 0xc0)) &&
                (DataStreamType == 0x06)) {

                 //
                 // TotalDataLength is in the same buffer.
                 //
                 TotalDataLength = ((USHORT UNALIGNED *)(IpxHeader+1))[4];

                //
                // KeepAlive - return FALSE
                //
                if (TotalDataLength == 0) {
                    return FALSE;
                }
            }

        } else {

            //
            // Now see if it is an NCP keep alive. It can be from rip or from
            // NCP on this machine
            //
            if (TotalLength == sizeof(IPX_HEADER) + 2) {

                UCHAR KeepAliveSignature = ((PUCHAR)(IpxHeader+1))[1];

                if ((KeepAliveSignature == '?') ||
                    (KeepAliveSignature == 'Y')) {
                    return FALSE;
                }
            }
        }
    }

    //
    // This was a normal packet, so return TRUE
    //

    return TRUE;
}

BOOLEAN
NbfIsDataFrame(
    PUCHAR  HeaderBuffer,
    ULONG   HeaderBufferLength,
    ULONG   TotalLength
    )
{
/*++

Routine Description:

    This routine looks at a data packet from the net to deterimine if there is
    any data flowing on the connection.

Arguments:

    HeaderBuffer - Pointer to the dlc header for this packet.

    HeaderBufferLength - Length of the header buffer (could be same as totallength)

    TotalLength  - the total length of the frame

Return Value:

    True if this is a frame that indicates data traffic on the connection.
    False otherwise.

--*/

    PDLC_FRAME  DlcHeader = (PDLC_FRAME)HeaderBuffer;
    BOOLEAN Command = (BOOLEAN)!(DlcHeader->Ssap & DLC_SSAP_RESPONSE);
    PNBF_HDR_CONNECTION nbfHeader;

    if (TotalLength < sizeof(PDLC_FRAME)) {
        return(FALSE);
    }

    if (!(DlcHeader->Byte1 & DLC_I_INDICATOR)) {

        //
        // We have an I frame.
        //

        if (TotalLength < 4 + sizeof(NBF_HDR_CONNECTION)) {

            //
            // It's a runt I-frame.
            //

            return(FALSE);
        }

        nbfHeader = (PNBF_HDR_CONNECTION) ((PUCHAR)DlcHeader + 4);

        switch (nbfHeader->Command) {
            case NBF_CMD_DATA_FIRST_MIDDLE:
            case NBF_CMD_DATA_ONLY_LAST:
            case NBF_CMD_DATA_ACK:
            case NBF_CMD_SESSION_CONFIRM:
            case NBF_CMD_SESSION_INITIALIZE:
            case NBF_CMD_NO_RECEIVE:
            case NBF_CMD_RECEIVE_OUTSTANDING:
            case NBF_CMD_RECEIVE_CONTINUE:
                return(TRUE);
                break;

            default:
                return(FALSE);
                break;
        }
    }
    return(FALSE);

}

VOID
IndicatePromiscuousRecv(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc,
    RECV_TYPE   RecvType
    )
{
    UCHAR   Header1[] = {' ', 'W', 'A', 'N', 'R', 0xFF, ' ', 'W', 'A', 'N', 'R', 0xFF};
    PUCHAR  HeaderBuffer, DataBuffer;
    ULONG   HeaderLength, DataLength;
    PNDIS_BUFFER    NdisBuffer;
    PNDIS_PACKET    NdisPacket;
    PRECV_DESC      LocalRecvDesc;
    PLINKCB         LinkCB = RecvDesc->LinkCB;
    KIRQL           OldIrql;
    PMINIPORTCB     Adapter;

    NdisAcquireSpinLock(&NdisWanCB.Lock);
    Adapter = NdisWanCB.PromiscuousAdapter;
    NdisReleaseSpinLock(&NdisWanCB.Lock);

    if (Adapter == NULL) {
        return;
    }

    DataLength = (RecvDesc->CurrentLength > (LONG)glLargeDataBufferSize) ? 
        glLargeDataBufferSize : RecvDesc->CurrentLength;

    LocalRecvDesc = 
        NdisWanAllocateRecvDesc(DataLength + MAC_HEADER_LENGTH);

    if (LocalRecvDesc == NULL) {
        return;
    }

    HeaderBuffer = 
        LocalRecvDesc->StartBuffer;

    HeaderLength = 0;

    switch (RecvType) {
    case RECV_LINK:
        NdisMoveMemory(HeaderBuffer, Header1, sizeof(Header1));
        HeaderBuffer[5] =
        HeaderBuffer[11] = (UCHAR)LinkCB->hLinkHandle;
    
        HeaderBuffer[12] = (UCHAR)(DataLength >> 8);
        HeaderBuffer[13] = (UCHAR)DataLength;
        HeaderLength = MAC_HEADER_LENGTH;
        break;

    case RECV_BUNDLE_PPP:
    case RECV_BUNDLE_DATA:
        break;
        
    }

    DataBuffer = HeaderBuffer + HeaderLength;

    NdisMoveMemory(DataBuffer,
                   RecvDesc->CurrentBuffer,
                   DataLength);

    LocalRecvDesc->CurrentBuffer = HeaderBuffer;
    LocalRecvDesc->CurrentLength = HeaderLength + DataLength;

    if (LocalRecvDesc->CurrentLength > 1514) {
        LocalRecvDesc->CurrentLength = 1514;
    }

    //
    // Get an ndis packet
    //
    NdisPacket =
        LocalRecvDesc->NdisPacket;

    PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->RecvDesc = LocalRecvDesc;

    //
    // Attach the buffers
    //
    NdisAdjustBufferLength(LocalRecvDesc->NdisBuffer,
                           LocalRecvDesc->CurrentLength);

    NdisRecalculatePacketCounts(NdisPacket);

    ReleaseBundleLock(BundleCB);

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    NDIS_SET_PACKET_STATUS(NdisPacket, NDIS_STATUS_RESOURCES);

    INSERT_DBG_RECV(PacketTypeNdis,
                    Adapter,
                    NULL,
                    RecvDesc->LinkCB,
                    NdisPacket);

    //
    // Indicate the packet
    // This assumes that bloodhound is always a legacy transport
    //
    NdisMIndicateReceivePacket(Adapter->MiniportHandle,
                               &NdisPacket,
                               1);

    KeLowerIrql(OldIrql);

    AcquireBundleLock(BundleCB);

#if DBG
    {
    NDIS_STATUS     Status;

    Status = NDIS_GET_PACKET_STATUS(NdisPacket);

    ASSERT(Status == NDIS_STATUS_RESOURCES);

    REMOVE_DBG_RECV(PacketTypeNdis, Adapter, NdisPacket);

    }
#endif


    {
        

        NdisWanFreeRecvDesc(LocalRecvDesc);
    }

}

BOOLEAN
GetProtocolFromPPPId(
    PBUNDLECB   BundleCB,
    USHORT      Id,
    PPROTOCOLCB *ProtocolCB
    )
{
    PPROTOCOLCB     ppcb;
    BOOLEAN         Found;

    *ProtocolCB = NULL;

    ppcb = (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;
    Found = FALSE;

    while ((PVOID)ppcb != (PVOID)&BundleCB->ProtocolCBList) {

        if (ppcb->State == PROTOCOL_ROUTED) {
            if (ppcb->PPPProtocolID == Id) {
                *ProtocolCB = ppcb;
                Found = TRUE;
                break;
            }
        }

        ppcb = (PPROTOCOLCB)ppcb->Linkage.Flink;
    }

    return (Found);
}

#ifdef NT

NDIS_STATUS
CompleteIoRecvPacket(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc
    )
{
    KIRQL       Irql;
    USHORT      ProtocolID;
    UCHAR       Header[] = {' ', 'R', 'E', 'C', 'V', 0xFF};
    PNDISWAN_IO_PACKET  IoPacket;
    PIO_STACK_LOCATION IrpSp;
    PIRP    Irp;
    LONG    CopySize, BufferLength, DataLength;
    PLIST_ENTRY Entry;
    PUCHAR  HeaderPointer;
    PLINKCB LinkCB = RecvDesc->LinkCB;

    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("CompleteIoRecvPacket: Enter"));

    HeaderPointer = 
        RecvDesc->StartBuffer;

    ProtocolID = RecvDesc->ProtocolID;

    //
    // Fill the frame out, and queue the data
    //
    NdisMoveMemory(HeaderPointer,
                   Header,
                   sizeof(Header));

    NdisMoveMemory(&HeaderPointer[6],
                   Header,
                   sizeof(Header));

    HeaderPointer[5] =
    HeaderPointer[11] = (UCHAR)LinkCB->hLinkHandle;

    HeaderPointer[12] = (UCHAR)(ProtocolID >> 8);
    HeaderPointer[13] = (UCHAR)ProtocolID;

    NdisMoveMemory(HeaderPointer + 14,
                   RecvDesc->CurrentBuffer,
                   RecvDesc->CurrentLength);

    RecvDesc->CurrentBuffer = RecvDesc->StartBuffer;
    RecvDesc->CurrentLength += 14;

#if DBG
if (gbDumpRecv) {
    
    INT i;
    DbgPrint("RecvData:");
    for (i = 0; i < RecvDesc->CurrentLength; i++) {
        if (i % 16 == 0) {
            DbgPrint("\n");
        }
        DbgPrint("%2.2x ", RecvDesc->CurrentBuffer[i]);
    }
    DbgPrint("\n");
}
#endif

    ReleaseBundleLock(BundleCB);

    //
    // See if someone has registered a recv context
    // for this link or if there are any irps around
    // to complete take this receive
    //

    NdisAcquireSpinLock(&IoRecvList.Lock);

    NdisDprAcquireSpinLock(&LinkCB->Lock);

    Entry = IoRecvList.IrpList.Flink;
    Irp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

    if ((LinkCB->hLinkContext == NULL) ||
        (LinkCB->RecvDescCount > 0) ||
        (IoRecvList.ulIrpCount == 0) ||
        !IoSetCancelRoutine(Irp, NULL)) {
        NDIS_STATUS Status;

        //
        // We will only buffer 5 packets for each link to avoid
        // chewing up tons of non-paged memory if rasman is not
        // reading at all.
        //
        if ((LinkCB->State == LINK_UP) &&
            (LinkCB->RecvDescCount < 5)) {
            
            InsertTailList(&IoRecvList.DescList,
                           &RecvDesc->Linkage);

            LinkCB->RecvDescCount++;

            IoRecvList.ulDescCount++;

            if (IoRecvList.ulDescCount > IoRecvList.ulMaxDescCount) {
                IoRecvList.ulMaxDescCount = IoRecvList.ulDescCount;
            }

            Status = NDIS_STATUS_PENDING;

        } else {

            Status = NDIS_STATUS_FAILURE;
        }

        NdisDprReleaseSpinLock(&LinkCB->Lock);

        NdisReleaseSpinLock(&IoRecvList.Lock);

        AcquireBundleLock(BundleCB);

        return(Status);
    }

    RemoveHeadList(&IoRecvList.IrpList);
    IoRecvList.ulIrpCount--;

    INSERT_RECV_EVENT('a');

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
        
    BufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    DataLength = BufferLength - sizeof(NDISWAN_IO_PACKET) + 1;
        
    CopySize = (RecvDesc->CurrentLength > DataLength) ?
        DataLength : RecvDesc->CurrentLength;

    IoPacket = Irp->AssociatedIrp.SystemBuffer;
        
    IoPacket->hHandle = LinkCB->hLinkContext;
    IoPacket->usHandleType = LINKHANDLE;
    IoPacket->usHeaderSize = 14;
    IoPacket->usPacketSize = (USHORT)CopySize;
    IoPacket->usPacketFlags = 0;
    
#if DBG
if (gbDumpRecv) {
    INT i;
    for (i = 0; i < RecvDesc->CurrentLength; i++) {
        if (i % 16 == 0) {
            DbgPrint("\n");
        }
        DbgPrint("%x ", RecvDesc->CurrentBuffer[i]);
    }
    DbgPrint("\n");
}
#endif

    NdisMoveMemory(IoPacket->PacketData,
                   RecvDesc->CurrentBuffer,
                   CopySize);
    
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof(NDISWAN_IO_PACKET) - 1 + CopySize;

    IoRecvList.LastPacketNumber = IoPacket->PacketNumber;
    IoRecvList.LastIrp = Irp;
    IoRecvList.LastIrpStatus = STATUS_SUCCESS;
    IoRecvList.LastCopySize = (ULONG)Irp->IoStatus.Information;

    ASSERT((LONG_PTR)Irp->IoStatus.Information > 0);
    
    NdisDprReleaseSpinLock(&LinkCB->Lock);

    NdisReleaseSpinLock(&IoRecvList.Lock);

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    
    AcquireBundleLock(BundleCB);

    if (NdisWanCB.PromiscuousAdapter != NULL) {
    
        IndicatePromiscuousRecv(BundleCB, RecvDesc, RECV_BUNDLE_PPP);
    }
        
    NdisWanDbgOut(DBG_TRACE, DBG_RECEIVE, ("CompleteIoRecvPacket: Exit"));

    return(NDIS_STATUS_SUCCESS);
}


#endif // end ifdef NT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\tcpip.h ===
// TCP control bits

#ifndef _TCPIP_
#define _TCPIP_

#define TH_SYN      0x02    // Synchronize sequence numbers
#define TH_FIN      0x01    // Sender has reached end of his stream
#define TH_RST      0x04    // Reset the connection
#define TH_PUSH     0x08    // Push data to above level
#define TH_ACK      0x10    // Acknowledgement field is valid
#define TH_URG      0x20    // Urgent pointer is valid

struct tcphdr {
    USHORT  th_sport;
    USHORT  th_dport;
    ULONG   th_seq;
    ULONG   th_ack;
    UCHAR   th_off;
    UCHAR   th_flags;
    USHORT  th_win;
    UCHAR   th_sumhi;
    UCHAR   th_sumlo;
    USHORT  th_urp;
    UCHAR   th_data[1];
};

#define IP_ALEN 4

typedef struct IPaddr {
    ULONG   s_addr;
} IPaddr;

#define IPPROTO_TCP 6

struct ip_v4 {

    UCHAR   ip_hl;
    UCHAR   ip_tos;
    USHORT  ip_len;
    USHORT  ip_id;
    USHORT  ip_off;
    UCHAR   ip_ttl;
    UCHAR   ip_p;
    USHORT  ip_sum;
    IPaddr  ip_src;
    IPaddr  ip_dst;
    UCHAR   ip_data[1];
};

typedef struct ip_v4 IPV4Header, *PIPV4Header;

typedef struct _PPTP_HEADER {
    USHORT  Length;
    USHORT  PacketType;
    ULONG   Cookie;
    USHORT  MessageType;
    USHORT  Reserved1;
} PPTP_HEADER, *PPPTP_HEADER;


#endif // _TCPIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\send.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Send.c

Abstract:

    This file contains the procedures for doing a send from a protocol, bound
    to the upper interface of NdisWan, to a Wan Miniport link, bound to the
    lower interfaceof NdisWan.  The upper interface of NdisWan conforms to the
    NDIS 3.1 Miniport specification.  The lower interface of NdisWan conforms
    to the NDIS 3.1 Extentions for Wan Miniport drivers.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "wan.h"

#ifdef DBG_SENDARRAY
UCHAR   SendArray[MAX_BYTE_DEPTH] = {0};
ULONG   __si = 0;
#endif

#define __FILE_SIG__    SEND_FILESIG

//
// Local function prototypes
//
USHORT
DoVJHeaderCompression(
    PBUNDLECB   BundleCB,
    PNDIS_PACKET    NdisPacket,
    PUCHAR      *CurrentBuffer,
    PULONG      CurrentLength,
    PULONG      PacketOffset
    );

VOID
DoCompressionEncryption(
    PBUNDLECB               BundleCB,
    PHEADER_FRAMING_INFO    FramingInfo,
    PSEND_DESC              *SendDesc
    );

VOID
FragmentAndQueue(
    PBUNDLECB               BundleCB,
    PHEADER_FRAMING_INFO    FramingInfo,
    PSEND_DESC              SendDesc,
    PLIST_ENTRY             LinkCBList,
    ULONG                   SendingLinks
    );

ULONG
GetSendingLinks(
    PBUNDLECB   BundleCB,
    INT         Class,
    PLIST_ENTRY lcbList
    );

VOID
GetNextProtocol(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB *ProtocolCB,
    PULONG      SendMask
    );

VOID
BuildLinkHeader(
    PHEADER_FRAMING_INFO    FramingInfo,
    PSEND_DESC              SendDesc
    );

//
// end of local function prototypes
//
VOID
NdisWanQueueSend(
    IN  PMINIPORTCB     MiniportCB,
    IN  PNDIS_PACKET    NdisPacket
    )
{
    PNDIS_BUFFER    NdisBuffer;
    UINT            BufferCount, PacketLength;
    PETH_HEADER     EthernetHeader;
    BOOLEAN         SendOnWire = FALSE;
    BOOLEAN         CompletePacket = FALSE;
    ULONG           BufferLength;
    PUCHAR          DestAddr, SrcAddr;
    PBUNDLECB       BundleCB = NULL;
    PPROTOCOLCB     ProtocolCB = NULL;
    PCM_VCCB        CmVcCB = NULL;
    INT             Class;
    PPACKET_QUEUE   PacketQueue;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("NdisWanQueueSend: Enter"));

    NdisWanInterlockedInc(&glSendCount);

    NdisQueryPacket(NdisPacket,
        NULL,
        &BufferCount,
        &NdisBuffer,
        &PacketLength);

    if(NdisBuffer != NULL)        
    {
        NdisQueryBuffer(NdisBuffer,
                        &EthernetHeader,
                        &BufferLength);
    }                    

    CmVcCB = PMINIPORT_RESERVED_FROM_NDIS(NdisPacket)->CmVcCB;

    if (BufferCount == 0 || BufferLength < 14) {

        //
        // Malformed packet!
        //
        CompletePacket = TRUE;

        goto QUEUE_SEND_EXIT;
    }

    DestAddr = EthernetHeader->DestAddr;
    SrcAddr = EthernetHeader->SrcAddr;

    //
    // Is this destined for the wire or is it self directed?
    // If SendOnWire is FALSE this is a self directed packet.
    //
    ETH_COMPARE_NETWORK_ADDRESSES_EQ(DestAddr, SrcAddr, &SendOnWire);

    //
    // Do we need to do loopback?  We can check for both multicast
    // and broadcast with one check because we don't differentiate
    // between the two.
    //
    if (!SendOnWire || (DestAddr[0] & 1)) {
        NdisWanIndicateLoopbackPacket(MiniportCB, NdisPacket);
    }

    //
    // We don't want to send packets from bloodhound
    //
    if (!SendOnWire ||
        (MiniportCB == NdisWanCB.PromiscuousAdapter)) {

        CompletePacket = TRUE;

        goto QUEUE_SEND_EXIT;
    }

    //
    // We play special tricks with NBF because NBF is
    // guaranteed to have a one-to-one mapping between
    // an adapter and a bundle.  We need to do this because
    // we may need the mac address information.
    //
    if (MiniportCB->ProtocolType == PROTOCOL_NBF) {

        ProtocolCB = MiniportCB->NbfProtocolCB;

        if (ProtocolCB == NULL) {

            //
            // This should just fall through and complete successfully.
            //
            NdisWanDbgOut(DBG_TRACE, DBG_SEND,
                ("NdisWanSend: Invalid ProtocolCB %x! Miniport %p, ProtoType %x",
                ProtocolCB, MiniportCB, MiniportCB->ProtocolType));

            CompletePacket = TRUE;

            goto QUEUE_SEND_EXIT;
        }

        BundleCB = ProtocolCB->BundleCB;

        if (BundleCB == NULL) {
            //
            // This should just fall through and complete successfully.
            //
            NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
                ("NdisWanSend: Invalid Bundle!"));

            NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
                ("NdisWanSend: MiniportCB: 0x%p, ProtocolType: 0x%x!", MiniportCB, MiniportCB->ProtocolType));

            CompletePacket = TRUE;

            goto QUEUE_SEND_EXIT;
        }

        AcquireBundleLock(BundleCB);

        if (BundleCB->State != BUNDLE_UP) {

            //
            // This should just fall through and complete successfully.
            //
            NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
                ("NdisWanSend: Invalid BundleState 0x%x", BundleCB->State));

            NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
                ("NdisWanSend: MiniportCB: 0x%p, ProtocolType: 0x%x!", MiniportCB, MiniportCB->ProtocolType));

            CompletePacket = TRUE;

            ReleaseBundleLock(BundleCB);

            BundleCB = NULL;

            goto QUEUE_SEND_EXIT;
        }

        REF_BUNDLECB(BundleCB);

    } else {
        ULONG_PTR   BIndex, PIndex;

        //
        // Get the ProtocolCB from the DestAddr
        //
        GetNdisWanIndices(DestAddr, BIndex, PIndex);

        if (!IsBundleValid((NDIS_HANDLE)BIndex, 
                           TRUE,
                           &BundleCB)) {
            //
            // This should just fall through and complete successfully.
            //
            NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
                ("NdisWanSend: BundleCB is not valid!, BundleHandle: 0x%x", BIndex));
            NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
                ("NdisWanSend: MiniportCB: 0x%p, ProtocolType: 0x%x!", MiniportCB, MiniportCB->ProtocolType));

            CompletePacket = TRUE;

            goto QUEUE_SEND_EXIT;
        }

        AcquireBundleLock(BundleCB);

        PROTOCOLCB_FROM_PROTOCOLH(BundleCB, ProtocolCB, PIndex);
    }

    if (ProtocolCB == NULL ||
        ProtocolCB == RESERVED_PROTOCOLCB) {
        //
        // This should just fall through and complete successfully.
        //
        NdisWanDbgOut(DBG_TRACE, DBG_SEND,
            ("NdisWanSend: Invalid ProtocolCB %x! Miniport %p, ProtoType %x",
            ProtocolCB, MiniportCB, MiniportCB->ProtocolType));

        CompletePacket = TRUE;

        ReleaseBundleLock(BundleCB);

        goto QUEUE_SEND_EXIT;
    }

    if (ProtocolCB->State != PROTOCOL_ROUTED) {

        NdisWanDbgOut(DBG_FAILURE, DBG_SEND,("NdisWanSend: Problem with route!"));

        NdisWanDbgOut(DBG_FAILURE, DBG_SEND,
            ("NdisWanSend: ProtocolCB: 0x%p, State: 0x%x",
            ProtocolCB, ProtocolCB->State));

        CompletePacket = TRUE;

        ReleaseBundleLock(BundleCB);

        goto QUEUE_SEND_EXIT;
    }

    //
    // For the packet that we are inserting
    //
    REF_PROTOCOLCB(ProtocolCB);

    NdisInterlockedIncrement(&ProtocolCB->OutstandingFrames);

    //
    // Queue the packet on the ProtocolCB NdisPacketQueue
    //
    Class = (CmVcCB != NULL) ? CmVcCB->FlowClass : 0;

    NDIS_SET_PACKET_STATUS(NdisPacket, NDIS_STATUS_PENDING);

    ASSERT(Class <= MAX_MCML);

    PacketQueue = &ProtocolCB->PacketQueue[Class];

    INSERT_DBG_SEND(PacketTypeNdis,
                    MiniportCB,
                    ProtocolCB,
                    NULL,
                    NdisPacket);

    InsertTailPacketQueue(PacketQueue, NdisPacket, PacketLength);

#ifdef DBG_SENDARRAY
{
    if (Class < MAX_MCML) {
        SendArray[__si] = 'P';
    } else {
        SendArray[__si] = 'Q';
    }
    if (++__si == MAX_BYTE_DEPTH) {
        __si = 0;
    }
}
#endif

    if (PacketQueue->ByteDepth > PacketQueue->MaxByteDepth) {
        //
        // We have queue more then we should so lets flush
        // This alogrithm should be fancied up at some point
        // to use Random Early Detection!!!!!
        //
        NdisPacket =
            RemoveHeadPacketQueue(PacketQueue);

        if (NdisPacket != NULL) {
            PacketQueue->DumpedPacketCount++;
            PacketQueue->DumpedByteCount +=
                (NdisPacket->Private.TotalLength - 14);
            ReleaseBundleLock(BundleCB);
            CompleteNdisPacket(ProtocolCB->MiniportCB,
                               ProtocolCB,
                               NdisPacket);
            AcquireBundleLock(BundleCB);
        }
    }

    //
    // If we are cleared to send data then
    // try to process the protocol queues
    //
    if (!(BundleCB->Flags & PAUSE_DATA)) {
        SendPacketOnBundle(ProtocolCB->BundleCB);
    } else {
        ReleaseBundleLock(BundleCB);
    }


QUEUE_SEND_EXIT:

    if (CompletePacket) {
        NDIS_SET_PACKET_STATUS(NdisPacket, NDIS_STATUS_SUCCESS);

        if (CmVcCB != NULL) {
            NdisMCoSendComplete(NDIS_STATUS_SUCCESS,
                CmVcCB->NdisVcHandle,
                NdisPacket);

            DEREF_CMVCCB(CmVcCB);

        } else {
            NdisMSendComplete(MiniportCB->MiniportHandle,
                NdisPacket,
                NDIS_STATUS_SUCCESS);
        }

        NdisWanInterlockedInc(&glSendCompleteCount);
    }

    //
    // Deref for ref applied in IsBundleValid
    //
    DEREF_BUNDLECB(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("NdisWanQueueSend: Exit"));
}


VOID
SendPacketOnBundle(
    PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

    Called with bundle lock held but returns with lock released!!!

Arguments:

Return Values:

--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_PENDING;
    ULONG           SendMask;
    PPROTOCOLCB     ProtocolCB, IOProtocolCB;
    BOOLEAN         PPPSent;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendPacketOnBundle: Enter"));

    //
    // Are we already involved in a send on this bundlecb?
    //
    if (BundleCB->Flags & IN_SEND) {

        //
        // If so flag that we should try back later
        // and get the out.
        //
        BundleCB->Flags |= TRY_SEND_AGAIN;

        ReleaseBundleLock(BundleCB);

        return;
    }

    BundleCB->Flags |= IN_SEND;

    IOProtocolCB = BundleCB->IoProtocolCB;

TryAgain:

    SendMask = BundleCB->SendMask;

    //
    // If the bundle is not up we will not send!
    //
    if (BundleCB->State != BUNDLE_UP) {
        goto TryNoMore;
    }

    do {
        BOOLEAN PacketSent = FALSE;
        BOOLEAN CouldSend;

        //
        // First try to send from the PPP send queue
        //
        do {

            CouldSend =
                SendFromPPP(BundleCB, IOProtocolCB, &PPPSent);

        } while (PPPSent);


        //
        // If we could not send a PPP frame get out
        //
        if (!CouldSend) {
            break;
        }

        //
        // This will force round-robin sends
        //
        GetNextProtocol(BundleCB, &ProtocolCB, &SendMask);

        if (ProtocolCB != NULL) {

            REF_PROTOCOLCB(ProtocolCB);

            if (BundleCB->Flags & QOS_ENABLED) {

                if (BundleCB->Flags & SEND_FRAGMENT) {
SendQosFrag:
                    //
                    // Send a single fragment from the fragment queue
                    //
                    CouldSend =
                        SendFromFragQueue(BundleCB,
                                          TRUE,
                                          &PacketSent);
                    if (CouldSend) {
                        BundleCB->Flags &= ~(SEND_FRAGMENT);
                    }
                }

                //
                // If we sent a fragment let the completion
                // handler send the next frame.
                //
                if (!PacketSent) {

                    //
                    // Now try the protocol's packet queues
                    //
                    if (SendMask != 0) {
                        INT Class;
                        INT i;

                        for (i = 0; i <= MAX_MCML; i++) {

                            CouldSend =
                                SendFromProtocol(BundleCB,
                                                 ProtocolCB,
                                                 &Class,
                                                 &SendMask,
                                                 &PacketSent);

                            if (!CouldSend) {
                                break;
                            }

                            BundleCB->Flags |= (SEND_FRAGMENT);

                            if (PacketSent) {
                                break;
                            }
                        }

                        if (!PacketSent ||
                            (PacketSent && (Class != MAX_MCML))) {

                            goto SendQosFrag;
                        }
                    }
                }

            } else {

                //
                // Now try the protocol's packet queues
                //
                if (SendMask != 0) {
                    INT Class;
                    INT i;

                    for (i = 0; i <= MAX_MCML; i++) {

                        CouldSend =
                            SendFromProtocol(BundleCB,
                                             ProtocolCB,
                                             &Class,
                                             &SendMask,
                                             &PacketSent);

                    }
                }

                SendFromFragQueue(BundleCB,
                                  FALSE,
                                  &PacketSent);
            }

            DEREF_PROTOCOLCB(ProtocolCB);
        }

    } while ((SendMask != 0) &&
             (BundleCB->State == BUNDLE_UP));

TryNoMore:

    //
    // Did someone try to do a send while we were already
    // sending on this bundle?
    //
    if (BundleCB->Flags & TRY_SEND_AGAIN) {

        //
        // If so clear the flag and try another send.
        //
        BundleCB->Flags &= ~TRY_SEND_AGAIN;

        goto TryAgain;

    }

#ifdef DBG_SENDARRAY
{
    SendArray[__si] = 'Z';
    if (++__si == MAX_BYTE_DEPTH) {
        __si = 0;
    }
}
#endif

    //
    // Clear the in send flag.
    //
    BundleCB->Flags &= ~IN_SEND;

    ReleaseBundleLock(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendPacketOnBundle: Exit"));
}

BOOLEAN
SendFromPPP(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB,
    PBOOLEAN    PacketSent
    )
{
    PLINKCB         LinkCB;
    PNDIS_PACKET    NdisPacket;
    PPACKET_QUEUE   PacketQueue;
    INT             SendingClass;
    BOOLEAN         CouldSend;
    ULONG           BytesSent;

    PacketQueue = &ProtocolCB->PacketQueue[MAX_MCML];

    CouldSend = TRUE;
    *PacketSent = FALSE;

    while (!IsPacketQueueEmpty(PacketQueue)) {
        LIST_ENTRY  LinkCBList;
        ULONG       SendingLinks;

        NdisPacket = PacketQueue->HeadQueue;

        LinkCB = 
            PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->LinkCB;

        NdisAcquireSpinLock(&LinkCB->Lock);

        if (LinkCB->State != LINK_UP) {

            NdisReleaseSpinLock(&LinkCB->Lock);

            NdisReleaseSpinLock(&BundleCB->Lock);

            DEREF_LINKCB(LinkCB);

            NdisAcquireSpinLock(&BundleCB->Lock);

            //
            // The link has gone down since this send was
            // queued so destroy the packet
            //
            RemoveHeadPacketQueue(PacketQueue);
            FreeIoNdisPacket(NdisPacket);
            continue;
        }

        if (!LinkCB->SendWindowOpen) {
            //
            // We can not send from the I/O queue because the send
            // window for this link is closed.  We will not send
            // any data until the link has resources!
            //
            CouldSend = FALSE;

            NdisReleaseSpinLock(&LinkCB->Lock);

            break;
        }

        NdisReleaseSpinLock(&LinkCB->Lock);

        //
        // Build the linkcb send list
        //
        InitializeListHead(&LinkCBList);
        InsertHeadList(&LinkCBList, &LinkCB->SendLinkage);
        SendingLinks = 1;

        //
        // We are sending this packet so take it off of the list
        //
        RemoveHeadPacketQueue(PacketQueue);

        SendingClass = MAX_MCML;

        ASSERT(NdisPacket != NULL);
        ASSERT(ProtocolCB != NULL);

        //
        // We we get here we should have a valid NdisPacket with at least one link
        // that is accepting sends
        //

        //
        // We will get the packet into a contiguous buffer, and do framing,
        // compression and encryption.
        //
        REF_BUNDLECB(BundleCB);
        BytesSent = FramePacket(BundleCB,
                                ProtocolCB,
                                NdisPacket,
                                &LinkCBList,
                                SendingLinks,
                                SendingClass);
        *PacketSent = TRUE;
    }

    return (CouldSend);
}

BOOLEAN
SendFromProtocol(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB,
    PINT        RetClass,
    PULONG      SendMask,
    PBOOLEAN    PacketSent
    )
{
    ULONG           BytesSent;
    BOOLEAN         CouldSend;
    PNDIS_PACKET    NdisPacket;
    PPACKET_QUEUE   PacketQueue;
    INT             Class;
    LIST_ENTRY      LinkCBList;
    ULONG           SendingLinks;

    CouldSend = TRUE;
    *PacketSent = FALSE;
    InitializeListHead(&LinkCBList);

    ASSERT(ProtocolCB != NULL);

    do {

        Class = ProtocolCB->NextPacketClass;

        *RetClass = Class;

        *SendMask &= ~(ProtocolCB->SendMaskBit);

        PacketQueue =
            &ProtocolCB->PacketQueue[Class];

        if (IsPacketQueueEmpty(PacketQueue)) {
            break;
        }

        if (BundleCB->Flags & QOS_ENABLED) {

            if ((Class < MAX_MCML) &&
                (PacketQueue->OutstandingFrags != 0)) {
                break;
            }

        } else {

            if (BundleCB->SendingLinks == 0) {
                break;
            }
        }

        //
        // Build a list of linkcb's that can be sent over
        //

        SendingLinks =
            GetSendingLinks(BundleCB, Class, &LinkCBList);

        //
        // If there are no links/resources available
        // to send over then get out
        //
        if (SendingLinks == 0) {
            CouldSend = FALSE;
            break;
        }

        NdisPacket =
            RemoveHeadPacketQueue(PacketQueue);

        ASSERT(NdisPacket != NULL);

        *PacketSent = TRUE;

        if (!(BundleCB->Flags & QOS_ENABLED)) {
            *SendMask |= ProtocolCB->SendMaskBit;
        }

        //
        // We we get here we should have a valid NdisPacket with at least one link
        // that is accepting sends
        //
        //
        // We will get the packet into a contiguous buffer, and do framing,
        // compression and encryption.
        //
        REF_BUNDLECB(BundleCB);
        BytesSent = FramePacket(BundleCB,
                                ProtocolCB,
                                NdisPacket,
                                &LinkCBList,
                                SendingLinks,
                                Class);
#ifdef DBG_SENDARRAY
{
    if (Class < MAX_MCML) {
        SendArray[__si] = 'p';
    } else {
        SendArray[__si] = 'q';
    }
    if (++__si == MAX_BYTE_DEPTH) {
        __si = 0;
    }
}
#endif

    } while (FALSE);

    if (CouldSend) {
        ProtocolCB->NextPacketClass += 1;

        if (ProtocolCB->NextPacketClass > MAX_MCML) {
            ProtocolCB->NextPacketClass = 0;
        }
    }

    //
    // If there are any LinkCB's still on the send list
    // we have to remove the reference from them
    //
    if (!IsListEmpty(&LinkCBList)) {
        PLIST_ENTRY le;
        PLINKCB lcb;

        ReleaseBundleLock(BundleCB);

        //
        // unroll the loop so that the correct link
        // is setup for the next link to xmit
        //
        le = RemoveHeadList(&LinkCBList);
        lcb = CONTAINING_RECORD(le, LINKCB, SendLinkage);

        BundleCB->NextLinkToXmit = lcb;

        DEREF_LINKCB(lcb);

        while (!IsListEmpty(&LinkCBList)) {

            le = RemoveHeadList(&LinkCBList);
            lcb = CONTAINING_RECORD(le, LINKCB, SendLinkage);

            DEREF_LINKCB(lcb);

        }

        AcquireBundleLock(BundleCB);
    }

    return (CouldSend);
}

BOOLEAN
SendFromFragQueue(
    PBUNDLECB   BundleCB,
    BOOLEAN     SendOne,
    PBOOLEAN    FragSent
    )
{
    ULONG           i;
    BOOLEAN         CouldSend;

    CouldSend = TRUE;
    *FragSent = FALSE;

    for (i = 0; i < MAX_MCML; i++) {
        PSEND_DESC  SendDesc;
        PSEND_FRAG_INFO FragInfo;
        PLINKCB         LinkCB;

        FragInfo =
            &BundleCB->SendFragInfo[BundleCB->NextFragClass];

        BundleCB->NextFragClass += 1;

        if (BundleCB->NextFragClass == MAX_MCML) {
            BundleCB->NextFragClass = 0;
        }

        if (FragInfo->FragQueueDepth == 0) {
            continue;
        }

        SendDesc = (PSEND_DESC)FragInfo->FragQueue.Flink;

        LinkCB = SendDesc->LinkCB;

        while ((PVOID)SendDesc != (PVOID)&FragInfo->FragQueue) {
            ULONG   BytesSent;

            if (!LinkCB->SendWindowOpen) {
                //
                // We can't send on this link!
                //
                CouldSend = FALSE;
                SendDesc = (PSEND_DESC)SendDesc->Linkage.Flink;
                LinkCB = SendDesc->LinkCB;
                FragInfo->WinClosedCount++;
                continue;
            }

            CouldSend = TRUE;

            RemoveEntryList(&SendDesc->Linkage);

            FragInfo->FragQueueDepth--;

            *FragSent = TRUE;

            ASSERT((LONG)FragInfo->FragQueueDepth >= 0);

            BytesSent =
                (*LinkCB->SendHandler)(SendDesc);

#ifdef DBG_SENDARRAY
{
            SendArray[__si] = 0x40 + (UCHAR)LinkCB->hLinkHandle;
            if (++__si == MAX_BYTE_DEPTH) {
                __si = 0;
            }
}
#endif
            //
            // Update the bandwidth on demand sample array with the latest send.
            // If we need to notify someone of a bandwidth event do it.
            //
            if (BundleCB->Flags & BOND_ENABLED) {
                UpdateBandwidthOnDemand(BundleCB->SUpperBonDInfo, BytesSent);
                CheckUpperThreshold(BundleCB);
                UpdateBandwidthOnDemand(BundleCB->SLowerBonDInfo, BytesSent);
                CheckLowerThreshold(BundleCB);
            }

            SendDesc =
                (PSEND_DESC)FragInfo->FragQueue.Flink;
            LinkCB = SendDesc->LinkCB;

            //
            // If we are only supposed to send a single
            // fragment then we need to get out
            //
            if (SendOne) {
                break;
            }
        }

        //
        // If we are only supposed to send a single
        // fragment then we need to get out
        //
        if (SendOne) {
            break;
        }
    }

    return (CouldSend);
}

UINT
FramePacket(
    PBUNDLECB       BundleCB,
    PPROTOCOLCB     ProtocolCB,
    PNDIS_PACKET    NdisPacket,
    PLIST_ENTRY     LinkCBList,
    ULONG           SendingLinks,
    INT             Class
    )
{
    ULONG       Flags, BytesSent;
    ULONG       PacketOffset = 0, CurrentLength = 0;
    PUCHAR      CurrentData;
    PLINKCB     LinkCB = NULL;
    USHORT      PPPProtocolID;
    PSEND_DESC  SendDesc;
    HEADER_FRAMING_INFO FramingInfoBuffer;
    PHEADER_FRAMING_INFO FramingInfo = &FramingInfoBuffer;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendPacket: Enter"));

    ASSERT(!IsListEmpty(LinkCBList));

    Flags = BundleCB->SendFlags;

    PPPProtocolID = 
        ProtocolCB->PPPProtocolID;

    //
    // If this is a directed PPP packet then send to
    // the link indicated in the packet
    //
    if (PPPProtocolID == PPP_PROTOCOL_PRIVATE_IO) {
        Flags |= IO_PROTOCOLID;
        Flags &= ~(DO_COMPRESSION | DO_ENCRYPTION | DO_MULTILINK);
    }

    //
    // Did the last receive cause us to flush?
    //
    if ((Flags & (DO_COMPRESSION | DO_ENCRYPTION)) &&
        (BundleCB->Flags & RECV_PACKET_FLUSH)) {
        BundleCB->Flags &= ~RECV_PACKET_FLUSH;
        Flags |= DO_FLUSH;
    }

    Flags |= FIRST_FRAGMENT;

    if (Class == MAX_MCML) {

        Flags &= ~(DO_COMPRESSION | DO_ENCRYPTION | DO_MULTILINK);
    }

    //
    // Get a linkcb to send over
    //
    {
        PLIST_ENTRY  Entry;

        Entry = RemoveHeadList(LinkCBList);

        LinkCB =
            CONTAINING_RECORD(Entry, LINKCB, SendLinkage);
    }

    //
    // Get a send desc
    //
    {
        ULONG   PacketLength;

        NdisQueryPacket(NdisPacket,
                        NULL,
                        NULL,
                        NULL,
                        &PacketLength);
        SendDesc =
            NdisWanAllocateSendDesc(LinkCB, PacketLength);

        if (SendDesc == NULL) {

            // ASSERT(SendDesc != NULL);

            ReleaseBundleLock(BundleCB);

            NDIS_SET_PACKET_STATUS(NdisPacket, NDIS_STATUS_RESOURCES);
            CompleteNdisPacket(ProtocolCB->MiniportCB,
                               ProtocolCB,
                               NdisPacket);
            AcquireBundleLock(BundleCB);

            goto FramePacketExit;
        }
    }
    

    BundleCB->OutstandingFrames++;

    SendDesc->ProtocolCB = ProtocolCB;
    SendDesc->OriginalPacket = NdisPacket;
    SendDesc->Class = Class;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND,
        ("SendDesc: %p NdisPacket: %p", SendDesc, NdisPacket));

    //
    // Build a PPP Header in the buffer and update
    // current pointer
    //
    FramingInfo->FramingBits =
        LinkCB->LinkInfo.SendFramingBits;
    FramingInfo->Flags = Flags;
    FramingInfo->Class = Class;

    BuildLinkHeader(FramingInfo, SendDesc);

    CurrentData =
        SendDesc->StartBuffer + FramingInfo->HeaderLength;

    //
    // If we are in promiscuous mode we should indicate this
    // baby back up.
    //
    if (NdisWanCB.PromiscuousAdapter != NULL) {
        IndicatePromiscuousSendPacket(LinkCB, NdisPacket);
    }

    //
    // Copy MAC Header into buffer if needed and update
    // current pointer
    //
    if ((Flags & SAVE_MAC_ADDRESS) &&
        (PPPProtocolID == PPP_PROTOCOL_NBF)) {
        ULONG   BytesCopied;

        NdisWanCopyFromPacketToBuffer(NdisPacket,
                                      PacketOffset,
                                      12,
                                      CurrentData,
                                      &BytesCopied);

        ASSERT(BytesCopied == 12);

        CurrentData += BytesCopied;
        CurrentLength += BytesCopied;
    }

    //
    // We are beyond the mac header
    // (also skip the length/protocoltype field)
    //
    if (Flags & IO_PROTOCOLID) {
        PacketOffset = 12;
    } else {
        PacketOffset = 14;
    }

    if ((Flags & DO_VJ) &&
        PPPProtocolID == PPP_PROTOCOL_IP) {

        //
        // Do protocol header compression into buffer and
        // update current pointer.
        //
        PPPProtocolID =
            DoVJHeaderCompression(BundleCB,
                                  NdisPacket,
                                  &CurrentData,
                                  &CurrentLength,
                                  &PacketOffset);
    }

    //
    // Copy the rest of the data!
    //
    {
        ULONG   BytesCopied;
        NdisWanCopyFromPacketToBuffer(NdisPacket,
                                      PacketOffset,
                                      0xFFFFFFFF,
                                      CurrentData,
                                      &BytesCopied);

        SendDesc->DataLength =
            CurrentLength + BytesCopied;
    }

    AddPPPProtocolID(FramingInfo, PPPProtocolID);

    if (Flags & (DO_COMPRESSION | DO_ENCRYPTION)) {

        DoCompressionEncryption(BundleCB,
                                FramingInfo,
                                &SendDesc);
    }

    //
    // At this point we have our framinginfo structure initialized,
    // SendDesc->StartData pointing to the begining of the frame,
    // FramingInfo.HeaderLength is the length of the header,
    // SendDesc->DataLength is the length of the data.
    //
    if (Flags & DO_MULTILINK) {

        //
        // Fragment the data and place fragments
        // on bundles frag queue.
        //
        FragmentAndQueue(BundleCB,
                         FramingInfo,
                         SendDesc,
                         LinkCBList,
                         SendingLinks);

        BytesSent = 0;

    } else {

        //
        // This send descriptor is not to be fragmented
        // so just send it!
        //
        SendDesc->HeaderLength = FramingInfo->HeaderLength;

        InterlockedExchange(&(PMINIPORT_RESERVED_FROM_NDIS(NdisPacket)->RefCount), 1);

        BytesSent =
            (*LinkCB->SendHandler)(SendDesc);

    }

    if ((BundleCB->Flags & BOND_ENABLED) &&
        (BytesSent != 0)) {

        //
        // Update the bandwidth on demand sample array with the latest send.
        // If we need to notify someone of a bandwidth event do it.
        //
        UpdateBandwidthOnDemand(BundleCB->SUpperBonDInfo, BytesSent);
        CheckUpperThreshold(BundleCB);
        UpdateBandwidthOnDemand(BundleCB->SLowerBonDInfo, BytesSent);
        CheckLowerThreshold(BundleCB);
    }

FramePacketExit:


    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendPacket: Exit - BytesSent %d", BytesSent));

    return (BytesSent);
}

UINT
SendOnLegacyLink(
    PSEND_DESC  SendDesc
    )
{
    UINT        SendLength;
    PLINKCB     LinkCB = SendDesc->LinkCB;
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    PPROTOCOLCB ProtocolCB  = SendDesc->ProtocolCB;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PNDIS_WAN_PACKET    WanPacket = SendDesc->WanPacket;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendOnLegacyLink: LinkCB: 0x%p, SendDesc: 0x%p, WanPacket: 0x%p", LinkCB, SendDesc, WanPacket));

    LinkCB->OutstandingFrames++;
    if (LinkCB->SendWindow == LinkCB->OutstandingFrames) {
        LinkCB->SendWindowOpen = FALSE;
        BundleCB->SendingLinks--;
    }

#if 0
    if (LinkCB->Stats.FramesTransmitted == 0) {
        PUCHAR  pd;

        if (*(WanPacket->CurrentBuffer) != 0xFF) {
            pd = WanPacket->CurrentBuffer;
        } else {
            pd = (WanPacket->CurrentBuffer + 2);
        }

        if (*(pd) != 0xC0 ||
            *(pd+1) != 0x21 ||
            *(pd+2) != 0x01) {
            DbgPrint("NDISWAN: SLL-FirstFrame not LCP ConfigReq bcb %p, lcb %p\n",
                     BundleCB, LinkCB);
            DbgBreakPoint();
        }
    }
#endif

    SendLength =
    WanPacket->CurrentLength =
        SendDesc->HeaderLength + SendDesc->DataLength;

    WanPacket->ProtocolReserved1 = (PVOID)SendDesc;

    //
    // DoStats
    //
    LinkCB->Stats.FramesTransmitted++;
    BundleCB->Stats.FramesTransmitted++;
    LinkCB->Stats.BytesTransmitted += SendLength;
    BundleCB->Stats.BytesTransmitted += SendLength;

    INSERT_DBG_SEND(PacketTypeWan,
                    LinkCB->OpenCB,
                    ProtocolCB,
                    LinkCB,
                    WanPacket);

    ReleaseBundleLock(BundleCB);

    //
    // If the link is up send the packet
    //
    NdisAcquireSpinLock(&LinkCB->Lock);


    if (LinkCB->State == LINK_UP) {

        KIRQL   OldIrql;

        NdisReleaseSpinLock(&LinkCB->Lock);

        if (gbSniffLink &&
            (NdisWanCB.PromiscuousAdapter != NULL)) {

            IndicatePromiscuousSendDesc(LinkCB, SendDesc, SEND_LINK);
        }

        //
        // There is a problem in ndis right now where
        // the miniport lock is not acquired before sending
        // to the wan miniport.  This opens a window when
        // the miniport does a sendcomplete from within
        // it's send handler since sendcomplete expects
        // to be running at dpc.
        //
        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

        WanMiniportSend(&Status,
                        LinkCB->OpenCB->BindingHandle,
                        LinkCB->NdisLinkHandle,
                        WanPacket);

        KeLowerIrql(OldIrql);

    } else {
        NdisReleaseSpinLock(&LinkCB->Lock);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendOnLegacyLink: Status: 0x%x", Status));

    //
    // If we get something other than pending back we need to
    // do the send complete.
    //
    if (Status != NDIS_STATUS_PENDING) {

        ProtoWanSendComplete(NULL,
                             WanPacket,
                             NDIS_STATUS_SUCCESS);
    }

    AcquireBundleLock(BundleCB);

    return (SendLength);
}

UINT
SendOnLink(
    PSEND_DESC  SendDesc
    )
{
    PLINKCB         LinkCB;
    PBUNDLECB       BundleCB;
    PPROTOCOLCB     ProtocolCB;
    PNDIS_PACKET    NdisPacket;
    PNDIS_BUFFER    NdisBuffer;
    UINT            SendLength;
    NDIS_STATUS     Status;


    LinkCB =
        SendDesc->LinkCB;

    ProtocolCB =
        SendDesc->ProtocolCB;

    NdisPacket =
        SendDesc->NdisPacket;

    NdisBuffer =
        SendDesc->NdisBuffer;

    BundleCB =
        LinkCB->BundleCB;


    NdisWanDbgOut(DBG_TRACE, DBG_SEND,
        ("SendOnLink: LinkCB: 0x%p, NdisPacket: 0x%p",
        LinkCB, NdisPacket));

    LinkCB->OutstandingFrames++;
    if (LinkCB->SendWindow == LinkCB->OutstandingFrames) {
        LinkCB->SendWindowOpen = FALSE;
        BundleCB->SendingLinks--;
    }

    PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->SendDesc = SendDesc;

    INSERT_DBG_SEND(PacketTypeNdis,
                    LinkCB->OpenCB,
                    ProtocolCB,
                    LinkCB,
                    NdisPacket);

    SendLength =
        SendDesc->HeaderLength + SendDesc->DataLength;


    //
    // Fixup the bufferlength and chain at front
    //
    NdisAdjustBufferLength(NdisBuffer, SendLength);
    NdisRecalculatePacketCounts(NdisPacket);

    //
    // Do Stats
    //
    LinkCB->Stats.FramesTransmitted++;
    BundleCB->Stats.FramesTransmitted++;
    LinkCB->Stats.BytesTransmitted += SendLength;
    BundleCB->Stats.BytesTransmitted += SendLength;

    ReleaseBundleLock(BundleCB);

    //
    // If the link is up send the packet
    //
    NdisAcquireSpinLock(&LinkCB->Lock);

    LinkCB->VcRefCount++;

    if (LinkCB->State == LINK_UP) {

        NdisReleaseSpinLock(&LinkCB->Lock);

        if (gbSniffLink &&
            (NdisWanCB.PromiscuousAdapter != NULL)) {

            IndicatePromiscuousSendDesc(LinkCB, SendDesc, SEND_LINK);
        }

        NdisCoSendPackets(LinkCB->NdisLinkHandle,
                          &NdisPacket,
                          1);

    } else {

        NdisReleaseSpinLock(&LinkCB->Lock);

        ProtoCoSendComplete(NDIS_STATUS_SUCCESS,
                            LinkCB->hLinkHandle,
                            NdisPacket);
    }

    AcquireBundleLock(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("SendOnLink: Exit"));

    return (SendLength);
}

USHORT
DoVJHeaderCompression(
    PBUNDLECB   BundleCB,
    PNDIS_PACKET    NdisPacket,
    PUCHAR      *CurrentBuffer,
    PULONG      CurrentLength,
    PULONG      PacketOffset
    )
{
    UCHAR   CompType = TYPE_IP;
    PUCHAR  Header = *CurrentBuffer;
    ULONG   CopyLength;
    ULONG   HeaderLength;
    ULONG   PreCompHeaderLen = 0, PostCompHeaderLen = 0;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    ASSERT(BundleCB->FramingInfo.SendFramingBits &
        (SLIP_VJ_COMPRESSION | PPP_FRAMING));

    NdisQueryPacket(NdisPacket,
        NULL,
        NULL,
        NULL,
        &CopyLength);

    CopyLength -= *PacketOffset;

    if (CopyLength > PROTOCOL_HEADER_LENGTH) {
        CopyLength = PROTOCOL_HEADER_LENGTH;
    }

    NdisWanCopyFromPacketToBuffer(NdisPacket,
        *PacketOffset,
        CopyLength,
        Header,
        &HeaderLength);

    ASSERT(CopyLength == HeaderLength);

    *PacketOffset += HeaderLength;

    //
    // Are we compressing TCP/IP headers?  There is a nasty
    // hack in VJs implementation for attempting to detect
    // interactive TCP/IP sessions.  That is, telnet, login,
    // klogin, eklogin, and ftp sessions.  If detected,
    // the traffic gets put on a higher TypeOfService (TOS).  We do
    // no such hack for RAS.  Also, connection ID compression
    // is negotiated, but we always don't compress it.
    //
    CompType =
        sl_compress_tcp(&Header,
        &HeaderLength,
        &PreCompHeaderLen,
        &PostCompHeaderLen,
        BundleCB->VJCompress,
        0);

    if (BundleCB->FramingInfo.SendFramingBits & SLIP_FRAMING) {
        Header[0] |= CompType;
    }

#if DBG
    if (CompType == TYPE_COMPRESSED_TCP) {
        NdisWanDbgOut(DBG_TRACE, DBG_SEND_VJ,("svj b %d a %d",PreCompHeaderLen, PostCompHeaderLen));
    }
#endif

    BundleCB->Stats.BytesTransmittedUncompressed +=
        PreCompHeaderLen;

    BundleCB->Stats.BytesTransmittedCompressed +=
        PostCompHeaderLen;

    if (CompType == TYPE_COMPRESSED_TCP) {
        PNDIS_BUFFER    MyBuffer;

        //
        // Source/Dest overlap so must use RtlMoveMemory
        //
        RtlMoveMemory(*CurrentBuffer, Header, HeaderLength);

        *CurrentBuffer += HeaderLength;
        *CurrentLength += HeaderLength;

        return (PPP_PROTOCOL_COMPRESSED_TCP);
    }

    *CurrentBuffer += HeaderLength;
    *CurrentLength += HeaderLength;

    switch (CompType) {
        case TYPE_IP:
            return (PPP_PROTOCOL_IP);
        case TYPE_UNCOMPRESSED_TCP:
            return (PPP_PROTOCOL_UNCOMPRESSED_TCP);
        default:
            DbgBreakPoint();
    }

    return (PPP_PROTOCOL_IP);
}

VOID
DoCompressionEncryption(
    PBUNDLECB               BundleCB,
    PHEADER_FRAMING_INFO    FramingInfo,
    PSEND_DESC              *SendDesc
    )
{
    ULONG   Flags = FramingInfo->Flags;
    PSEND_DESC  SendDesc1 = *SendDesc;
    PLINKCB LinkCB = SendDesc1->LinkCB;
    PUCHAR  DataBuffer, DataBuffer1;
    ULONG   DataLength;
    union {
        USHORT  uShort;
        UCHAR   uChar[2];
    }CoherencyCounter;

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("DoCompressionEncryption: Enter"));

    //
    // If we are compressing/encrypting, the ProtocolID
    // is part of the compressed data so fix the pointer
    // and the length;
    //
    FramingInfo->HeaderLength -=
        FramingInfo->ProtocolID.Length;

    SendDesc1->DataLength += FramingInfo->ProtocolID.Length;

    DataBuffer = DataBuffer1 =
        SendDesc1->StartBuffer + FramingInfo->HeaderLength;

    DataLength =
        SendDesc1->DataLength;

    //
    // Get the coherency counter
    //
    CoherencyCounter.uShort = BundleCB->SCoherencyCounter;
    CoherencyCounter.uChar[1] &= 0x0F;

    //
    // Bump the coherency count
    //
    BundleCB->SCoherencyCounter++;

    if (Flags & DO_COMPRESSION) {
        PSEND_DESC  SendDesc2;
        PUCHAR  DataBuffer2;

        //
        // We need to get the max size here to protect
        // against expansion of the data
        //
        SendDesc2 =
            NdisWanAllocateSendDesc(LinkCB, glLargeDataBufferSize);

        if (SendDesc2 == NULL) {
            //
            // Just don't compress!
            //
            BundleCB->SCoherencyCounter--;
            return;
        }

        DataBuffer2 =
            SendDesc2->StartBuffer + FramingInfo->HeaderLength;

        BundleCB->Stats.BytesTransmittedUncompressed += DataLength;

        if (Flags & DO_FLUSH ||
            Flags & DO_HISTORY_LESS) {
            //
            // Init the compression history table and tree
            //
            initsendcontext(BundleCB->SendCompressContext);
        }

        //
        // We are doing the copy to get things into a contiguous buffer before
        // compression occurs
        //
        CoherencyCounter.uChar[1] |=
            compress(DataBuffer1,
                     DataBuffer2,
                     &DataLength,
                     BundleCB->SendCompressContext);

        if (CoherencyCounter.uChar[1] & PACKET_FLUSHED) {

            NdisWanFreeSendDesc(SendDesc2);

            //
            // If encryption is enabled this will force a
            // reinit of the table
            //
            Flags |= DO_FLUSH;

        } else {
            //
            // We compressed the packet so now the data is in
            // the CopyBuffer. We need to copy the PPP header
            // from DataBuffer to CopyBuffer.  The header
            // includes everything except for the protocolid field.
            //
            NdisMoveMemory(SendDesc2->StartBuffer,
                           SendDesc1->StartBuffer,
                           FramingInfo->HeaderLength);

            FramingInfo->ProtocolID.Length = 0;

            UpdateFramingInfo(FramingInfo, SendDesc2->StartBuffer);

            SendDesc2->DataLength = DataLength;
            SendDesc2->ProtocolCB = SendDesc1->ProtocolCB;
            SendDesc2->OriginalPacket = SendDesc1->OriginalPacket;
            SendDesc2->Class = SendDesc1->Class;
            NdisWanFreeSendDesc(SendDesc1);

            *SendDesc = SendDesc2;
            DataBuffer = DataBuffer2;
        }

        BundleCB->Stats.BytesTransmittedCompressed += DataLength;
    }

    //
    // If encryption is enabled encrypt the data in the
    // buffer.  Encryption is done inplace so additional
    // buffers are not needed.
    //
    // Do data encryption
    //
    if (Flags & DO_ENCRYPTION) {
        PUCHAR  SessionKey = BundleCB->SendCryptoInfo.SessionKey;
        ULONG   SessionKeyLength = BundleCB->SendCryptoInfo.SessionKeyLength;
        PVOID   SendRC4Key = BundleCB->SendCryptoInfo.RC4Key;

        //
        // We may need to reinit the rc4 table
        //
        if ((Flags & DO_FLUSH) &&
            !(Flags & DO_HISTORY_LESS)) {
            rc4_key(SendRC4Key, SessionKeyLength, SessionKey);
        }

        //
        // Mark this as being encrypted
        //
        CoherencyCounter.uChar[1] |= PACKET_ENCRYPTED;

        //
        // If we are in history-less mode we will
        // change the RC4 session key for every
        // packet, otherwise every 256 frames
        // change the RC4 session key
        //
        if ((Flags & DO_HISTORY_LESS) ||
            (BundleCB->SCoherencyCounter & 0xFF) == 0) {

            if (Flags & DO_LEGACY_ENCRYPTION) {
                //
                // Simple munge for legacy encryption
                //
                SessionKey[3] += 1;
                SessionKey[4] += 3;
                SessionKey[5] += 13;
                SessionKey[6] += 57;
                SessionKey[7] += 19;

            } else {

                //
                // Use SHA to get new sessionkey
                //
                GetNewKeyFromSHA(&BundleCB->SendCryptoInfo);

            }

            //
            // We use rc4 to scramble and recover a new key
            //

            //
            // Re-initialize the rc4 receive table to the
            // intermediate value
            //
            rc4_key(SendRC4Key, SessionKeyLength, SessionKey);

            //
            // Scramble the existing session key
            //
            rc4(SendRC4Key, SessionKeyLength, SessionKey);

            if (Flags & DO_40_ENCRYPTION) {

                //
                // If this is 40 bit encryption we need to fix
                // the first 3 bytes of the key.
                //
                SessionKey[0] = 0xD1;
                SessionKey[1] = 0x26;
                SessionKey[2] = 0x9E;

            } else if (Flags & DO_56_ENCRYPTION) {

                //
                // If this is 56 bit encryption we need to fix
                // the first byte of the key.
                //
                SessionKey[0] = 0xD1;
            }

            NdisWanDbgOut(DBG_TRACE, DBG_CCP,
                ("RC4 Send encryption KeyLength %d", BundleCB->SendCryptoInfo.SessionKeyLength));
            NdisWanDbgOut(DBG_TRACE, DBG_CCP,
                ("RC4 Send encryption Key %.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x",
                BundleCB->SendCryptoInfo.SessionKey[0],
                BundleCB->SendCryptoInfo.SessionKey[1],
                BundleCB->SendCryptoInfo.SessionKey[2],
                BundleCB->SendCryptoInfo.SessionKey[3],
                BundleCB->SendCryptoInfo.SessionKey[4],
                BundleCB->SendCryptoInfo.SessionKey[5],
                BundleCB->SendCryptoInfo.SessionKey[6],
                BundleCB->SendCryptoInfo.SessionKey[7],
                BundleCB->SendCryptoInfo.SessionKey[8],
                BundleCB->SendCryptoInfo.SessionKey[9],
                BundleCB->SendCryptoInfo.SessionKey[10],
                BundleCB->SendCryptoInfo.SessionKey[11],
                BundleCB->SendCryptoInfo.SessionKey[12],
                BundleCB->SendCryptoInfo.SessionKey[13],
                BundleCB->SendCryptoInfo.SessionKey[14],
                BundleCB->SendCryptoInfo.SessionKey[15]));

            //
            // Re-initialize the rc4 receive table to the
            // scrambled session key
            //
            rc4_key(SendRC4Key, SessionKeyLength, SessionKey);
        }

        //
        // Encrypt the data
        //
        rc4(SendRC4Key, DataLength, DataBuffer);
    }


    //
    // Did the last receive cause us to flush?
    //
    if (Flags & (DO_FLUSH | DO_HISTORY_LESS)) {
        CoherencyCounter.uChar[1] |= PACKET_FLUSHED;
    }

    //
    // Add the coherency bytes to the frame
    //
    AddCompressionInfo(FramingInfo, CoherencyCounter.uShort);

    ASSERT(((CoherencyCounter.uShort + 1) & 0x0FFF) ==
        (BundleCB->SCoherencyCounter & 0x0FFF));

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("DoCompressionEncryption: Exit"));
}

VOID
FragmentAndQueue(
    PBUNDLECB               BundleCB,
    PHEADER_FRAMING_INFO    FramingInfo,
    PSEND_DESC              SendDesc,
    PLIST_ENTRY             LinkCBList,
    ULONG                   SendingLinks
    )
{
    ULONG       DataLeft;
    ULONG       FragmentsSent;
    ULONG       FragmentsLeft;
    ULONG       Flags;
    PLINKCB     LinkCB;
    PUCHAR      DataBuffer;
    ULONG       DataLength;
    PPROTOCOLCB ProtocolCB;
    PNDIS_PACKET    NdisPacket;
    PSEND_FRAG_INFO FragInfo;
    INT         Class;
#if DBG
    ULONG   MaxFragments;
#endif

    Class = SendDesc->Class;

    ASSERT(Class >= 0 && Class < MAX_MCML);

    FragInfo =
        &BundleCB->SendFragInfo[Class];

    DataBuffer =
        SendDesc->StartBuffer + FramingInfo->HeaderLength;

    DataLeft =
    DataLength = SendDesc->DataLength;

    FragmentsSent = 0;
    Flags = FramingInfo->Flags;
    LinkCB = SendDesc->LinkCB;
    ProtocolCB = SendDesc->ProtocolCB;
    NdisPacket = SendDesc->OriginalPacket;

    if (BundleCB->Flags & QOS_ENABLED) {

        FragmentsLeft = 
            (DataLength/FragInfo->MaxFragSize == 0) ?
            1 : DataLength/FragInfo->MaxFragSize;

        if (DataLength > FragInfo->MaxFragSize * FragmentsLeft) {
            FragmentsLeft += 1;
        }

        if (FragmentsLeft > BundleCB->SendResources) {
            FragmentsLeft = BundleCB->SendResources;
        }

    } else {

        FragmentsLeft = SendingLinks;
    }

#if DBG
    MaxFragments = FragmentsLeft;
#endif

    //
    // For all fragments we loop fixing up the multilink header
    // if multilink is on, fixing up pointers in the wanpacket,
    // and queuing the wanpackets for further processing.
    //
    while (DataLeft) {
        ULONG   FragDataLength;

        if (!(Flags & FIRST_FRAGMENT)) {
            PLIST_ENTRY  Entry;

            //
            // We had more than one fragment, get the next
            // link to send over and a wanpacket from the
            // link.
            //
            //
            // Get a linkcb to send over
            //
            if (IsListEmpty(LinkCBList)) {
                ULONG   Count;

                Count = 
                    GetSendingLinks(BundleCB, Class, LinkCBList);

                if (Count == 0) {
                    //
                    //
                    //
#if DBG_FAILURE
                    DbgPrint("NDISWAN: FragmentAndQueue LinkCBCount %d\n", Count);
#endif                    
                    continue;
                }
            }

            Entry = RemoveHeadList(LinkCBList);

            LinkCB =
                CONTAINING_RECORD(Entry, LINKCB, SendLinkage);

            SendDesc =
                NdisWanAllocateSendDesc(LinkCB, DataLeft + 6);

            if (SendDesc == NULL) {
                //
                // 
                //
                InsertTailList(LinkCBList, &LinkCB->SendLinkage);
#if DBG_FAILURE
                DbgPrint("NDISWAN: FragmentAndQueue SendDesc == NULL! LinkCB: 0x%p\n", LinkCB);
#endif                
                continue;
            }

            SendDesc->ProtocolCB = ProtocolCB;
            SendDesc->OriginalPacket = NdisPacket;
            SendDesc->Class = Class;

            //
            // Get new framing information and build a new
            // header for the new link.
            //
            FramingInfo->FramingBits = 
                LinkCB->LinkInfo.SendFramingBits;
            FramingInfo->Flags = Flags;

            BuildLinkHeader(FramingInfo, SendDesc);
        }

        if (FragmentsLeft > 1) {

            //
            // Calculate the length of this fragment
            //
            FragDataLength = (DataLength * LinkCB->SBandwidth / 100);

            if (BundleCB->Flags & QOS_ENABLED) {

                FragDataLength = (FragDataLength > FragInfo->MaxFragSize) ?
                    FragInfo->MaxFragSize : FragDataLength;

            } else {

                FragDataLength = (FragDataLength < FragInfo->MinFragSize) ?
                    FragInfo->MinFragSize : FragDataLength;
            }

            if ((FragDataLength > DataLeft) ||
                ((LONG)DataLeft - FragDataLength < FragInfo->MinFragSize)) {
                //
                // This will leave a fragment of less than min frag size
                // so send all of the data
                //
                FragDataLength = DataLeft;
                FragmentsLeft = 1;
            }

        } else {
            //
            // We either have one fragment left or this link has
            // more than 85 percent of the bundle so send what
            // data is left
            //
            FragDataLength = DataLeft;
            FragmentsLeft = 1;
        }

        if (!(Flags & FIRST_FRAGMENT)) {
            //
            // Copy the data to the new buffer from the old buffer.
            //
            NdisMoveMemory(SendDesc->StartBuffer + FramingInfo->HeaderLength,
                           DataBuffer,
                           FragDataLength);
        }

        //
        // Update the data pointer and the length left to send
        //
        DataBuffer += FragDataLength;
        DataLeft -= FragDataLength;

        {
            UCHAR   MultilinkFlags = 0;

            //
            // Multlink is on so create flags for this
            // fragment.
            //
            if (Flags & FIRST_FRAGMENT) {
                MultilinkFlags = MULTILINK_BEGIN_FRAME;
                Flags &= ~FIRST_FRAGMENT;
            }

            if (FragmentsLeft == 1) {
                MultilinkFlags |= MULTILINK_END_FRAME;
            }

            //
            // Add the multilink header information and
            // take care of the sequence number.
            //
            AddMultilinkInfo(FramingInfo,
                             MultilinkFlags,
                             FragInfo->SeqNumber,
                             BundleCB->SendSeqMask);

            NdisWanDbgOut(DBG_INFO, DBG_MULTILINK_SEND, ("sf %x %x %d",
                FragInfo->SeqNumber, MultilinkFlags, FragDataLength));

            FragInfo->SeqNumber++;
        }

        //
        // Setup the SEND_DESC
        //
        SendDesc->HeaderLength = FramingInfo->HeaderLength;
        SendDesc->DataLength = FragDataLength;
        SendDesc->Flags |= SEND_DESC_FRAG;

        //
        // Queue for further processing.
        //
        InsertTailList(&FragInfo->FragQueue, &SendDesc->Linkage);

        FragInfo->FragQueueDepth++;

        FragmentsSent++;
        FragmentsLeft--;

    }   // end of the fragment loop

    ASSERT(FragmentsLeft == 0);

    InterlockedExchangeAdd(&ProtocolCB->PacketQueue[Class].OutstandingFrags, (LONG)FragmentsSent);

#ifdef DBG_SENDARRAY
{
    SendArray[__si] = '0' + (UCHAR)FragmentsSent;
    if (++__si == MAX_BYTE_DEPTH) {
        __si = 0;
    }
}
#endif

    //
    // Get the mac reserved structure from the ndispacket.  This
    // is where we will keep the reference count on the packet.
    //
    ASSERT(((LONG)FragmentsSent > 0) && (FragmentsSent <= MaxFragments));

    InterlockedExchange(&(PMINIPORT_RESERVED_FROM_NDIS(SendDesc->OriginalPacket)->RefCount), FragmentsSent);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("NdisPacket: 0x%p RefCount %d", SendDesc->OriginalPacket, FragmentsSent));
}

ULONG
GetSendingLinks(
    PBUNDLECB   BundleCB,
    INT         Class,
    PLIST_ENTRY lcbList
    )
{
    ULONG   SendingLinks;
    PLINKCB LinkCB, StartLinkCB, LastLinkCB;

    StartLinkCB = LinkCB = LastLinkCB =
        BundleCB->NextLinkToXmit;

    SendingLinks = 0;

    //
    // If this is a fragmented send...
    // If QOS is enabled we just need some send resources
    // If QOS is not enabled we need sending links
    // If this is a non-fragmented send...
    // We need sending links
    //

    if (LinkCB != NULL) {

        if (Class == MAX_MCML) {

            do {

                NdisDprAcquireSpinLock(&LinkCB->Lock);

                if ((LinkCB->State == LINK_UP) &&
                    LinkCB->LinkActive && 
                    LinkCB->SendWindowOpen) {

                    InsertTailList(lcbList, &LinkCB->SendLinkage);

                    REF_LINKCB(LinkCB);

                    SendingLinks += 1;
                    LastLinkCB = LinkCB;
                }

                NdisDprReleaseSpinLock(&LinkCB->Lock);

                LinkCB = (PLINKCB)LinkCB->Linkage.Flink;

                if ((PVOID)LinkCB == (PVOID)&BundleCB->LinkCBList) {
                    LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
                }

            } while (LinkCB != StartLinkCB);

        } else {
            if (BundleCB->Flags& QOS_ENABLED) {

                do {

                    NdisDprAcquireSpinLock(&LinkCB->Lock);

                    if ((LinkCB->State == LINK_UP) &&
                        LinkCB->LinkActive && 
                        (LinkCB->SendResources != 0)) {
                        InsertTailList(lcbList, &LinkCB->SendLinkage);

                        REF_LINKCB(LinkCB);

                        SendingLinks += 1;
                        LastLinkCB = LinkCB;
                    }

                    NdisDprReleaseSpinLock(&LinkCB->Lock);

                    LinkCB = (PLINKCB)LinkCB->Linkage.Flink;

                    if ((PVOID)LinkCB == (PVOID)&BundleCB->LinkCBList) {
                        LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
                    }

                } while (LinkCB != StartLinkCB);

            } else {

                do {

                    NdisDprAcquireSpinLock(&LinkCB->Lock);

                    if ((LinkCB->State == LINK_UP) &&
                        LinkCB->LinkActive && 
                        LinkCB->SendWindowOpen) {
                        InsertTailList(lcbList, &LinkCB->SendLinkage);

                        REF_LINKCB(LinkCB);

                        SendingLinks += 1;
                        LastLinkCB = LinkCB;
                    }

                    NdisDprReleaseSpinLock(&LinkCB->Lock);

                    LinkCB = (PLINKCB)LinkCB->Linkage.Flink;

                    if ((PVOID)LinkCB == (PVOID)&BundleCB->LinkCBList) {
                        LinkCB = (PLINKCB)BundleCB->LinkCBList.Flink;
                    }

                } while (LinkCB != StartLinkCB);
            }
        }

        BundleCB->NextLinkToXmit =
            (LastLinkCB->Linkage.Flink == &BundleCB->LinkCBList) ?
            (PLINKCB)BundleCB->LinkCBList.Flink : 
            (PLINKCB)LastLinkCB->Linkage.Flink;
    }

#ifdef DBG_SENDARRAY
{
    if (SendingLinks == 0) {
        SendArray[__si] = 'g';
    } else {
        SendArray[__si] = 'G';
    }
    if (++__si == MAX_BYTE_DEPTH) {
        __si = 0;
    }
}
#endif

    return (SendingLinks);
}

VOID
GetNextProtocol(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB *ProtocolCB,
    PULONG      SendMask
    )
{
    PLIST_ENTRY     ppcblist;
    PPROTOCOLCB     ppcb;
    ULONG           mask;
    ULONG           i;
    BOOLEAN         Found;

    *ProtocolCB = NULL;
    mask = *SendMask;
    *SendMask = 0;

    ppcb = BundleCB->NextProtocol;

    if (ppcb == NULL) {
        return;
    }

    //
    // There is a window where we could have set the initial
    // send mask and had a protocol removed without clearing
    // it's send bit.  If we 'and' the temp mask with the 
    // bundle's mask we should clear out any bits that are
    // left dangling.
    //
    mask &= BundleCB->SendMask;

    //
    // Starting with the next flagged protocol
    // see if it can send.  If not clear its
    // sendbit from the mask and go to the next.
    // If none can send mask will be 0 and
    // protocol will be NULL.  We know that there
    // are only ulnumberofroutes in table so only
    // look for that many.
    //

    i = BundleCB->ulNumberOfRoutes;
    Found = FALSE;

    do {

        if (ppcb->State == PROTOCOL_ROUTED) {
            *ProtocolCB = ppcb;
            Found = TRUE;
        } else {
            mask &= ~ppcb->SendMaskBit;
        }

        ppcb = (PPROTOCOLCB)ppcb->Linkage.Flink;

        if ((PVOID)ppcb == (PVOID)&BundleCB->ProtocolCBList) {

            ppcb = (PPROTOCOLCB)BundleCB->ProtocolCBList.Flink;
        }

        if (Found) {
            BundleCB->NextProtocol = ppcb;
            break;
        }

    } while ( --i );

    if (*ProtocolCB != NULL) {
        *SendMask = mask;
    }
}

NDIS_STATUS
BuildIoPacket(
    IN  PLINKCB             LinkCB,
    IN  PBUNDLECB           BundleCB,
    IN  PNDISWAN_IO_PACKET  pWanIoPacket,
    IN  BOOLEAN             SendImmediate
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_RESOURCES;
    ULONG   Stage = 0;
    ULONG   DataLength;
    PUCHAR  DataBuffer, pSrcAddr, pDestAddr;
    PNDIS_PACKET    NdisPacket;
    PNDIS_BUFFER    NdisBuffer;
    PPROTOCOLCB     IoProtocolCB;
    PSEND_DESC      SendDesc;
    UCHAR   SendHeader[] = {' ', 'S', 'E', 'N', 'D', 0xFF};

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("BuildIoPacket: Enter!"));
    //
    // Some time in the future this should be redone so that
    // there is a pool of packets and buffers attached to a
    // BundleCB.  This pool could be grown and shrunk as needed
    // but some minimum number would live for the lifetime of
    // the BundleCB.

    //
    // Allocate needed resources
    //
    {
        ULONG   SizeNeeded;

        //
        // Need max of 18 bytes; 4 bytes for ppp/llc header and
        // 14 for MAC address
        //
        SizeNeeded = 18;

        //
        // The header will either be given to us or
        // it will be added by us (ethernet mac header)
        //
        SizeNeeded += (pWanIoPacket->usHeaderSize > 0) ?
            pWanIoPacket->usHeaderSize : MAC_HEADER_LENGTH;

        //
        // Amount of data we need to send
        //
        SizeNeeded += pWanIoPacket->usPacketSize;

        Status = 
            AllocateIoNdisPacket(SizeNeeded,
                                 &NdisPacket,
                                 &NdisBuffer, 
                                 &DataBuffer);

        if (Status != NDIS_STATUS_SUCCESS) {

            NdisWanDbgOut(DBG_FAILURE, DBG_SEND, 
                          ("BuildIoPacket: Error Allocating IoNdisPacket!"));

            DEREF_LINKCB(LinkCB);

            return (NDIS_STATUS_RESOURCES);
        }
    }

    PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->LinkCB = LinkCB;

    //
    // We only support ethernet headers right now so the supplied header
    // either has to be ethernet or none at all!
    //
    pDestAddr = &DataBuffer[0];
    pSrcAddr = &DataBuffer[6];

    //
    // If no header build a header
    //
    if (pWanIoPacket->usHeaderSize == 0) {

        //
        // Header will look like " S XXYYYY" where
        // XX is the ProtocolCB index and YYYY is the
        // BundleCB index.  Both the Src and Dst addresses
        // look the same.
        //
        NdisMoveMemory(pDestAddr,
                       SendHeader,
                       sizeof(SendHeader));

        NdisMoveMemory(pSrcAddr,
                       SendHeader,
                       sizeof(SendHeader));

        //
        // Fill the BundleCB Index for the Src and Dest Address
        //
        pDestAddr[5] = pSrcAddr[5] = 
            (UCHAR)LinkCB->hLinkHandle;

        DataLength = 12;

    } else {
        //
        // Header supplied so go ahead and move it.
        //
        NdisMoveMemory(pDestAddr,
                       pWanIoPacket->PacketData,
                       pWanIoPacket->usHeaderSize);

        DataLength = pWanIoPacket->usHeaderSize;
    }

    //
    // Copy the data to the buffer
    //
    NdisMoveMemory(&DataBuffer[12],
                   &pWanIoPacket->PacketData[pWanIoPacket->usHeaderSize],
                   pWanIoPacket->usPacketSize);

    DataLength += pWanIoPacket->usPacketSize;

    //
    // Adjust buffer length and chain buffer to ndis packet
    //
    NdisAdjustBufferLength(NdisBuffer, DataLength);
    NdisRecalculatePacketCounts(NdisPacket);

    //
    // Queue the packet on the bundlecb
    //
    IoProtocolCB = BundleCB->IoProtocolCB;

    ASSERT(IoProtocolCB != NULL);

    if (SendImmediate) {
        InsertHeadPacketQueue(&IoProtocolCB->PacketQueue[MAX_MCML],
                              NdisPacket, DataLength);
    } else {
        InsertTailPacketQueue(&IoProtocolCB->PacketQueue[MAX_MCML],
                              NdisPacket, DataLength);
    }

    InterlockedIncrement(&IoProtocolCB->OutstandingFrames);

    //
    // Try to send
    //
    // Called with lock held and returns with
    // lock released
    //
    SendPacketOnBundle(BundleCB);

    AcquireBundleLock(BundleCB);

    NdisWanDbgOut(DBG_TRACE, DBG_SEND, ("BuildIoPacket: Exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

VOID
BuildLinkHeader(
    PHEADER_FRAMING_INFO    FramingInfo,
    PSEND_DESC              SendDesc
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   LinkFraming = FramingInfo->FramingBits;
    ULONG   Flags = FramingInfo->Flags;
    PUCHAR  CurrentPointer = SendDesc->StartBuffer;

    FramingInfo->HeaderLength =
        FramingInfo->AddressControl.Length =
        FramingInfo->Multilink.Length =
        FramingInfo->Compression.Length =
        FramingInfo->ProtocolID.Length = 0;

    if (LinkFraming & PPP_FRAMING) {

        if (!(LinkFraming & PPP_COMPRESS_ADDRESS_CONTROL)) {
            //
            // If there is no address/control compression
            // we need a pointer and a length
            //

            if (LinkFraming & LLC_ENCAPSULATION) {
                FramingInfo->AddressControl.Pointer = CurrentPointer;
                *CurrentPointer++ = 0xFE;
                *CurrentPointer++ = 0xFE;
                *CurrentPointer++ = 0x03;
                *CurrentPointer++ = 0xCF;
                FramingInfo->AddressControl.Length = 4;
                FramingInfo->HeaderLength += FramingInfo->AddressControl.Length;

            } else {
                FramingInfo->AddressControl.Pointer = CurrentPointer;
                *CurrentPointer++ = 0xFF;
                *CurrentPointer++ = 0x03;
                FramingInfo->AddressControl.Length = 2;
                FramingInfo->HeaderLength += FramingInfo->AddressControl.Length;
            }
        }

        if (!(Flags & IO_PROTOCOLID)) {

            //
            // If this is not from our private I/O interface we will
            // build the rest of the header.
            //
            if ((Flags & DO_MULTILINK) && (LinkFraming & PPP_MULTILINK_FRAMING)) {

                //
                // We are doing multilink so we need a pointer
                // and a length
                //
                FramingInfo->Multilink.Pointer = CurrentPointer;

                if (!(LinkFraming & PPP_COMPRESS_PROTOCOL_FIELD)) {
                    //
                    // No protocol compression
                    //
                    *CurrentPointer++ = 0x00;
                    FramingInfo->Multilink.Length++;
                }

                *CurrentPointer++ = 0x3D;
                FramingInfo->Multilink.Length++;

                if (!(LinkFraming & PPP_SHORT_SEQUENCE_HDR_FORMAT)) {
                    //
                    // We are using long sequence number
                    //
                    FramingInfo->Multilink.Length += 2;
                    CurrentPointer += 2;

                }

                FramingInfo->Multilink.Length += 2;
                CurrentPointer += 2;

                FramingInfo->HeaderLength += FramingInfo->Multilink.Length;

            }

            if (Flags & FIRST_FRAGMENT) {

                if (Flags & (DO_COMPRESSION | DO_ENCRYPTION)) {
                    //
                    // We are doing compression/encryption so we need
                    // a pointer and a length
                    //
                    FramingInfo->Compression.Pointer = CurrentPointer;

                    //
                    // It appears that legacy ras (< NT 4.0) requires that
                    // the PPP protocol field in a compressed packet not
                    // be compressed, ie has to have the leading 0x00
                    //
                    if (!(LinkFraming & PPP_COMPRESS_PROTOCOL_FIELD)) {
                        //
                        // No protocol compression
                        //
                        *CurrentPointer++ = 0x00;
                        FramingInfo->Compression.Length++;
                    }

                    *CurrentPointer++ = 0xFD;
                    FramingInfo->Compression.Length++;

                    //
                    // Add coherency bytes
                    //
                    FramingInfo->Compression.Length += 2;
                    CurrentPointer += 2;

                    FramingInfo->HeaderLength += FramingInfo->Compression.Length;
                }


                FramingInfo->ProtocolID.Pointer = CurrentPointer;

                if (!(LinkFraming & PPP_COMPRESS_PROTOCOL_FIELD) ||
                    (Flags & (DO_COMPRESSION | DO_ENCRYPTION))) {
                    FramingInfo->ProtocolID.Length++;
                    CurrentPointer++;
                }

                FramingInfo->ProtocolID.Length++;
                FramingInfo->HeaderLength += FramingInfo->ProtocolID.Length;
                CurrentPointer++;
            }
        }


    } else if ((LinkFraming & RAS_FRAMING)) {
        //
        // If this is old ras framing:
        //
        // Alter the framing so that 0xFF 0x03 is not added
        // and that the first byte is 0xFD not 0x00 0xFD
        //
        // So basically, a RAS compression looks like
        // <0xFD> <2 BYTE COHERENCY> <NBF DATA FIELD>
        //
        // Whereas uncompressed looks like
        // <NBF DATA FIELD> which always starts with 0xF0
        //
        // If this is ppp framing:
        //
        // A compressed frame will look like (before address/control
        // - multilink is added)
        // <0x00> <0xFD> <2 Byte Coherency> <Compressed Data>
        //
        if (Flags & (DO_COMPRESSION | DO_ENCRYPTION)) {
            FramingInfo->Compression.Pointer = CurrentPointer;

            *CurrentPointer++ = 0xFD;
            FramingInfo->Compression.Length++;

            //
            // Coherency bytes
            //
            FramingInfo->Compression.Length += 2;
            CurrentPointer += 2;

            FramingInfo->HeaderLength += FramingInfo->Compression.Length;
        }
    }
}

VOID
IndicatePromiscuousSendPacket(
    PLINKCB         LinkCB,
    PNDIS_PACKET    NdisPacket
    )
{
    PNDIS_BUFFER    NdisBuffer;
    PNDIS_PACKET    LocalNdisPacket;
    NDIS_STATUS     Status;
    PRECV_DESC      RecvDesc;
    PBUNDLECB       BundleCB = LinkCB->BundleCB;
    KIRQL           OldIrql;
    PMINIPORTCB     Adapter;
    ULONG           PacketLength;

    NdisAcquireSpinLock(&NdisWanCB.Lock);
    Adapter = NdisWanCB.PromiscuousAdapter;
    NdisReleaseSpinLock(&NdisWanCB.Lock);

    if (Adapter == NULL) {
        return;
    }

    NdisQueryPacket(NdisPacket, 
                    NULL, 
                    NULL, 
                    NULL, 
                    &PacketLength);

    RecvDesc =
        NdisWanAllocateRecvDesc(PacketLength);

    if (RecvDesc == NULL) {
        return;
    }

    //
    // Get an ndis packet
    //
    LocalNdisPacket =
        RecvDesc->NdisPacket;

    NdisWanCopyFromPacketToBuffer(NdisPacket,
        0,
        0xFFFFFFFF,
        RecvDesc->StartBuffer,
        &RecvDesc->CurrentLength);

    PPROTOCOL_RESERVED_FROM_NDIS(LocalNdisPacket)->RecvDesc = RecvDesc;

    //
    // Attach the buffers
    //
    NdisAdjustBufferLength(RecvDesc->NdisBuffer,
                           RecvDesc->CurrentLength);

    NdisRecalculatePacketCounts(LocalNdisPacket);

    ReleaseBundleLock(BundleCB);

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    NDIS_SET_PACKET_STATUS(LocalNdisPacket, NDIS_STATUS_RESOURCES);

    INSERT_DBG_RECV(PacketTypeNdis, 
                    Adapter, 
                    NULL, 
                    LinkCB, 
                    LocalNdisPacket);

    //
    // Indicate the packet
    // This assumes that bloodhound is always a legacy transport
    //
    NdisMIndicateReceivePacket(Adapter->MiniportHandle,
                               &LocalNdisPacket,
                               1);

    KeLowerIrql(OldIrql);

    Status = NDIS_GET_PACKET_STATUS(LocalNdisPacket);

    ASSERT(Status == NDIS_STATUS_RESOURCES);

    REMOVE_DBG_RECV(PacketTypeNdis, Adapter, LocalNdisPacket);

    {
     

        NdisWanFreeRecvDesc(RecvDesc);
    }

    AcquireBundleLock(BundleCB);
}

VOID
IndicatePromiscuousSendDesc(
    PLINKCB     LinkCB,
    PSEND_DESC  SendDesc,
    SEND_TYPE   SendType
    )
{
    UCHAR   Header1[] = {' ', 'W', 'A', 'N', 'S', 0xFF, ' ', 'W', 'A', 'N', 'S', 0xFF};
    PUCHAR  HeaderBuffer, DataBuffer;
    ULONG   HeaderLength, DataLength;
    PNDIS_BUFFER    NdisBuffer;
    PNDIS_PACKET    NdisPacket;
    NDIS_STATUS     Status;
    PBUNDLECB   BundleCB = LinkCB->BundleCB;
    PRECV_DESC  RecvDesc;
    KIRQL       OldIrql;
    PMINIPORTCB     Adapter;

    AcquireBundleLock(BundleCB);

    NdisAcquireSpinLock(&NdisWanCB.Lock);
    Adapter = NdisWanCB.PromiscuousAdapter;
    NdisReleaseSpinLock(&NdisWanCB.Lock);

    if (Adapter == NULL) {
        ReleaseBundleLock(BundleCB);
        return;
    }

    DataLength = 
        SendDesc->HeaderLength + SendDesc->DataLength;

    RecvDesc = 
        NdisWanAllocateRecvDesc(DataLength + MAC_HEADER_LENGTH);

    if (RecvDesc == NULL) {
        ReleaseBundleLock(BundleCB);
        return;
    }

    HeaderBuffer = RecvDesc->StartBuffer;
    HeaderLength = 0;

    switch (SendType) {
        case SEND_LINK:
            NdisMoveMemory(HeaderBuffer, Header1, sizeof(Header1));
            HeaderBuffer[5] =
                HeaderBuffer[11] = (UCHAR)LinkCB->hLinkHandle;

            HeaderBuffer[12] = (UCHAR)(DataLength >> 8);
            HeaderBuffer[13] = (UCHAR)DataLength;
            HeaderLength = MAC_HEADER_LENGTH;
            break;

        case SEND_BUNDLE_PPP:
        case SEND_BUNDLE_DATA:
            break;


    }

    DataBuffer = HeaderBuffer + HeaderLength;

    NdisMoveMemory(DataBuffer,
                   SendDesc->StartBuffer,
                   DataLength);

    RecvDesc->CurrentBuffer = HeaderBuffer;
    RecvDesc->CurrentLength = HeaderLength + DataLength;
    if (RecvDesc->CurrentLength > 1514) {
        RecvDesc->CurrentLength = 1514;
    }

    //
    // Get an ndis packet
    //
    NdisPacket = 
        RecvDesc->NdisPacket;

    PPROTOCOL_RESERVED_FROM_NDIS(NdisPacket)->RecvDesc = RecvDesc;

    //
    // Attach the buffers
    //
    NdisAdjustBufferLength(RecvDesc->NdisBuffer,
                           RecvDesc->CurrentLength);

    NdisRecalculatePacketCounts(NdisPacket);

    ReleaseBundleLock(BundleCB);

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    NDIS_SET_PACKET_STATUS(NdisPacket, NDIS_STATUS_RESOURCES);

    INSERT_DBG_RECV(PacketTypeNdis, Adapter, NULL, LinkCB, NdisPacket);

    //
    // Indicate the packet
    // This assumes that bloodhound is always a legacy transport
    //
    NdisMIndicateReceivePacket(Adapter->MiniportHandle,
                               &NdisPacket,
                               1);

    KeLowerIrql(OldIrql);

    Status = NDIS_GET_PACKET_STATUS(NdisPacket);

    ASSERT(Status == NDIS_STATUS_RESOURCES);

    REMOVE_DBG_RECV(PacketTypeNdis, Adapter, NdisPacket);

    {
        

        NdisWanFreeRecvDesc(RecvDesc);
    }
}

VOID
CompleteNdisPacket(
    PMINIPORTCB     MiniportCB,
    PPROTOCOLCB     ProtocolCB,
    PNDIS_PACKET    NdisPacket
    )
{
    PBUNDLECB   BundleCB = ProtocolCB->BundleCB;
    PCM_VCCB    CmVcCB;

    InterlockedDecrement(&ProtocolCB->OutstandingFrames);

    if (ProtocolCB->ProtocolType == PROTOCOL_PRIVATE_IO) {
        //
        // If this is a packet that we created we need to free
        // the resources
        //
        FreeIoNdisPacket(NdisPacket);
        return;
    }

    AcquireBundleLock(BundleCB);

    DEREF_PROTOCOLCB(ProtocolCB);

    ReleaseBundleLock(BundleCB);

    REMOVE_DBG_SEND(PacketTypeNdis, MiniportCB, NdisPacket);

    CmVcCB =
        PMINIPORT_RESERVED_FROM_NDIS(NdisPacket)->CmVcCB;

    if (CmVcCB != NULL) {
        NdisMCoSendComplete(NDIS_STATUS_SUCCESS,
                            CmVcCB->NdisVcHandle,
                            NdisPacket);

        DEREF_CMVCCB(CmVcCB);

    } else {

        NdisMSendComplete(MiniportCB->MiniportHandle,
                          NdisPacket,
                          NDIS_STATUS_SUCCESS);
    }

    //
    // Increment global count
    //
    NdisWanInterlockedInc(&glSendCompleteCount);
}

#if DBG
VOID
InsertDbgPacket(
    PDBG_PKT_CONTEXT   DbgContext
    )
{
    PDBG_PACKET DbgPacket, temp;
    PBUNDLECB   BundleCB = DbgContext->BundleCB;
    PPROTOCOLCB ProtocolCB = DbgContext->ProtocolCB;
    PLINKCB     LinkCB = DbgContext->LinkCB;

    DbgPacket =
        NdisAllocateFromNPagedLookasideList(&DbgPacketDescList);

    if (DbgPacket == NULL) {
        return;
    }

    DbgPacket->Packet = DbgContext->Packet;
    DbgPacket->PacketType = DbgContext->PacketType;
    DbgPacket->BundleCB = BundleCB;
    if (BundleCB) {
        DbgPacket->BundleState = BundleCB->State;
        DbgPacket->BundleFlags = BundleCB->Flags;
    }

    DbgPacket->ProtocolCB = ProtocolCB;
    if (ProtocolCB) {
        DbgPacket->ProtocolState = ProtocolCB->State;
    }

    DbgPacket->LinkCB = LinkCB;
    if (LinkCB) {
        DbgPacket->LinkState = LinkCB->State;
    }

    DbgPacket->SendCount = glSendCount;

    NdisAcquireSpinLock(DbgContext->ListLock);

    temp = (PDBG_PACKET)DbgContext->ListHead->Flink;

    while ((PVOID)temp != (PVOID)DbgContext->ListHead) {
        if (temp->Packet == DbgPacket->Packet) {
            DbgPrint("NDISWAN: Packet on list twice l %x desc %x pkt %x\n",
                     DbgContext->ListHead, DbgPacket, DbgPacket->Packet);
            DbgBreakPoint();
        }
        temp = (PDBG_PACKET)temp->Linkage.Flink;
    }

    InsertTailList(DbgContext->ListHead, &DbgPacket->Linkage);

    NdisReleaseSpinLock(DbgContext->ListLock);
}

BOOLEAN
RemoveDbgPacket(
    PDBG_PKT_CONTEXT DbgContext
    )
{
    PDBG_PACKET DbgPacket = NULL;
    BOOLEAN     Found = FALSE;

    NdisAcquireSpinLock(DbgContext->ListLock);

    if (!IsListEmpty(DbgContext->ListHead)) {
        for (DbgPacket = (PDBG_PACKET)DbgContext->ListHead->Flink;
            (PVOID)DbgPacket != (PVOID)DbgContext->ListHead;
            DbgPacket = (PDBG_PACKET)DbgPacket->Linkage.Flink) {

            if (DbgPacket->Packet == DbgContext->Packet) {
                RemoveEntryList(&DbgPacket->Linkage);
                NdisFreeToNPagedLookasideList(&DbgPacketDescList,
                    DbgPacket);
                Found = TRUE;
                break;
            }
        }
    }

    ASSERT(Found == TRUE);

    NdisReleaseSpinLock(DbgContext->ListLock);

    return (Found);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\tapi.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Tapi.c

Abstract:


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

//
// We want to initialize all of the global variables now!
//
#include "wan.h"

#define __FILE_SIG__    TAPI_FILESIG

ULONG gulNdistapiMissedCount = 0;

EXPORT
VOID
NdisTapiCompleteRequest(
    IN  NDIS_HANDLE Handle,
    IN  PVOID       NdisRequest,
    IN  NDIS_STATUS Status
    );

EXPORT
VOID
NdisTapiIndicateStatus(
    IN  NDIS_HANDLE Handle,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

NDIS_STATUS
NdisWanTapiRequestProc(
    HANDLE NdisTapiKey,
    PNDIS_REQUEST   NdisRequest
    )
/*++

Routine Name:

    NdisWanTapiRequestProc

Routine Description:

    Procedure is called by the NdisTapi.sys driver to send
    requests to the WanMiniport driver.  We intercept this
    just to moderate.  NdisTapi could call the miniport directly
    if we wanted but we don't.

Arguments:

Return Values:

--*/
{
    NDIS_STATUS     Status;
    PWAN_REQUEST    WanRequest;
    PNDIS_REQUEST   MyNdisRequest;
    POPENCB         OpenCB = NULL;
    OPENCB *pOpenCBTemp;
    LIST_ENTRY *pEntry;
    

    NdisWanDbgOut(DBG_TRACE, DBG_TAPI, ("NdisWanTapiRequestProc - Enter"));
    NdisWanDbgOut(DBG_INFO, DBG_TAPI, ("NdisRequest: Type: 0x%x OID: 0x%x",
    NdisRequest->RequestType,NdisRequest->DATA.QUERY_INFORMATION.Oid));

    //
    // Map the NdisTapiKey to OpenCB
    //
    NdisAcquireSpinLock(&OpenCBList.Lock);

    for(pEntry = OpenCBList.List.Flink;
        pEntry != &OpenCBList.List;
        pEntry = pEntry->Flink)
    {
        pOpenCBTemp = CONTAINING_RECORD(pEntry, OPENCB, Linkage);
        
        if(     (NULL != pOpenCBTemp->NdisTapiKey)
            &&  (pOpenCBTemp->NdisTapiKey == NdisTapiKey))
        {
            OpenCB = pOpenCBTemp;
            break;
        }
    }

    if(OpenCB == NULL)
    {
        //
        // Miniport is already removed from the list.
        //
        NdisReleaseSpinLock(&OpenCBList.Lock);
        NdisWanInterlockedInc(&gulNdistapiMissedCount);
        return NDIS_STATUS_FAILURE;
    }

    //
    // Take a ref on the opencb and release locks.
    //
    NdisAcquireSpinLock(&OpenCB->Lock);

    if (OpenCB->Flags & OPEN_CLOSING) {

        NdisReleaseSpinLock(&OpenCB->Lock);
        NdisReleaseSpinLock(&OpenCBList.Lock);
        return (NDIS_STATUS_FAILURE);
    }

    REF_OPENCB(OpenCB);

    NdisReleaseSpinLock(&OpenCB->Lock);
    NdisReleaseSpinLock(&OpenCBList.Lock);
    
    WanRequest =
        NdisAllocateFromNPagedLookasideList(&WanRequestList);

    if (WanRequest == NULL) {
        DEREF_OPENCB(OpenCB);
        return (NDIS_STATUS_RESOURCES);
    }

    WanRequest->Type = ASYNC;
    WanRequest->Origin = NDISTAPI;
    WanRequest->OpenCB = OpenCB;
    WanRequest->OriginalRequest = NdisRequest;

    NdisWanInitializeNotificationEvent(&WanRequest->NotificationEvent);

    MyNdisRequest = &WanRequest->NdisRequest;
    MyNdisRequest->RequestType =
        NdisRequest->RequestType;
    if (NdisRequest->RequestType == NdisRequestQueryInformation) {
        MyNdisRequest->DATA.QUERY_INFORMATION.Oid =
            NdisRequest->DATA.QUERY_INFORMATION.Oid;
        MyNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
            NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;
        MyNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
            NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength;
        MyNdisRequest->DATA.QUERY_INFORMATION.BytesWritten =
            NdisRequest->DATA.QUERY_INFORMATION.BytesWritten;
    } else if (NdisRequest->RequestType == NdisRequestSetInformation) {
        MyNdisRequest->DATA.SET_INFORMATION.Oid =
            NdisRequest->DATA.SET_INFORMATION.Oid;
        MyNdisRequest->DATA.SET_INFORMATION.InformationBuffer =
            NdisRequest->DATA.SET_INFORMATION.InformationBuffer;
        MyNdisRequest->DATA.SET_INFORMATION.InformationBufferLength =
            NdisRequest->DATA.SET_INFORMATION.InformationBufferLength;
        MyNdisRequest->DATA.SET_INFORMATION.BytesRead =
            NdisRequest->DATA.SET_INFORMATION.BytesRead;
    }
        
    Status = NdisWanSubmitNdisRequest(OpenCB, WanRequest);

    NdisWanDbgOut(DBG_INFO, DBG_TAPI, ("Status: 0x%x", Status));
    NdisWanDbgOut(DBG_TRACE, DBG_TAPI, ("NdisWanTapiRequestProc - Exit"));

    DEREF_OPENCB(OpenCB);

    return (Status);
}

VOID
NdisWanTapiRequestComplete(
    POPENCB OpenCB,
    PWAN_REQUEST    WanRequest
    )
{
    PNDIS_REQUEST   NdisRequest, MyNdisRequest;

    NdisWanDbgOut(DBG_TRACE, DBG_TAPI,
        ("NdisWanTapiRequestComplete - Enter"));

    NdisRequest = WanRequest->OriginalRequest;

    MyNdisRequest = &WanRequest->NdisRequest;
    if (NdisRequest->RequestType == NdisRequestQueryInformation) {
        NdisRequest->DATA.QUERY_INFORMATION.BytesWritten =
            MyNdisRequest->DATA.QUERY_INFORMATION.BytesWritten;
    } else if (NdisRequest->RequestType == NdisRequestSetInformation) {
        NdisRequest->DATA.SET_INFORMATION.BytesRead =
            MyNdisRequest->DATA.SET_INFORMATION.BytesRead;
    }

    NdisWanDbgOut(DBG_INFO, DBG_TAPI,
        ("NdisRequest: Type: 0x%x OID: 0x%x",
        NdisRequest->RequestType,
        NdisRequest->DATA.QUERY_INFORMATION.Oid));

    NdisWanDbgOut(DBG_INFO, DBG_TAPI,
        ("Status: 0x%x", WanRequest->NotificationStatus));

    NdisTapiCompleteRequest(OpenCB->NdisTapiKey,
                            NdisRequest,
                            WanRequest->NotificationStatus);

    NdisFreeToNPagedLookasideList(&WanRequestList, WanRequest);
}

VOID
NdisWanTapiIndication(
    POPENCB OpenCB,
    PUCHAR          StatusBuffer,
    ULONG           StatusBufferSize
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    NdisWanDbgOut(DBG_TRACE, DBG_TAPI, ("NdisWanTapiIndication - Enter"));

    //
    // If tapi is present and this miniport has registered for
    // connectionwrapper services give this to tapi
    //
    if (OpenCB->WanInfo.FramingBits & TAPI_PROVIDER) {

        NdisTapiIndicateStatus(OpenCB,
                               StatusBuffer,
                               StatusBufferSize);
    }

    NdisWanDbgOut(DBG_TRACE, DBG_TAPI, ("NdisWanTapiIndication - Exit"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\util.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Util.c

Abstract:

This file contains utility functions used by NdisWan.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "wan.h"

#define __FILE_SIG__    UTIL_FILESIG

VOID
NdisWanCopyFromPacketToBuffer(
    IN  PNDIS_PACKET    pNdisPacket,
    IN  ULONG           Offset,
    IN  ULONG           BytesToCopy,
    OUT PUCHAR          Buffer,
    OUT PULONG          BytesCopied
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    ULONG   NdisBufferCount;
    PNDIS_BUFFER    CurrentBuffer;
    PVOID   VirtualAddress;
    ULONG   CurrentLength, AmountToMove;
    ULONG   LocalBytesCopied = 0, PacketLength;

    *BytesCopied = 0;

    //
    // Take care of zero byte copy
    //
    if (!BytesToCopy) {
        return;
    }

    //
    // Get the buffer count
    //
    NdisQueryPacket(pNdisPacket,
                    NULL,
                    &NdisBufferCount,
                    &CurrentBuffer,
                    &PacketLength);

    //
    // Could be a null packet
    //
    if (!NdisBufferCount ||
        Offset == PacketLength) {
        return;
    }


    NdisQueryBuffer(CurrentBuffer,
                    &VirtualAddress,
                    &CurrentLength);

    while (LocalBytesCopied < BytesToCopy &&
           LocalBytesCopied < PacketLength) {

        //
        // No more bytes left in this buffer
        //
        if (!CurrentLength) {

            //
            // Get the next buffer
            //
            NdisGetNextBuffer(CurrentBuffer,
                              &CurrentBuffer);

            //
            // End of the packet, copy what we can
            //
            if (CurrentBuffer == NULL) {
                break;
            }

            //
            //
            //
            NdisQueryBuffer(CurrentBuffer,
                            &VirtualAddress,
                            &CurrentLength);

            if (!CurrentLength) {
                continue;
            }

        }

        //
        // Get to the point where we can start copying
        //
        if (Offset) {

            if (Offset > CurrentLength) {

                //
                // Not in this buffer, go to the next one
                //
                Offset -= CurrentLength;
                CurrentLength = 0;
                continue;

            } else {

                //
                // At least some in this buffer
                //
                VirtualAddress = (PUCHAR)VirtualAddress + Offset;
                CurrentLength -= Offset;
                Offset = 0;
            }
        }

        if (!CurrentLength) {
            continue;
        }

        //
        // We can copy some data.  If we need more data than is available
        // in this buffer we can copy what we need and go back for more.
        //
        AmountToMove = (CurrentLength > (BytesToCopy - LocalBytesCopied)) ?
                       (BytesToCopy - LocalBytesCopied) : CurrentLength;

        NdisMoveMemory(Buffer, VirtualAddress, AmountToMove);

        Buffer = (PUCHAR)Buffer + AmountToMove;

        VirtualAddress = (PUCHAR)VirtualAddress + AmountToMove;

        LocalBytesCopied += AmountToMove;

        CurrentLength -= AmountToMove;
    }

    *BytesCopied = LocalBytesCopied;
}

VOID
NdisWanCopyFromBufferToPacket(
    PUCHAR  Buffer,
    ULONG   BytesToCopy,
    PNDIS_PACKET    NdisPacket,
    ULONG   PacketOffset,
    PULONG  BytesCopied
    )
{
    PNDIS_BUFFER    NdisBuffer;
    ULONG   NdisBufferCount, NdisBufferLength;
    PVOID   VirtualAddress;
    ULONG   LocalBytesCopied = 0;

    *BytesCopied = 0;

    //
    // Make sure we actually want to do something
    //
    if (BytesToCopy == 0) {
        return;
    }

    //
    // Get the buffercount of the packet
    //
    NdisQueryPacket(NdisPacket,
                    NULL,
                    &NdisBufferCount,
                    &NdisBuffer,
                    NULL);

    //
    // Make sure this is not a null packet
    //
    if (NdisBufferCount == 0) {
        return;
    }

    //
    // Get first buffer and buffer length
    //
    NdisQueryBuffer(NdisBuffer,
                    &VirtualAddress,
                    &NdisBufferLength);

    while (LocalBytesCopied < BytesToCopy) {

        if (NdisBufferLength == 0) {

            NdisGetNextBuffer(NdisBuffer,
                              &NdisBuffer);

            if (NdisBuffer == NULL) {
                break;
            }

            NdisQueryBuffer(NdisBuffer,
                            &VirtualAddress,
                            &NdisBufferLength);

            continue;
        }

        if (PacketOffset != 0) {

            if (PacketOffset > NdisBufferLength) {

                PacketOffset -= NdisBufferLength;

                NdisBufferLength = 0;

                continue;

            } else {
                VirtualAddress = (PUCHAR)VirtualAddress + PacketOffset;
                NdisBufferLength -= PacketOffset;
                PacketOffset = 0;
            }
        }

        //
        // Copy the data
        //
        {
            ULONG   AmountToMove;
            ULONG   AmountRemaining;

            AmountRemaining = BytesToCopy - LocalBytesCopied;

            AmountToMove = (NdisBufferLength < AmountRemaining) ?
                            NdisBufferLength : AmountRemaining;

            NdisMoveMemory((PUCHAR)VirtualAddress,
                           Buffer,
                           AmountToMove);

            Buffer += AmountToMove;
            LocalBytesCopied += AmountToMove;
            NdisBufferLength -= AmountToMove;
        }
    }

    *BytesCopied = LocalBytesCopied;
}

BOOLEAN
IsLinkValid(
    NDIS_HANDLE LinkHandle,
    BOOLEAN     CheckState,
    PLINKCB     *LinkCB
    )
{
    PLINKCB     plcb;
    LOCK_STATE  LockState;
    BOOLEAN     Valid;

    *LinkCB = NULL;
    Valid = FALSE;

    NdisAcquireReadWriteLock(&ConnTableLock, FALSE, &LockState);

    do {

        if (PtrToUlong(LinkHandle) > ConnectionTable->ulArraySize) {
            break;
        }

        plcb = *(ConnectionTable->LinkArray + PtrToUlong(LinkHandle));

        if (plcb == NULL) {
            break;
        }

        NdisDprAcquireSpinLock(&plcb->Lock);

        if (CheckState &&
            (plcb->State != LINK_UP)) {

            NdisDprReleaseSpinLock(&plcb->Lock);
            break;
        }

        REF_LINKCB(plcb);
        NdisDprReleaseSpinLock(&plcb->Lock);

        *LinkCB = plcb;

        Valid = TRUE;

    } while (FALSE);


    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

    return (Valid);
}

BOOLEAN
IsBundleValid(
    NDIS_HANDLE BundleHandle,
    BOOLEAN     CheckState,
    PBUNDLECB   *BundleCB
    )
{
    PBUNDLECB   pbcb;
    LOCK_STATE  LockState;
    BOOLEAN     Valid;

    *BundleCB = NULL;
    Valid = FALSE;

    NdisAcquireReadWriteLock(&ConnTableLock, FALSE, &LockState);

    do {
        if (PtrToUlong(BundleHandle) > ConnectionTable->ulArraySize) {
            break;
        }

        pbcb = *(ConnectionTable->BundleArray + PtrToUlong(BundleHandle));

        if (pbcb == NULL) {
            break;
        }

        NdisDprAcquireSpinLock(&pbcb->Lock);

        if (CheckState &&
            (pbcb->State != BUNDLE_UP)) {

            NdisDprReleaseSpinLock(&pbcb->Lock);
            break;
        }

        REF_BUNDLECB(pbcb);
        NdisDprReleaseSpinLock(&pbcb->Lock);

        *BundleCB = pbcb;

        Valid = TRUE;

    } while (FALSE);

    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

    return (Valid);
}


BOOLEAN
AreLinkAndBundleValid(
    NDIS_HANDLE LinkHandle,
    BOOLEAN     CheckState,
    PLINKCB     *LinkCB,
    PBUNDLECB   *BundleCB
    )
{
    PLINKCB     plcb;
    PBUNDLECB   pbcb;
    LOCK_STATE  LockState;
    BOOLEAN     Valid;

    *LinkCB = NULL;
    *BundleCB = NULL;
    Valid = FALSE;

    NdisAcquireReadWriteLock(&ConnTableLock, FALSE, &LockState);

    do {

        if (PtrToUlong(LinkHandle) > ConnectionTable->ulArraySize) {
            break;
        }

        plcb = *(ConnectionTable->LinkArray + PtrToUlong(LinkHandle));

        if (plcb == NULL) {
            break;
        }

        NdisDprAcquireSpinLock(&plcb->Lock);

        if (CheckState &&
            (plcb->State != LINK_UP)) {

            NdisDprReleaseSpinLock(&plcb->Lock);
            break;
        }

        pbcb = plcb->BundleCB;

        if (pbcb == NULL) {
            NdisDprReleaseSpinLock(&plcb->Lock);
            break;
        }

        REF_LINKCB(plcb);
        NdisDprReleaseSpinLock(&plcb->Lock);

        NdisDprAcquireSpinLock(&pbcb->Lock);
        REF_BUNDLECB(pbcb);
        NdisDprReleaseSpinLock(&pbcb->Lock);

        *LinkCB = plcb;
        *BundleCB = pbcb;

        Valid = TRUE;

    } while (FALSE);

    NdisReleaseReadWriteLock(&ConnTableLock, &LockState);

    return (Valid);
}

//
// Called with BundleCB->Lock held
//
VOID
DoDerefBundleCBWork(
    PBUNDLECB   BundleCB
    )
{
    ASSERT(BundleCB->State == BUNDLE_GOING_DOWN);
    ASSERT(BundleCB->OutstandingFrames == 0);
    ASSERT(BundleCB->ulNumberOfRoutes == 0);
    ASSERT(BundleCB->ulLinkCBCount == 0);
    ReleaseBundleLock(BundleCB);
    RemoveBundleFromConnectionTable(BundleCB);
    NdisWanFreeBundleCB(BundleCB);
}

//
// Called with LinkCB->Lock held
//
VOID
DoDerefLinkCBWork(
    PLINKCB     LinkCB
    )
{
    PBUNDLECB   _pbcb = LinkCB->BundleCB;

    ASSERT(LinkCB->State == LINK_GOING_DOWN);
    ASSERT(LinkCB->OutstandingFrames == 0);
    NdisReleaseSpinLock(&LinkCB->Lock);
    RemoveLinkFromBundle(_pbcb, LinkCB, FALSE);
    RemoveLinkFromConnectionTable(LinkCB);
    NdisWanFreeLinkCB(LinkCB);
}

//
//
//
VOID
DoDerefCmVcCBWork(
    PCM_VCCB    VcCB
    )
{
    InterlockedExchange((PLONG)&(VcCB)->State, CMVC_DEACTIVE);
    NdisMCmDeactivateVc(VcCB->NdisVcHandle);
    NdisMCmCloseCallComplete(NDIS_STATUS_SUCCESS, 
                             VcCB->NdisVcHandle, 
                             NULL);
}

//
// Called with ClAfSap->Lock held
//
VOID
DoDerefClAfSapCBWork(
    PCL_AFSAPCB AfSapCB
    )
{
    NDIS_STATUS Status;

    ASSERT(AfSapCB->Flags & SAP_REGISTERED);

    if (AfSapCB->Flags & SAP_REGISTERED) {

        AfSapCB->Flags &= ~(SAP_REGISTERED);
        AfSapCB->Flags |= (SAP_DEREGISTERING);

        NdisReleaseSpinLock(&AfSapCB->Lock);

        Status = NdisClDeregisterSap(AfSapCB->SapHandle);
    
        if (Status != NDIS_STATUS_PENDING) {
            ClDeregisterSapComplete(Status, AfSapCB);
        }

    } else {

        NdisReleaseSpinLock(&AfSapCB->Lock);

    }
}

VOID
DerefVc(
    PLINKCB LinkCB
    )
{
    //
    // Ref applied when we sent the packet to the underlying
    // miniport
    //
    LinkCB->VcRefCount--;

    if ((LinkCB->ClCallState == CL_CALL_CLOSE_PENDING) &&
        (LinkCB->VcRefCount == 0) ) {

        NDIS_STATUS CloseStatus;

        LinkCB->ClCallState = CL_CALL_CLOSED;

        NdisReleaseSpinLock(&LinkCB->Lock);

        CloseStatus =
            NdisClCloseCall(LinkCB->NdisLinkHandle,
                            NULL,
                            NULL,
                            0);

        if (CloseStatus != NDIS_STATUS_PENDING) {
            ClCloseCallComplete(CloseStatus,
                                LinkCB,
                                NULL);
        }

        NdisAcquireSpinLock(&LinkCB->Lock);
    }
}

VOID
DeferredWorker(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Arg1,
    PVOID   Arg2
    )
{
    NdisAcquireSpinLock(&DeferredWorkList.Lock);

    while (!(IsListEmpty(&DeferredWorkList.List))) {
        PLIST_ENTRY Entry;
        PBUNDLECB   BundleCB;

        Entry = RemoveHeadList(&DeferredWorkList.List);
        DeferredWorkList.ulCount--;

        NdisReleaseSpinLock(&DeferredWorkList.Lock);

        BundleCB =
            CONTAINING_RECORD(Entry, BUNDLECB, DeferredLinkage);

        AcquireBundleLock(BundleCB);

        BundleCB->Flags &= ~DEFERRED_WORK_QUEUED;

        //
        // Do all of the deferred work items for this Bundle
        //
        SendPacketOnBundle(BundleCB);

        //
        // Deref for the ref applied when we inserted this item on
        // the worker queue.
        //
        DEREF_BUNDLECB(BundleCB);

        NdisAcquireSpinLock(&DeferredWorkList.Lock);
    }

    DeferredWorkList.TimerScheduled = FALSE;

    NdisReleaseSpinLock(&DeferredWorkList.Lock);
}


#ifdef NT

VOID
NdisWanStringToNdisString(
    PNDIS_STRING    pDestString,
    PWSTR           pSrcBuffer
    )
{
    PWSTR   Dest, Src = pSrcBuffer;
    NDIS_STRING SrcString;

    NdisInitUnicodeString(&SrcString, pSrcBuffer);
    NdisWanAllocateMemory(&pDestString->Buffer, SrcString.MaximumLength, NDISSTRING_TAG);
    if (pDestString->Buffer == NULL) {
        return;
    }
    pDestString->MaximumLength = SrcString.MaximumLength;
    pDestString->Length = SrcString.Length;
    RtlCopyUnicodeString(pDestString, &SrcString);
}


VOID
NdisWanFreeNdisString(
    PNDIS_STRING    NdisString
    )
{
    if (NdisString->Buffer != NULL) {
        NdisWanFreeMemory(NdisString->Buffer);
    }
}

VOID
NdisWanAllocateAdapterName(
    PNDIS_STRING    Dest,
    PNDIS_STRING    Src
    )
{
    NdisWanAllocateMemory(&Dest->Buffer, Src->MaximumLength, NDISSTRING_TAG);
    if (Dest->Buffer != NULL) {
        Dest->MaximumLength = Src->MaximumLength;
        Dest->Length = Src->Length;
        RtlUpcaseUnicodeString(Dest, Src, FALSE);
    }
}

//VOID
//NdisWanFreeNdisString(
//  PNDIS_STRING    NdisString
//  )
//{
//  NdisFreeMemory(NdisString->Buffer,
//                 NdisString->MaximumLength * sizeof(WCHAR),
//                 0);
//}

VOID
NdisWanNdisStringToInteger(
    PNDIS_STRING    Source,
    PULONG          Value
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PWSTR   s = Source->Buffer;
    ULONG   Digit;

    *Value = 0;

    while (*s != UNICODE_NULL) {

        if (*s >= L'0' && *s < L'9') {
            Digit = *s - L'0';
        } else if (*s >= L'A' && *s <= L'F') {
            Digit = *s - L'A' + 10;
        } else if (*s >= L'a' && *s <= L'f') {
            Digit = *s - L'a' + 10;
        } else {
            break;
        }

        *Value = (*Value << 4) | Digit;

        s++;
    }
}

VOID
NdisWanCopyNdisString(
    PNDIS_STRING Dest,
    PNDIS_STRING Src
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PWSTR   SrcBuffer = Src->Buffer;
    PWSTR   DestBuffer = Dest->Buffer;

    while (*SrcBuffer != UNICODE_NULL) {

        *DestBuffer = *SrcBuffer;

        SrcBuffer++;
        DestBuffer++;
    }

    *DestBuffer = UNICODE_NULL;

    Dest->Length = Src->Length;

}

VOID
BonDWorker(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Arg1,
    PVOID   Arg2
    )
{
    PLIST_ENTRY Entry;

    NdisAcquireSpinLock(&BonDWorkList.Lock);

    for (Entry = BonDWorkList.List.Flink;
        Entry != &BonDWorkList.List;
        Entry = Entry->Flink) {
        PBUNDLECB   BundleCB;

        BundleCB = CONTAINING_RECORD(Entry, BUNDLECB, BonDLinkage);

        NdisReleaseSpinLock(&BonDWorkList.Lock);

        AcquireBundleLock(BundleCB);

        if (BundleCB->State != BUNDLE_UP ||
            !(BundleCB->Flags & BOND_ENABLED)) {
            ReleaseBundleLock(BundleCB);
            NdisAcquireSpinLock(&BonDWorkList.Lock);
            continue;
        }

        AgeSampleTable(&BundleCB->SUpperBonDInfo->SampleTable);
        CheckUpperThreshold(BundleCB);
    
        AgeSampleTable(&BundleCB->SLowerBonDInfo->SampleTable);
        CheckLowerThreshold(BundleCB);
    
        AgeSampleTable(&BundleCB->RUpperBonDInfo->SampleTable);
        CheckUpperThreshold(BundleCB);
    
        AgeSampleTable(&BundleCB->RLowerBonDInfo->SampleTable);
        CheckUpperThreshold(BundleCB);

        ReleaseBundleLock(BundleCB);

        NdisAcquireSpinLock(&BonDWorkList.Lock);
    }

    NdisReleaseSpinLock(&BonDWorkList.Lock);
}

#if 0
VOID
CheckBonDInfo(
    PKDPC       Dpc,
    PBUNDLECB   BundleCB,
    PVOID       SysArg1,
    PVOID       SysArg2
    )
{
    if (!(BundleCB->Flags & BOND_ENABLED)) {
        return;
    }

    AgeSampleTable(&BundleCB->SUpperBonDInfo.SampleTable);
    CheckUpperThreshold(BundleCB);

    AgeSampleTable(&BundleCB->SLowerBonDInfo.SampleTable);
    CheckLowerThreshold(BundleCB);

    AgeSampleTable(&BundleCB->RUpperBonDInfo.SampleTable);
    CheckUpperThreshold(BundleCB);

    AgeSampleTable(&BundleCB->RLowerBonDInfo.SampleTable);
    CheckUpperThreshold(BundleCB);
}
#endif

VOID
AgeSampleTable(
    PSAMPLE_TABLE   SampleTable
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    WAN_TIME    CurrentTime, TimeDiff;
    ULONG       HeadIndex = SampleTable->ulHead;

    //
    // Should return CurrentTime in 100ns units
    //
    NdisWanGetSystemTime(&CurrentTime);

    //
    // We will search through the sample indexing over samples that are more than
    // one second older than the current time.
    //
    while (!IsSampleTableEmpty(SampleTable) ) {
        PBOND_SAMPLE    FirstSample;

        FirstSample = &SampleTable->SampleArray[SampleTable->ulHead];

        NdisWanCalcTimeDiff(&TimeDiff, &CurrentTime, &FirstSample->TimeStamp);

        if (NdisWanIsTimeDiffLess(&TimeDiff, &SampleTable->SamplePeriod))
            break;
            
        SampleTable->ulCurrentSampleByteCount -= FirstSample->ulBytes;

        ASSERT((LONG)SampleTable->ulCurrentSampleByteCount >= 0);

        FirstSample->ulReferenceCount = 0;

        if (++SampleTable->ulHead == SampleTable->ulSampleArraySize) {
            SampleTable->ulHead = 0;            
        }

        SampleTable->ulSampleCount--;
    }

    if (IsSampleTableEmpty(SampleTable)) {
        ASSERT((LONG)SampleTable->ulCurrentSampleByteCount == 0);
        SampleTable->ulHead = SampleTable->ulCurrent;
    }
}

VOID
UpdateSampleTable(
    PSAMPLE_TABLE   SampleTable,
    ULONG           Bytes
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    WAN_TIME    CurrentTime, TimeDiff;
    ULONG   CurrentIndex = SampleTable->ulCurrent;
    PBOND_SAMPLE    CurrentSample = &SampleTable->SampleArray[CurrentIndex];

    NdisWanGetSystemTime(&CurrentTime);

    NdisWanCalcTimeDiff(&TimeDiff, &CurrentTime, &CurrentSample->TimeStamp);

    if (NdisWanIsTimeDiffLess(&TimeDiff, &SampleTable->SampleRate) ||
        IsSampleTableFull(SampleTable)) {
        //
        // Add this send on the previous sample
        //
        CurrentSample->ulBytes += Bytes;
        CurrentSample->ulReferenceCount++;
    } else {
        ULONG   NextIndex;

        //
        // We need a new sample
        //
        if (IsSampleTableEmpty(SampleTable)) {
            NextIndex = SampleTable->ulHead;
            ASSERT(NextIndex == SampleTable->ulCurrent);
        } else {
            NextIndex = SampleTable->ulCurrent + 1;
        }

        if (NextIndex == SampleTable->ulSampleArraySize) {
            NextIndex = 0;
        }

        SampleTable->ulCurrent = NextIndex;

        CurrentSample = &SampleTable->SampleArray[NextIndex];
        CurrentSample->TimeStamp = CurrentTime;
        CurrentSample->ulBytes = Bytes;
        CurrentSample->ulReferenceCount = 1;
        SampleTable->ulSampleCount++;

        ASSERT(SampleTable->ulSampleCount <= SampleTable->ulSampleArraySize);
    }

    SampleTable->ulCurrentSampleByteCount += Bytes;
}

VOID
UpdateBandwidthOnDemand(
    PBOND_INFO  BonDInfo,
    ULONG       Bytes
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    PSAMPLE_TABLE   SampleTable = &BonDInfo->SampleTable;

    //
    // Age and update the sample table
    //
    AgeSampleTable(SampleTable);
    UpdateSampleTable(SampleTable, Bytes);
}

VOID
CheckUpperThreshold(
    PBUNDLECB       BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    WAN_TIME    CurrentTime, TimeDiff;
    PBOND_INFO  BonDInfo;
    PSAMPLE_TABLE   SampleTable;
    ULONGLONG   Bps;
    BOOLEAN     SSignal, RSignal;

    //
    // First check send side
    //
    BonDInfo = BundleCB->SUpperBonDInfo;
    SSignal = FALSE;
    SampleTable = &BonDInfo->SampleTable;
    Bps = SampleTable->ulCurrentSampleByteCount;

    //
    // Switch on the current state
    //
    switch (BonDInfo->State) {

        case BonDSignaled:
            break;

        case BonDIdle:
            //
            // We are currently below the upper threshold.  If we
            // go over the upperthreshold we will set the time and
            // transition to the monitor state.
            //
            if (Bps >= BonDInfo->ulBytesThreshold) {
                NdisWanGetSystemTime(&BonDInfo->StartTime);
                BonDInfo->State = BonDMonitor;
                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("U-S: i -> m, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
            }
            break;

        case BonDMonitor:

            //
            // We are currently in the monitor state which means that
            // we have gone above the upper threshold.  If we fall below
            // the upper threshold we will go back to the idle state.
            //
            if (Bps < BonDInfo->ulBytesThreshold) {

                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("U-S: m -> i, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
                BonDInfo->State = BonDIdle;

            } else {

                NdisWanGetSystemTime(&CurrentTime);

                NdisWanCalcTimeDiff(&TimeDiff, &CurrentTime, &BonDInfo->StartTime);

                if (!NdisWanIsTimeDiffLess(&TimeDiff, &SampleTable->SamplePeriod))  {

                    SSignal = TRUE;
                }
            }
            break;
    }

    //
    // Now check the receive side
    //
    BonDInfo = BundleCB->RUpperBonDInfo;
    RSignal = FALSE;
    SampleTable = &BonDInfo->SampleTable;
    Bps = SampleTable->ulCurrentSampleByteCount;

    switch (BonDInfo->State) {

        case BonDSignaled:
            break;

        case BonDIdle:
            //
            // We are currently below the upper threshold.  If we
            // go over the upperthreshold we will set the time and
            // transition to the monitor state.
            //
            if (Bps >= BonDInfo->ulBytesThreshold) {
                NdisWanGetSystemTime(&BonDInfo->StartTime);
                BonDInfo->State = BonDMonitor;
                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("U-R: i -> m, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
            }
            break;

        case BonDMonitor:

            //
            // We are currently in the monitor state which means that
            // we have gone above the upper threshold.  If we fall below
            // the upper threshold we will go back to the idle state.
            //
            if (Bps < BonDInfo->ulBytesThreshold) {

                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("U-R: m -> i, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
                BonDInfo->State = BonDIdle;

            } else {

                NdisWanGetSystemTime(&CurrentTime);

                NdisWanCalcTimeDiff(&TimeDiff, &CurrentTime, &BonDInfo->StartTime);

                if (!NdisWanIsTimeDiffLess(&TimeDiff, &SampleTable->SamplePeriod))  {

                    RSignal = TRUE;
                }
            }
            break;
    }

    if (SSignal || RSignal) {

        //
        // We have been above the threshold for time greater than the
        // threshold sample period so we need to notify someone of this
        // historic event!
        //
        CompleteThresholdEvent(BundleCB, BonDInfo->DataType, UPPER_THRESHOLD);
    
        BundleCB->SUpperBonDInfo->State = BonDSignaled;
        BundleCB->RUpperBonDInfo->State = BonDSignaled;

#if DBG
        {
            ULONGLONG   util;

            util = BundleCB->SUpperBonDInfo->SampleTable.ulCurrentSampleByteCount;
            util *= 100;
            util /= BundleCB->SUpperBonDInfo->ulBytesInSamplePeriod;
            NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("U-S: Bps %I64d Threshold %I64d Util %I64d",
                     Bps, BundleCB->SUpperBonDInfo->ulBytesThreshold, util));

            util = BundleCB->RUpperBonDInfo->SampleTable.ulCurrentSampleByteCount;
            util *= 100;
            util /= BundleCB->RUpperBonDInfo->ulBytesInSamplePeriod;
            NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("U-R: Bps %I64d Threshold %I64d Util %I64d",
                     Bps, BundleCB->RUpperBonDInfo->ulBytesThreshold, util));
        }
#endif

    }
}

VOID
CheckLowerThreshold(
    PBUNDLECB   BundleCB
    )
/*++

Routine Name:

Routine Description:

Arguments:

Return Values:

--*/
{
    WAN_TIME    CurrentTime, TimeDiff;
    PBOND_INFO  BonDInfo;
    PSAMPLE_TABLE   SampleTable;
    ULONGLONG   Bps;
    BOOLEAN     SSignal, RSignal;

    if (!(BundleCB->Flags & BOND_ENABLED)) {
        return;
    }

    //
    // First check send side
    //
    BonDInfo = BundleCB->SLowerBonDInfo;
    SampleTable = &BonDInfo->SampleTable;
    Bps = SampleTable->ulCurrentSampleByteCount;
    SSignal = FALSE;

    //
    // Switch on the current state
    //
    switch (BonDInfo->State) {

        case BonDIdle:
            //
            // We are currently above the lower threshold.  If we
            // go under the lowerthreshold we will set the time and
            // transition to the monitor state.
            //
            if (Bps <= BonDInfo->ulBytesThreshold) {
                NdisWanGetSystemTime(&BonDInfo->StartTime);
                BonDInfo->State = BonDMonitor;
                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("L-S: i -> m, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
            }
            break;

        case BonDMonitor:

            //
            // We are currently in the monitor state which means that
            // we have gone below the lower threshold.  If we climb above
            // the lower threshold we will go back to the idle state.
            //
            if (Bps > BonDInfo->ulBytesThreshold) {

                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("L-S: m -> i, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
                BonDInfo->State = BonDIdle;

            } else {

                NdisWanGetSystemTime(&CurrentTime);

                NdisWanCalcTimeDiff(&TimeDiff, &CurrentTime, &BonDInfo->StartTime);

                if (!NdisWanIsTimeDiffLess(&TimeDiff, &SampleTable->SamplePeriod))  {

                    SSignal = TRUE;
                }
            }
            break;

        case BonDSignaled:
            break;
    }

    //
    // Now check the receive side
    //
    BonDInfo = BundleCB->RLowerBonDInfo;
    RSignal = FALSE;
    SampleTable = &BonDInfo->SampleTable;
    Bps = SampleTable->ulCurrentSampleByteCount;

    switch (BonDInfo->State) {

        case BonDIdle:
            //
            // We are currently above the lower threshold.  If we
            // go below the lowerthreshold we will set the time and
            // transition to the monitor state.
            //
            if (Bps <= BonDInfo->ulBytesThreshold) {
                NdisWanGetSystemTime(&BonDInfo->StartTime);
                BonDInfo->State = BonDMonitor;
                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("L-R: i -> m, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
            }
            break;

        case BonDMonitor:

            //
            // We are currently in the monitor state which means that
            // we have gone below the lower threshold.  If we climb above
            // the lower threshold we will go back to the idle state.
            //
            if (Bps > BonDInfo->ulBytesThreshold) {

                NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("L-R: m -> i, %I64d-%I64d", Bps, BonDInfo->ulBytesThreshold));
                BonDInfo->State = BonDIdle;

            } else {

                NdisWanGetSystemTime(&CurrentTime);

                NdisWanCalcTimeDiff(&TimeDiff, &CurrentTime, &BonDInfo->StartTime);

                if (!NdisWanIsTimeDiffLess(&TimeDiff, &SampleTable->SamplePeriod))  {

                    RSignal = TRUE;
                }
            }
            break;

        case BonDSignaled:
            break;
    }

    if (SSignal && RSignal) {
        //
        // We have been above the threshold for time greater than the
        // threshold sample period so we need to notify someone of this
        // historic event!
        //
        CompleteThresholdEvent(BundleCB, BonDInfo->DataType, LOWER_THRESHOLD);
    
        BundleCB->SLowerBonDInfo->State = BonDSignaled;
        BundleCB->RLowerBonDInfo->State = BonDSignaled;

#if DBG
        {
            ULONGLONG   util;

            util = BundleCB->SLowerBonDInfo->SampleTable.ulCurrentSampleByteCount;
            util *= 100;
            util /= BundleCB->SLowerBonDInfo->ulBytesInSamplePeriod;
            NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("L-S: Bps %I64d Threshold %I64d Util %I64d",
                     Bps, BundleCB->SLowerBonDInfo->ulBytesThreshold, util));

            util = BundleCB->RLowerBonDInfo->SampleTable.ulCurrentSampleByteCount;
            util *= 100;
            util /= BundleCB->RLowerBonDInfo->ulBytesInSamplePeriod;
            NdisWanDbgOut(DBG_TRACE, DBG_BACP, ("L-R: Bps %I64d Threshold %I64d Util %I64d",
                     Bps, BundleCB->RLowerBonDInfo->ulBytesThreshold, util));
        }
#endif
    }
}

#endif  // end of ifdef NT

#if DBG
VOID
InsertSendTrc(
    PSEND_TRC_INFO  SendTrcInfo,
    ULONG           DataLength,
    PUCHAR          Data
    )
{
    PWAN_TRC_EVENT  NewTrcEvent;
    PSEND_TRC_INFO  TrcInfo;

    if (WanTrcCount == 4096) {
        NewTrcEvent = (PWAN_TRC_EVENT)
            RemoveTailList(&WanTrcList);

        NdisWanFreeMemory(NewTrcEvent->TrcInfo);

        NdisZeroMemory(NewTrcEvent, sizeof(WAN_TRC_EVENT));

    } else {
        NdisWanAllocateMemory(&NewTrcEvent, 
                              sizeof(WAN_TRC_EVENT), 
                              WANTRCEVENT_TAG);

        if (NewTrcEvent == NULL) {
            return;
        }
    }

    WanTrcCount += 1;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\wan.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Wan.h

Abstract:

    This file contains all include files for the NdisWan driver.



Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <xfilter.h>
#include <ntddk.h>
#include <ndisprv.h>

#include "wandefs.h"
#include "debug.h"
#include "wanpub.h"
#include "wantypes.h"
#include "adapter.h"
#include "global.h"
#include "wanproto.h"

#include <rc4.h>
#include "compress.h"
#include "tcpip.h"
#include "vjslip.h"

#include "isnipx.h"
#include "nbfconst.h"
#include "nbfhdrs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\vjslip.h ===
#ifndef _VJSLIP_
#define _VJSLIP_

/*
 * Copyright (c) 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are
 * permitted provided that the above copyright notice and this
 * paragraph are duplicated in all such forms and that any
 * documentation, advertising materials, and other materials
 * related to such distribution and use acknowledge that the
 * software was developed by the University of California,
 * Berkeley.  The name of the University may not be used to
 * endorse or promote products derived from this software
 * without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
 * IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE.
 */


// A.1  Definitions and State Data

#define MAX_VJ_STATES 16   /* must be >2 and <255 */
#define MAX_HDR 128     /* max TCP+IP hdr length (by protocol def) */


//
// NT is little endian, so we follow these rules
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define ntohs(x) _byteswap_ushort((USHORT)(x))
#define ntohl(x) _byteswap_ulong((ULONG)(x))
#else
#define ntohs(x) (USHORT)( ((x) >> 8) + (((x) & 0xFF)  << 8) )

#define ntohl(x) (ULONG) ( ((x) >> 24) + (((x) & 0xFF0000) >> 8) +\
                 (((x) & 0xFF00) << 8) + (((x) & 0xFF) << 24) )
#endif

#define htons(x) ntohs(x)
#define htonl(x) ntohl(x)


/* packet types */
#define TYPE_IP                 0x40
#define TYPE_UNCOMPRESSED_TCP   0x70
#define TYPE_COMPRESSED_TCP     0x80
#define TYPE_ERROR              0x00
                     /* this is not a type that ever appears on
                      * the wire.  The receive framer uses it to
                      * tell the decompressor there was a packet
                      * transmission error. */
/*
 * Bits in first octet of compressed packet
 */

/* flag bits for what changed in a packet */

#define NEW_C  0x40
#define NEW_I  0x20
#define TCP_PUSH_BIT 0x10

#define NEW_S  0x08
#define NEW_A  0x04
#define NEW_W  0x02
#define NEW_U  0x01


/* reserved, special-case values of above */
#define SPECIAL_I (NEW_S|NEW_W|NEW_U)        /* echoed interactive traffic */
#define SPECIAL_D (NEW_S|NEW_A|NEW_W|NEW_U)  /* unidirectional data */
#define SPECIALS_MASK (NEW_S|NEW_A|NEW_W|NEW_U)


/*
 * "state" data for each active tcp conversation on the wire.  This is
 * basically a copy of the entire IP/TCP header from the last packet together
 * with a small identifier the transmit & receive ends of the line use to
 * locate saved header.
 */

struct cstate {
     struct cstate *cs_next;  /* next most recently used cstate (xmit only) */
     USHORT cs_hlen;         /* size of hdr (receive only) */
     UCHAR cs_id;            /* connection # associated with this state */
     UCHAR cs_filler;
     union {
          UCHAR hdr[MAX_HDR];
          struct ip_v4 csu_ip;   /* ip/tcp hdr from most recent packet */
     } slcs_u;
};

#define cs_ip slcs_u.csu_ip

#define cs_hdr slcs_u.csu_hdr

/*
 * all the state data for one serial line (we need one of these per line).
 */
typedef struct slcompress slcompress;

struct slcompress {
     struct cstate *last_cs;           /* most recently used tstate */
     UCHAR last_recv;                  /* last rcvd conn. id */
     UCHAR last_xmit;                  /* last sent conn. id */
     USHORT flags;
     UCHAR  MaxStates;
//
// Some Statistics
//
     ULONG  OutPackets;
     ULONG  OutCompressed;
     ULONG  OutSearches;
     ULONG  OutMisses;
     ULONG  InUncompressed;
     ULONG  InCompressed;
     ULONG  InErrors;
     ULONG  InTossed;

     struct cstate tstate[MAX_VJ_STATES];  /* xmit connection states */
     struct cstate rstate[MAX_VJ_STATES];  /* receive connection states */
};

struct mbuf {
    PUCHAR  m_off;          // pointer to start of data
    UINT    m_len;          // length of data
};

#define mtod(m,t)  ((t)(m->m_off))

/* flag values */
#define SLF_TOSS    1       /* tossing rcvd frames because of input err */

/*
 * The following macros are used to encode and decode numbers.  They all
 * assume that `cp' points to a buffer where the next byte encoded (decoded)
 * is to be stored (retrieved).  Since the decode routines do arithmetic,
 * they have to convert from and to network byte order.
 */

/*
 * ENCODE encodes a number that is known to be non-zero.  ENCODEZ checks for
 * zero (zero has to be encoded in the long, 3 byte form).
 */
#define ENCODE(n) { \
     if ((USHORT)(n) >= 256) { \
          *cp++ = 0; \
          cp[1] = (UCHAR)(n); \
          cp[0] = (UCHAR)((n) >> 8); \
          cp += 2; \
     } else { \
          *cp++ = (UCHAR)(n); \
     } \
}

#define ENCODEZ(n) { \
     if ((USHORT)(n) >= 256 || (USHORT)(n) == 0) { \
          *cp++ = 0; \
          cp[1] = (UCHAR)(n); \
          cp[0] = (UCHAR)((n) >> 8); \
          cp += 2; \
     } else { \
          *cp++ = (UCHAR)(n); \
     } \
}

/*
 * DECODEL takes the (compressed) change at byte cp and adds it to the
 * current value of packet field 'f' (which must be a 4-byte (long) integer
 * in network byte order).  DECODES does the same for a 2-byte (short) field.
 * DECODEU takes the change at cp and stuffs it into the (short) field f.
 * 'cp' is updated to point to the next field in the compressed header.
 */

#define DECODEL(f) { \
     ULONG _x_ = ntohl(f); \
     if (*cp == 0) {\
          _x_ += ((cp[1] << 8) + cp[2]); \
          (f) = htonl(_x_); \
          cp += 3; \
     } else { \
          _x_ += *cp; \
          (f) = htonl(_x_); \
          cp++; \
     } \
}

#define DECODES(f) { \
     USHORT _x_= ntohs(f); \
     if (*cp == 0) {\
          _x_ += ((cp[1] << 8) + cp[2]); \
          (f) = htons(_x_); \
          cp += 3; \
     } else { \
          _x_ += *cp; \
          (f) = htons(_x_); \
          cp++; \
     } \
}

#define DECODEU(f) { \
     USHORT _x_; \
     if (*cp == 0) {\
          _x_=(cp[1] << 8) + cp[2]; \
          (f) = htons(_x_); \
          cp += 3; \
     } else { \
          _x_=*cp; \
          (f) = htons(_x_); \
          cp++; \
     } \
}

typedef UCHAR UNALIGNED * PUUCHAR;


UCHAR
sl_compress_tcp(
    PUUCHAR UNALIGNED *m_off,       // Frame start (points to IP header)
    PULONG m_len,                   // Length of entire frame
    PULONG precomph_len,            // Length of tcp/ip header pre-comp
    PULONG postcomph_len,           // Length of tcp/ip header post-comp
    struct slcompress *comp,        // Compression struct for this link
    ULONG compress_cid);            // Compress connection id boolean

//LONG
//sl_uncompress_tcp(
//    PUUCHAR UNALIGNED *bufp,
//    LONG len,
//    UCHAR type,
//    struct slcompress *comp);
LONG
sl_uncompress_tcp(
    PUUCHAR UNALIGNED *InBuffer,
    PLONG   InLength,
    UCHAR   UNALIGNED *OutBuffer,
    PLONG   OutLength,
    UCHAR   type,
    struct slcompress *comp
    );

NDIS_STATUS
sl_compress_init(
    struct slcompress **comp,
    UCHAR MaxStates);

VOID
sl_compress_terminate(
    struct slcompress **comp
    );

#endif // _VJSLIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\vjslip.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    vjslip.c

Abstract:

Author:

    Thomas J. Dimitri  (TommyD)

Environment:

Revision History:

--*/

#include "wan.h"

#define __FILE_SIG__    VJ_FILESIG

#if 0
NPAGED_LOOKASIDE_LIST   VJCtxList; // List of free vj context descs
#endif

#define INCR(counter) ++comp->counter;

//   A.2  Compression
//
//   This routine looks daunting but isn't really.  The code splits into four
//   approximately equal sized sections:  The first quarter manages a
//   circularly linked, least-recently-used list of `active' TCP
//   connections./47/  The second figures out the sequence/ack/window/urg
//   changes and builds the bulk of the compressed packet.  The third handles
//   the special-case encodings.  The last quarter does packet ID and
//   connection ID encoding and replaces the original packet header with the
//   compressed header.
//
//   The arguments to this routine are a pointer to a packet to be
//   compressed, a pointer to the compression state data for the serial line,
//   and a flag which enables or disables connection id (C bit) compression.
//
//   Compression is done `in-place' so, if a compressed packet is created,
//   both the start address and length of the incoming packet (the off and
//   len fields of m) will be updated to reflect the removal of the original
//   header and its replacement by the compressed header.  If either a
//   compressed or uncompressed packet is created, the compression state is
//   updated.  This routines returns the packet type for the transmit framer
//   (TYPE_IP, TYPE_UNCOMPRESSED_TCP or TYPE_COMPRESSED_TCP).
//
//   Because 16 and 32 bit arithmetic is done on various header fields, the
//   incoming IP packet must be aligned appropriately (e.g., on a SPARC, the
//   IP header is aligned on a 32-bit boundary).  Substantial changes would
//   have to be made to the code below if this were not true (and it would
//   probably be cheaper to byte copy the incoming header to somewhere
//   correctly aligned than to make those changes).
//
//   Note that the outgoing packet will be aligned arbitrarily (e.g., it
//   could easily start on an odd-byte boundary).
//

UCHAR
sl_compress_tcp(
    PUUCHAR UNALIGNED   *m_off,         // Frame start (points to IP header)
    ULONG               *m_len,         // Length of entire frame
    ULONG               *precomph_len,  // Length of TCP/IP header pre-comp
    ULONG               *postcomph_len, // Length of TCP/IP header post-comp
    struct slcompress   *comp,          // Compression struct for this link
    ULONG compress_cid) {               // Compress connection id boolean

    struct cstate *cs = comp->last_cs->cs_next;
    struct ip_v4 UNALIGNED *ip = (struct ip_v4 UNALIGNED *)*m_off;
    struct ip_v4 UNALIGNED *csip;
    ULONG hlen = ip->ip_hl & 0x0F;      // last 4 bits are the length
    struct tcphdr UNALIGNED *oth;       /* last TCP header */
    struct tcphdr UNALIGNED *th;        /* current TCP header */

//   ----------------------------
//    47. The two most common operations on the connection list are a `find'
//   that terminates at the first entry (a new packet for the most recently
//   used connection) and moving the last entry on the list to the head of
//   the list (the first packet from a new connection).  A circular list
//   efficiently handles these two operations.

    ULONG deltaS, deltaA;     /* general purpose temporaries */
    ULONG changes = 0;        /* change mask */
    UCHAR new_seq[16];       /* changes from last to current */
    UCHAR UNALIGNED *cp = new_seq;
    USHORT ip_len;

    /*
     * Bail if this is an IP fragment or if the TCP packet isn't
     * `compressible' (i.e., ACK isn't set or some other control bit is
     * set).  Or if it does not contain the TCP protocol.
     */
    if ((ip->ip_off & 0xff3f) || *m_len < 40 || ip->ip_p != IPPROTO_TCP)
         return (TYPE_IP);

    th = (struct tcphdr UNALIGNED *) & ((ULONG UNALIGNED *) ip)[hlen];
    if ((th->th_flags & (TH_SYN | TH_FIN | TH_RST | TH_ACK)) != TH_ACK)
         return (TYPE_IP);

    //
    // The TCP/IP stack is propagating the padding bytes that it
    // is receiving off of the LAN.  This shows up here as a
    // packet that has a length that is greater than the IP datagram
    // length.  We will add this work around for now.
    //
    if (*m_len > ntohs(ip->ip_len)) {
        *m_len = ntohs(ip->ip_len);
    }

    /*
     * Packet is compressible -- we're going to send either a
     * COMPRESSED_TCP or UNCOMPRESSED_TCP packet.  Either way we need to
     * locate (or create) the connection state.  Special case the most
     * recently used connection since it's most likely to be used again &
     * we don't have to do any reordering if it's used.
     */

    //
    // Keep stats here
    //
    INCR(OutPackets);

    csip = (struct ip_v4 UNALIGNED*)&cs->cs_ip;

    if (ip->ip_src.s_addr != csip->ip_src.s_addr ||
        ip->ip_dst.s_addr != csip->ip_dst.s_addr ||
        *(ULONG UNALIGNED *) th != ((ULONG UNALIGNED *) csip)[csip->ip_hl & 0x0F]) {

         /*
          * Wasn't the first -- search for it.
          *
          * States are kept in a circularly linked list with last_cs
          * pointing to the end of the list.  The list is kept in lru
          * order by moving a state to the head of the list whenever
          * it is referenced.  Since the list is short and,
          * empirically, the connection we want is almost always near
          * the front, we locate states via linear search.  If we
          * don't find a state for the datagram, the oldest state is
          * (re-)used.
          */
         struct cstate *lcs;
         struct cstate *lastcs = comp->last_cs;

         do {
              lcs = cs;
              cs = cs->cs_next;
              INCR(OutSearches);

              csip = (struct ip_v4 UNALIGNED*)&cs->cs_ip;

              if (ip->ip_src.s_addr == csip->ip_src.s_addr &&
                  ip->ip_dst.s_addr == csip->ip_dst.s_addr &&
                  *(ULONG UNALIGNED *) th == ((ULONG UNALIGNED *) csip)[cs->cs_ip.ip_hl & 0x0F])

                   goto found;

         } while (cs != lastcs);

         /*
          * Didn't find it -- re-use oldest cstate.  Send an
          * uncompressed packet that tells the other side what
          * connection number we're using for this conversation. Note
          * that since the state list is circular, the oldest state
          * points to the newest and we only need to set last_cs to
          * update the lru linkage.
          */

         INCR(OutMisses);

         //
         // A miss!
         //
         comp->last_cs = lcs;
         hlen += (th->th_off >> 4);
         hlen <<= 2;

         if (hlen > *m_len) {
             return(TYPE_IP);
         }

         goto uncompressed;

found:
         /* Found it -- move to the front on the connection list. */
         if (cs == lastcs)
              comp->last_cs = lcs;
         else {
              lcs->cs_next = cs->cs_next;
              cs->cs_next = lastcs->cs_next;
              lastcs->cs_next = cs;
         }
    }

    /*
     * Make sure that only what we expect to change changed. The first
     * line of the `if' checks the IP protocol version, header length &
     * type of service.  The 2nd line checks the "Don't fragment" bit.
     * The 3rd line checks the time-to-live and protocol (the protocol
     * check is unnecessary but costless).  The 4th line checks the TCP
     * header length.  The 5th line checks IP options, if any.  The 6th
     * line checks TCP options, if any.  If any of these things are
     * different between the previous & current datagram, we send the
     * current datagram `uncompressed'.
     */
    oth = (struct tcphdr UNALIGNED *) & ((ULONG UNALIGNED *) csip)[hlen];
    deltaS = hlen;
    hlen += (th->th_off >> 4);
    hlen <<= 2;

    //
    // Bug fix?  It's in cslip.tar.Z
    //
    if (hlen > *m_len) {
        NdisWanDbgOut(DBG_FAILURE, DBG_VJ,("Bad TCP packet length"));
        return(TYPE_IP);
    }

    if (((USHORT UNALIGNED *) ip)[0] != ((USHORT UNALIGNED *) csip)[0] ||
        ((USHORT UNALIGNED *) ip)[3] != ((USHORT UNALIGNED *) csip)[3] ||
        ((USHORT UNALIGNED *) ip)[4] != ((USHORT UNALIGNED *) csip)[4] ||
        (th->th_off >> 4) != (oth->th_off >> 4) ||
        (deltaS > 5 &&
         memcmp((UCHAR UNALIGNED *)(ip + 1), (UCHAR UNALIGNED *)(csip + 1), (deltaS - 5) << 2)) ||
        ((th->th_off >> 4) > 5 &&
         memcmp((UCHAR UNALIGNED *)(th + 1), (UCHAR UNALIGNED *)(oth + 1), ((th->th_off >> 4) - 5) << 2))) {

        goto uncompressed;
    }

    /*
     * Figure out which of the changing fields changed.  The receiver
     * expects changes in the order: urgent, window, ack, seq.
     */
    if (th->th_flags & TH_URG) {
         deltaS = ntohs(th->th_urp);
         ENCODEZ(deltaS);
         changes |= NEW_U;
    } else if (th->th_urp != oth->th_urp) {
    
         /*
          * argh! URG not set but urp changed -- a sensible
          * implementation should never do this but RFC793 doesn't
          * prohibit the change so we have to deal with it.
          */
         goto uncompressed;
    }

    if (deltaS = (USHORT) (ntohs(th->th_win) - ntohs(oth->th_win))) {
         ENCODE(deltaS);
         changes |= NEW_W;
    }
    if (deltaA = ntohl(th->th_ack) - ntohl(oth->th_ack)) {
        if (deltaA > 0xffff) {
            goto uncompressed;
        }

         ENCODE(deltaA);
         changes |= NEW_A;
    }
    if (deltaS = ntohl(th->th_seq) - ntohl(oth->th_seq)) {
        if (deltaS > 0xffff) {
            goto uncompressed;
        }

         ENCODE(deltaS);
         changes |= NEW_S;
    }

    ip_len = ntohs(csip->ip_len);

    /*
     * Look for the special-case encodings.
     */
    switch (changes) {

    case 0:
         /*
          * Nothing changed. If this packet contains data and the last
          * one didn't, this is probably a data packet following an
          * ack (normal on an interactive connection) and we send it
          * compressed.  Otherwise it's probably a retransmit,
          * retransmitted ack or window probe.  Send it uncompressed
          * in case the other side missed the compressed version.
          */
         if (ip->ip_len != csip->ip_len &&
             ip_len == hlen)

              break;

         /* (fall through) */

    case SPECIAL_I:
    case SPECIAL_D:
         /*
          * Actual changes match one of our special case encodings --
          * send packet uncompressed.
          */
         goto uncompressed;

    case NEW_S | NEW_A:
         if (deltaS == deltaA &&
             deltaS == (ip_len - hlen)) {
              /* special case for echoed terminal traffic */
              changes = SPECIAL_I;
              cp = new_seq;
         }
         break;

    case NEW_S:
         if (deltaS == (ip_len - hlen)) {
              /* special case for data xfer */
              changes = SPECIAL_D;
              cp = new_seq;
         }
         break;
    }

    deltaS = ntohs(ip->ip_id) - ntohs(csip->ip_id);

    if (deltaS != 1) {
         ENCODEZ(deltaS);
         changes |= NEW_I;
    }

    if (th->th_flags & TH_PUSH)
         changes |= TCP_PUSH_BIT;
    /*
     * Grab the cksum before we overwrite it below.  Then update our
     * state with this packet's header.
     */
    deltaA = (th->th_sumhi << 8) + th->th_sumlo;

    NdisMoveMemory((UCHAR UNALIGNED *)csip,
                   (UCHAR UNALIGNED *)ip,
                   hlen);

    /*
     * We want to use the original packet as our compressed packet. (cp -
     * new_seq) is the number of bytes we need for compressed sequence
     * numbers.  In addition we need one byte for the change mask, one
     * for the connection id and two for the tcp checksum. So, (cp -
     * new_seq) + 4 bytes of header are needed.  hlen is how many bytes
     * of the original packet to toss so subtract the two to get the new
     * packet size.
     */
    deltaS = (ULONG)(cp - new_seq);
    cp = (UCHAR UNALIGNED *) ip;
    *precomph_len = hlen;

    if (compress_cid == 0 || comp->last_xmit != cs->cs_id) {
         comp->last_xmit = cs->cs_id;
         hlen -= deltaS + 4;
         *postcomph_len = deltaS + 4;
         cp += hlen;
         *cp++ = (UCHAR)(changes | NEW_C);
         *cp++ = cs->cs_id;
    } else {
         hlen -= deltaS + 3;
         *postcomph_len = deltaS + 3;
         cp += hlen;
         *cp++ = (UCHAR)changes;
    }

    *m_len -= hlen;
    *m_off += hlen;
    *cp++ = (UCHAR)(deltaA >> 8);
    *cp++ = (UCHAR)(deltaA);

    NdisMoveMemory((UCHAR UNALIGNED *)cp,
                   (UCHAR UNALIGNED *)new_seq,
                   deltaS);

    INCR(OutCompressed);
    return (TYPE_COMPRESSED_TCP);

uncompressed:
    /*
     * Update connection state cs & send uncompressed packet
     * ('uncompressed' means a regular ip/tcp packet but with the
     * 'conversation id' we hope to use on future compressed packets in
     * the protocol field).
     */

    NdisMoveMemory((UCHAR UNALIGNED *)csip,
                   (UCHAR UNALIGNED *)ip,
                   hlen);

    ip->ip_p = cs->cs_id;
    comp->last_xmit = cs->cs_id;
    return (TYPE_UNCOMPRESSED_TCP);
}





//   A.3  Decompression
//
//   This routine decompresses a received packet.  It is called with a
//   pointer to the packet, the packet length and type, and a pointer to the
//   compression state structure for the incoming serial line.  It returns a
//   pointer to the resulting packet or zero if there were errors in the
//   incoming packet.  If the packet is COMPRESSED_TCP or UNCOMPRESSED_TCP,
//   the compression state will be updated.
//
//   The new packet will be constructed in-place.  That means that there must
//   be 128 bytes of free space in front of bufp to allow room for the
//   reconstructed IP and TCP headers.  The reconstructed packet will be
//   aligned on a 32-bit boundary.
//

//LONG
//sl_uncompress_tcp(
//    PUUCHAR UNALIGNED  *bufp,
//    LONG len,
//    UCHAR type,
//    struct slcompress  *comp) {
LONG
sl_uncompress_tcp(
    PUUCHAR UNALIGNED *InBuffer,
    PLONG   InLength,
    UCHAR   UNALIGNED *OutBuffer,
    PLONG   OutLength,
    UCHAR   type,
    struct slcompress *comp
    )
{
    UCHAR UNALIGNED *cp;
    LONG inlen;
    LONG hlen, changes;
    struct tcphdr UNALIGNED *th;
    struct cstate *cs;
    struct ip_v4 UNALIGNED *ip;

    inlen = *InLength;

    switch (type) {

    case TYPE_ERROR:
    default:
        NdisWanDbgOut(DBG_FAILURE, DBG_VJ, ("Packet transmission error type 0x%.2x",type));
         goto bad;

    case TYPE_IP:
         break;

    case TYPE_UNCOMPRESSED_TCP:
         /*
          * Locate the saved state for this connection.  If the state
          * index is legal, clear the 'discard' flag.
          */
         ip = (struct ip_v4 UNALIGNED *) *InBuffer;
         if (ip->ip_p >= comp->MaxStates) {
            NdisWanDbgOut(DBG_FAILURE, DBG_VJ, ("Max state exceeded %u", ip->ip_p));
            goto bad;
         }

         cs = &comp->rstate[comp->last_recv = ip->ip_p];
         comp->flags &= ~SLF_TOSS;

         /*
          * Restore the IP protocol field then save a copy of this
          * packet header.  (The checksum is zeroed in the copy so we
          * don't have to zero it each time we process a compressed
          * packet.
          */
         hlen = ip->ip_hl & 0x0F;
         hlen += ((struct tcphdr UNALIGNED *) & ((ULONG UNALIGNED *) ip)[hlen])->th_off >> 4;
         hlen <<= 2;

         if (hlen > inlen) {
             NdisWanDbgOut(DBG_FAILURE, DBG_VJ, ("recv'd runt uncompressed packet %d %d", hlen, inlen));
             goto bad;
         }

         NdisMoveMemory((PUCHAR)&cs->cs_ip,
                        (PUCHAR)ip,
                        hlen);

         cs->cs_ip.ip_p = IPPROTO_TCP;

         NdisMoveMemory((PUCHAR)OutBuffer,
                        (PUCHAR)&cs->cs_ip,
                        hlen);

         cs->cs_ip.ip_sum = 0;
         cs->cs_hlen = (USHORT)hlen;

         *InBuffer = (PUCHAR)ip + hlen;
         *InLength = inlen - hlen;
         *OutLength = hlen;

         INCR(InUncompressed);
         return (inlen);

    case TYPE_COMPRESSED_TCP:
         break;
    }

    /* We've got a compressed packet. */
    INCR(InCompressed);
    cp = *InBuffer;
    changes = *cp++;

    if (changes & NEW_C) {
         /*
          * Make sure the state index is in range, then grab the
          * state. If we have a good state index, clear the 'discard'
          * flag.
          */
         if (*cp >= comp->MaxStates) {
            NdisWanDbgOut(DBG_FAILURE, DBG_VJ, ("MaxState of %u too big", *cp));                
            goto bad;
         }

         comp->flags &= ~SLF_TOSS;
         comp->last_recv = *cp++;
    } else {
         /*
          * This packet has an implicit state index.  If we've had a
          * line error since the last time we got an explicit state
          * index, we have to toss the packet.
          */
         if (comp->flags & SLF_TOSS) {
            NdisWanDbgOut(DBG_FAILURE, DBG_VJ,("Packet has state index, have to toss it"));
            INCR(InTossed);
            return (0);
        }
    }

    /*
     * Find the state then fill in the TCP checksum and PUSH bit.
     */

    cs = &comp->rstate[comp->last_recv];

    //
    // If there was a line error and we did not get notified we could
    // miss a TYPE_UNCOMPRESSED_TCP which would leave us with an
    // un-init'd cs!
    //
    if (cs->cs_hlen == 0) {
        NdisWanDbgOut(DBG_FAILURE, DBG_VJ,("Un-Init'd state!"));
        goto bad;
    }

    hlen = (cs->cs_ip.ip_hl & 0x0F) << 2;
    th = (struct tcphdr UNALIGNED  *) & ((UCHAR UNALIGNED  *) &cs->cs_ip)[hlen];

    th->th_sumhi = cp[0];
    th->th_sumlo = cp[1];

    cp += 2;
    if (changes & TCP_PUSH_BIT)
         th->th_flags |= TH_PUSH;
    else
         th->th_flags &= ~TH_PUSH;

    /*
     * Fix up the state's ack, seq, urg and win fields based on the
     * changemask.
     */
    switch (changes & SPECIALS_MASK) {
    case SPECIAL_I:
         {
            UCHAR UNALIGNED *   piplen=(UCHAR UNALIGNED *)&(cs->cs_ip.ip_len);
            UCHAR UNALIGNED *   ptcplen;
            ULONG   tcplen;
            ULONG   i;

            i = ((piplen[0] << 8) + piplen[1]) - cs->cs_hlen;

//          th->th_ack = htonl(ntohl(th->th_ack) + i);

            ptcplen=(UCHAR UNALIGNED *)&(th->th_ack);
            tcplen=(ptcplen[0] << 24) + (ptcplen[1] << 16) +
                    (ptcplen[2] << 8) + ptcplen[3] + i;
            ptcplen[3]=(UCHAR)(tcplen);
            ptcplen[2]=(UCHAR)(tcplen >> 8);
            ptcplen[1]=(UCHAR)(tcplen >> 16);
            ptcplen[0]=(UCHAR)(tcplen >> 24);


//          th->th_seq = htonl(ntohl(th->th_seq) + i);

            ptcplen=(UCHAR UNALIGNED *)&(th->th_seq);
            tcplen=(ptcplen[0] << 24) + (ptcplen[1] << 16) +
                    (ptcplen[2] << 8) + ptcplen[3] + i;
            ptcplen[3]=(UCHAR)(tcplen);
            ptcplen[2]=(UCHAR)(tcplen >> 8);
            ptcplen[1]=(UCHAR)(tcplen >> 16);
            ptcplen[0]=(UCHAR)(tcplen >> 24);

         }
         break;

    case SPECIAL_D:
         {
//          th->th_seq = htonl(ntohl(th->th_seq) + ntohs(cs->cs_ip.ip_len)
//                      - cs->cs_hlen);

            UCHAR   UNALIGNED *piplen=(UCHAR UNALIGNED *)&(cs->cs_ip.ip_len);
            UCHAR   UNALIGNED *ptcplen;
            ULONG   tcplen;
            ULONG   i;

            i = ((piplen[0] << 8) + piplen[1]) - cs->cs_hlen;

            ptcplen=(UCHAR UNALIGNED *)&(th->th_seq);
            tcplen=(ptcplen[0] << 24) + (ptcplen[1] << 16) +
                    (ptcplen[2] << 8) + ptcplen[3] + i;

            ptcplen[3]=(UCHAR)(tcplen);
            ptcplen[2]=(UCHAR)(tcplen >> 8);
            ptcplen[1]=(UCHAR)(tcplen >> 16);
            ptcplen[0]=(UCHAR)(tcplen >> 24);


         }

         break;

    default:
         if (changes & NEW_U) {
              th->th_flags |= TH_URG;
              DECODEU(th->th_urp)
         } else
              th->th_flags &= ~TH_URG;

         if (changes & NEW_W)
            DECODES(th->th_win);
         if (changes & NEW_A)
            DECODEL(th->th_ack)
         if (changes & NEW_S)
            DECODEL(th->th_seq)

         break;
    }
    /* Update the IP ID */
    if (changes & NEW_I) {
    
         DECODES(cs->cs_ip.ip_id)

    } else {

        USHORT id;
        UCHAR UNALIGNED *pid = (UCHAR UNALIGNED *)&(cs->cs_ip.ip_id);

//        cs->cs_ip.ip_id = htons(ntohs(cs->cs_ip.ip_id) + 1);
        id=(pid[0] << 8) + pid[1] + 1;
        pid[0]=(UCHAR)(id >> 8);
        pid[1]=(UCHAR)(id);
    }


    /*
     * At this point, cp points to the first byte of data in the packet.
     * If we're not aligned on a 4-byte boundary, copy the data down so
     * the IP & TCP headers will be aligned.  Then back up cp by the
     * TCP/IP header length to make room for the reconstructed header (we
     * assume the packet we were handed has enough space to prepend 128
     * bytes of header).  Adjust the lenth to account for the new header
     * & fill in the IP total length.
     */
//    len -= (cp - *bufp);
    inlen -= (ULONG)(cp - *InBuffer);

    if (inlen < 0) {
    
         /*
          * we must have dropped some characters (crc should detect
          * this but the old slip framing won't)
          */
        NdisWanDbgOut(DBG_FAILURE, DBG_VJ,("len has dropped below 0!"));
         goto bad;
    }
//
//  Who Cares about 4 byte alignement!  It's just a useless big copy!
//
//    if ((ULONG) cp & 3) {
//         if (len > 0)
//          //
//          // BUG BUG we want OVBCOPY..
//          //
//            NdisMoveMemory(
//              (PUCHAR)((ULONG) cp & ~3),
//              cp,
//              len);
//         cp = (PUCHAR) ((ULONG) cp & ~3);
//    }

//    cp -= cs->cs_hlen;
//    len += cs->cs_hlen;

//    cs->cs_ip.ip_len = htons(len);
    cs->cs_ip.ip_len = htons(inlen + cs->cs_hlen);

//  NdisMoveMemory(
//      (PUCHAR)cp,
//      (PUCHAR)&cs->cs_ip,
//      cs->cs_hlen);

  NdisMoveMemory((PUCHAR)OutBuffer,
                 (PUCHAR)&cs->cs_ip,
                 cs->cs_hlen);

//  *bufp = cp;
    *InBuffer = cp;
    *InLength = inlen;
    *OutLength = cs->cs_hlen;

    /* recompute the ip header checksum */
    {
//         USHORT UNALIGNED * bp = (USHORT UNALIGNED *) cp;
         USHORT UNALIGNED * bp = (USHORT UNALIGNED *) OutBuffer;

         for (changes = 0; hlen > 0; hlen -= 2)
              changes += *bp++;

         changes = (changes & 0xffff) + (changes >> 16);
         changes = (changes & 0xffff) + (changes >> 16);
//         ((struct ip_v4 UNALIGNED *) cp)->ip_sum = (USHORT)~changes;
         ((struct ip_v4 UNALIGNED *) OutBuffer)->ip_sum = (USHORT)~changes;
    }

    return (inlen + cs->cs_hlen);

bad:
    comp->flags |= SLF_TOSS;
    INCR(InErrors);
    return (0);
}




//   A.4  Initialization
//
//   This routine initializes the state structure for both the transmit and
//   receive halves of some serial line.  It must be called each time the
//   line is brought up.
//

VOID
WanInitVJ(
    VOID
)
{
#if 0
    NdisInitializeNPagedLookasideList(&VJCtxList,
                                      NULL,
                                      NULL,
                                      0,
                                      sizeof(slcompress),
                                      VJCTX_TAG,
                                      0);
#endif
}

VOID
WanDeleteVJ(
    VOID
    )
{
#if 0
    NdisDeleteNPagedLookasideList(&VJCtxList);
#endif
}

NDIS_STATUS
sl_compress_init(
    struct slcompress **retcomp,
    UCHAR  MaxStates
    )
{
    ULONG i;
    struct cstate *tstate; // = comp->tstate;
    struct slcompress *comp;

    comp = *retcomp;

    //
    // Do we need to allocate memory for this bundle
    //

    if (comp == NULL) {

        NdisWanAllocateMemory(&comp, sizeof(slcompress), VJCOMPRESS_TAG);

        //
        // If there was no memory to allocate
        //
        if (comp == NULL) {
    
            return(NDIS_STATUS_RESOURCES);
        }
    }

    tstate = comp->tstate;

    /*
     * Clean out any junk left from the last time line was used.
     */
    NdisZeroMemory(
        (PUCHAR) comp,
        sizeof(*comp));

    /*
     * Link the transmit states into a circular list.
     */
    for (i = MaxStates - 1; i > 0; --i) {
        tstate[i].cs_id = (UCHAR)i;
        tstate[i].cs_next = &tstate[i - 1];
    }

    tstate[0].cs_next = &tstate[MaxStates - 1];
    tstate[0].cs_id = 0;
    comp->last_cs = &tstate[0];

    /*
     * Make sure we don't accidentally do CID compression
     * (assumes MAX_VJ_STATES < 255).
     */
    comp->last_recv = 255;
    comp->last_xmit = 255;
    comp->flags = SLF_TOSS;
    comp->MaxStates=MaxStates;

    *retcomp = comp;

    return (NDIS_STATUS_SUCCESS);
}

VOID
sl_compress_terminate(
    struct slcompress **comp
    )
{
    if (*comp != NULL) {
        NdisWanFreeMemory(*comp);
        *comp = NULL;
    }
}

//   A.5  Berkeley Unix dependencies
//
//   Note:  The following is of interest only if you are trying to bring the
//   sample code up on a system that is not derived from 4BSD (Berkeley
//   Unix).
//
//   The code uses the normal Berkeley Unix header files (from
//   /usr/include/netinet) for definitions of the structure of IP and TCP
//   headers.  The structure tags tend to follow the protocol RFCs closely
//   and should be obvious even if you do not have access to a 4BSD
//   system./48/
//
//   ----------------------------
//    48. In the event they are not obvious, the header files (and all the
//   Berkeley networking code) can be anonymous ftp'd from host
//
//
//   The macro BCOPY(src, dst, amt) is invoked to copy amt bytes from src to
//   dst.  In BSD, it translates into a call to BCOPY.  If you have the
//   misfortune to be running System-V Unix, it can be translated into a call
//   to memcpy.  The macro OVBCOPY(src, dst, amt) is used to copy when src
//   and dst overlap (i.e., when doing the 4-byte alignment copy).  In the
//   BSD kernel, it translates into a call to ovbcopy.  Since AT&T botched
//   the definition of memcpy, this should probably translate into a copy
//   loop under System-V.
//
//   The macro BCMP(src, dst, amt) is invoked to compare amt bytes of src and
//   dst for equality.  In BSD, it translates into a call to bcmp.  In
//   System-V, it can be translated into a call to memcmp or you can write a
//   routine to do the compare.  The routine should return zero if all bytes
//   of src and dst are equal and non-zero otherwise.
//
//   The routine ntohl(dat) converts (4 byte) long dat from network byte
//   order to host byte order.  On a reasonable cpu this can be the no-op
//   macro:
//                           #define ntohl(dat) (dat)
//
//   On a Vax or IBM PC (or anything with Intel byte order), you will have to
//   define a macro or routine to rearrange bytes.
//
//   The routine ntohs(dat) is like ntohl but converts (2 byte) shorts
//   instead of longs.  The routines htonl(dat) and htons(dat) do the inverse
//   transform (host to network byte order) for longs and shorts.
//
//   A struct mbuf is used in the call to sl_compress_tcp because that
//   routine needs to modify both the start address and length if the
//   incoming packet is compressed.  In BSD, an mbuf is the kernel's buffer
//   management structure.  If other systems, the following definition should
//   be sufficient:
//
//            struct mbuf {
//                    UCHAR  *m_off; /* pointer to start of data */
//                    int     m_len;  /* length of data */
//            };
//
//            #define mtod(m, t) ((t)(m->m_off))
//
//
//   B  Compatibility with past mistakes
//
//
//   When combined with the modern PPP serial line protocol[9], the use of
//   header compression is automatic and invisible to the user.
//   Unfortunately, many sites have existing users of the SLIP described in
//   [12] which doesn't allow for different protocol types to distinguish
//   header compressed packets from IP packets or for version numbers or an
//   option exchange that could be used to automatically negotiate header
//   compression.
//
//   The author has used the following tricks to allow header compressed SLIP
//   to interoperate with the existing servers and clients.  Note that these
//   are hacks for compatibility with past mistakes and should be offensive
//   to any right thinking person.  They are offered solely to ease the pain
//   of running SLIP while users wait patiently for vendors to release PPP.
//
//
//   B.1  Living without a framing `type' byte
//
//   The bizarre packet type numbers in sec. A.1 were chosen to allow a
//   `packet type' to be sent on lines where it is undesirable or impossible
//   to add an explicit type byte.  Note that the first byte of an IP packet
//   always contains `4' (the IP protocol version) in the top four bits.  And
//   that the most significant bit of the first byte of the compressed header
//   is ignored.  Using the packet types in sec. A.1, the type can be encoded
//   in the most significant bits of the outgoing packet using the code
//
//                    p->dat[0] |= sl_compress_tcp(p, comp);
//
//    and decoded on the receive side by
//
//                  if (p->dat[0] & 0x80)
//                          type = TYPE_COMPRESSED_TCP;
//                  else if (p->dat[0] >= 0x70) {
//                          type = TYPE_UNCOMPRESSED_TCP;
//                          p->dat[0] &=~ 0x30;
//                  } else
//                          type = TYPE_IP;
//                  status = sl_uncompress_tcp(p, type, comp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\wandefs.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Wandefs.h

Abstract:

    This file contains defines for the NdisWan driver.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#ifndef _NDISWAN_DEFS_
#define _NDISWAN_DEFS_

//
// This needs to be added into ndis.h
//
#define SAP_TYPE_NDISWAN_PPP            0x00000004

//
// Device class currently used by RAS to query TAPI
// miniports for the connection wrapper ID
//
#define DEVICECLASS_NDISWAN_SAP         L"NDIS"

//
// Define if we are going to pull the miniport name out of
// an ndis wrapper control structure!!!!!! (kinda dirty)
//
#define MINIPORT_NAME           1

//
// Version stuff
//
#define NDISWAN_MAJOR_VERSION   5
#define NDISWAN_MINOR_VERSION   0

//
// Maximum number of protocols we can support
//
#define MAX_PROTOCOLS           32

//
// Identifiers for protocol type being added to the
// protocol lookup table
//
#define PROTOCOL_TYPE           0
#define PPP_TYPE                1

//
// Flags for Send packet properties
//
#define SEND_ON_WIRE            0x00000001
#define SELF_DIRECTED           0x00000002

#define MAC_HEADER_LENGTH       14
#define PROTOCOL_HEADER_LENGTH  128

//
// Maximum length possible for a ppp header
// No addr/ctrl comp (2)
// No proto id comp 
// multilink large sequence #'s (6)
// MPPC/MPPE (6)
// Protocol (2)
//
#define MAX_PPP_HEADER_LENGTH       14

// No addr/ctrl comp (4)
// No proto id comp 
// multilink large sequence #'s (6)
// MPPC/MPPE (6)
// Protocol (2)
//
#define MAX_PPP_LLC_HEADER_LENGTH   16

//
// Known protocol ID's
//
#define PROTOCOL_PRIVATE_IO     0xAB00
#define PROTOCOL_IP             0x0800
#define PROTOCOL_IPX            0x8137
#define PROTOCOL_NBF            0x80D5
#define PROTOCOL_APPLETALK      0x80F3

//
// Returned from protocol table lookup if value is
// not found
//
#define RESERVED_PROTOCOLCB     (IntToPtr(0xFFFFFFFF))

//
// OID Masks
//
#define OID_GEN                 0x00000000
#define OID_CO_GEN              0x00000000
#define OID_802_3               0x01000000
#define OID_WAN                 0x04000000
#define OID_PNP                 0xFD000000
#define OID_QOS                 0xFB000000

#define DEFAULT_MRU             1614
#define DEFAULT_MRRU            1614
#define DEFAULT_TUNNEL_MTU      1400
#define MAX_RECVDESC_COUNT      64

//
// Known PPP protocol ID's
//
#define PPP_PROTOCOL_PRIVATE_IO         0x00AB
#define PPP_PROTOCOL_IP                 0x0021
#define PPP_PROTOCOL_APPLETALK          0x0029
#define PPP_PROTOCOL_UNCOMPRESSED_TCP   0x002F
#define PPP_PROTOCOL_COMPRESSED_TCP     0x002D
#define PPP_PROTOCOL_IPX                0x002B
#define PPP_PROTOCOL_NBF                0x003F
#define PPP_PROTOCOL_COMPRESSION        0x00FD
#define PPP_PROTOCOL_COMP_RESET         0x80FD


//
//
//                                      
#define DEFAULT_MTU                 1500
#define MAX_OUTSTANDING_PACKETS     10
#define ONE_HUNDRED_MILS            1000000
#define ONE_SECOND                  10000000
#define TEN_SECONDS                 100000000
#define MILS_TO_100NANOS            10000
#define SAMPLE_ARRAY_SIZE           10
#define DEFAULT_PACKETQUEUE_DEPTH   128*1024
#define DEFAULT_MIN_FRAG_SIZE       64

//
// Multilink defines
//
#define MULTILINK_BEGIN_FRAME       0x80
#define MULTILINK_END_FRAME         0x40
#define MULTILINK_COMPLETE_FRAME    0xC0
#define MULTILINK_FLAG_MASK         0xC0
#define MULTILINK_HOLE_FLAG         0x01
#define SHORT_SEQ_MASK              0x0FFF
#define TEST_SHORT_SEQ              0x0800
#define LONG_SEQ_MASK               0x0FFFFFF
#define TEST_LONG_SEQ               0x00800000
#define MCML_SHORTCLASS_MASK        0x30
#define MCML_LONGCLASS_MASK         0x3C
#define MAX_MCML                    1


//
// Memory tags
//
#define BUNDLECB_TAG        'AnaW'
#define LINKPROTOCB_TAG     'BnaW'
#define SMALLDATADESC_TAG   'CnaW'
#define MEDIUMDATADESC_TAG  'DnaW'
#define LARGEDATADESC_TAG   'EnaW'
#define WANREQUEST_TAG      'FnaW'
#define LOOPBACKDESC_TAG    'GnaW'
#define VJCOMPRESS_TAG      'HnaW'
#define MINIPORTCB_TAG      'InaW'
#define OPENCB_TAG          'JnaW'
#define IOPACKET_TAG        'KnaW'
#define LINEUPINFO_TAG      'Lnaw'
#define NDISSTRING_TAG      'MnaW'
#define PROTOCOLTABLE_TAG   'NnaW'
#define CONNECTIONTABLE_TAG 'OnaW'
#define POOLDESC_TAG        'PnaW'
#define DATABUFFER_TAG      'QnaW'
#define WANPACKET_TAG       'RnaW'
#define AFSAPVCCB_TAG       'SnaW'
#define TRANSDRV_TAG        'TnaW'
#define BONDALLOC_TAG       'UnaW'
#define ENCRYPTCTX_TAG      'VnaW'
#define COMPCTX_TAG         'XnaW'
#define PROTOCOLCB_TAG      'ZnaW'

#define CACHEDKEY_TAG       'ANaW'

#if DBG
#define DBGPACKET_TAG       'znaW'
#define WANTRCEVENT_TAG     'ynaW'
#endif

#define RECVDESC_SIG        'vceR'
#define SENDESC_SIG         'dneS'
#define CLAFSAP_SIG         '  lC'
#define CMAFSAP_SIG         '  mC'
#define CMVC_SIG            'cVmC'
#define LINKCB_SIG          'kniL'
#define PROTOCB_SIG         'torP'

#define SEQ_EQ(_a, _b)  ((int)((_a) - (_b)) == 0)
#define SEQ_LT(_a, _b, _t)  (!SEQ_EQ(_a, _b) && ((int)((_a) - (_b)) & _t))
#define SEQ_LTE(_a, _b, _t) (SEQ_EQ(_a, _b) || ((int)((_a) - (_b)) & _t))
#define SEQ_GT(_a, _b, _t)  (!SEQ_EQ(_a, _b) && !((int)((_a) - (_b)) & _t))
#define SEQ_GTE(_a, _b, _t) (SEQ_EQ(_a, _b) || !((int)((_a) - (_b)) & _t))


//
// Link State's
//
typedef enum _LinkState {
    LINK_DOWN,
    LINK_GOING_DOWN,
    LINK_UP
} LinkState;

//
// Bundle State's
//
typedef enum _BundleState {
    BUNDLE_DOWN,
    BUNDLE_GOING_DOWN,
    BUNDLE_UP
} BundleState;

//
// Protocol State's
//
typedef enum _ProtocolState {
    PROTOCOL_UNROUTED,
    PROTOCOL_UNROUTING,
    PROTOCOL_ROUTING,
    PROTOCOL_ROUTED
} ProtocolState;

//
// Cm Vc State's
//
typedef enum _CmVcState {
    CMVC_CREATED,
    CMVC_ACTIVE,
    CMVC_CLOSE_DISPATCHED,
    CMVC_CLOSING,
    CMVC_DEACTIVE
} CmVcState;

typedef enum _ClCallState {
    CL_CALL_CLOSED,
    CL_CALL_CLOSE_PENDING,
    CL_CALL_CONNECTED
} ClCallState;

typedef enum _TransDrvState {
    TRANSDRV_OPENING,
    TRANSDRV_REGISTERING,
    TRANSDRV_OPENED,
    TRANSDRV_CLOSED
} TransDrvState;

//
// Wan request types
//
typedef enum _WanRequestType {
    ASYNC,
    SYNC
} WanRequestType;

typedef enum _WanRequestOrigin {
    NDISWAN,
    NDISTAPI
} WanRequestOrigin;

typedef enum _RECV_TYPE {
    RECV_LINK,
    RECV_BUNDLE_PPP,
    RECV_BUNDLE_DATA
} RECV_TYPE;

typedef enum _SEND_TYPE {
    SEND_LINK,
    SEND_BUNDLE_PPP,
    SEND_BUNDLE_DATA
} SEND_TYPE;

typedef enum _BandwidthOnDemandState {
    BonDSignaled,
    BonDIdle,
    BonDMonitor
} BandwithOnDemandState;

#ifdef CHECK_BUNDLE_LOCK
#define AcquireBundleLock(_pbcb)            \
{                                           \
    NdisAcquireSpinLock(&(_pbcb)->Lock);    \
    ASSERT(!(_pbcb)->LockAcquired);         \
    (_pbcb)->LockLine = __LINE__;           \
    (_pbcb)->LockFile = __FILE_SIG__;       \
    (_pbcb)->LockAcquired = TRUE;           \
}

#define ReleaseBundleLock(_pbcb)            \
{                                           \
    (_pbcb)->LockLine = __LINE__;           \
    (_pbcb)->LockAcquired = FALSE;          \
    NdisReleaseSpinLock(&(_pbcb)->Lock);    \
}

#else
#define AcquireBundleLock(_pbcb)            \
    NdisAcquireSpinLock(&(_pbcb)->Lock)
    
#define ReleaseBundleLock(_pbcb)            \
    NdisReleaseSpinLock(&(_pbcb)->Lock)
#endif

#define REF_NDISWANCB()\
    InterlockedIncrement(&NdisWanCB.RefCount)

#define DEREF_NDISWANCB()   \
    NdisWanInterlockedDec(&NdisWanCB.RefCount)

#define REF_BUNDLECB(_pbcb)                                     \
{                                                               \
    (_pbcb)->RefCount++;                                        \
}

//
// Decrement the reference count on the bundle.  If the count
// goes to zero we need to remove the bundle from the connection
// table and free it.
//
#define DEREF_BUNDLECB(_pbcb)                                   \
{                                                               \
    if ((_pbcb) != NULL) {                                      \
        AcquireBundleLock(_pbcb);                               \
        ASSERT((_pbcb)->RefCount > 0);                          \
        if (--(_pbcb)->RefCount == 0) {                         \
            DoDerefBundleCBWork(_pbcb);                         \
        } else {                                                \
            ReleaseBundleLock(_pbcb);                           \
        }                                                       \
    }                                                           \
}

//
// Decrement the reference count on the bundle.  If the count
// goes to zero we need to remove the bundle from the connection
// table and free it.
//
// Called with BundleCB->Lock held but returns with it released!
//
#define DEREF_BUNDLECB_LOCKED(_pbcb)                            \
{                                                               \
    if ((_pbcb) != NULL) {                                      \
        ASSERT((_pbcb)->RefCount > 0);                          \
        if (--(_pbcb)->RefCount == 0) {                         \
            DoDerefBundleCBWork(_pbcb);                         \
        } else {                                                \
            ReleaseBundleLock(_pbcb);                           \
        }                                                       \
    }                                                           \
}

#define REF_LINKCB(_plcb)                                       \
{                                                               \
    ASSERT((_plcb)->RefCount > 0);                              \
    (_plcb)->RefCount++;                                        \
}

//
// Decrement the reference count on the link.  If the count
// goes to zero we need to remove the link from the connection
// table and free it.
//
#define DEREF_LINKCB(_plcb)                                     \
{                                                               \
    if ((_plcb) != NULL) {                                      \
        NdisAcquireSpinLock(&(_plcb)->Lock);                    \
        ASSERT((_plcb)->RefCount > 0);                          \
        if (--(_plcb)->RefCount == 0) {                         \
            DoDerefLinkCBWork(_plcb);                           \
        } else {                                                \
            NdisReleaseSpinLock(&(_plcb)->Lock);                \
        }                                                       \
    }                                                           \
}

//
// Decrement the reference count on the link.  If the count
// goes to zero we need to remove the link from the connection
// table and free it.
//
// Called with LinkCB->Lock held but returns with it released!
//
#define DEREF_LINKCB_LOCKED(_plcb)                              \
{                                                               \
    if ((_plcb) != NULL) {                                      \
        PBUNDLECB   _pbcb = (_plcb)->BundleCB;                  \
        ASSERT((_plcb)->RefCount > 0);                          \
        if (--(_plcb)->RefCount == 0) {                         \
            DoDerefLinkCBWork(_plcb);                           \
        } else {                                                \
            NdisReleaseSpinLock(&(_plcb)->Lock);                \
        }                                                       \
    }                                                           \
}

#define REF_PROTOCOLCB(_ppcb)                                   \
{                                                               \
    ASSERT((_ppcb)->RefCount > 0);                              \
    (_ppcb)->RefCount++;                                        \
}

#define DEREF_PROTOCOLCB(_ppcb)                                 \
{                                                               \
    ASSERT((_ppcb)->RefCount > 0);                              \
    if (--(_ppcb)->RefCount == 0) {                             \
        ASSERT((_ppcb)->OutstandingFrames == 0);                \
        ASSERT((_ppcb)->State == PROTOCOL_UNROUTING);           \
        NdisWanSetSyncEvent(&(_ppcb)->UnrouteEvent);            \
        RemoveProtocolCBFromBundle(ProtocolCB);                 \
    }                                                           \
}

#define REF_OPENCB(_pocb)                                       \
    InterlockedIncrement(&(_pocb)->RefCount)

#define DEREF_OPENCB(_pocb)                                     \
{                                                               \
    if (InterlockedDecrement(&(_pocb)->RefCount) == 0) {        \
        NdisAcquireSpinLock(&(_pocb)->Lock);                    \
        ProtoCloseWanAdapter(_pocb);                            \
    }                                                           \
}

#define REF_MINIPORTCB(_pmcb)                                   \
    InterlockedIncrement(&(_pmcb)->RefCount)

#define DEREF_MINIPORTCB(_pmcb)                                 \
{                                                               \
    if (InterlockedDecrement(&(_pmcb)->RefCount) == 0) {        \
        NdisWanFreeMiniportCB(_pmcb);                           \
    }                                                           \
}

#define REF_CMVCCB(_pvccb)                                      \
    InterlockedIncrement(&(_pvccb)->RefCount)

#define DEREF_CMVCCB(_pvccb)                                    \
{                                                               \
    if (InterlockedDecrement(&(_pvccb)->RefCount) == 0) {       \
        DoDerefCmVcCBWork(_pvccb);                              \
    }                                                           \
}

#define REF_CLAFSAPCB(_pclaf)                                   \
    (_pclaf)->RefCount++;
    
#define DEREF_CLAFSAPCB(_pclaf)                                 \
{                                                               \
    NdisAcquireSpinLock(&((_pclaf)->Lock));                     \
    if (--(_pclaf)->RefCount == 0) {                            \
        DoDerefClAfSapCBWork(_pclaf);                           \
    } else {                                                    \
        NdisReleaseSpinLock(&((_pclaf)->Lock));                 \
    }                                                           \
}
    
#define DEREF_CLAFSAPCB_LOCKED(_pclaf)                          \
{                                                               \
    if (--(_pclaf)->RefCount == 0) {                            \
        DoDerefClAfSapCBWork(_pclaf);                           \
    } else {                                                    \
        NdisReleaseSpinLock(&((_pclaf)->Lock));                 \
    }                                                           \
}

#define BUNDLECB_FROM_LINKCB(_ppbcb, _plcb)                     \
{                                                               \
    *(_ppbcb) = (PBUNDLECB)_plcb->BundleCB;                     \
}

#define BUNDLECB_FROM_BUNDLEH(_ppbcb, _bh)                      \
{                                                               \
    LOCK_STATE  _ls;                                            \
    PBUNDLECB   _bcb = NULL;                                    \
    NdisAcquireReadWriteLock(&ConnTableLock, FALSE, &_ls);      \
    if ((ULONG_PTR)(_bh) <= ConnectionTable->ulArraySize) {     \
        _bcb = *(ConnectionTable->BundleArray + (ULONG_PTR)(_bh));\
    }                                                           \
    if (_bcb != NULL) {                                         \
        NdisDprAcquireSpinLock(&(_bcb)->Lock);                  \
        REF_BUNDLECB(_bcb);                                     \
        NdisDprReleaseSpinLock(&(_bcb)->Lock);                  \
    }                                                           \
    NdisReleaseReadWriteLock(&ConnTableLock, &_ls);             \
    *(_ppbcb) = _bcb;                                           \
}

#define LINKCB_FROM_LINKH(_pplcb, _lh)                          \
{                                                               \
    LOCK_STATE _ls;                                             \
    PLINKCB _lcb = NULL;                                        \
    NdisAcquireReadWriteLock(&ConnTableLock, FALSE, &_ls);      \
    if ((ULONG_PTR)(_lh) <= ConnectionTable->ulArraySize) {     \
        _lcb = *(ConnectionTable->LinkArray + (ULONG_PTR)(_lh));\
    }                                                           \
    if (_lcb != NULL) {                                         \
        NdisDprAcquireSpinLock(&(_lcb)->Lock);                  \
        REF_LINKCB(_lcb);                                       \
        NdisDprReleaseSpinLock(&(_lcb)->Lock);                  \
    }                                                           \
    NdisReleaseReadWriteLock(&ConnTableLock, &_ls);             \
    *(_pplcb) = _lcb;                                           \
}

#define InsertTailGlobalList(_gl, _ple)                         \
{                                                               \
    NdisAcquireSpinLock(&(_gl.Lock));                           \
    InsertTailList(&(_gl.List), (_ple));                        \
    _gl.ulCount++;                                              \
    if (_gl.ulCount > _gl.ulMaxCount) {                         \
        _gl.ulMaxCount = _gl.ulCount;                           \
    }                                                           \
    NdisReleaseSpinLock(&(_gl.Lock));                           \
}

#define InsertTailGlobalListEx(_gl, _ple, _t, _pt)              \
{                                                               \
    NdisAcquireSpinLock(&(_gl.Lock));                           \
    InsertTailList(&(_gl.List), (_ple));                        \
    _gl.ulCount++;                                              \
    if (_gl.ulCount > _gl.ulMaxCount) {                         \
        _gl.ulMaxCount = _gl.ulCount;                           \
    }                                                           \
    if (!_gl.TimerScheduled) {                                  \
        LARGE_INTEGER   _ft;                                    \
        _gl.TimerScheduled = TRUE;                              \
        _ft.QuadPart = Int32x32To64(_t, -10000);                \
        KeSetTimerEx(&_gl.Timer, _ft, _pt, &_gl.Dpc);           \
    }                                                           \
    NdisReleaseSpinLock(&(_gl.Lock));                           \
}

#define InsertHeadGlobalList(_gl, _ple)                         \
{                                                               \
    NdisAcquireSpinLock(&(_gl.Lock));                           \
    InsertHeadList(&(_gl.List), (_ple));                        \
    _gl.ulCount++;                                              \
    if (_gl.ulCount > _gl.ulMaxCount) {                         \
        _gl.ulMaxCount = _gl.ulCount;                           \
    }                                                           \
    NdisReleaseSpinLock(&(_gl.Lock));                           \
}

#define InsertHeadGlobalListEx(_gl, _ple, _t, _pt)              \
{                                                               \
    NdisAcquireSpinLock(&(_gl.Lock));                           \
    InsertHeadList(&(_gl.List), (_ple));                        \
    _gl.ulCount++;                                              \
    if (_gl.ulCount > _gl.ulMaxCount) {                         \
        _gl.ulMaxCount = _gl.ulCount;                           \
    }                                                           \
    if (!_gl.TimerScheduled) {                                  \
        LARGE_INTEGER   _ft;                                    \
        _gl.TimerScheduled = TRUE;                              \
        _ft.QuadPart = Int32x32To64(_t, -10000);                \
        KeSetTimerEx(&_gl.Timer, _ft, _pt, &_gl.Dpc);           \
    }                                                           \
    NdisReleaseSpinLock(&(_gl.Lock));                           \
}

#define RemoveHeadGlobalList(_gl, _pple)                        \
{                                                               \
    NdisAcquireSpinLock(&(_gl.Lock));                           \
    *(_pple) = RemoveHeadList(&(_gl.List));                     \
    _gl.ulCount--;                                              \
    NdisReleaseSpinLock(&(_gl.Lock));                           \
}

#define RemoveEntryGlobalList(_gl, _ple)                        \
{                                                               \
    NdisAcquireSpinLock(&(_gl.Lock));                           \
    RemoveEntryList(_ple);                                      \
    _gl.ulCount--;                                              \
    NdisReleaseSpinLock(&(_gl.Lock));                           \
}

#if 0
//
// The Remote address (DEST address) is what we use to mutilplex
// sends across our single adapter/binding context.  The address
// has the following format:
//
// XX XX YY YY YY YY
//
// XX = Randomly generated OUI
// YY = ProtocolCB
//
#define FillNdisWanHdrContext(_pAddr, _ppcb)    \
    *((ULONG UNALIGNED*)(&_pAddr[2])) = *((ULONG UNALIGNED*)(&_ppcb))

#define GetNdisWanHdrContext(_pAddr, _pppcb)    \
    *((ULONG UNALIGNED*)(_pppcb)) = *((ULONG UNALIGNED*)(&_pAddr[2]))
#endif

//
// The Remote address (DEST address) is what we use to mutilplex
// sends across our single adapter/binding context.  The address
// has the following format:
//
// XX XX XX YY YY ZZ
//
// XX = Randomly generated OUI
// YY = Index into the active bundle connection table to get bundlecb
// ZZ = Index into the protocol table of a bundle to get protocolcb
//
#define FillNdisWanIndices(_pAddr, _bI, _pI)    \
{                                               \
    _pAddr[3] = (UCHAR)((USHORT)_bI >> 8);      \
    _pAddr[4] = (UCHAR)_bI;                     \
    _pAddr[5] = (UCHAR)_pI;                     \
}

#define GetNdisWanIndices(_pAddr, _bI, _pI)         \
{                                                   \
    _bI = ((USHORT)_pAddr[3] << 8) | _pAddr[4];     \
    _pI = _pAddr[5];                                \
    ASSERT(_pI < MAX_PROTOCOLS);                    \
}

//
// In the Src address (from a NdisSend) the bundle index
// is stashed in the two high order bytes as shown below
// with the mask of valid bits given by the x's.  The
// high byte is shifted to the left one bit so the number
// of possible bundles is now 0x7FFF
//
// XX XX YY YY YY YY
//
// XX = Bytes described below owned by NdisWan
// YY = Transports Receive context
//
//       0                1
// 0 1 2 3 4 5 6 7  0 1 2 3 4 5 6 7
// x x x x x x x 0  x x x x x x x x
//
#define FillTransportBundleIndex(_pAddr, _Index)            \
{                                                           \
    _pAddr[0] = (UCHAR)((USHORT)_Index >> 7) & 0xFE;        \
    _pAddr[1] = (UCHAR)_Index;                              \
}

#define GetTransportBundleIndex(_pAddr)                     \
    (((USHORT)_pAddr[0] << 7) & 0x7F) | _pAddr[1]


#define GetProtocolCBFromProtocolList(_pl, _pt, _pppcb)     \
{                                                           \
    PPROTOCOLCB _pP;                                        \
    for (_pP = (PPROTOCOLCB)(_pl)->Flink;                   \
        (PLIST_ENTRY)_pP != _pl;                            \
        _pP = (PPROTOCOLCB)(_pP)->Linkage.Flink) {          \
                                                            \
        if (_pP->ProtocolType == _pt) {                     \
            *(_pppcb) = _pP;                                \
            break;                                          \
        }                                                   \
    }                                                       \
    if ((PVOID)_pP == (PVOID)_pl) {                         \
        *(_pppcb) = NULL;                                   \
    }                                                       \
}

#define PROTOCOLCB_FROM_PROTOCOLH(_pBCB, _pPCB, _hP)    \
{                                                       \
    if (_hP < MAX_PROTOCOLS) {                          \
        _pPCB = _pBCB->ProtocolCBTable[_hP];            \
    } else {                                            \
        _pPCB = NULL;                                   \
    }                                                   \
}

#define NetToHostShort(_ns) ( ((_ns & 0x00FF) << 8) | ((_ns & 0xFF00) >> 8) )
#define HostToNetShort(_hs) ( ((_hs & 0x00FF) << 8) | ((_hs & 0xFF00) >> 8) )

#define IsLinkSendWindowOpen(_plcb) \
    ((_plcb)->SendWindow > (_plcb)->OutstandingFrames)

#define IsSampleTableFull(_pST) ((_pST)->ulSampleCount == (_pST)->ulSampleArraySize)
#define IsSampleTableEmpty(_pST) ((_pST)->ulSampleCount == 0)

#define PMINIPORT_RESERVED_FROM_NDIS(_packet) \
    ((PNDISWAN_MINIPORT_RESERVED)((_packet)->MiniportReserved))

#define PPROTOCOL_RESERVED_FROM_NDIS(_packet) \
    ((PNDISWAN_PROTOCOL_RESERVED)((_packet)->ProtocolReserved))

#define PRECV_RESERVED_FROM_NDIS(_packet) \
    ((PNDISWAN_RECV_RESERVED)((_packet)->ProtocolReserved))

#define IsCompleteFrame(_fl) \
    ((_fl & MULTILINK_BEGIN_FRAME) && (_fl & MULTILINK_END_FRAME))

#define AddPPPProtocolID(_finf, _usID)                              \
{                                                                   \
    PUCHAR  _cp = _finf->ProtocolID.Pointer;                        \
    if (_finf->ProtocolID.Length != 0) {                            \
        ASSERT(_cp);                                                \
        if (!(_finf->FramingBits & PPP_COMPRESS_PROTOCOL_FIELD) ||  \
            (_finf->Flags & (DO_COMPRESSION | DO_ENCRYPTION))) {    \
            *_cp++ = (UCHAR)(_usID >> 8);                           \
        }                                                           \
        *_cp = (UCHAR)_usID;                                        \
    }                                                               \
}

#define AddMultilinkInfo(_finf, _f, _seq, _mask)                    \
{                                                                   \
    PUCHAR  _cp = _finf->Multilink.Pointer;                         \
    if (_finf->Multilink.Length != 0) {                             \
        ASSERT(_cp);                                                \
        if (!(_finf->FramingBits & PPP_COMPRESS_PROTOCOL_FIELD)) {  \
            _cp++;                                                  \
        }                                                           \
        _cp++;                                                      \
        _seq &= _mask;                                              \
        if (_finf->FramingBits & PPP_SHORT_SEQUENCE_HDR_FORMAT) {   \
            *_cp++ = _f | (UCHAR)(_finf->Class << 4) | (UCHAR)((_seq >> 8) & SHORT_SEQ_MASK);   \
            *_cp++ = (UCHAR)_seq;                                   \
        } else {                                                    \
            *_cp++ = _f | (UCHAR)(_finf->Class << 2);               \
            *_cp++ = (UCHAR)(_seq >> 16);                           \
            *_cp++ = (UCHAR)(_seq >> 8);                            \
            *_cp = (UCHAR)_seq;                                     \
        }                                                           \
    }                                                               \
}

#define AddCompressionInfo(_finf, _usCC)                            \
{                                                                   \
    PUCHAR  _cp = _finf->Compression.Pointer;                       \
    if (_finf->Compression.Length != 0) {                           \
        ASSERT(_cp);                                                \
        if (!(_finf->FramingBits & PPP_COMPRESS_PROTOCOL_FIELD)) {  \
            _cp++;                                                  \
        }                                                           \
        _cp++;                                                      \
        *_cp++ = (UCHAR)(_usCC >> 8);                               \
        *_cp = (UCHAR)_usCC;                                        \
    }                                                               \
}

#define UpdateFramingInfo(_finf, _pd)               \
{                                                   \
    PUCHAR  _sdb = (_pd);                           \
    (_finf)->AddressControl.Pointer = (_sdb);       \
    (_sdb) += (_finf)->AddressControl.Length;       \
    (_finf)->Multilink.Pointer = (_sdb);            \
    (_sdb) += (_finf)->Multilink.Length;            \
    (_finf)->Compression.Pointer = (_sdb);          \
    (_sdb) += (_finf)->Compression.Length;          \
    (_finf)->ProtocolID.Pointer = (_sdb);           \
}

#define NdisWanChangeMiniportAddress(_a, _addr)                             \
{                                                                           \
    PNDIS_MINIPORT_BLOCK    Miniport;                                       \
                                                                            \
    Miniport = (PNDIS_MINIPORT_BLOCK)((_a)->MiniportHandle);                \
    ETH_COPY_NETWORK_ADDRESS(Miniport->EthDB->AdapterAddress, _addr);       \
}

//
// Queue routines for the ProtocolCB's NdisPacket queues
//
#define InsertHeadPacketQueue(_ppq, _pnp, _pl)      \
{                                                   \
    PMINIPORT_RESERVED_FROM_NDIS(_pnp)->Next =      \
    (_ppq)->HeadQueue;                              \
    if ((_ppq)->HeadQueue == NULL) {                \
        (_ppq)->TailQueue = _pnp;                   \
    }                                               \
    (_ppq)->HeadQueue = _pnp;                       \
    (_ppq)->ByteDepth += (_pl-14);                  \
    (_ppq)->PacketDepth += 1;                       \
    if ((_ppq)->PacketDepth > (_ppq)->MaxPacketDepth) { \
        (_ppq)->MaxPacketDepth = (_ppq)->PacketDepth; \
    }                                               \
}

#define InsertTailPacketQueue(_ppq, _pnp, _pl)      \
{                                                   \
    PMINIPORT_RESERVED_FROM_NDIS(_pnp)->Next = NULL;\
    if ((_ppq)->HeadQueue == NULL) {                \
        (_ppq)->HeadQueue = _pnp;                   \
    } else {                                        \
        PMINIPORT_RESERVED_FROM_NDIS((_ppq)->TailQueue)->Next = _pnp;   \
    }                                               \
    (_ppq)->TailQueue = _pnp;                       \
    (_ppq)->ByteDepth += (_pl-14);                  \
    (_ppq)->PacketDepth += 1;                       \
    if ((_ppq)->PacketDepth > (_ppq)->MaxPacketDepth) { \
        (_ppq)->MaxPacketDepth = (_ppq)->PacketDepth; \
    }                                               \
}

#define RemoveHeadPacketQueue(_ppq)                             \
    (_ppq)->HeadQueue;                                          \
    {                                                           \
        PNDIS_PACKET _cp = (_ppq)->HeadQueue;                   \
        PNDIS_PACKET _np =                                      \
        PMINIPORT_RESERVED_FROM_NDIS(_cp)->Next;                \
        if (_np == NULL) {                                      \
            (_ppq)->TailQueue = NULL;                           \
        }                                                       \
        (_ppq)->HeadQueue = _np;                                \
        (_ppq)->ByteDepth -= ((_cp)->Private.TotalLength-14);   \
        (_ppq)->PacketDepth -= 1;                               \
    }

#define IsPacketQueueEmpty(_ppq) ((_ppq)->HeadQueue == NULL)

#define NdisWanDoReceiveComplete(_pa)   \
{                                       \
    NdisReleaseSpinLock(&(_pa)->Lock);  \
    NdisMEthIndicateReceiveComplete((_pa)->MiniportHandle); \
    NdisAcquireSpinLock(&(_pa)->Lock);  \
}



//
// OS specific code
//
#ifdef NT

//
// NT stuff
//
#define NdisWanInitializeNotificationEvent(_pEvent) \
        KeInitializeEvent(_pEvent, NotificationEvent, FALSE)

#define NdisWanSetNotificationEvent(_pEvent) \
        KeSetEvent(_pEvent, 0, FALSE)

#define NdisWanClearNotificationEvent(_pEvent) \
        KeClearEvent(_pEvent)

#define NdisWanWaitForNotificationEvent(_pEvent) \
        KeWaitForSingleObject(_pEvent, Executive, KernelMode, TRUE, NULL)

#define NdisWanInitializeSyncEvent(_pEvent) \
        KeInitializeEvent(_pEvent, SynchronizationEvent, FALSE)

#define NdisWanSetSyncEvent(_pEvent) \
        KeSetEvent(_pEvent, 1, FALSE)

#define NdisWanClearSyncEvent(_pEvent) \
        KeClearEvent(_pEvent)

#define NdisWanWaitForSyncEvent(_pEvent) \
        KeWaitForSingleObject(_pEvent, UserRequest, KernelMode, FALSE, NULL)

#if 0
#if DBG && !defined(_WIN64)
#define CheckDataBufferList(_e)                             \
{                                                           \
    PSINGLE_LIST_ENTRY   _le;                               \
    KIRQL               _irql;                              \
    KeAcquireSpinLock(&DataBufferList.Lock, &_irql);        \
    _le = DataBufferList.L.ListHead.Next.Next;              \
    while (_le != NULL) {                                   \
        if ((PSINGLE_LIST_ENTRY)_e == _le) {                \
            DbgPrint("NDISWAN: Corrupt DataBufferList Free!\n"); \
            DbgPrint("NDISWAN: List %x Entry %x\n", &DataBufferList, _e);\
            DbgBreakPoint();                                \
        }                                                   \
        _le = _le->Next;                                    \
    }                                                       \
    KeReleaseSpinLock(&DataBufferList.Lock, _irql);         \
}
#else
#define CheckDataBufferList(_e)
#endif
#endif

#if 0
#define NdisWanFreeDataBuffer(_e)                           \
{                                                           \
    NdisFreeToNPagedLookasideList(&DataBufferList, _e);     \
}

#define NdisWanAllocateDataBuffer() \
        NdisAllocateFromNPagedLookasideList(&DataBufferList)
#endif


#define NdisWanAllocateMemory(_AllocatedMemory, _Size, _t)                                  \
{                                                                                           \
    (PVOID)*(_AllocatedMemory) = (PVOID)ExAllocatePoolWithTag(NonPagedPool, _Size, _t);     \
    if ((PVOID)*(_AllocatedMemory) != NULL) {                                               \
        NdisZeroMemory((PUCHAR)*(_AllocatedMemory), _Size);                                 \
    }                                                                                       \
}

#define NdisWanAllocatePriorityMemory(_AllocatedMemory, _Size, _t, _p)                      \
{                                                                                           \
    (PVOID)*(_AllocatedMemory) = (PVOID)ExAllocatePoolWithTagPriority(NonPagedPool, _Size, _t, _p);\
    if ((PVOID)*(_AllocatedMemory) != NULL) {                                               \
        NdisZeroMemory((PUCHAR)*(_AllocatedMemory), _Size);                                 \
    }                                                                                       \
}

#define NdisWanFreeMemory(_AllocatedMemory) \
        ExFreePool(_AllocatedMemory)

#define NdisWanAllocateNdisBuffer(_ppnb, _pd, _dl)      \
{                                                       \
    NDIS_STATUS _s;                                     \
    NdisAllocateBuffer(&(_s), _ppnb, NULL, _pd, _dl);   \
    if (_s != NDIS_STATUS_SUCCESS) {                    \
        *(_ppnb) = NULL;                                \
    }                                                   \
}

#define NdisWanFreeNdisBuffer(_pnb) NdisFreeBuffer(_pnb)

#define NdisWanMoveMemory(_Dest, _Src, _Length) \
        RtlMoveMemory(_Dest, _Src, _Length)

#define NdisWanGetSystemTime(_pTime)                    \
{                                                       \
    LARGE_INTEGER   _tc;                                \
    ULONG           _ti;                                \
    KeQueryTickCount(&_tc);                             \
    _ti = KeQueryTimeIncrement();                       \
    (_pTime)->QuadPart = _tc.QuadPart * _ti;            \
}

#define NdisWanCalcTimeDiff(_pDest, _pEnd, _pBegin) \
        (_pDest)->QuadPart = (_pEnd)->QuadPart - (_pBegin)->QuadPart

#define NdisWanInitWanTime(_pTime, _Val) \
        (_pTime)->QuadPart = _Val

#define NdisWanMultiplyWanTime(_pDest, _pMulti1, _pMulti2)  \
        (_pDest)->QuadPart = (_pMulti1)->QuadPart * (_pMulti2)->QuadPart

#define NdisWanDivideWanTime(_pDest, _pDivi1, _pDivi2)  \
        (_pDest)->QuadPart = (_pDivi1)->QuadPart / (_pDivi2)->QuadPart

#define NdisWanIsTimeDiffLess(_pTime1, _pTime2) \
        ((_pTime1)->QuadPart < (_pTime2)->QuadPart)

#define NdisWanIsTimeDiffGreater(_pTime1, _pTime2) \
        ((_pTime1)->QuadPart > (_pTime2)->QuadPart)

#define NdisWanIsTimeEqual(_pTime1, _pTime2) \
        ((_pTime1)->QuadPart == (_pTime2)->QuadPart)

#define NdisWanUppercaseNdisString(_pns1, _pns2, _b) \
        RtlUpcaseUnicodeString(_pns1, _pns2, _b)

#define MDL_ADDRESS(_MDL_)  MmGetSystemAddressForMdl(_MDL_)

#define NdisWanInterlockedInc(_pul) \
        InterlockedIncrement(_pul)

#define NdisWanInterlockedDec(_pul) \
        InterlockedDecrement(_pul)

#define NdisWanInterlockedExchange(_pul, _ul) \
        InterlockedExchange(_pul, _ul)

#define NdisWanInterlockedExchangeAdd(_pul, _ul) \
        InterlockedExchangeAdd(_pul, _ul)

#define NdisWanInterlockedInsertTailList(_phead, _pentry, _plock) \
        ExInterlockedInsertTailList(_phead, _pentry, _plock)

#define NdisWanInterlockedInsertHeadList(_phead, _pentry, _plock) \
        ExInterlockedInsertHeadList(_phead, _pentry, _plock)

#define NdisWanInterlockedRemoveHeadList(_phead, _plock) \
        ExInterlockedRemoveHeadList(_phead, _plock)

#define NdisWanRaiseIrql(_pirql) \
        KeRaiseIrql(DISPATCH_LEVEL, _pirql)

#define NdisWanLowerIrql(_irql) \
        KeLowerIrql(_irql)

//
// Wait for event structure.  Used for async completion notification.
//
typedef KEVENT      WAN_EVENT;
typedef WAN_EVENT   *PWAN_EVENT;

typedef LARGE_INTEGER   WAN_TIME;
typedef WAN_TIME        *PWAN_TIME;

typedef KIRQL       WAN_IRQL;
typedef WAN_IRQL    *PWAN_IRQL;

#else   // end NT stuff
//
// Win95 stuff
//

typedef ULONG       WAN_TIME;
typedef WAN_TIME    *PWAN_TIME;

#endif // end of Win95 stuff

#endif // end of _NDISWAN_DEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\wanproto.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Wanproto.h

Abstract:

    This file contains the prototypes for functions that NdisWan uses.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe  06/06/95    Created

--*/

#ifndef _NDISWAN_PROTO
#define _NDISWAN_PROTO

//
// Functions from cl.c
//
NDIS_STATUS
ClCreateVc(
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     NdisVcHandle,
    OUT PNDIS_HANDLE    ProtocolVcContext
    );

NDIS_STATUS
ClDeleteVc(
    IN  NDIS_HANDLE     ProtocolVcContext
    );

VOID
ClOpenAfComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     NdisAfHandle
    );

VOID
ClCloseAfComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolAfContext
    );

VOID
ClRegisterSapComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolSapContext,
    IN  PCO_SAP         Sap,
    IN  NDIS_HANDLE     NdisSapHandle
    );

VOID
ClDeregisterSapComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolSapContext
    );

VOID
ClMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
ClModifyQoSComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
ClCloseCallComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  NDIS_HANDLE     ProtocolPartyContext OPTIONAL
    );

NDIS_STATUS
ClIncomingCall(
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    );

VOID
ClIncomingCallQoSChange(
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
ClIncomingCloseCall(
    IN  NDIS_STATUS     CloseStatus,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PVOID           CloseData   OPTIONAL,
    IN  UINT            Size        OPTIONAL
    );

VOID
ClCallConnected(
    IN  NDIS_HANDLE     ProtocolVcContext
    );

//
// Functions from cm.c
//
NDIS_STATUS
CmCreateVc(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    );

NDIS_STATUS
CmDeleteVc(
    IN  NDIS_HANDLE             ProtocolVcContext
    );

NDIS_STATUS
CmOpenAf(
    IN  NDIS_HANDLE             CallMgrBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             NdisAfHandle,
    OUT PNDIS_HANDLE            CallMgrAfContext
    );

NDIS_STATUS
CmCloseAf(
    IN  NDIS_HANDLE             CallMgrAfContext
    );

NDIS_STATUS
CmRegisterSap(
    IN  NDIS_HANDLE             CallMgrAfContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    );

NDIS_STATUS
CmDeregisterSap(
    IN  NDIS_HANDLE             CallMgrSapContext
    );

NDIS_STATUS
CmMakeCall(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    OUT PNDIS_HANDLE            CallMgrPartyContext OPTIONAL
    );

NDIS_STATUS
CmCloseCall(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
    IN  PVOID                   CloseData           OPTIONAL,
    IN  UINT                    Size                OPTIONAL
    );

NDIS_STATUS
CmModifyCallQoS(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
CmIncomingCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
CmActivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
CmDeactivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext
    );

NDIS_STATUS
CmRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

//
// Functions from ccp.c
//
VOID
WanInitECP(
    VOID
    );

VOID
WanDeleteECP(
    VOID
    );

NTSTATUS
WanAllocateECP(
    PBUNDLECB           BundleCB,
    PCOMPRESS_INFO      CompInfo,
    PCRYPTO_INFO        CryptoInfo,
    BOOLEAN             IsSend
    );

VOID
WanDeallocateECP(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    PCRYPTO_INFO    CryptoInfo
    );

NTSTATUS
WanAllocateCCP(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    BOOLEAN         IsSend
    );

VOID
WanDeallocateCCP(
    PBUNDLECB       BundleCB,
    PCOMPRESS_INFO  CompInfo,
    BOOLEAN         IsSend
    );

//
// Functions from indicate.c
//
VOID
NdisWanLineUpIndication(
    IN  POPENCB OpenCB,
    IN  PUCHAR  Buffer,
    IN  ULONG   BufferSize
    );

VOID
NdisWanLineDownIndication(
    IN  POPENCB OpenCB,
    IN  PUCHAR  Buffer,
    IN  ULONG   BufferSize
    );

VOID
NdisWanFragmentIndication(
    IN  POPENCB OpenCB,
    IN  PUCHAR  Buffer,
    IN  ULONG   BufferSize
    );

VOID
NdisCoWanFragmentIndication(
    IN  PLINKCB     LinkCB,
    IN  PBUNDLECB   BundleCB,
    IN  PUCHAR      Buffer,
    IN  ULONG       BufferSize
    );

VOID
NdisCoWanLinkParamChange(
    IN  PLINKCB     LinkCB,
    IN  PBUNDLECB   BundleCB,
    IN  PUCHAR      Buffer,
    IN  ULONG       BufferSize
    );

VOID
UpdateBundleInfo(
    IN  PBUNDLECB   BundleCB
    );

VOID
AddLinkToBundle(
    IN  PBUNDLECB   BundleCB,
    IN  PLINKCB     LinkCB
    );

VOID
RemoveLinkFromBundle(
    IN  PBUNDLECB   BundleCB,
    IN  PLINKCB     LinkCB,
    IN  BOOLEAN     Locked
    );

VOID
FreeBundleResources(
    PBUNDLECB   BundleCB
    );

//
// Functions from init.c
//

//
// Functions from io.c
//
VOID
SetBundleFlags(
    PBUNDLECB   BundleCB
    );

#ifdef NT

NTSTATUS
NdisWanIoctl(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

NTSTATUS
NdisWanCreate(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

NTSTATUS
NdisWanCleanup(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

NTSTATUS
NdisWanPnPPower(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

VOID
NdisWanCancelRoutine(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

NTSTATUS
NdisWanIrpStub(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    );

VOID
FlushProtocolPacketQueue(
    PPROTOCOLCB ProtocolCB
    );

VOID
IoRecvIrpWorker(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Arg1,
    PVOID   Arg2
    );

#endif // NT

VOID
RemoveProtocolCBFromBundle(
    PPROTOCOLCB ProtocolCB
    );

//
// Functions from loopback.c
//
VOID
NdisWanIndicateLoopbackPacket(
    PMINIPORTCB     MiniportCB,
    PNDIS_PACKET    NdisPacket
    );

//
// Functions from memory.c
//
PMINIPORTCB
NdisWanAllocateMiniportCB(
    IN  PNDIS_STRING AdapterName
    );

VOID
NdisWanFreeMiniportCB(
    IN  PMINIPORTCB pMiniportCB
    );

POPENCB
NdisWanAllocateOpenCB(
    IN  PNDIS_STRING BindName
    );

VOID
NdisWanFreeOpenCB(
    IN  POPENCB pOpenCB
    );

PPROTOCOLCB
NdisWanAllocateProtocolCB(
    IN  PNDISWAN_ROUTE  Route
    );

VOID
NdisWanFreeProtocolCB(
    IN  PPROTOCOLCB ProtocolCB
    );

PLINKCB
NdisWanAllocateLinkCB(
    IN  POPENCB OpenCB,
    IN  ULONG   SendWindow
    );

VOID
NdisWanFreeLinkCB(
    IN  PLINKCB LinkCB
    );

PBUNDLECB
NdisWanAllocateBundleCB(
    VOID
    );

VOID
NdisWanFreeBundleCB(
    IN  PBUNDLECB BundleCB
    );

PNDIS_PACKET
NdisWanAllocateNdisPacket(
    ULONG   MagicNumber
    );

VOID
NdisWanFreeNdisPacket(
    PNDIS_PACKET    NdisPacket
    );

PVOID
AllocateDataDesc(
    POOL_TYPE   PoolType,
    SIZE_T      NumberOfBytes,
    ULONG       Tag
    );

VOID
FreeDataDesc(
    PVOID   Buffer
    );

PRECV_DESC
NdisWanAllocateRecvDesc(
    ULONG   SizeNeeded
    );

VOID
NdisWanFreeRecvDesc(
    PRECV_DESC  RecvDesc
    );

PSEND_DESC
NdisWanAllocateSendDesc(
    PLINKCB LinkCB,
    ULONG   SizeNeeded
    );

VOID
NdisWanFreeSendDesc(
    PSEND_DESC  SendDesc
    );

NDIS_STATUS
NdisWanAllocateSendResources(
    POPENCB OpenCB
    );

VOID
NdisWanFreeSendResources(
    POPENCB OpenCB
    );

NDIS_STATUS
NdisWanCreateProtocolInfoTable(
    VOID
    );

VOID
NdisWanDestroyProtocolInfoTable(
    VOID
    );

NDIS_STATUS
NdisWanCreateConnectionTable(
    ULONG   TableSize
    );

VOID
CompleteThresholdEvent(
    PBUNDLECB   BundleCB,
    ULONG       DataType,
    ULONG       ThresholdType
    );

PCL_AFSAPCB
NdisWanAllocateClAfSapCB(
    POPENCB OpenCB,
    PCO_ADDRESS_FAMILY AddressFamily
    );

VOID
NdisWanFreeClAfSapCB(
    PCL_AFSAPCB AfSapCB
    );

PCM_AFSAPCB
NdisWanAllocateCmAfSapCB(
    PMINIPORTCB MiniportCB
    );

VOID
NdisWanFreeCmAfSapCB(
    PCM_AFSAPCB AfSapCB
    );

PCM_VCCB
NdisWanAllocateCmVcCB(
    PCM_AFSAPCB AfSapCB,
    NDIS_HANDLE NdisVcHandle
    );

VOID
NdisWanFreeCmVcCB(
    PCM_VCCB    CmVcCB
    );

NDIS_STATUS
AllocateIoNdisPacket(
    ULONG           SizeNeeded,
    PNDIS_PACKET    *NdisPacket,
    PNDIS_BUFFER    *NdisBuffer, 
    PUCHAR          *DataBuffer
    );

VOID
FreeIoNdisPacket(
    PNDIS_PACKET    NdisPacket
);

//
// Functions from ndiswan.c
//
NDIS_STATUS
DoMiniportInit(
    VOID
    );

NDIS_STATUS
DoProtocolInit(
    IN  PUNICODE_STRING RegistryPath
    );

NDIS_STATUS
DoWanMiniportInit(
    VOID
    );

VOID
NdisWanReadRegistry(
    IN  PUNICODE_STRING RegistryPath
    );

VOID
NdisWanBindMiniports(
    IN  PUNICODE_STRING RegistryPath
    );

VOID
NdisWanGlobalCleanup(
    VOID
    );

VOID
SetProtocolInfo(
    IN  PPROTOCOL_INFO  ProtocolInfo
    );

BOOLEAN
GetProtocolInfo(
    IN OUT  PPROTOCOL_INFO ProtocolInfo
    );

NDIS_HANDLE
InsertLinkInConnectionTable(
    IN  PLINKCB LinkCB
    );

VOID
RemoveLinkFromConnectionTable(
    IN  PLINKCB LinkCB
    );

NDIS_HANDLE
InsertBundleInConnectionTable(
    IN  PBUNDLECB   BundleCB
    );

VOID
RemoveBundleFromConnectionTable(
    IN  PBUNDLECB   BundleCB
    );

NTSTATUS
BindQueryRoutine(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    );

BOOLEAN
IsHandleValid(
    USHORT  usHandleType,
    NDIS_HANDLE hHandle
    );

#if DBG

PUCHAR
NdisWanGetNdisStatus(
    IN  NDIS_STATUS GeneralStatus
    );

#endif


//
// Functions from miniport.c
//

BOOLEAN
MPCheckForHang(
    IN  NDIS_HANDLE MiniportAdapterContext
    );

#if 0
NDIS_STATUS
MPQueryInformation(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    );

NDIS_STATUS
MPSetInformation(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    );
#endif

VOID
MPHalt(
    IN  NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
MPInitialize(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN  PNDIS_MEDIUM    MediumArray,
    IN  UINT            MediumArraySize,
    IN  NDIS_HANDLE     MiniportAdapterHandle,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    );

NDIS_STATUS
MPReconfigure(
    OUT PNDIS_STATUS    OpenErrorStatus,
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    );

NDIS_STATUS
MPReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    );

VOID
MPReturnPacket(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PNDIS_PACKET    Packet
    );

VOID
MPSendPackets(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PPNDIS_PACKET   PacketArray,
    IN  UINT            NumberOfPackets
    );

NDIS_STATUS
MPTransferData(
    OUT PNDIS_PACKET NdisPacket,
    OUT PUINT BytesTransferred,
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportReceiveContext,
    IN UINT ByteOffset,
    IN UINT BytesToTransfer
    );

NDIS_STATUS
MPCoCreateVc(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  NDIS_HANDLE     NdisVcHandle,
    OUT PNDIS_HANDLE    MiniportVcContext
    );

NDIS_STATUS
MPCoDeleteVc(
    IN  NDIS_HANDLE MiniportVcContext
           );

NDIS_STATUS
MPCoActivateVc(
    IN  NDIS_HANDLE             MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    );

NDIS_STATUS
MPCoDeactivateVc(
    IN  NDIS_HANDLE MiniportVcContext
    );

VOID
MPCoSendPackets(
    IN  NDIS_HANDLE     MiniportVcContext,
    IN  PPNDIS_PACKET   PacketArray,
    IN  UINT            NumberOfPackets
    );

NDIS_STATUS
MPCoRequest(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_HANDLE             MiniportVcContext   OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

//
// Functions from protocol.c
//

NDIS_STATUS
ProtoOpenWanAdapter(
    POPENCB pOpenCB
    );

NDIS_STATUS
ProtoCloseWanAdapter(
    IN  POPENCB pOpenCB
);

VOID
ProtoOpenAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status,
    IN  NDIS_STATUS OpenErrorStatus
    );

VOID
ProtoCloseAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    );

VOID
ProtoResetComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    );

VOID
ProtoReceiveComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    );

VOID
ProtoIndicateStatus(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

VOID
ProtoIndicateStatusComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    );

VOID
ProtoWanSendComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_WAN_PACKET    Packet,
    IN  NDIS_STATUS         Status
    );

NDIS_STATUS
ProtoWanReceiveIndication(
    IN  NDIS_HANDLE NdisLinkHandle,
    IN  PUCHAR      Packet,
    IN  ULONG       PacketSize
    );

VOID
ProtoRequestComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_REQUEST   NdisRequest,
    IN  NDIS_STATUS     Status
    );

VOID
ProtoBindAdapter(
    OUT PNDIS_STATUS    Status,
    IN  NDIS_HANDLE     BindContext,
    IN  PNDIS_STRING    DeviceName,
    IN  PVOID           SystemSpecific1,
    IN  PVOID           SystemSpecific2
    );

VOID
ProtoUnbindAdapter(
    OUT PNDIS_STATUS    Status,
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  NDIS_HANDLE     UnbindContext
    );

VOID
ProtoUnload(
    VOID
    );

NDIS_STATUS
ProtoPnPEvent(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNET_PNP_EVENT  NetPnPEvent
    );

VOID
ProtoCoSendComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PNDIS_PACKET    Packet
    );

VOID
ProtoCoIndicateStatus(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext   OPTIONAL,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

UINT
ProtoCoReceivePacket(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  NDIS_HANDLE     ProtocolVcContext,
    IN  PNDIS_PACKET    Packet
    );

NDIS_STATUS
ProtoCoRequest(
    IN  NDIS_HANDLE         ProtocolAfContext,
    IN  NDIS_HANDLE         ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE         ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST    NdisRequest
    );

VOID
ProtoCoRequestComplete(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     ProtocolAfContext,
    IN  NDIS_HANDLE     ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE     ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST   NdisRequest
    );

VOID
ProtoCoAfRegisterNotify(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY      AddressFamily
    );

NDIS_STATUS
DoNewLineUpToProtocol(
    IN  PPROTOCOLCB ProtocolCB
    );

NDIS_STATUS
DoLineUpToProtocol(
    IN  PPROTOCOLCB ProtocolCB
    );

NDIS_STATUS
DoLineDownToProtocol(
    PPROTOCOLCB ProtocolCB
    );

VOID
NdisWanProcessStatusIndications(
    PMINIPORTCB MiniportCB
    );

//
// Functions from receive.c
//
NDIS_STATUS
DetectBroadbandFraming(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
DetectFraming(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
ReceivePPP(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
ReceiveSLIP(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
ReceiveRAS(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
ReceiveARAP(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
ReceiveForward(
    PLINKCB         LinkCB,
    PRECV_DESC      RecvDesc
    );

NDIS_STATUS
ReceiveLLC(
   PLINKCB          LinkCB,
   PRECV_DESC       RecvDesc
   );

VOID
FlushAssemblyLists(
    IN  PBUNDLECB   BundleCB
    );

BOOLEAN
IpIsDataFrame(
    PUCHAR  HeaderBuffer,
    ULONG   HeaderBufferLength,
    ULONG   TotalLength
    );

BOOLEAN
IpxIsDataFrame(
    PUCHAR  HeaderBuffer,
    ULONG   HeaderBufferLength,
    ULONG   TotalLength
    );

BOOLEAN
NbfIsDataFrame(
    PUCHAR  HeaderBuffer,
    ULONG   HeaderBufferLength,
    ULONG   TotalLength
    );

VOID
IndicatePromiscuousRecv(
    PBUNDLECB   BundleCB,
    PRECV_DESC  RecvDesc,
    RECV_TYPE   RecvType
    );

//
// Functions from request.c
//

NDIS_STATUS
NdisWanSubmitNdisRequest(
    IN  POPENCB             pOpenCB,
    IN  PWAN_REQUEST        WanRequest
    );

NDIS_STATUS
NdisWanOidProc(
    IN  PMINIPORTCB         pMiniportCB,
    IN OUT PNDIS_REQUEST    NdisRequest
    );

NDIS_STATUS
NdisWanCoOidProc(
    IN  PMINIPORTCB         pMiniportCB,
    IN  PCM_VCCB            CmVcCB OPTIONAL,
    IN OUT PNDIS_REQUEST    NdisRequest
    );
//
// Functions from send.c
//
VOID
NdisWanQueueSend(
    IN  PMINIPORTCB     MiniportCB,
    IN  PNDIS_PACKET    NdisPacket
    );

VOID
SendPacketOnBundle(
    PBUNDLECB   BundleCB
    );

BOOLEAN
SendFromPPP(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB,
    PBOOLEAN    PacketSent
    );

BOOLEAN
SendFromProtocol(
    PBUNDLECB   BundleCB,
    PPROTOCOLCB ProtocolCB,
    PINT        RetClass,
    PULONG      SendMask,
    PBOOLEAN    PacketSent
    );

BOOLEAN
SendFromFragQueue(
    PBUNDLECB   BundleCB,
    BOOLEAN     SendOne,
    PBOOLEAN    PacketSent
    );

UINT
FramePacket(
    PBUNDLECB       BundleCB,
    PPROTOCOLCB     ProtocolCB,
    PNDIS_PACKET    NdisPacket,
    PLIST_ENTRY     LinkCBList,
    ULONG           SendingLinks,
    INT             Class
    );

UINT
SendOnLegacyLink(
    PSEND_DESC  SendDesc
    );

UINT
SendOnLink(
    PSEND_DESC  SendDesc
    );

NDIS_STATUS
BuildIoPacket(
    IN  PLINKCB             LinkCB,
    IN  PBUNDLECB           BundleCB,
    IN  PNDISWAN_IO_PACKET  pWanIoPacket,
    IN  BOOLEAN             SendImmediate
    );

VOID
CompleteNdisPacket(
    PMINIPORTCB     MiniportCB,
    PPROTOCOLCB     ProtocolCB,
    PNDIS_PACKET    NdisPacket
    );

VOID
IndicatePromiscuousSendPacket(
    PLINKCB         LinkCB,
    PNDIS_PACKET    NdisPacket
    );

VOID
IndicatePromiscuousSendDesc(
    PLINKCB LinkCB,
    PSEND_DESC  SendDesc,
    SEND_TYPE   SendType
    );

VOID
DestroyIoPacket(
    PNDIS_PACKET    NdisPacket
    );

//
// Functions from tapi.c
//

NDIS_STATUS
NdisWanTapiRequestProc(
    HANDLE NdisWanKey,
    PNDIS_REQUEST   NdisRequest
    );

VOID
NdisWanTapiRequestComplete(
    POPENCB OpenCB,
    PWAN_REQUEST    WanRequest
    );

VOID
NdisWanTapiIndication(
    POPENCB OpenCB,
    PUCHAR          StatusBuffer,
    ULONG           StatusBufferSize
    );

//
// Function from util.c
//

VOID
NdisWanStringToNdisString(
    IN  PNDIS_STRING    pDestString,
    IN  PWSTR           pSrcBuffer
    );

VOID
NdisWanAllocateAdapterName(
    PNDIS_STRING    Dest,
    PNDIS_STRING    Src
    );

VOID
NdisWanFreeNdisString(
    IN  PNDIS_STRING    NdisString
    );

VOID
NdisWanNdisStringToInteger(
    IN  PNDIS_STRING    Source,
    IN  PULONG          Value
    );

VOID
NdisWanCopyNdisString(
    OUT PNDIS_STRING Dest,
    IN  PNDIS_STRING Src
    );

VOID
NdisWanCopyFromPacketToBuffer(
    IN  PNDIS_PACKET    NdisPacket,
    IN  ULONG           Offset,
    IN  ULONG           BytesToCopy,
    OUT PUCHAR          Buffer,
    OUT PULONG          BytesCopied
    );
    
VOID
NdisWanCopyFromBufferToPacket(
    PUCHAR  Buffer,
    ULONG   BytesToCopy,
    PNDIS_PACKET    NdisPacket,
    ULONG   PacketOffset,
    PULONG  BytesCopied
    );

BOOLEAN
IsLinkValid(
    NDIS_HANDLE LinkHandle,
    BOOLEAN     CheckState,
    PLINKCB     *LinkCB
    );

BOOLEAN
IsBundleValid(
    NDIS_HANDLE BundleHandle,
    BOOLEAN     CheckState,
    PBUNDLECB   *BundleCB
    );

BOOLEAN
AreLinkAndBundleValid(
    NDIS_HANDLE LinkHandle,
    BOOLEAN     CheckState,
    PLINKCB     *LinkCB,
    PBUNDLECB   *BundleCB
    );

VOID
DoDerefBundleCBWork(
    PBUNDLECB   BundleCB
    );

VOID
DoDerefLinkCBWork(
    PLINKCB     LinkCB
    );

VOID
DoDerefClAfSapCBWork(
    PCL_AFSAPCB AfSapCB
    );

VOID
DoDerefCmVcCBWork(
    PCM_VCCB    VcCB
    );

VOID
DerefVc(
    PLINKCB LinkCB
    );

VOID
DeferredWorker(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Arg1,
    PVOID   Arg2
    );

VOID
BonDWorker(
    PKDPC   Dpc,
    PVOID   Context,
    PVOID   Arg1,
    PVOID   Arg2
    );

VOID
CheckBonDInfo(
    PKDPC       Dpc,
    PBUNDLECB   BundleCB,
    PVOID       SysArg1,
    PVOID       SysArg2
    );

VOID
AgeSampleTable(
    PSAMPLE_TABLE   SampleTable
    );

VOID
UpdateSampleTable(
    PSAMPLE_TABLE   SampleTable,
    ULONG           BytesSent
    );

VOID
UpdateBandwidthOnDemand(
    PBOND_INFO  BonDInfo,
    ULONG       Bytes
    );

VOID
CheckUpperThreshold(
    PBUNDLECB       BundleCB
    );

VOID
CheckLowerThreshold(
    PBUNDLECB   BundleCB
    );

//
// Functions from vjslip.c
//  
VOID
WanInitVJ(
    VOID
    );

VOID
WanDeleteVJ(
    VOID
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\wantypes.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Wantypes.h

Abstract:

    This file contains data structures used by the NdisWan driver
    


Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#include "packet.h"

#ifndef _NDISWAN_TYPES_
#define _NDISWAN_TYPES_

//
// OS specific structures
//
#ifdef NT

#endif
//
// end of OS specific structures
//

//
// WanRequest structure used to queue requests to the WAN Miniports
//
typedef struct _WAN_REQUEST {
    LIST_ENTRY          Linkage;
    WanRequestType      Type;           // Sync or Async
    WanRequestOrigin    Origin;         // Is this tapi
    struct _OPENCB      *OpenCB;
    NDIS_HANDLE         AfHandle;
    NDIS_HANDLE         VcHandle;
    NDIS_REQUEST        NdisRequest;        // Ndis Request
    PNDIS_REQUEST       OriginalRequest;
    NDIS_STATUS         NotificationStatus; // Request status
    WAN_EVENT           NotificationEvent;  // Request pending event
} WAN_REQUEST, *PWAN_REQUEST;

//
// Used for
//
typedef struct _WAN_GLOBAL_LIST {
    NDIS_SPIN_LOCK  Lock;           // Access lock
    ULONG           ulCount;        // Count of nodes on list
    ULONG           ulMaxCount;     // Max allowed on list
    LIST_ENTRY      List;           // Doubly-Linked list of nodes
} WAN_GLOBAL_LIST, *PWAN_GLOBAL_LIST;

typedef struct _WAN_GLOBAL_LIST_EX {
    NDIS_SPIN_LOCK  Lock;           // Access lock
    ULONG           ulCount;        // Count of nodes on list
    ULONG           ulMaxCount;     // Max allowed on list
    LIST_ENTRY      List;           // Doubly-Linked list of nodes
    KDPC            Dpc;
    KTIMER          Timer;
    BOOLEAN         TimerScheduled;
} WAN_GLOBAL_LIST_EX, *PWAN_GLOBAL_LIST_EX;

//
// Ethernet Header
//
typedef struct _ETH_HEADER {
    UCHAR   DestAddr[6];
    UCHAR   SrcAddr[6];
    USHORT  Type;
} ETH_HEADER, *PETH_HEADER;

//
// If any of the fields of this structure are removed
// check private\inc\wanpub.h to make sure that the
// corresponding field is removed from WAN_PROTOCOL_INFO
//
typedef struct _PROTOCOL_INFO {
    USHORT  ProtocolType;
    USHORT  PPPId;
    ULONG   Flags;
    ULONG   MTU;
    ULONG   TunnelMTU;
    ULONG   PacketQueueDepth;
}PROTOCOL_INFO, *PPROTOCOL_INFO;

//
// The ProtocolType to PPPProtocolID Lookup Table
//
typedef struct _PROTOCOL_INFO_TABLE {
    NDIS_SPIN_LOCK  Lock;               // Table access lock
    ULONG           ulAllocationSize;   // Size of memory allocated
    ULONG           ulArraySize;        // MAX size of the two arrays
    ULONG           Flags;
    PIRP            EventIrp;
    PPROTOCOL_INFO  ProtocolInfo;
} PROTOCOL_INFO_TABLE, *PPROTOCOL_INFO_TABLE;

//
// ProtocolInfo and Table flags
//
#define PROTOCOL_UNBOUND            0x00000001
#define PROTOCOL_BOUND              0x00000002
#define PROTOCOL_REBOUND            0x00000004
#define PROTOCOL_EVENT_OCCURRED     0x00000008
#define PROTOCOL_EVENT_SIGNALLED    0x00000010


typedef struct _IO_RECV_LIST {
    ULONG           ulIrpCount;     // Count of nodes on list
    LIST_ENTRY      IrpList;        // Doubly-Linked list of nodes
    PIRP            LastIrp;
    NTSTATUS        LastIrpStatus;
    ULONG           LastPacketNumber;
    ULONG           LastCopySize;
    ULONG           ulDescCount;    // Count of nodes on list
    ULONG           ulMaxDescCount; // Max# of nodes on list
    LIST_ENTRY      DescList;       // Doubly-Linked list of nodes
    KDPC            Dpc;
    KTIMER          Timer;
    BOOLEAN         TimerScheduled;
    NDIS_SPIN_LOCK  Lock;           // Access lock
} IO_RECV_LIST, *PIO_RECV_LIST;


//
// Active connections Table
//
typedef struct _CONNECTION_TABLE {
    ULONG               ulAllocationSize;   // Size of memory allocated
    ULONG               ulArraySize;        // Number of possible connections in table
    ULONG               ulNumActiveLinks;   // Number of links in link array
    ULONG               ulNextLink;         // Index to insert next link
    ULONG               ulNumActiveBundles; // Number of bundles in bundle array
    ULONG               ulNextBundle;       // Index to insert next bundle
    LIST_ENTRY          BundleList;         // List of bundlecbs in table
    LIST_ENTRY          LinkList;           // List of linkcbs in the table
    struct  _LINKCB     **LinkArray;        // Pointer to the LinkArray
    struct _BUNDLECB    **BundleArray;      // Pointer to the BundleArray
} CONNECTION_TABLE, *PCONNECTION_TABLE;

typedef struct _IO_DISPATCH_TABLE {
    ULONG       ulFunctionCode;
    NTSTATUS    (*Function)();
}IO_DISPATCH_TABLE, *PIO_DISPATCH_TABLE;

typedef struct _HEADER_FIELD_INFO {
    ULONG   Length;
    PUCHAR  Pointer;
}HEADER_FIELD_INFO, *PHEADER_FIELD_INFO;

typedef struct _HEADER_FRAMING_INFO {
    ULONG               FramingBits;            // Framing bits
    INT                 Class;
    ULONG               HeaderLength;           // Total length of the header
    ULONG               Flags;                  // Framing flags
#define DO_MULTILINK            0x00000001
#define DO_COMPRESSION          0x00000002
#define DO_ENCRYPTION           0x00000004
#define IO_PROTOCOLID           0x00000008
#define FIRST_FRAGMENT          0x00000010
#define DO_FLUSH                0x00000020
#define DO_LEGACY_ENCRYPTION    0x00000040      // Legacy encryption NT 3.0/3.5/3.51
#define DO_40_ENCRYPTION        0x00000080      // Pseudo fixed 40 bit encryption NT 4.0
#define DO_128_ENCRYPTION       0x00000100      // 128 bit encryption NT 4.0 encryption update
#define DO_VJ                   0x00000200
#define SAVE_MAC_ADDRESS        0x00000400
#define DO_HISTORY_LESS         0x00000800
#define DO_56_ENCRYPTION        0x00001000
    HEADER_FIELD_INFO   AddressControl;         // Info about the address/control field
    HEADER_FIELD_INFO   Multilink;              // Info about the multlink field
    HEADER_FIELD_INFO   Compression;            // Info about compression
    HEADER_FIELD_INFO   ProtocolID;             // Info about the protocol id field
}HEADER_FRAMING_INFO, *PHEADER_FRAMING_INFO;

//
// Used for receive data processing
//
typedef struct _RECV_DESC {
    LIST_ENTRY          Linkage;
    ULONG               Signature;
    struct _LINKCB      *LinkCB;
    struct _BUNDLECB    *BundleCB;
    ULONG               SequenceNumber;
    ULONG               Flags;
    USHORT              ProtocolID;
    BOOLEAN             CopyRequired;
    BOOLEAN             Reserved;
    PUCHAR              CurrentBuffer;
    LONG                CurrentLength;
    PUCHAR              StartBuffer;
    LONG                StartLength;
    LONG                HeaderLength;
    PUCHAR              DataBuffer;
    PNDIS_BUFFER        NdisBuffer;
    PNDIS_PACKET        NdisPacket;
    PNDIS_PACKET        OriginalPacket;
} RECV_DESC, *PRECV_DESC;

//
// Used for send data processing
//
typedef struct _SEND_DESC {
    LIST_ENTRY          Linkage;
    ULONG               Signature;
    ULONG               RefCount;
    ULONG               Flags;
#define SEND_DESC_FRAG  0x00000001
    INT                 Class;
    struct _LINKCB      *LinkCB;
    struct _PROTOCOLCB  *ProtocolCB;
    PNDIS_WAN_PACKET    WanPacket;
    PNDIS_BUFFER        NdisBuffer;
    PNDIS_PACKET        NdisPacket;
    PUCHAR              StartBuffer;
    ULONG               HeaderLength;
    ULONG               DataLength;
    PNDIS_PACKET        OriginalPacket;
} SEND_DESC, *PSEND_DESC;

//
// This structure contains every necessary
// to completely describe send or recv in ndiswan
//
typedef struct _DATA_DESC {
    union {
        SEND_DESC   SendDesc;
        RECV_DESC   RecvDesc;
    };
    PNPAGED_LOOKASIDE_LIST  LookasideList;
    PNDIS_PACKET            NdisPacket;
    PNDIS_BUFFER            NdisBuffer;
    ULONG                   DataBufferLength;
    PUCHAR                  DataBuffer;
} DATA_DESC, *PDATA_DESC;

#define DATADESC_SIZE   sizeof(DATA_DESC) + sizeof(PVOID)

//
// BundleInfo is information needed by the bundle for framing decisions.
// This information is the combined information of all links that are part
// of this bundle.
//
typedef struct _BUNDLE_FRAME_INFO {
    ULONG   SendFramingBits;        // Send framing bits
    ULONG   RecvFramingBits;        // Receive framing bits
    ULONG   MaxRSendFrameSize;      // Max size of send frame
    ULONG   MaxRRecvFrameSize;      // Max size of receive frame
    ULONG   PPPHeaderLength;
} BUNDLE_FRAME_INFO, *PBUNDLE_FRAME_INFO;

typedef struct _BOND_SAMPLE {
    ULONG           ulBytes;
    ULONG           ulReferenceCount;
    WAN_TIME        TimeStamp;
} BOND_SAMPLE, *PBOND_SAMPLE;

typedef struct _SAMPLE_TABLE {
    ULONG           ulHead;                     // Index to 1st sample in current period
    ULONG           ulCurrent;                  // Index to latest insertion in table
    ULONG           ulSampleCount;              // Count of samples in table
    ULONGLONG       ulCurrentSampleByteCount;   // Count of bytes sent in this sample period
    ULONG           ulSampleArraySize;          // Sample array size
    WAN_TIME        SampleRate;                 // Time between each sample
    WAN_TIME        SamplePeriod;               // Time between 1st sample and last sample
    BOND_SAMPLE     SampleArray[SAMPLE_ARRAY_SIZE];     // SampleArray
} SAMPLE_TABLE, *PSAMPLE_TABLE;

typedef struct _BOND_INFO {
    ULONGLONG   ulBytesThreshold;           // Threshold in BytesPerSamplePeriod
    ULONGLONG   ulBytesInSamplePeriod;      // Max bytes in sample period
    USHORT      usPercentBandwidth;         // Threshold as % of total bandwidth
    ULONG       ulSecondsInSamplePeriod;    // # of seconds in a sample period
    ULONG       State;                      // Current state
    ULONG       DataType;
    WAN_TIME    StartTime;                  // Start time for threshold event
    SAMPLE_TABLE    SampleTable;
} BOND_INFO, *PBOND_INFO;

#define BONDALLOC_SIZE  \
    (sizeof(BOND_INFO) * 4) +\
    (sizeof(PVOID) * 3)
    
typedef struct _CACHED_KEY{
    USHORT  Coherency;
    UCHAR   SessionKey[1];
} CACHED_KEY, *PCACHED_KEY;

//
// This information is used to describe the encryption that is being
// done on the bundle.  At some point this should be moved into
// wanpub.h and ndiswan.h.
//
typedef struct _CRYPTO_INFO{
#define CRYPTO_IS_SERVER     0x00000001
    ULONG   Flags;                  //
    UCHAR   StartKey[16];           // Start key
    UCHAR   SessionKey[16];         // Session key used for encrypting
    ULONG   SessionKeyLength;       // Session key length
    PVOID   Context;                // Working key encryption context
    PVOID   RC4Key;                 // RC4 encryption context
    PVOID   CachedKeyBuffer;        // cached key array, for receive only
    PCACHED_KEY pCurrKey;           // pointer to save the next cached key
    PCACHED_KEY pLastKey;           // the last key in the buffer, to speed up lookup
} CRYPTO_INFO, *PCRYPTO_INFO;

#define ENCRYPTCTX_SIZE \
    sizeof(struct RC4_KEYSTRUCT) +\
    sizeof(A_SHA_CTX) +\
    (sizeof(PVOID))
    
typedef struct _BUNDLE_RECV_INFO {
    LIST_ENTRY  AssemblyList;   // List head for assembly of recv descriptors
    ULONG       AssemblyCount;  // # of descriptors on the assembly list
    PRECV_DESC  RecvDescHole;   // Pointer to 1st hole in recv desc list
    ULONG       MinSeqNumber;   // Minimum recv sequence number
    ULONG       FragmentsLost;  // Count of recv fragments flushed
} BUNDLE_RECV_INFO, *PBUNDLE_RECV_INFO;

typedef struct _SEND_FRAG_INFO {
    LIST_ENTRY      FragQueue;          //
    ULONG           FragQueueDepth;
    ULONG           SeqNumber;      // Current send sequence number (multilink)
    ULONG           MinFragSize;
    ULONG           MaxFragSize;
    ULONG           WinClosedCount;
} SEND_FRAG_INFO, *PSEND_FRAG_INFO;

//
// This is the control block that defines a bundle (connection).
// This block is created when a WAN Miniport driver gives a lineup
// indicating a new connection has been established.  This control
// block will live as long as the connection is up (until a linedown
// is received) or until the link associated with the bundle is
// added to a different bundle.  BundleCB's live in the global bundle
// array with their hBundleHandle as their index into the array.
//
typedef struct _BUNDLECB {
    LIST_ENTRY      Linkage;            // Linkage for the global free list
    ULONG           Flags;              // Flags
#define IN_SEND                 0x00000001
#define TRY_SEND_AGAIN          0x00000002
#define RECV_PACKET_FLUSH       0x00000004
#define PROTOCOL_PRIORITY       0x00000008
#define INDICATION_EVENT        0x00000010
#define FRAMES_PENDING_EVENT    0x00000020
#define BOND_ENABLED            0x00000040
#define DEFERRED_WORK_QUEUED    0x00000080
#define DISABLE_IDLE_DETECT     0x00000100
#define CCP_ALLOCATED           0x00000200
#define QOS_ENABLED             0x00000400
#define DO_DEFERRED_WORK        0x00000800
#define BUNDLE_IN_RECV          0x00001000
#define PAUSE_DATA              0x00002000
#define SEND_CCP_ALLOCATED      0x00004000
#define RECV_CCP_ALLOCATED      0x00008000
#define SEND_ECP_ALLOCATED      0x00010000
#define RECV_ECP_ALLOCATED      0x00020000
#define SEND_FRAGMENT           0x00040000

    BundleState     State;
    ULONG           RefCount;           // Reference count for this structure

    NDIS_HANDLE     hBundleHandle;      // ConnectionTable index
    NDIS_HANDLE     hBundleContext;     // Usermode context

    LIST_ENTRY      LinkCBList;         // List head for links
    ULONG           ulLinkCBCount;      // Count of links

    BUNDLE_FRAME_INFO   FramingInfo;    // Framing information

    //
    // Send section
    //
    struct _LINKCB  *NextLinkToXmit;    // Next link to send data over
    ULONG           SendSeqMask;        // Mask for send sequence numbers
    ULONG           SendSeqTest;        // Test for sequence number diff
    ULONG           SendFlags;
    SEND_FRAG_INFO  SendFragInfo[MAX_MCML];
    ULONG           NextFragClass;

    ULONG           SendingLinks;       // Number of links with open send windows
    ULONG           SendResources;      // # of avail packets for fragmented sends
    ULONG           SendWindow;         // # of sends that can be sent to miniport
    ULONG           OutstandingFrames;  // # outstanding sends
    WAN_EVENT       OutstandingFramesEvent; // Async notification event for pending sends
    NDIS_STATUS     IndicationStatus;

    //
    // Receive section
    //
    BUNDLE_RECV_INFO    RecvInfo[MAX_MCML]; // Array of ML recv info
    ULONG       RecvSeqMask;            // Mask for receive sequence number
    ULONG       RecvSeqTest;            // Test for sequence number diff
    ULONG       RecvFlags;

    //
    // Protocol information
    //
    struct _PROTOCOLCB  **ProtocolCBTable;  // ProctocolCB table
    ULONG               ulNumberOfRoutes;   // ProtocolCB table count
    LIST_ENTRY          ProtocolCBList;     // List head for routed ProtocolCB's
    struct _PROTOCOLCB  *NextProtocol;
    struct _PROTOCOLCB  *IoProtocolCB;
    ULONG               SendMask;           // Send Mask for all send queues
    WAN_TIME            LastNonIdleData;

    FLOWSPEC    SFlowSpec;
    FLOWSPEC    RFlowSpec;

    //
    // VJ information
    //
    VJ_INFO SendVJInfo;                 // Send VJ compression options
    VJ_INFO RecvVJInfo;                 // Recv VJ compression options
    struct slcompress *VJCompress;      // VJ compression table

    //
    // MS Compression
    //
    COMPRESS_INFO   SendCompInfo;       // Send compression options
    PVOID   SendCompressContext;        // Sendd compressor context

    COMPRESS_INFO   RecvCompInfo;       // Recv compression options
    PVOID   RecvCompressContext;        // Recv decompressor context

    //
    // MS Encryption
    //
    CRYPTO_INFO SendCryptoInfo;
    CRYPTO_INFO RecvCryptoInfo;

    USHORT  SCoherencyCounter;          // Coherency counters
    USHORT  SReserved1;
    USHORT  RCoherencyCounter;          //
    USHORT  RReseved1;
    USHORT  LastRC4Reset;               // Encryption key reset
    USHORT  LReserved1;
    ULONG   CCPIdentifier;              //

    //
    // Bandwidth on Demand
    //
    PVOID       BonDAllocation;
    LIST_ENTRY  BonDLinkage;
    PBOND_INFO  SUpperBonDInfo;
    PBOND_INFO  SLowerBonDInfo;
    PBOND_INFO  RUpperBonDInfo;
    PBOND_INFO  RLowerBonDInfo;

    //
    // Deferred Linkage
    //
    LIST_ENTRY  DeferredLinkage;

    //
    // Bundle Name
    //
    ULONG   ulNameLength;                   // Bundle name length
    UCHAR   Name[MAX_NAME_LENGTH];          // Bundle name

    //
    // Bundle statistics
    //
    WAN_STATS   Stats;                      // Bundle statistics

    NDIS_SPIN_LOCK  Lock;                   // Structure access lock

#ifdef CHECK_BUNDLE_LOCK
    ULONG           LockFile;
    ULONG           LockLine;
    BOOLEAN         LockAcquired;
#endif
} BUNDLECB, *PBUNDLECB;

#define BUNDLECB_SIZE \
    (sizeof(BUNDLECB) + (sizeof(PPROTOCOLCB) * MAX_PROTOCOLS) +\
    sizeof(PROTOCOLCB) + (2 * sizeof(PVOID)))

//
// Link receive handlers defined for:
// PPP, RAS, ARAP, Forward
//
typedef
NDIS_STATUS
(*LINK_RECV_HANDLER)(
    IN  struct _LINKCB  *LinkCB,
    IN  PRECV_DESC      RecvDesc
    );

//
// Link send handlers defined for:
// PPP, RAS, ARAP, Forward
//
typedef
UINT
(*LINK_SEND_HANDLER)(
    IN  PSEND_DESC      SendDesc
    );

typedef struct _LINK_RECV_INFO {
    ULONG   LastSeqNumber;  // Last recv sequence number
    ULONG   FragmentsLost;  // Number of lost fragments
} LINK_RECV_INFO, *PLINK_RECV_INFO;

//
// This control blocks defines an active link that is part
// of a bundle (connection).  This block is created when a
// WAN Miniport driver gives a lineup indicating that a new
// connection has been established or when a new vc/call is
// created by the proxy.  The control block lives until a
// linedown indication is received for the link or the vc/call
// is dropped by the proxy.  The control block lives linked
// into a bundle control block.
//
typedef struct _LINKCB {
    LIST_ENTRY          Linkage;                // bundle linkage
    ULONG               Signature;
    LinkState           State;
    ClCallState         ClCallState;
    ULONG               RefCount;               // Reference count
    ULONG               VcRefCount;

#define LINK_IN_RECV    0x00000001
    ULONG               Flags;

    NDIS_HANDLE         hLinkHandle;            // connection table index

    NDIS_HANDLE         hLinkContext;           // usermode context
    NDIS_HANDLE         NdisLinkHandle;
    NDIS_HANDLE         ConnectionWrapperID;
    struct _OPENCB      *OpenCB;                // OpenCB
    struct _BUNDLECB    *BundleCB;              // BundleCB
    struct _CL_AFSAPCB  *AfSapCB;

    ULONG               RecvDescCount;          // # of Desc's on the list

    LINK_RECV_INFO      RecvInfo[MAX_MCML];

    LINK_SEND_HANDLER   SendHandler;
    LINK_RECV_HANDLER   RecvHandler;

    FLOWSPEC            SFlowSpec;
    FLOWSPEC            RFlowSpec;
    ULONG               SBandwidth;             // % of the bundle send bandwidth
    ULONG               RBandwidth;             // % of the bundle recv bandwidth
    BOOLEAN             LinkActive;             // TRUE if Link has > minBandwidth of Bundle
    BOOLEAN             SendWindowOpen;         // TRUE if send window is open
    ULONG               SendResources;          // # of avail packets for fragmented sends
    ULONG               SendWindow;             // Max # of Outstanding sends allowed
    ULONG               OutstandingFrames;      // Number of outstanding frames on the link
    WAN_EVENT           OutstandingFramesEvent; // Async notification event for pending sends
    LIST_ENTRY          SendLinkage;
    LIST_ENTRY          ConnTableLinkage;

    WAN_LINK_INFO       LinkInfo;               // Framing information

    ULONG               ulNameLength;           // Name length
    UCHAR               Name[MAX_NAME_LENGTH];  // Name

    WAN_STATS           Stats;                  // statistics
    NDIS_SPIN_LOCK      Lock;
} LINKCB, *PLINKCB;

#define LINKCB_SIZE (sizeof(LINKCB))

//
// The protocol control block defines a protocol that is routed to a bundle
//
typedef struct _PROTOCOLCB {
    LIST_ENTRY          Linkage;                // bundle linkage
    ULONG               Signature;
    ProtocolState       State;
    ULONG               RefCount;
    ULONG               Flags;

    NDIS_HANDLE         ProtocolHandle;         // Index of this protocol in
                                                // the bundle protocol array
    struct _MINIPORTCB  *MiniportCB;            // Pointer to the adaptercb
    struct _BUNDLECB    *BundleCB;              // Pointer to the bundlecb

    LIST_ENTRY          VcList;                 // List of attached Vc's
    LIST_ENTRY          MiniportLinkage;        // Link into miniportcb
    LIST_ENTRY          RefLinkage;             // Link into outstanding ref list

    ULONG               OutstandingFrames;
    ULONG               SendMaskBit;            // Send bit mask
    PACKET_QUEUE        PacketQueue[MAX_MCML+1];
    ULONG               NextPacketClass;

    USHORT              ProtocolType;           // EtherType of this protocol
    USHORT              PPPProtocolID;          // PPP Protocol ID
    ULONG               MTU;                    // MTU for this protocol
    ULONG               TunnelMTU;
    WAN_TIME            LastNonIdleData;        // Time at which last
                                                // non-idle packet was recv'd
    BOOLEAN             (*NonIdleDetectFunc)(); // Function to sniff for
                                                // non-idle data
    ULONG               ulTransportHandle;      // Transport's connection
                                                // identifier
    UCHAR               NdisWanAddress[6];      // MAC address used for
                                                // this protocol
    UCHAR               TransportAddress[6];    // MAC address used for
                                                // indications to transport
    NDIS_STRING         BindingName;
    NDIS_STRING         InDeviceName;
    NDIS_STRING         OutDeviceName;
    WAN_EVENT           UnrouteEvent;           // Async notification for pending unroute
    ULONG               ulLineUpInfoLength;     // Length of protocol
                                                // specific lineup info
    PUCHAR              LineUpInfo;             // Pointer to protocol
                                                // specific lineup info
//  NDIS_SPIN_LOCK      Lock;                   // Structure access lock
} PROTOCOLCB, *PPROTOCOLCB;

#define PROTOCOLCB_SIZE (sizeof(PROTOCOLCB))

union _LINKPROTOCB{
    PROTOCOLCB  ProtocolCB;
    LINKCB      LinkCB;
} LINKPROTOCB;

#define LINKPROTOCB_SIZE (sizeof(LINKPROTOCB))

//
// This control block is allocated for every address family that
// ndiswan's client component opens and registers a sap with.
// They are threaded up on the open control block.
//
typedef struct _CL_AFSAPCB {
    LIST_ENTRY          Linkage;
    ULONG               Signature;
    ULONG               RefCount;
    ULONG               Flags;
    struct  _OPENCB     *OpenCB;            // OpenCB
    CO_ADDRESS_FAMILY   Af;                 // Af info
    NDIS_HANDLE         AfHandle;           // Ndis's Af handle
    NDIS_HANDLE         SapHandle;          // Ndis's Sap handle
    LIST_ENTRY          LinkCBList;         // List of Links (VCs) on this Af
    NDIS_SPIN_LOCK      Lock;
} CL_AFSAPCB, *PCL_AFSAPCB;

#define AF_OPENING              0x00000001
#define AF_OPENED               0x00000002
#define AF_OPEN_FAILED          0x00000004
#define AF_CLOSING              0x00000008
#define AF_CLOSED               0x00000010
#define SAP_REGISTERING         0x00000020
#define SAP_REGISTERED          0x00000040
#define SAP_REGISTER_FAILED     0x00000080
#define SAP_DEREGISTERING       0x00000100
#define AFSAP_REMOVED_UNBIND    0x00000200
#define AFSAP_REMOVED_REQUEST   0x00000400
#define AFSAP_REMOVED_OPEN      0x00000800

#define AFSAP_REMOVED_FLAGS     (SAP_REGISTER_FAILED | \
                                AFSAP_REMOVED_UNBIND | \
                                AFSAP_REMOVED_REQUEST | \
                                AFSAP_REMOVED_OPEN)
#define CLSAP_BUFFERSIZE    (sizeof(CO_SAP) +  \
                             sizeof(DEVICECLASS_NDISWAN_SAP))

//
// This control block is allocated for every open on the
// CO_ADDRESS_FAMILY_PPP and is threaded up on the miniport
// control block.
//
typedef struct _CM_AFSAPCB {
    LIST_ENTRY          Linkage;
    ULONG               Signature;
    ULONG               RefCount;
    struct _MINIPORTCB  *MiniportCB;
    NDIS_HANDLE         AfHandle;
    LIST_ENTRY          ProtocolCBList;
    WAN_EVENT           NotificationEvent;
    NDIS_STATUS         NotificationStatus;
    NDIS_SPIN_LOCK      Lock;
} CM_AFSAPCB, *PCM_AFSAPCB;

//
// This control block is allocated for every call
// to CmCreateVc
typedef struct _CM_VCCB {
    LIST_ENTRY          Linkage;
    ULONG               Signature;
    CmVcState           State;
    ULONG               RefCount;
    ULONG               Flags;
#define NO_FRAGMENT 0x00000001
    INT                 FlowClass;
    NDIS_HANDLE         NdisVcHandle;
    struct _PROTOCOLCB  *ProtocolCB;
    struct _CM_AFSAPCB  *AfSapCB;
    NDIS_SPIN_LOCK      Lock;
} CM_VCCB, *PCM_VCCB;

union _AFSAPVCCB{
    CL_AFSAPCB  ClAfSapCB;
    CM_AFSAPCB  CmAfSapCB;
    CM_VCCB     CmVcCB;
} AFSAPVCCB;

#define AFSAPVCCB_SIZE sizeof(AFSAPVCCB)
    
#if 0
typedef struct _PS_MEDIA_PARAMETERS{

    CO_MEDIA_PARAMETERS StdMediaParameters;
    UCHAR LinkId[6]; // Used by NdisWan
    NDIS_STRING InstanceName;

} PS_MEDIA_PARAMETERS, *PPS_MEDIA_PARAMETERS;

#endif

#define IE_IN_USE       0x00010000

#endif          // WAN_TYPES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\wanadd.h ===
//
// NDIS WAN Information structures used
// by NDIS 5.0 Miniport drivers
//

//
// Defines for the individual fields are the
// same as for NDIS 3.x/4.x Wan miniports.
//
// See the DDK.
//

//
// Information that applies to all VC's on
// this adapter.
//
// OID: OID_WAN_CO_GET_INFO
//
typedef struct _NDIS_WAN_CO_INFO {
	OUT ULONG			MaxFrameSize;
	OUT	ULONG			MaxSendWindow;
	OUT ULONG			FramingBits;
	OUT ULONG			DesiredACCM;
} NDIS_WAN_CO_INFO, *PNDIS_WAN_CO_INFO;

//
// Set VC specific PPP framing information.
//
// OID: OID_WAN_CO_SET_LINK_INFO
//
typedef struct _NDIS_WAN_CO_SET_LINK_INFO {
	IN	ULONG			MaxSendFrameSize;
	IN	ULONG			MaxRecvFrameSize;
	IN	ULONG			SendFramingBits;
	IN	ULONG			RecvFramingBits;
	IN	ULONG			SendCompressionBits;
	IN	ULONG			RecvCompressionBits;
	IN	ULONG			SendACCM;
	IN	ULONG			RecvACCM;
} NDIS_WAN_CO_SET_LINK_INFO, *PNDIS_WAN_CO_SET_LINK_INFO;

//
// Get VC specific PPP framing information.
//
// OID: OID_WAN_CO_GET_LINK_INFO
//
typedef struct _NDIS_WAN_CO_GET_LINK_INFO {
	OUT ULONG			MaxSendFrameSize;
	OUT ULONG			MaxRecvFrameSize;
	OUT ULONG			SendFramingBits;
	OUT ULONG			RecvFramingBits;
	OUT ULONG			SendCompressionBits;
	OUT ULONG			RecvCompressionBits;
	OUT ULONG			SendACCM;
	OUT ULONG			RecvACCM;
} NDIS_WAN_CO_GET_LINK_INFO, *PNDIS_WAN_CO_GET_LINK_INFO;

//
// Get VC specific PPP compression information
//
// OID: OID_WAN_CO_GET_COMP_INFO
//
typedef struct _NDIS_WAN_CO_GET_COMP_INFO {
	OUT NDIS_WAN_COMPRESS_INFO	SendCapabilities;
	OUT NDIS_WAN_COMPRESS_INFO	RecvCapabilities;
} NDIS_WAN_CO_GET_COMP_INFO, *PNDIS_WAN_CO_GET_COMP_INFO;


//
// Set VC specific PPP compression information
//
// OID: OID_WAN_CO_SET_COMP_INFO
//
typedef struct _NDIS_WAN_CO_SET_COMP_INFO {
	IN	NDIS_WAN_COMPRESS_INFO	SendCapabilities;
	IN	NDIS_WAN_COMPRESS_INFO	RecvCapabilities;
} NDIS_WAN_CO_SET_COMP_INFO, *PNDIS_WAN_CO_SET_COMP_INFO;


//
// Get VC specific statistics
//
// OID: OID_WAN_CO_GET_STATS_INFO
//
typedef struct _NDIS_WAN_CO_GET_STATS_INFO {
	OUT ULONG		BytesSent;
	OUT ULONG		BytesRcvd;
	OUT ULONG		FramesSent;
	OUT ULONG		FramesRcvd;
	OUT ULONG		CRCErrors;						// Serial-like info only
	OUT ULONG		TimeoutErrors;					// Serial-like info only
	OUT ULONG		AlignmentErrors;				// Serial-like info only
	OUT ULONG		SerialOverrunErrors;			// Serial-like info only
	OUT ULONG		FramingErrors;					// Serial-like info only
	OUT ULONG		BufferOverrunErrors;			// Serial-like info only
	OUT ULONG		BytesTransmittedUncompressed;	// Compression info only
	OUT ULONG		BytesReceivedUncompressed;		// Compression info only
	OUT ULONG		BytesTransmittedCompressed;	 	// Compression info only
	OUT ULONG		BytesReceivedCompressed;		// Compression info only
} NDIS_WAN_CO_GET_STATS_INFO, *PNDIS_WAN_CO_GET_STATS_INFO;

//
// Used to notify NdisWan of Errors.  See error
// bit mask in ndiswan.h
//
// NDIS_STATUS:	NDIS_STATUS_WAN_CO_FRAGMENT
//
typedef struct _NDIS_WAN_CO_FRAGMENT {
	IN	ULONG			Errors;
} NDIS_WAN_CO_FRAGMENT, *PNDIS_WAN_CO_FRAGMENT;

//
// Used to notify NdisWan of changes in link speed and
// send window.  Can be given at any time.  NdisWan will honor
// any send window (even zero).  NdisWan will default zero
// TransmitSpeed/ReceiveSpeed settings to 28.8Kbs.
//
// NDIS_STATUS:	NDIS_STATUS_WAN_CO_LINKPARAMS
//
typedef struct _WAN_CO_LINKPARAMS {
	ULONG	TransmitSpeed;				// Transmit speed of the VC in Bps
	ULONG	ReceiveSpeed;				// Receive speed of the VC in Bps
	ULONG	SendWindow;					// Current send window for the VC
} WAN_CO_LINKPARAMS, *PWAN_CO_LINKPARAMS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\kdext\api.c ===
#include <wanhelp.h>

DECLARE_API(ndiswancb)
{
	DWORD		Address, BytesRead;
	NDISWANCB	NdisWanCB;

	Address = GetExpression("ndiswan!ndiswancb");

	if (!ReadMemory(Address, &NdisWanCB, sizeof(NDISWANCB), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(NDISWANCB)) {

		DisplayNdisWanCB(Address, &NdisWanCB);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(NdisWanCB));
	}

	return;
}

DECLARE_API(enumwanadaptercb)
{
	DWORD	Address, BytesRead;
	WAN_GLOBAL_LIST	AdapterList;
	PWAN_GLOBAL_LIST	Address1;

	Address = GetExpression("ndiswan!wanadaptercblist");
	Address1 = (PWAN_GLOBAL_LIST)Address;

	if (!ReadMemory(Address, &AdapterList, sizeof(WAN_GLOBAL_LIST), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(WAN_GLOBAL_LIST)) {
		dprintf("WanAdapterCBList: 0x%8.8x\n",Address);
		dprintf("   Lock: 0x%8.8x Irql: 0x%8.8x\n",
		        AdapterList.Lock.SpinLock, AdapterList.Lock.OldIrql);
		dprintf("   Count: %ld MaxCount: %ld\n",
		        AdapterList.ulCount, AdapterList.ulMaxCount);

		Address = AdapterList.List.Flink;

		while ((PVOID)Address != (PVOID)&Address1->List) {
			WAN_ADAPTERCB	WanAdapterCB;

			if (ReadMemory(Address, &WanAdapterCB, sizeof(WAN_ADAPTERCB), &BytesRead)) {
				DisplayWanAdapterCB(Address, &WanAdapterCB);
			}

			Address = (DWORD)WanAdapterCB.Linkage.Flink;
		}

	} else {

		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(WAN_GLOBAL_LIST));
	}
}

DECLARE_API(wanadaptercb)
{
	DWORD			Address, BytesRead;
	WAN_ADAPTERCB	WanAdapterCB;
	PUCHAR			s = (PSTR)args;
	BOOLEAN			Verbose = FALSE;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("wanadapter <PWANADAPTERCB>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &WanAdapterCB, sizeof(WAN_ADAPTERCB), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(WAN_ADAPTERCB)) {

		DisplayWanAdapterCB(Address, &WanAdapterCB);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(WanAdapterCB));
	}
}

DECLARE_API(enumadaptercb)
{
	DWORD	Address, BytesRead;
	WAN_GLOBAL_LIST	AdapterList;
	PWAN_GLOBAL_LIST	Address1;


	Address = GetExpression("ndiswan!adaptercblist");
	Address1 = (PWAN_GLOBAL_LIST)Address;

	if (!ReadMemory(Address, &AdapterList, sizeof(WAN_GLOBAL_LIST), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(WAN_GLOBAL_LIST)) {

		dprintf("AdapterCBList: 0x%8.8x\n",Address);
		dprintf("   Lock: 0x%8.8x Irql: 0x%8.8x\n",
		        AdapterList.Lock.SpinLock, AdapterList.Lock.OldIrql);
		dprintf("   Count: %ld MaxCount: %ld\n",
		        AdapterList.ulCount, AdapterList.ulMaxCount);

		Address = AdapterList.List.Flink;

		while ((PVOID)Address != (PVOID)&Address1->List) {
			ADAPTERCB	AdapterCB;

			if (ReadMemory(Address, &AdapterCB, sizeof(ADAPTERCB), &BytesRead)) {
				DisplayAdapterCB(Address, &AdapterCB);
			}

			Address = (DWORD)AdapterCB.Linkage.Flink;
		}
	} else {

		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(WAN_GLOBAL_LIST));
	}
}

DECLARE_API(adaptercb)
{
	DWORD			Address, BytesRead;
	ADAPTERCB		AdapterCB;
	PUCHAR			s = (PSTR)args;
	BOOLEAN			Verbose = FALSE;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("adapter <PADAPTERCB>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &AdapterCB, sizeof(ADAPTERCB), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(ADAPTERCB)) {

		DisplayAdapterCB(Address, &AdapterCB);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(AdapterCB));
	}
}

DECLARE_API(connectiontable)
{
	DWORD		Address, Address1, BytesRead, i, j;
	CONNECTION_TABLE	ConnectionTable;

	Address = GetExpression("ndiswan!connectiontable");

	if (!ReadMemory(Address, &Address1, sizeof(DWORD), &BytesRead)) {
		return;
	}

	if (!ReadMemory(Address1, &ConnectionTable, sizeof(CONNECTION_TABLE), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(CONNECTION_TABLE)) {
		DisplayConnectionTable(Address, &ConnectionTable);

		for (i = 0, j = 0; j < ConnectionTable.ulNumActiveLinks; i++) {
			LINKCB	LinkCB;

			//
			// Get pointer to location in Linktable
			//
			Address = ConnectionTable.LinkArray + i;

			if (!ReadMemory(Address, &Address1, sizeof(DWORD), &BytesRead)) {
				continue;
			}

			if (Address1 != NULL) {

				if (ReadMemory(Address1, &LinkCB, sizeof(LINKCB), &BytesRead)) {
					DisplayLinkCB(Address1, &LinkCB);
					j++;
				}

			}

		}

		for (i = 0, j = 0; j < ConnectionTable.ulNumActiveBundles; i++) {
			BUNDLECB	BundleCB;

			//
			// Get pointer to location in bundletable
			//
			Address = ConnectionTable.BundleArray + i;


			if (!ReadMemory(Address, &Address1, sizeof(DWORD), &BytesRead)) {
				continue;
			}

			if (Address1 != NULL) {

				if (ReadMemory(Address1, &BundleCB, sizeof(BUNDLECB), &BytesRead)) {
					DisplayBundleCB(Address1, &BundleCB);
					j++;
				}
			}

		}

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(CONNECTION_TABLE));
	}
}

DECLARE_API(bundlecb)
{
	DWORD		Address, BytesRead;
	BUNDLECB	BundleCB;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("bundlecb <PBUNDLECB>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &BundleCB, sizeof(BUNDLECB), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(BUNDLECB)) {

		DisplayBundleCB(Address, &BundleCB);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(BUNDLECB));
	}
}

DECLARE_API(linkcb)
{
	DWORD	Address, BytesRead;
	LINKCB	LinkCB;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("linkcb <PLINKCB>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &LinkCB, sizeof(LINKCB), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(LINKCB)) {

		DisplayLinkCB(Address, &LinkCB);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(LINKCB));
	}
}

DECLARE_API(protocolcb)
{
	DWORD		Address, BytesRead;
	PROTOCOLCB	ProtocolCB;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("protocolcb <PPROTOCOLCB>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &ProtocolCB, sizeof(PROTOCOLCB), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(PROTOCOLCB)) {

		DisplayProtocolCB(Address, &ProtocolCB);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(PROTOCOLCB));
	}
}

DECLARE_API(wanpacket)
{
	DWORD		Address, BytesRead;
	NDIS_WAN_PACKET	Packet;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("wanpacket <PNDIS_WAN_PACKET>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &Packet, sizeof(NDIS_WAN_PACKET), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(NDIS_WAN_PACKET)) {

		DisplayWanPacket(Address, &Packet);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(NDIS_WAN_PACKET));
	}
}

DECLARE_API(ndispacket)
{
	DWORD		Address, BytesRead;
	NDIS_PACKET	Packet;

    //
    // Did they forget something...
    //
    if (0 == args[0])
    {
Usage:
        dprintf("ndispacket <PNDIS_PACKET>\n");
        return;
    }

	sscanf(args, "%lx", &Address);

	if (!ReadMemory(Address, &Packet, sizeof(NDIS_PACKET), &BytesRead)) {
		return;		
	}

	if (BytesRead >= sizeof(NDIS_PACKET)) {

		DisplayNdisPacket(Address, &Packet);

	} else {
		dprintf("Only read %d bytes, expected %d bytes\n", BytesRead, sizeof(NDIS_PACKET));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\kdext\wanhelp.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:


Environment:

    User Mode

--*/

#include <wanhelp.h>

//
// globals
//
EXT_API_VERSION        	ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  	ExtensionApis;
ULONG                  	STeip;
ULONG                  	STebp;
ULONG                  	STesp;
USHORT                 	SavedMajorVersion;
USHORT					SavedMinorVersion;
VOID	UnicodeToAnsi(PWSTR	pws,PSTR ps, ULONG cbLength);
CHAR	Name[1024];

PSTR	gApiDescriptions[] =
{
    "help             - What do you think your reading?\n",
    "ndiswancb        - Dump the contents of the main NdisWan control structure\n",
	"enumwanadaptercb - Dump the head of the WanAdapterCB list\n",
	"wanadaptercb     - Dump the contents of a Wan Miniport Adapter structure\n",
	"enumadaptercb    - Dump the head of the AdapterCB list\n",
	"adaptercb        - Dump the contents of a NdisWan Adapter structure\n",
	"connectiontable  - Dump the connetion table\n",
	"bundlecb         - Dump the bundlecb\n",
	"linkcb           - Dump the linkcb\n",
	"protocolcb       - Dump the protocolcb\n",
	"wanpacket        - Dump the wanpacket\n",
	"ndispacket       - Dump the ndispacket\n",
};

#define MAX_APIS 12

//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
BOOLEAN
DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
		case DLL_THREAD_ATTACH:
			DbgBreakPoint();
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

/*++
   Try and keep an accurate list of commands.
--*/
DECLARE_API(help)
{
   UINT  c;

	if (0 == args[0]) {
		for (c = 0; c < MAX_APIS; c++)
			dprintf(gApiDescriptions[c]);
		return;
	}
}

VOID
UnicodeToAnsi(
	PWSTR	pws,
	PSTR	ps,
	ULONG	cbLength
	)
{
	PSTR	Dest = ps;
	PWSTR	Src = pws;
	ULONG	Length = cbLength;

	dprintf("Enter UnicodeToAnsi\n");

	while (Length--) {
		*Dest++ = (CHAR)*Src++;
	}

	dprintf("Exit UnicodeToAnsi\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\kdext\display.c ===
#include <wanhelp.h>

PSTR MediumType[] =
{
	"NdisMedium802_3",
	"NdisMedium802_5",
	"NdisMediumFddi",
	"NdisMediumWan",
	"NdisMediumLocalTalk",
	"NdisMediumDix",
	"NdisMediumArcnetRaw",
	"NdisMediumArcnet878_2",
	"NdisMediumAtm",
	"NdisMediumWirelessWan",
	"NdisMediumIrda"
};

PSTR WanMediumSubtype[] =
{
    "NdisWanMediumHub",
    "NdisWanMediumX_25",
    "NdisWanMediumIsdn",
    "NdisWanMediumSerial",
    "NdisWanMediumFrameRelay",
    "NdisWanMediumAtm",
    "NdisWanMediumSonet",
    "NdisWanMediumSW56K"
};

PSTR WanHeaderFormat[] =
{
	"NdisWanHeaderNative",       // src/dest based on subtype, followed by NLPID
	"NdisWanHeaderEthernet"      // emulation of ethernet header
};

PSTR HardwareStatus[] =
{
    "NdisHardwareStatusReady",
    "NdisHardwareStatusInitializing",
    "NdisHardwareStatusReset",
    "NdisHardwareStatusClosing",
    "NdisHardwareStatusNotReady"
};

PSTR LinkCBStates[] =
{
	"LinkDown",
	"LinkGoingDown",
	"LinkUp"
};

PSTR BundleCBStates[] =
{
	"BundleDown",
	"BundleGowingDown",
	"BundleUp",
	"BundleRouted",
	"BundleUnrouting"
};

PSTR WanQuality[] =
{
	"NdisWanRaw",
	"NdisWanErrorControl",
	"NdisWanReliable"
};

PSTR DeferredQueueDesc[] =
{
	"ReceiveIndication",
	"SendComplete",
	"StatusIndication",
	"Loopback"
};

VOID
DisplayNdisWanCB(
	DWORD	Address,
	PNDISWANCB	NdisWanCB
	)
{
	dprintf("NdisWanCB: 0x%8.8x\n\n", Address);
	dprintf("   Lock: 0x%8.8x Irql: 0x%8.8x\n", NdisWanCB->Lock.SpinLock, NdisWanCB->Lock.OldIrql);
	dprintf("   NdisWrapperHandle: 0x%8.8x\n", NdisWanCB->hNdisWrapperHandle);
	dprintf("   ProtocolHandle: 0x%8.8x\n", NdisWanCB->hProtocolHandle);
	dprintf("   NumberOfProtocols: %ld\n", NdisWanCB->ulNumberOfProtocols);
	dprintf("   NumberOfLinks: %ld\n", NdisWanCB->ulNumberOfLinks);
	dprintf("   MiniumFragmentSize: 0x%8.8x\n", NdisWanCB->ulMinFragmentSize);
	dprintf("   TraceLevel: 0x%8.8x\n", NdisWanCB->ulTraceLevel);
	dprintf("   TraceMask: 0x%8.8x\n", NdisWanCB->ulTraceMask);
	dprintf("   DriverObject: 0x%8.8x\n", NdisWanCB->pDriverObject);
	dprintf("   DeviceObject: 0x%8.8x\n", NdisWanCB->pDeviceObject);
	dprintf("   PacketsSent: %ld\n", NdisWanCB->SendCount);
	dprintf("   PacketsCompleted: %ld\n", NdisWanCB->SendCompleteCount);
	dprintf("   IORecvQueueEmpty: %ld\n", NdisWanCB->IORecvError1);
	dprintf("   IORecvBeforMap: %ld\n", NdisWanCB->IORecvError2);
	dprintf("   PromiscuousAdapter: 0x%8.8x\n",NdisWanCB->PromiscuousAdapter);
}

VOID
DisplayWanAdapterCB(
	DWORD	Address,
	PWAN_ADAPTERCB	WanAdapterCB
	)
{
	dprintf("\n\nWanAdapterCB: 0x%8.8x\n", Address);

	dprintf("   Linkage:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
			WanAdapterCB->Linkage.Flink, WanAdapterCB->Linkage.Blink);

	dprintf("   Lock: 0x%8.8x Irql: 0x%8.8x\n",
			WanAdapterCB->Lock.SpinLock, WanAdapterCB->Lock.OldIrql);

	dprintf("   FreeLinkCBList:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
			WanAdapterCB->FreeLinkCBList.Flink, WanAdapterCB->FreeLinkCBList.Blink);

	dprintf("   NdisBindingHandle: 0x%8.8x\n", WanAdapterCB->hNdisBindingHandle);

	dprintf("   WanRequest: 0x%8.8x\n", WanAdapterCB->pWanRequest);
	dprintf("   LastRequest: 0x%8.8x\n", WanAdapterCB->pLastWanRequest);

	dprintf("   MiniportName: Buffer: 0x%8.8x Length: %ld\n",
			WanAdapterCB->MiniportName.Buffer, WanAdapterCB->MiniportName.Length);

	dprintf("   MediumType: %s\n", MediumType[WanAdapterCB->MediumType]);

	dprintf("   MediumSubType: %s\n", WanMediumSubtype[WanAdapterCB->MediumSubType]);

	dprintf("   WanHeaderFormat: %s\n", WanHeaderFormat[WanAdapterCB->WanHeaderFormat]);

	dprintf("   MaxFrameSize: %ld\n", WanAdapterCB->WanInfo.MaxFrameSize);

	dprintf("   MaxTransmit: %ld\n", WanAdapterCB->WanInfo.MaxTransmit);

	dprintf("   HeaderPadding: %ld\n",WanAdapterCB->WanInfo.HeaderPadding);

	dprintf("   TailPadding: %ld\n",WanAdapterCB->WanInfo.TailPadding);

	dprintf("   Endpoints: %ld\n",WanAdapterCB->WanInfo.Endpoints);

	dprintf("   MemoryFlags: 0x%8.8x\n",WanAdapterCB->WanInfo.MemoryFlags);

	dprintf("   HighestAddress: 0x%8.8x 0x%8.8x\n",
				WanAdapterCB->WanInfo.HighestAcceptableAddress.HighPart,
				WanAdapterCB->WanInfo.HighestAcceptableAddress.LowPart);

	dprintf("   FramingBits: 0x%8.8x\n",WanAdapterCB->WanInfo.FramingBits);

	dprintf("   DesiredACCM: 0x%8.8x\n",WanAdapterCB->WanInfo.DesiredACCM);
}

VOID
DisplayAdapterCB(
	DWORD	Address,
	PADAPTERCB	AdapterCB
	)
{
	DWORD	i;

	dprintf("\n\nAdapterCB: 0x%8.8x\n", Address);

	dprintf("   Linkage:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
			AdapterCB->Linkage.Flink, AdapterCB->Linkage.Blink);

	dprintf("   Lock: 0x%8.8x Irql: 0x%8.8x\n",
			AdapterCB->Lock.SpinLock, AdapterCB->Lock.OldIrql);

	dprintf("   ReferenceCount: %ld\n", AdapterCB->ulReferenceCount);

	dprintf("   MiniportAdapterHandle: 0x%8.8x\n", AdapterCB->hMiniportHandle);

	dprintf("   Flags: 0x%8.8x\n", AdapterCB->Flags);

	dprintf("   FreeDeferredQueue:\n");
	dprintf("      Head: 0x%8.8x\n", AdapterCB->FreeDeferredQueue.Head);
	dprintf("      Tail: 0x%8.8x\n", AdapterCB->FreeDeferredQueue.Tail);
	dprintf("      Count: %ld\n", AdapterCB->FreeDeferredQueue.Count);
	dprintf("      MaxCount: %ld\n", AdapterCB->FreeDeferredQueue.MaxCount);
	for (i = 0; i < MAX_DEFERRED_QUEUE_TYPES; i++) {
		dprintf("   DeferredQueue: %s\n", DeferredQueueDesc[i]);
		dprintf("      Head: 0x%8.8x\n", AdapterCB->DeferredQueue[i].Head);
		dprintf("      Tail: 0x%8.8x\n", AdapterCB->DeferredQueue[i].Tail);
		dprintf("      Count: %ld\n", AdapterCB->DeferredQueue[i].Count);
		dprintf("      MaxCount: %ld\n", AdapterCB->DeferredQueue[i].MaxCount);
	}

	dprintf("   MediumType: %s\n", MediumType[AdapterCB->MediumType]);

	dprintf("   HardwareStatus: %s\n", HardwareStatus[AdapterCB->HardwareStatus]);

	dprintf("   AdapterName: Buffer: 0x%8.8x Length: %d\n",
			AdapterCB->AdapterName.Buffer, AdapterCB->AdapterName.Length);

	dprintf("   NetworkAddress: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
			AdapterCB->NetworkAddress[0], AdapterCB->NetworkAddress[1], AdapterCB->NetworkAddress[2],
			AdapterCB->NetworkAddress[3], AdapterCB->NetworkAddress[4], AdapterCB->NetworkAddress[5]);

	dprintf("   NumberOfProtocols: %ld\n", AdapterCB->ulNumberofProtocols);

	dprintf("   ProtocolType: 0x%4.4x\n", AdapterCB->ProtocolType);

	dprintf("   NbfBundleCB: 0x%8.8x\n", AdapterCB->NbfBundleCB);
	dprintf("   NbfProtocolHandle: 0x%8.8x\n", AdapterCB->NbfProtocolHandle);

}

VOID
DisplayConnectionTable(
	DWORD	Address,
	PCONNECTION_TABLE	ConnectionTable
	)
{
	dprintf("\n\nConnectionTable: 0x%8.8x\n", Address);
	dprintf("   Lock: 0x%8.8x Irql: 0x%8.8x\n",
			ConnectionTable->Lock.SpinLock, ConnectionTable->Lock.OldIrql);
	dprintf("   AllocationSize: %ld\n", ConnectionTable->ulAllocationSize);
	dprintf("   ArraySize: %ld\n", ConnectionTable->ulArraySize);
	dprintf("   Number Of Active Links: %ld\n", ConnectionTable->ulNumActiveLinks);
	dprintf("   Number Of Active Bundles: %ld\n", ConnectionTable->ulNumActiveBundles);
	dprintf("   LinkArray: 0x%8.8x\n", ConnectionTable->LinkArray);
	dprintf("   BundleArray: 0x%8.8x\n", ConnectionTable->BundleArray);
}

VOID
DisplayLinkCB(
	DWORD	Address,
	PLINKCB	LinkCB
	)
{
	dprintf("\n\nLinkCB: 0x%8.8x\n", Address);
	dprintf("   Linkage:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	LinkCB->Linkage.Flink, LinkCB->Linkage.Blink);
	dprintf("   Handle: 0x%8.8x\n", LinkCB->hLinkHandle);
	dprintf("   User Context: 0x%8.8x\n", LinkCB->hLinkContext);
	dprintf("   ReferenceCount: %ld\n", LinkCB->ulReferenceCount);
	dprintf("   State: %s\n", LinkCBStates[LinkCB->State]);
	dprintf("   WanAdapterCB: 0x%8.8x\n", LinkCB->WanAdapterCB);
	dprintf("   BundleCB: 0x%8.8x\n", LinkCB->BundleCB);
	dprintf("   WanMiniport Lineup Context: 0x%8.8x\n", LinkCB->NdisLinkHandle);
	dprintf("   WanPacketPool:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	LinkCB->WanPacketPool.Flink, LinkCB->WanPacketPool.Blink);
	dprintf("   WanPacketCount: %ld\n", LinkCB->ulWanPacketCount);
	dprintf("   OutstandingFrames: %ld\n", LinkCB->OutstandingFrames);
	dprintf("   LastRecvSeqNumber: 0x%8.8x\n", LinkCB->LastRecvSeqNumber);
	dprintf("   RecvFragmentsLost: 0x%8.8x\n", LinkCB->RecvFragmentsLost);
	dprintf("   LinkBandwidth: %ld\n", LinkCB->ulBandwidth);
	dprintf("   LinkInfo:\n");
	dprintf("      MaxSendFrameSize: %ld\n", LinkCB->LinkInfo.MaxSendFrameSize);
	dprintf("      MaxRecvFrameSize: %ld\n", LinkCB->LinkInfo.MaxRecvFrameSize);
	dprintf("      HeaderPadding: %ld\n", LinkCB->LinkInfo.HeaderPadding);
	dprintf("      TailPadding: %ld\n", LinkCB->LinkInfo.TailPadding);
	dprintf("      SendFramingBits: 0x%8.8x\n", LinkCB->LinkInfo.SendFramingBits);
	dprintf("      RecvFramingBits: 0x%8.8x\n", LinkCB->LinkInfo.RecvFramingBits);
	dprintf("      SendCompressionBits: 0x%8.8x\n", LinkCB->LinkInfo.SendCompressionBits);
	dprintf("      RecvCompressionBits: 0x%8.8x\n", LinkCB->LinkInfo.RecvCompressionBits);
	dprintf("      SendACCM: 0x%8.8x\n", LinkCB->LinkInfo.SendACCM);
	dprintf("      RecvACCM: 0x%8.8x\n", LinkCB->LinkInfo.RecvACCM);
	dprintf("      MaxRSendFrameSize: %ld\n", LinkCB->LinkInfo.MaxRSendFrameSize);
	dprintf("      MaxRRecvFrameSize: %ld\n", LinkCB->LinkInfo.MaxRRecvFrameSize);
	dprintf("   LineUpInfo:\n");
	dprintf("      LinkSpeed: %ld\n", LinkCB->LineUpInfo.LinkSpeed);
	dprintf("      Quality: 0x%8.8x\n", LinkCB->LineUpInfo.Quality);
	dprintf("      SendWindow: %d\n", LinkCB->LineUpInfo.SendWindow);
	dprintf("      ConnectionWrapperID: 0x%8.8x\n", LinkCB->LineUpInfo.ConnectionWrapperID);
	dprintf("      NdisLinkHandle: 0x%8.8x\n", LinkCB->LineUpInfo.NdisLinkHandle);
	dprintf("      NdisLinkContext: 0x%8.8x\n", LinkCB->LineUpInfo.NdisLinkContext);
	dprintf("   FriendlyName: %s\n", LinkCB->Name);
	dprintf("   LinkStats:\n");
	dprintf("      BytesTransmitted: %ld\n", LinkCB->LinkStats.BytesTransmitted);
	dprintf("      BytesReceived: %ld\n", LinkCB->LinkStats.BytesReceived);
	dprintf("      FramesTransmitted: %ld\n", LinkCB->LinkStats.FramesTransmitted);
	dprintf("      FramesReceived: %ld\n", LinkCB->LinkStats.FramesReceived);

	dprintf("      CRCErrors: %ld\n", LinkCB->LinkStats.CRCErrors);
	dprintf("      TimeoutErrors: %ld\n", LinkCB->LinkStats.TimeoutErrors);
	dprintf("      AlignmentErrors: %ld\n", LinkCB->LinkStats.AlignmentErrors);
	dprintf("      SerialOverrunErrors: %ld\n", LinkCB->LinkStats.SerialOverrunErrors);
	dprintf("      FramingErrors: %ld\n", LinkCB->LinkStats.FramingErrors);
	dprintf("      BufferOverrunErrors: %ld\n", LinkCB->LinkStats.BufferOverrunErrors);
	dprintf("      ByteTransmittedUncompressed: %ld\n", LinkCB->LinkStats.BytesTransmittedUncompressed);
	dprintf("      BytesReceivedUncompressed: %ld\n", LinkCB->LinkStats.BytesReceivedUncompressed);
	dprintf("      BytesTransmittedCompressed: %ld\n", LinkCB->LinkStats.BytesTransmittedCompressed);
	dprintf("      BytesReceivedCompressed: %ld\n", LinkCB->LinkStats.BytesReceivedCompressed);
}

VOID
DisplayBundleCB(
	DWORD	Address,
	PBUNDLECB	BundleCB
	)
{
	DWORD	i;
	ENCRYPTION_INFO *EncryptInfo;
	A_SHA_CTX	*SHAContext;
	A_SHA_COMM_CTX	*SHACommon;
	PUCHAR	LMSessionKey, UserSessionKey, Challenge;


	dprintf("\n\nBundleCB: 0x%8.8x\n", Address);
	dprintf("   Handle: 0x%8.8x\n",BundleCB->hBundleHandle);
	dprintf("   ReferenceCount: %ld\n",BundleCB->ulReferenceCount);
	dprintf("   State: %s\n",BundleCBStates[BundleCB->State]);
	dprintf("   LinkCBList:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	BundleCB->LinkCBList.Flink, BundleCB->LinkCBList.Blink);
	dprintf("   LinkCBCount: %ld\n",BundleCB->ulLinkCBCount);
	dprintf("   FramingInfo:\n");
	dprintf("      SendFramingBits: 0x%8.8x\n", BundleCB->FramingInfo.SendFramingBits);
	dprintf("      RecvFramingBits: 0x%8.8x\n", BundleCB->FramingInfo.RecvFramingBits);
	dprintf("      MaxRSendFrameSize: %ld\n", BundleCB->FramingInfo.MaxRSendFrameSize);
	dprintf("      MaxRRecvFrameSize: %ld\n", BundleCB->FramingInfo.MaxRRecvFrameSize);
	dprintf("   NextLinkToXmit: 0x%8.8x\n",BundleCB->NextLinkToXmit);
	dprintf("   SendingLinks: %d\n", BundleCB->SendingLinks);
	dprintf("   SendPacketQueue:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	BundleCB->SendPacketQueue.Flink, BundleCB->SendPacketQueue.Blink);
	dprintf("   SendSequenceNumber: 0x%8.8x\n", BundleCB->SendSeqNumber);
	dprintf("   SendSequenceMask: 0x%8.8x\n", BundleCB->SendSeqMask);
	dprintf("   SendSequenceTest: 0x%8.8x\n", BundleCB->SendSeqTest);
	dprintf("   Flags: 0x%8.8x\n",BundleCB->Flags);
	dprintf("   OutstandingFrames: %ld\n",BundleCB->OutstandingFrames);
	dprintf("   RecvDescPool:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	BundleCB->RecvDescPool.Flink, BundleCB->RecvDescPool.Blink);
	dprintf("   RecvDesc Count: %ld\n", BundleCB->RecvDescCount);
	dprintf("   RecvDesc Max Count: %ld\n", BundleCB->RecvDescMax);
	dprintf("   RecvDescAssemblyList:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	BundleCB->RecvDescAssemblyList.Flink, BundleCB->RecvDescAssemblyList.Blink);
	dprintf("   RecvDescHole: 0x%8.8x\n", BundleCB->RecvDescHole);
	dprintf("   MinReceivedSeqNumber: 0x%8.8x\n", BundleCB->MinReceivedSeqNumber);
	dprintf("   RecvSeqMask: 0x%8.8x\n", BundleCB->RecvSeqMask);
	dprintf("   RecvSeqTest: 0x%8.8x\n", BundleCB->RecvSeqTest);
	dprintf("   RecvFragmentsLost: %ld\n", BundleCB->RecvFragmentsLost);
	dprintf("   LastRecvNonIdleData: %ld%ld\n", BundleCB->LastRecvNonIdleData.HighPart, BundleCB->LastRecvNonIdleData.LowPart);
	dprintf("   ProtocolCBTable: 0x%8.8x\n",BundleCB->ProtocolCBTable);
	dprintf("   Number Of Routes: %ld\n",BundleCB->ulNumberOfRoutes);
	dprintf("   ProtocolCBList:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	BundleCB->ProtocolCBList.Flink, BundleCB->ProtocolCBList.Blink);
	dprintf("   SendMask: 0x%8.8x\n",BundleCB->SendMask);
	dprintf("   LineUpInfo:\n");
	dprintf("      BundleSpeed: %ld\n", BundleCB->LineUpInfo.BundleSpeed);
	dprintf("      MaxSendSize: %ld\n", BundleCB->LineUpInfo.ulMaximumTotalSize);
	dprintf("      LinkQuality: %s\n", WanQuality[BundleCB->LineUpInfo.Quality]);
	dprintf("      SendWindow: %d\n", BundleCB->LineUpInfo.usSendWindow);
	dprintf("   SendVJInfo:\n");
	dprintf("      IPCompressionProtocol: 0x%4.4x\n", BundleCB->SendVJInfo.IPCompressionProtocol);
	dprintf("      MaxSlotID: %d\n", BundleCB->SendVJInfo.MaxSlotID);
	dprintf("      CompSlotID: %d\n", BundleCB->SendVJInfo.CompSlotID);
	dprintf("   RecvVJInfo:\n");
	dprintf("      IPCompressionProtocol: 0x%4.4x\n", BundleCB->RecvVJInfo.IPCompressionProtocol);
	dprintf("      MaxSlotID: %d\n", BundleCB->RecvVJInfo.MaxSlotID);
	dprintf("      CompSlotID: %d\n", BundleCB->RecvVJInfo.CompSlotID);
	dprintf("   VJCompress: 0x%8.8x\n", BundleCB->VJCompress);

	LMSessionKey = BundleCB->SendCompInfo.LMSessionKey;
	UserSessionKey = BundleCB->SendCompInfo.UserSessionKey;
	Challenge = BundleCB->SendCompInfo.Challenge;

	dprintf("   SendCompInfo:\n");
	dprintf("      MSCompType: 0x%8.8x\n", BundleCB->SendCompInfo.MSCompType);
	dprintf("      CompType: 0x%2.2x\n", BundleCB->SendCompInfo.CompType);
	dprintf("      CompLength: 0x%4.4x\n", BundleCB->SendCompInfo.CompLength);
	dprintf("      LMSessionKey: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	LMSessionKey[0], LMSessionKey[1], LMSessionKey[2], LMSessionKey[3],
    LMSessionKey[4], LMSessionKey[5], LMSessionKey[6], LMSessionKey[7]);
	dprintf("      UserSessionKey: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	UserSessionKey[0], UserSessionKey[1], UserSessionKey[2], UserSessionKey[3],
    UserSessionKey[4], UserSessionKey[5], UserSessionKey[6], UserSessionKey[7]);
	dprintf("                      0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	UserSessionKey[8], UserSessionKey[9], UserSessionKey[10], UserSessionKey[11],
    UserSessionKey[12], UserSessionKey[13], UserSessionKey[14], UserSessionKey[15]);
	dprintf("      Challenge: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	Challenge[0], Challenge[1], Challenge[2], Challenge[3],
    Challenge[4], Challenge[5], Challenge[6], Challenge[7]);
	dprintf("   SendCompressContext: 0x%8.8x\n", BundleCB->SendCompressContext);

	LMSessionKey = BundleCB->RecvCompInfo.LMSessionKey;
	UserSessionKey = BundleCB->RecvCompInfo.UserSessionKey;
	Challenge = BundleCB->RecvCompInfo.Challenge;

	dprintf("   RecvCompInfo:\n");
	dprintf("      MSCompType: 0x%8.8x\n", BundleCB->RecvCompInfo.MSCompType);
	dprintf("      CompType: 0x%2.2x\n", BundleCB->RecvCompInfo.CompType);
	dprintf("      CompLength: 0x%4.4x\n", BundleCB->RecvCompInfo.CompLength);
	dprintf("      LMSessionKey: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	LMSessionKey[0], LMSessionKey[1], LMSessionKey[2], LMSessionKey[3],
    LMSessionKey[4], LMSessionKey[5], LMSessionKey[6], LMSessionKey[7]);
	dprintf("      UserSessionKey: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	UserSessionKey[0], UserSessionKey[1], UserSessionKey[2], UserSessionKey[3],
    UserSessionKey[4], UserSessionKey[5], UserSessionKey[6], UserSessionKey[7]);
	dprintf("                      0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	UserSessionKey[8], UserSessionKey[9], UserSessionKey[10], UserSessionKey[11],
    UserSessionKey[12], UserSessionKey[13], UserSessionKey[14], UserSessionKey[15]);
	dprintf("      Challenge: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	Challenge[0], Challenge[1], Challenge[2], Challenge[3],
    Challenge[4], Challenge[5], Challenge[6], Challenge[7]);
	dprintf("   RecvCompressContext: 0x%8.8x\n", BundleCB->RecvCompressContext);

	EncryptInfo = &BundleCB->SendEncryptInfo;
	dprintf("   SendEncryptInfo:\n");
	dprintf("      StartKey  : 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->StartKey[0],EncryptInfo->StartKey[1],
	EncryptInfo->StartKey[2],EncryptInfo->StartKey[3],
	EncryptInfo->StartKey[4],EncryptInfo->StartKey[5],
	EncryptInfo->StartKey[6],EncryptInfo->StartKey[7]);
	dprintf("                : 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->StartKey[8],EncryptInfo->StartKey[9],
	EncryptInfo->StartKey[10],EncryptInfo->StartKey[11],
	EncryptInfo->StartKey[12],EncryptInfo->StartKey[13],
	EncryptInfo->StartKey[14],EncryptInfo->StartKey[15]);
	dprintf("      SessionKey: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->SessionKey[0],EncryptInfo->SessionKey[1],
	EncryptInfo->SessionKey[2],EncryptInfo->SessionKey[3],
	EncryptInfo->SessionKey[4],EncryptInfo->SessionKey[5],
	EncryptInfo->SessionKey[6],EncryptInfo->SessionKey[7]);
	dprintf("                : 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->SessionKey[8], EncryptInfo->SessionKey[9],
	EncryptInfo->SessionKey[10],EncryptInfo->SessionKey[11],
	EncryptInfo->SessionKey[12],EncryptInfo->SessionKey[13],
	EncryptInfo->SessionKey[14],EncryptInfo->SessionKey[15]);
	dprintf("      SessionKeyLength: %ld\n", EncryptInfo->SessionKeyLength);

#if 0
	SHAContext = (A_SHA_CTX*)&EncryptInfo->Context;
	SHACommon = &SHAContext->commonContext;
	dprintf("      SHAContext:\n");
	dprintf("         FinishFlag: 0x%8.8x\n", SHAContext->FinishFlag);
	dprintf("         HashVal: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHAContext->HashVal[0], SHAContext->HashVal[1], SHAContext->HashVal[2], SHAContext->HashVal[3], SHAContext->HashVal[4],
	SHAContext->HashVal[5], SHAContext->HashVal[6], SHAContext->HashVal[7], SHAContext->HashVal[8], SHAContext->HashVal[9]);
	dprintf("                  0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHAContext->HashVal[10], SHAContext->HashVal[11], SHAContext->HashVal[12], SHAContext->HashVal[13], SHAContext->HashVal[14],
	SHAContext->HashVal[15], SHAContext->HashVal[16], SHAContext->HashVal[17], SHAContext->HashVal[18], SHAContext->HashVal[19]);
	dprintf("         state: 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x\n",
	SHACommon->state[0], SHACommon->state[1], SHACommon->state[2], SHACommon->state[3], SHACommon->state[4]);
	dprintf("         count: %ld %ld\n", SHACommon->count[0], SHACommon->count[1]);
	dprintf("         buffer: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[0], SHACommon->buffer[1], SHACommon->buffer[2], SHACommon->buffer[3], SHACommon->buffer[4],
	SHACommon->buffer[5], SHACommon->buffer[6], SHACommon->buffer[7]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[8], SHACommon->buffer[9], SHACommon->buffer[10], SHACommon->buffer[11], SHACommon->buffer[12],
	SHACommon->buffer[13], SHACommon->buffer[14], SHACommon->buffer[15]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[16], SHACommon->buffer[17], SHACommon->buffer[18], SHACommon->buffer[19], SHACommon->buffer[20],
	SHACommon->buffer[21], SHACommon->buffer[22], SHACommon->buffer[23]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[24], SHACommon->buffer[25], SHACommon->buffer[26], SHACommon->buffer[27], SHACommon->buffer[28],
	SHACommon->buffer[29], SHACommon->buffer[30], SHACommon->buffer[31]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[32], SHACommon->buffer[33], SHACommon->buffer[34], SHACommon->buffer[35], SHACommon->buffer[36],
	SHACommon->buffer[37], SHACommon->buffer[38], SHACommon->buffer[39]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[40], SHACommon->buffer[41], SHACommon->buffer[42], SHACommon->buffer[43], SHACommon->buffer[44],
	SHACommon->buffer[45], SHACommon->buffer[46], SHACommon->buffer[47]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[48], SHACommon->buffer[49], SHACommon->buffer[50], SHACommon->buffer[51], SHACommon->buffer[52],
	SHACommon->buffer[53], SHACommon->buffer[54], SHACommon->buffer[55]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[56], SHACommon->buffer[57], SHACommon->buffer[58], SHACommon->buffer[59], SHACommon->buffer[60],
	SHACommon->buffer[61], SHACommon->buffer[62], SHACommon->buffer[63]);
	dprintf("   SendRC4Key: 0x%8.8x\n", BundleCB->SendRC4Key);
#endif

	EncryptInfo = &BundleCB->RecvEncryptInfo;
	dprintf("   RecvEncryptInfo:\n");
	dprintf("      StartKey  : 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->StartKey[0],EncryptInfo->StartKey[1],
	EncryptInfo->StartKey[2],EncryptInfo->StartKey[3],
	EncryptInfo->StartKey[4],EncryptInfo->StartKey[5],
	EncryptInfo->StartKey[6],EncryptInfo->StartKey[7]);
	dprintf("                : 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->StartKey[8],EncryptInfo->StartKey[9],
	EncryptInfo->StartKey[10],EncryptInfo->StartKey[11],
	EncryptInfo->StartKey[12],EncryptInfo->StartKey[13],
	EncryptInfo->StartKey[14],EncryptInfo->StartKey[15]);
	dprintf("      SessionKey: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->SessionKey[0],EncryptInfo->SessionKey[1],
	EncryptInfo->SessionKey[2],EncryptInfo->SessionKey[3],
	EncryptInfo->SessionKey[4],EncryptInfo->SessionKey[5],
	EncryptInfo->SessionKey[6],EncryptInfo->SessionKey[7]);
	dprintf("                : 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	EncryptInfo->SessionKey[8], EncryptInfo->SessionKey[9],
	EncryptInfo->SessionKey[10],EncryptInfo->SessionKey[11],
	EncryptInfo->SessionKey[12],EncryptInfo->SessionKey[13],
	EncryptInfo->SessionKey[14],EncryptInfo->SessionKey[15]);
	dprintf("      SessionKeyLength: %ld\n", EncryptInfo->SessionKeyLength);

#if 0
	SHAContext = (A_SHA_CTX*)&EncryptInfo->Context;
	SHACommon = &SHAContext->commonContext;
	dprintf("      SHAContext:\n");
	dprintf("         FinishFlag: 0x%8.8x\n", SHAContext->FinishFlag);
	dprintf("         HashVal: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHAContext->HashVal[0], SHAContext->HashVal[1], SHAContext->HashVal[2], SHAContext->HashVal[3], SHAContext->HashVal[4],
	SHAContext->HashVal[5], SHAContext->HashVal[6], SHAContext->HashVal[7], SHAContext->HashVal[8], SHAContext->HashVal[9]);
	dprintf("                  0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHAContext->HashVal[10], SHAContext->HashVal[11], SHAContext->HashVal[12], SHAContext->HashVal[13], SHAContext->HashVal[14],
	SHAContext->HashVal[15], SHAContext->HashVal[16], SHAContext->HashVal[17], SHAContext->HashVal[18], SHAContext->HashVal[19]);
	dprintf("         state: 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x\n",
	SHACommon->state[0], SHACommon->state[1], SHACommon->state[2], SHACommon->state[3], SHACommon->state[4]);
	dprintf("         count: %ld %ld\n", SHACommon->count[0], SHACommon->count[1]);
	dprintf("         buffer: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[0], SHACommon->buffer[1], SHACommon->buffer[2], SHACommon->buffer[3], SHACommon->buffer[4],
	SHACommon->buffer[5], SHACommon->buffer[6], SHACommon->buffer[7]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[8], SHACommon->buffer[9], SHACommon->buffer[10], SHACommon->buffer[11], SHACommon->buffer[12],
	SHACommon->buffer[13], SHACommon->buffer[14], SHACommon->buffer[15]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[16], SHACommon->buffer[17], SHACommon->buffer[18], SHACommon->buffer[19], SHACommon->buffer[20],
	SHACommon->buffer[21], SHACommon->buffer[22], SHACommon->buffer[23]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[24], SHACommon->buffer[25], SHACommon->buffer[26], SHACommon->buffer[27], SHACommon->buffer[28],
	SHACommon->buffer[29], SHACommon->buffer[30], SHACommon->buffer[31]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[32], SHACommon->buffer[33], SHACommon->buffer[34], SHACommon->buffer[35], SHACommon->buffer[36],
	SHACommon->buffer[37], SHACommon->buffer[38], SHACommon->buffer[39]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[40], SHACommon->buffer[41], SHACommon->buffer[42], SHACommon->buffer[43], SHACommon->buffer[44],
	SHACommon->buffer[45], SHACommon->buffer[46], SHACommon->buffer[47]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[48], SHACommon->buffer[49], SHACommon->buffer[50], SHACommon->buffer[51], SHACommon->buffer[52],
	SHACommon->buffer[53], SHACommon->buffer[54], SHACommon->buffer[55]);
	dprintf("                 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
	SHACommon->buffer[56], SHACommon->buffer[57], SHACommon->buffer[58], SHACommon->buffer[59], SHACommon->buffer[60],
	SHACommon->buffer[61], SHACommon->buffer[62], SHACommon->buffer[63]);
#endif
	dprintf("   RecvRC4Key: 0x%8.8x\n", BundleCB->RecvRC4Key);

	dprintf("   SCoherencyCounter: 0x%4.4x\n", BundleCB->SCoherencyCounter);
	dprintf("   RCoherencyCounter: 0x%4.4x\n", BundleCB->RCoherencyCounter);
	dprintf("   LastRC4Reset: 0x%4.4x\n", BundleCB->LastRC4Reset);
	dprintf("   CCPIdentifier: 0x%4.4x\n", BundleCB->CCPIdentifier);

#ifdef BANDWIDTH_ON_DEMAND
	dprintf("   UpperBonDInfo:\n");
	dprintf("      BytesThreshold: %ld\n", BundleCB->UpperBonDInfo.ulBytesThreshold);
	dprintf("      PercentBandwidth: %d\n", BundleCB->UpperBonDInfo.usPercentBandwidth);
	dprintf("      SecondsInSamplePeriod: %ld\n", BundleCB->UpperBonDInfo.ulSecondsInSamplePeriod);
	dprintf("      State: 0x%8.8x\n", BundleCB->UpperBonDInfo.State);
	dprintf("      StartTime: 0x%8.8x%8.8x\n",
	BundleCB->UpperBonDInfo.StartTime.HighPart, BundleCB->UpperBonDInfo.StartTime.LowPart);
	dprintf("      SampleTable:\n");
	dprintf("         FirstIndex: %ld\n", BundleCB->UpperBonDInfo.SampleTable.ulFirstIndex);
	dprintf("         CurrentIndex: %ld\n", BundleCB->UpperBonDInfo.SampleTable.ulCurrentIndex);
	dprintf("         CurrentSampleByteCount: %ld\n", BundleCB->UpperBonDInfo.SampleTable.ulCurrentSampleByteCount);
	dprintf("         SampleArraySize: %ld\n", BundleCB->UpperBonDInfo.SampleTable.ulSampleArraySize);
	dprintf("         SampleRate: 0x%8.8x%8.8x\n",
	BundleCB->UpperBonDInfo.SampleTable.SampleRate.HighPart, BundleCB->UpperBonDInfo.SampleTable.SampleRate.LowPart);
	dprintf("         SamplePeriod: 0x%8.8x%8.8x\n",
	BundleCB->UpperBonDInfo.SampleTable.SamplePeriod.HighPart, BundleCB->UpperBonDInfo.SampleTable.SamplePeriod.LowPart);
	dprintf("         SampleTable:\n");
	for (i = 0; i < SAMPLE_ARRAY_SIZE; i++) {
		dprintf("         Sample %d:\n", i);
		dprintf("            BytesThisSend: %ld\n",BundleCB->UpperBonDInfo.SampleTable.SampleArray[i].ulBytesThisSend);
		dprintf("            ReferenceCount: %ld\n",BundleCB->UpperBonDInfo.SampleTable.SampleArray[i].ulReferenceCount);
		dprintf("            TimeStample: 0x%8.8x%8.8x\n",
		BundleCB->UpperBonDInfo.SampleTable.SampleArray[i].TimeStamp.HighPart, BundleCB->UpperBonDInfo.SampleTable.SampleArray[i].TimeStamp.LowPart);
	}
	dprintf("   LowerBonDInfo:\n");
	dprintf("      BytesThreshold: %ld\n", BundleCB->LowerBonDInfo.ulBytesThreshold);
	dprintf("      PercentBandwidth: %d\n", BundleCB->LowerBonDInfo.usPercentBandwidth);
	dprintf("      SecondsInSamplePeriod: %ld\n", BundleCB->LowerBonDInfo.ulSecondsInSamplePeriod);
	dprintf("      State: 0x%8.8x\n", BundleCB->LowerBonDInfo.State);
	dprintf("      StartTime: 0x%8.8x%8.8x\n",
	BundleCB->LowerBonDInfo.StartTime.HighPart, BundleCB->LowerBonDInfo.StartTime.LowPart);
	dprintf("      SampleTable:\n");
	dprintf("         FirstIndex: %ld\n", BundleCB->LowerBonDInfo.SampleTable.ulFirstIndex);
	dprintf("         CurrentIndex: %ld\n", BundleCB->LowerBonDInfo.SampleTable.ulCurrentIndex);
	dprintf("         CurrentSampleByteCount: %ld\n", BundleCB->LowerBonDInfo.SampleTable.ulCurrentSampleByteCount);
	dprintf("         SampleArraySize: %ld\n", BundleCB->LowerBonDInfo.SampleTable.ulSampleArraySize);
	dprintf("         SampleRate: 0x%8.8x%8.8x\n",
	BundleCB->LowerBonDInfo.SampleTable.SampleRate.HighPart, BundleCB->LowerBonDInfo.SampleTable.SampleRate.LowPart);
	dprintf("         SamplePeriod: 0x%8.8x%8.8x\n",
	BundleCB->LowerBonDInfo.SampleTable.SamplePeriod.HighPart, BundleCB->LowerBonDInfo.SampleTable.SamplePeriod.LowPart);
	dprintf("         SampleArray:\n");
	for (i = 0; i < SAMPLE_ARRAY_SIZE; i++) {
		dprintf("         Sample %d:\n", i);
		dprintf("            BytesThisSend: %ld\n",BundleCB->LowerBonDInfo.SampleTable.SampleArray[i].ulBytesThisSend);
		dprintf("            ReferenceCount: %ld\n",BundleCB->LowerBonDInfo.SampleTable.SampleArray[i].ulReferenceCount);
		dprintf("            TimeStample: 0x%8.8x%8.8x\n",
		BundleCB->LowerBonDInfo.SampleTable.SampleArray[i].TimeStamp.HighPart, BundleCB->LowerBonDInfo.SampleTable.SampleArray[i].TimeStamp.LowPart);
	}
#endif

	dprintf("   FriendlyName: %s\n", BundleCB->Name);
	dprintf("   BundleStats:\n");
	dprintf("      BytesTransmitted: %ld\n", BundleCB->BundleStats.BytesTransmitted);
	dprintf("      BytesReceived: %ld\n", BundleCB->BundleStats.BytesReceived);
	dprintf("      FramesTransmitted: %ld\n", BundleCB->BundleStats.FramesTransmitted);
	dprintf("      FramesReceived: %ld\n", BundleCB->BundleStats.FramesReceived);

	dprintf("      CRCErrors: %ld\n", BundleCB->BundleStats.CRCErrors);
	dprintf("      TimeoutErrors: %ld\n", BundleCB->BundleStats.TimeoutErrors);
	dprintf("      AlignmentErrors: %ld\n", BundleCB->BundleStats.AlignmentErrors);
	dprintf("      SerialOverrunErrors: %ld\n", BundleCB->BundleStats.SerialOverrunErrors);
	dprintf("      FramingErrors: %ld\n", BundleCB->BundleStats.FramingErrors);
	dprintf("      BufferOverrunErrors: %ld\n", BundleCB->BundleStats.BufferOverrunErrors);
	dprintf("      ByteTransmittedUncompressed: %ld\n", BundleCB->BundleStats.BytesTransmittedUncompressed);
	dprintf("      BytesReceivedUncompressed: %ld\n", BundleCB->BundleStats.BytesReceivedUncompressed);
	dprintf("      BytesTransmittedCompressed: %ld\n", BundleCB->BundleStats.BytesTransmittedCompressed);
	dprintf("      BytesReceivedCompressed: %ld\n", BundleCB->BundleStats.BytesReceivedCompressed);
}

VOID
DisplayProtocolCB(
	DWORD	Address,
	PPROTOCOLCB	ProtocolCB
	)
{
	DWORD	i;

	dprintf("\n\nProtocolCB: 0x%8.8x\n", Address);
	dprintf("   Linkage:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	ProtocolCB->Linkage.Flink, ProtocolCB->Linkage.Blink);
	dprintf("   ProtocolHandle: 0x%8.8x\n", ProtocolCB->hProtocolHandle);
	dprintf("   ReferenceCount: %ld\n", ProtocolCB->ulReferenceCount);
	dprintf("   HeadNdisPacketQueue: 0x%8.8x\n", ProtocolCB->HeadNdisPacketQueue);
	dprintf("   TailNdisPacketQueue: 0x%8.8x\n", ProtocolCB->TailNdisPacketQueue);
	dprintf("   SendMaskBit: 0x%8.8x\n", ProtocolCB->SendMaskBit);
	dprintf("   AdapterCB: 0x%8.8x\n", ProtocolCB->AdapterCB);
	dprintf("   BundleCB: 0x%8.8x\n", ProtocolCB->BundleCB);
	dprintf("   Flags: 0x%8.8x\n", ProtocolCB->Flags);
	dprintf("   ProtocolType: 0x%4.4x\n", ProtocolCB->usProtocolType);
	dprintf("   PPP ProtocolID: 0x%4.4x\n", ProtocolCB->usPPPProtocolID);
	dprintf("   LastRecvNonIdleData: %ld%ld\n", ProtocolCB->LastRecvNonIdleData.HighPart, ProtocolCB->LastRecvNonIdleData.LowPart);
	dprintf("	NonIdleDetectFunc: 0x%8.8x\n", ProtocolCB->NonIdleDetectFunc);

#ifdef BANDWIDTH_ON_DEMAND
	dprintf("   Priority: %ld\n", ProtocolCB->usPriority);
	dprintf("   Bytes Quota: %ld\n", ProtocolCB->ulByteQuota);
	dprintf("      SampleTable:\n");
	dprintf("         FirstIndex: %ld\n", ProtocolCB->SampleTable.ulFirstIndex);
	dprintf("         CurrentIndex: %ld\n", ProtocolCB->SampleTable.ulCurrentIndex);
	dprintf("         CurrentSampleByteCount: %ld\n", ProtocolCB->SampleTable.ulCurrentSampleByteCount);
	dprintf("         SampleArraySize: %ld\n", ProtocolCB->SampleTable.ulSampleArraySize);
	dprintf("         SampleRate: 0x%8.8x%8.8x\n",
	ProtocolCB->SampleTable.SampleRate.HighPart, ProtocolCB->SampleTable.SampleRate.LowPart);
	dprintf("         SamplePeriod: 0x%8.8x%8.8x\n",
	ProtocolCB->SampleTable.SamplePeriod.HighPart, ProtocolCB->SampleTable.SamplePeriod.LowPart);
	dprintf("         SampleArray:\n");
	for (i = 0; i < SAMPLE_ARRAY_SIZE; i++) {
		dprintf("         Sample %d:\n", i);
		dprintf("            BytesThisSend: %ld\n",ProtocolCB->SampleTable.SampleArray[i].ulBytesThisSend);
		dprintf("            ReferenceCount: %ld\n",ProtocolCB->SampleTable.SampleArray[i].ulReferenceCount);
		dprintf("            TimeStample: 0x%8.8x%8.8x\n",
		ProtocolCB->SampleTable.SampleArray[i].TimeStamp.HighPart, ProtocolCB->SampleTable.SampleArray[i].TimeStamp.LowPart);
	}
#endif

	dprintf("   TransportHandle: 0x%8.8x\n", ProtocolCB->hTransportHandle);
	dprintf("   NdisWanAddress: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
			ProtocolCB->NdisWanAddress[0], ProtocolCB->NdisWanAddress[1], ProtocolCB->NdisWanAddress[2],
			ProtocolCB->NdisWanAddress[3], ProtocolCB->NdisWanAddress[4], ProtocolCB->NdisWanAddress[5]);
	dprintf("   TransportAddress: 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
			ProtocolCB->TransportAddress[0], ProtocolCB->TransportAddress[1], ProtocolCB->TransportAddress[2],
			ProtocolCB->TransportAddress[3], ProtocolCB->TransportAddress[4], ProtocolCB->TransportAddress[5]);
	dprintf("   DeviceName: Buffer: 0x%8.8x Length: %ld\n",
			ProtocolCB->DeviceName.Buffer, ProtocolCB->DeviceName.Length);
}

VOID
DisplayWanPacket(
	DWORD	Address,
	PNDIS_WAN_PACKET	Packet
	)
{

	dprintf("\n\nWanPacket: 0x%8.8x\n", Address);
	dprintf("   WanPacketQueue:\n");
	dprintf("      Flink: 0x%8.8x Blink: 0x%8.8x\n",
	Packet->WanPacketQueue.Flink, Packet->WanPacketQueue.Blink);
	dprintf("   CurrentBuffer: 0x%8.8x\n", Packet->CurrentBuffer);
	dprintf("   CurrentLength: %ld\n", Packet->CurrentLength);
	dprintf("   StartBuffer: 0x%8.8x\n", Packet->StartBuffer);
	dprintf("   EndBuffer: 0x%8.8x\n", Packet->EndBuffer);
	dprintf("   PR1 (LinkCB): 0x%8.8x\n", Packet->ProtocolReserved1);
	dprintf("   PR2 (NdisPacket): 0x%8.8x\n", Packet->ProtocolReserved2);
	dprintf("   PR3 (ProtocolCB): 0x%8.8x\n", Packet->ProtocolReserved3);
	dprintf("   PR4 (BytesSent): %ld\n", Packet->ProtocolReserved4);
	dprintf("   MR1: 0x%8.8x\n", Packet->MacReserved1);
	dprintf("   MR2: 0x%8.8x\n", Packet->MacReserved2);
	dprintf("   MR3: 0x%8.8x\n", Packet->MacReserved3);
	dprintf("   MR4: 0x%8.8x\n", Packet->MacReserved4);
}

VOID
DisplayNdisPacket(
	DWORD	Address,
	PNDIS_PACKET	Packet
	)
{

	dprintf("\n\nNdisPacket: 0x%8.8x\n", Address);
	dprintf("   Private:\n");
	dprintf("      PhysicalCount: 0x%8.8x\n", Packet->Private.PhysicalCount);
	dprintf("      TotalLength: %ld\n", Packet->Private.TotalLength);
	dprintf("      BufferHead: 0x%8.8x\n", Packet->Private.Head);
	dprintf("      BufferTail: 0x%8.8x\n", Packet->Private.Tail);
	dprintf("      Pool: 0x%8.8x\n", Packet->Private.Pool);
	dprintf("      Count: 0x%8.8x\n", Packet->Private.Count);
	dprintf("      Flags: 0x%8.8x\n", Packet->Private.Flags);
	dprintf("      ValidCounts: %d\n", Packet->Private.ValidCounts);
	dprintf("   MR1 (Next/MagicNumber): 0x%8.8x\n", *((PDWORD)&Packet->MiniportReserved[0]));
	dprintf("   MR2 (ReferenceCount): 0x%4.4x (Flags): 0x%4.4x\n",
	*((PWORD)&Packet->MiniportReserved[4]),*((PWORD)&Packet->MiniportReserved[6]));
	dprintf("   WR1: 0x%8.8x\n", *((PDWORD)&Packet->WrapperReserved[0]));
	dprintf("   WR2: 0x%8.8x\n", *((PDWORD)&Packet->WrapperReserved[4]));
}

#if 0
VOID
DisplayVJContext(
	DWORD	Address,
	struct slcompress *context
	)
{
	dprintf("\n\nVJ Compress: 0x%8.8x\n", Address);
	dprintf("   last_cs (tstate): 0x%8.8x\n", context->last_cs);
	dprintf("   last_recv: %d\n", context->last_recv);
	dprintf("   last_xmit: %d\n", context->last_xmit);
	dprintf("   flags: 0x%4.4x\n", context->flags);
	dprintf("   MaxStates: %d\n", context->MaxStates);
	dprintf("   OutPackets: %ld\n", context->OutPackets);
	dprintf("   OutCompressed: %ld\n", context->OutCompressed);
	dprintf("   OutMisses: %ld\n", context->OutMisses);
	dprintf("   InUncompressed: %ld\n", context->InUncompressed);
	dprintf("   InCompressed: %ld\n", context->InCompressed);
	dprintf("   InErrors: %ld\n", context->InErrors);
	dprintf("   InTossed: %ld\n", context->InTossed);
	dprintf("   TxStates:\n");
	for (i = 0; i < MAX_VJ_STATES; i++) {
		cstate *state = &context->tstate[i];
		dprintf("      next  : 0x%8.x8\n", state->cs_next);
		dprintf("      hlen  : %d\n", state->cs_hlen);
		dprintf("      id    : %d\n", state->cs_id);
		dprintf("      ip_hl : %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_tos: %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_len: %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_id : %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_off: %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_ttl: %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_p  : %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_sum: %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_hl : %d\n", state->slcs_u.ip_hl);
		dprintf("      ip_hl : %d\n", state->slcs_u.ip_hl);
	}

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\kdext\display.h ===
VOID
DisplayNdisWanCB(
	DWORD	Address,
	PNDISWANCB	NdisWanCB
	);

VOID
DisplayWanAdapterCB(
	ULONG	Address,
	PWAN_ADAPTERCB	WanAdapterCB
	);

VOID
DisplayAdapterCB(
	ULONG	Address,
	PADAPTERCB	AdapterCB
	);

VOID
DisplayConnectionTable(
	DWORD	Address,
	PCONNECTION_TABLE	ConnectionTable
	);

VOID
DisplayBundleCB(
	DWORD	Address,
	PBUNDLECB	BundleCB
	);

VOID
DisplayProtocolCB(
	DWORD	Address,
	PPROTOCOLCB	ProtocolCB
	);

VOID
DisplayLinkCB(
	DWORD	Address,
	PLINKCB	LinkCB
	);

VOID
DisplayWanPacket(
	DWORD	Address,
	PNDIS_WAN_PACKET	Packet
	);

VOID
DisplayNdisPacket(
	DWORD	Address,
	PNDIS_PACKET	Packet
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndiswan\kdext\wanhelp.h ===
/*++

   Copyright (c) 1993  Microsoft Corporation

   Module Name:

      wanhelp

   Abstract:


   Author:

      Thanks - Kyle Brandon

   History:

--*/

#ifndef __WANHELP_H
#define __WANHELP_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <stdio.h>
#include <wdbgexts.h>

#include <srb.h>
#include <io.h>

#include <qos.h>

//#include <imagehlp.h>
//#include <stdlib.h>
//#include <ntverp.h>
//#include <ndismain.h>
//#include <ndismac.h>
//#include <ndismini.h>
//#include <ndiswan.h>
#include "wan.h"
#include "display.h"

//
// support routines.
//
VOID UnicodeToAnsi(PWSTR pws, PSTR ps, ULONG cbLength);


//
// Internal definitions
//

#define	NOT_IMPLEMENTED				0xFACEFEED


#endif // __WANHELP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\precomp.h ===
#define NDIS_TAPI_CURRENT_VERSION 0x00030000
#include "ndis.h"
#include <ndisprv.h>
#include "ntddndis.h"
#include "ndisprv.h"
#include "pxdebug.h"
#include "ndiswan.h"
//#include "ndisadd.h"
#include "pxuser.h"
#include "proxy.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\proxy.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    Proxy.h

Abstract:

    Fuction prototypes and globals


Author:

    Tony Bell


Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    TonyBe      03/04/99        Created

--*/

#ifndef _PROXY__H
#define _PROXY__H

#include "pxtapi.h"
#include "pxdefs.h"
#include "pxtypes.h"
#include "ndpif.h"

//
// Global data
//
extern NPAGED_LOOKASIDE_LIST    ProviderEventLookaside;
extern NPAGED_LOOKASIDE_LIST    VcLookaside;
extern TAPI_LINE_TABLE          LineTable;
extern VC_TABLE                 VcTable;
extern TAPI_TSP_CB              TspCB;
extern PX_DEVICE_EXTENSION      *DeviceExtension;
extern TSP_EVENT_LIST           TspEventList;

//
// Functions from pxntinit.c
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PxCancelSetQuery(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Functions from pxinit.c
//

BOOLEAN
InitNDISProxy(
    VOID
    );

VOID
GetRegistryParameters(
    IN PUNICODE_STRING  RegistryPath
    );

NDIS_STATUS
GetConfigDword(
    NDIS_HANDLE Handle,
    PWCHAR      ParameterName,
    PULONG      Destination,
    ULONG       MinValue,
    ULONG       MaxValue
    );

//
// From pxcm.c
//
NDIS_STATUS
PxCmCreateVc(
    IN  NDIS_HANDLE         ProtocolAfContext,
    IN  NDIS_HANDLE         NdisVcHandle,
    OUT PNDIS_HANDLE        pProtocolVcContext
    );

NDIS_STATUS
PxCmDeleteVc(
    IN  NDIS_HANDLE         ProtocolVcContext
    );

NDIS_STATUS
PxCmOpenAf(
    IN  NDIS_HANDLE         CallMgrBindingContext,
    IN  PCO_ADDRESS_FAMILY  pAddressFamily,
    IN  NDIS_HANDLE         NdisAfHandle,
    OUT PNDIS_HANDLE        pCallMgrAfContext
    );

NDIS_STATUS
PxCmCloseAf(
    IN NDIS_HANDLE       CallMgrAfContext
    );

NDIS_STATUS
PxCmRegisterSap(
    IN  NDIS_HANDLE     CallMgrAfContext,
    IN  PCO_SAP         pCoSap,
    IN  NDIS_HANDLE     NdisSapHandle,
    OUT PNDIS_HANDLE    pCallMgrSapContext
    );

NDIS_STATUS
PxCmDeRegisterSap(
    IN  NDIS_HANDLE       CallMgrSapContext
    );

NDIS_STATUS
PxCmMakeCall(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  pCallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle         OPTIONAL,
    OUT PNDIS_HANDLE            pCallMgrPartyContext    OPTIONAL
    );

NDIS_STATUS
PxCmCloseCall(
    IN  NDIS_HANDLE     CallMgrVcContext,
    IN  NDIS_HANDLE     CallMgrPartyContext OPTIONAL,
    IN  PVOID           Buffer  OPTIONAL,
    IN  UINT            Size    OPTIONAL
    );

VOID
PxCmIncomingCallComplete(
    IN  NDIS_STATUS         Status,
    IN  NDIS_HANDLE         CallMgrVcContext,
    IN PCO_CALL_PARAMETERS pCallParameters
    );

NDIS_STATUS
PxCmAddParty(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  pCallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle,
    OUT PNDIS_HANDLE            pCallMgrPartyContext
    );

NDIS_STATUS
PxCmDropParty(
    IN  NDIS_HANDLE             CallMgrPartyContext,
    IN  PVOID                   Buffer  OPTIONAL,
    IN  UINT                    Size    OPTIONAL
    );

VOID
PxCmActivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     pCallParameters
    );

VOID
PxCmDeActivateVcComplete(
    IN  NDIS_STATUS         Status,
    IN  NDIS_HANDLE         CallMgrVcContext
    );

NDIS_STATUS
PxCmModifyCallQos(
    IN  NDIS_HANDLE         CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS pCallParameters
    );

NDIS_STATUS
PxCmRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

VOID
PxCmRequestComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE ProtocolVcContext,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN PNDIS_REQUEST NdisRequest
    );

NDIS_STATUS
PxCmMakeCall(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  pCallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle         OPTIONAL,
    OUT PNDIS_HANDLE            pCallMgrPartyContext    OPTIONAL
    );

//
// From pxutils.c
//
BOOLEAN
PxIsAdapterAlreadyBound(
    PNDIS_STRING    pDeviceName
    );


PPX_ADAPTER
PxAllocateAdapter(
    ULONG   ulAdditionalLength
    );

VOID
PxFreeAdapter(
    PPX_ADAPTER pAdapter
    );

PPX_CM_AF
PxAllocateCmAf(
    IN  PCO_ADDRESS_FAMILY  pFamily
    );

VOID
PxFreeCmAf(
    PPX_CM_AF    pCmAf
    );

PPX_CL_AF
PxAllocateClAf(
    IN  PCO_ADDRESS_FAMILY  pFamily,
    IN  PPX_ADAPTER         pAdapter
    );

VOID
PxFreeClAf(
    PPX_CL_AF    pAfBlock
    );

PPX_CM_SAP
PxAllocateCmSap(
    PCO_SAP     Sap
    );

VOID
PxFreeCmSap(
    PPX_CM_SAP   pCmSap
    );

VOID
PxFreeClSap(
    PPX_CL_SAP   pClSap
    );

PPX_VC
PxAllocateVc(
    IN PPX_CL_AF    pClAf
    );

VOID
PxFreeVc(
    PPX_VC  pVc
    );

#if 0
NDIS_STATUS
GenericGetNdisCallParams(
    IN  PPX_VC                  pProxyVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    TapiBuffer,
    OUT PCO_CALL_PARAMETERS     *pNdisCallParameters
    );

NDIS_STATUS
GenericGetTapiCallParams(
    IN PPX_VC               pProxyVc,
    IN PCO_CALL_PARAMETERS  pCallParams
    );

PPX_CL_SAP
GenericTranslateTapiSap(
    IN  PPX_CL_AF       pClAf,
    IN  PPX_TAPI_LINE   TapiLine
    );

VOID
GenericFreeNdisSap(
    IN  PPX_CL_AF       pAfBlock,
    IN  PCO_SAP         pCoSap
    );
#endif

NDIS_STATUS
PxAfXyzTranslateTapiCallParams(
    IN  PPX_VC                  pProxyVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    pTapiParams,
    OUT PCO_CALL_PARAMETERS *   ppNdisCallParams
    );

NDIS_STATUS
PxAfXyzTranslateNdisCallParams(
    IN  PPX_VC              pProxyVc,
    IN  PCO_CALL_PARAMETERS pNdisCallParams
    );

PPX_CL_SAP
PxAfXyzTranslateTapiSap(
    IN  PPX_CL_AF       pClAf,
    IN  PPX_TAPI_LINE   TapiLine
    );

NDIS_STATUS
PxAfTapiTranslateTapiCallParams(
    IN  PPX_VC                  pProxyVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    pTapiParams,
    OUT PCO_CALL_PARAMETERS *   ppNdisCallParams
    );

ULONG
PxCopyLineCallParams(
    IN  LINE_CALL_PARAMS *pSrcLineCallParams,
    OUT LINE_CALL_PARAMS *pDstLineCallParams
    );

NDIS_STATUS
PxAfTapiTranslateNdisCallParams(
    IN  PPX_VC                  pProxyVc,
    IN  PCO_CALL_PARAMETERS     pNdisCallParams
    );

PPX_CL_SAP
PxAfTapiTranslateTapiSap(
    IN  PPX_CL_AF       pClAf,
    IN  PPX_TAPI_LINE   TapiLine
    );

VOID
PxAfTapiFreeNdisSap(
    IN  PPX_CL_AF   pClAf,
    IN  PCO_SAP     pCoSap
    );

PCO_CALL_PARAMETERS
PxCopyCallParameters(
    IN  PCO_CALL_PARAMETERS pCallParameters
    );

VOID
PxStartIncomingCallTimeout(
    IN  PPX_VC  pProxyVc
    );

VOID
PxStopIncomingCallTimeout(
    IN  PPX_VC  pProxyVc
    );

VOID
PxIncomingCallTimeout(
    IN  PVOID   SystemSpecific1,
    IN  PVOID   FunctionContext,
    IN  PVOID   SystemSpecific2,
    IN  PVOID   SystemSpecific3
    );

ULONG
PxMapNdisStatusToTapiDisconnectMode(
    IN  NDIS_STATUS NdisStatus,
    IN  BOOLEAN     bMakeCallStatus
    );

NTSTATUS
IntegerToChar (
    IN ULONG    Value,
    IN LONG     OutputLength,
    OUT PSZ     String
    );

NTSTATUS
IntegerToWChar (
    IN  ULONG Value,
    IN  LONG OutputLength,
    OUT PWCHAR String
    );

BOOLEAN
PxAfAndSapFromDevClass(
    PPX_ADAPTER pAdapter,
    LPCWSTR     DevClass,
    PPX_CM_AF   *pCmAf,
    PPX_CM_SAP  *pCmSap
    );

VOID
GetAllDevClasses(
    PPX_ADAPTER pAdapter,
    LPCWSTR     DevClass,
    PULONG      DevClassSize
    );

VOID
PxCloseCallWithCm(
    PPX_VC      pVc
    );

NDIS_STATUS
PxCloseCallWithCl(
    PPX_VC      pVc
    );

VOID
DoDerefVcWork(
    PPX_VC  pVc
    );

VOID
DoDerefClAfWork(
    PPX_CL_AF   pClAf
    );

VOID
DoDerefCmAfWork(
    PPX_CM_AF   pCmAf
    );

//
// Functions from pxco.c
//
VOID
PxCoBindAdapter(
    OUT PNDIS_STATUS    pStatus,
    IN  NDIS_HANDLE     BindContext,
    IN  PNDIS_STRING    DeviceName,
    IN  PVOID           SystemSpecific1,
    IN  PVOID           SystemSpecific2
    );

VOID
PxCoOpenAdaperComplete(
    NDIS_HANDLE BindingContext,
    NDIS_STATUS Status,
    NDIS_STATUS OpenErrorStatus
    );

VOID
PxCoUnbindAdapter(
    OUT PNDIS_STATUS    pStatus,
    IN  NDIS_HANDLE     ProtocolBindContext,
    IN  PNDIS_HANDLE    UnbindContext
    );

VOID
PxCoCloseAdaperComplete(
    NDIS_HANDLE BindingContext,
    NDIS_STATUS Status
    );

VOID
PxCoRequestComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_REQUEST NdisRequest,
    IN NDIS_STATUS Status
    );

VOID
PxCoNotifyAfRegistration(
     IN  NDIS_HANDLE        BindingContext,
     IN  PCO_ADDRESS_FAMILY pFamily
     );

VOID
PxCoUnloadProtocol(
    VOID
    );

NDIS_STATUS
PxCoPnPEvent(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );

NDIS_STATUS
PxPnPSetPower(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );

NDIS_STATUS
PxPnPQueryPower(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );

NDIS_STATUS
PxPnPQueryRemove(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );

NDIS_STATUS
PxPnPCancelRemove(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );

NDIS_STATUS
PxPnPReconfigure(
    IN  PPX_ADAPTER     pAdapter        OPTIONAL,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    );

VOID
PxCoSendComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
    );

VOID
PxCoTransferDataComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status,
    IN UINT BytesTransferred
    );

VOID
PxCoResetComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_STATUS Status
    );

VOID
PxCoStatusComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    );

VOID
PxCoReceiveComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    );

VOID
PxCoStatus(
    IN   NDIS_HANDLE             ProtocolBindingContext,
    IN   NDIS_HANDLE             ProtocolVcContext   OPTIONAL,
    IN   NDIS_STATUS             GeneralStatus,
    IN   PVOID                   StatusBuffer,
    IN   UINT                    StatusBufferSize
    );

UINT
PxCoReceivePacket(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PNDIS_PACKET pNdisPacket
    );

VOID 
PxTerminateDigitDetection(
                          IN    PPX_VC              pVc,
                          IN    PNDISTAPI_REQUEST   pNdisTapiRequest,
                          IN    ULONG               ulReason
                          );

VOID 
PxDigitTimerRoutine(
                    IN PVOID SystemSpecific1,
                    IN PVOID FunctionContext,
                    IN PVOID SystemSpecific2,
                    IN PVOID SystemSpecific3
                    );

NDIS_STATUS
PxStopDigitReporting(
                     PPX_VC pVc
                     );


VOID 
PxHandleReceivedDigit(
    IN    PPX_VC  pVc,
    IN    PVOID   Buffer,
    IN    UINT    BufferSize
    );

VOID
PxHandleWanLinkParams(
    IN    PPX_VC  pVc,
    IN    PVOID   Buffer,
    IN    UINT    BufferSize
    );

//
// Functions from pxcl.c
//
NDIS_STATUS
PxClCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext
    );


NDIS_STATUS
PxClDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext
    );


NDIS_STATUS
PxClRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

VOID
PxClRequestComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE ProtocolVcContext,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN PNDIS_REQUEST NdisRequest
    );

VOID
PxClOpenAfComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE NdisAfHandle
    );

VOID
PxClCloseAfComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolAfContext
    );

VOID
PxClRegisterSapComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolSapContext,
    IN  PCO_SAP Sap,
    IN  NDIS_HANDLE NdisSapHandle
    );

VOID
PxClDeregisterSapComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolSapContext
    );

VOID
PxClMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    );

VOID
PxClModifyCallQosComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
PxClCloseCallComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN NDIS_HANDLE ProtocolPartyContext OPTIONAL
    );

VOID
PxClAddPartyComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN NDIS_HANDLE NdisPartyHandle,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
PxClDropPartyComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolPartyContext
    );

NDIS_STATUS
PxClIncomingCall(
    IN NDIS_HANDLE ProtocolSapContext,
    IN NDIS_HANDLE ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS pCallParams
    );

VOID
PxClIncomingCallQosChange(
    IN NDIS_HANDLE ProtocolVcContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
PxClIncomingCloseCall(
    IN NDIS_STATUS closeStatus,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PVOID CloseData OPTIONAL,
    IN UINT Size OPTIONAL
    );

VOID
PxClIncomingDropParty(
    IN NDIS_STATUS DropStatus,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN PVOID CloseData OPTIONAL,
    IN UINT Size OPTIONAL
    );

VOID
PxClCallConnected(
    IN NDIS_HANDLE  ProtocolVcContext
    );

//
// Functions from pxtapi.c
//

ULONG
GetLineEvents(
    PCHAR   EventBuffer,
    ULONG   BufferSize
    );

NDIS_STATUS
PxTapiPlaceHolder(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiMakeCall(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetDevCaps(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiAccept(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiAnswer(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiLineGetID (
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiClose(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiCloseCall(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiConditionalMediaDetection(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiConfigDialog(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiDevSpecific(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiDial(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiDrop(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetAddressCaps(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetAddressID(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetAddressStatus(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetCallInfo(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetCallStatus(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetDevConfig(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetExtensionID(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetID(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetLineDevStatus(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiNegotiateExtVersion(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSendUserUserInfo(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSetAppSpecific(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSetCallParams(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSetDefaultMediaDetection(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSetDevConfig(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSetMediaMode(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSetStatusMessages (
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGetCallAddressID(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiOpen(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiProviderInit(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiProviderShutdown(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSecureCall(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiSelectExtVersion(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiGatherDigits(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );

NDIS_STATUS
PxTapiMonitorDigits(
    IN PNDISTAPI_REQUEST    pndisTapiRequest
    );  

VOID
PxTapiCompleteDropIrps(
    IN PPX_VC   pVc,
    IN ULONG    Status
    );

VOID
PxTapiCompleteAllIrps(
    IN PPX_VC   pVc,
    IN ULONG    Status
    );

VOID
PxIndicateStatus(
    IN  PVOID   StatusBuffer,
    IN  UINT    StatusBufferSize
    );


NDIS_STATUS
AllocateTapiResources(
    IN  PPX_ADAPTER ClAdapter,
    IN  PPX_CL_AF   pClAf
    );

PPX_TAPI_PROVIDER
AllocateTapiProvider(
    IN PPX_ADAPTER  ClAdapter,
    IN PPX_CL_AF    pClAf
    );

VOID
MarkProviderOnline(
   PPX_TAPI_PROVIDER   TapiProvider
   );

VOID
MarkProviderOffline(
    PPX_TAPI_PROVIDER   TapiProvider
    );

VOID
MarkProviderConnected(
    PPX_TAPI_PROVIDER   TapiProvider
    );

VOID
MarkProviderDisconnected(
    PPX_TAPI_PROVIDER   TapiProvider
    );

VOID
ClearSapWithTapiLine(
    PPX_CL_SAP  pClSap
  );

VOID
FreeTapiProvider(
    PPX_TAPI_PROVIDER   TapiProvider
    );


PPX_TAPI_LINE
AllocateTapiLine(
    IN PPX_TAPI_PROVIDER    TapiProvider,
    IN ULONG                LineID
    );

VOID
FreeTapiLine(
    IN PPX_TAPI_LINE    TapiLine
    );

PPX_TAPI_ADDR
AllocateTapiAddr(
    IN PPX_TAPI_PROVIDER    TapiProvider,
    IN PPX_TAPI_LINE        TapiLine,
    IN ULONG                AddrID
    );

VOID
FreeTapiAddr(
    IN  PPX_TAPI_ADDR   TapiAddr
    );

NDIS_STATUS
AllocateTapiCallInfo(
    PPX_VC          pVC,
    LINE_CALL_INFO  UNALIGNED *LineCallInfo
    );

BOOLEAN
InsertVcInTable(
    PPX_VC          pVc
    );

VOID
RemoveVcFromTable(
    PPX_VC          pVc
    );

BOOLEAN
IsTapiLineValid(
    ULONG           hdLine,
    PPX_TAPI_LINE   *TapiLine
    );

BOOLEAN
IsTapiDeviceValid(
    ULONG           ulDeviceID,
    PPX_TAPI_LINE   *TapiLine
    );

BOOLEAN
IsVcValid(
    ULONG_PTR       CallId,
    PPX_VC          *pVc
    );

VOID
GetVcFromCtx(
    NDIS_HANDLE     VcCtx,
    PPX_VC          *pVc
    );

BOOLEAN
IsAddressValid(
    PPX_TAPI_LINE   TapiLine,
    ULONG           AddressId,
    PPX_TAPI_ADDR   *TapiAddr
    );

BOOLEAN
GetLineFromCmLineID(
    PPX_TAPI_PROVIDER   TapiProvider,
    ULONG               CmLineID,
    PPX_TAPI_LINE       *TapiLine
    );

PPX_TAPI_ADDR
GetAvailAddrFromProvider(
    PPX_TAPI_PROVIDER   TapiProvider
    );

PPX_TAPI_ADDR
GetAvailAddrFromLine(
    PPX_TAPI_LINE   TapiLine
    );

BOOLEAN
GetAvailLineFromProvider(
    PPX_TAPI_PROVIDER   TapiProvider,
    PPX_TAPI_LINE       *TapiLine,
    PPX_TAPI_ADDR       *TapiAddr
    );

BOOLEAN
InsertLineInTable(
    PPX_TAPI_LINE   TapiLine
    );

VOID
RemoveTapiLineFromTable(
    PPX_TAPI_LINE   TapiLine
    );

NDIS_STATUS
PxVcCleanup(
    PPX_VC  pVc,
    ULONG   DropPending
    );


#endif  // _PROXY__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\pxcl.c ===
/*++                        

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    pxcl.c

Abstract:

    The module contains the calls to the proxy client from NDIS.

Author:

   Richard Machin (RMachin)

Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    RMachin     10-3-96         created
    TonyBe      02-21-99        re-work/re-write

Notes:

--*/
#include "precomp.h"

#define MODULE_NUMBER MODULE_CL
#define _FILENUMBER 'LCXP'


NDIS_STATUS
PxClCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PPX_CL_AF   pClAf;
    PPX_VC      pVc;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClCreateVc: ClAf %p\n", ProtocolAfContext));

    pClAf = (PPX_CL_AF)ProtocolAfContext;

    NdisAcquireSpinLock(&pClAf->Lock);

    if (pClAf->State != PX_AF_OPENED) {
        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClCreateVc: Invalid AfState ClAf %p, State %x\n", 
             pClAf, pClAf->State));

        NdisReleaseSpinLock(&pClAf->Lock);

        return (NDIS_STATUS_FAILURE);
    }

    pVc = PxAllocateVc(pClAf);

    if (pVc == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClCreateVc: Error allocating memory\n"));

        NdisReleaseSpinLock(&pClAf->Lock);

        return (NDIS_STATUS_RESOURCES);
    }

    pVc->ClVcHandle = NdisVcHandle;

    NdisReleaseSpinLock(&pClAf->Lock);

    if (!InsertVcInTable(pVc)) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClCreateVc: failed to insert in vc table\n"));

        PxFreeVc(pVc);

        return (NDIS_STATUS_RESOURCES);
    }
   
    *ProtocolVcContext = (NDIS_HANDLE)pVc->hdCall;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClCreateVc: Exit\n"));

    return(NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
PxClDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext
    )
{
    PPX_VC  pVc;

    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClDeleteVc: Enter\n"));

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClDeleteVc: VcCtx invalid %x\n", ProtocolVcContext));

        return (NDIS_STATUS_FAILURE);
    }

    ASSERT(pVc->State == PX_VC_IDLE);

    //
    // Deref for ref applied when we allocated the Vc.
    // We do not need the full deref code as the ref
    // applied at entry will keep the vc around.
    //
    pVc->RefCount--;

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC(pVc);

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClDeleteVc: Exit, Status %x\n", Status));

    return (Status);
}


NDIS_STATUS
PxClRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    )
/*++

Routine Description:

    This is called by an underlying cm/mp to send an ndisrequest to
    a client.  Since we might be proxying on behalf of multiple clients
    we need to broadcast this request on to all clients that have
    opened our address family for this adapter.  We are interested in
    OID_CO_AF_CLOSE so that we can cleanup our open on the Af and
    OID_GEN_CO_LINK_SPEED so that we can get changes in linkspeed
    on the adapter (and Vc if active).

Arguments:



Return Value:


--*/
{
    PPX_CL_AF       pClAf;
    PPX_CM_AF       pCmAf;
    PPX_ADAPTER     pAdapter;
    PPX_VC          pVc = NULL;
    NDIS_STATUS     Status;
    NDIS_HANDLE     VcHandle;

    //
    // The Vc returned here could be NULL as this
    // request might not be on vc.
    //
    GetVcFromCtx(ProtocolVcContext, &pVc);
    
    pClAf = (PPX_CL_AF)ProtocolAfContext;
    pAdapter = pClAf->Adapter;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClRequest: ClAf %p, Vc %p\n", pClAf, pVc));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    switch (NdisRequest->DATA.QUERY_INFORMATION.Oid) {
        case OID_CO_AF_CLOSE:
            {
            PPX_TAPI_PROVIDER   TapiProvider;

            NdisAcquireSpinLock(&pAdapter->Lock);

            RemoveEntryList(&pClAf->Linkage);

            InsertTailList(&pAdapter->ClAfClosingList, &pClAf->Linkage);

            NdisReleaseSpinLock(&pAdapter->Lock);

            //
            // We need to cleanup and close the open
            // on this af.  This would include tearing
            // down all active calls (Vc's), deregistering
            // all saps and closing the af.
            //
            NdisAcquireSpinLock(&pClAf->Lock);

            //
            // Mark the Af as closing...
            //
            pClAf->State = PX_AF_CLOSING;

            TapiProvider = pClAf->TapiProvider;

            NdisReleaseSpinLock(&pClAf->Lock);

            //
            // Take all tapi devices associated with
            // this address family offline
            //
            if (TapiProvider != NULL) {
                NdisAcquireSpinLock(&TapiProvider->Lock);

                MarkProviderOffline(TapiProvider);

                NdisReleaseSpinLock(&TapiProvider->Lock);
            }

            //
            // Build list of Vc's that need attention
            //
            NdisAcquireSpinLock(&pClAf->Lock);

            while (!IsListEmpty(&pClAf->VcList)) {
                PLIST_ENTRY         Entry;
                PPX_VC              pActiveVc;

                Entry = RemoveHeadList(&pClAf->VcList);

                InsertHeadList(&pClAf->VcClosingList, Entry);

                pActiveVc = CONTAINING_RECORD(Entry, PX_VC, ClAfLinkage);

                NdisReleaseSpinLock(&pClAf->Lock);

                NdisAcquireSpinLock(&pActiveVc->Lock);

                pActiveVc->CloseFlags |= PX_VC_CLOSE_AF;

                REF_VC(pActiveVc);

                PxVcCleanup(pActiveVc, 0);

                DEREF_VC_LOCKED(pActiveVc);

                NdisAcquireSpinLock(&pClAf->Lock);
            }

            //
            // Get rid of all of the saps
            //
            {
                PLIST_ENTRY pe;
                PPX_CL_SAP  pClSap;

                pe = pClAf->ClSapList.Flink;

                pClSap =
                    CONTAINING_RECORD(pe, PX_CL_SAP, Linkage);

                while ((PVOID)pClSap != (PVOID)&pClAf->ClSapList) {

                    if (InterlockedCompareExchange((PLONG)&pClSap->State,
                                                   PX_SAP_CLOSING,
                                                   PX_SAP_OPENED) == PX_SAP_OPENED) {

                        RemoveEntryList(&pClSap->Linkage);

                        InsertTailList(&pClAf->ClSapClosingList, &pClSap->Linkage);

                        NdisReleaseSpinLock(&pClAf->Lock);

                        ClearSapWithTapiLine(pClSap);

                        Status = NdisClDeregisterSap(pClSap->NdisSapHandle);

                        if (Status != NDIS_STATUS_PENDING) {
                            PxClDeregisterSapComplete(Status, pClSap);
                        }

                        NdisAcquireSpinLock(&pClAf->Lock);

                        pe = pClAf->ClSapList.Flink;

                        pClSap =
                            CONTAINING_RECORD(pe, PX_CL_SAP, Linkage);
                    } else {
                        pe = pClSap->Linkage.Flink;

                        pClSap =
                            CONTAINING_RECORD(pe, PX_CL_SAP, Linkage);
                    }
                }
            }

            DEREF_CL_AF_LOCKED(pClAf);

            //
            // Now broadcast this close to all of the clients
            // we have using this adapter/af.
            //
            NdisAcquireSpinLock(&pAdapter->Lock);

            while (!IsListEmpty(&pAdapter->CmAfList)) {
                PX_REQUEST  ProxyRequest;
                PPX_REQUEST pProxyRequest = &ProxyRequest;
                ULONG       Info = 0;
                PNDIS_REQUEST   tempNdisRequest;

                pCmAf = (PPX_CM_AF)RemoveHeadList(&pAdapter->CmAfList);

                InsertTailList(&pAdapter->CmAfClosingList, &pCmAf->Linkage);

                NdisReleaseSpinLock(&pAdapter->Lock);

                NdisAcquireSpinLock(&pCmAf->Lock);

                pCmAf->State = PX_AF_CLOSING;

                REF_CM_AF(pCmAf);

                NdisReleaseSpinLock(&pCmAf->Lock);

                NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

                tempNdisRequest = &pProxyRequest->NdisRequest;

                tempNdisRequest->RequestType =
                    NdisRequestSetInformation;
                tempNdisRequest->DATA.QUERY_INFORMATION.Oid =
                    OID_CO_AF_CLOSE;
                tempNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                    &Info;
                tempNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                    sizeof(ULONG);

                PxInitBlockStruc(&pProxyRequest->Block);

                Status = NdisCoRequest(pAdapter->CmBindingHandle,
                                       pCmAf->NdisAfHandle,
                                       NULL,
                                       NULL,
                                       tempNdisRequest);

                if (Status == NDIS_STATUS_PENDING) {
                    Status = PxBlock(&pProxyRequest->Block);
                }

                DEREF_CM_AF(pCmAf);

                NdisAcquireSpinLock(&pAdapter->Lock);
            }

            NdisReleaseSpinLock(&pAdapter->Lock);

            }
            break;

        case OID_GEN_CO_LINK_SPEED:
            //
            // We need to record the new speed of
            // the vc.
            //
            break;

        default:
            //
            // Just pass it through
            //
            break;
    }

    VcHandle = (pVc != NULL) ? pVc->CmVcHandle : NULL;

    //
    // Now broadcast this request up to all of the Clients 
    // that have opend our af for this adapter.
    //
    NdisAcquireSpinLock(&pAdapter->Lock);

    pCmAf = (PPX_CM_AF)pAdapter->CmAfList.Flink;

    while ((PVOID)pCmAf != (PVOID)&pAdapter->CmAfList) {
        PPX_CM_AF   NextAf;
        PX_REQUEST  ProxyRequest;
        PPX_REQUEST pProxyRequest = &ProxyRequest;

        NextAf = 
            (PPX_CM_AF)pCmAf->Linkage.Flink;

        NdisAcquireSpinLock(&pCmAf->Lock);

        if (pCmAf->State != PX_AF_OPENED) {
            NdisReleaseSpinLock(&pCmAf->Lock);
            pCmAf = NextAf;
            continue;
        }

        REF_CM_AF(pCmAf);
        NdisReleaseSpinLock(&pCmAf->Lock);

        NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

        NdisMoveMemory(&pProxyRequest->NdisRequest, NdisRequest, sizeof(NDIS_REQUEST));

        NdisReleaseSpinLock(&pAdapter->Lock);

        PxInitBlockStruc(&pProxyRequest->Block);

        Status = NdisCoRequest(pAdapter->CmBindingHandle,
                               pCmAf->NdisAfHandle,
                               VcHandle,
                               NULL,
                               &pProxyRequest->NdisRequest);

        if (Status == NDIS_STATUS_PENDING) {
            PxBlock(&pProxyRequest->Block);
        }

        NdisAcquireSpinLock(&pAdapter->Lock);

        //
        // deref for the ref applied before we
        // propagated this request
        //
        DEREF_CM_AF(pCmAf);

        pCmAf = NextAf;
    }

    NdisReleaseSpinLock(&pAdapter->Lock);

    //
    // Remove ref applied when we attempted to
    // map the vcctx to a vcptr at entry.
    //
    DEREF_VC(pVc);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return (NDIS_STATUS_SUCCESS);
}

VOID
PxClRequestComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE ProtocolVcContext,       // Optional
    IN NDIS_HANDLE ProtocolPartyContext,    // Optional
    IN PNDIS_REQUEST NdisRequest
    )
{
    PPX_REQUEST     pProxyRequest;
    PPX_CL_AF       pClAf;
    PPX_VC          pVc = NULL;

    pClAf = (PPX_CL_AF)ProtocolAfContext;

    //
    // The Vc returned here could be NULL as this
    // request might not be on vc.
    //
    GetVcFromCtx(ProtocolVcContext, &pVc);

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClRequestComplete: ClAf %p, Vc %p, Oid: %x, Status %x\n", 
         pClAf, pVc, NdisRequest->DATA.QUERY_INFORMATION.Oid, Status));

    pProxyRequest = CONTAINING_RECORD(NdisRequest, PX_REQUEST, NdisRequest);

    if (pProxyRequest->Flags & PX_REQ_ASYNC) {
        pProxyRequest->Flags &= ~PX_REQ_ASYNC;
        PxFreeMem(pProxyRequest);
    } else {
        PxSignal(&pProxyRequest->Block, Status);
    }

    //
    // Remove ref applied when we attempted to
    // map the vcctx to a vcptr at entry.
    //
    DEREF_VC(pVc);
}

VOID
PxClOpenAfComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisAfHandle
    )
{
    PPX_CL_AF   pClAf;

    pClAf = (PPX_CL_AF)ProtocolAfContext;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClOpenAfComplete: ClAf %p, Status %x\n", pClAf, Status));

    pClAf->NdisAfHandle = NdisAfHandle;

    PxSignal(&pClAf->Block, Status);
}

VOID
PxClCloseAfComplete(
    IN NDIS_STATUS  Status,
    IN NDIS_HANDLE  ProtocolAfContext
    )
{
    PPX_CL_AF   pClAf;
    PPX_ADAPTER pAdapter;
    PPX_TAPI_PROVIDER   TapiProvider;

    pClAf = (PPX_CL_AF)ProtocolAfContext;
    pAdapter = pClAf->Adapter;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClCloseAfComplete: ClAf %p, Status %x\n", pClAf, Status));

   // ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    NdisAcquireSpinLock(&pAdapter->Lock);

    RemoveEntryList(&pClAf->Linkage);

    DEREF_ADAPTER_LOCKED(pAdapter);

    NdisAcquireSpinLock(&pClAf->Lock);

    pClAf->State = PX_AF_CLOSED;

    TapiProvider = pClAf->TapiProvider;
    pClAf->TapiProvider = NULL;

    NdisReleaseSpinLock(&pClAf->Lock);

    if (TapiProvider != NULL) {

        NdisAcquireSpinLock(&TapiProvider->Lock);

        MarkProviderOffline(TapiProvider);

        NdisReleaseSpinLock(&TapiProvider->Lock);
    }

    PxFreeClAf(pClAf);

   // ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
}


VOID
PxClRegisterSapComplete(
    IN NDIS_STATUS  Status,
    IN NDIS_HANDLE  ProtocolSapContext,
    IN PCO_SAP      pSap,
    IN NDIS_HANDLE  NdisSapHandle
    )
{
    PPX_CL_SAP      pClSap;
    PPX_CL_AF       pClAf;
    PPX_TAPI_LINE   TapiLine;

    pClSap = (PPX_CL_SAP)ProtocolSapContext;
    pClAf = pClSap->ClAf;
    TapiLine = pClSap->TapiLine;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClRegisterSapComplete: ClSap %p, Status %x\n", pClSap, Status));


    if (Status != NDIS_STATUS_SUCCESS) {

        InterlockedExchange((PLONG)&pClSap->State, PX_SAP_CLOSED);

        NdisAcquireSpinLock(&pClAf->Lock);

        RemoveEntryList(&pClSap->Linkage);

        DEREF_CL_AF_LOCKED(pClAf);

        TapiLine->ClSap = NULL;

        PxFreeClSap(pClSap);

        return;
    }

    pClSap->NdisSapHandle = NdisSapHandle;

    NdisAcquireSpinLock(&pClAf->Lock);

    if (pClAf->State != PX_AF_OPENED) {
        //
        // the af is no longer open so we to deregister
        // this sap
        //

        NdisReleaseSpinLock(&pClAf->Lock);

        InterlockedExchange((PLONG)&pClSap->State, PX_SAP_CLOSING);

        Status = NdisClDeregisterSap(pClSap->NdisSapHandle);

        if (Status != NDIS_STATUS_PENDING) {
            PxClDeregisterSapComplete(Status, pClSap);
        }

        return;
    }

    NdisReleaseSpinLock(&pClAf->Lock);


    NdisAcquireSpinLock(&TapiLine->Lock);

    if (TapiLine->DevStatus->ulNumOpens == 0) {

        NdisReleaseSpinLock(&TapiLine->Lock);

        //
        // There are not any opens on the line so we
        // need to deregister the sap
        //
        InterlockedExchange((PLONG)&pClSap->State, PX_SAP_CLOSING);

        Status = NdisClDeregisterSap(pClSap->NdisSapHandle);

        if (Status != NDIS_STATUS_PENDING) {
            PxClDeregisterSapComplete(Status, pClSap);
        }

        return;
    }

    NdisReleaseSpinLock(&TapiLine->Lock);

    InterlockedExchange((PLONG)&pClSap->State, PX_SAP_OPENED);
}

VOID
PxClDeregisterSapComplete(
    IN NDIS_STATUS  Status,
    IN NDIS_HANDLE  ProtocolSapContext
    )
{
    PPX_CL_SAP  pClSap;
    PPX_CL_AF   pClAf;

    pClSap = (PPX_CL_SAP)ProtocolSapContext;
    pClAf = pClSap->ClAf;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClDeregisterSapComplete: ClSap %p, Status %x\n", pClSap, Status));

    NdisAcquireSpinLock(&pClAf->Lock);

    RemoveEntryList(&pClSap->Linkage);

    DEREF_CL_AF_LOCKED(pClAf);

    InterlockedExchange((PLONG)&pClSap->State, PX_SAP_CLOSED);

    PxFreeClSap(pClSap);
}

VOID
PxClMakeCallComplete(
    IN  NDIS_STATUS         Status,
    IN  NDIS_HANDLE         ProtocolVcContext,
    IN  NDIS_HANDLE         ProxyNdisPartyHandle OPTIONAL,
    IN  PCO_CALL_PARAMETERS pCallParameters
    )
{
    PPX_VC      pVc;
    PPX_CL_AF   pClAf;
    ULONG       ulCallState;
    ULONG       ulCallStateMode;
    BOOLEAN     TapiStateChange;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClMakeCallComplete: VcCtx %x, Status %x\n", ProtocolVcContext, Status));

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {
        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClMakeCallComplete: pVc invalid %x\n", ProtocolVcContext));

        return;
    }

    TapiStateChange = TRUE;

    NdisAcquireSpinLock(&pVc->Lock);

    ASSERT(pVc->Flags & PX_VC_OWNER);

    do {

        if (pVc->Flags & PX_VC_OUTCALL_ABORTED) {
            //
            // This call has been aborted while
            // in the PROCEEDING state.  This means
            // that the CloseCallComplete has run 
            // and did our cleanup so just get
            // out.
            //
            break;

        } else if (pVc->Flags & PX_VC_OUTCALL_ABORTING) {
            pVc->Flags &= ~PX_VC_OUTCALL_ABORTING;
            pVc->Flags |= PX_VC_OUTCALL_ABORTED;
        }


        ASSERT((pVc->State == PX_VC_DISCONNECTING) ||
               (pVc->State == PX_VC_PROCEEDING));

        if (Status == NDIS_STATUS_SUCCESS) {

            //
            // This means that we received a drop from tapi
            // while the ClMakeCall was pending.
            //
            if (pVc->State == PX_VC_DISCONNECTING) {
                //
                // We need to drop the call with the
                // call manager/miniport
                //
                pVc->Flags &= ~PX_VC_OUTCALL_ABORTED;
                PxCloseCallWithCm(pVc);

                TapiStateChange = FALSE;

            } else {

                ulCallState = LINECALLSTATE_CONNECTED;
                ulCallStateMode = 0;
                pVc->PrevState = pVc->State;
                pVc->State = PX_VC_CONNECTED;
            }

        } else {

            ulCallState = LINECALLSTATE_DISCONNECTED;
            ulCallStateMode =
                PxMapNdisStatusToTapiDisconnectMode(Status, TRUE);

            //
            // Remove the ref applied before we
            // call NdisClMakeCall.  We don't need
            // to do the full deref code here as the
            // ref applied when we mapped the vc will
            // keep the vc around!
            //
            pVc->RefCount--;

            pVc->PrevState = pVc->State;
            pVc->State = PX_VC_IDLE;
        }

        if (TapiStateChange == TRUE) {

            SendTapiCallState(pVc, 
                              ulCallState, 
                              ulCallStateMode, 
                              pVc->CallInfo->ulMediaMode);
        }

        if (pVc->Flags & PX_VC_DROP_PENDING){
            PxTapiCompleteDropIrps(pVc, Status);
        }

    } while (FALSE);

    //
    // Deref for ref applied when mapping the context.
    // This releases the Vc lock!
    //
    DEREF_VC_LOCKED(pVc);
}

VOID
PxClModifyCallQosComplete(
    IN NDIS_STATUS          Status,
    IN NDIS_HANDLE          ProtocolVcContext,
    IN PCO_CALL_PARAMETERS  CallParameters
    )
{

}


VOID
PxClCloseCallComplete(
    IN NDIS_STATUS  Status,
    IN NDIS_HANDLE  ProtocolVcContext,
    IN NDIS_HANDLE  ProtocolPartyContext OPTIONAL
    )
{
    PPX_VC      pVc;
    PPX_CL_AF   pClAf;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClCloseCallComplete: VcCtx %x, Status %x\n", ProtocolVcContext, Status));

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClCloseCallComplete: pVc invalid %x\n", ProtocolVcContext));

        return;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    do {

        //
        // The closecall did not take (atm does
        // not support receiving a closecall while
        // an outgoing call is proceeding).  We 
        // need to get out and cleanup later.
        //
        if (Status != NDIS_STATUS_SUCCESS) {
            pVc->Flags |= PX_VC_CLEANUP_CM;
            pVc->CloseFlags |= PX_VC_CM_CLOSE_FAIL;
            break;
        }

        pVc->CloseFlags |= PX_VC_CM_CLOSE_COMP;

        if (pVc->Flags & PX_VC_OUTCALL_ABORTED) {

            //
            // This call has been aborted while
            // in the PROCEEDING state.  This means
            // that the MakeCallComplete has run 
            // and did our cleanup so just get
            // out.
            //
            break;

        } else if (pVc->Flags & PX_VC_OUTCALL_ABORTING) {

            pVc->Flags &= ~PX_VC_OUTCALL_ABORTING;
            pVc->Flags |= PX_VC_OUTCALL_ABORTED;
        } else if (pVc->Flags & PX_VC_INCALL_ABORTING) {
            pVc->Flags &= ~PX_VC_INCALL_ABORTING;
            pVc->Flags |= PX_VC_INCALL_ABORTED;
        }

        pVc->PrevState = pVc->State;
        pVc->State = PX_VC_IDLE;

        pClAf = pVc->ClAf;

        SendTapiCallState(pVc, 
                          LINECALLSTATE_DISCONNECTED, 
                          0, 
                          pVc->CallInfo->ulMediaMode);

        if (pVc->Flags & PX_VC_DROP_PENDING) {
            PxTapiCompleteDropIrps(pVc, Status);
        }

        //
        // Remove the ref applied when this call
        // became connected with the call manager
        // (NdisClMakeCall/PxClIncomingCall).
        // We don't need to do the full deref code 
        // here as the ref applied when we mapped 
        // the vc will keep the vc around!
        //
        pVc->RefCount--;

    } while (FALSE);

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);
}


VOID
PxClAddPartyComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN NDIS_HANDLE NdisPartyHandle,
    IN PCO_CALL_PARAMETERS CallParameters
    )
{
    ASSERT(0);
}

VOID
PxClDropPartyComplete(
    IN NDIS_STATUS status,
    IN NDIS_HANDLE ProtocolPartyContext
    )
{
    ASSERT(0);
}

NDIS_STATUS
PxClIncomingCall(
    IN NDIS_HANDLE              ProtocolSapContext,
    IN NDIS_HANDLE              ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS  pCallParams
    )
{
    PPX_VC      pVc;
    PPX_CL_SAP  pClSap;
    PPX_CL_AF   pClAf;
    NDIS_STATUS Status;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClIncomingCall: Sap %p VcCtx %x\n", 
         ProtocolSapContext, ProtocolVcContext));

    pClSap = (PPX_CL_SAP)ProtocolSapContext;

    if (pClSap->State != PX_SAP_OPENED) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClIncomingCall: Invalid SapState Sap %p State %x\n", 
             pClSap, pClSap->State));

        return (NDIS_STATUS_FAILURE);
    }

    pClAf = pClSap->ClAf;

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClIncomingCall: pVc invalid %x\n", ProtocolVcContext));

        return (NDIS_STATUS_FAILURE);
    }

    Status =
        (*pClAf->AfGetTapiCallParams)(pVc, pCallParams);

    if (Status != NDIS_STATUS_SUCCESS) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClIncomingCall: pVc invalid %x\n", ProtocolVcContext));

        return (Status);
    }

    NdisAcquireSpinLock(&pVc->Lock);

    // The algorithim for computing a unique "htCall" is to start
    // at the value 1, and perpetually increment by 2.  Keeping
    // the low bit set will allow the user-mode TAPI component
    // we talk to to distinguish between these incoming call handles
    // and outgoing call handles, the latter of which will always
    // have the low bit zero'd (since they're really pointers to heap).
    //
    // In <= NT 4.0, valid values used to range between 0x80000000
    // and 0xffffffff, as we relied on the fact that user-mode
    // addresses always had the low bit zero'd.  (Not a valid
    // assumption anymore!)
    //

    pVc->htCall = 
        InterlockedExchangeAdd((PLONG)&TspCB.htCall, 2);

    //
    // This ref is applied for the indication to
    // tapi of a new call.  The ref will be removed
    // when tapi closes the call in PxTapiCloseCall.
    //
    REF_VC(pVc);

    //
    // This ref is applied for the connection
    // between the proxy and the call manager.
    // The ref will be removed in either 
    // PxClCloseCallComplete or PxVcCleanup
    // in the case where the offered call is
    // dropped by the client.
    //
    REF_VC(pVc);

    SendTapiNewCall(pVc, 
                    pVc->hdCall, 
                    pVc->htCall, 
                    0);

    SendTapiCallState(pVc, 
                      LINECALLSTATE_OFFERING, 
                      0, 
                      pVc->CallInfo->ulMediaMode);

    pVc->PrevState = pVc->State;
    pVc->State = PX_VC_OFFERING;

    PxStartIncomingCallTimeout(pVc);

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    return (NDIS_STATUS_PENDING);
}

VOID
PxClIncomingCallQosChange(
    IN NDIS_HANDLE          ProtocolVcContext,
    IN PCO_CALL_PARAMETERS  pCallParams
    )
{

}


VOID
PxClIncomingCloseCall(
    IN NDIS_STATUS  CloseStatus,
    IN NDIS_HANDLE  ProtocolVcContext,
    IN PVOID        CloseData OPTIONAL,
    IN UINT         Size OPTIONAL
    )
{
    PPX_VC      pVc;
    PPX_CL_AF   pClAf;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClIncomingCloseCall: VcCtx %x\n", ProtocolVcContext));

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClIncomingCloseCall: pVc invalid %x\n", ProtocolVcContext));

        return;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    pVc->CloseFlags |= PX_VC_INCOMING_CLOSE;

    PxVcCleanup(pVc, PX_VC_CLEANUP_CM);

    //
    // remove the ref applied when we
    // mapped the ctx to the vc at entry
    //
    DEREF_VC_LOCKED(pVc);

}

VOID
PxClIncomingDropParty(
    IN NDIS_STATUS  DropStatus,
    IN NDIS_HANDLE  ProtocolPartyContext,
    IN PVOID        CloseData OPTIONAL,
    IN UINT         Size OPTIONAL
    )
{
    ASSERT(0);
}

VOID
PxClCallConnected(
    IN NDIS_HANDLE ProtocolVcContext
    )
{
    PPX_VC  pVc;

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClCallConnected: VcCtx %x\n", ProtocolVcContext));

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("PxClCallConnected: pVc invalid %x\n", ProtocolVcContext));

        return;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    PXDEBUGP(PXD_LOUD, PXM_CL,
        ("PxClCallConnected: pVc %p, State %x\n", pVc, pVc->State));

    if (pVc->State == PX_VC_CONNECTED) {

        SendTapiCallState(pVc, 
                          LINECALLSTATE_CONNECTED, 
                          0, 
                          pVc->CallInfo->ulMediaMode);
    }

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    PXDEBUGP(PXD_LOUD, PXM_CL, ("PxClCallConnected: Exit\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\pxdebug.c ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    PXDebug.c

Abstract:

    This module contains all debug-related code.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    rmachin     11-01-96    stolen from ArvindM's cmadebug file
    TonyBe      02-21-99    re-work/re-write

Notes:

--*/


#include <precomp.h>

#define MODULE_NUMBER MODULE_DEBUG
#define _FILENUMBER 'BDXP'

#if DBG

ULONG   PXDebugLevel = PXD_ERROR;
ULONG   PXDebugMask = PXM_ALL;

LIST_ENTRY  PxdMemoryList;
ULONG       PxdAllocCount = 0;  // how many allocated so far (unfreed)

NDIS_SPIN_LOCK    PxdMemoryLock;
BOOLEAN           PxdInitDone = FALSE;


PVOID
PxAuditAllocMem(
    PVOID   pPointer,
    ULONG   Size,
    ULONG   Tag,
    ULONG   FileNumber,
    ULONG   LineNumber
    )
{
    PVOID               pBuffer = NULL;
    PPXD_ALLOCATION     pAllocInfo;
    NDIS_STATUS         Status;

    if(!PxdInitDone) {
        NdisAllocateSpinLock(&(PxdMemoryLock));
        InitializeListHead(&PxdMemoryList);
        PxdInitDone = TRUE;
    }

    pAllocInfo = ExAllocatePoolWithTag(NonPagedPool,
                                       Size+sizeof(PXD_ALLOCATION),
                                       Tag);

    if (pAllocInfo != NULL) {

        pBuffer = (PVOID)&(pAllocInfo->UserData);
        NdisFillMemory(pBuffer, Size, 0xAF);
        pAllocInfo->Signature = PXD_MEMORY_SIGNATURE;
        pAllocInfo->FileNumber = FileNumber;
        pAllocInfo->LineNumber = LineNumber;
        pAllocInfo->Size = Size;
        pAllocInfo->Location = (ULONG_PTR)pPointer;

        NdisAcquireSpinLock(&(PxdMemoryLock));

        InsertTailList(&PxdMemoryList, &pAllocInfo->Linkage);

        PxdAllocCount++;

        NdisReleaseSpinLock(&(PxdMemoryLock));
    }

    return (pBuffer);
}


VOID
PxAuditFreeMem(
    PVOID   Pointer
    )
{
    PPXD_ALLOCATION pAllocInfo;

    pAllocInfo = CONTAINING_RECORD(Pointer, PXD_ALLOCATION, UserData);

    if(pAllocInfo->Signature != PXD_MEMORY_SIGNATURE)
    {
        DbgPrint("PxAuditFreeMem: unknown buffer 0x%x!\n", Pointer);
        DbgBreakPoint();
        return;
    }

    NdisAcquireSpinLock(&(PxdMemoryLock));

    pAllocInfo->Signature = (ULONG)'DEAD';

    RemoveEntryList(&pAllocInfo->Linkage);

    PxdAllocCount--;

    NdisReleaseSpinLock(&(PxdMemoryLock));

    ExFreePool(pAllocInfo);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\pxco.c ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    pxdown.c

Abstract:

    The module contains the calls to NDIS for the NDIS Proxy.

Author:

   Richard Machin (RMachin)

Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    RMachin     10-3-96         created
    TonyBe      02-21-99        re-work/re-write

Notes:

--*/
#include "precomp.h"
#include <atm.h>
#define MODULE_NUMBER MODULE_CO
#define _FILENUMBER   'OCXP'

VOID
PxCoBindAdapter(
    OUT PNDIS_STATUS    pStatus,
    IN  NDIS_HANDLE     BindContext,
    IN  PNDIS_STRING    DeviceName,
    IN  PVOID           SystemSpecific1,
    IN  PVOID           SystemSpecific2
    )
/*++

Routine Description:
    Entry point that gets called by NDIS when an adapter appears on the
    system.

Arguments:
    pStatus - place for our Return Value
    BindContext - to be used if we call NdisCompleteBindAdapter; we don't
    DeviceName - Name of the adapter to be bound to
    SystemSpecific1 - Name of the protocol-specific entry in this adapter's
            registry section
    SystemSpecific2 - Not used

Return Value:
    None. We set *pStatus to NDIS_STATUS_SUCCESS if everything goes off well,
    otherwise an NDIS error status.

--*/
{
    NDIS_STATUS         OpenError;
    UINT                SelectedIndex;
    PPX_ADAPTER         pAdapter = NULL;
    NDIS_MEDIUM         Media[NdisMediumMax];
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    ULONG               InitStage = 0;

    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxCoBindAdapter: %Z\n", DeviceName));

    //
    //  Wait for all calls to NdisRegisterProtocol to complete.
    //
    NdisWaitEvent(&DeviceExtension->NdisEvent, 0);

    //
    // Use a do..while..false loop and break on error.
    // Cleanup is at the end of the loop.
    //
    do
    {
        //
        //  Check if this is a device we have already bound to.
        //
        if (PxIsAdapterAlreadyBound(DeviceName)) {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            PXDEBUGP(PXD_WARNING, PXM_CO, ("PxCoBindAdapter: already bound to %Z\n", DeviceName));
            break;
        }

        // pAdapter gets the devicname stuck on the end -- alloc space for it
        //
        pAdapter =
            PxAllocateAdapter(DeviceName->MaximumLength);

        if(pAdapter == (PPX_ADAPTER)NULL) {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // We have memory allocated we will need to free it!
        //
        InitStage++;

        //
        // Go to the end of the string and work back until we find
        // the first "{".  Now start parsing the string converting
        // and copying from WCHAR to CHAR all digits until we hit
        // the closing "}".
        //
        {
            ULONG   i;
            for (i = DeviceName->Length/2; i > 0; i--) {
                if (DeviceName->Buffer[i] == (WCHAR)L'{') {
                    break;
                }
            }

            if (i != 0) {
                NDIS_STRING Src;
                RtlInitUnicodeString(&Src, &DeviceName->Buffer[i]);
                RtlGUIDFromString(&Src, &pAdapter->Guid);

                PXDEBUGP(PXD_INFO, PXM_CO, ("GUID %4.4x-%2.2x-%2.2x-%1.1x%1.1x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x\n",
                         pAdapter->Guid.Data1, pAdapter->Guid.Data2, pAdapter->Guid.Data3,
                         pAdapter->Guid.Data4[0],pAdapter->Guid.Data4[1],pAdapter->Guid.Data4[2],
                         pAdapter->Guid.Data4[3],pAdapter->Guid.Data4[4],pAdapter->Guid.Data4[5],
                         pAdapter->Guid.Data4[6],pAdapter->Guid.Data4[7]));
            }
        }

        PxInitBlockStruc(&pAdapter->BindEvent);

        PxInitBlockStruc(&pAdapter->OpenEvent);  //blocks thread

        PxInitBlockStruc(&pAdapter->AfRegisterEvent);
        pAdapter->AfRegisteringCount = 0;

        //
        // We can't get away with a single open for both
        // client and call manager components without changing the wrapper.
        // Bite the bullet and do two opens.
        //

        //
        // Build the medium array
        //
        {
            ULONG i;
            for (i = 0; i < NdisMediumMax; i++) {
                Media[i] = i;
            }
        }

        //
        // Open the adapter as a client!
        //

        NdisOpenAdapter(&Status,
                        &OpenError,
                        &pAdapter->ClBindingHandle,
                        &SelectedIndex,
                        Media,
                        NdisMediumMax,
                        DeviceExtension->PxProtocolHandle,
                        (NDIS_HANDLE)pAdapter,
                        DeviceName,
                        0,
                        NULL);

        if(Status == NDIS_STATUS_PENDING) {
            Status  = PxBlock(&pAdapter->OpenEvent);
        }

        if(Status != NDIS_STATUS_SUCCESS) {
            // We had some sort of error
            PXDEBUGP(PXD_ERROR, PXM_CO, ("Cl OpenAdapter Failed %x\n", Status));
            pAdapter->ClBindingHandle = NULL;
            pAdapter->MediaType = -1;
            break;
        }

        NdisAcquireSpinLock(&pAdapter->Lock);
        REF_ADAPTER(pAdapter);
        NdisReleaseSpinLock(&pAdapter->Lock);

        //
        // We have a ref on the adapter
        //
        InitStage++;

        PxInitBlockStruc(&pAdapter->OpenEvent);  //blocks thread

        //
        // Open the adapter as a call manager!
        //
        NdisOpenAdapter(&Status,
                        &OpenError,
                        &pAdapter->CmBindingHandle,
                        &SelectedIndex,
                        Media,
                        NdisMediumMax,
                        DeviceExtension->PxProtocolHandle,
                        (NDIS_HANDLE)&pAdapter->Sig,
                        DeviceName,
                        0,
                        NULL);

        if(Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&pAdapter->OpenEvent);
        }

        if(Status != NDIS_STATUS_SUCCESS) {
            // We had some sort of error
            pAdapter->CmBindingHandle = NULL;
            pAdapter->MediaType = -1;
            PXDEBUGP(PXD_ERROR, PXM_CO, ("CM OpenAdapter Failed %x\n", Status));
            break;
        }

        NdisAcquireSpinLock(&pAdapter->Lock);
        REF_ADAPTER(pAdapter);

        //
        // We have another ref on the adapter
        //
        InitStage++;

        pAdapter->State = PX_ADAPTER_OPEN;

        PXDEBUGP(PXD_INFO, PXM_CO, ("Bound to %Z, Adapter %p, NdisHandle %p\n",
                    DeviceName, pAdapter, pAdapter->ClBindingHandle));
        //
        // Set up media type in adapters
        //
        pAdapter->MediaType =
            Media[SelectedIndex];

        NdisReleaseSpinLock(&pAdapter->Lock);

        //
        // Set MediaTypeName/MediaSubtypeName for this adapter
        //
        {
            NDIS_WAN_MEDIUM_SUBTYPE SubType = 0;
            PX_REQUEST      ProxyRequest;
            PNDIS_REQUEST   Request;
            PWCHAR  MediaTypes[] = {
                L"GENERIC",
                L"X25",
                L"ISDN",
                L"SERIAL",
                L"FRAMERELAY",
                L"ATM",
                L"SONET",
                L"SW56",
                L"PPTP VPN",
                L"L2TP VPN",
                L"IRDA",
                L"PARALLEL"};

            switch (pAdapter->MediaType) {
                case NdisMediumWan:
                case NdisMediumCoWan:

                    PxInitBlockStruc (&ProxyRequest.Block);

                    Request = &ProxyRequest.NdisRequest;

                    Request->RequestType =
                        NdisRequestQueryInformation;

                    Request->DATA.QUERY_INFORMATION.Oid =
                        OID_WAN_MEDIUM_SUBTYPE;

                    Request->DATA.QUERY_INFORMATION.InformationBuffer =
                        &SubType;

                    Request->DATA.QUERY_INFORMATION.InformationBufferLength =
                        sizeof(NDIS_WAN_MEDIUM_SUBTYPE);

                    NdisRequest(&Status,
                                pAdapter->ClBindingHandle,
                                Request);

                    if (Status == NDIS_STATUS_PENDING) {
                        Status = PxBlock(&ProxyRequest.Block);
                    }

                    if (Status != NDIS_STATUS_SUCCESS) {
                        SubType = 0;
                    }

                    break;

                case NdisMediumAtm:
                    SubType = NdisWanMediumAtm;
                    break;

                default:
                    SubType = NdisWanMediumHub;
                    break;
            }

            if ((ULONG)SubType > 11) {
                SubType = 0;
            }

            pAdapter->MediumSubType = SubType;

            NdisMoveMemory((PUCHAR)(pAdapter->MediaName),
                           (PUCHAR)(MediaTypes[SubType]),
                           wcslen(MediaTypes[SubType]) * sizeof(WCHAR));

            pAdapter->MediaNameLength = 
                wcslen(MediaTypes[SubType]) * sizeof(WCHAR);

            Status = NDIS_STATUS_SUCCESS;
        }

        //
        // Stick the binding name string in the adapter. We use in subsequent
        // checks that we're not already bound.
        //
        pAdapter->DeviceName.MaximumLength = DeviceName->MaximumLength;
        pAdapter->DeviceName.Length = DeviceName->Length;
        pAdapter->DeviceName.Buffer =
            (PWCHAR)((PUCHAR)pAdapter + sizeof(PX_ADAPTER));

        NdisMoveMemory(pAdapter->DeviceName.Buffer,
                       DeviceName->Buffer,
                       DeviceName->Length);

    } while(FALSE); //end of do loop

    if (pAdapter != NULL) {
        PxSignal(&pAdapter->BindEvent, NDIS_STATUS_SUCCESS);
    }

    if (Status != NDIS_STATUS_SUCCESS) {

        //
        // Set the state to closing since we're going to get rid
        // of the adapter. 
        //
        if ((InitStage >= 1) && (InitStage <= 3)) {
            pAdapter->State = PX_ADAPTER_CLOSING;
        }
        
        switch (InitStage) {

            case 3:
                //
                // We have applied 2 additional refs on the adapter
                // we don't need to do the entire deref code for
                // the first one!  Fall through to the case below
                // to run the full deref code for the second ref.
                //
                
                pAdapter->RefCount--;

            case 2:

                //
                // We have added at least one ref that will need
                // the entire deref package applied!  Break out
                // so the deref code can free the memory.
                //
                PxInitBlockStruc(&pAdapter->ClCloseEvent);

                NdisCloseAdapter(&Status, pAdapter->ClBindingHandle);

                if (Status == NDIS_STATUS_PENDING) {
                    Status = PxBlock(&pAdapter->ClCloseEvent);
                }

                DEREF_ADAPTER(pAdapter);
                break;

            case 1:

                //
                // We have added no addition refs so we can
                // just free the memory here.
                //
                PxFreeAdapter(pAdapter);
                break;

            default:
                break;
        }
    }

    ASSERT(Status != NDIS_STATUS_PENDING);

    *pStatus = Status;
    
}

VOID
PxCoOpenAdaperComplete(
    NDIS_HANDLE BindingContext,
    NDIS_STATUS Status,
    NDIS_STATUS OpenErrorStatus
    )
/*++
Routine Description
    Our OpenAdapter completion . We signal whoever opened the
    adapter.

Arguments
    BindingContext      - A pointer to a PX_ADAPTER structure.
    Status              - Status of open attempt.
    OpenErrorStatus     - Additional status information.

Return Value:
    None

--*/
{
    PPX_ADAPTER     pAdapter;
    BOOLEAN         IsClient;

    PXDEBUGP(PXD_LOUD, PXM_CO, ("Open Adapter Complete %p %x\n", BindingContext, Status));

    AdapterFromBindContext(BindingContext, pAdapter, IsClient);

    PxSignal(&pAdapter->OpenEvent, Status);
}

VOID
PxCoUnbindAdapter(
    OUT PNDIS_STATUS    pStatus,
    IN  NDIS_HANDLE     ProtocolBindContext,
    IN  PNDIS_HANDLE    UnbindContext
    )
/*++

Routine Description:
    entry point called by NDIS when we need to destroy an existing
    adapter binding. This is called for the CM open.

    By now, al clients will have been called. So any clients that opend this AF will have cleaned up their
    connections with us, and we will have cleaned up with the Call Manager.

    We should have CL and related CL adapter structures to get rid of. The Client Bind, SAPs, VCs and Party structures
    should already have gone. If not, we throw them away anyway.

    Close and clean up the adapters.

Arguments:
    pStatus - where we return the status of this call
    ProtocolBindContext - actually a pointer to the Adapter structure
    UnbindContext - we should pass this value in NdisCompleteUnbindAdapter

Return Value:
    None; *pStatus contains the result code.

--*/
{
    PPX_ADAPTER     pAdapter;
    NDIS_STATUS     Status;
    BOOLEAN         IsClient;

    AdapterFromBindContext(ProtocolBindContext, pAdapter, IsClient);

    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxCoUnbindAdapter: pAdapter %p, UnbindContext %p\n",
                        pAdapter, UnbindContext));

    PxBlock(&pAdapter->BindEvent);

    NdisAcquireSpinLock(&pAdapter->Lock);

    pAdapter->UnbindContext = UnbindContext;
    pAdapter->State = PX_ADAPTER_CLOSING;

    //
    // Wait for any threads registering AFs to exit.
    //
    while (pAdapter->AfRegisteringCount != 0) {

        NdisReleaseSpinLock(&pAdapter->Lock);

        PxBlock(&pAdapter->AfRegisterEvent);

        NdisAcquireSpinLock(&pAdapter->Lock);
    }

    ASSERT((pAdapter->Flags & PX_CMAF_REGISTERING) == 0);

    //
    // Do we have any af's opend on the underlying call manager
    // and are there any saps registered on them?
    //
    while (!IsListEmpty(&pAdapter->ClAfList)) {
        PPX_TAPI_PROVIDER   TapiProvider;
        PPX_CL_AF   pClAf;

        pClAf = (PPX_CL_AF)RemoveHeadList(&pAdapter->ClAfList);

        InsertTailList(&pAdapter->ClAfClosingList, &pClAf->Linkage);

        NdisReleaseSpinLock(&pAdapter->Lock);

        NdisAcquireSpinLock(&pClAf->Lock);

        pClAf->State = PX_AF_CLOSING;

        TapiProvider = pClAf->TapiProvider;

        NdisReleaseSpinLock(&pClAf->Lock);

        //
        // Take all tapi devices associated with
        // this address family offline
        //
        if (TapiProvider != NULL) {
            NdisAcquireSpinLock(&TapiProvider->Lock);

            MarkProviderOffline(TapiProvider);

            NdisReleaseSpinLock(&TapiProvider->Lock);
        }

        //
        // Build list of Vc's that need attention
        //
        NdisAcquireSpinLock(&pClAf->Lock);

        while (!IsListEmpty(&pClAf->VcList)) {
            PLIST_ENTRY         Entry;
            PPX_VC              pActiveVc;

            Entry = RemoveHeadList(&pClAf->VcList);

            InsertHeadList(&pClAf->VcClosingList, Entry);

            pActiveVc = CONTAINING_RECORD(Entry, PX_VC, ClAfLinkage);

            NdisReleaseSpinLock(&pClAf->Lock);

            NdisAcquireSpinLock(&pActiveVc->Lock);

            pActiveVc->CloseFlags |= PX_VC_UNBIND;

            REF_VC(pActiveVc);

            PxVcCleanup(pActiveVc, 0);

            DEREF_VC_LOCKED(pActiveVc);

            NdisAcquireSpinLock(&pClAf->Lock);
        }

        //
        // get rid of any saps on this af
        //
        {
            PLIST_ENTRY pe;
            PPX_CL_SAP  pClSap;

            pe = pClAf->ClSapList.Flink;

            pClSap =
                CONTAINING_RECORD(pe, PX_CL_SAP, Linkage);

            while ((PVOID)pClSap != (PVOID)&pClAf->ClSapList) {

                if (InterlockedCompareExchange((PLONG)&pClSap->State,
                                               PX_SAP_CLOSING,
                                               PX_SAP_OPENED) == PX_SAP_OPENED) {

                    RemoveEntryList(&pClSap->Linkage);

                    InsertTailList(&pClAf->ClSapClosingList, &pClSap->Linkage);

                    NdisReleaseSpinLock(&pClAf->Lock);

                    ClearSapWithTapiLine(pClSap);

                    Status = NdisClDeregisterSap(pClSap->NdisSapHandle);

                    if (Status != NDIS_STATUS_PENDING) {
                        PxClDeregisterSapComplete(Status, pClSap);
                    }

                    NdisAcquireSpinLock(&pClAf->Lock);

                    pe = pClAf->ClSapList.Flink;

                    pClSap =
                        CONTAINING_RECORD(pe, PX_CL_SAP, Linkage);
                } else {
                    pe = pClSap->Linkage.Flink;

                    pClSap =
                        CONTAINING_RECORD(pe, PX_CL_SAP, Linkage);
                }
            }
        }

        //
        // deref for the ref applied when we opened this af
        // and put it on the adapter's list
        //
        DEREF_CL_AF_LOCKED(pClAf);

        NdisAcquireSpinLock(&pAdapter->Lock);
    }

    //
    // Do any clients have our AF open?
    //
    while (!IsListEmpty(&pAdapter->CmAfList)) {

        PPX_CM_AF   pCmAf;
        PX_REQUEST  ProxyRequest;
        PPX_REQUEST pProxyRequest = &ProxyRequest;
        ULONG       Info = 0;
        PNDIS_REQUEST   Request;

        pCmAf = (PPX_CM_AF)RemoveHeadList(&pAdapter->CmAfList);

        InsertTailList(&pAdapter->CmAfClosingList, &pCmAf->Linkage);

        NdisReleaseSpinLock(&pAdapter->Lock);

        NdisAcquireSpinLock(&pCmAf->Lock);

        pCmAf->State = PX_AF_CLOSING;

        REF_CM_AF(pCmAf);

        NdisReleaseSpinLock(&pCmAf->Lock);

        NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

        Request = &pProxyRequest->NdisRequest;

        Request->RequestType =
            NdisRequestSetInformation;
        Request->DATA.QUERY_INFORMATION.Oid =
            OID_CO_AF_CLOSE;
        Request->DATA.QUERY_INFORMATION.InformationBuffer =
            &Info;
        Request->DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(ULONG);

        PxInitBlockStruc(&pProxyRequest->Block);

        Status = NdisCoRequest(pAdapter->CmBindingHandle,
                               pCmAf->NdisAfHandle,
                               NULL,
                               NULL,
                               Request);

        if (Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&pProxyRequest->Block);
        }

        DEREF_CM_AF(pCmAf);

        NdisAcquireSpinLock(&pAdapter->Lock);
    }

    NdisReleaseSpinLock(&pAdapter->Lock);

    if (IsClient) {

        PxInitBlockStruc(&pAdapter->ClCloseEvent);

        NdisCloseAdapter(&Status, pAdapter->ClBindingHandle);

        if (Status == NDIS_STATUS_PENDING) {
            PxBlock(&pAdapter->ClCloseEvent);
        }

        PXDEBUGP(PXD_LOUD, PXM_CO, ("PxCoUnbindAdapter: CloseAdapter-Cl(%p)\n",
                    pAdapter));

    } else {

        PxInitBlockStruc(&pAdapter->CmCloseEvent);

        NdisCloseAdapter(&Status, pAdapter->CmBindingHandle);

        if (Status == NDIS_STATUS_PENDING) {
            PxBlock(&pAdapter->CmCloseEvent);
        }

        PXDEBUGP(PXD_LOUD, PXM_CO, ("PxCoUnbindAdapter: CloseAdapter-Cm(%p)\n",
                    pAdapter));

    }

    DEREF_ADAPTER(pAdapter);

    *pStatus = NDIS_STATUS_SUCCESS;
}

VOID
PxCoCloseAdaperComplete(
    NDIS_HANDLE BindingContext,
    NDIS_STATUS Status
    )
/*++
Routine Description

    Our CloseAdapter completion handler. We signal whoever closed the
    adapter.

Arguments
    BindingContext      - A pointer to a PX_ADAPTER structure.
    Status              - Status of close attempt.

Return Value:
    None
--*/
{
    PPX_ADAPTER     pAdapter;
    BOOLEAN         IsClient;

    AdapterFromBindContext(BindingContext, pAdapter, IsClient);

    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxCoCloseAdapterComp: Adapter %p\n", pAdapter));

    if (IsClient) {
        PxSignal(&pAdapter->ClCloseEvent, Status);
    } else {
        PxSignal(&pAdapter->CmCloseEvent, Status);
    }
}

VOID
PxCoRequestComplete(
    IN NDIS_HANDLE BindingContext,
    IN PNDIS_REQUEST NdisRequest,
    IN NDIS_STATUS Status
    )
{
    PPX_ADAPTER     pAdapter;
    PPX_REQUEST     pProxyRequest;
    BOOLEAN         IsClient;

    AdapterFromBindContext(BindingContext, pAdapter, IsClient);

    PXDEBUGP(PXD_INFO, PXM_CO, ("PxCoRequestComplete: Adapter %p\n", pAdapter));

    pProxyRequest = CONTAINING_RECORD(NdisRequest, PX_REQUEST, NdisRequest);

    PxSignal(&pProxyRequest->Block, Status);
}


VOID
PxCoNotifyAfRegistration(
     IN  NDIS_HANDLE        BindingContext,
     IN  PCO_ADDRESS_FAMILY pFamily
     )
/*++

Routine Description:

    We get called here each time a call manager registers an address family.

    This is where we open the address family, and register a proxy version if we
    fancy it.

Arguments:

    PxBindingContext       - our pointer to an adapter
    pFamily                 - The AF that's been registered

Return Value:
    None

--*/
{
    PPX_ADAPTER     pAdapter;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PPX_CL_AF       pClAf;
    BOOLEAN         IsClient;
    BOOLEAN         CmAfRegistered;
    BOOLEAN         Found;
    BOOLEAN         RegisterInProgress = FALSE;


    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxNotifyAfRegistration\n"));

    //
    // First, check we're not being called because we registered ourselves...
    //
    if(pFamily->AddressFamily == CO_ADDRESS_FAMILY_TAPI) {
        PXDEBUGP(PXD_LOUD, PXM_CO, ("PxNotifyAfRegistration: AF_TAPI registration -- do nothing\n"));
        return;
    }

    //
    // Get the adapter
    //
    AdapterFromBindContext(BindingContext, pAdapter, IsClient);

    if (!IsClient) {
       PXDEBUGP(PXD_LOUD, PXM_CO, ("PxNotifyAfRegistration: Called for CM adapter -- do nothing\n"));
       return;
    }

    //
    // We need to keep the adapter around so place a ref on it!
    //
    NdisAcquireSpinLock(&pAdapter->Lock);
    REF_ADAPTER(pAdapter);
    NdisReleaseSpinLock(&pAdapter->Lock);

    //
    // Wait until we are finished with the binding!
    //
    PxBlock(&pAdapter->BindEvent);

    NdisAcquireSpinLock(&pAdapter->Lock);

    do {

        if ((pAdapter->State == PX_ADAPTER_CLOSING ||
            pAdapter->State == PX_ADAPTER_CLOSED)) {
            PXDEBUGP(PXD_FATAL, PXM_CO, ("PxNotifyAfRegistration: Adapter: %p state: %x is invalid\n",
                pAdapter, pAdapter->State));

            break;
        }

        //
        // See if this adapter already has this type of af registered
        //
        Found = FALSE;

        pClAf = (PPX_CL_AF)pAdapter->ClAfList.Flink;

        while ((PVOID)pClAf != (PVOID)&pAdapter->ClAfList) {
            if (pClAf->Af.AddressFamily == pFamily->AddressFamily) {
                Found = TRUE;
                break;
            }

            pClAf = (PPX_CL_AF)pClAf->Linkage.Flink;
        }

        if (Found) {

            PXDEBUGP(PXD_FATAL, PXM_CO, ("PxNotifyAfRegistration: Af already registered Adapter: %p, Af: %x\n",
                pAdapter, pClAf->Af));

            break;
        }

        pClAf =
            PxAllocateClAf(pFamily, pAdapter);

        if(pClAf == NULL) {

            Status = NDIS_STATUS_RESOURCES;
            PXDEBUGP(PXD_WARNING, PXM_CO, ("NotifyAfRegistration: failed to allocate a PX_CL_AF\n"));
            break;
        }

        //
        // Make sure that we don't let an Unbind thread invalidate our Binding
        // handle.
        //
        if (pAdapter->AfRegisteringCount == 0) {
            PxInitBlockStruc(&pAdapter->AfRegisterEvent);
        }
        pAdapter->AfRegisteringCount++;

        RegisterInProgress = TRUE;

        NdisReleaseSpinLock(&pAdapter->Lock);

        //
        // Open the address family
        //
        {
            NDIS_CLIENT_CHARACTERISTICS     ClChars;
            PNDIS_CLIENT_CHARACTERISTICS    pClChars = &ClChars;

            //
            // Do the client open on the address family
            //
            NdisZeroMemory (pClChars, sizeof(NDIS_CLIENT_CHARACTERISTICS));

            pClChars->MajorVersion = NDIS_MAJOR_VERSION;
            pClChars->MinorVersion = NDIS_MINOR_VERSION;
            pClChars->Reserved = 0;

            pClChars->ClCreateVcHandler = PxClCreateVc;
            pClChars->ClDeleteVcHandler = PxClDeleteVc;
            pClChars->ClOpenAfCompleteHandler = PxClOpenAfComplete;
            pClChars->ClCloseAfCompleteHandler = PxClCloseAfComplete;
            pClChars->ClRegisterSapCompleteHandler = PxClRegisterSapComplete;
            pClChars->ClDeregisterSapCompleteHandler = PxClDeregisterSapComplete;
            pClChars->ClMakeCallCompleteHandler = PxClMakeCallComplete;
            pClChars->ClModifyCallQoSCompleteHandler = PxClModifyCallQosComplete;
            pClChars->ClCloseCallCompleteHandler = PxClCloseCallComplete;
            pClChars->ClAddPartyCompleteHandler = PxClAddPartyComplete;
            pClChars->ClDropPartyCompleteHandler = PxClDropPartyComplete;
            pClChars->ClIncomingCallHandler = PxClIncomingCall;
            pClChars->ClIncomingCallQoSChangeHandler = PxClIncomingCallQosChange;
            pClChars->ClIncomingCloseCallHandler = PxClIncomingCloseCall;
            pClChars->ClIncomingDropPartyHandler = PxClIncomingDropParty;
            pClChars->ClCallConnectedHandler = PxClCallConnected;
            pClChars->ClRequestHandler = PxClRequest;
            pClChars->ClRequestCompleteHandler = PxClRequestComplete;

            PxInitBlockStruc(&pClAf->Block);

            Status = NdisClOpenAddressFamily(pAdapter->ClBindingHandle,
                                             pFamily,
                                             (NDIS_HANDLE)pClAf,
                                             pClChars,
                                             sizeof(NDIS_CLIENT_CHARACTERISTICS),
                                             &pClAf->NdisAfHandle);

            if(Status == NDIS_STATUS_PENDING) {
                Status = PxBlock(&pClAf->Block);
            }
        }

        NdisAcquireSpinLock(&pAdapter->Lock);

        if (Status != NDIS_STATUS_SUCCESS) {

            PXDEBUGP(PXD_WARNING, PXM_CO, ("NotifyAfRegistration: Error opening Af %x, Adapter %p, Error %x!!!\n",
                pFamily->AddressFamily, pAdapter, Status));

            PxFreeClAf(pClAf);
            break;
        }

        NdisAcquireSpinLock(&pClAf->Lock);

        pClAf->State = PX_AF_OPENED;

        NdisReleaseSpinLock(&pClAf->Lock);

        //
        // Have only need to register one instance of CO_ADDRESS_FAMILY_TAPI
        // for each adapter.
        //

        InsertTailList(&pAdapter->ClAfList, &pClAf->Linkage);

        if (pAdapter->Flags & PX_CMAF_REGISTERED) {
            CmAfRegistered = TRUE;
        } else {
            CmAfRegistered = FALSE;
            pAdapter->Flags |= PX_CMAF_REGISTERING;
        }

        REF_ADAPTER(pAdapter);

        NdisReleaseSpinLock(&pAdapter->Lock);

        if (!CmAfRegistered) {
            CO_ADDRESS_FAMILY   PxFamily;
            NDIS_CALL_MANAGER_CHARACTERISTICS CmChars;
            PNDIS_CALL_MANAGER_CHARACTERISTICS pCmChars = &CmChars;

            //
            // Now register the Proxied address family. First, get the CM adapter handle.
            //
            NdisZeroMemory(pCmChars, sizeof(CmChars));

            pCmChars->MajorVersion = NDIS_MAJOR_VERSION;
            pCmChars->MinorVersion = NDIS_MINOR_VERSION;
            pCmChars->Reserved = 0;

            pCmChars->CmCreateVcHandler = PxCmCreateVc;
            pCmChars->CmDeleteVcHandler = PxCmDeleteVc;
            pCmChars->CmOpenAfHandler = PxCmOpenAf;
            pCmChars->CmCloseAfHandler = PxCmCloseAf;
            pCmChars->CmRegisterSapHandler = PxCmRegisterSap;
            pCmChars->CmDeregisterSapHandler = PxCmDeRegisterSap;
            pCmChars->CmMakeCallHandler = PxCmMakeCall;
            pCmChars->CmCloseCallHandler = PxCmCloseCall;
            pCmChars->CmIncomingCallCompleteHandler = PxCmIncomingCallComplete;
            pCmChars->CmAddPartyHandler = PxCmAddParty;
            pCmChars->CmDropPartyHandler = PxCmDropParty;
            pCmChars->CmActivateVcCompleteHandler = PxCmActivateVcComplete;
            pCmChars->CmDeactivateVcCompleteHandler = PxCmDeActivateVcComplete;
            pCmChars->CmModifyCallQoSHandler = PxCmModifyCallQos;
            pCmChars->CmRequestHandler = PxCmRequest;
            pCmChars->CmRequestCompleteHandler = PxCmRequestComplete;

            NdisMoveMemory(&PxFamily, pFamily, sizeof(PxFamily));

            PxFamily.AddressFamily = CO_ADDRESS_FAMILY_TAPI;

            PXDEBUGP(PXD_LOUD, PXM_CO, ("NotifyAfRegistration: NdisCmRegisterAddressFamily\n"));

            Status =
                NdisCmRegisterAddressFamily(pAdapter->CmBindingHandle,
                                            &PxFamily,
                                            pCmChars,
                                            sizeof(CmChars));

            NdisAcquireSpinLock(&pAdapter->Lock);

            pAdapter->Flags &= ~PX_CMAF_REGISTERING;

            if(Status != NDIS_STATUS_SUCCESS) {

                //
                // Close the CM af again
                //
                PXDEBUGP(PXD_FATAL, PXM_CO, ("NotifyAfRegistration: NdisCmRegisterAddressFamily on Bind %p bad sts = %x\n", pAdapter->CmBindingHandle, Status));

                RemoveEntryList(&pClAf->Linkage);

                InsertTailList(&pAdapter->ClAfClosingList, &pClAf->Linkage);

                NdisReleaseSpinLock(&pAdapter->Lock);

                NdisAcquireSpinLock(&pClAf->Lock);

                pClAf->State = PX_AF_CLOSING;

                NdisReleaseSpinLock(&pClAf->Lock);

                Status = NdisClCloseAddressFamily (pClAf->NdisAfHandle);

                if (Status != NDIS_STATUS_PENDING) {

                    PxClCloseAfComplete(Status, pClAf);
                }

                NdisAcquireSpinLock(&pAdapter->Lock);

                break;

            } else {

                pAdapter->Flags |= PX_CMAF_REGISTERED;

                NdisReleaseSpinLock(&pAdapter->Lock);
            }
        }

        NdisAcquireSpinLock(&pClAf->Lock);
        REF_CL_AF(pClAf);
        NdisReleaseSpinLock(&pClAf->Lock);

        Status =
            AllocateTapiResources(pAdapter, pClAf);

        DEREF_CL_AF(pClAf);

        NdisAcquireSpinLock(&pAdapter->Lock);


    } while (FALSE);

    if (RegisterInProgress) {

        pAdapter->AfRegisteringCount--;

        if (pAdapter->AfRegisteringCount == 0) {
            PxSignal(&pAdapter->AfRegisterEvent, NDIS_STATUS_SUCCESS);
        }
    }

    DEREF_ADAPTER_LOCKED(pAdapter);
}

VOID
PxCoUnloadProtocol(
    VOID
    )
/*++

Routine Description:
    Unload the entire protocol (CM and CL).

Arguments:
    None

Return Value:
    None

--*/
{
    NDIS_STATUS         Status;

    NdisDeregisterProtocol(&Status, DeviceExtension->PxProtocolHandle);

#if DBG
    NdisAcquireSpinLock(&(DeviceExtension->Lock));

    ASSERT(IsListEmpty(&DeviceExtension->AdapterList));

    NdisReleaseSpinLock(&DeviceExtension->Lock);
#endif
}

NDIS_STATUS
PxCoPnPEvent(
    IN  NDIS_HANDLE     BindingContext,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    NDIS_STATUS     Status;
    PPX_ADAPTER     pAdapter=NULL;
    BOOLEAN         IsClient;

    if (BindingContext != NULL) {
        AdapterFromBindContext(BindingContext, pAdapter, IsClient);
    }

    switch (pNetPnPEvent->NetEvent){
        case NetEventSetPower:
            Status = PxPnPSetPower(pAdapter, pNetPnPEvent);
            break;

        case NetEventQueryPower:
            Status = PxPnPQueryPower(pAdapter, pNetPnPEvent);
            break;

        case NetEventQueryRemoveDevice:
            Status = PxPnPQueryRemove(pAdapter, pNetPnPEvent);
            break;

        case NetEventCancelRemoveDevice:
            Status = PxPnPCancelRemove(pAdapter, pNetPnPEvent);
            break;

        case NetEventReconfigure:
            Status = PxPnPReconfigure(pAdapter, pNetPnPEvent);
            break;

        case NetEventBindList:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;

        default:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }

    PXDEBUGP(PXD_INFO, PXM_CO, ("PnPEvent(CM): Event %d, returning %x\n",
                pNetPnPEvent->NetEvent, Status));

    return (Status);
}

NDIS_STATUS
PxPnPSetPower(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    PNET_DEVICE_POWER_STATE     pPowerState;
    NDIS_STATUS                 Status;

    pPowerState = (PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;

    switch (*pPowerState) {
        case NetDeviceStateD0:
            Status = NDIS_STATUS_SUCCESS;
            break;

        default:
            //
            //  We can't suspend, so we ask NDIS to unbind us
            //  by returning this status:
            //
            Status = NDIS_STATUS_NOT_SUPPORTED;
        break;
    }

    return (Status);
}


NDIS_STATUS
PxPnPQueryPower(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxPnPQueryRemove(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxPnPCancelRemove(
    IN  PPX_ADAPTER     pAdapter,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxPnPReconfigure(
    IN  PPX_ADAPTER     pAdapter        OPTIONAL,
    IN  PNET_PNP_EVENT  pNetPnPEvent
    )
{
    return (NDIS_STATUS_NOT_SUPPORTED);
}

VOID
PxCoSendComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
    )
{
    PXDEBUGP(PXD_INFO, PXM_CO, ("PxCoSendComplete\n"));
}



VOID
PxCoTransferDataComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status,
    IN UINT BytesTransferred
    )
{
    PXDEBUGP(PXD_INFO, PXM_CO, ("PxCoTransferDataComplete\n"));
}


VOID
PxCoResetComplete(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_STATUS Status
    )
{
    PXDEBUGP(PXD_INFO, PXM_CO, ("PxCoResetComplete\n"));
}

VOID
PxCoStatusComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    )
{
    PXDEBUGP(PXD_INFO, PXM_CO, ("PxCoStatusComplete\n"));
}

VOID
PxCoReceiveComplete(
    IN NDIS_HANDLE ProtocolBindingContext
    )
{
    PXDEBUGP(PXD_INFO, PXM_CO, ("PxCoReceiveComplete\n"));
}

VOID
PxCoStatus(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_HANDLE  ProtocolVcContext   OPTIONAL,
    IN NDIS_STATUS  GeneralStatus,
    IN PVOID        StatusBuffer,
    IN UINT         StatusBufferSize
    )
{
    PPX_VC  pVc = NULL;

    PXDEBUGP(PXD_INFO, PXM_CO, 
             ("PxCoStatus : %p, Status %x\n", 
              ProtocolBindingContext,GeneralStatus));

    GetVcFromCtx(ProtocolVcContext, &pVc);

    if (pVc == NULL) {
        return;
    }

    switch (GeneralStatus) {
        case NDIS_STATUS_TAPI_RECV_DIGIT:

            PxHandleReceivedDigit(pVc,
                                  StatusBuffer,
                                  StatusBufferSize);
            break;

        case NDIS_STATUS_WAN_CO_LINKPARAMS:

            PxHandleWanLinkParams(pVc,
                                  StatusBuffer,
                                  StatusBufferSize);
            break;

        default:
            break;
    }

    DEREF_VC(pVc);
}

UINT
PxCoReceivePacket(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PNDIS_PACKET pNdisPacket
    )
{
    PXDEBUGP(PXD_INFO, PXM_CO, ("CoReceivePacket\n"));
    NDIS_SET_PACKET_STATUS(pNdisPacket, NDIS_STATUS_SUCCESS);
    return 0;
}


ULONG
PxGetMillisecondTickCount()
{
    LARGE_INTEGER               TickCount, Milliseconds;
    ULONG                       TimeIncrement;
    
    //
    // Return the current "tick count" (number of milliseconds since Windows started).
    // TAPI wants this in its DTMF notification messages. We have to do a little math here because
    // the kernel query tick count function returns the number of timer ticks, which is some
    // multiple of 100ns.
    //

    KeQueryTickCount(&TickCount);
    TimeIncrement = KeQueryTimeIncrement();

    Milliseconds.QuadPart = (TickCount.QuadPart / 10000) * TimeIncrement;

    //
    // This might seem a bit sketchy but TAPI only gives us a 32-bit wide place to store the tick
    // count. According to the SDK, TAPI apps are supposed to be aware that this will roll over every
    // 49.7 days. (...it's amusing to think of TAPI staying up for 49.7 days, but I digress...)
    //

    return (Milliseconds.LowPart);

}


// PxTerminateDigitDetection
//
// Must be called with the VC lock held.

VOID 
PxTerminateDigitDetection(
                          IN    PPX_VC              pVc,
                          IN    PNDISTAPI_REQUEST   pNdisTapiRequest,
                          IN    ULONG               ulReason
                          )
{
    PNDIS_TAPI_GATHER_DIGITS    pNdisTapiGatherDigits;
    PIRP                        Irp;
    PWCHAR                      pDigitsBuffer; 
    NDIS_STATUS                 Status;


    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxTerminateDigitDetection: Enter\n"));
    
    pNdisTapiGatherDigits = 
            (PNDIS_TAPI_GATHER_DIGITS)pNdisTapiRequest->Data;   

    Irp = pNdisTapiRequest->Irp;
        
    pNdisTapiGatherDigits->ulTickCount = PxGetMillisecondTickCount();           

    pNdisTapiGatherDigits->ulTerminationReason = ulReason;

    //
    // Put the null character at the end of the buffer, and send it on it's way.
    //
    pDigitsBuffer = 
        (PWCHAR) (((PUCHAR)pNdisTapiGatherDigits) + pNdisTapiGatherDigits->ulDigitsBufferOffset);
        
    pDigitsBuffer[pNdisTapiGatherDigits->ulNumDigitsRead] = 
        UNICODE_NULL;

    Irp->IoStatus.Status = NDIS_STATUS_SUCCESS;
    Irp->IoStatus.Information = 
        sizeof(NDISTAPI_REQUEST) + (pNdisTapiRequest->ulDataSize - 1);                             

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // Note: we call release here even though we didn't acquire in this function.
    //       This is OK since this function MUST be called with the lock held.
    //
    NdisReleaseSpinLock(&pVc->Lock);

    Status = PxStopDigitReporting(pVc);

    NdisAcquireSpinLock(&pVc->Lock); // See comment above.

    // FIXME: If this failed (i.e. Status is some error value, 
    //        there's not much we can do about it here).

    if (Status != NDIS_STATUS_SUCCESS) {
        PXDEBUGP(PXD_ERROR, PXM_CO, 
                 ("PxTerminateDigitDetection: PxStopDigitReporting returned Status 0x%x\n",
                  Status));
        ASSERT(FALSE);
    }

    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxTerminateDigitDetection: Exit\n"));
}



VOID 
PxDigitTimerRoutine(
                    IN PVOID SystemSpecific1,
                    IN PVOID FunctionContext,
                    IN PVOID SystemSpecific2,
                    IN PVOID SystemSpecific3
                    )
{
    PPX_VC                      pVc = (PPX_VC) FunctionContext;
    PNDISTAPI_REQUEST           pNdisTapiRequest;
    PIRP                        Irp;
    PNDIS_TAPI_GATHER_DIGITS    pNdisTapiGatherDigits;  
    ULONG ulReason;

    NdisAcquireSpinLock(&pVc->Lock);

    do {
        if (pVc->PendingGatherDigits == NULL) {
            //
            // The request either completed, or a digit is being processed right now, so this timeout is
            // meaningless.
            //      
            
            break;
        }

        pNdisTapiRequest = pVc->PendingGatherDigits;
        Irp = pNdisTapiRequest->Irp;

        if (!IoSetCancelRoutine(Irp, NULL))
        {
            //
            // The cancel routine is running. Let it handle the IRP.
            //
            break;
        }

        pVc->PendingGatherDigits = NULL;
        ASSERT(pNdisTapiRequest == Irp->AssociatedIrp.SystemBuffer);

        pNdisTapiGatherDigits = 
            (PNDIS_TAPI_GATHER_DIGITS)pNdisTapiRequest->Data;

        if (pNdisTapiGatherDigits->ulNumDigitsRead == 0) {
            //
            // We timed out before detecting the first digit.
            //
            ulReason = LINEGATHERTERM_FIRSTTIMEOUT;
        } else {
            ulReason = LINEGATHERTERM_INTERTIMEOUT;
        }

        PxTerminateDigitDetection(pVc, pNdisTapiRequest, ulReason);

    } while (FALSE);
    
    NdisReleaseSpinLock(&pVc->Lock);

    DEREF_VC(pVc);

}


// ++ DTMFDigitToOrdinal
//
// Turn a DTMF digit into a number between 0 and 15. The digits are assigned
// numbers in the following order: '0' - '9', 'A' - 'D', '*', '#'.
//
// This is horribly ugly now, but we'll optimize later.
//
// Arguments:
// wcDigit  - The digit, expressed as a UNICODE character.
//
// Return value:
// A number between 0 and 15, or 16 if the digit passed in was not a valid 
// DTMF digit. 
// 
ULONG
DTMFDigitToOrdinal(
                   WCHAR    wcDigit
                   )
{
    ULONG ulOrdinal;

    switch (wcDigit) {
    case L'0':
        ulOrdinal = 0;      
        break;
    case L'1':
        ulOrdinal = 1;      
        break;
    case L'2':
        ulOrdinal = 2;      
        break;
    case L'3':
        ulOrdinal = 3;      
        break;
    case L'4':
        ulOrdinal = 4;      
        break;
    case L'5':
        ulOrdinal = 5;      
        break;
    case L'6':
        ulOrdinal = 6;      
        break;
    case L'7':
        ulOrdinal = 7;      
        break;
    case L'8':
        ulOrdinal = 8;      
        break;
    case L'9':
        ulOrdinal = 9;      
        break;
    case L'A':
        ulOrdinal = 10;     
        break;
    case L'B':
        ulOrdinal = 11;     
        break;
    case L'C':
        ulOrdinal = 12;     
        break;
    case L'D':
        ulOrdinal = 13;     
        break;
    case L'*':
        ulOrdinal = 14;     
        break;
    case L'#':
        ulOrdinal = 15;     
        break;
    default:
        ulOrdinal = 16;     
        break;

    };

    return ulOrdinal;
}


NDIS_STATUS
PxStopDigitReporting(
                     PPX_VC pVc
                     )
{
    PX_REQUEST      ProxyRequest;
    PNDIS_REQUEST   NdisRequest;    
    ULONG           Unused = 0;
    NDIS_STATUS     Status;

    //        
    // Fill out our request structure to tell the miniport to stop reporting
    // digits.
    //
    NdisZeroMemory(&ProxyRequest, sizeof(ProxyRequest));

    PxInitBlockStruc(&ProxyRequest.Block);

    NdisRequest = &ProxyRequest.NdisRequest;

    NdisRequest->RequestType = NdisRequestSetInformation;

    NdisRequest->DATA.SET_INFORMATION.Oid = OID_CO_TAPI_DONT_REPORT_DIGITS;

    NdisRequest->DATA.SET_INFORMATION.InformationBuffer = (PVOID)&Unused;

    NdisRequest->DATA.SET_INFORMATION.InformationBufferLength = sizeof(Unused);

    Status = NdisCoRequest(pVc->Adapter->ClBindingHandle, 
                           pVc->ClAf->NdisAfHandle,
                           pVc->ClVcHandle,
                           NULL,
                           NdisRequest);

    if (Status == NDIS_STATUS_PENDING) {
        Status = PxBlock(&ProxyRequest.Block);
    }

    return Status;  
}



VOID 
PxHandleReceivedDigit(
    IN    PPX_VC  pVc,
    IN    PVOID   Buffer,
    IN    UINT    BufferSize
    )
{
    PNDIS_TAPI_GATHER_DIGITS    pNdisTapiGatherDigits;
    PWCHAR                      pDigitsBuffer; 
    
    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxHandleReceiveDigit: Enter\n"));

    do {
        PLIST_ENTRY             Entry;
        PIRP                    Irp;
        PNDISTAPI_REQUEST       pNdisTapiRequest;
        ULONG                   ulDigitOrdinal;         
        BOOLEAN                 bTimerCancelled = FALSE;

        //
        // We need at least one WCHAR in the buffer.
        //
        if (BufferSize < sizeof(WCHAR)) {
            //
            // No useful data, get out
            //
            break;
        }

        NdisAcquireSpinLock(&pVc->Lock);

        if (pVc->ulMonitorDigitsModes != 0) {
            NDIS_TAPI_EVENT Event;
            PPX_TAPI_LINE   pTapiLine;

            //
            // We're monitoring (not gathering) digits, so send up a message right away. 
            //

            pTapiLine = pVc->TapiLine;
            Event.htLine = pTapiLine->htLine;
            Event.htCall = pVc->htCall;
            Event.ulMsg = LINE_MONITORDIGITS;
            Event.ulParam1 = (ULONG_PTR) (* ((PWCHAR)Buffer));
            Event.ulParam2 = (ULONG_PTR) (pVc->ulMonitorDigitsModes); // ToDo - There could be > 1 mode here - have to get this from the driver.
            Event.ulParam3 = (ULONG_PTR) (PxGetMillisecondTickCount());
            
            NdisReleaseSpinLock(&pVc->Lock);
            
            PxIndicateStatus((PVOID) &Event, sizeof(NDIS_TAPI_EVENT));
            
            break;

        }
        
        if (pVc->PendingGatherDigits == NULL) {
            //
            // No Irp to complete, get out
            //
            NdisReleaseSpinLock(&pVc->Lock);
            break;
        }

        NdisCancelTimer(&pVc->DigitTimer, &bTimerCancelled); // deref of VC is at the end - makes locking code a bit cleaner.       

        pNdisTapiRequest = pVc->PendingGatherDigits;

        Irp = pNdisTapiRequest->Irp;

        if (!IoSetCancelRoutine(Irp, NULL))
        {
            //
            // The cancel routine is running. Let it handle the IRP.
            //
            NdisReleaseSpinLock(&pVc->Lock);
            break;
        }

        pVc->PendingGatherDigits = NULL;
        ASSERT(pNdisTapiRequest == Irp->AssociatedIrp.SystemBuffer);

        pNdisTapiGatherDigits = 
            (PNDIS_TAPI_GATHER_DIGITS)pNdisTapiRequest->Data;

        //
        // Store the current digit, and increment the count. 
        //
        pDigitsBuffer = 
            (PWCHAR) (((PUCHAR)pNdisTapiGatherDigits) + pNdisTapiGatherDigits->ulDigitsBufferOffset);

        pDigitsBuffer[pNdisTapiGatherDigits->ulNumDigitsRead] = 
            *((PWCHAR)Buffer);

        pNdisTapiGatherDigits->ulNumDigitsRead++;
        
        // 
        // Check if we read a termination digit.
        //

        ulDigitOrdinal = DTMFDigitToOrdinal(*((PWCHAR)Buffer));

        if (Irp->Cancel) {

            PxTerminateDigitDetection(pVc, pNdisTapiRequest, LINEGATHERTERM_CANCEL);

        } else if (pNdisTapiGatherDigits->ulTerminationDigitsMask & (1 << ulDigitOrdinal)) {
            
            PxTerminateDigitDetection(pVc, pNdisTapiRequest, LINEGATHERTERM_TERMDIGIT);
        
        } else if (pNdisTapiGatherDigits->ulNumDigitsRead == pNdisTapiGatherDigits->ulNumDigitsNeeded) {
            
            PxTerminateDigitDetection(pVc, pNdisTapiRequest, LINEGATHERTERM_BUFFERFULL);
        
        } else {
            pVc->PendingGatherDigits = pNdisTapiRequest;
            
            if (pNdisTapiGatherDigits->ulInterDigitTimeout) {
                REF_VC(pVc);
                NdisSetTimer(&pVc->DigitTimer, pNdisTapiGatherDigits->ulInterDigitTimeout);
            }

            IoSetCancelRoutine(Irp, PxCancelSetQuery);
        }

        NdisReleaseSpinLock(&pVc->Lock);

        if (bTimerCancelled) {
            //
            // Do this only if the timer was actually cancelled. If it wasn't, then
            // either it wasn't set and the VC wouldn't have been ref'd in the first
            // place, or it fired, in which case the timer routine would have deref'd
            // it already.
            //
            DEREF_VC(pVc);
        }

    } while (FALSE);
    
    PXDEBUGP(PXD_LOUD, PXM_CO, ("PxHandleReceiveDigit: Exit\n"));
}

VOID 
PxHandleWanLinkParams(
    IN    PPX_VC  pVc,
    IN    PVOID   Buffer,
    IN    UINT    BufferSize
    )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\pxcm.c ===
/*++                    

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    pxcm.c

Abstract:

    This module contains the Call Manager (CM_) entry points listed
    in the protocol characteristics table. These entry points are called
    by the NDIS wrapper on behalf of requests made by a client.

Author:

   Richard Machin (RMachin)

Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    RMachin     10-03-96        created
    tonybe      01-23-99        rewrite and cleanup

Notes:


--*/

#include "precomp.h"
#define MODULE_NUMBER MODULE_CM
#define _FILENUMBER   'MCXP'

NDIS_STATUS
PxCmCreateVc(
    IN  NDIS_HANDLE         ProtocolAfContext,
    IN  NDIS_HANDLE         NdisVcHandle,
    OUT PNDIS_HANDLE        pProtocolVcContext
    )
/*++

Routine Description:
    We do not allow a client of the proxy to create a Vc ever!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    PXDEBUGP(PXD_FATAL, PXM_CM, 
             ("PxCmCreateVc: Should never be called!\n"));

    ASSERT(0);

    return(NDIS_STATUS_FAILURE);
}


NDIS_STATUS
PxCmDeleteVc(
    IN  NDIS_HANDLE         ProtocolVcContext
    )
/*++

Routine Description:
    We do not allow a client to delete a vc!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    PXDEBUGP(PXD_FATAL, PXM_CM, 
             ("PxCmDeleteVc: Should never be called!\n"));

    ASSERT(0);

    return(NDIS_STATUS_FAILURE);
}

NDIS_STATUS
PxCmOpenAf(
    IN  NDIS_HANDLE         BindingContext,
    IN  PCO_ADDRESS_FAMILY  AddressFamily,
    IN  NDIS_HANDLE         NdisAfHandle,
    OUT PNDIS_HANDLE        CallMgrAfContext
    )
/*++

Routine Description:
    This routine creats an Af context for the client that is opening
    our address family.  The Af context is threaded up on the adapter
    block.

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{

    PPX_CM_AF   pCmAf;
    PPX_ADAPTER pAdapter;

    PXDEBUGP(PXD_LOUD, PXM_CM, ("PxCmOpenAf: AF: %x\n",AddressFamily->AddressFamily));

    //
    // Make sure the address family being opened is ours
    //
    if(AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_TAPI) {

        PXDEBUGP(PXD_ERROR, PXM_CM,
                 ("PxCmOpenAf: not Proxy address family: %x\n",
                  AddressFamily->AddressFamily));

        return(NDIS_STATUS_BAD_VERSION);
    }

    AdapterFromCmBindContext(BindingContext, pAdapter);

    NdisAcquireSpinLock(&pAdapter->Lock);

    if (pAdapter->State != PX_ADAPTER_OPEN) {
        NdisReleaseSpinLock(&pAdapter->Lock);
        return (NDIS_STATUS_CLOSING);
    }

    NdisReleaseSpinLock(&pAdapter->Lock);

    pCmAf =
        PxAllocateCmAf(AddressFamily);

    if (pCmAf == NULL) {
        PXDEBUGP(PXD_ERROR, PXM_CM, ("PXCmOpenAf: AfBlock memory allocation failed!\n"));
        return (NDIS_STATUS_RESOURCES);
    }

    pCmAf->NdisAfHandle = NdisAfHandle;

    pCmAf->State = PX_AF_OPENED;
    pCmAf->Adapter = pAdapter;

    NdisAcquireSpinLock(&pAdapter->Lock);

    InsertTailList(&pAdapter->CmAfList, &pCmAf->Linkage);

    REF_ADAPTER(pAdapter);

    NdisReleaseSpinLock(&pAdapter->Lock);

    PXDEBUGP(PXD_LOUD, PXM_CM, ("PxCmOpenAf: CmAf %p, NdisAfHandle is %p\n",
        pCmAf,NdisAfHandle));

    *CallMgrAfContext = pCmAf;

    return(NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
PxCmCloseAf(
    IN NDIS_HANDLE  CallMgrAfContext
    )
/*++

Routine Description:
    The client is closing the open of this address family.

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    PPX_CM_AF       pCmAf;
    PPX_ADAPTER     pAdapter;

    pCmAf = (PPX_CM_AF)CallMgrAfContext;

    //ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    PXDEBUGP(PXD_LOUD, PXM_CM, ("PxCmCloseAf: CmAf %p\n", pCmAf));

    //
    // There should not be any open saps on this af!
    //
    ASSERT(IsListEmpty(&pCmAf->CmSapList) == TRUE);

    //
    // There should not be any active Vc's on this af!
    //
    ASSERT(IsListEmpty(&pCmAf->VcList) == TRUE);

    pAdapter = pCmAf->Adapter;

    NdisAcquireSpinLock(&pAdapter->Lock);

    RemoveEntryList(&pCmAf->Linkage);

    DEREF_ADAPTER_LOCKED(pAdapter);

    NdisAcquireSpinLock(&pCmAf->Lock);

    pCmAf->State = PX_AF_CLOSED;

    pCmAf->Linkage.Flink =
    pCmAf->Linkage.Blink = (PLIST_ENTRY)pCmAf;

    DEREF_CM_AF_LOCKED(pCmAf);

    //ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return (NDIS_STATUS_PENDING);

}


NDIS_STATUS
PxCmRegisterSap(
    IN  NDIS_HANDLE             CallMgrAfContext,
    IN  PCO_SAP                 Sap,
    IN  NDIS_HANDLE             NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    )
/*++

Routine Description:

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    PPX_CM_AF   pCmAf;
    PPX_CM_SAP  pCmSap;
    PPX_ADAPTER pAdapter;

    pCmAf = (PPX_CM_AF)CallMgrAfContext;

    PXDEBUGP(PXD_LOUD, PXM_CM, ("PxCmRegisterSap: CmAf %p\n", pCmAf));

    NdisAcquireSpinLock(&pCmAf->Lock);

    if (pCmAf->State != PX_AF_OPENED) {
        PXDEBUGP(PXD_WARNING, PXM_CM,
            ("PxCmRegisterSap: Invalid state %x\n", pCmAf->State));

        NdisReleaseSpinLock(&pCmAf->Lock);
        return (NDIS_STATUS_FAILURE);
    }

    pAdapter = pCmAf->Adapter;

    NdisReleaseSpinLock(&pCmAf->Lock);

    NdisAcquireSpinLock(&pAdapter->Lock);

    if (pAdapter->State != PX_ADAPTER_OPEN) {
        NdisReleaseSpinLock(&pAdapter->Lock);
        return (NDIS_STATUS_CLOSING);
    }

    NdisReleaseSpinLock(&pAdapter->Lock);

    //
    // Allocate memory for the Sap
    //
    pCmSap = PxAllocateCmSap(Sap);

    if (pCmSap == NULL) {
        PXDEBUGP(PXD_WARNING, PXM_CM,
            ("PxCmRegisterSap: Error allocating memory for sap %p\n", Sap));

        NdisReleaseSpinLock(&pCmAf->Lock);
        return (NDIS_STATUS_RESOURCES);
    }

    NdisAcquireSpinLock(&pCmAf->Lock);

    pCmSap->NdisSapHandle = NdisSapHandle;
    pCmSap->CmAf = pCmAf;

    InsertTailList(&pCmAf->CmSapList, &pCmSap->Linkage);

    REF_CM_AF(pCmAf);

    NdisReleaseSpinLock(&pCmAf->Lock);

    *CallMgrSapContext = pCmSap;

    return(STATUS_SUCCESS);
}


NDIS_STATUS
PxCmDeRegisterSap(
    IN  NDIS_HANDLE       CallMgrSapContext
    )
/*++

Routine Description:

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    PPX_CM_SAP  pCmSap;
    PPX_CM_AF   pCmAf;

    pCmSap = (PPX_CM_SAP)CallMgrSapContext;

    //
    // BUG 494260
    //  NDIS should not be invoking this deregister handler at a raised
    //  IRQL (i.e while holding a spinlock).  Bug 494260 documents this
    //  this issue.
    //  
    //  This assert has been commented out to prevent breaks on checked build.
    //  When 494260 is fixed, this ASSERT should be uncommented.
    //
    
    // ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    PXDEBUGP(PXD_LOUD, PXM_CM, ("PxCmDeRegisterSap: CmSap %p\n", pCmSap));

    pCmAf = pCmSap->CmAf;

    InterlockedExchange((PLONG)&pCmSap->State, PX_SAP_CLOSED);

    NdisAcquireSpinLock(&pCmAf->Lock);

    RemoveEntryList(&pCmSap->Linkage);

    DEREF_CM_AF_LOCKED(pCmAf);

    PxFreeCmSap(pCmSap);

    //
    // Refer comment above
    //
    
    //ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return(STATUS_SUCCESS);
}

NDIS_STATUS
PxCmMakeCall(
    IN  NDIS_HANDLE              CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS   pCallParameters,
    IN  NDIS_HANDLE              NdisPartyHandle         OPTIONAL,
    OUT PNDIS_HANDLE             pCallMgrPartyContext    OPTIONAL
    )
/*++

Routine Description:
    We do not allow a client to make a call!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    ASSERT(0);
    return(STATUS_SUCCESS);
}

NDIS_STATUS
PxCmCloseCall(
    IN  NDIS_HANDLE     CallMgrVcContext,
    IN  NDIS_HANDLE     CallMgrPartyContext OPTIONAL,
    IN  PVOID           Buffer  OPTIONAL,
    IN  UINT            Size    OPTIONAL
    )
{
    PPX_VC      pVc;
    PPX_CM_AF   pCmAf;
    NDIS_STATUS Status;

    PXDEBUGP(PXD_LOUD, PXM_CM, 
        ("PxCmCloseCall: VcCtx %x\n", CallMgrVcContext));

    GetVcFromCtx(CallMgrVcContext, &pVc);

    if (pVc == NULL) {
        PXDEBUGP(PXD_WARNING, PXM_CM, 
            ("PxCmCloseCall: Invalid VcCtx %x!\n", CallMgrVcContext));

        return (NDIS_STATUS_SUCCESS);
    }

    NdisAcquireSpinLock(&pVc->Lock);

    pVc->HandoffState = PX_VC_HANDOFF_IDLE;

    pVc->CloseFlags |= PX_VC_CL_CLOSE_CALL;
    NdisReleaseSpinLock(&pVc->Lock);

    NdisCmCloseCallComplete(NDIS_STATUS_SUCCESS,
                            pVc->CmVcHandle,
                            NULL);

#ifdef CODELETEVC_FIXED
    //
    // Evidently the CoCreateVc is unbalanced
    // when creating a proxy vc.  The call to 
    // NdisCoDeleteVc will fail because the
    // Vc is still active.
    // Investigate this with ndis guys!!!!!
    //
    Status =
        NdisCoDeleteVc(pVc->CmVcHandle);

    if (Status == NDIS_STATUS_SUCCESS) {
        pVc->CmVcHandle = NULL;
    }
#endif

    NdisAcquireSpinLock(&pVc->Lock);


    //
    // If the Vc is no longer connected then
    // we are waiting for this part of the vc
    // to go away before we can cleanup the
    // vc with the call manager.
    //
    if (pVc->Flags & PX_VC_CLEANUP_CM) {

        ASSERT(pVc->State == PX_VC_DISCONNECTING);

        PxCloseCallWithCm(pVc);
    }

    pCmAf = pVc->CmAf;

    //
    // Remove the reference applied when the call
    // was dispatched to the client.  We do not need
    // all of the ref code because of the ref applied
    // at entry to this function.
    //
    pVc->RefCount--;

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    DEREF_CM_AF(pCmAf);

    return(NDIS_STATUS_PENDING);
}

VOID
PxCmIncomingCallComplete(
    IN  NDIS_STATUS         Status,
    IN  NDIS_HANDLE         CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS pCallParameters
    )
{

    PPX_VC      pVc;

    PXDEBUGP(PXD_LOUD, PXM_CM, 
        ("PxCmIncomingCallComplete: VcCtx %x\n", CallMgrVcContext));

    GetVcFromCtx(CallMgrVcContext, &pVc);

    if (pVc == NULL) {
        PXDEBUGP(PXD_WARNING, PXM_CM, 
            ("PxCmIncomingCallComplete: Invalid VcCtx %x!\n", 
             CallMgrVcContext));

        return;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    PXDEBUGP(PXD_LOUD, PXM_CM, 
        ("PxCmIncomingCallComplete: Vc %p, Status %x\n", 
         pVc, Status));

    PxSignal(&pVc->Block, Status);

    //
    // remove the ref applied when we mapped
    // the vcctx to the vc
    //
    DEREF_VC_LOCKED(pVc);
}

NDIS_STATUS
PxCmAddParty(
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  pCallParameters,
    IN  NDIS_HANDLE             NdisPartyHandle,
    OUT PNDIS_HANDLE            pCallMgrPartyContext
    )
/*++

Routine Description:
    We do not allow a client to add a party to a vc!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{

    ASSERT(0);
    return(STATUS_SUCCESS);
}

NDIS_STATUS
PxCmDropParty(
    IN  NDIS_HANDLE             CallMgrPartyContext,
    IN  PVOID                   Buffer  OPTIONAL,
    IN  UINT                    Size    OPTIONAL
    )
/*++

Routine Description:
    We do not allow a client to drop a party on a vc!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    ASSERT(0);
    return(STATUS_SUCCESS);
}

VOID
PxCmActivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS     pCallParameters)
/*++

Routine Description:
    The vc has already been activate by the underlying
    call manager/miniport!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    ASSERT(0);
}

VOID
PxCmDeActivateVcComplete(
    IN  NDIS_STATUS         Status,
    IN  NDIS_HANDLE         CallMgrVcContext
    )
/*++

Routine Description:
    The vc is never deactivated by our call manager!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{

    ASSERT(0);
}

NDIS_STATUS
PxCmModifyCallQos(
    IN  NDIS_HANDLE         CallMgrVcContext,
    IN  PCO_CALL_PARAMETERS pCallParameters
    )
/*++

Routine Description:
    Not sure what to do here right now!
    ToDo!!!!!!!!!!

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    return(STATUS_SUCCESS);
}

NDIS_STATUS
PxCmRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    )
/*++

Routine Description:
    We will handle requests from the clients and pass them down
    to the underlying call manager/miniport if needed.

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    return(STATUS_SUCCESS);
}

VOID
PxCmRequestComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE ProtocolVcContext,      // Optional
    IN NDIS_HANDLE ProtocolPartyContext, // Optional
    IN PNDIS_REQUEST NdisRequest
    )
/*++

Routine Description:
    Called by the client upon completion of any requests
    that we have passed up to it.  If this request needed to
    be completed synchronously (status matters) then we will
    signal completion and let the calling routine free the
    memory.  If this could complete asynchronously then we
    just free the memory here.

Arguments:

Return Value:
    NDIS_STATUS_SUCCESS  if everything goes off well right here
    NDIS_STATUS_XXXX     to indicate any error.

--*/
{
    PPX_REQUEST     pProxyRequest;
    PPX_CM_AF       pCmAf;
    PPX_VC          pVc;

    pCmAf = (PPX_CM_AF)ProtocolAfContext;
    pVc = (PPX_VC)ProtocolVcContext;

    PXDEBUGP(PXD_INFO, PXM_CM, ("PxCmRequestComplete: CmAf %p, Vc %p\n", pCmAf, pVc));

    pProxyRequest = CONTAINING_RECORD(NdisRequest, PX_REQUEST, NdisRequest);

    if (pProxyRequest->Flags & PX_REQ_ASYNC) {
        pProxyRequest->Flags &= ~PX_REQ_ASYNC;
        PxFreeMem(pProxyRequest);
        DEREF_CM_AF(pCmAf);
    } else {
        PxSignal(&pProxyRequest->Block, Status);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\pxdefs.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    pxdefs.h

Abstract:

    Defines for ndproxy.sys

Author:

    Tony Bell    


Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    TonyBe      03/04/99        Created

--*/

#ifndef _PXDEFS__H
#define _PXDEFS__H

///////////////////////////////////////////////////////////////////////////
//                      Constants
///////////////////////////////////////////////////////////////////////////

#define MODULE_INIT     0x00010000
#define MODULE_NTINIT   0x00020000
#define MODULE_CO       0x00030000
#define MODULE_CL       0x00040000
#define MODULE_DEBUG    0x00050000
#define MODULE_CM       0x00060000
#define MODULE_UTIL     0x00070000
#define MODULE_CFG      0x00080000
#define MODULE_TAPI     0x00100000

//
// Proxy's memory tags
//
#define PX_EVENT_TAG        '1XP'
#define PX_VCTABLE_TAG      '2XP'
#define PX_ADAPTER_TAG      '3XP'
#define PX_CLSAP_TAG        '4XP'
#define PX_CMSAP_TAG        '5XP'
#define PX_PARTY_TAG        '6XP'
#define PX_COCALLPARAMS_TAG '7XP'
#define PX_REQUEST_TAG      '8XP'
#define PX_PROVIDER_TAG     '9XP'
#define PX_ENUMLINE_TAG     'aXP'
#define PX_TAPILINE_TAG     'bXP'
#define PX_ENUMADDR_TAG     'cXP'
#define PX_TAPIADDR_TAG     'dXP'
#define PX_TAPICALL_TAG     'eXP'
#define PX_LINECALLINFO_TAG 'fXP'
#define PX_CMAF_TAG         'gXP'
#define PX_CLAF_TAG         'hXP'
#define PX_VC_TAG           'iXP'
#define PX_TRANSLATE_CALL   'jXP'
#define PX_TRANSLATE_SAP    'kXP'
#define PX_LINETABLE_TAG    'lXP'

#define NDIS_MAJOR_VERSION  0x05
#define NDIS_MINOR_VERSION  0x00
#define PX_MAJOR_VERSION    0x01
#define PX_MINOR_VERSION    0x00

#define DD_PROXY_DEVICE_NAME        L"\\Device\\NDProxy"
#define PX_NAME                     L"NDProxy"
#define MAX_ADSL_MEDIATYPE_STRING   48
#define MAX_STATUS_COUNT            8
#define MAX_LINE_DEVS               255
#define MAX_NUM_CONCURRENT_CALLS    1000
#define MAX_DEVCLASS_STRINGSIZE     16

#define LINE_TABLE_SIZE             500
#define VC_TABLE_SIZE               500

#define MAX_STRING_PARAM_SIZE   40

#define MAX_OUT_CALL_STATES     4

#define LINE_CALL_INFO_VAR_DATA_SIZE    (17*MAX_STRING_PARAM_SIZE)

//
// ADSL flags to indicate overriding registry values
// in device extension
//
#define ADSL_TX_RATE_FROM_REG   ((USHORT)0x0001)
#define ADSL_RX_RATE_FROM_REG   ((USHORT)0x0002)
#define ADSL_FLAGS_MASK         ((USHORT)0x0004)

//
// Status of tapi with ndproxy
//
typedef enum _NDISTAPI_STATUS {
    NDISTAPI_STATUS_CONNECTED,
    NDISTAPI_STATUS_DISCONNECTED,
    NDISTAPI_STATUS_CONNECTING,
    NDISTAPI_STATUS_DISCONNECTING
} NDISTAPI_STATUS, *PNDISTAPI_STATUS;

//
// Status of providers with ndproxy
//
typedef enum _PROVIDER_STATUS {
    PROVIDER_STATUS_ONLINE,
    PROVIDER_STATUS_OFFLINE
} PROVIDER_STATUS, *PPROVIDER_STATUS;

//
// States for PX_ADAPTER
//
typedef enum PX_ADAPTER_STATE {
    PX_ADAPTER_CLOSED,
    PX_ADAPTER_CLOSING,
    PX_ADAPTER_OPENING,
    PX_ADAPTER_OPEN
} PX_ADAPTER_STATE;

//
// States for PX_CL_AF, PX_CM_AF
//
typedef enum PX_AF_STATE{
    PX_AF_CLOSED,
    PX_AF_CLOSING,
    PX_AF_OPENING,
    PX_AF_OPENED
} PX_AF_STATE;

//
// States for PX_CL_SAP, PX_CM_SAP
//
typedef enum PX_SAP_STATE {
    PX_SAP_CLOSED,
    PX_SAP_CLOSING,
    PX_SAP_OPENING,
    PX_SAP_OPENED
} PX_SAP_STATE;

//
// States for PX_VC between ndproxy
// and the underlying call manager
//
typedef enum PX_VC_STATE {
    PX_VC_IDLE,                     // created
    PX_VC_PROCEEDING,               // outgoing
    PX_VC_OFFERING,                 // incoming
    PX_VC_DISCONNECTING,
    PX_VC_CONNECTED
} PX_VC_STATE;

//
// States for PX_VC between ndproxy
// and the client
//
typedef enum PX_VC_HANDOFF_STATE {
    PX_VC_HANDOFF_IDLE,             // created
    PX_VC_HANDOFF_OFFERING,         // incoming (always)
    PX_VC_HANDOFF_DISCONNECTING,
    PX_VC_HANDOFF_CONNECTED
} PX_VC_HANDOFF_STATE;


///////////////////////////////////////////////////////////////////////////
//                      Macros
///////////////////////////////////////////////////////////////////////////

#ifdef ROUND_UP
#undef ROUND_UP
#endif
#define ROUND_UP(_Val)  (((_Val) + 3) & ~3)


#ifndef MAX

/*++
OPAQUE
MAX(
    IN  OPAQUE      Fred,
    IN  OPAQUE      Shred
)
--*/
#define MAX(Fred, Shred)        (((Fred) > (Shred)) ? (Fred) : (Shred))

#endif // MAX


#ifndef MIN

/*++
OPAQUE
MIN(
    IN  OPAQUE      Fred,
    IN  OPAQUE      Shred
)
--*/
#define MIN(Fred, Shred)        (((Fred) < (Shred)) ? (Fred) : (Shred))

#endif // MIN

/*++
PVOID
PxAllocMem(
    IN  ULONG   Size
)
--*/
#if DBG

#define PxAllocMem(_p, _s, _t)  \
        _p = PxAuditAllocMem((PVOID)(&(_p)), _s, _t, _FILENUMBER, __LINE__);


#else // DBG

#define PxAllocMem(_p, _s, _t)  \
        _p = ExAllocatePoolWithTag(NonPagedPool, (ULONG)_s, (ULONG)_t)

#endif // DBG


/*++
VOID
PxFreeMem(
    IN  PVOID   Pointer
)
--*/
#if DBG

#define PxFreeMem(Pointer)  PxAuditFreeMem((PVOID)Pointer)

#else

#define PxFreeMem(Pointer)  ExFreePool((PVOID)(Pointer))

#endif // DBG

/*++
VOID
PxInitBlockStruc(
    PxBlockStruc    *pBlock
)
--*/
#define PxInitBlockStruc(pBlock)    NdisInitializeEvent(&((pBlock)->Event))

/*++
NDIS_STATUS
PxBlock(
    PxBlockStruc    *pBlock
)
--*/
#define PxBlock(pBlock)     \
            (NdisWaitEvent(&((pBlock)->Event), 0), (pBlock)->Status)


/*++
VOID
PxSignal(
    IN  PxBlockStruc    *pBlock,
    IN  UINT            Status
)
--*/
#define PxSignal(_pbl, _s)  \
            { (_pbl)->Status = _s; NdisSetEvent(&((_pbl)->Event)); }

/*++
VOID
REF_ADAPTER(
    IN  PPX_ADAPTER _pa
    )
--*/
#define REF_ADAPTER(_pa)    \
    (_pa)->RefCount++

/*++
VOID
DEREF_ADAPTER(
    IN  PPX_ADAPTER _pa
    )
--*/
#define DEREF_ADAPTER(_pa)                              \
{                                                       \
    NdisAcquireSpinLock(&(_pa)->Lock);                  \
    if (--(_pa)->RefCount == 0) {                       \
        NdisReleaseSpinLock(&(_pa)->Lock);              \
        PxFreeAdapter(_pa);                             \
    } else {                                            \
        NdisReleaseSpinLock(&(_pa)->Lock);              \
    }                                                   \
}

/*++
VOID
DEREF_ADAPTER_LOCKED(
    IN  PPX_ADAPTER _pa
    )
--*/
#define DEREF_ADAPTER_LOCKED(_pa)                       \
{                                                       \
    if (--(_pa)->RefCount == 0) {                       \
        NdisReleaseSpinLock(&(_pa)->Lock);              \
        PxFreeAdapter(_pa);                             \
    } else {                                            \
        NdisReleaseSpinLock(&(_pa)->Lock);              \
    }                                                   \
}

/*++
REF_CM_AF(
    IN PPX_CM_AF   _paf
    )
--*/
#define REF_CM_AF(_paf)                                 \
{                                                       \
    ASSERT((LONG)(_paf)->RefCount != 0);                \
    (_paf)->RefCount++;                                 \
}                                                       

/*++
VOID
DEREF_CM_AF(
    IN PPX_CM_AF   _paf
    )
--*/
#define DEREF_CM_AF(_paf)                               \
{                                                       \
    NdisAcquireSpinLock(&(_paf)->Lock);                 \
    ASSERT((LONG)(_paf)->RefCount > 0);                 \
    if (--(_paf)->RefCount == 0) {                      \
        DoDerefCmAfWork(_paf);                          \
    } else {                                            \
        NdisReleaseSpinLock(&(_paf)->Lock);             \
    }                                                   \
}

/*++
VOID
DEREF_CM_AF_LOCKED(
    IN PPX_CM_AF   _paf
    )
--*/
#define DEREF_CM_AF_LOCKED(_paf)                        \
{                                                       \
    ASSERT((LONG)(_paf)->RefCount > 0);                 \
    if (--(_paf)->RefCount == 0) {                      \
        DoDerefCmAfWork(_paf);                          \
    } else {                                            \
        NdisReleaseSpinLock(&(_paf)->Lock);             \
    }                                                   \
}

/*++
REF_CL_AF(
    IN PPX_CL_AF   _paf
    )
--*/
#define REF_CL_AF(_paf)                                 \
{                                                       \
    ASSERT((LONG)(_paf)->RefCount != 0);                \
    (_paf)->RefCount++;                                 \
}

/*++
VOID
DEREF_CL_AF(
    IN PPX_CL_AF   _paf
    )
--*/
#define DEREF_CL_AF(_paf)                               \
{                                                       \
    if ((_paf) != NULL) {                               \
        NdisAcquireSpinLock(&(_paf)->Lock);             \
        ASSERT((LONG)(_paf)->RefCount > 0);             \
        if (--(_paf)->RefCount == 0) {                  \
            DoDerefClAfWork(_paf);                      \
        } else {                                        \
            NdisReleaseSpinLock(&(_paf)->Lock);         \
        }                                               \
    }                                                   \
}

/*++
VOID
DEREF_CL_AF_LOCKED(
    IN PPX_CL_AF   _paf
    )
--*/
#define DEREF_CL_AF_LOCKED(_paf)                        \
{                                                       \
    if ((_paf) != NULL) {                               \
    ASSERT((LONG)(_paf)->RefCount > 0);                 \
        if (--(_paf)->RefCount == 0) {                  \
            DoDerefClAfWork(_paf);                      \
        } else {                                        \
            NdisReleaseSpinLock(&(_paf)->Lock);         \
        }                                               \
    }                                                   \
}

/*++
REF_VC(
    IN PPX_VC   _pvc
    )
--*/
#define REF_VC(_pvc)    \
    (_pvc)->RefCount++

#ifdef CODELETEVC_FIXED
/*++
VOID
DEREF_VC(
    IN PPX_VC   _pvc
    )
--*/
#define DEREF_VC(_pvc)                                  \
{                                                       \
    if (_pvc != NULL) {                                 \
        NdisAcquireSpinLock(&(_pvc)->Lock);             \
        if (--(_pvc)->RefCount == 0) {                  \
            DoDerefVcWork(_pvc);                        \
        } else {                                        \
            NdisReleaseSpinLock(&(_pvc)->Lock);         \
        }                                               \
    }                                                   \
}

/*++
VOID
DEREF_VC_LOCKED(
    IN PPX_VC   _pvc
    )
--*/
#define DEREF_VC_LOCKED(_pvc)                           \
{                                                       \
    if (_pvc != NULL) {                                 \
        if (--(_pvc)->RefCount == 0) {                  \
            DoDrefVcWork(_pvc);                         \
        } else {                                        \
            NdisReleaseSpinLock(&(_pvc)->Lock);         \
        }                                               \
    }                                                   \
}
#else
/*++
VOID
DEREF_VC(
    IN PPX_VC   _pvc
    )
--*/
#define DEREF_VC(_pvc)                                  \
{                                                       \
    if (_pvc != NULL) {                                 \
        NdisAcquireSpinLock(&(_pvc)->Lock);             \
        if (--(_pvc)->RefCount == 0) {                  \
            DoDerefVcWork(_pvc);                        \
        } else {                                        \
            NdisReleaseSpinLock(&(_pvc)->Lock);         \
        }                                               \
    }                                                   \
}

/*++
VOID
DEREF_VC_LOCKED(
    IN PPX_VC   _pvc
    )
--*/
#define DEREF_VC_LOCKED(_pvc)                           \
{                                                       \
    if (_pvc != NULL) {                                 \
        if (--(_pvc)->RefCount == 0) {                  \
            DoDerefVcWork(_pvc);                        \
        } else {                                        \
            NdisReleaseSpinLock(&(_pvc)->Lock);         \
        }                                               \
    }                                                   \
}
#endif

/*++
REF_TAPILINE
    IN PPX_TAPI_LINE   _ptl
    )
--*/
#define REF_TAPILINE(_ptl)    \
    (_ptl)->RefCount++

/*++
VOID
DEREF_TAPILINE(
    IN PPX_TAPI_LINE   _ptl
    )
--*/
#define DEREF_TAPILINE(_ptl)                            \
{                                                       \
    if (_ptl != NULL) {                                 \
        NdisAcquireSpinLock(&(_ptl)->Lock);             \
        if (--(_ptl)->RefCount == 0) {                  \
            NdisReleaseSpinLock(&(_ptl)->Lock);         \
            FreeTapiLine(_ptl);                         \
        } else {                                        \
            NdisReleaseSpinLock(&(_ptl)->Lock);         \
        }                                               \
    }                                                   \
}

/*++
VOID
DEREF_TAPILINE_LOCKED(
    IN PPX_TAPI_LINE   _ptl
    )
--*/
#define DEREF_TAPILINE_LOCKED(_ptl)                     \
{                                                       \
    if (_ptl != NULL) {                                 \
        if (--(_ptl)->RefCount == 0) {                  \
            NdisReleaseSpinLock(&(_ptl)->Lock);         \
            FreeTapiLine(_ptl);                         \
        } else {                                        \
            NdisReleaseSpinLock(&(_ptl)->Lock);         \
        }                                               \
    }                                                   \
}

/*++
VOID
AdapterFromBindContext(
    IN  NDIS_HANDLE _ctx,
    IN  PPX_ADAPTER _pa,
    IN  BOOLENA     _bcl
    )
--*/
#define AdapterFromBindContext(_ctx, _pa, _bcl)         \
{                                                       \
    if (*(PULONG)(_ctx) == PX_ADAPTER_SIG) {            \
        (_pa) = CONTAINING_RECORD((_ctx), PX_ADAPTER, Sig);   \
        (_bcl) = FALSE;                                 \
    } else {                                            \
        (_pa) = (PPX_ADAPTER)(_ctx);                    \
        (_bcl) = TRUE;                                  \
    }                                                   \
}

/*++
VOID
AdapterFromClBindContext(
    IN  NDIS_HANDLE _ctx,
    IN  PPX_ADAPTER _pa
    )
--*/
#define AdapterFromClBindContext(_ctx, _pa) \
        (_pa) = (PPX_ADAPTER)(_ctx)

/*++
VOID
AdapterFromCmBindContext(
    IN  NDIS_HANDLE _ctx,
    IN  PPX_ADAPTER _pa
    )
--*/
#define AdapterFromCmBindContext(_ctx, _pa)                     \
{                                                               \
    ASSERT(*(PULONG)(_ctx) == PX_ADAPTER_SIG);                  \
    (_pa) = CONTAINING_RECORD((_ctx), PX_ADAPTER, Sig);         \
}

/*
VOID
SendTapiCallState(
    IN  PPX_VC      _pvc,
    IN  ULONG_PTR   _p1,
    IN  ULONG_PTR   _p2,
    IN  ULONG_PTR   _p3
    )
*/
#define SendTapiCallState(_pvc, _p1, _p2, _p3)                  \
{                                                               \
    NDIS_TAPI_EVENT _le;                                        \
    PPX_TAPI_LINE   _tl;                                        \
    PXDEBUGP (PXD_LOUD, PXM_TAPI,                               \
              ("SendTapiCallState: Vc %p, CallState: %x, p2: %x, p3 %x\n",\
               _pvc, _p1, _p2, _p3));                           \
    _tl = (_pvc)->TapiLine;                                     \
    _le.htLine = _tl->htLine;                                   \
    _le.htCall = _pvc->htCall;                                  \
    _le.ulMsg = LINE_CALLSTATE;                                 \
    _le.ulParam1 = _p1;                                         \
    _le.ulParam2 = _p2;                                         \
    _le.ulParam3 = _p3;                                         \
    ASSERT((_p1) != (_pvc)->ulCallState);                       \
    (_pvc)->ulCallState = (_p1);                                \
    (_pvc)->ulCallStateMode = (_p2);                            \
    NdisReleaseSpinLock(&(_pvc)->Lock);                         \
    PxIndicateStatus(&(_le), sizeof(NDIS_TAPI_EVENT));          \
    NdisAcquireSpinLock(&(_pvc)->Lock);                         \
}
//    if ((_p1) == LINECALLSTATE_DISCONNECTED) {                  \
//        InterlockedDecrement((PLONG)&(_tl)->DevStatus->ulNumActiveCalls);\
//    } else if ((_p1) == LINECALLSTATE_OFFERING || (_p1) == LINECALLSTATE_PROCEEDING) {\
//        InterlockedIncrement((PLONG)&(_tl)->DevStatus->ulNumActiveCalls);\
//    }                                                           \

/*
VOID
SendTapiNewCall(
    IN  PPX_VC      _pvc,
    IN  ULONG_PTR   _p1,
    IN  ULONG_PTR   _p2,
    IN  ULONG_PTR   _p3
    )
*/
#define SendTapiNewCall(_pvc, _p1, _p2, _p3)                    \
{                                                               \
    NDIS_TAPI_EVENT _le;                                        \
    _le.htLine = _pvc->TapiLine->htLine;                        \
    _le.htCall = _pvc->htCall;                                  \
    _le.ulMsg = LINE_NEWCALL;                                   \
    _le.ulParam1 = _p1;                                         \
    _le.ulParam2 = _p2;                                         \
    _le.ulParam3 = _p3;                                         \
    PXDEBUGP (PXD_LOUD, PXM_TAPI,                               \
              ("SendTapiNewCall: Vc %p, p1: %x, p2: %x, p3 %x\n",\
               _pvc, _p1, _p2, _p3));                           \
    NdisReleaseSpinLock(&(_pvc)->Lock);                         \
    PxIndicateStatus(&(_le), sizeof(NDIS_TAPI_EVENT));          \
    NdisAcquireSpinLock(&(_pvc)->Lock);                         \
}

/*
VOID
SendTapiLineClose(
    IN  PPX_TAPI_LINE   _ptl
    )
*/
#define SendTapiLineClose(_ptl)                                 \
{                                                               \
    NDIS_TAPI_EVENT _le;                                        \
    _le.htLine = (_ptl)->htLine;                                \
    _le.htCall = 0;                                             \
    _le.ulMsg = LINE_CLOSE;                                     \
    _le.ulParam1 = 0;                                           \
    _le.ulParam2 = 0;                                           \
    _le.ulParam3 = 0;                                           \
    PXDEBUGP (PXD_LOUD, PXM_TAPI,                               \
              ("SendTapiLineClose: TapiLine %p\n",_ptl));       \
    PxIndicateStatus(&(_le), sizeof(NDIS_TAPI_EVENT));          \
}

/*
VOID
SendTapiLineCreate(
    IN  PPX_TAPI_LINE   _ptl
    )
*/
#define SendTapiLineCreate(_ptl)                                \
{                                                               \
    NDIS_TAPI_EVENT _le;                                        \
    _le.htLine = (_ptl)->htLine;                                \
    _le.htCall = 0;                                             \
    _le.ulMsg = LINE_CREATE;                                    \
    _le.ulParam1 = 0;                                           \
    _le.ulParam2 = (_ptl)->hdLine;                              \
    _le.ulParam3 = 0;                                           \
    PXDEBUGP (PXD_LOUD, PXM_TAPI,                               \
              ("SendTapiLineCreate: TapiLine %p\n",_ptl));      \
    PxIndicateStatus(&(_le), sizeof(NDIS_TAPI_EVENT));          \
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\pxinit.c ===
/*++

Copyright (c) 1995-1996  Micrososfft Corporation

Module Name:

    pxinit.c

Abstract:

    The module contains the init code for the NDIS Proxy.

Author:

   Richard Machin (RMachin)
Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    RMachin     10-3-96         created
    TonyBe      02-21-99        re-work/re-write

Notes:

--*/

#include <precomp.h>

#define MODULE_NUMBER   MODULE_INIT
#define _FILENUMBER   'TINI'

//
// Local defines...
//
NDIS_STATUS
GetConfigDword(
    NDIS_HANDLE Handle,
    PWCHAR      ParameterName,
    PULONG      Destination,
    ULONG       MinValue,
    ULONG       MaxValue
);

BOOLEAN
InitNDISProxy(
    VOID
    )
/*++
Routine Description

    The main init routine. We:

    read our configuration
    register as a protocol
    open the appropriate cards as a client (call ActivateBinding, which:
      Opens the appropriate address families
      Opens the cards as a Call Manager)

Arguments

    None

Calling Sequence:

    Called from pxntinit/DriverEntry

Return Value:

    TRUE if initalization succeeds.

--*/
{

    NDIS_PROTOCOL_CHARACTERISTICS PxProtocolCharacteristics;
    NDIS_STATUS         Status;
    NDIS_HANDLE         ConfigHandle;
    PVOID               Context;
    PVOID               BindingList;
    PNDIS_STRING        BindingNameString;

    PXDEBUGP(PXD_INFO, PXM_INIT, ("InitNdisProxy\n"));

    // Registering NDIS protocols.
    NdisZeroMemory(&PxProtocolCharacteristics,
                   sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

    PxProtocolCharacteristics.MajorNdisVersion =             NDIS_MAJOR_VERSION;
    PxProtocolCharacteristics.MinorNdisVersion =             NDIS_MINOR_VERSION;
    PxProtocolCharacteristics.Filler  =                      (USHORT)0;
    PxProtocolCharacteristics.Flags  =                       NDIS_PROTOCOL_PROXY |
                                                             NDIS_PROTOCOL_BIND_ALL_CO;
    PxProtocolCharacteristics.OpenAdapterCompleteHandler  = PxCoOpenAdaperComplete;
    PxProtocolCharacteristics.CloseAdapterCompleteHandler = PxCoCloseAdaperComplete;
    PxProtocolCharacteristics.TransferDataCompleteHandler = PxCoTransferDataComplete;
    PxProtocolCharacteristics.ResetCompleteHandler =        PxCoResetComplete;
    PxProtocolCharacteristics.SendCompleteHandler   =       PxCoSendComplete;
    PxProtocolCharacteristics.RequestCompleteHandler =      PxCoRequestComplete;
    PxProtocolCharacteristics.ReceiveHandler =              NULL;
    PxProtocolCharacteristics.ReceiveCompleteHandler =      PxCoReceiveComplete;
    PxProtocolCharacteristics.ReceivePacketHandler =        NULL;
    PxProtocolCharacteristics.StatusHandler =               NULL;
    PxProtocolCharacteristics.StatusCompleteHandler =       PxCoStatusComplete;
    PxProtocolCharacteristics.BindAdapterHandler =          PxCoBindAdapter;
    PxProtocolCharacteristics.UnbindAdapterHandler =        PxCoUnbindAdapter;
    PxProtocolCharacteristics.PnPEventHandler =             PxCoPnPEvent;
    PxProtocolCharacteristics.UnloadHandler =               PxCoUnloadProtocol;
    PxProtocolCharacteristics.CoStatusHandler =             PxCoStatus;
    PxProtocolCharacteristics.CoReceivePacketHandler =      PxCoReceivePacket;
    PxProtocolCharacteristics.CoAfRegisterNotifyHandler =   PxCoNotifyAfRegistration;
    NdisInitUnicodeString(&(PxProtocolCharacteristics.Name), PX_NAME);

    //
    //  To block BindAdapter till all RegisterProtocols are done.
    //
    NdisInitializeEvent(&DeviceExtension->NdisEvent);

    //
    // Now register ourselves as a CM with NDIS.
    //
    PXDEBUGP(PXD_LOUD,PXM_INIT, ("Registering Protocol\n"));
    NdisRegisterProtocol(&Status,
                         &(DeviceExtension->PxProtocolHandle),
                         &PxProtocolCharacteristics,
                         sizeof(PxProtocolCharacteristics));

    if (Status != NDIS_STATUS_SUCCESS) {
        PXDEBUGP(PXD_INFO, PXM_INIT, ("Protocol registration failed!\n"));
        return FALSE;
    }

    //
    //  Allow BindAdapter to proceed.
    //
    NdisSetEvent(&DeviceExtension->NdisEvent);

    return TRUE;
}

VOID
GetRegistryParameters(
    IN PUNICODE_STRING  RegistryPath
    )

/*++

Routine Description:

This routine stores the configuration information for this device.

Arguments:

RegistryPath - Pointer to the null-terminated Unicode name of the
    registry path for this driver.

Return Value:

None.  As a side-effect, sets DeviceExtension->EventDataQueuLength field

--*/

{
    NDIS_STRING     ProtocolName;
    ULONG           ulDefaultData = 0;
    ULONG           ulMaxRate = -1;
    NTSTATUS        Status = STATUS_SUCCESS;
    HANDLE          hHandle, hParamsKeyHandle = NULL;
    NDIS_STRING     KeyName;
    USHORT          DefaultMediaType[] = L"Unspecfied ADSL Media";

    NdisInitUnicodeString(&ProtocolName, L"NDProxy");
    NdisInitUnicodeString(&KeyName, L"Parameters");

    //
    //    Open the Proxy's key in the registry.
    //
    NdisOpenProtocolConfiguration(&Status,
                                  &hHandle,
                                  &ProtocolName);

    if (Status != NDIS_STATUS_SUCCESS) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        NdisOpenConfigurationKeyByName(&Status,
                                       hHandle,     //"HKLM/CCS/NDProxy"
                                       &KeyName,    //"Parameters"
                                       &hParamsKeyHandle);

        if (NT_SUCCESS(Status)) {
            ULONG ulResult;
            PNDIS_CONFIGURATION_PARAMETER   pNdisConfigurationParameter;

            //
            // Gather all of the "user specified" information from
            // the registry.
            //
            Status = GetConfigDword (hParamsKeyHandle, L"TxRate", &DeviceExtension->ADSLTxRate, ulDefaultData, ulMaxRate);

            if (!NT_SUCCESS(Status)) {
                PXDEBUGP(PXD_LOUD, PXM_INIT, (
                                   "GetRegistryParameters: NdisReadConfiguration failed, err=%x\n",
                                   Status
                                   ));
            } else {
                DeviceExtension->RegistryFlags |= ADSL_TX_RATE_FROM_REG;
            }

            //
            // Next
            //
            Status = GetConfigDword (hParamsKeyHandle, L"RxRate", &DeviceExtension->ADSLRxRate, ulDefaultData, ulMaxRate);

            if (!NT_SUCCESS(Status)) {
                PXDEBUGP(PXD_LOUD, PXM_INIT, (
                                   "GetRegistryParameters: NdisReadConfiguration failed, err=%x\n",
                                   Status));
            } else {
                DeviceExtension->RegistryFlags |= ADSL_RX_RATE_FROM_REG;
            }

            //
            // Dump values
            //
            PXDEBUGP (PXD_LOUD, PXM_INIT, (
                                "GetRegistryParameters: ADSLTxRate = %x\n",
                                DeviceExtension->ADSLTxRate
                                ));
            PXDEBUGP (PXD_LOUD, PXM_INIT, (
                                "GetRegistryParameters: ADSLRxRate = %x\n",
                                DeviceExtension->ADSLRxRate
                                ));
        }
    }
}

NDIS_STATUS
GetConfigDword(
    NDIS_HANDLE Handle,
    PWCHAR      ParameterName,
    PULONG      Destination,
    ULONG       MinValue,
    ULONG       MaxValue
)
/*++

Routine Description

    A routine to read a ulong  from the registry. We're given a handle,
    the name of the key, and where to put it.

Arguments

    Handle          - Open handle to the parent key.
    ParameterName   - Pointer to name of the parameter.
    Destination     - Where to put the dword.
    MinValue        - Minimum value of the dword allowed.
    MaxValue        - Maximum allowable value.

Return Value:

    NDIS_STATUS_SUCCESS if we read in the value, error code otherwise.

--*/
{
    NDIS_STATUS                     Status;
    ULONG                           Value;
    NDIS_STRING                     ParameterNameString;
    PNDIS_CONFIGURATION_PARAMETER   pNdisConfigurationParameter;

    NdisInitUnicodeString(
                    &ParameterNameString,
                    ParameterName
                    );

    NdisReadConfiguration(
                    &Status,
                    &pNdisConfigurationParameter,
                    Handle,
                    &ParameterNameString,
                    NdisParameterInteger
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        Value = pNdisConfigurationParameter->ParameterData.IntegerData;

        if ((Value >= (ULONG)MinValue) && (Value <= (ULONG)MaxValue))
        {
            *Destination = (ULONG)Value;
        }
    }

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\pxntinit.c ===
/*++                    

Copyright (c) 1995  Microsoft Corporation

Module Name:

pxntinit.c

Abstract:

The module contains the NT-specific init code forthe NDIS Proxy.

Author:

Richard Machin (RMachin)

Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------

    RMachin     10-3-96         created
    TonyBe      02-21-99        re-work/re-write

Notes:

--*/

#include "ntddk.h"
//#include <cxport.h>
#include <precomp.h>

#define MODULE_NUMBER MODULE_NTINIT
#define _FILENUMBER 'NITN'

PPX_DEVICE_EXTENSION    DeviceExtension;
NPAGED_LOOKASIDE_LIST   ProviderEventLookaside;
NPAGED_LOOKASIDE_LIST   VcLookaside;
TAPI_TSP_CB             TspCB;
VC_TABLE                VcTable;
TAPI_LINE_TABLE         LineTable;
TSP_EVENT_LIST          TspEventList;

//
// Local funcion prototypes
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PxUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
PxIOCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
PxIOClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
PxIODispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
PxIOCleanup(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
PxCancelGetEvents(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// All of the init code can be discarded.
//
#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)

#endif // ALLOC_PRAGMA

//
// Tapi OIDs that the Proxy supports
//
OID_DISPATCH TapiOids[] =
{
    {OID_TAPI_ACCEPT,sizeof (NDIS_TAPI_ACCEPT), PxTapiAccept},
    {OID_TAPI_ANSWER, sizeof (NDIS_TAPI_ANSWER), PxTapiAnswer},
    {OID_TAPI_CLOSE, sizeof (NDIS_TAPI_CLOSE), PxTapiClose},
    {OID_TAPI_CLOSE_CALL, sizeof (NDIS_TAPI_CLOSE_CALL), PxTapiCloseCall},
    {OID_TAPI_CONDITIONAL_MEDIA_DETECTION, sizeof (NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION), PxTapiConditionalMediaDetection},
    {OID_TAPI_CONFIG_DIALOG, sizeof (NDIS_TAPI_CONFIG_DIALOG), PxTapiConfigDialog},
    {OID_TAPI_DEV_SPECIFIC, sizeof (NDIS_TAPI_DEV_SPECIFIC), PxTapiDevSpecific},
    {OID_TAPI_DIAL, sizeof (NDIS_TAPI_DIAL), PxTapiDial},
    {OID_TAPI_DROP, sizeof (NDIS_TAPI_DROP), PxTapiDrop},
    {OID_TAPI_GET_ADDRESS_CAPS, sizeof (NDIS_TAPI_GET_ADDRESS_CAPS), PxTapiGetAddressCaps},
    {OID_TAPI_GET_ADDRESS_ID, sizeof (NDIS_TAPI_GET_ADDRESS_ID), PxTapiGetAddressID},
    {OID_TAPI_GET_ADDRESS_STATUS, sizeof (NDIS_TAPI_GET_ADDRESS_STATUS), PxTapiGetAddressStatus},
    {OID_TAPI_GET_CALL_ADDRESS_ID, sizeof (NDIS_TAPI_GET_CALL_ADDRESS_ID), PxTapiGetCallAddressID},
    {OID_TAPI_GET_CALL_INFO, sizeof (NDIS_TAPI_GET_CALL_INFO), PxTapiGetCallInfo},
    {OID_TAPI_GET_CALL_STATUS, sizeof (NDIS_TAPI_GET_CALL_STATUS), PxTapiGetCallStatus},
    {OID_TAPI_GET_DEV_CAPS, sizeof (NDIS_TAPI_GET_DEV_CAPS), PxTapiGetDevCaps},
    {OID_TAPI_GET_DEV_CONFIG, sizeof (NDIS_TAPI_GET_DEV_CONFIG), PxTapiGetDevConfig},
    {OID_TAPI_GET_EXTENSION_ID, sizeof (NDIS_TAPI_GET_EXTENSION_ID), PxTapiGetExtensionID},
    {OID_TAPI_GET_ID, sizeof (NDIS_TAPI_GET_ID), PxTapiLineGetID},
    {OID_TAPI_GET_LINE_DEV_STATUS, sizeof (NDIS_TAPI_GET_LINE_DEV_STATUS), PxTapiGetLineDevStatus},
    {OID_TAPI_MAKE_CALL, sizeof (NDIS_TAPI_MAKE_CALL), PxTapiMakeCall},
    {OID_TAPI_NEGOTIATE_EXT_VERSION, sizeof (NDIS_TAPI_NEGOTIATE_EXT_VERSION), PxTapiNegotiateExtVersion},
    {OID_TAPI_OPEN, sizeof (NDIS_TAPI_OPEN) + sizeof(NDISTAPI_OPENDATA), PxTapiOpen},
    {OID_TAPI_PROVIDER_INITIALIZE, sizeof (NDIS_TAPI_PROVIDER_INITIALIZE), PxTapiProviderInit},
    {OID_TAPI_PROVIDER_SHUTDOWN, sizeof (NDIS_TAPI_PROVIDER_SHUTDOWN), PxTapiProviderShutdown},
    {OID_TAPI_SECURE_CALL, sizeof (NDIS_TAPI_SECURE_CALL), PxTapiSecureCall},
    {OID_TAPI_SELECT_EXT_VERSION, sizeof (NDIS_TAPI_SELECT_EXT_VERSION), PxTapiSelectExtVersion},
    {OID_TAPI_SEND_USER_USER_INFO, sizeof (NDIS_TAPI_SEND_USER_USER_INFO), PxTapiSendUserUserInfo},
    {OID_TAPI_SET_APP_SPECIFIC, sizeof (NDIS_TAPI_SET_APP_SPECIFIC), PxTapiSetAppSpecific},
    {OID_TAPI_SET_CALL_PARAMS, sizeof (NDIS_TAPI_SET_CALL_PARAMS), PxTapiSetCallParams},
    {OID_TAPI_SET_DEFAULT_MEDIA_DETECTION, sizeof (NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION), PxTapiSetDefaultMediaDetection},
    {OID_TAPI_SET_DEV_CONFIG, sizeof (NDIS_TAPI_SET_DEV_CONFIG), PxTapiSetDevConfig},
    {OID_TAPI_SET_MEDIA_MODE, sizeof (NDIS_TAPI_SET_MEDIA_MODE), PxTapiSetMediaMode},
    {OID_TAPI_SET_STATUS_MESSAGES, sizeof (NDIS_TAPI_SET_STATUS_MESSAGES), PxTapiSetStatusMessages},
    {OID_TAPI_GATHER_DIGITS, sizeof (NDIS_TAPI_GATHER_DIGITS), PxTapiGatherDigits},
    {OID_TAPI_MONITOR_DIGITS, sizeof (NDIS_TAPI_MONITOR_DIGITS), PxTapiMonitorDigits}
};

//
// TAPI OIDs that do not map to NDIS5, and are passed-through to CallManagers:
//

#define MAX_TAPI_SUPPORTED_OIDS     (sizeof(TapiOids)/sizeof(OID_DISPATCH))

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Initialization routine for the NDIS Proxy.

Arguments:

    DriverObject    - Pointer to the driver object created by the system.
    RegistryPath    - Points to global registry path

Return Value:

    The final status from the initialization operation.

--*/
{
    NTSTATUS            Status;
    UNICODE_STRING      deviceName;
    USHORT              i;
    UINT                initStatus;
    PDEVICE_OBJECT      DeviceObject;
    ULONG               SizeNeeded;

    PXDEBUGP(PXD_INFO, PXM_INIT, ("NDIS Proxy DriverEntry; built %s, %s\n", __DATE__, __TIME__));

    ExInitializeNPagedLookasideList(&ProviderEventLookaside,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(PROVIDER_EVENT),
                                    PX_EVENT_TAG,
                                    0);

    ExInitializeNPagedLookasideList(&VcLookaside,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(PX_VC),
                                    PX_VC_TAG,
                                    0);

    NdisZeroMemory(&TspCB, sizeof(TspCB));
    NdisZeroMemory(&TspEventList, sizeof(TspEventList));
    NdisZeroMemory(&VcTable, sizeof(VcTable));
    NdisZeroMemory(&LineTable, sizeof(LineTable));

    //
    // Create the device objects. IoCreateDevice zeroes the memory
    // occupied by the object.
    //
    RtlInitUnicodeString(&deviceName, DD_PROXY_DEVICE_NAME);

    Status = IoCreateDevice(DriverObject,
                            sizeof (PX_DEVICE_EXTENSION),
                            &deviceName,
                            FILE_DEVICE_NETWORK,
                            0,
                            FALSE,
                            &DeviceObject);

    if(!NT_SUCCESS(Status)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Initialize the driver object
    //
    DeviceExtension =
        (PPX_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    NdisZeroMemory(DeviceExtension,
                  sizeof (PX_DEVICE_EXTENSION));

    DeviceExtension->pDriverObject = DriverObject;
    NdisAllocateSpinLock(&DeviceExtension->Lock);
    InitializeListHead(&DeviceExtension->AdapterList);

    GetRegistryParameters (RegistryPath);

    NdisAllocateSpinLock(&TspCB.Lock);
    TspCB.Status             = NDISTAPI_STATUS_DISCONNECTED;
    TspCB.NdisTapiNumDevices = 0;
    TspCB.htCall             = 1;
    InitializeListHead(&TspCB.ProviderList);

    NdisAllocateSpinLock(&TspEventList.Lock);
    InitializeListHead(&TspEventList.List);

    //
    // Intialize the VcTable
    //
    NdisInitializeReadWriteLock(&VcTable.Lock);
    VcTable.Size = VC_TABLE_SIZE;
    InitializeListHead(&VcTable.List);

    SizeNeeded = (VC_TABLE_SIZE * sizeof(PPX_VC));

    PxAllocMem(VcTable.Table, SizeNeeded, PX_VCTABLE_TAG);

    if (VcTable.Table == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_INIT, ("DriverEntry: ExAllocPool for VcTable\n"));

        Status = STATUS_UNSUCCESSFUL;

        goto DriverEntry_err;
    }

    NdisZeroMemory(VcTable.Table, SizeNeeded);

    //
    // Initialize the LineTable
    //
    NdisInitializeReadWriteLock(&LineTable.Lock);
    LineTable.Size = LINE_TABLE_SIZE;
    SizeNeeded = (LINE_TABLE_SIZE * sizeof(PPX_TAPI_LINE));

    PxAllocMem(LineTable.Table, SizeNeeded, PX_LINETABLE_TAG);

    if (LineTable.Table == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_INIT, ("DriverEntry: ExAllocPool for VcTable\n"));

        Status = STATUS_UNSUCCESSFUL;

        goto DriverEntry_err;
    }

    NdisZeroMemory(LineTable.Table, SizeNeeded);

    DeviceExtension->pDeviceObject  = DeviceObject;

    DriverObject->DriverUnload                          = PxUnload;
    DriverObject->FastIoDispatch                        = NULL;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = PxIOCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = PxIOClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = PxIODispatch;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]         = PxIOCleanup;

    //
    // Intialize the device objects.
    //
    DeviceObject->Flags |= DO_DIRECT_IO;
    DeviceExtension->pDeviceObject = DeviceObject;

    //
    // Finally, initialize the stack.
    //
    initStatus = InitNDISProxy();

    if (initStatus == TRUE) {
        return(STATUS_SUCCESS);
    }

DriverEntry_err:

    Status = STATUS_UNSUCCESSFUL;

    while (!(IsListEmpty(&TspEventList.List))) {
        PPROVIDER_EVENT ProviderEvent;

        ProviderEvent = (PPROVIDER_EVENT)
            RemoveHeadList(&TspEventList.List);

        ExFreeToNPagedLookasideList(&ProviderEventLookaside, ProviderEvent);
    }

    if (VcTable.Table != NULL) {
        PxFreeMem(VcTable.Table);
        VcTable.Table = NULL;
    }

    if (LineTable.Table != NULL) {
        PxFreeMem(LineTable.Table);
        LineTable.Table = NULL;
    }

    if(DeviceObject != NULL) {
        IoDeleteDevice(DeviceObject);
        DeviceExtension->pDeviceObject = NULL;
    }

    ExDeleteNPagedLookasideList(&ProviderEventLookaside);
    ExDeleteNPagedLookasideList(&VcLookaside);

    return(Status);
}

VOID
PxUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/

{
    PXDEBUGP(PXD_LOUD, PXM_INIT, ("PxUnload: enter\n"));

    //
    // Call our unload handler
    //
    PxCoUnloadProtocol();

    NdisAcquireSpinLock(&TspEventList.Lock);

    while (!(IsListEmpty(&TspEventList.List))) {
        PPROVIDER_EVENT ProviderEvent;

        ProviderEvent = (PPROVIDER_EVENT)
            RemoveHeadList(&TspEventList.List);

        ExFreeToNPagedLookasideList(&ProviderEventLookaside, ProviderEvent);
    }

    NdisReleaseSpinLock(&TspEventList.Lock);

    ExDeleteNPagedLookasideList(&ProviderEventLookaside);
    ExDeleteNPagedLookasideList(&VcLookaside);

    if (DeviceExtension->pDeviceObject != NULL) {
        IoDeleteDevice (DeviceExtension->pDeviceObject);
    }

    //
    // Free Vc table memory
    //
    ASSERT(VcTable.Count == 0);
    PxFreeMem(VcTable.Table);

    //
    // Free the allocated tapi resources
    // (TapiProviders, TapiLines, TapiAddrs)
    //
    NdisAcquireSpinLock(&TspCB.Lock);

    while (!IsListEmpty(&TspCB.ProviderList)) {
        PPX_TAPI_PROVIDER    tp;

        tp = (PPX_TAPI_PROVIDER)
            RemoveHeadList(&TspCB.ProviderList);

        NdisReleaseSpinLock(&TspCB.Lock);

        FreeTapiProvider(tp);

        NdisAcquireSpinLock(&TspCB.Lock);
    }

    NdisReleaseSpinLock(&TspCB.Lock);

    NdisFreeSpinLock(&TspCB.Lock);

    //
    // Free the line table
    //
    ASSERT(LineTable.Count == 0);
    PxFreeMem(LineTable.Table);


    NdisFreeSpinLock(&(DeviceExtension->Lock));

    PXDEBUGP (PXD_LOUD, PXM_INIT, ("PxUnload: exit\n"));
}

NTSTATUS
PxIOCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PXDEBUGP(PXD_LOUD, PXM_INIT, ("IRP_MJ_CREATE, Irp=%p", Irp));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return (STATUS_SUCCESS);
}

NTSTATUS
PxIOClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PPX_TAPI_PROVIDER   Provider;

    PXDEBUGP(PXD_LOUD, PXM_INIT, ("IRP_MJ_CLOSE, Entry\n"));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return (STATUS_SUCCESS);
}


NTSTATUS
PxIODispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This is the generic dispatch routine for the Proxy. Irps come from the
    usermode TSP component.

Arguments:

    DeviceObject - Pointer to device object for target device
    Irp          - Pointer to I/O request packet

Return Value:

  NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PVOID               ioBuffer;
    ULONG               inputBufferLength;
    ULONG               outputBufferLength;
    ULONG               ioControlCode;
    ULONG               InfoSize = 0;
    NTSTATUS            ntStatus = STATUS_PENDING;
    PIO_STACK_LOCATION  IrpStack;
    ULONG               RequestId;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Get the pointer to the input/output buffer and its length
    //
    ioBuffer =
        Irp->AssociatedIrp.SystemBuffer;

    inputBufferLength =
        IrpStack->Parameters.DeviceIoControl.InputBufferLength;

    outputBufferLength =
        IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if ((IrpStack->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
        (DeviceObject != DeviceExtension->pDeviceObject)) {

        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return (STATUS_NOT_SUPPORTED);
    }

    ioControlCode = IrpStack->Parameters.DeviceIoControl.IoControlCode;

//    PxAssert((ioControlCode & (METHOD_BUFFERED | METHOD_IN_DIRECT | METHOD_OUT_DIRECT | METHOD_NEITHER)) == METHOD_BUFFERED);

    switch(ioControlCode)
    {
        case IOCTL_NDISTAPI_CONNECT:
        {
            PPX_TAPI_PROVIDER   Provider;

            PXDEBUGP(PXD_INFO, PXM_INIT, ("IOCTL_NDISTAPI_CONNECT, Irp=%p\n", Irp));

            //
            // Someone's connecting. Make sure they passed us a valid
            // info buffer.
            //
            if ((inputBufferLength < 2*sizeof(ULONG)) ||
                (outputBufferLength < sizeof(ULONG))) {
                PXDEBUGP (PXD_WARNING, PXM_INIT, ("IOCTL_NDISTAPI_CONNECT: buffer too small\n"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            NdisAcquireSpinLock(&TspCB.Lock);

            //
            // Return the number of line devs
            //
            PxAssert(outputBufferLength >= sizeof(ULONG));

            *((ULONG *) ioBuffer)= TspCB.NdisTapiNumDevices;

            TspCB.Status = NDISTAPI_STATUS_CONNECTED;

            Provider = (PPX_TAPI_PROVIDER)TspCB.ProviderList.Flink;

            while ((PVOID)Provider != (PVOID)&TspCB.ProviderList) {

                NdisAcquireSpinLock(&Provider->Lock);

                if (Provider->Status == PROVIDER_STATUS_ONLINE) {

                    MarkProviderConnected(Provider);
                }
                NdisReleaseSpinLock(&Provider->Lock);

                Provider = (PPX_TAPI_PROVIDER)Provider->Linkage.Flink;
            }

            ntStatus = STATUS_SUCCESS;
            InfoSize = sizeof (ULONG);

            NdisReleaseSpinLock(&TspCB.Lock);

            break;
        }

        case IOCTL_NDISTAPI_DISCONNECT:
        {
            PPX_TAPI_PROVIDER   Provider;

            NdisAcquireSpinLock(&TspCB.Lock);

            //
            // If no one is talking then set state to
            // disconnected.
            //
            TspCB.Status = NDISTAPI_STATUS_DISCONNECTING;

            Provider = (PPX_TAPI_PROVIDER)TspCB.ProviderList.Flink;

            while ((PVOID)Provider != (PVOID)&TspCB.ProviderList) {

                NdisAcquireSpinLock(&Provider->Lock);

                if (Provider->Status == PROVIDER_STATUS_ONLINE) {
                    MarkProviderDisconnected(Provider);
                }

                NdisReleaseSpinLock(&Provider->Lock);

                Provider = 
                    (PPX_TAPI_PROVIDER)Provider->Linkage.Flink;
            }

            NdisReleaseSpinLock (&TspCB.Lock);

            ntStatus = STATUS_SUCCESS;
            InfoSize = 0;

            break;
        }

        case IOCTL_NDISTAPI_QUERY_INFO:
        case IOCTL_NDISTAPI_SET_INFO:
        {
            ULONG               targetDeviceID;
            NDIS_STATUS         ndisStatus = NDIS_STATUS_SUCCESS;
            NDIS_HANDLE         providerHandle = NULL;
            PNDISTAPI_REQUEST   ndisTapiRequest;
            KIRQL               oldIrql;
            KIRQL               cancelIrql;
            PPX_TAPI_LINE       TapiLine = NULL;
            INT                 n=0;
            PKDEVICE_QUEUE_ENTRY    packet;

            //
            // All the following OIDs come in here as query/set IOCTls:
            //Init
            //Accept
            //Answer
            //Close
            //CloseCall
            //ConditionalMediaDetection
            //ConfigDialog
            //DevSpecific
            //Dial
            //Drop
            //GetAddressCaps
            //GetAddressID
            //GetAddressStatus
            //GetCallAddressID
            //GetCallInfo
            //GetCallStatus
            //GetDevCaps
            //GetDevConfig
            //GetExtensionID
            //GetID
            //GetLineDevStatus
            //MakeCall
            //NegotiateExtVersion
            //Open
            //ProviderInitialize
            //ProviderShutdown
            //SecureCall
            //SelectExtVersion
            //SendUserUserInfo
            //SetAppSpecific
            //SetCallParams
            //SetDefaultMediaDetection
            //SetDevConfig
            //SetMediaMode
            //SetStatusMessages
            //

            //
            // Verify we're connected, then check the device ID of the
            // incoming request against our list of online devices
            //

            //
            // Something other then pending was returned so complete
            // the irp
            //

            if (inputBufferLength < sizeof (NDISTAPI_REQUEST) ||
                outputBufferLength < sizeof(NDISTAPI_REQUEST)) {
                PXDEBUGP(PXD_WARNING, PXM_INIT,  ("IOCTL_SET/QUERY: Invalid BufferLength! len %d needed %d\n",
                inputBufferLength, sizeof(NDISTAPI_REQUEST)));

                ntStatus = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            ndisTapiRequest = ioBuffer;

            targetDeviceID = ndisTapiRequest->ulDeviceID;

            InfoSize = sizeof(NDISTAPI_REQUEST);

            PXDEBUGP(PXD_LOUD, PXM_INIT, (
                           "NdisTapiRequest: Irp: %p Oid: %x, devID: %d, reqID: %x\n",
                           Irp,
                           ndisTapiRequest->Oid,
                           ndisTapiRequest->ulDeviceID,
                           *((ULONG *)ndisTapiRequest->Data)));

            n = ndisTapiRequest->Oid - OID_TAPI_ACCEPT;

            if (n > MAX_TAPI_SUPPORTED_OIDS) {
                PXDEBUGP(PXD_WARNING,PXM_INIT, ("IOCTL_SET/QUERY: Invalid OID %x index %d\n",
                ndisTapiRequest->Oid, n));

                ndisTapiRequest->ulReturnValue = NDIS_STATUS_TAPI_INVALPARAM;
                ntStatus = STATUS_SUCCESS;
                break; // out of switch
            }

            //
            // defensive check that data buffer size is not bad
            //
            if (ndisTapiRequest->ulDataSize < TapiOids[n].SizeofStruct) {
                PXDEBUGP(PXD_WARNING, PXM_INIT, ("IOCTL_SET/QUERY: Invalid BufferLength2! len %d needed %d\n",
                    ndisTapiRequest->ulDataSize, TapiOids[n].SizeofStruct));
                ndisTapiRequest->ulReturnValue  = NDIS_STATUS_TAPI_STRUCTURETOOSMALL;
                ntStatus = STATUS_SUCCESS;
                break;
            }

            //
            //  Make sure the IRP contained sufficient data.
            //
            if (ndisTapiRequest->ulDataSize >
                inputBufferLength - FIELD_OFFSET(NDISTAPI_REQUEST, Data[0])) {
                PXDEBUGP(PXD_WARNING, PXM_INIT, ("IOCTL_SET/QUERY: Invalid BufferLength3! len %d needed %d\n",
                    ndisTapiRequest->ulDataSize, inputBufferLength - FIELD_OFFSET(NDISTAPI_REQUEST, Data[0])));
                ndisTapiRequest->ulReturnValue  = NDIS_STATUS_TAPI_STRUCTURETOOSMALL;
                ntStatus = STATUS_SUCCESS;
                break;
            }

            NdisAcquireSpinLock (&TspCB.Lock);

            //
            // Are we initialized with TAPI?
            //
            if (TspCB.Status != NDISTAPI_STATUS_CONNECTED) {
                PXDEBUGP(PXD_WARNING, PXM_INIT, ("TAPI not connected, returning err\n"));

                NdisReleaseSpinLock(&TspCB.Lock);

                ndisTapiRequest->ulReturnValue = NDISTAPIERR_UNINITIALIZED;
                ntStatus = STATUS_SUCCESS;
                break;
            }

            //
            // Get a unique ID for this request -- value between 1 and fffffffe.
            // (Can't use the TAPI ID in case it's spoofed)
            //

            if (++TspCB.ulUniqueId > 0xfffffffe) {
                TspCB.ulUniqueId = 0x80000001;
            }

            RequestId =
            ndisTapiRequest->ulUniqueRequestId =
                TspCB.ulUniqueId;

            ndisTapiRequest->Irp = Irp;

            NdisReleaseSpinLock (&TspCB.Lock);

            //
            // Mark the TAPI request pending
            //
            IoMarkIrpPending(Irp);
            ntStatus = STATUS_PENDING;

            //
            // Dispatch the request
            //
            ndisStatus =
                (*TapiOids[n].FuncPtr)(ndisTapiRequest);

            if (ndisStatus == NDIS_STATUS_PENDING) {

                PXDEBUGP (PXD_LOUD, PXM_INIT, ("IOCTL_TAPI_SET/QUERY_INFO: reqProc returning PENDING\n" ));

                return (STATUS_PENDING);
            }

            //
            // Something other then pending was returned so complete
            // the irp
            //
            InfoSize = MIN (outputBufferLength,
                            sizeof(NDISTAPI_REQUEST)+ndisTapiRequest->ulDataSize);
            //
            // Set the TAPI return status
            //
            ndisTapiRequest->ulReturnValue = ndisStatus;

            IoSetCancelRoutine(Irp, NULL);

            ntStatus = STATUS_SUCCESS;

            break;
        }

        case IOCTL_NDISTAPI_GET_LINE_EVENTS:
        {
            KIRQL   oldIrql;
            KIRQL   cancelIrql;
            PNDISTAPI_EVENT_DATA    ndisTapiEventData = ioBuffer;

            PXDEBUGP(PXD_VERY_LOUD, PXM_INIT, ("IOCTL_NDISTAPI_GET_LINE_EVENTS\n"));

            //
            // Defensive check that the input buffer is at least
            // the size of the request,
            // and that we can move at least one event
            //
            if (inputBufferLength < sizeof (NDISTAPI_EVENT_DATA)) {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                InfoSize = sizeof (ULONG);
                PXDEBUGP(PXD_WARNING, PXM_INIT, ("IOCTL_NDISTAPI_GET_LINE_EVENTS: buffer too small\n"));
                break;
            }

            if (outputBufferLength - sizeof(NDISTAPI_EVENT_DATA) + 1 <  ndisTapiEventData->ulTotalSize) {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                InfoSize = sizeof (ULONG);
                PXDEBUGP(PXD_WARNING, PXM_INIT, ("IOCTL_NDISTAPI_GET_LINE_EVENTS: buffer too small\n"));
                break;
            }

            //
            // Sync event buf access by acquiring EventSpinLock
            //
            NdisAcquireSpinLock(&TspEventList.Lock);

            //
            // Is there any data available?
            //
            if (TspEventList.Count != 0) {
                //
                // There's line event data queued in our ring buffer. Grab as
                // much as we can & complete the request.
                //
                PXDEBUGP(PXD_VERY_LOUD, PXM_INIT, 
                         ("IOCTL_NDISTAPI_GET_LINE_EVENTS: event count = x%x, IoBuffer->TotalSize = %x\n", 
                          TspEventList.Count, ndisTapiEventData->ulTotalSize));

                ndisTapiEventData->ulUsedSize =
                    GetLineEvents(ndisTapiEventData->Data,
                                  ndisTapiEventData->ulTotalSize);

                ntStatus = STATUS_SUCCESS;
                InfoSize =
                    MIN (outputBufferLength, ((ndisTapiEventData->ulUsedSize) + sizeof(NDISTAPI_EVENT_DATA) - 1));

            } else {
                PXDEBUGP(PXD_VERY_LOUD, PXM_INIT, ("IOCTL_NDISTAPI_GET_LINE_EVENTS: no events in queue\n"));

                //
                // Hold the request pending.  It remains in the cancelable
                // state.  When new line event input is received or generated (i.e.
                // LINEDEVSTATE_REINIT) the data will get copied & the
                // request completed.
                //

                if (NULL == TspEventList.RequestIrp) {

                    IoSetCancelRoutine (Irp, PxCancelGetEvents);

                    IoMarkIrpPending (Irp);

                    Irp->IoStatus.Status = STATUS_PENDING;

                    Irp->IoStatus.Information = 0;

                    TspEventList.RequestIrp = Irp;

                    ntStatus = STATUS_PENDING;

                } else {
                    ntStatus = STATUS_UNSUCCESSFUL;
                    InfoSize = sizeof (ULONG);
                }
            }

            NdisReleaseSpinLock(&TspEventList.Lock);

            break;
        }

        case IOCTL_NDISTAPI_SET_DEVICEID_BASE:
        {
            ULONG   BaseId;

            PXDEBUGP(PXD_INFO, PXM_INIT, ("IOCTL_NDISTAPI_SET_DEVICEID_BASE, Irp=x%x, inputBufLen = %x\n", Irp, inputBufferLength ));

            //
            // Someone's connecting. Make sure they passed us a valid
            // info buffer
            //
            if ((inputBufferLength < sizeof(ULONG))) {
                PXDEBUGP (PXD_WARNING, PXM_INIT, ("IOCTL_NDISTAPI_SET_DEVICEID_BASE: buffer too small\n"));

                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            NdisAcquireSpinLock(&TspCB.Lock);

            if (TspCB.Status != NDISTAPI_STATUS_CONNECTED) {
                PXDEBUGP (PXD_WARNING, PXM_INIT, ("IOCTL_NDISTAPI_SET_DEVICEID_BASE: Disconnected\n"));
                ntStatus = STATUS_UNSUCCESSFUL;
                NdisReleaseSpinLock(&TspCB.Lock);
                break;
            }

            //
            // Set the base ID
            //
            BaseId = *((ULONG *) ioBuffer);

            PXDEBUGP(PXD_LOUD, PXM_INIT, ("BaseID %d\n", BaseId));

            NdisReleaseSpinLock(&TspCB.Lock);

            {
                LOCK_STATE      LockState;
                ULONG           i;

                //
                // Update the deviceId's for each line on the provider
                //
                NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

                for (i = 0; i < LineTable.Size; i++) {
                    PPX_TAPI_LINE   TapiLine;

                    TapiLine = LineTable.Table[i];

                    if ((TapiLine != NULL)) {

                        TapiLine->ulDeviceID = BaseId++;
                    }
                }

                NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
            }

            InfoSize = 0;
            ntStatus = STATUS_SUCCESS;
            break;
        }

        case IOCTL_NDISTAPI_CREATE:
        {
            PPX_TAPI_PROVIDER       Provider;
            PNDISTAPI_CREATE_INFO   CreateInfo;
            PPX_TAPI_LINE           TapiLine;

            InfoSize = 0;

            if (inputBufferLength < sizeof(CreateInfo)) {
                PXDEBUGP(PXD_WARNING, PXM_INIT, ("IOCTL_NDISTAPI_CREATE: buffer too small\n"));

                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            CreateInfo = (PNDISTAPI_CREATE_INFO)ioBuffer;

            if (!IsTapiLineValid(CreateInfo->TempID, &TapiLine)) {
                PXDEBUGP(PXD_WARNING, PXM_INIT, 
                         ("IOCTL_NDISTAPI_CREATE: Failed to find Id %d\n",
                          CreateInfo->TempID));
                ntStatus = STATUS_INVALID_PARAMETER;
                break;
            }

            PXDEBUGP(PXD_LOUD, PXM_INIT, 
                     ("IOCTL_NDISTAPI_CREATE: Created new Line %p Id %d\n",
                      TapiLine, CreateInfo->DeviceID));

            TapiLine->ulDeviceID = CreateInfo->DeviceID;

            ntStatus = STATUS_SUCCESS;

            break;
        }

        default:

            ntStatus = STATUS_INVALID_PARAMETER;

            PXDEBUGP(PXD_WARNING, PXM_INIT, ("unknown IRP_MJ_DEVICE_CONTROL\n"));

            break;

    } // switch

    //
    // Complete this IRP synchronously if we are done.
    //
    if (ntStatus != STATUS_PENDING) {
        PIO_STACK_LOCATION  IrpSp;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = InfoSize;
        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        IrpSp->Control &= ~SL_PENDING_RETURNED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    PXDEBUGP(PXD_VERY_LOUD, PXM_INIT, ("PxDispatch: Completing Irp %p (Status %x) synchronously\n", Irp, ntStatus));


    return ntStatus;
}

NTSTATUS
PxIOCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for cleanup requests.
    All requests queued are completed with STATUS_CANCELLED.

Arguments:

    DeviceObject - Pointer to device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIRP    MyIrp;

    PXDEBUGP(PXD_LOUD, PXM_INIT, ("PxIOCleanup: enter\n"));

    NdisAcquireSpinLock (&TspEventList.Lock);

    //
    // Cancel the EventRequest Irp
    //
    MyIrp = TspEventList.RequestIrp;

    if ((MyIrp != NULL) &&
        (MyIrp->Tail.Overlay.OriginalFileObject == 
         Irp->Tail.Overlay.OriginalFileObject)) {

        if (IoSetCancelRoutine(MyIrp, NULL) != NULL) {
            TspEventList.RequestIrp = NULL;
            MyIrp->IoStatus.Status = STATUS_CANCELLED;
            MyIrp->IoStatus.Information = 0;
            NdisReleaseSpinLock(&TspEventList.Lock);
            IoCompleteRequest(MyIrp, IO_NO_INCREMENT);
            NdisAcquireSpinLock(&TspEventList.Lock);
        }
    }

    //
    // Cancel any Set/Query Irp's
    //

    NdisReleaseSpinLock(&TspEventList.Lock);

    //
    // Complete the cleanup request with STATUS_SUCCESS.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    PXDEBUGP (PXD_LOUD, PXM_INIT, ("PxIOCleanup: exit\n"));

    return(STATUS_SUCCESS);
}

VOID
PxCancelGetEvents(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIRP    MyIrp;

    PXDEBUGP(PXD_LOUD, PXM_INIT, 
             ("PxCancelGetEvents: enter. Irp = %x\n", Irp));

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // Acquire the EventSpinLock & check to see if we're canceling a
    // pending get-events Irp
    //
    NdisAcquireSpinLock (&TspEventList.Lock);

    MyIrp = TspEventList.RequestIrp;
    TspEventList.RequestIrp = NULL;

    NdisReleaseSpinLock(&TspEventList.Lock);

    if (MyIrp != NULL) {

        ASSERT(MyIrp == Irp);

        //
        // Don't let it get cancelled again
        //
        IoSetCancelRoutine (MyIrp, NULL);

        MyIrp->IoStatus.Status = STATUS_CANCELLED;
        MyIrp->IoStatus.Information = 0;

        IoCompleteRequest (MyIrp, IO_NO_INCREMENT);
    }
}

VOID
PxCancelSetQuery(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    BOOLEAN Found = FALSE;
    LOCK_STATE  LockState;
    PPX_VC  pVc;
    PIRP    MyIrp;

    PXDEBUGP(PXD_LOUD, PXM_INIT, 
             ("PxCancelSetQuery: enter. Irp = %x\n", Irp));

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // We must search through the Vc's in the Vc table
    // and find the pending ndisrequest!
    //
    NdisAcquireReadWriteLock(&VcTable.Lock, FALSE, &LockState);

    pVc = (PPX_VC)VcTable.List.Flink;

    while ((PVOID)pVc != (PVOID)&VcTable.List) {
        PLIST_ENTRY         Entry;
        PNDISTAPI_REQUEST   Request;

        NdisAcquireSpinLock(&pVc->Lock);

        Entry = pVc->PendingDropReqs.Flink;

        while (Entry != &pVc->PendingDropReqs) {

            Request = 
                CONTAINING_RECORD(Entry, NDISTAPI_REQUEST, Linkage);

            MyIrp = Request->Irp;

            if (MyIrp->Cancel) {
                Found = TRUE;
                RemoveEntryList(&Request->Linkage);
                break;
            }

            Entry = Entry->Flink;
        }

        if (!Found) {
            if (pVc->PendingGatherDigits != NULL) {
                MyIrp = pVc->PendingGatherDigits->Irp;

                if (MyIrp->Cancel) {
                    Found = TRUE;
                    pVc->PendingGatherDigits = NULL;
                }
            }
        }

        NdisReleaseSpinLock(&pVc->Lock);

        if (Found) {
            break;
        }

        pVc = (PPX_VC)pVc->Linkage.Flink;
    }

    NdisReleaseReadWriteLock(&VcTable.Lock, &LockState);

    if (Found) {

        //
        // Don't let it get cancelled again
        //
        IoSetCancelRoutine (MyIrp, NULL);
        MyIrp->IoStatus.Status = STATUS_CANCELLED;
        MyIrp->IoStatus.Information = 0;

        IoCompleteRequest (MyIrp, IO_NO_INCREMENT);
    }

    PXDEBUGP(PXD_INFO, PXM_INIT, ("PxIOCancel: completing Irp=%p\n", Irp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\pxtapi.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pxtapi.c

Abstract:

    The module contains the TAPI-specific code for the NDIS Proxy.

Author:

   Richard Machin (RMachin)

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    RMachin     01-08-97    created (after Dan Knudson's NdisTapi)
    TonyBe      02-21-99    re-work/re-write

Notes:

--*/

#include <precomp.h>
#include <stdio.h>
#define MODULE_NUMBER MODULE_TAPI
#define _FILENUMBER 'IPAT'

ULONG
GetLineEvents(
    PCHAR   EventBuffer,
    ULONG   BufferSize
    )

/*++

Routine Description:

  Gets event data out of our global event queue and writes it to the buffer. Data is put into the queue
  by PxIndicateStatus (above).


Arguments:

    EventBuffer     pointer to a buffer of size BufferSize
    BufferSize      size of event buffer (expected to be 1024)

Return Value:



Note:

    Assumes TspEventList.Lock held by caller.

--*/

{
    ULONG   BytesLeft;
    ULONG   BytesMoved = 0;

    BytesLeft = BufferSize;

    while (!(IsListEmpty(&TspEventList.List))) {

        PPROVIDER_EVENT ProviderEvent;

        if (BytesLeft < sizeof(NDIS_TAPI_EVENT)) {
            break;
        }

        ProviderEvent = (PPROVIDER_EVENT)
            RemoveHeadList(&TspEventList.List);

        TspEventList.Count--;

        RtlMoveMemory(EventBuffer + BytesMoved,
                      (PUCHAR)&ProviderEvent->Event,
                      sizeof(NDIS_TAPI_EVENT));

        BytesMoved += sizeof(NDIS_TAPI_EVENT);
        BytesLeft -= sizeof(NDIS_TAPI_EVENT);

        ExFreeToNPagedLookasideList(&ProviderEventLookaside,
                                    ProviderEvent);
    }

    return (BytesMoved);
}

NDIS_STATUS
PxTapiMakeCall(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
/*++

Routine Description:

    TSPI_lineMakeCall handler.

Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_MAKE_CALL    TapiBuffer =
        (PNDIS_TAPI_MAKE_CALL)(pNdisTapiRequest->Data);

    LINE_CALL_PARAMS*       pTapiCallParams =
        (LINE_CALL_PARAMS*)(&TapiBuffer->LineCallParams);

    PPX_TAPI_LINE           TapiLine;
    PPX_TAPI_ADDR           TapiAddr;
    PPX_VC                  pVc = NULL;
    PPX_CL_AF               pClAf;
    PCO_CALL_PARAMETERS     pNdisCallParams = 0;
    NDIS_STATUS             Status  = NDIS_STATUS_SUCCESS;
    ULONG                   targetDeviceID = 0;
    LPCWSTR                 lpcwszTemp;
    PPX_ADAPTER             pAdapter;
    PPX_TAPI_PROVIDER       TapiProvider;

    lpcwszTemp = (LPWSTR)
        (((UCHAR *) TapiBuffer) + TapiBuffer->ulDestAddressOffset);

    PXDEBUGP(PXD_TAPI, PXM_TAPI, 
             ("TapiMakeCall: DialAddress in Tapi buffer %x = %ls\n",lpcwszTemp, lpcwszTemp));

    if (!IsTapiLineValid((ULONG)TapiBuffer->hdLine, &TapiLine)) {

        PXDEBUGP (PXD_WARNING, PXM_TAPI, 
                  ("PxTapiMakeCall: NDISTAPIERR_BADDEVICEID: line = %x\n", TapiBuffer->hdLine));

        return (NDISTAPIERR_BADDEVICEID);
    }

    do {

        NdisAcquireSpinLock(&TapiLine->Lock);

        //
        // Is this line in service? (does it have an valid af?)
        //
        if (!(TapiLine->DevStatus->ulDevStatusFlags & 
              LINEDEVSTATUSFLAGS_INSERVICE)) {
            PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                      ("PxTapiMakeCall: Line not in service!\n"));
            NdisReleaseSpinLock(&TapiLine->Lock);
            Status = NDISTAPIERR_DEVICEOFFLINE;
            break;
        }

        PXDEBUGP (PXD_TAPI, PXM_TAPI,
            ("PxTapiMakeCall: got device x%x from ID %d\n", TapiLine, TapiBuffer->hdLine));

        if (pTapiCallParams->ulAddressMode == LINEADDRESSMODE_ADDRESSID) {

            //
            // Get the specificed address from the address id
            //
            if (!IsAddressValid(TapiLine, pTapiCallParams->ulAddressID, &TapiAddr)) {
                Status = NDISTAPIERR_BADDEVICEID;
                NdisReleaseSpinLock(&TapiLine->Lock);
                break;
            }

        } else {

            //
            // Get the first available address
            //
            TapiAddr =
                GetAvailAddrFromLine(TapiLine);

            if (TapiAddr == NULL) {
                Status = NDISTAPIERR_BADDEVICEID;
                NdisReleaseSpinLock(&TapiLine->Lock);
                break;
            }
        }

        TapiProvider = TapiLine->TapiProvider;
        pAdapter = TapiProvider->Adapter;
        pClAf = TapiLine->ClAf;

        NdisReleaseSpinLock(&TapiLine->Lock);

        NdisAcquireSpinLock(&pClAf->Lock);

        //
        // Allocate a Vc block.  This will create the block
        // with refcount = 1.
        //
        pVc = PxAllocateVc(pClAf);

        if (pVc == NULL) {
            PXDEBUGP (PXD_WARNING, PXM_TAPI, ("PxTapiMakeCall: failed to allocate a vc\n"));
            NdisReleaseSpinLock(&pClAf->Lock);
            Status = NDIS_STATUS_TAPI_RESOURCEUNAVAIL;
            break;
        }

        NdisReleaseSpinLock(&pClAf->Lock);

        Status =
            AllocateTapiCallInfo(pVc, NULL);

        if (Status != NDIS_STATUS_SUCCESS) {
            PXDEBUGP (PXD_WARNING, PXM_TAPI, ("PxTapiMakeCall: Error allocating TapiCallInfo!\n"));
            PxFreeVc(pVc);
            Status = NDIS_STATUS_TAPI_RESOURCEUNAVAIL;
            break;
        }

        pVc->TapiLine = TapiLine;
        pVc->TapiAddr = TapiAddr;
        InterlockedIncrement((PLONG)&TapiAddr->CallCount);
        InterlockedIncrement((PLONG)&TapiLine->DevStatus->ulNumActiveCalls);

        pVc->htCall = TapiBuffer->htCall;

        pVc->CallInfo->ulLineDeviceID = TapiLine->CmLineID;
        pVc->CallInfo->ulAddressID = TapiAddr->AddrId;
        pVc->CallInfo->ulOrigin = LINECALLORIGIN_OUTBOUND;

        //
        // Set up intended bearer and media mode
        //
        pVc->CallInfo->ulBearerMode =
            pTapiCallParams->ulBearerMode;

        pVc->CallInfo->ulMediaMode =
            pTapiCallParams->ulMediaMode;

        if (pTapiCallParams->ulMaxRate == 0) {

            pVc->CallInfo->ulRate =
                TapiLine->DevCaps->ulMaxRate;

        } else {

            pVc->CallInfo->ulRate =
                pTapiCallParams->ulMaxRate;
        }

        if (!InsertVcInTable(pVc)) {
            PXDEBUGP (PXD_WARNING, PXM_TAPI,
                ("PxTapiMakeCall: failed to insert in vc table\n"));

            PxFreeVc(pVc);
            Status = NDIS_STATUS_TAPI_RESOURCEUNAVAIL;
            break;
        }

        //
        // Our call handle is an index into the call table
        //
        TapiBuffer->hdCall = (HDRV_CALL)pVc->hdCall;

        Status = NdisCoCreateVc(pAdapter->ClBindingHandle,
                                pClAf->NdisAfHandle,
                                (NDIS_HANDLE)pVc->hdCall,
                                &pVc->ClVcHandle);


        if (Status != NDIS_STATUS_SUCCESS) {
            RemoveVcFromTable(pVc);
            PxFreeVc(pVc);
            Status = NDIS_STATUS_TAPI_CALLUNAVAIL;
            break;
        }

        //
        // Move (AF-specific) call parameters into  NdisCallParams structure
        //
        Status =
            (*pClAf->AfGetNdisCallParams)(pVc,
                                          TapiLine->CmLineID,
                                          TapiAddr->AddrId,
                                          CO_TAPI_FLAG_OUTGOING_CALL,
                                          TapiBuffer,
                                          &pNdisCallParams);

        if (Status != NDIS_STATUS_SUCCESS) {
            PXDEBUGP (PXD_WARNING, PXM_TAPI,
                ("PxTapiMakeCall: failed to move call params: Status %x\n", Status));

            NdisCoDeleteVc(pVc->ClVcHandle);
            RemoveVcFromTable(pVc);
            PxFreeVc(pVc);
            Status = NDIS_STATUS_TAPI_INVALCALLPARAMS;
            break;
        }

        // Store Call Params for when lineGetID dispatches an incoming call...
        //
        NdisAcquireSpinLock(&pVc->Lock);

        pVc->pCallParameters = pNdisCallParams;
        pVc->PrevState = pVc->State;
        pVc->State = PX_VC_PROCEEDING;
        pVc->Flags |= PX_VC_OWNER;

        //
        // Ref applied ndis part of the make call.  
        // This ref is removed in PxClCloseCallComplete or 
        // PxClMakeCallComplete in the case of a make call
        // failure.
        //
        REF_VC(pVc);

        //
        // Indicate call state change to TAPI
        //
        SendTapiCallState(pVc, 
                          LINECALLSTATE_PROCEEDING, 
                          0, 
                          pVc->CallInfo->ulMediaMode);

        NdisReleaseSpinLock(&pVc->Lock);

        Status =
            NdisClMakeCall(pVc->ClVcHandle,
                           pVc->pCallParameters,
                           NULL,
                           NULL);

        if (Status != NDIS_STATUS_PENDING) {

            PxClMakeCallComplete(Status,
                                 (NDIS_HANDLE)pVc->hdCall,
                                 NULL,
                                 pVc->pCallParameters);
        }

        Status = NDIS_STATUS_SUCCESS;

    } // end of do loop

    while (FALSE);

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiMakeCall: exit Status %x\n", Status));

    DEREF_TAPILINE(TapiLine);

    return Status;
}

NDIS_STATUS
PxTapiGetDevCaps(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Stick the appropriate device info into the request buffer.

    Arguments:

    Request -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PPX_TAPI_LINE   TapiLine = NULL;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PNDIS_TAPI_GET_DEV_CAPS pNdisTapiGetDevCaps =
        (PNDIS_TAPI_GET_DEV_CAPS) pNdisTapiRequest->Data;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetDevCaps: enter\n"));

    if (!IsTapiDeviceValid(pNdisTapiGetDevCaps->ulDeviceID, &TapiLine)) {
        PXDEBUGP (PXD_WARNING, PXM_TAPI,
            ( "PxTapiGetDevCaps: NDISTAPIERR_BADDEVICEID: line = %x\n",
            pNdisTapiGetDevCaps->ulDeviceID));
        return(NDISTAPIERR_BADDEVICEID);
    }

    NdisAcquireSpinLock(&TapiLine->Lock);

    do {

        ULONG   SizeDevCaps;
        ULONG   DevClassesSize = 0;
        USHORT  DevClassesList[512];
        WCHAR   LineName[128];
        ULONG   LineNameSize = 0;
        WCHAR   ProviderInfo[128];
        ULONG   ProviderInfoSize = 0;
        PLINE_DEV_CAPS  ldc;
        PPX_ADAPTER ClAdapter;
        ULONG   SizeToMove;
        LONG    SizeLeft;
        PUCHAR  dst;
        ULONG   TotalSize;

        //
        // Synchronously get dev caps for this device
        //

        ClAdapter = TapiLine->TapiProvider->Adapter;

        ldc = TapiLine->DevCaps;

        SizeDevCaps = ldc->ulUsedSize;

        //
        // Add some space for our providerinfo if needed
        //
        if (ldc->ulProviderInfoSize == 0) {

            NdisZeroMemory(ProviderInfo, sizeof(ProviderInfo));

            ProviderInfoSize = wcslen(L"NDPROXY") * sizeof(WCHAR);

            NdisMoveMemory((PUCHAR)ProviderInfo, 
                           L"NDPROXY", 
                           ProviderInfoSize);

            //
            // For NULL termination
            //
            ProviderInfoSize += sizeof(UNICODE_NULL);

            SizeDevCaps += ProviderInfoSize;
        }

        //
        // Add some space for our linename if needed
        //
        if ((ldc->ulLineNameSize == 0) &&
            (ClAdapter != NULL) &&
            (ClAdapter->MediaNameLength != 0)) {
            PUCHAR  dstTemp;

            NdisZeroMemory(LineName, sizeof(LineName));

            dstTemp = (PUCHAR)LineName;

            NdisMoveMemory(dstTemp,
                           (PUCHAR)(ClAdapter->MediaName),
                           ClAdapter->MediaNameLength);

            (ULONG_PTR)dstTemp += ClAdapter->MediaNameLength;

            //
            // ToDo! Shoud get the name of the adapter
            // and insert here!
            //

            NdisMoveMemory(dstTemp,
                           L" - Line",
                           wcslen(L" - Line") * sizeof(WCHAR));

            (ULONG_PTR)dstTemp += 
                wcslen(L" - Line") * sizeof(WCHAR);

            (VOID)
            IntegerToWChar(TapiLine->CmLineID,
                          -4,
                          (WCHAR *)dstTemp);

            (ULONG_PTR)dstTemp += 4 * sizeof(WCHAR);

            LineNameSize = (ULONG)((ULONG_PTR)dstTemp - (ULONG_PTR)LineName);

            //
            // For NULL termination
            //
            LineNameSize += sizeof(UNICODE_NULL);

            SizeDevCaps += LineNameSize;
        }

        //
        // Add some space for our device classes
        //
        DevClassesSize = sizeof(DevClassesList);
        NdisZeroMemory((PUCHAR)DevClassesList, 
                       sizeof(DevClassesList));

        if (ClAdapter != NULL) {
            GetAllDevClasses(ClAdapter,
                             DevClassesList,
                             &DevClassesSize);
        }

        SizeDevCaps += DevClassesSize;

        ldc = &pNdisTapiGetDevCaps->LineDevCaps;

        SizeToMove = (TapiLine->DevCaps->ulUsedSize > ldc->ulTotalSize) ?
            ldc->ulTotalSize : TapiLine->DevCaps->ulUsedSize;

        SizeLeft = ldc->ulTotalSize - SizeToMove;

        //
        // Save the total size
        //
        TotalSize = ldc->ulTotalSize;

        PXDEBUGP(PXD_TAPI, PXM_TAPI,
                 ("PxTapiGetDevCaps: got device %x from ID %d: moving %d bytes\n",
                  TapiLine,
                  pNdisTapiGetDevCaps->ulDeviceID,
                  SizeToMove));

        NdisMoveMemory((PUCHAR)ldc,
                       (PUCHAR)TapiLine->DevCaps,
                       SizeToMove);

        ldc->ulNeededSize = SizeDevCaps;
        ldc->ulTotalSize = TotalSize;
        ldc->ulUsedSize = SizeToMove;

        if (SizeLeft > 0) {

            //
            // If there is no provider info fill our proxy info
            //
            if (ldc->ulProviderInfoSize == 0) {

                dst = (PUCHAR)ldc + ldc->ulUsedSize;

                SizeToMove = (SizeLeft > (LONG)ProviderInfoSize) ?
                    ProviderInfoSize : SizeLeft;

                NdisMoveMemory(dst,
                               (PUCHAR)ProviderInfo,
                               SizeToMove);

                ldc->ulProviderInfoSize = SizeToMove;
                ldc->ulProviderInfoOffset = (ULONG)((ULONG_PTR)dst-(ULONG_PTR)ldc);
                ldc->ulUsedSize += SizeToMove;

                SizeLeft -= SizeToMove;
            }
        }

        if (SizeLeft > 0) {
            //
            // If these is no line name fill in our line name
            //
            if (ldc->ulLineNameSize == 0 &&
                ClAdapter != NULL &&
                ClAdapter->MediaNameLength != 0) {

                dst = (PUCHAR)ldc + ldc->ulUsedSize;

                SizeToMove = (SizeLeft > (LONG)LineNameSize) ?
                    LineNameSize : SizeLeft;

                NdisMoveMemory(dst,
                               (PUCHAR)LineName,
                               SizeToMove);

                ldc->ulLineNameSize = SizeToMove;
                ldc->ulLineNameOffset = (ULONG)((ULONG_PTR)dst-(ULONG_PTR)ldc);
                ldc->ulUsedSize += SizeToMove;

                SizeLeft -= SizeToMove;
            }
        }

        if (SizeLeft > 0) {
            //
            // Add the devclasses to the end
            //
            if (DevClassesSize > 0) {

                dst = (PUCHAR)ldc + ldc->ulUsedSize;

                SizeToMove = (SizeLeft > (LONG)DevClassesSize) ?
                    DevClassesSize : SizeLeft;

                NdisMoveMemory(dst,
                               DevClassesList,
                               SizeToMove);

                ldc->ulDeviceClassesSize = SizeToMove;
                ldc->ulDeviceClassesOffset = (ULONG)((ULONG_PTR)dst-(ULONG_PTR)ldc);
                ldc->ulUsedSize += SizeToMove;

                SizeLeft -= SizeToMove;
            }
        }

    } while (FALSE);

    DEREF_TAPILINE_LOCKED(TapiLine);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetDevCaps: exit: used=%d, needed=%d, total=%d\n",
        pNdisTapiGetDevCaps->LineDevCaps.ulUsedSize,
        pNdisTapiGetDevCaps->LineDevCaps.ulNeededSize,
        pNdisTapiGetDevCaps->LineDevCaps.ulTotalSize));

    return (Status);
}

NDIS_STATUS
PxTapiAccept(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiAccept: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiAccept: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiAnswer(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_ANSWER   pNdisTapiAnswer;
    PPX_VC              pVc = NULL;
    NDIS_STATUS         Status;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiAnswer: enter\n"));

    pNdisTapiAnswer =
        (PNDIS_TAPI_ANSWER)pNdisTapiRequest->Data;

    if (!IsVcValid(pNdisTapiAnswer->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiAnswer: pVc invalid call handle %d\n",
                               pNdisTapiAnswer->hdCall));

        return(NDIS_STATUS_TAPI_INVALCALLHANDLE);
    }

    NdisAcquireSpinLock(&pVc->Lock);

    do {

        if (pVc->State != PX_VC_OFFERING) {

            //
            // call in wrong state
            //
            PXDEBUGP(PXD_FATAL, PXM_TAPI, ("PxTapiAnswer: pVc VC %x/%x invalid state %x\n",
                        pVc, pVc->Flags,
                        pVc->ulCallState));

            NdisReleaseSpinLock(&pVc->Lock);

            Status = NDIS_STATUS_TAPI_INVALCALLSTATE;

            break;
        }

        if (pVc->Flags & PX_VC_CALLTIMER_STARTED) {
            PxStopIncomingCallTimeout(pVc);
        }

        PXDEBUGP (PXD_LOUD, PXM_TAPI, 
            ("PxTapiAnswer: calling NdisClIncomingCallComplete\n"));

        pVc->PrevState = pVc->State;
        pVc->State = PX_VC_CONNECTED;

        NdisReleaseSpinLock(&pVc->Lock);

        NdisClIncomingCallComplete (NDIS_STATUS_SUCCESS,
                                    pVc->ClVcHandle,
                                    pVc->pCallParameters);
    } while (FALSE);

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC(pVc);

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiAnswer: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiLineGetID(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

Returns a handle to the client wich is returned to the tapi application.  
This handle is only meaning full to the client and will vary depending
on the deviceclass.

Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_ID   pNdisTapiGetId =
        (PNDIS_TAPI_GET_ID)pNdisTapiRequest->Data;

    PVAR_STRING         DeviceID = &pNdisTapiGetId->DeviceID;
    PPX_VC              pVc = NULL;
    NDIS_HANDLE         VcHandle = NULL;
    PPX_CM_AF           pCmAf;
    PPX_CM_SAP          pCmSap;
    NDIS_STATUS         Status;
    LPCWSTR             DevClass;
    ULONG               DevClassSize;
    PPX_ADAPTER         pAdapter;

    DevClass =
        (LPCWSTR)(((CHAR *)pNdisTapiGetId) + pNdisTapiGetId->ulDeviceClassOffset);

    DevClassSize = pNdisTapiGetId->ulDeviceClassSize;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiLineGetID: enter. CallId %x, DevClass = %ls\n", pNdisTapiGetId->hdCall, DevClass));

    if (pNdisTapiGetId->ulSelect != LINECALLSELECT_CALL) {
        return (NDIS_STATUS_FAILURE);
    }

    //
    // validate call handle and get call pointer
    //
    if (!IsVcValid(pNdisTapiGetId->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxNdisTapiGetId: pVc invalid call handle %d\n",
                               pNdisTapiGetId->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    do {
        //
        // ToDo!
        //
        // If we already are working with a client
        // we need to see if this is a mapping to the same
        // client or to a different one.  If it is to the
        // same one just return the current handle.  If it
        // is to a different one we should either fail or
        // tear the vc hand-off down from the current client
        // and then hand-off to the new client.
        //
        if (pVc->CmVcHandle != NULL) {

            Status = NDIS_STATUS_SUCCESS;

            break;
        }

        if (pVc->State != PX_VC_CONNECTED) {
            Status = NDIS_STATUS_TAPI_INVALCALLSTATE;
            break;
        }

        pAdapter = pVc->Adapter;

        //
        // Find the sap/af of the client that we need to indicate this on
        //
        if (!PxAfAndSapFromDevClass(pAdapter, 
                                    DevClass, 
                                    &pCmAf, 
                                    &pCmSap)) {

            PXDEBUGP(PXD_WARNING, PXM_TAPI,
                ("PxTapiLineGetID: SAP not found!\n"));

            Status = NDIS_STATUS_FAILURE;

            break;
        }

        pVc->HandoffState = PX_VC_HANDOFF_OFFERING;
        pVc->CmAf = pCmAf;
        pVc->CmSap = pCmSap;

        VcHandle = pVc->ClVcHandle;

        NdisReleaseSpinLock(&pVc->Lock);

        //
        // Create the Vc
        //
        Status = NdisCoCreateVc(pAdapter->CmBindingHandle,
                                pCmAf->NdisAfHandle,
                                (NDIS_HANDLE)pVc->hdCall,
                                &VcHandle);

        if (Status != NDIS_STATUS_SUCCESS) {

            PXDEBUGP(PXD_WARNING, PXM_TAPI,
                ("PxTapiLineGetID: Client refused Vc CmAf %p DevClass %ls Status %x\n",
                pCmAf, DevClass, Status));

            Status = NDIS_STATUS_FAILURE;

            //
            // remove ref that was applied when we mapped the devclass
            // to an af/sap.
            //
            DEREF_CM_AF(pCmAf);

            NdisAcquireSpinLock(&pVc->Lock);

            pVc->HandoffState = PX_VC_HANDOFF_IDLE;

            break;
        }

        NdisAcquireSpinLock(&pVc->Lock);

        pVc->CmVcHandle = VcHandle;

        //
        // Apply a reference on the vc for 
        // activating this call with the client.
        // This ref is removed in PxCmCloseCall.
        //
        REF_VC(pVc);

        NdisReleaseSpinLock(&pVc->Lock);

        //
        // Dispatch the incoming call to the client
        //
        Status = 
            NdisCmDispatchIncomingCall(pCmSap->NdisSapHandle,
                                       pVc->CmVcHandle,
                                       pVc->pCallParameters);

        if (Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&pVc->Block);
        }

        if (Status != NDIS_STATUS_SUCCESS) {
            //
            // The client did not except the call
            // delete the vc and go away.
            //
            PXDEBUGP(PXD_WARNING, PXM_TAPI,
                ("PxTapiLineGetID: Client rejected call VC %p, Status %x\n", 
                 pVc, Status));

#ifdef CODELETEVC_FIXED
            //
            // Evidently the CoCreateVc is unbalanced
            // when creating a proxy vc.  The call to 
            // NdisCoDeleteVc will fail because the
            // Vc is still active.
            // ToDo! Investigate this with ndis
            //
            Status =
                NdisCoDeleteVc(pVc->CmVcHandle);

#endif
            //
            // remove ref that was applied when we mapped the devclass
            // to an af/sap.
            //
            DEREF_CM_AF(pCmAf);

            NdisAcquireSpinLock(&pVc->Lock);

#ifdef CODELETEVC_FIXED
            if (Status == NDIS_STATUS_SUCCESS) {
                pVc->CmVcHandle = NULL;
            }
#endif

            pVc->HandoffState = PX_VC_HANDOFF_IDLE;

            //
            // Remove the reference we applied before
            // dispatching incoming call to client.  
            // We do not need to do all of the deref code 
            // because of the ref applied at entry to 
            // this function
            //
            pVc->RefCount--;

            break;
        }

        NdisCmDispatchCallConnected(pVc->CmVcHandle);

        NdisAcquireSpinLock(&pVc->Lock);

        //
        // If we are still in the offering state
        // we can safely move to connected at this 
        // point.  We might not be in offering if
        // right after we connected the client
        // did an NdisClCloseCall before we could
        // reacquire the spinlock.
        //
        if (pVc->HandoffState == PX_VC_HANDOFF_OFFERING) {
            pVc->HandoffState = PX_VC_HANDOFF_CONNECTED;
        }

    } while (FALSE);

    //
    // If we get here and we are not in the connected
    // state something happened to tear our call
    // down with the client.  This could have been
    // an error attempting to create the call with the
    // client or we received either a
    // tapidrop from tapi
    // incomingclosecall from cm
    //
    if (pVc->State != PX_VC_CONNECTED) {

        Status =
            PxCloseCallWithCl(pVc);

        if ((Status != NDIS_STATUS_PENDING) &&
            (pVc->Flags & PX_VC_CLEANUP_CM)) {
            PxCloseCallWithCm(pVc);
        }

        Status = NDIS_STATUS_FAILURE;

    } else if (Status == NDIS_STATUS_SUCCESS) {

        Status = NdisCoGetTapiCallId(pVc->CmVcHandle,
                                     DeviceID);
        //
        // ToDo?: If status is failure here, do we need to do anything? In our
        //          case this should be OK, because the TSP ensures the size of 
        //          the VAR_STRING is right, and that's the only thing that can 
        //          cause a failure. 
        //
    }

    PXDEBUGP(PXD_LOUD, PXM_TAPI,
        ("PxTapiLineGetID: Vc %p, Status %x\n", pVc, Status));

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    return Status;
}

NDIS_STATUS
PxTapiClose (
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI is closing it's handle to our device. We shouldn't see any further requests or
    send any TAPI events after completing this function.

    In the current design, we are the sole owner of all VCs (i.e. there are no 'pass-through' or monitor-only
    functions in the Proxy). TAPI should not call this func before all calls have been closed and all apps
    have disconnected.

   NOTE: this function is also called by TAPI after we send it a LINE_REMOVE message, indicating that
   the adapter has been unbound. In this case, too, we should already have closed all calls/freed VCs and
   associated structures.

    Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_CLOSE    pTapiClose =
        (PNDIS_TAPI_CLOSE)pNdisTapiRequest->Data;

    PPX_TAPI_LINE       TapiLine;
    PPX_VC              pVc;
    PPX_TAPI_PROVIDER   TapiProvider;
    PPX_CL_SAP          pClSap;
    PPX_CL_AF           pClAf;
    NDIS_STATUS         Status;


    PXDEBUGP(PXD_TAPI, PXM_TAPI, 
             ("PxTapiClose: ID: %d\n", pTapiClose->hdLine));

    //
    // validate line handle and get line pointer
    //
    if (!IsTapiLineValid((ULONG)pTapiClose->hdLine, &TapiLine)) {
        PXDEBUGP (PXD_WARNING, PXM_TAPI, ("PxTapiClose: NDISTAPIERR_BADDEVICEID: line = %x\n", pTapiClose->hdLine));
        return (NDISTAPIERR_BADDEVICEID);
    }

    NdisAcquireSpinLock(&TapiLine->Lock);

    TapiLine->DevStatus->ulNumOpens--;

    if (TapiLine->DevStatus->ulNumOpens != 0) {
        NdisReleaseSpinLock(&TapiLine->Lock);
        return (NDIS_STATUS_SUCCESS);
    }

    pClAf = TapiLine->ClAf;
    pClSap = TapiLine->ClSap;
    TapiLine->ClSap = NULL;

    TapiLine->DevStatus->ulOpenMediaModes = 0;

    NdisReleaseSpinLock(&TapiLine->Lock);

    //
    // If we have any active Vc's on this line we need
    // tear them down.
    //
    if (pClAf != NULL) {
        NdisAcquireSpinLock(&pClAf->Lock);

        REF_CL_AF(pClAf);

#if 0
        while (!IsListEmpty(&pClAf->VcList)) {
            PLIST_ENTRY         Entry;
            PPX_VC              pActiveVc;

            Entry = RemoveHeadList(&pClAf->VcList);

            InsertHeadList(&pClAf->VcClosingList, Entry);

            pActiveVc = 
                CONTAINING_RECORD(Entry, PX_VC, ClAfLinkage);

            NdisReleaseSpinLock(&pClAf->Lock);

            NdisAcquireSpinLock(&pActiveVc->Lock);

            if (!(pActiveVc->CloseFlags & PX_VC_TAPI_CLOSE)) {

                REF_VC(pActiveVc);

                pActiveVc->CloseFlags |= PX_VC_TAPI_CLOSE;

                PxVcCleanup(pActiveVc, 0);

                PxTapiCompleteAllIrps(pActiveVc, NDIS_STATUS_SUCCESS);

                //
                // Remove the ref applied in the make call or call offering
                // indication.  We do not need the full deref code because
                // of the ref applied at entry.
                //
                pActiveVc->RefCount--;

                DEREF_VC_LOCKED(pActiveVc);
            }

            NdisAcquireSpinLock(&pClAf->Lock);
        }
#endif
        //
        // If we have a sap registered on this line we need
        // to close it.
        //
        if (pClSap != NULL) {

            // If the SAP is opened then we need to close it
            if (pClSap->State == PX_SAP_OPENED) {

                RemoveEntryList(&pClSap->Linkage);

                InsertTailList(&pClAf->ClSapClosingList, &pClSap->Linkage);

                NdisReleaseSpinLock(&pClAf->Lock);

                InterlockedExchange((PLONG)&pClSap->State, PX_SAP_CLOSING);

                Status = NdisClDeregisterSap(pClSap->NdisSapHandle);

                if (Status != NDIS_STATUS_PENDING) {
                    PxClDeregisterSapComplete(Status, pClSap);
                }

                NdisAcquireSpinLock(&pClAf->Lock);
            }

        }

        DEREF_CL_AF_LOCKED(pClAf);
    }

    DEREF_TAPILINE(TapiLine);

    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiCloseCall(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

     for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    NDIS_STATUS     Status;
    PNDIS_TAPI_CLOSE_CALL pNdisTapiCloseCall =
        (PNDIS_TAPI_CLOSE_CALL)pNdisTapiRequest->Data;

    PPX_VC              pVc;
    PPX_TAPI_LINE       TapiLine;


    if (!IsVcValid(pNdisTapiCloseCall->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiCloseCall: invalid call handle %d\n",
                               pNdisTapiCloseCall->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    PXDEBUGP (PXD_TAPI, PXM_TAPI, 
              ("PxTapiCloseCall: enter. VC = %x, State = %x\n", 
               pVc, pVc->State));

    NdisAcquireSpinLock(&pVc->Lock);

    pVc->CloseFlags |= PX_VC_TAPI_CLOSECALL;

    //
    // Check the Vc state and act accordingly
    //
    PxVcCleanup(pVc, 0);

    PxTapiCompleteAllIrps(pVc, NDIS_STATUS_SUCCESS);

    //
    // Remove the ref applied in the make call or call offering
    // indication.  We do not need the full deref code because
    // of the ref applied at entry.
    //
    pVc->RefCount--;

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiCloseCall: exit.\n"));

    return (NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
PxTapiConditionalMediaDetection(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiConditionalMediaDetection: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiConditionalMediaDetection: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiConfigDialog (
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiConfigDialog: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiConfigDialog: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiDevSpecific(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    D for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiDevSpecific: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiDevSpecific: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiDial(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiDial: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiDial: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiDrop(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
/*++

Routine Description:

   Drop the call without deallocating the VC.

Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PPX_VC          pVc;
    PIRP            Irp;

    PNDIS_TAPI_DROP pNdisTapiDrop =
        (PNDIS_TAPI_DROP)pNdisTapiRequest->Data;

    if (!IsVcValid(pNdisTapiDrop->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiDrop: invalid call handle %d\n",
                               pNdisTapiDrop->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    PXDEBUGP(PXD_TAPI, PXM_TAPI, 
             ("PxTapiDrop enter: Vc: %p VcState: %x CallState: %x\n", pVc, pVc->State, pVc->ulCallState ));

    NdisAcquireSpinLock(&pVc->Lock);
    
    if(pVc->CloseFlags & PX_VC_TAPI_DROP)
    {
        DEREF_VC_LOCKED(pVc);
        return (NDIS_STATUS_SUCCESS);
    }

    Irp = pNdisTapiRequest->Irp;

    IoSetCancelRoutine(Irp, PxCancelSetQuery);

    //
    // Insert the request in the Vc's pending list
    //
    InsertTailList(&pVc->PendingDropReqs, 
                   &pNdisTapiRequest->Linkage);

    pVc->CloseFlags |= PX_VC_TAPI_DROP;

    //
    // Check the Vc state and act accordingly
    //
    Status = 
        PxVcCleanup(pVc, PX_VC_DROP_PENDING);

    if (Status != NDIS_STATUS_PENDING) {
        RemoveEntryList(&pNdisTapiRequest->Linkage);
        IoSetCancelRoutine(Irp, NULL);
    }

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    return (Status);
}

NDIS_STATUS
PxTapiGetAddressCaps(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_ADDRESS_CAPS pNdisTapiGetAddressCaps =
        (PNDIS_TAPI_GET_ADDRESS_CAPS) pNdisTapiRequest->Data;
    PPX_TAPI_LINE   TapiLine;
    PPX_TAPI_ADDR   TapiAddr;
    PPX_ADAPTER     ClAdapter;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;

    if (!IsTapiDeviceValid(pNdisTapiRequest->ulDeviceID, &TapiLine)) {
        PXDEBUGP (PXD_WARNING, PXM_TAPI, ( "PxTapiGetAddressCaps: NDISTAPIERR_BADDEVICEID: line = %x\n", pNdisTapiRequest->ulDeviceID));
        return (NDISTAPIERR_BADDEVICEID);
    }

    PXDEBUGP(PXD_TAPI, PXM_TAPI,
            ("PxTapiGetAddressCaps: got device %p from ID %d\n",
            TapiLine, pNdisTapiRequest->ulDeviceID));

    NdisAcquireSpinLock(&TapiLine->Lock);

    do {
        ULONG   DevClassesSize = 0;
        USHORT  DevClassesList[512];
        ULONG   SizeToMove;
        ULONG   TotalSize;
        ULONG   SizeLeft;
        PLINE_ADDRESS_CAPS In, Out;


        //
        // Get the tapi address that we are interested in
        //
        if (!IsAddressValid(TapiLine,
                            pNdisTapiGetAddressCaps->ulAddressID,
                            &TapiAddr)) {

            Status = NDIS_STATUS_TAPI_INVALADDRESSID;
            break;
        }

        In = TapiAddr->Caps;
        Out = &pNdisTapiGetAddressCaps->LineAddressCaps;

        //
        // Add some space for our device classes
        //
        DevClassesSize = sizeof(DevClassesList);
        NdisZeroMemory((PUCHAR)DevClassesList, 
                       sizeof(DevClassesList));

        if (TapiLine->TapiProvider->Adapter != NULL) {
            GetAllDevClasses(TapiLine->TapiProvider->Adapter,
                             DevClassesList,
                             &DevClassesSize);
        }

        //
        // Synchronously get Address caps for this device
        //
        SizeToMove = (In->ulUsedSize > Out->ulTotalSize) ?
            Out->ulTotalSize : In->ulUsedSize;

        TotalSize = Out->ulTotalSize;

        NdisMoveMemory((PUCHAR)Out, (PUCHAR)In, SizeToMove);

        SizeLeft = 
            TotalSize - SizeToMove;

        Out->ulTotalSize = TotalSize;
        Out->ulUsedSize = SizeToMove;
        Out->ulNeededSize = 
            In->ulUsedSize + DevClassesSize;

        if (SizeLeft > 0) {
            //
            // If these is room fill in our devclasses
            //
            if (DevClassesSize > 0) {
                PUCHAR  dst;

                dst = (PUCHAR)Out + Out->ulUsedSize;

                SizeToMove = (SizeLeft > DevClassesSize) ?
                    DevClassesSize : SizeLeft;

                NdisMoveMemory(dst, DevClassesList, SizeToMove);
                Out->ulDeviceClassesSize = SizeToMove;
                Out->ulDeviceClassesOffset =
                    (ULONG)((ULONG_PTR)dst - (ULONG_PTR)Out);
                Out->ulUsedSize += SizeToMove;
                SizeLeft -= SizeToMove;
            }
        }

    } while (FALSE);

    DEREF_TAPILINE_LOCKED(TapiLine);

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiGetAddressCaps: exit. \n"));

    return (Status);
}

NDIS_STATUS
PxTapiGetAddressID(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_ADDRESS_ID TapiBuffer =
        (PNDIS_TAPI_GET_ADDRESS_ID) pNdisTapiRequest->Data;
    PPX_TAPI_LINE   TapiLine;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiGetAddressID: enter\n"));

    if (!IsTapiLineValid((ULONG)TapiBuffer->hdLine, &TapiLine)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiGetAddressID: NDISTAPIERR_BADDEVICEID: line = %x\n", TapiBuffer->hdLine));
        return(NDISTAPIERR_BADDEVICEID);
    }

    NdisAcquireSpinLock(&TapiLine->Lock);

    //
    // ToDo!
    //
    TapiBuffer->ulAddressID = 0;

    DEREF_TAPILINE_LOCKED(TapiLine);

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiGetAddressID: exit\n"));

    return (NDIS_STATUS_SUCCESS);

}

NDIS_STATUS
PxTapiGetAddressStatus(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    Placeholder for TAPI OID action routines
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetAddressStatus: enter\n"));

    //
    // ToDo!
    //
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetAddressStatus: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);

}

NDIS_STATUS
PxTapiGetCallAddressID(
    IN    PNDISTAPI_REQUEST       pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_CALL_ADDRESS_ID TapiBuffer =
        (PNDIS_TAPI_GET_CALL_ADDRESS_ID)pNdisTapiRequest->Data;

    PPX_VC              pVc;

    if (!IsVcValid(TapiBuffer->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiGetCallAddressID: invalid call handle %d\n",
                               TapiBuffer->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetCallAddressID: Vc: %p\n", pVc));

    NdisAcquireSpinLock(&pVc->Lock);

    TapiBuffer->ulAddressID = pVc->TapiAddr->AddrId;

    DEREF_VC_LOCKED(pVc);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetCallAddressID: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiGetCallInfo(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_CALL_INFO TapiBuffer =
        (PNDIS_TAPI_GET_CALL_INFO)pNdisTapiRequest->Data;

    PPX_VC          pVc;
    PPX_TAPI_LINE   TapiLine;
    LINE_CALL_INFO* CallInfo;
    LINE_CALL_INFO* OutCallInfo = &TapiBuffer->LineCallInfo;
    ULONG           VarDataSize = 0;    // Total available
    ULONG           VarDataUsed = 0;

    if (!IsVcValid(TapiBuffer->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiGetCallInfo: invalid call handle %d\n",
                               TapiBuffer->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    // 
    // Make sure we have enough space to copy everything over
    //
    CallInfo = pVc->CallInfo;
    TapiLine = pVc->TapiLine;

    VarDataSize = 
        pNdisTapiRequest->ulDataSize - sizeof(NDIS_TAPI_GET_CALL_INFO);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, 
              ("PxTapiGetCallInfo: enter. pVc = %p, AvailSize = %x, needed = %x\n", 
               pVc, OutCallInfo->ulTotalSize,  CallInfo->ulUsedSize));

    OutCallInfo->ulNeededSize = CallInfo->ulUsedSize;

    //
    // Patch up the Id here.  We store it in our callinfo
    // block in terms of the call managers 0 based Id.  We
    // need to give tapi the Id it is looking for which is
    // stored in the tapiline.
    //
    OutCallInfo->ulLineDeviceID = TapiLine->ulDeviceID;

    OutCallInfo->ulAddressID = CallInfo->ulAddressID;

    OutCallInfo->ulBearerMode = CallInfo->ulBearerMode;

    OutCallInfo->ulRate = CallInfo->ulRate;

    OutCallInfo->ulMediaMode = CallInfo->ulMediaMode;

    OutCallInfo->ulAppSpecific = CallInfo->ulAppSpecific;
    OutCallInfo->ulCallID = 0;
    OutCallInfo->ulRelatedCallID = 0;
    OutCallInfo->ulCallParamFlags = 0;

    OutCallInfo->DialParams.ulDialPause = 0;
    OutCallInfo->DialParams.ulDialSpeed = 0;
    OutCallInfo->DialParams.ulDigitDuration = 0;
    OutCallInfo->DialParams.ulWaitForDialtone = 0;

    OutCallInfo->ulReason = CallInfo->ulReason;
    OutCallInfo->ulCompletionID = 0;

    OutCallInfo->ulCountryCode = 0;
    OutCallInfo->ulTrunk = (ULONG)-1;

    //
    // Do the CallerID
    //
    if (CallInfo->ulCallerIDSize) {

        if (((VarDataUsed + CallInfo->ulCallerIDSize) <= VarDataSize) &&
            ((CallInfo->ulCallerIDOffset + CallInfo->ulCallerIDSize) <= CallInfo->ulUsedSize)) {

            OutCallInfo->ulCallerIDSize = CallInfo->ulCallerIDSize;
            OutCallInfo->ulCallerIDFlags = CallInfo->ulCallerIDFlags;
            OutCallInfo->ulCallerIDOffset = sizeof (LINE_CALL_INFO) + VarDataUsed;
            NdisMoveMemory ( (PUCHAR)(OutCallInfo)+OutCallInfo->ulCallerIDOffset,
                             (PUCHAR)(CallInfo)+CallInfo->ulCallerIDOffset,
                             CallInfo->ulCallerIDSize);

            VarDataUsed +=  CallInfo->ulCallerIDSize;
            pVc->ulCallInfoFieldsChanged |= LINECALLINFOSTATE_CALLERID;
        }
    } else {

        OutCallInfo->ulCallerIDFlags = LINECALLPARTYID_UNAVAIL;
        OutCallInfo->ulCallerIDSize = 0;
        OutCallInfo->ulCallerIDOffset = 0;
    }

    OutCallInfo->ulCallerIDNameSize = 0;
    OutCallInfo->ulCallerIDNameOffset = 0;

    //
    // Do the CalledID
    //
    if (CallInfo->ulCalledIDSize) {
        if (((VarDataUsed + CallInfo->ulCalledIDSize) <= VarDataSize) &&
            ((CallInfo->ulCalledIDOffset + CallInfo->ulCalledIDSize) <= CallInfo->ulUsedSize)) {

            OutCallInfo->ulCalledIDFlags = CallInfo->ulCalledIDFlags;
            OutCallInfo->ulCalledIDSize = CallInfo->ulCalledIDSize;
            OutCallInfo->ulCalledIDOffset = sizeof (LINE_CALL_INFO) + VarDataUsed;

            NdisMoveMemory ( (PUCHAR)(OutCallInfo)+OutCallInfo->ulCalledIDOffset,
                             (PUCHAR)(CallInfo)+CallInfo->ulCalledIDOffset,
                             CallInfo->ulCalledIDSize);

            VarDataUsed +=  CallInfo->ulCalledIDSize;
            pVc->ulCallInfoFieldsChanged |= LINECALLINFOSTATE_CALLEDID;
        }

    } else {
        OutCallInfo->ulCalledIDFlags = LINECALLPARTYID_UNAVAIL;
        OutCallInfo->ulCalledIDSize = 0;
        OutCallInfo->ulCalledIDOffset = 0;
    }

    OutCallInfo->ulCalledIDNameSize = 0;
    OutCallInfo->ulCalledIDNameOffset = 0;

    OutCallInfo->ulCallStates = LINECALLSTATE_IDLE |
                                LINECALLSTATE_OFFERING |
                                LINECALLSTATE_CONNECTED |
                                LINECALLSTATE_PROCEEDING |
                                LINECALLSTATE_DISCONNECTED |
                                LINECALLSTATE_SPECIALINFO |
                                LINECALLSTATE_UNKNOWN;

    OutCallInfo->ulOrigin = (pVc->Flags & PX_VC_OWNER) ? LINECALLORIGIN_EXTERNAL : LINECALLORIGIN_OUTBOUND;
    OutCallInfo->ulReason = LINECALLREASON_UNAVAIL;
    OutCallInfo->ulCompletionID = 0;
    OutCallInfo->ulConnectedIDFlags = LINECALLPARTYID_UNAVAIL;
    OutCallInfo->ulConnectedIDSize = 0;
    OutCallInfo->ulConnectedIDOffset    =    0;
    OutCallInfo->ulConnectedIDNameSize = 0;
    OutCallInfo->ulConnectedIDNameOffset = 0;

    OutCallInfo->ulRedirectionIDFlags = LINECALLPARTYID_UNAVAIL;
    OutCallInfo->ulRedirectionIDSize = 0;
    OutCallInfo->ulRedirectionIDOffset = 0;
    OutCallInfo->ulRedirectionIDNameSize = 0;
    OutCallInfo->ulRedirectionIDNameOffset = 0;

    OutCallInfo->ulRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;
    OutCallInfo->ulRedirectingIDSize = 0;
    OutCallInfo->ulRedirectingIDOffset = 0;
    OutCallInfo->ulRedirectingIDNameSize       =       0;
    OutCallInfo->ulRedirectingIDNameOffset = 0;

    OutCallInfo->ulDisplaySize = 0;
    OutCallInfo->ulDisplayOffset = 0;

    OutCallInfo->ulUserUserInfoSize = 0;
    OutCallInfo->ulUserUserInfoOffset = 0;

    OutCallInfo->ulHighLevelCompSize = 0;
    OutCallInfo->ulHighLevelCompOffset = 0;

    OutCallInfo->ulLowLevelCompSize = 0;
    OutCallInfo->ulLowLevelCompOffset = 0;

    OutCallInfo->ulChargingInfoSize = 0;
    OutCallInfo->ulChargingInfoOffset = 0;

    OutCallInfo->ulTerminalModesSize = 0;
    OutCallInfo->ulTerminalModesOffset    =    0;

    OutCallInfo->ulDevSpecificSize = 0;
    OutCallInfo->ulDevSpecificOffset = 0;

    OutCallInfo->ulNeededSize =
    OutCallInfo->ulUsedSize = sizeof(LINE_CALL_INFO) + VarDataUsed;

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiGetCallStatus (
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_CALL_STATUS TapiBuffer =
        (PNDIS_TAPI_GET_CALL_STATUS)pNdisTapiRequest->Data;

    PPX_VC              pVc;
    LINE_CALL_INFO*     CallInfo;
    LINE_CALL_STATUS*   CallStatus = &TapiBuffer->LineCallStatus;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetCallStatus: enter\n"));\

    if (!IsVcValid(TapiBuffer->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiGetCallStatus: invalid call handle %d\n",
                               TapiBuffer->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    CallInfo = pVc->CallInfo;

    CallStatus->ulUsedSize = sizeof(LINE_CALL_STATUS);

    CallStatus->ulCallState = pVc->ulCallState;

    //
    // fill the mode depending on the call state
    //
    switch (pVc->ulCallState) {
        case LINECALLSTATE_IDLE:
        default:
            CallStatus->ulCallStateMode = 0;
            CallStatus->ulCallFeatures = 0;
            break;

        case LINECALLSTATE_CONNECTED:
            CallStatus->ulCallStateMode = 0;
            CallStatus->ulCallFeatures = LINECALLFEATURE_DROP;
            break;

        case LINECALLSTATE_OFFERING:
            CallStatus->ulCallStateMode = 0;
            CallStatus->ulCallFeatures = LINECALLFEATURE_ANSWER;
            break;

        case LINECALLSTATE_DISCONNECTED:
            if (pVc->ulCallStateMode == 0x11 )
                CallStatus->ulCallStateMode = LINEDISCONNECTMODE_BUSY;
            else
                CallStatus->ulCallStateMode = LINEDISCONNECTMODE_NOANSWER;
            break;

        case LINECALLSTATE_BUSY:
            CallStatus->ulCallStateMode = LINEBUSYMODE_UNAVAIL;
            break;

        case LINECALLSTATE_SPECIALINFO:
            //      if(cm->NoActiveLine)
            //          CallStatus->ulCallStateMode = LINESPECIALINFO_NOCIRCUIT;
            CallStatus->ulCallStateMode = 0;
            break;
    }

    CallStatus->ulDevSpecificSize = 0;
    CallStatus->ulDevSpecificOffset = 0;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("GetCallStatus: VC %x/%x, CallSt %x, Mode %x, Features %x\n",
                        pVc, pVc->Flags,
                        CallStatus->ulCallState,
                        CallStatus->ulCallStateMode,
                        CallStatus->ulCallFeatures));
    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiGetDevConfig(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetDevConfig: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetDevConfig: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiGetExtensionID(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_EXTENSION_ID TapiBuffer = (PNDIS_TAPI_GET_EXTENSION_ID)pNdisTapiRequest->Data;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetExtensionID: enter\n"));

    //   TapiBuffer->LineExtensionID.ulExtensionID0 = 0;
    //  TapiBuffer->LineExtensionID.ulExtensionID1 = 0;
    //  TapiBuffer->LineExtensionID.ulExtensionID2 = 0;
    //  TapiBuffer->LineExtensionID.ulExtensionID3 = 0;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetExtensionID: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiGetLineDevStatus(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_GET_LINE_DEV_STATUS TapiBuffer =
        (PNDIS_TAPI_GET_LINE_DEV_STATUS)pNdisTapiRequest->Data;

    PPX_TAPI_LINE   TapiLine;
    PX_ADAPTER      *pAdapter;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetLineDevStatus: enter\n"));

    //
    // validate line handle and get line pointer
    //
    if (!IsTapiLineValid((ULONG)TapiBuffer->hdLine, &TapiLine)) {
        PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiGetLineDevStatus: NDISTAPIERR_BADDEVICEID: line = %x\n", TapiBuffer->hdLine));
        return (NDISTAPIERR_BADDEVICEID);
    }

    NdisAcquireSpinLock(&TapiLine->Lock);

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiGetLineDevStatus: got device %p from ID %d\n", TapiLine, TapiBuffer->hdLine));

    //
    // Get MediaModes and Current Calls
    //
    TapiBuffer->LineDevStatus.ulOpenMediaModes =
        TapiLine->DevStatus->ulOpenMediaModes;

    TapiBuffer->LineDevStatus.ulNumActiveCalls =
        TapiLine->DevStatus->ulNumActiveCalls;

    TapiBuffer->LineDevStatus.ulDevStatusFlags =
        TapiLine->DevStatus->ulDevStatusFlags;

    DEREF_TAPILINE_LOCKED(TapiLine);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiGetLineDevStatus: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiNegotiateExtVersion(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_NEGOTIATE_EXT_VERSION    pNdisTapiNegotiateExtVersion =
        (PNDIS_TAPI_NEGOTIATE_EXT_VERSION) pNdisTapiRequest->Data;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiNegotiateExtVersion: enter\n"));

    pNdisTapiNegotiateExtVersion->ulExtVersion = 0;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiNegotiateExtVersion: exit NDIS_STATUS_TAPI_OPERATIONUNAVAIL\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiSendUserUserInfo(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiSendUserUserInfo: enter\n"));
    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiSendUserUserInfo: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiSetAppSpecific(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_SET_APP_SPECIFIC pNdisTapiSetAppSpecific =
        (PNDIS_TAPI_SET_APP_SPECIFIC)(pNdisTapiRequest->Data);

    PPX_VC pVc;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetAppSpecific: enter\n"));

    if (!IsVcValid(pNdisTapiSetAppSpecific->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiSetAppSpecific: pVc invalid call handle %d\n",
                               pNdisTapiSetAppSpecific->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    //
    // Get the VC, and re-set the app specific longword.
    //
    pVc->CallInfo->ulAppSpecific =
        pNdisTapiSetAppSpecific->ulAppSpecific;

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetAppSpecific: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiSetCallParams(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetCallParams: enter\n"));

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetCallParams: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiSetDefaultMediaDetection(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{

    PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION TapiBuffer =
        (PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION)pNdisTapiRequest->Data;
    PPX_CL_AF       pClAf = NULL;
    PPX_CL_SAP      pClSap = NULL;
    PCO_SAP         pCoSap;
    PPX_TAPI_LINE   TapiLine = NULL;
    NDIS_STATUS     Status;
    BOOLEAN         Found = FALSE;
    PPX_TAPI_PROVIDER   TapiProvider;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiSetDefaultMediaDetection: enter\n"));

    //
    // validate line handle and get line pointer
    //
    if (!IsTapiLineValid((ULONG)TapiBuffer->hdLine, &TapiLine)) {
        PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                  ("PxTapiSetDefaultMediaDetection: NDISTAPIERR_BADDEVICEID: line = %x\n", 
                   TapiBuffer->hdLine));
        return (NDISTAPIERR_BADDEVICEID);
    }

    PXDEBUGP(PXD_LOUD, PXM_TAPI, 
             ("PxTapiSetDefaultMediaDetection: got TapiLine %p from ID %d\n", 
              TapiLine, TapiBuffer->hdLine));

    NdisAcquireSpinLock(&TapiLine->Lock);

    do {

        //
        // Is this line in service? (does it have an valid af?)
        //
        if (!(TapiLine->DevStatus->ulDevStatusFlags & 
              LINEDEVSTATUSFLAGS_INSERVICE)) {
            PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                      ("PxTapiSetDefaultMediaDetection: Line not in service!\n"));
            NdisReleaseSpinLock(&TapiLine->Lock);
            Status = NDIS_STATUS_TAPI_INVALLINESTATE;
            break;
        }

        //
        // Make sure this line supports these media modes
        //
        if ((TapiBuffer->ulMediaModes & TapiLine->DevCaps->ulMediaModes) !=
            TapiBuffer->ulMediaModes) {

            PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                      ("PxTapiSetDefaultMediaDetection: invalid media mode\n"));
            NdisReleaseSpinLock(&TapiLine->Lock);
            Status = NDIS_STATUS_TAPI_INVALMEDIAMODE;
            break;
        }

        //
        // See if we already have these media modes open
        //
        if ((TapiBuffer->ulMediaModes & 
            ~TapiLine->DevStatus->ulOpenMediaModes) == 0) {

            PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                      ("PxTapiSetDefaultMediaDetection: Already have a sap!\n"));
            NdisReleaseSpinLock(&TapiLine->Lock);

            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        TapiLine->DevStatus->ulOpenMediaModes |= 
            TapiBuffer->ulMediaModes;

        pClAf = TapiLine->ClAf;

        pClSap = TapiLine->ClSap;
        TapiLine->ClSap = NULL;

        NdisReleaseSpinLock(&TapiLine->Lock);


        PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                  ("PxTapiSetDefaultMediaDetection: TapiLine: %p, pClAf: %p, MediaModes: %x\n", 
                   TapiLine, pClAf, TapiLine->DevStatus->ulOpenMediaModes));

        NdisAcquireSpinLock(&pClAf->Lock);

        REF_CL_AF(pClAf);

        if (pClSap != NULL) {
            //
            // We already have a sap on this line.  We only need one
            // per line so let's deregister the old one before registering
            // the new one.
            //
            RemoveEntryList(&pClSap->Linkage);

            InsertTailList(&pClAf->ClSapClosingList, &pClSap->Linkage);

            NdisReleaseSpinLock(&pClAf->Lock);

            InterlockedExchange((PLONG)&pClSap->State, PX_SAP_CLOSING);

            Status = NdisClDeregisterSap(pClSap->NdisSapHandle);

            if (Status != NDIS_STATUS_PENDING) {
                PxClDeregisterSapComplete(Status, pClSap);
            }

        } else {
            NdisReleaseSpinLock(&pClAf->Lock);
        }

        //
        // Get a SAP translation for this Media Mode setting.
        // The function is called with the Af lock held and
        // returns with the Af lock released!
        //
        pClSap = (*pClAf->AfGetNdisSap)(pClAf, TapiLine);

        if (pClSap == NULL) {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisAcquireSpinLock(&pClAf->Lock);

        InsertTailList(&pClAf->ClSapList, &pClSap->Linkage);

        REF_CL_AF(pClAf);

        NdisReleaseSpinLock(&pClAf->Lock);

        //
        //  Register the new sap
        //
        Status = NdisClRegisterSap(pClAf->NdisAfHandle,
                                   pClSap,
                                   pClSap->CoSap,
                                   &pClSap->NdisSapHandle);

        if (Status != NDIS_STATUS_PENDING) {
            PxClRegisterSapComplete(Status,
                                    pClSap,
                                    pClSap->CoSap,
                                    pClSap->NdisSapHandle);
        }

    } while (FALSE);

    DEREF_CL_AF(pClAf);

    DEREF_TAPILINE(TapiLine);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetDefaultMediaDetection: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiSetDevConfig(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetDevConfig: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetDevConfig: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiSetMediaMode(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PNDIS_TAPI_SET_MEDIA_MODE    pNdisTapiSetMediaMode =
        (PNDIS_TAPI_SET_MEDIA_MODE)(pNdisTapiRequest->Data);

    PPX_VC pVc;
    PPX_TAPI_LINE   TapiLine;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetMediaMode: enter\n"));

    if (!IsVcValid(pNdisTapiSetMediaMode->hdCall, &pVc)) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, ("PxTapiSetMediaMode: pVc invalid call handle %d\n",
                               pNdisTapiSetMediaMode->hdCall));

        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    NdisAcquireSpinLock(&pVc->Lock);

    TapiLine = pVc->TapiAddr->TapiLine;

    if ((TapiLine->DevCaps->ulMediaModes & pNdisTapiSetMediaMode->ulMediaMode)) {
        pVc->CallInfo->ulMediaMode = pNdisTapiSetMediaMode->ulMediaMode;
    } else {
        Status = NDIS_STATUS_TAPI_INVALMEDIAMODE;
    }

    //
    // Deref for ref applied at entry when 
    // validating the vc
    //
    DEREF_VC_LOCKED(pVc);

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSetMediaMode: exit\n"));

    return (Status);
}

NDIS_STATUS
PxTapiSetStatusMessages(
    IN    PNDISTAPI_REQUEST       pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiSeStatusMessages: enter\n"));
    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("PxTapiSetStatusMessages: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiOpen(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{

    PNDIS_TAPI_OPEN TapiBuffer =
        (PNDIS_TAPI_OPEN)pNdisTapiRequest->Data;

    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PPX_TAPI_LINE       TapiLine;
    PPX_TAPI_ADDR       TapiAddr;
    PNDISTAPI_OPENDATA  OpenData;
    PX_ADAPTER          *Adapter;
    ULONG               n;

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiOpen: enter\nn"));

    if (!IsTapiDeviceValid(TapiBuffer->ulDeviceID, &TapiLine)) {
        PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiOPEN: NDISTAPIERR_BADDEVICEID: line = %x\n", TapiBuffer->ulDeviceID));
        return(NDISTAPIERR_BADDEVICEID);
    }

    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiOpen: got device %p from ID %d\n", TapiLine, TapiBuffer->ulDeviceID));

    NdisAcquireSpinLock(&TapiLine->Lock);

    if (!(TapiLine->DevStatus->ulDevStatusFlags & 
          LINEDEVSTATUSFLAGS_INSERVICE)) {

        NdisReleaseSpinLock(&TapiLine->Lock);

        return(NDISTAPIERR_DEVICEOFFLINE);
    }

    //
    // Stick TAPI's line handle into the device
    //
    TapiLine->htLine = (HTAPI_LINE)TapiBuffer->htLine;

    TapiLine->DevStatus->ulNumOpens++;

    //
    // Stick our line handle into the out param. This is the context that will be
    // passed to us in subsequent API calls on this open line device. Use the device ID.
    //
    TapiBuffer->hdLine = TapiLine->hdLine;

    //
    // Stick the miniport GUID and the mediatype into the variable data portion of the
    // TAPI Open call (req'd for NDISWAN/Tonybe)
    //
    Adapter = TapiLine->TapiProvider->Adapter;

    OpenData = (PNDISTAPI_OPENDATA)
        ((PUCHAR)pNdisTapiRequest->Data + sizeof(NDIS_TAPI_OPEN));

    RtlMoveMemory(&OpenData->Guid,
                  &Adapter->Guid,
                  sizeof(OpenData->Guid));

    OpenData->MediaType = Adapter->MediumSubType;

    DEREF_TAPILINE_LOCKED(TapiLine);

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiOpen: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiProviderInit(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:
fea142c4
    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiProviderInit: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiProviderInit: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
PxTapiProviderShutdown(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:
fea142c4
    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiProviderShutdown: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiProviderShutdown: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
PxTapiSecureCall(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSecureCall: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSecureCall: exit\n"));

    return (NDIS_STATUS_TAPI_OPERATIONUNAVAIL);
}

NDIS_STATUS
PxTapiSelectExtVersion(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )

/*++

Routine Description:

    TAPI OID action routine
Arguments:

    pNdisTapiRequest -- the request that arrived in an IRP system buffer

Return Value:


--*/

{
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSelectExtVersion: enter\n"));
    PXDEBUGP (PXD_TAPI, PXM_TAPI, ("PxTapiSelectExtVersion: exit\n"));

    return (NDIS_STATUS_SUCCESS);
}



NDIS_STATUS
PxTapiGatherDigits(
    IN PNDISTAPI_REQUEST    pNdisTapiRequest
    )
{
    NDIS_STATUS                 Status = STATUS_SUCCESS;
    PNDIS_TAPI_GATHER_DIGITS    pNdisTapiGatherDigits = NULL;
    NDIS_HANDLE                 NdisBindingHandle, NdisAfHandle, NdisVcHandle;
    PPX_VC                      pVc = NULL;

    PXDEBUGP(PXD_LOUD, PXM_TAPI, ("PxTapiGatherDigits: Enter\n"));

    pNdisTapiGatherDigits = 
        (PNDIS_TAPI_GATHER_DIGITS)pNdisTapiRequest->Data;

    do {
        PX_REQUEST      ProxyRequest;
        PNDIS_REQUEST   NdisRequest;
        PIRP            Irp;

        if (!IsVcValid(pNdisTapiGatherDigits->hdCall, &pVc)) {
            PXDEBUGP(PXD_WARNING, PXM_TAPI, 
                     ("PxTapiGatherDigits: Invalid call - Setting "
                      "Status NDISTAPIERR_BADDEVICEID\n"));
            Status = NDISTAPIERR_BADDEVICEID;
            break;
        }

        NdisAcquireSpinLock(&pVc->Lock);

        //
        // If we're monitoring digits (ala lineMonitorDigits) then we can't gather digits. 
        //
        if (pVc->ulMonitorDigitsModes != 0) {
            NdisReleaseSpinLock(&pVc->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (pVc->PendingGatherDigits != NULL) {
            //
            // Check if the buffer passed to TSPI_lineGatherDigits was NULL. If so, then this 
            // is a request to cancel digit gathering that was previously initiated. If not, then
            // the app is trying to do two lineGatherDigits() operations at once and we have to 
            // fail this. 
            //
            if (pNdisTapiGatherDigits->lpsOrigDigitsBuffer == NULL) {
                
                pVc->PendingGatherDigits = NULL;
                PxTerminateDigitDetection(pVc, pNdisTapiRequest, LINEGATHERTERM_CANCEL);

                NdisReleaseSpinLock(&pVc->Lock);                
                Status = NDIS_STATUS_SUCCESS;

                break;
            } else {
            
                NdisReleaseSpinLock(&pVc->Lock);
                Status = NDIS_STATUS_FAILURE;
                break;

            }
        } else if (pNdisTapiGatherDigits->lpsOrigDigitsBuffer == NULL) {
            //
            // Trying to cancel digit detection even though it wasn't started. Fail this. 
            //

            NdisReleaseSpinLock(&pVc->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        Irp = pNdisTapiRequest->Irp;

        IoSetCancelRoutine(Irp, PxCancelSetQuery);

        //
        // Store the unique request ID in the VC - this will be used later to retrieve the 
        // original IRP.
        //
        pVc->PendingGatherDigits = pNdisTapiRequest;

        NdisReleaseSpinLock(&pVc->Lock);

        //
        // Initialize the timer that will be used to implement the digit timeouts. 
        //

        NdisInitializeTimer(&pVc->DigitTimer,
                            PxDigitTimerRoutine,
                            (PVOID)pVc);

        //        
        // Fill out our request structure.
        //
        NdisZeroMemory(&ProxyRequest, sizeof(ProxyRequest));

        PxInitBlockStruc(&ProxyRequest.Block);

        NdisRequest = &ProxyRequest.NdisRequest;

        NdisRequest->RequestType = 
            NdisRequestSetInformation;
        
        NdisRequest->DATA.SET_INFORMATION.Oid = 
            OID_CO_TAPI_REPORT_DIGITS;

        NdisRequest->DATA.SET_INFORMATION.InformationBuffer = 
            (PVOID)&pNdisTapiGatherDigits->ulDigitModes;   // This is the NDIS_TAPI_GATHER_DIGITS structure

        NdisRequest->DATA.SET_INFORMATION.InformationBufferLength = 
            sizeof(pNdisTapiGatherDigits->ulDigitModes);
            
        Status = 
            NdisCoRequest(pVc->Adapter->ClBindingHandle, 
                          pVc->ClAf->NdisAfHandle,
                          pVc->ClVcHandle,
                          NULL,
                          NdisRequest);

        if (Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&ProxyRequest.Block);
        }

        if (Status != NDIS_STATUS_SUCCESS) {

            NdisAcquireSpinLock(&pVc->Lock);

            pVc->PendingGatherDigits = NULL;

            IoSetCancelRoutine(Irp, NULL);

            NdisReleaseSpinLock(&pVc->Lock);

            PXDEBUGP(PXD_WARNING, PXM_TAPI, 
                     ("PxTapiGatherDigits: NdisCoRequest failed\n"));
            break;
        }

        //
        // Start the timer for the first digit timeout. Ref the VC here because otherwise it might 
        // go away before the timer fires.
        //
        if (pNdisTapiGatherDigits->ulFirstDigitTimeout) {
            
            NdisAcquireSpinLock(&pVc->Lock);
            REF_VC(pVc);
            NdisReleaseSpinLock(&pVc->Lock);

            NdisSetTimer(&pVc->DigitTimer,
                         pNdisTapiGatherDigits->ulFirstDigitTimeout);
        }

        //
        // Set status to pending because this request just initiates the gathering of digits. 
        // The IRP will complete once all the digits come in. 
        //
        Status = NDIS_STATUS_PENDING; 
                            
    } while (FALSE);

    DEREF_VC(pVc);

    PXDEBUGP(PXD_LOUD, PXM_TAPI,
             ("PxTapiGatherDigits: Exit - Returning 0x%x\n", Status));

    return (Status);
}

NDIS_STATUS
PxTapiMonitorDigits(
                     IN PNDISTAPI_REQUEST    pNdisTapiRequest
                     )  
{   
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    PNDIS_TAPI_MONITOR_DIGITS   pNdisTapiMonitorDigits = NULL;
    PPX_VC                      pVc = NULL;

    PXDEBUGP(PXD_LOUD, PXM_TAPI, ("PxTapiMonitorDigits: Enter\n"));

    pNdisTapiMonitorDigits = 
        (PNDIS_TAPI_MONITOR_DIGITS)pNdisTapiRequest->Data;

    do {
        if (!IsVcValid(pNdisTapiMonitorDigits->hdCall, &pVc)) {
            PXDEBUGP(PXD_WARNING, PXM_TAPI, 
                     ("PxTapiMonitorDigits: Invalid call - Setting "
                      "Status NDISTAPIERR_BADDEVICEID\n"));
            Status = NDISTAPIERR_BADDEVICEID;
            break;
        }

        NdisAcquireSpinLock(&pVc->Lock);

        if (pVc->PendingGatherDigits != NULL) {
            //
            // Can't monitor digits while a lineGatherDigits request is in effect.
            //
            NdisReleaseSpinLock(&pVc->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }


        if (pVc->ulMonitorDigitsModes != 0) {
            
            NdisReleaseSpinLock(&pVc->Lock);
            //
            // We are already monitoring digits as a result of lineMonitorDigits request. 
            // If the digit modes in the this request are zero, then this is a request to 
            // cancel digit monitoring. 
            //
            
            if (pNdisTapiMonitorDigits->ulDigitModes == 0) {
                
                Status = PxStopDigitReporting(pVc);

                if (Status != NDIS_STATUS_SUCCESS) {
                    PXDEBUGP(PXD_WARNING, PXM_TAPI, 
                             ("PxTapiMonitorDigits: Failed to stop digit reporting with status 0x%x\n", Status));
                    
                    break;
                }
                
                //
                // It's a shame that I have to acquire and release again since I had 
                // the lock before, but there's no way to know whether I can set this
                // to zero until I know the status that PxStopDigitReporting() returned.
                //
                NdisAcquireSpinLock(&pVc->Lock);
                pVc->ulMonitorDigitsModes = 0; 
                NdisReleaseSpinLock(&pVc->Lock);

            } else {
                //
                // We're already monitoring digits, so this request to do so must fail. 
                //
                Status = NDIS_STATUS_FAILURE;
                break;              
            }
        } else {            
            PX_REQUEST      ProxyRequest;
            PNDIS_REQUEST   NdisRequest;

            pVc->ulMonitorDigitsModes = pNdisTapiMonitorDigits->ulDigitModes; 

            NdisReleaseSpinLock(&pVc->Lock);

            if (pNdisTapiMonitorDigits->ulDigitModes == 0) {
                //
                // Someone's trying to cancel digit monitoring, but it hasn't been started yet.
                //
                Status = NDIS_STATUS_FAILURE;
                break;
            }


            //        
            // Fill out our request structure to tell the miniport to start reporting digits.
            //
            NdisZeroMemory(&ProxyRequest, sizeof(ProxyRequest));

            PxInitBlockStruc(&ProxyRequest.Block);

            NdisRequest = &ProxyRequest.NdisRequest;

            NdisRequest->RequestType = 
                NdisRequestSetInformation;
        
            NdisRequest->DATA.SET_INFORMATION.Oid = 
                OID_CO_TAPI_REPORT_DIGITS;

            NdisRequest->DATA.SET_INFORMATION.InformationBuffer = 
                (PVOID)&pNdisTapiMonitorDigits->ulDigitModes;   

            NdisRequest->DATA.SET_INFORMATION.InformationBufferLength = 
                sizeof(pNdisTapiMonitorDigits->ulDigitModes);

            Status = 
                NdisCoRequest(pVc->Adapter->ClBindingHandle, 
                              pVc->ClAf->NdisAfHandle,
                              pVc->ClVcHandle,
                              NULL,
                              NdisRequest);
            
            if (Status == NDIS_STATUS_PENDING) {
                Status = PxBlock(&ProxyRequest.Block);
            }

            if (Status != NDIS_STATUS_SUCCESS) {

                NdisAcquireSpinLock(&pVc->Lock);

                pVc->ulMonitorDigitsModes = 0;

                NdisReleaseSpinLock(&pVc->Lock);

                PXDEBUGP(PXD_WARNING, PXM_TAPI, 
                         ("PxTapiMonitorDigits: NdisCoRequest to start digit reporting failed with status 0x%x\n", Status));
                break;
            }

        }   
    } while (FALSE);

    DEREF_VC(pVc);
    
    PXDEBUGP(PXD_LOUD, PXM_TAPI, ("PxTapiMonitorDigits: Exit - Returning 0x%x\n", Status));

    return (Status);
} 



VOID
PxTapiCompleteDropIrps(
    IN PPX_VC   pVc,
    IN ULONG    Status
    )

/*++

Routine Description:



Arguments:



Return Value:


--*/

{
    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiCompleteDropIrps: Vc %p\n", pVc));

    ASSERT(!IsListEmpty(&pVc->PendingDropReqs));
    ASSERT(pVc->Flags & PX_VC_DROP_PENDING);

    pVc->Flags &= ~PX_VC_DROP_PENDING;

    while (!IsListEmpty(&pVc->PendingDropReqs)) {

        PLIST_ENTRY             Entry;
        PIRP                    Irp;
        KIRQL                   Irql;
        PNDISTAPI_REQUEST       pNdisTapiRequest;

        Entry = 
            RemoveHeadList(&pVc->PendingDropReqs);

        NdisReleaseSpinLock(&pVc->Lock);

        pNdisTapiRequest = 
            CONTAINING_RECORD(Entry, NDISTAPI_REQUEST, Linkage);

        Irp = pNdisTapiRequest->Irp;

        ASSERT(pNdisTapiRequest == Irp->AssociatedIrp.SystemBuffer);

        IoSetCancelRoutine(Irp, NULL);

        Irp->IoStatus.Information = 
            sizeof(NDISTAPI_REQUEST) + (pNdisTapiRequest->ulDataSize - 1);

        Irp->IoStatus.Status = STATUS_SUCCESS;

        PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                  ("PxTapiCompleteIrp: Irp %p, Oid: %x\n", Irp, pNdisTapiRequest->Oid));

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        NdisAcquireSpinLock(&pVc->Lock);

    }

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiCompleteDropIrps: exit\n"));

    return;
}

VOID
PxTapiCompleteAllIrps(
    IN PPX_VC   pVc,
    IN ULONG    Status
    )

/*++

Routine Description:



Arguments:



Return Value:


--*/

{
    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiCompleteAllIrps: Vc %p\n", pVc));

    if (pVc->Flags & PX_VC_DROP_PENDING){
        PxTapiCompleteDropIrps(pVc, Status);
    }

    if (pVc->PendingGatherDigits != NULL) {

        PIRP                    Irp;
        KIRQL                   Irql;
        PNDISTAPI_REQUEST       pNdisTapiRequest;


        pNdisTapiRequest = pVc->PendingGatherDigits;
        pVc->PendingGatherDigits = NULL;

        NdisReleaseSpinLock(&pVc->Lock);

        Irp = pNdisTapiRequest->Irp;

        ASSERT(pNdisTapiRequest == Irp->AssociatedIrp.SystemBuffer);

        IoSetCancelRoutine(Irp, NULL);

        Irp->IoStatus.Information = 
            sizeof(NDISTAPI_REQUEST) + (pNdisTapiRequest->ulDataSize - 1);

        Irp->IoStatus.Status = STATUS_SUCCESS;

        PXDEBUGP (PXD_LOUD, PXM_TAPI, 
                  ("PxTapiCompleteIrp: Irp %p, Oid: %x\n", Irp, pNdisTapiRequest->Oid));

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        NdisAcquireSpinLock(&pVc->Lock);
    }

    PXDEBUGP (PXD_LOUD, PXM_TAPI, ("PxTapiCompleteAllIrps: exit\n"));

    return;
}

VOID
PxIndicateStatus(
    IN  PVOID   StatusBuffer,
    IN  UINT    StatusBufferSize
    )

/*++

Routine Description:

    Called to send any event info that may be in the device extension to TAPI in the form of an
    NDIS_TAPI_EVENT, sent in an available queued GET_EVENT IRP. If there's no outstanding IRP, stick
    the data in the queue so it will go whenver there is one.

Arguments:



Return Value:


--*/
{
    PIRP                    Irp;
    PNDIS_TAPI_EVENT        NdisTapiEvent;
    PNDISTAPI_EVENT_DATA    NdisTapiEventData;

    NdisTapiEvent = StatusBuffer;

    //
    // Sync event buf access by acquiring EventSpinLock
    //
    NdisAcquireSpinLock(&TspCB.Lock);

    //
    // Are we initialized with TAPI?
    //
    if (TspCB.Status != NDISTAPI_STATUS_CONNECTED) {
        PXDEBUGP(PXD_WARNING, PXM_TAPI, 
                 ("PxIndicateStatus: TAPI not connected!\n"));

        NdisReleaseSpinLock(&TspCB.Lock);

        return;
    }

    NdisReleaseSpinLock(&TspCB.Lock);

    NdisAcquireSpinLock(&TspEventList.Lock);

    Irp = TspEventList.RequestIrp;
    TspEventList.RequestIrp = NULL;

    if (Irp == NULL) {
        PPROVIDER_EVENT ProviderEvent;
        
        ProviderEvent =
            ExAllocateFromNPagedLookasideList(&ProviderEventLookaside);
        
        if (ProviderEvent != NULL) {
            RtlMoveMemory(&ProviderEvent->Event,
                          StatusBuffer,
                          sizeof(NDIS_TAPI_EVENT));
        
            InsertTailList(&TspEventList.List,
                           &ProviderEvent->Linkage);
        
            TspEventList.Count++;

            if (TspEventList.Count > TspEventList.MaxCount) {
                TspEventList.MaxCount = TspEventList.Count;
            }

        }
    } else {
        ASSERT(IsListEmpty(&TspEventList.List));
    }

    NdisReleaseSpinLock(&TspEventList.Lock);

    //
    // Check of there is an outstanding request to satisfy
    //
    if (Irp != NULL) {
        KIRQL   Irql;

        //
        // Clear out the cancel routine
        //
        IoSetCancelRoutine (Irp, NULL);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information =
            sizeof(NDISTAPI_EVENT_DATA) + StatusBufferSize - 1;

        //
        // Copy as much of the input data possible from the input data
        // queue to the SystemBuffer to satisfy the read.
        //
        NdisTapiEventData = Irp->AssociatedIrp.SystemBuffer;

        ASSERT(NdisTapiEventData->ulTotalSize >= StatusBufferSize);

        RtlMoveMemory(NdisTapiEventData->Data,
                      (PCHAR) StatusBuffer,
                      StatusBufferSize);

        //
        // Set the flag so that we start the next packet and complete
        // this read request (with STATUS_SUCCESS) prior to return.
        //

        NdisTapiEventData->ulUsedSize = StatusBufferSize;

        PXDEBUGP(PXD_LOUD, PXM_TAPI, 
                 ("PxIndicateStatus: htLine: %x, htCall: %x, Msg: %x\n",
                  NdisTapiEvent->htLine, NdisTapiEvent->htCall, NdisTapiEvent->ulMsg));

        PXDEBUGP(PXD_LOUD, PXM_TAPI, 
                 ("                : p1: %x, p2: %x, p3: %x\n",
                  NdisTapiEvent->ulParam1, NdisTapiEvent->ulParam2, NdisTapiEvent->ulParam3));

        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

    }
}

NDIS_STATUS
AllocateTapiResources(
    IN  PPX_ADAPTER     ClAdapter,
    IN  PPX_CL_AF       pClAf
    )
{
    NDIS_STATUS     Status;
    ULONG           SizeNeeded;
    ULONG           TapiVersion;
    PPX_TAPI_LINE   TapiLine = NULL;
    PPX_TAPI_ADDR   TapiAddr = NULL;
    UINT            i, j;
    PPX_TAPI_PROVIDER  TapiProvider;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("AllocateTapiResoures: Enter\n"));

    //
    // See if this device supports TAPI and if so
    // see how many lines it has
    //
    TapiProvider =
        AllocateTapiProvider(ClAdapter, pClAf);

    if (TapiProvider == NULL) {
        PXDEBUGP(PXD_ERROR, PXM_TAPI, ("Error allocating TapiProvider!\n"));
        return (NDIS_STATUS_FAILURE);
    }

    return (NDIS_STATUS_SUCCESS);
}

PPX_TAPI_PROVIDER
AllocateTapiProvider(
    PPX_ADAPTER     ClAdapter,
    PPX_CL_AF       pClAf
    )
{
    PNDIS_REQUEST   NdisRequest;
    NDIS_STATUS     Status;
    CO_TAPI_CM_CAPS CmCaps;
    BOOLEAN         TapiSupported = TRUE;
    ULONG           AllocSize;
    PPX_TAPI_PROVIDER   TapiProvider = NULL;
    ULONG           i;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("AllocateTapiProvider: Enter\n"));

    do {
        PX_REQUEST  ProxyRequest;
        PPX_REQUEST pProxyRequest = &ProxyRequest;

        NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));
        NdisZeroMemory(&CmCaps, sizeof(CmCaps));

        PxInitBlockStruc (&pProxyRequest->Block);

        NdisRequest = &pProxyRequest->NdisRequest;

        NdisRequest->RequestType =
        NdisRequestQueryInformation;
        NdisRequest->DATA.QUERY_INFORMATION.Oid =
            OID_CO_TAPI_CM_CAPS;
        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
            &CmCaps;
        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(CmCaps);

        Status =
            NdisCoRequest(ClAdapter->ClBindingHandle,
                          pClAf->NdisAfHandle,
                          NULL,
                          NULL,
                          NdisRequest);

        if (Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&pProxyRequest->Block);
        }

        if (Status != NDIS_STATUS_SUCCESS) {

            if (Status != NDIS_STATUS_NOT_SUPPORTED) {
                break;
            }

            Status = NDIS_STATUS_SUCCESS;
            //
            // Setup a default config for this device.
            // ToDo! These values should be read from
            // the registry on a per device basis!
            //
            CmCaps.ulNumLines = 1;
            CmCaps.ulFlags = 0;
            CmCaps.ulCoTapiVersion = CO_TAPI_VERSION;
            TapiSupported = FALSE;
        }

        //
        // Allocate a tapi provider block for this adapter
        // The provider block will live outside of the
        // adapter.  This allows us to continue tapi service
        // after a machine has been power managed.
        //

        AllocSize = sizeof(PX_TAPI_PROVIDER) +
                    (sizeof(PPX_TAPI_LINE) * CmCaps.ulNumLines) +
                    sizeof(PVOID);

        PxAllocMem(TapiProvider, AllocSize, PX_PROVIDER_TAG);

        if (TapiProvider == NULL) {
            break;
        }

        NdisZeroMemory(TapiProvider, AllocSize);

        NdisAllocateSpinLock(&TapiProvider->Lock);

        TapiProvider->Status = PROVIDER_STATUS_OFFLINE;

        TapiProvider->Adapter = ClAdapter;
        TapiProvider->ClAf = pClAf;
        TapiProvider->NumDevices = CmCaps.ulNumLines;
        TapiProvider->Guid = ClAdapter->Guid;
        TapiProvider->Af = pClAf->Af;
        PXDEBUGP(PXD_TAPI, PXM_TAPI, ("TapiProvider Allocated: GUID %4.4x-%2.2x-%2.2x-%1.1x%1.1x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x\n",
                 TapiProvider->Guid.Data1, TapiProvider->Guid.Data2, TapiProvider->Guid.Data3,
                 TapiProvider->Guid.Data4[0],TapiProvider->Guid.Data4[1],TapiProvider->Guid.Data4[2],
                 TapiProvider->Guid.Data4[3],TapiProvider->Guid.Data4[4],TapiProvider->Guid.Data4[5],
                 TapiProvider->Guid.Data4[6],TapiProvider->Guid.Data4[7]));

        TapiProvider->TapiSupported = TapiSupported;

        TapiProvider->TapiFlags |= CmCaps.ulFlags;

        TapiProvider->CoTapiVersion = CmCaps.ulCoTapiVersion;

        InitializeListHead(&TapiProvider->LineList);
        InitializeListHead(&TapiProvider->CreateList);

        for (i = 0; i < TapiProvider->NumDevices; i++) {
            PPX_TAPI_LINE   TapiLine;

            TapiLine =
                AllocateTapiLine(TapiProvider, i);

            if (TapiLine == NULL) {
                FreeTapiProvider(TapiProvider);
                TapiProvider = NULL;
                break;
            }

            //
            // Put the new line on the create list
            // We will need to insert it in the line table
            // and possibly notify tapi about it
            //
            InsertTailList(&TapiProvider->CreateList, &TapiLine->Linkage);
        }

    } while ( FALSE );

    if (TapiProvider != NULL) {
        PPX_TAPI_PROVIDER   tp;
        BOOLEAN             TapiConnected;

        //
        // See if we already have a provider for this
        // GUID.  If we don't just add this provider on
        // to the tsp and do the right thing with it's
        // new lines.  If we do see if anything on the
        // provider has changed and do the right thing
        // with it's tapi lines.
        //
        NdisAcquireSpinLock(&TspCB.Lock);

        tp = (PPX_TAPI_PROVIDER)TspCB.ProviderList.Flink;

        while ((PVOID)tp != (PVOID)&TspCB.ProviderList) {

            if ((tp->Status == PROVIDER_STATUS_OFFLINE) &&
                (NdisEqualMemory(&tp->Guid, &TapiProvider->Guid, sizeof(tp->Guid))) &&
                (pClAf->Af.AddressFamily == tp->Af.AddressFamily)) {

                //
                // We have already have a provider for this 
                // adapter/address family.  See if anything has
                // changed.  
                //
                //
                // ToDo!
                // This check needs to be more complete!
                //
                if (tp->NumDevices != TapiProvider->NumDevices) {
                    //
                    // ToDo!
                    // Much work to do here!
                    //

                } else {
                    //
                    // Nothing has changed so free the new allocations
                    // and reactivate the old ones.
                    //

                    FreeTapiProvider(TapiProvider);

                    TapiProvider = tp;
                }

                PXDEBUGP(PXD_TAPI, PXM_TAPI, ("TapiProvider found: GUID %4.4x-%2.2x-%2.2x-%1.1x%1.1x-%1.1x%1.1x%1.1x%1.1x%1.1x%1.1x\n",
                         ClAdapter->Guid.Data1, ClAdapter->Guid.Data2, ClAdapter->Guid.Data3,
                         ClAdapter->Guid.Data4[0],ClAdapter->Guid.Data4[1],ClAdapter->Guid.Data4[2],
                         ClAdapter->Guid.Data4[3],ClAdapter->Guid.Data4[4],ClAdapter->Guid.Data4[5],
                         ClAdapter->Guid.Data4[6],ClAdapter->Guid.Data4[7]));
                break;

            } else {

                tp = (PPX_TAPI_PROVIDER)tp->Linkage.Flink;
            }
        }

        //
        // We did not find a provider on the list
        // so insert the new provider
        //
        if ((PVOID)tp == (PVOID)&TspCB.ProviderList) {
            InsertTailList(&TspCB.ProviderList, &TapiProvider->Linkage);
            TspCB.NdisTapiNumDevices += TapiProvider->NumDevices;
        }

        if (TspCB.Status == NDISTAPI_STATUS_CONNECTED) {
            TapiProvider->Status = PROVIDER_STATUS_ONLINE;
        }

        NdisReleaseSpinLock(&TspCB.Lock);

        NdisAcquireSpinLock(&TapiProvider->Lock);

        pClAf->TapiProvider = TapiProvider;
        TapiProvider->ClAf= pClAf;
        TapiProvider->Adapter = ClAdapter;

        while (!IsListEmpty(&TapiProvider->CreateList)) {
            PPX_TAPI_LINE   TapiLine;

            TapiLine = (PPX_TAPI_LINE)
                RemoveHeadList(&TapiProvider->CreateList);

            InsertTailList(&TapiProvider->LineList, &TapiLine->Linkage);

            //
            // Insert the line in the table
            //
            if (!InsertLineInTable(TapiLine)) {
                FreeTapiLine(TapiLine);
                continue;
            }

            NdisReleaseSpinLock(&TapiProvider->Lock);

            SendTapiLineCreate(TapiLine);

            NdisAcquireSpinLock(&TapiProvider->Lock);
        }

        MarkProviderOnline(TapiProvider);

        NdisReleaseSpinLock(&TapiProvider->Lock);
    }

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("TapiProvider: %x\n", TapiProvider));

    return (TapiProvider);
}

VOID
MarkProviderOffline(
    PPX_TAPI_PROVIDER   TapiProvider
    )
{
    LOCK_STATE      LockState;
    ULONG           i;

    TapiProvider->Status = PROVIDER_STATUS_OFFLINE;
    TapiProvider->ClAf = NULL;
    TapiProvider->Adapter = NULL;

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = LineTable.Table[i];

        if (TapiLine != NULL) {

            NdisAcquireSpinLock(&TapiLine->Lock);

            if (TapiLine->TapiProvider == TapiProvider) {

                TapiLine->DevStatus->ulDevStatusFlags &=
                    ~(LINEDEVSTATUSFLAGS_INSERVICE);
    
                TapiLine->ClAf = NULL;
    
                NdisReleaseSpinLock(&TapiLine->Lock);

#if 0
                NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);

                SendTapiLineClose(TapiLine);

                NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);
#endif

            } else {

                NdisReleaseSpinLock(&TapiLine->Lock);
            }
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
}

VOID
MarkProviderOnline(
   PPX_TAPI_PROVIDER   TapiProvider
   )
{
    LOCK_STATE      LockState;
    ULONG           i;

    TapiProvider->Status = PROVIDER_STATUS_ONLINE;

    NdisReleaseSpinLock(&TapiProvider->Lock);

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = LineTable.Table[i];

        if (TapiLine != NULL) {

            NdisAcquireSpinLock(&TapiLine->Lock);

            if (TapiLine->TapiProvider == TapiProvider) {

                TapiLine->DevStatus->ulDevStatusFlags |=
                    LINEDEVSTATUSFLAGS_INSERVICE;
    
                TapiLine->ClAf = TapiProvider->ClAf;

//#if 0
                //
                // This line was open by tapi before it was
                // marked offline.  We need to force tapi to
                // reopen the line so we will send the CLOSE_LINE
                // message in the hopes that any apps that care
                // will then turn around and reopen the line.
                //
                if (TapiLine->DevStatus->ulNumOpens != 0) {
//                    TapiLine->DevStatus->ulNumOpens = 0;

                    NdisReleaseSpinLock(&TapiLine->Lock);

                    SendTapiLineClose(TapiLine);

                    NdisAcquireSpinLock(&TapiLine->Lock);
                }
//#endif

            }

            NdisReleaseSpinLock(&TapiLine->Lock);
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);

    NdisAcquireSpinLock(&TapiProvider->Lock);
}


VOID
MarkProviderConnected(
  PPX_TAPI_PROVIDER   TapiProvider
  )
{
    LOCK_STATE      LockState;
    ULONG           i;

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = LineTable.Table[i];

        if (TapiLine != NULL) {

            NdisAcquireSpinLock(&TapiLine->Lock);

            if (TapiLine->TapiProvider == TapiProvider) {

                TapiLine->DevStatus->ulDevStatusFlags |=
                    LINEDEVSTATUSFLAGS_CONNECTED;
            }

            NdisReleaseSpinLock(&TapiLine->Lock);
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
}

VOID
MarkProviderDisconnected(
  PPX_TAPI_PROVIDER   TapiProvider
  )
{
    LOCK_STATE      LockState;
    ULONG           i;

    //
    // ToDo! If we have any active calls on this line we
    // need to disconnect them without tapi's assistance.  This
    // would only happen if tapi crashes while we have active calls
    //

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = LineTable.Table[i];

        if (TapiLine != NULL) {

            NdisAcquireSpinLock(&TapiLine->Lock);

            if (TapiLine->TapiProvider == TapiProvider) {

                TapiLine->DevStatus->ulDevStatusFlags &=
                    ~(LINEDEVSTATUSFLAGS_CONNECTED);
            }

            NdisReleaseSpinLock(&TapiLine->Lock);
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
}

VOID
ClearSapWithTapiLine(
    PPX_CL_SAP  pClSap
  )
{
    LOCK_STATE      LockState;
    ULONG           i;

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = LineTable.Table[i];

        if (TapiLine != NULL) {

            NdisAcquireSpinLock(&TapiLine->Lock);

            if (TapiLine->ClSap == pClSap) {
                TapiLine->ClSap = NULL;
            }

            NdisReleaseSpinLock(&TapiLine->Lock);
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
}


VOID
FreeTapiProvider(
    PPX_TAPI_PROVIDER   TapiProvider
    )
{
    //
    // Free any lines on the create list
    //
    while (!IsListEmpty(&TapiProvider->CreateList)) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = (PPX_TAPI_LINE)
            RemoveHeadList(&TapiProvider->CreateList);

        FreeTapiLine(TapiLine);
    }

    //
    // Free the lines associated with this provider
    //
    while (!IsListEmpty(&TapiProvider->LineList)) {
        PPX_TAPI_LINE   TapiLine;

        TapiLine = (PPX_TAPI_LINE)
            RemoveHeadList(&TapiProvider->LineList);

        if (TapiLine->Flags & PX_LINE_IN_TABLE) {
            RemoveTapiLineFromTable(TapiLine);
        }

        FreeTapiLine(TapiLine);
    }

    NdisFreeSpinLock(&TapiProvider->Lock);

    PxFreeMem(TapiProvider);
}

PPX_TAPI_LINE
AllocateTapiLine(
    PPX_TAPI_PROVIDER   TapiProvider,
    ULONG               LineNumber
    )
{
    PLINE_DEV_CAPS      ldc;
    PNDIS_REQUEST       NdisRequest;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    PCO_TAPI_LINE_CAPS  LineCaps;
    PUCHAR              EnumBuffer;
#if DBG
    ULONG               EnumBufferSize = PAGE_SIZE -
                                         sizeof(PXD_ALLOCATION);
#else
    ULONG               EnumBufferSize = PAGE_SIZE;
#endif
    ULONG               SizeNeeded, SizeDevCaps;
    PPX_TAPI_LINE       TapiLine = NULL;
    PPX_ADAPTER         ClAdapter = TapiProvider->Adapter;
    PPX_CL_AF           pClAf = TapiProvider->ClAf;
    ULONG               i;
    PX_REQUEST          ProxyRequest;
    PPX_REQUEST         pProxyRequest = &ProxyRequest;

    PxAllocMem((PCO_TAPI_LINE_CAPS)EnumBuffer, EnumBufferSize, PX_ENUMLINE_TAG);

    if (EnumBuffer == NULL) {
        return (NULL);
    }

    NdisZeroMemory(EnumBuffer, EnumBufferSize);

    LineCaps = (PCO_TAPI_LINE_CAPS)EnumBuffer;

    LineCaps->ulLineID = LineNumber;

    ldc = &LineCaps->LineDevCaps;

    ldc->ulTotalSize =
        EnumBufferSize - (sizeof(CO_TAPI_LINE_CAPS) - sizeof(LINE_DEV_CAPS));

    //
    // If this device does not support TAPI we will build
    // a default line configuration.
    // ToDo! Some of these values should be queried from
    // the registry on a per device basis!
    //
    if (!TapiProvider->TapiSupported) {
        NDIS_CO_LINK_SPEED   SpeedInfo;

        LineCaps->ulFlags = 0;

        ldc->ulTotalSize =
        ldc->ulNeededSize =
        ldc->ulUsedSize =
            sizeof(LINE_DEV_CAPS);
        ldc->ulStringFormat = STRINGFORMAT_ASCII;
        ldc->ulAddressModes = LINEADDRESSMODE_ADDRESSID;
        ldc->ulNumAddresses = 1;
        ldc->ulBearerModes = LINEBEARERMODE_VOICE |
                             LINEBEARERMODE_DATA;
        ldc->ulMediaModes = LINEMEDIAMODE_DIGITALDATA;
        ldc->ulMaxNumActiveCalls = 1000;

        NdisZeroMemory(pProxyRequest, sizeof(ProxyRequest));

        PxInitBlockStruc (&pProxyRequest->Block);

        NdisRequest = &pProxyRequest->NdisRequest;

        NdisRequest->RequestType =
            NdisRequestQueryInformation;

        NdisRequest->DATA.QUERY_INFORMATION.Oid =
            OID_GEN_CO_LINK_SPEED;

        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
            &SpeedInfo;

        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
            sizeof(NDIS_CO_LINK_SPEED);

        PXDEBUGP(PXD_INFO, PXM_CO, ("NDProxy: DeviceExtension->RegistryFlags = %x\n", DeviceExtension->RegistryFlags));

        PXDEBUGP(PXD_INFO, PXM_CO, ("NDProxy: using ndisrequest to get rates from adapter\n"));

        Status =
            NdisCoRequest(ClAdapter->ClBindingHandle,
                          pClAf->NdisAfHandle,
                          NULL,
                          NULL,
                          NdisRequest);

        if (Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&pProxyRequest->Block);
        }

        if (Status == NDIS_STATUS_SUCCESS) {
            ldc->ulMaxRate = SpeedInfo.Outbound;
        } else {
            ldc->ulMaxRate = 128000;
        }

    } else if (!(TapiProvider->TapiFlags & CO_TAPI_FLAG_PER_LINE_CAPS) &&
                (LineNumber > 0)) {

        PLINE_DEV_CAPS      ldc1;
        PCO_TAPI_LINE_CAPS  LineCaps1;
        PPX_TAPI_LINE       Line1;

        //
        // If all of the lines on this device have the same caps
        // and this is not the first line, just copy the caps
        // from the first line!
        //
        Line1 = (PPX_TAPI_LINE)
            TapiProvider->CreateList.Flink;

        ldc1 = Line1->DevCaps;

        if (ldc1->ulTotalSize > ldc->ulTotalSize) {

            //
            // We don't have enough memory allocated!
            //
            PxFreeMem(EnumBuffer);

            EnumBufferSize =
                (sizeof(CO_TAPI_LINE_CAPS) - sizeof(LINE_DEV_CAPS) +
                 ldc1->ulTotalSize);

            PxAllocMem((PCO_TAPI_LINE_CAPS)EnumBuffer, EnumBufferSize, PX_ENUMLINE_TAG);

            if (EnumBuffer == NULL){
                return (NULL);
            }

            NdisZeroMemory(EnumBuffer, EnumBufferSize);

            LineCaps = (PCO_TAPI_LINE_CAPS)EnumBuffer;
            LineCaps->ulLineID = LineNumber;
            LineCaps->LineDevCaps.ulTotalSize =
                EnumBufferSize - (sizeof(CO_TAPI_LINE_CAPS) -
                sizeof(LINE_DEV_CAPS));

            ldc = &LineCaps->LineDevCaps;
        }

        NdisMoveMemory(ldc, ldc1, ldc1->ulUsedSize);

    } else {

        NdisZeroMemory(pProxyRequest, sizeof(ProxyRequest));

        PxInitBlockStruc (&pProxyRequest->Block);

        NdisRequest = &pProxyRequest->NdisRequest;

        NdisRequest->RequestType =
        NdisRequestQueryInformation;
        NdisRequest->DATA.QUERY_INFORMATION.Oid =
            OID_CO_TAPI_LINE_CAPS;
        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
            LineCaps;
        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
            EnumBufferSize;

        Status =
            NdisCoRequest(ClAdapter->ClBindingHandle,
                          pClAf->NdisAfHandle,
                          NULL,
                          NULL,
                          NdisRequest);

        if (Status == NDIS_STATUS_PENDING) {
            Status = PxBlock(&pProxyRequest->Block);
        }

        if (Status == NDIS_STATUS_INVALID_LENGTH){
            

            //
            // Our buffer was not large enough so try again
            //
            
            EnumBufferSize =
                MAX (LineCaps->LineDevCaps.ulNeededSize,
                     NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded);

            PxFreeMem(EnumBuffer);

            PxAllocMem((PCO_TAPI_LINE_CAPS)EnumBuffer, EnumBufferSize, PX_ENUMLINE_TAG);

            if (EnumBuffer == NULL){
                return(NULL);
            }

            NdisZeroMemory(EnumBuffer, EnumBufferSize);

            LineCaps = (PCO_TAPI_LINE_CAPS)EnumBuffer;
            LineCaps->ulLineID = LineNumber;

            ldc = &LineCaps->LineDevCaps;

            ldc->ulTotalSize =
                EnumBufferSize - (sizeof(CO_TAPI_LINE_CAPS) - sizeof(LINE_DEV_CAPS));

            NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

            PxInitBlockStruc (&pProxyRequest->Block);

            NdisRequest = &pProxyRequest->NdisRequest;

            NdisRequest->RequestType =
                NdisRequestQueryInformation;
            NdisRequest->DATA.QUERY_INFORMATION.Oid =
                OID_CO_TAPI_LINE_CAPS;
            NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                LineCaps;
            NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                EnumBufferSize;

            Status =
                NdisCoRequest(ClAdapter->ClBindingHandle,
                              pClAf->NdisAfHandle,
                              NULL,
                              NULL,
                              NdisRequest);

            if (Status == NDIS_STATUS_PENDING){
                Status = PxBlock(&pProxyRequest->Block);
            }

            if (Status != NDIS_STATUS_SUCCESS){
                PxFreeMem(EnumBuffer);
                return(NULL);
            }

        }else if (Status != STATUS_SUCCESS){
            PxFreeMem(EnumBuffer);
            return(NULL);
        }
    }

    SizeNeeded = sizeof(PX_TAPI_LINE);
    SizeNeeded +=
        (sizeof(PPX_TAPI_ADDR) * LineCaps->LineDevCaps.ulNumAddresses);
    SizeNeeded += sizeof(LINE_DEV_STATUS);
    SizeNeeded += 3*sizeof(PVOID);

    if (LineCaps->LineDevCaps.ulUsedSize < sizeof(LINE_DEV_CAPS)) {
        LineCaps->LineDevCaps.ulUsedSize = sizeof(LINE_DEV_CAPS);
    }

    SizeDevCaps = LineCaps->LineDevCaps.ulUsedSize;

    SizeNeeded += SizeDevCaps;

    PxAllocMem(TapiLine, SizeNeeded, PX_TAPILINE_TAG);

    if (TapiLine == NULL){
        PxFreeMem(EnumBuffer);
        return(NULL);
    }

    NdisZeroMemory(TapiLine, SizeNeeded);

    TapiLine->DevCaps = (PLINE_DEV_CAPS)
        ((PUCHAR)TapiLine + sizeof(PX_TAPI_LINE) + sizeof(PVOID));

    (ULONG_PTR)TapiLine->DevCaps &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    TapiLine->DevStatus = (PLINE_DEV_STATUS)
        ((PUCHAR)TapiLine->DevCaps + SizeDevCaps + sizeof(PVOID));

    (ULONG_PTR)TapiLine->DevStatus &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    TapiLine->AddrTable.Table = (PPX_TAPI_ADDR*)
        ((PUCHAR)TapiLine->DevStatus + 
         sizeof(LINE_DEV_STATUS) + sizeof(PVOID));

    (ULONG_PTR)TapiLine->AddrTable.Table &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    NdisMoveMemory(TapiLine->DevCaps,
                   &LineCaps->LineDevCaps,
                   LineCaps->LineDevCaps.ulUsedSize);

    ldc = TapiLine->DevCaps;

    //
    // Proxy fills some fields on behalf of all cm/miniports
    //
    ldc->ulPermanentLineID = 
        TapiProvider->Guid.Data1 + LineNumber;
    ldc->ulAddressModes = LINEADDRESSMODE_ADDRESSID;
    ldc->ulAnswerMode = LINEANSWERMODE_NONE;
    ldc->ulLineStates = LINEDEVSTATE_CONNECTED |
                        LINEDEVSTATE_DISCONNECTED |
                        LINEDEVSTATE_OPEN |
                        LINEDEVSTATE_CLOSE |
                        LINEDEVSTATE_INSERVICE |
                        LINEDEVSTATE_OUTOFSERVICE |
                        LINEDEVSTATE_REMOVED;
    ldc->ulDevCapFlags = LINEDEVCAPFLAGS_CLOSEDROP;
    ldc->PermanentLineGuid = TapiProvider->Guid;

    ldc->ulTotalSize =
    ldc->ulNeededSize =
        ldc->ulUsedSize;

    TapiLine->TapiProvider = TapiProvider;
    TapiLine->CmLineID = LineNumber;
    TapiLine->Flags |= LineCaps->ulFlags;
    TapiLine->DevStatus->ulTotalSize =
    TapiLine->DevStatus->ulNeededSize =
    TapiLine->DevStatus->ulUsedSize = sizeof(LINE_DEV_STATUS);
    TapiLine->ClAf = pClAf;
    TapiLine->RefCount= 1;

    //
    // Build the address table for this line
    //
    InitializeListHead(&TapiLine->AddrTable.List);

    NdisAllocateSpinLock(&TapiLine->Lock);

    TapiLine->AddrTable.Size = TapiLine->DevCaps->ulNumAddresses;

    PXDEBUGP(PXD_TAPI, PXM_TAPI,
        ("Allocated TapiLine %p LineId %d \n", TapiLine, TapiLine->CmLineID));

    for (i = 0; i < TapiLine->DevCaps->ulNumAddresses; i++) {
        PPX_TAPI_ADDR   TapiAddr;

        TapiAddr =
            AllocateTapiAddr(TapiProvider, TapiLine, i);

        if (TapiAddr == NULL) {
            FreeTapiLine(TapiLine);
            TapiLine = NULL;
            break;
        }

        //
        // Insert the address in the line's address table
        //
        TapiLine->AddrTable.Table[i] = TapiAddr;
        InsertTailList(&TapiLine->AddrTable.List,
                       &TapiAddr->Linkage);
        TapiLine->AddrTable.Count++;
    }

    PxFreeMem(EnumBuffer);

    return (TapiLine);
}


VOID
FreeTapiLine(
    PPX_TAPI_LINE   TapiLine
    )
{
    ULONG   i;

    for (i = 0; i < TapiLine->DevCaps->ulNumAddresses; i++){
        PPX_TAPI_ADDR   TapiAddr;

        //
        // Remove the address from the line table
        //
        TapiAddr = TapiLine->AddrTable.Table[i];

        if (TapiAddr != NULL) {

            RemoveEntryList(&TapiAddr->Linkage);
            TapiLine->AddrTable.Table[i] = NULL;
            TapiLine->AddrTable.Count--;

            //
            // Free the address memory
            //
            FreeTapiAddr(TapiAddr);
        }
    }

    NdisFreeSpinLock(&TapiLine->Lock);

    //
    // Free the line memory
    //
    PxFreeMem(TapiLine);
}


PPX_TAPI_ADDR
AllocateTapiAddr(
    PPX_TAPI_PROVIDER   TapiProvider,
    PPX_TAPI_LINE       TapiLine,
    ULONG               AddrID
    )
{
    PPX_TAPI_ADDR   TapiAddr;
    PUCHAR          EnumBuffer;
#if DBG
    ULONG           EnumBufferSize = PAGE_SIZE -
                                     sizeof(PXD_ALLOCATION);
#else
    ULONG           EnumBufferSize = PAGE_SIZE;
#endif
    PNDIS_REQUEST   NdisRequest;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    ULONG           SizeNeeded;
    PPX_ADAPTER     ClAdapter = TapiProvider->Adapter;
    PPX_CL_AF       pClAf = TapiProvider->ClAf;
    PX_REQUEST      ProxyRequest;
    PPX_REQUEST     pProxyRequest = &ProxyRequest;
    PLINE_ADDRESS_CAPS      ac;
    PCO_TAPI_ADDRESS_CAPS   AddrCaps;

    PxAllocMem((PCO_TAPI_ADDRESS_CAPS)EnumBuffer, EnumBufferSize, PX_ENUMADDR_TAG);

    if (EnumBuffer == NULL){
        return(NULL);
    }

    NdisZeroMemory(EnumBuffer, EnumBufferSize);

    AddrCaps = (PCO_TAPI_ADDRESS_CAPS)EnumBuffer;
    AddrCaps->ulLineID = TapiLine->CmLineID;
    AddrCaps->ulAddressID = AddrID;

    ac = &AddrCaps->LineAddressCaps;

    ac->ulTotalSize =
        EnumBufferSize - (sizeof(CO_TAPI_ADDRESS_CAPS) - sizeof(LINE_ADDRESS_CAPS));

    //
    // If this device does not support TAPI we will
    // build a default address.
    // ToDo! Some of these values should be queried from
    // the registry on a per device basis!
    //
    if (!TapiProvider->TapiSupported){
        ac->ulTotalSize =
        ac->ulNeededSize =
        ac->ulUsedSize = sizeof(LINE_ADDRESS_CAPS);
        ac->ulMaxNumActiveCalls = 1000;

    }else if (!(TapiLine->Flags & CO_TAPI_FLAG_PER_ADDRESS_CAPS) &&
              (AddrID > 0)){

        PLINE_ADDRESS_CAPS      ac1;
        PCO_TAPI_ADDRESS_CAPS   AddrCaps1;
        PPX_TAPI_ADDR           Addr1;

        //
        // If all of the addresses on this line have the same
        // caps and this is not the first address, just copy
        // the caps from the first address!
        //
        Addr1 = (PPX_TAPI_ADDR)
            TapiLine->AddrTable.List.Flink;

        ac1 = Addr1->Caps;

        if (ac1->ulTotalSize > ac->ulTotalSize){

            //
            // We don't have enough memory allocated!
            //
            PxFreeMem(EnumBuffer);

            EnumBufferSize =
                (sizeof(CO_TAPI_ADDRESS_CAPS) - sizeof(LINE_ADDRESS_CAPS) +
                ac1->ulTotalSize);

            PxAllocMem((PCO_TAPI_ADDRESS_CAPS)EnumBuffer, EnumBufferSize, PX_ENUMADDR_TAG);

            if (EnumBuffer == NULL){
                return (NULL);
            }

            NdisZeroMemory(EnumBuffer, EnumBufferSize);

            AddrCaps = (PCO_TAPI_ADDRESS_CAPS)EnumBuffer;
            AddrCaps->ulLineID = TapiLine->CmLineID;
            AddrCaps->ulAddressID = AddrID;
            AddrCaps->LineAddressCaps.ulTotalSize = EnumBufferSize -
                (sizeof(CO_TAPI_ADDRESS_CAPS) - sizeof(LINE_ADDRESS_CAPS));
        }

        ac = &AddrCaps->LineAddressCaps;

        NdisMoveMemory(ac, ac1, ac1->ulUsedSize);

    }else{

        NdisZeroMemory(pProxyRequest, sizeof(ProxyRequest));

        PxInitBlockStruc (&pProxyRequest->Block);

        NdisRequest = &pProxyRequest->NdisRequest;

        NdisRequest->RequestType =
            NdisRequestQueryInformation;
        NdisRequest->DATA.QUERY_INFORMATION.Oid =
            OID_CO_TAPI_ADDRESS_CAPS;
        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
            AddrCaps;
        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
            EnumBufferSize;

        Status =
        NdisCoRequest(ClAdapter->ClBindingHandle,
                      pClAf->NdisAfHandle,
                      NULL,
                      NULL,
                      NdisRequest);

        if (Status == NDIS_STATUS_PENDING){
            Status = PxBlock(&pProxyRequest->Block);
        }

        if (Status == NDIS_STATUS_INVALID_LENGTH){

            //
            // Our buffer was not large enough so try again
            //
            SizeNeeded =
            EnumBufferSize =
            NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded;

            PxFreeMem(EnumBuffer);

            PxAllocMem((PCO_TAPI_ADDRESS_CAPS)EnumBuffer, EnumBufferSize, PX_ENUMADDR_TAG);

            if (EnumBuffer == NULL){
                return(NULL);
            }

            NdisZeroMemory(EnumBuffer, EnumBufferSize);

            AddrCaps = (PCO_TAPI_ADDRESS_CAPS)EnumBuffer;
            AddrCaps->ulLineID = TapiLine->CmLineID;
            AddrCaps->ulAddressID = AddrID;
            AddrCaps->LineAddressCaps.ulTotalSize = EnumBufferSize -
                (sizeof(CO_TAPI_ADDRESS_CAPS) - sizeof(LINE_ADDRESS_CAPS));

            NdisZeroMemory(pProxyRequest, sizeof(ProxyRequest));

            PxInitBlockStruc (&pProxyRequest->Block);

            NdisRequest = &pProxyRequest->NdisRequest;

            NdisRequest->RequestType =
                NdisRequestQueryInformation;
            NdisRequest->DATA.QUERY_INFORMATION.Oid =
                OID_CO_TAPI_ADDRESS_CAPS;
            NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                AddrCaps;
            NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                EnumBufferSize;

            Status =
                NdisCoRequest(ClAdapter->ClBindingHandle,
                              pClAf->NdisAfHandle,
                              NULL,
                              NULL,
                              NdisRequest);

            if (Status == NDIS_STATUS_PENDING){
                Status = PxBlock(&pProxyRequest->Block);
            }

            if (Status != NDIS_STATUS_SUCCESS){
                PxFreeMem(EnumBuffer);
                return(NULL);
            }

        }else if (Status != STATUS_SUCCESS){
            PxFreeMem(EnumBuffer);
            return(NULL);
        }
    }

    if (AddrCaps->LineAddressCaps.ulUsedSize < sizeof(LINE_ADDRESS_CAPS)) {
        AddrCaps->LineAddressCaps.ulUsedSize = sizeof(LINE_ADDRESS_CAPS);
    }

    SizeNeeded = sizeof(PX_TAPI_ADDR);
    SizeNeeded += AddrCaps->LineAddressCaps.ulUsedSize;
    SizeNeeded += sizeof(LINE_ADDRESS_STATUS);
    SizeNeeded += 2*sizeof(PVOID);

    PxAllocMem(TapiAddr, SizeNeeded, PX_TAPIADDR_TAG);

    if (TapiAddr == NULL){
        PxFreeMem(EnumBuffer);
        return (NULL);
    }

    NdisZeroMemory((PUCHAR)TapiAddr, SizeNeeded);

    TapiAddr->Caps = (PLINE_ADDRESS_CAPS)
        ((PUCHAR)TapiAddr + sizeof(PX_TAPI_ADDR) + sizeof(PVOID));

    (ULONG_PTR)TapiAddr->Caps &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    TapiAddr->AddrStatus = (PLINE_ADDRESS_STATUS)
        ((PUCHAR)TapiAddr->Caps + 
         AddrCaps->LineAddressCaps.ulUsedSize + sizeof(PVOID));

    (ULONG_PTR)TapiAddr->AddrStatus &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    NdisMoveMemory(TapiAddr->Caps,
                   &AddrCaps->LineAddressCaps,
                   AddrCaps->LineAddressCaps.ulUsedSize);

    //
    // Proxy fills some fields on behalf of all cm/miniports
    //
    ac = TapiAddr->Caps;

    if (ac->ulTotalSize < ac->ulUsedSize) {
        ac->ulTotalSize = ac->ulUsedSize;
    }

    if (ac->ulNeededSize < ac->ulNeededSize) {
        ac->ulNeededSize = ac->ulUsedSize;
    }

    ac->ulLineDeviceID = TapiLine->ulDeviceID;
    ac->ulAddressSharing = LINEADDRESSSHARING_PRIVATE;
    ac->ulAddressStates = LINEADDRESSSTATE_NUMCALLS;
    ac->ulCallInfoStates = LINECALLINFOSTATE_BEARERMODE |
                           LINECALLINFOSTATE_RATE |
                           LINECALLINFOSTATE_MEDIAMODE;

    ac->ulCallStates = LINECALLSTATE_IDLE |
                       LINECALLSTATE_OFFERING |
                       LINECALLSTATE_ACCEPTED |
                       LINECALLSTATE_BUSY |
                       LINECALLSTATE_CONNECTED |
                       LINECALLSTATE_PROCEEDING |
                       LINECALLSTATE_DISCONNECTED;

    ac->ulDialToneModes = 0;
    ac->ulBusyModes = LINEBUSYMODE_UNAVAIL;
    ac->ulSpecialInfo = 0;

    ac->ulDisconnectModes = LINEDISCONNECTMODE_NORMAL |
                            LINEDISCONNECTMODE_BUSY |
                            LINEDISCONNECTMODE_NOANSWER;

    TapiAddr->TapiLine = TapiLine;
    TapiAddr->AddrId = AddrID;

    PxFreeMem(EnumBuffer);

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("Allocated TapiAddr %p AddrId %d for TapiLine %p\n", TapiAddr, TapiAddr->AddrId, TapiLine));

    return (TapiAddr);
}

VOID
FreeTapiAddr(
    PPX_TAPI_ADDR   TapiAddr
    )
{
    //
    // ToDo! we need to tear down all
    // active calls on this address.
    //

    PxFreeMem(TapiAddr);
}

NDIS_STATUS
AllocateTapiCallInfo(
    PPX_VC          pVc,
    LINE_CALL_INFO  UNALIGNED *LineCallInfo
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG   SizeNeeded;

    if (pVc->CallInfo) {
        PxFreeMem(pVc->CallInfo);
    }

    if (LineCallInfo != NULL) {
        SizeNeeded = LineCallInfo->ulUsedSize;
    } else {
        SizeNeeded = sizeof(LINE_CALL_INFO) + LINE_CALL_INFO_VAR_DATA_SIZE;
    }

    PxAllocMem(pVc->CallInfo, SizeNeeded, PX_LINECALLINFO_TAG);

    if (pVc->CallInfo == NULL) {
        return (NDIS_STATUS_RESOURCES);
    }

    pVc->ulCallInfoFieldsChanged = 0;

    NdisZeroMemory(pVc->CallInfo, SizeNeeded);

    if (LineCallInfo != NULL) {
        NdisMoveMemory(pVc->CallInfo,
                       LineCallInfo,
                       LineCallInfo->ulUsedSize);
    } else {
        pVc->CallInfo->ulTotalSize = SizeNeeded;
        pVc->CallInfo->ulNeededSize = SizeNeeded;
        pVc->CallInfo->ulUsedSize = sizeof(LINE_CALL_INFO);
    }

    return (Status);
}

BOOLEAN
InsertVcInTable(
    PPX_VC      pVc
    )
{
    ULONG       i;
    ULONG       index;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    LOCK_STATE  LockState;
    PPX_CL_AF   pClAf;

    NdisAcquireReadWriteLock(&VcTable.Lock, TRUE, &LockState);

    if (VcTable.Count == VcTable.Size) {
        ULONG       SizeNeeded;
        PUCHAR      AllocatedMemory;
        PPX_VC      *NewTable;

        //
        // Grow the table
        //
        SizeNeeded =
            (VcTable.Size + VcTable.Size/2) * sizeof(PPX_VC);
        PxAllocMem(AllocatedMemory, SizeNeeded, PX_VCTABLE_TAG);

        if (AllocatedMemory == NULL) {
            NdisReleaseReadWriteLock(&VcTable.Lock, &LockState);
            return (FALSE);
        }

        RtlZeroMemory(AllocatedMemory,SizeNeeded);

        NewTable = (PPX_VC*)AllocatedMemory;

        RtlMoveMemory((PUCHAR)NewTable,
                      (PUCHAR)VcTable.Table,
                      (sizeof(PPX_VC) * VcTable.Size));

        PxFreeMem(VcTable.Table);

        VcTable.Table = NewTable;
        VcTable.Size += VcTable.Size/2;
    }

    i = VcTable.Size;
    index = VcTable.NextSlot;

    do {

        if (VcTable.Table[index] == NULL) {

            NdisDprAcquireSpinLock(&pVc->Lock);

            pVc->hdCall = index;

            VcTable.Table[index] = pVc;
            InsertTailList(&VcTable.List,
                           &pVc->Linkage);
            VcTable.Count++;
            VcTable.NextSlot =
                (VcTable.NextSlot + 1) % VcTable.Size;

            pVc->Flags |= PX_VC_IN_TABLE;
            pClAf = pVc->ClAf;

            NdisDprReleaseSpinLock(&pVc->Lock);

            PXDEBUGP(PXD_TAPI, PXM_TAPI, ("Inserting pVc %x in VcTable hdCall %d\n", pVc, pVc->hdCall));
            break;
        }
        index = (index+1) % VcTable.Size;

    } while (--i);

    NdisReleaseReadWriteLock(&VcTable.Lock, &LockState);

    if (i != 0) {
        NdisAcquireSpinLock(&pClAf->Lock);
        REF_CL_AF(pClAf);
        InsertTailList(&pClAf->VcList, &pVc->ClAfLinkage);
        NdisReleaseSpinLock(&pClAf->Lock);
    } else {
        PXDEBUGP(PXD_TAPI,PXM_TAPI, ("Failed to insert pVc %x in VcTable\n", pVc));
    }

    return (i != 0);
}

VOID
RemoveVcFromTable(
    PPX_VC      pVc
    )
{
    LOCK_STATE  LockState;
    PPX_CL_AF   pClAf;

    PXDEBUGP(PXD_TAPI, PXM_TAPI, ("Removing pVc %x from VcTable hdCall %d\n", pVc, pVc->hdCall));

    NdisAcquireReadWriteLock(&VcTable.Lock, TRUE, &LockState);

    ASSERT(VcTable.Table[pVc->hdCall] == pVc);


    VcTable.Table[pVc->hdCall] = NULL;

    VcTable.Count--;

    NdisDprAcquireSpinLock(&pVc->Lock);

    RemoveEntryList(&pVc->Linkage);

    pVc->Flags &= ~PX_VC_IN_TABLE;
    pClAf = pVc->ClAf;

    NdisDprReleaseSpinLock(&pVc->Lock);

    NdisReleaseReadWriteLock(&VcTable.Lock, &LockState);

    NdisAcquireSpinLock(&pClAf->Lock);

    RemoveEntryList(&pVc->ClAfLinkage);

    DEREF_CL_AF_LOCKED(pClAf);
}

BOOLEAN
IsTapiLineValid(
    ULONG           hdLine,
    PPX_TAPI_LINE   *TapiLine
    )
{
    
    LOCK_STATE      LockState;
    ULONG           i;

    *TapiLine = NULL;

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   RetLine;

        RetLine = LineTable.Table[i];

        if ((RetLine != NULL) &&
            (RetLine->hdLine == hdLine)) {
            *TapiLine = RetLine;
            NdisDprAcquireSpinLock(&RetLine->Lock);
            REF_TAPILINE(RetLine);
            NdisDprReleaseSpinLock(&RetLine->Lock);
            break;
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);

    return (*TapiLine != NULL);
}


BOOLEAN
IsTapiDeviceValid(
    ULONG           ulDeviceID,
    PPX_TAPI_LINE   *TapiLine
    )
{
    LOCK_STATE  LockState;
    ULONG       i;

    *TapiLine = NULL;

    NdisAcquireReadWriteLock(&LineTable.Lock, FALSE, &LockState);

    for (i = 0; i < LineTable.Size; i++) {
        PPX_TAPI_LINE   RetLine;

        RetLine = LineTable.Table[i];

        if ((RetLine != NULL) &&
            (RetLine->ulDeviceID == ulDeviceID)) {
            *TapiLine = RetLine;
            NdisDprAcquireSpinLock(&RetLine->Lock);
            REF_TAPILINE(RetLine);
            NdisDprReleaseSpinLock(&RetLine->Lock);
            break;
        }
    }

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);

    return (*TapiLine != NULL);
}

BOOLEAN
IsVcValid(
    ULONG_PTR   CallId,
    PPX_VC      *pVc
    )
{
    PPX_VC      RetVc = NULL;
    LOCK_STATE  LockState;
    ULONG       i;

    NdisAcquireReadWriteLock(&VcTable.Lock, FALSE, &LockState);


    if (CallId < VcTable.Size) {
        RetVc = VcTable.Table[CallId];
    }

    if (RetVc != NULL) {
        NdisDprAcquireSpinLock(&RetVc->Lock);
        REF_VC(RetVc);
        NdisDprReleaseSpinLock(&RetVc->Lock);
    }

    NdisReleaseReadWriteLock(&VcTable.Lock, &LockState);

    *pVc = RetVc;

    return (RetVc != NULL);
}

VOID
GetVcFromCtx(
    NDIS_HANDLE VcCtx,
    PPX_VC      *pVc
    )
{
    PPX_VC      RetVc = NULL;
    ULONG_PTR   i;
    LOCK_STATE  LockState;

    NdisAcquireReadWriteLock(&VcTable.Lock, FALSE, &LockState);

    i = (ULONG_PTR)(VcCtx);

    if (i < VcTable.Size) {
        RetVc = VcTable.Table[i];
    }

    if (RetVc != NULL) {
        NdisDprAcquireSpinLock(&RetVc->Lock);
        REF_VC(RetVc);
        NdisDprReleaseSpinLock(&RetVc->Lock);
    }

    NdisReleaseReadWriteLock(&VcTable.Lock, &LockState);

    *pVc = RetVc;
}



//
// Function assumes that the TapiLine's spinlock is held!
//
BOOLEAN
IsAddressValid(
    PPX_TAPI_LINE   TapiLine,
    ULONG           AddressId,
    PPX_TAPI_ADDR   *TapiAddr
    )
{
    PPX_TAPI_ADDR   RetAddr = NULL;

    do {

        if (AddressId >= TapiLine->AddrTable.Count) {
            break;
        }

        RetAddr = TapiLine->AddrTable.Table[AddressId];

    } while (FALSE);

    *TapiAddr = RetAddr;

    return (RetAddr != NULL);
}

BOOLEAN
GetLineFromCmLineID(
    PPX_TAPI_PROVIDER   TapiProvider,
    ULONG               CmLineID,
    PPX_TAPI_LINE       *TapiLine
    )
{
    PPX_TAPI_LINE   RetLine;

    NdisAcquireSpinLock(&TapiProvider->Lock);

    RetLine = (PPX_TAPI_LINE)
        TapiProvider->LineList.Flink;

    while ((PVOID)RetLine != (PVOID)&TapiProvider->LineList) {

        if ((RetLine->CmLineID == CmLineID) &&
            (RetLine->DevStatus->ulNumOpens != 0)) {
            break;
        }

        RetLine = (PPX_TAPI_LINE)
            RetLine->Linkage.Flink;
    }
    
    if ((PVOID)RetLine == (PVOID)&TapiProvider->LineList) {
        RetLine = NULL;
    }

    NdisReleaseSpinLock(&TapiProvider->Lock);

    *TapiLine = RetLine;

    return (RetLine != NULL);
}

BOOLEAN
GetAvailLineFromProvider(
    PPX_TAPI_PROVIDER   TapiProvider,
    PPX_TAPI_LINE       *TapiLine,
    PPX_TAPI_ADDR       *TapiAddr
    )
{
    LOCK_STATE      LockState;
    ULONG           i;
    PPX_TAPI_LINE   tl;

    NdisAcquireSpinLock(&TapiProvider->Lock);

    tl = (PPX_TAPI_LINE)TapiProvider->LineList.Flink;

    while ((PVOID)tl != (PVOID)&TapiProvider->LineList) {
        PTAPI_ADDR_TABLE    AddrTable;
        PPX_TAPI_ADDR       ta;

        NdisDprAcquireSpinLock(&tl->Lock);

        if (tl->DevStatus->ulNumOpens != 0) {

            AddrTable = &tl->AddrTable;
            ta = (PPX_TAPI_ADDR)AddrTable->List.Flink;

            //
            // Walk the addresses on this line
            //
            while ((PVOID)ta != (PVOID)&AddrTable->List) {

                //
                // If this address has a callcount that is
                // < then the max num it supports, add another
                // call on this address!
                //
                if (ta->CallCount < ta->Caps->ulMaxNumActiveCalls) {

                    *TapiLine = tl;
                    *TapiAddr = ta;

                    NdisDprReleaseSpinLock(&tl->Lock);

                    NdisReleaseSpinLock(&TapiProvider->Lock);

                    return (TRUE);
                }

                ta = (PPX_TAPI_ADDR)ta->Linkage.Flink;
            }
        }

        NdisDprReleaseSpinLock(&tl->Lock);

        tl = (PPX_TAPI_LINE)tl->Linkage.Flink;
    }

    NdisReleaseSpinLock(&TapiProvider->Lock);

    return (FALSE);
}

//
// Function assumes that the TapiLine's spinlock is held!
//
PPX_TAPI_ADDR
GetAvailAddrFromLine(
    PPX_TAPI_LINE   TapiLine
    )
{
    PPX_TAPI_ADDR       TapiAddr;
    PTAPI_ADDR_TABLE    AddrTable;

    AddrTable = &TapiLine->AddrTable;
    TapiAddr = (PPX_TAPI_ADDR)AddrTable->List.Flink;

    //
    // Walk the addresses on this line
    //
    while ((PVOID)TapiAddr != (PVOID)&AddrTable->List) {

        //
        // If this address has a callcount that is
        // < then the max num it supports, add another
        // call on this address!
        //
        if (TapiAddr->CallCount < 
            TapiAddr->Caps->ulMaxNumActiveCalls) {

            return (TapiAddr);
        }

        TapiAddr = (PPX_TAPI_ADDR)TapiAddr->Linkage.Flink;
    }

    return (NULL);
}

BOOLEAN
InsertLineInTable(
    PPX_TAPI_LINE   TapiLine
    )
{
    ULONG       i;
    ULONG       index;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
       LOCK_STATE  LockState;

    NdisAcquireReadWriteLock(&LineTable.Lock, TRUE, &LockState);

    if (LineTable.Count == LineTable.Size) {
        ULONG           SizeNeeded;
        PUCHAR          AllocatedMemory;
        PPX_TAPI_LINE   *NewTable;

        //
        // Grow the table
        //
        SizeNeeded =
            (LineTable.Size + LineTable.Size/2) * sizeof(PPX_TAPI_LINE);
        PxAllocMem(AllocatedMemory, SizeNeeded, PX_LINETABLE_TAG);

        if (AllocatedMemory == NULL) {
            NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
            return (FALSE);
        }

        RtlZeroMemory(AllocatedMemory,SizeNeeded);

        NewTable = (PPX_TAPI_LINE*)AllocatedMemory;

        RtlMoveMemory((PUCHAR)NewTable,
                      (PUCHAR)LineTable.Table,
                      (sizeof(PPX_TAPI_LINE) * LineTable.Size));

        PxFreeMem(LineTable.Table);

        LineTable.Table = NewTable;
        LineTable.Size += LineTable.Size/2;
    }

    i = LineTable.Size;
    index = LineTable.NextSlot;

    do {

        if (LineTable.Table[index] == NULL) {

            TapiLine->hdLine = index;
            TapiLine->Flags |= PX_LINE_IN_TABLE;
            LineTable.Table[index] = TapiLine;
            LineTable.Count++;
            LineTable.NextSlot =
                (LineTable.NextSlot + 1) % LineTable.Size;

            PXDEBUGP(PXD_TAPI, PXM_TAPI,
                ("Inserting TapiLine %p in LineTable hdCall %d\n", TapiLine, TapiLine->hdLine));
            break;
        }
        index = (index+1) % LineTable.Size;

    } while (--i);

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);

#if DBG
    if (i == 0) {
        PXDEBUGP(PXD_TAPI,PXM_TAPI,
            ("Failed to insert TapiLine %p in LineTable\n", TapiLine));
    }
#endif

    return (i != 0);
}

VOID
RemoveTapiLineFromTable(
    PPX_TAPI_LINE   TapiLine
    )
{
    LOCK_STATE  LockState;

    PXDEBUGP(PXD_TAPI, PXM_TAPI,
        ("Removing TapiLine %p from LineTable hdCall %d\n", TapiLine, TapiLine->hdLine));

    NdisAcquireReadWriteLock(&LineTable.Lock, TRUE, &LockState);

    ASSERT(LineTable.Table[TapiLine->hdLine] == TapiLine);

    LineTable.Table[TapiLine->hdLine] = NULL;

    TapiLine->Flags &= ~PX_LINE_IN_TABLE;

    LineTable.Count--;

    NdisReleaseReadWriteLock(&LineTable.Lock, &LockState);
}

NDIS_STATUS
PxVcCleanup(
    PPX_VC  pVc,
    ULONG   Flags
    )
{
    NDIS_STATUS Status;

    PXDEBUGP(PXD_LOUD, PXM_TAPI, 
             ("PxVcCleanup: Vc %p, State: %x, HandoffState: %x VcFlags: %x, NewFlags: %x\n",
              pVc, pVc->State, pVc->HandoffState, Flags, pVc->Flags, Flags));

    //
    // Terminate Digit Gathering or Monitoring.
    //

    if (pVc->ulMonitorDigitsModes != 0) {
        NdisReleaseSpinLock(&pVc->Lock);
        PxStopDigitReporting(pVc);
        NdisAcquireSpinLock(&pVc->Lock);

        pVc->ulMonitorDigitsModes = 0;        
    } else if (pVc->PendingGatherDigits != NULL) {
        PNDISTAPI_REQUEST pNdisTapiRequest = pVc->PendingGatherDigits;

        pVc->PendingGatherDigits = NULL;
        PxTerminateDigitDetection(pVc, pNdisTapiRequest, LINEGATHERTERM_CANCEL);        
    }

    switch (pVc->State) {
        case PX_VC_IDLE:
            //
            // Already idle do nothing.
            //
            Status = NDIS_STATUS_SUCCESS;
            break;

        case PX_VC_PROCEEDING:
            //
            // We have an outgoing call, when it completes close
            // it down with ndis and complete the drop when
            // in PxClCloseCallComplete.
            // 
            pVc->PrevState = pVc->State;
            pVc->State = PX_VC_DISCONNECTING;

            //
            // Attempt to close the call directly
            // if this fails we will cleanup when
            // the outgoing call completes
            //
            pVc->Flags |= (PX_VC_OUTCALL_ABORTING | 
                           PX_VC_CLEANUP_CM |
                           Flags);

            PxCloseCallWithCm(pVc);

            Status = NDIS_STATUS_PENDING;
            break;

        case PX_VC_OFFERING:
            //
            // We have an incoming call offered to tapi.  Close
            // it down now by calling it's callcomplete handler
            // with a non-success value.
            //
            pVc->Flags |= (Flags | 
                           PX_VC_INCALL_ABORTING);

            pVc->PrevState = pVc->State;

            if (pVc->Flags & PX_VC_CLEANUP_CM) {
                pVc->State= PX_VC_DISCONNECTING;
            } else {
                pVc->State = PX_VC_IDLE;
            }

            if (pVc->Flags & PX_VC_CALLTIMER_STARTED) {
                PxStopIncomingCallTimeout(pVc);
            }


            NdisReleaseSpinLock(&pVc->Lock);

            NdisClIncomingCallComplete(NDIS_STATUS_FAILURE,
                                       pVc->ClVcHandle,
                                       pVc->pCallParameters);

            NdisAcquireSpinLock(&pVc->Lock);

            if (pVc->Flags & PX_VC_CLEANUP_CM) {

                PxCloseCallWithCm(pVc);

            } else {
                SendTapiCallState(pVc,
                                  LINECALLSTATE_DISCONNECTED,
                                  0,
                                  pVc->CallInfo->ulMediaMode);

                //
                // Remove the ref applied in PxClIncomingCall.
                // Don't use the full deref code here as the
                // ref applied when we mapped the vc will
                // keep the vc around.
                //
                pVc->RefCount--;
            }

            Status = NDIS_STATUS_SUCCESS;


            break;

        case PX_VC_DISCONNECTING:
            pVc->Flags |= (Flags);
            Status = NDIS_STATUS_PENDING;
            break;

        case PX_VC_CONNECTED:
            //
            // We have a call that needs to be closed with ndis.
            // This may include dropping the call with a client
            // depending on the handoff state.  Complete the drop
            // irp in PxClCloseCallComplete
            //
            if (!(pVc->Flags & PX_VC_DROP_PENDING)) {

                pVc->PrevState = pVc->State;
                pVc->State = PX_VC_DISCONNECTING;

                pVc->Flags |= (Flags | PX_VC_CLEANUP_CM);

                Status =
                    PxCloseCallWithCl(pVc);

                if (Status != NDIS_STATUS_PENDING) {
                    PxCloseCallWithCm(pVc);
                }
            }

            Status = NDIS_STATUS_PENDING;

            break;

        default:
            PXDEBUGP(PXD_FATAL, PXM_TAPI, 
                     ("PxVcCleanup: Invalid VcState! Vc: %p VcState: %x CallState: %x\n",
                      pVc, pVc->State, pVc->ulCallState ));

            Status = NDIS_STATUS_FAILURE;
            ASSERT(0);
            break;
    }

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\pxtypes.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    pxtypes.h

Abstract:

    Structures for ndproxy.sys

Author:

    Tony Bell    


Revision History:

    Who         When            What
    --------    --------        ----------------------------------------------
    TonyBe      03/04/99        Created

--*/

#ifndef _PXTYPES__H
#define _PXTYPES__H

//
// Generic structs...
//
typedef struct _PxBlockStruc{
    NDIS_EVENT      Event;
    NDIS_STATUS     Status;
} PxBlockStruc, *PPxBlockStruc;

typedef struct _PX_REQUEST{
    NDIS_REQUEST    NdisRequest;
    ULONG           Flags;
#define PX_REQ_ASYNC    0x00000001
    PxBlockStruc    Block;
} PX_REQUEST, *PPX_REQUEST;

//
// Data structures to help run through the many variable length fields
// defined in the NDIS_TAPI_MAKE_CALL structure.
//
typedef struct _PXTAPI_CALL_PARAM_ENTRY {
    ULONG_PTR           SizePointer;
    ULONG_PTR           OffsetPointer;

} PXTAPI_CALL_PARAM_ENTRY, *PPXTAPI_CALL_PARAM_ENTRY;

#define PX_TCP_ENTRY(_SizeName, _OffsetName)                    \
{                                                               \
    FIELD_OFFSET(struct _LINE_CALL_PARAMS, _SizeName),          \
    FIELD_OFFSET(struct _LINE_CALL_PARAMS, _OffsetName)         \
}

//
// Data structures to help run through the many variable length fields
// defined in the LINE_CALL_INFO structure.
//
typedef struct _PXTAPI_CALL_INFO_ENTRY {
    ULONG_PTR           SizePointer;
    ULONG_PTR           OffsetPointer;

} PXTAPI_CALL_INFO_ENTRY, *PPXTAPI_CALL_INFO_ENTRY;

#define PX_TCI_ENTRY(_SizeName, _OffsetName)                    \
{                                                               \
    FIELD_OFFSET(struct _LINE_CALL_INFO, _SizeName),            \
    FIELD_OFFSET(struct _LINE_CALL_INFO, _OffsetName)           \
}

//
//
//
// Start of TAPI stuff
//
//
//
typedef struct  _OID_DISPATCH {
    ULONG       Oid;
    UINT SizeofStruct;
    NDIS_STATUS  (*FuncPtr)();
} OID_DISPATCH;


//
// This table contains all of the tapi addresses on a line.
// One of these is embedded in each tapi_line struct.
//
typedef struct _TAPI_ADDR_TABLE {
    ULONG                   Count;          // # of addresses in table
    ULONG                   Size;           // size of table (# of possible
                                            // addresses)
    LIST_ENTRY              List;
    struct _PX_TAPI_ADDR    **Table;
} TAPI_ADDR_TABLE, *PTAPI_ADDR_TABLE;

//
// This structure contains all of the information that defines
// a tapi line in tapi space.  One of these is created for
// each line that a device exposes.
//
typedef struct _PX_TAPI_LINE {
    LIST_ENTRY              Linkage;
    ULONG                   RefCount;
    struct _PX_TAPI_PROVIDER    *TapiProvider;
    ULONG                   ulDeviceID;     // Id of line in tapi space
                                            // (tapi baseid based)
    ULONG                   Flags;
#define PX_LINE_IN_TABLE    0x00000001

    HTAPI_LINE              htLine;         // tapi's line handle
    ULONG                   hdLine;         // our line handle (index into
                                            // provider's line table)
    ULONG                   CmLineID;       // call managers index (0 based)
    struct _PX_CL_AF        *ClAf;
    struct _PX_CL_SAP       *ClSap;

    PLINE_DEV_CAPS          DevCaps;
    PLINE_DEV_STATUS        DevStatus;
    TAPI_ADDR_TABLE         AddrTable;
    NDIS_SPIN_LOCK          Lock;
}PX_TAPI_LINE, *PPX_TAPI_LINE;

typedef struct _PX_TAPI_ADDR {
    LIST_ENTRY              Linkage;
    ULONG                   RefCount;
    struct _PX_TAPI_LINE    *TapiLine;
    ULONG                   AddrId;         // Id of address, same for both
                                            // tapi and adapter (0 based)
    ULONG                   CallCount;      // # of active calls on list
    PLINE_ADDRESS_CAPS      Caps;
    PLINE_ADDRESS_STATUS    AddrStatus;
}PX_TAPI_ADDR, *PPX_TAPI_ADDR;

typedef struct _TAPI_LINE_TABLE {
    ULONG                   Count;          // # of lines in table
    ULONG                   Size;           // size of table
                                            // (# of possible lines)
    ULONG                   NextSlot;       // next avail index
    struct _PX_TAPI_LINE    **Table;
    NDIS_RW_LOCK            Lock;
} TAPI_LINE_TABLE, *PTAPI_LINE_TABLE;

typedef struct _VC_TABLE {
    ULONG                   Count;          // # of calls in table
    ULONG                   Size;           // size of table (# of possible
                                            // calls)
    ULONG                   NextSlot;       // next avail index
    LIST_ENTRY              List;           // list of calls
    struct _PX_VC           **Table;
    NDIS_RW_LOCK            Lock;
} VC_TABLE, *PVC_TABLE;

typedef struct _PX_TAPI_PROVIDER {
    LIST_ENTRY          Linkage;        // Linkage into tspcb
    PROVIDER_STATUS     Status;         // provider status
    struct _PX_ADAPTER  *Adapter;       // adapter providing for
    struct _PX_CL_AF    *ClAf;          // address family
    LIST_ENTRY          LineList;       // list of lines
    LIST_ENTRY          CreateList;     // list of lines with
                                        // outstanding line creates
    ULONG               NumDevices;     // 
    ULONG_PTR           TempID;
    ULONG               CreateCount;
    ULONG               TapiFlags;
    ULONG               CoTapiVersion;
    BOOLEAN             TapiSupported;
    GUID                Guid;
    CO_ADDRESS_FAMILY   Af;
    NDIS_SPIN_LOCK      Lock;
} PX_TAPI_PROVIDER, *PPX_TAPI_PROVIDER;

typedef struct _TAPI_TSP_CB {
    NDISTAPI_STATUS Status;
    ULONG           htCall;
    LIST_ENTRY      ProviderList;
    ULONG           NdisTapiNumDevices;
    ULONG           ulUniqueId;          // to generate ID for each TAPI request
    ULONG           RefCount;
    NDIS_SPIN_LOCK  Lock;               // SpinLock for this structure
} TAPI_TSP_CB, *PTAPI_TSP_CB;

typedef struct _PROVIDER_EVENT {
    LIST_ENTRY  Linkage;                // List linkage
    NDIS_TAPI_EVENT Event;              // Event structure
}PROVIDER_EVENT, *PPROVIDER_EVENT;

typedef struct _TSP_EVENT_LIST {
    LIST_ENTRY      List;
    ULONG           Count;
    ULONG           MaxCount;
    PIRP            RequestIrp;
    NDIS_SPIN_LOCK  Lock;
} TSP_EVENT_LIST, *PTSP_EVENT_LIST;

typedef struct _PX_DEVICE_EXTENSION {
    UINT            RefCount;
    PDRIVER_OBJECT  pDriverObject;      // passed in DriverEntry
    PDEVICE_OBJECT  pDeviceObject;      // created by IoCreateDevice
    NDIS_HANDLE     PxProtocolHandle;   // Set by NdisRegisterProtocol
    LIST_ENTRY      AdapterList;
    ULONG           RegistryFlags;
    ULONG           ADSLTxRate;
    ULONG           ADSLRxRate;
    NDIS_EVENT      NdisEvent;          // sync registerprotocol/bindadapter handler
    NDIS_SPIN_LOCK  Lock;
} PX_DEVICE_EXTENSION, *PPX_DEVICE_EXTENSION;


//
//  We allocate one PX_ADAPTER structure for each adapter that
//  the Proxy opens. A pointer to this structure is passed to NdisOpenAdapter
//  as the ProtocolBindingContext.
//  The adapter is referenced for:
//      Successful bind
//      Client opening an address family on it
//      Proxy Cl part opening an address family on it
//
typedef struct _PX_ADAPTER {
    LIST_ENTRY              Linkage;
    ULONG                   Sig;
#define PX_ADAPTER_SIG      '  mC'
    PX_ADAPTER_STATE        State;
    ULONG                   RefCount;
    ULONG                   Flags;
#define PX_CMAF_REGISTERING 0x00000001
#define PX_CMAF_REGISTERED  0x00000002

    //
    // Proxy as Client stuff
    //
    NDIS_HANDLE             ClBindingHandle;    // set by NdisOpenAdapter
    LIST_ENTRY              ClAfList;
    LIST_ENTRY              ClAfClosingList;

    //
    // Proxy as Call Manager stuff
    //
    NDIS_HANDLE             CmBindingHandle;    // set by NdisOpenAdapter
    LIST_ENTRY              CmAfList;
    LIST_ENTRY              CmAfClosingList;

    NDIS_HANDLE             UnbindContext;
    NDIS_STATUS             ndisStatus;
    KEVENT                  event;
    GUID                    Guid;
    NDIS_MEDIUM             MediaType;
    NDIS_WAN_MEDIUM_SUBTYPE MediumSubType;
    NDIS_STRING             DeviceName;         // Used to check bound adapters
    ULONG                   MediaNameLength;
    WCHAR                   MediaName[128];
    PxBlockStruc            ClCloseEvent;
    PxBlockStruc            CmCloseEvent;
    PxBlockStruc            OpenEvent;
    PxBlockStruc            BindEvent;
    PxBlockStruc            AfRegisterEvent;
    ULONG                   AfRegisteringCount; // pending calls to NdisCmRegisterAF
    NDIS_SPIN_LOCK          Lock;
} PX_ADAPTER, *PPX_ADAPTER;


//
// The CM_AF is created for each AddressFamily that the
// proxy exposes to the CoNDIS clients
//
typedef struct _PX_CM_AF {
    LIST_ENTRY          Linkage;
    PX_AF_STATE         State;
    ULONG               RefCount;

    NDIS_HANDLE         NdisAfHandle;
    struct _PX_ADAPTER  *Adapter;

    LIST_ENTRY          CmSapList;
    LIST_ENTRY          VcList;

    CO_ADDRESS_FAMILY   Af;

    NDIS_SPIN_LOCK      Lock;
} PX_CM_AF, *PPX_CM_AF;

//
// Function Prototypes for function ptrs
//
typedef
NDIS_STATUS
(*AF_SPECIFIC_GET_NDIS_CALL_PARAMS)(
    IN  struct _PX_VC           *pProxyVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    TapiBuffer,
    OUT PCO_CALL_PARAMETERS     *pNdisCallParameters
    );

typedef
NDIS_STATUS
(*AF_SPECIFIC_GET_TAPI_CALL_PARAMS)(
    IN struct _PX_VC        *pProxyVc,
    IN PCO_CALL_PARAMETERS  pCallParams
    );

typedef
struct _PX_CL_SAP*
(*AF_SPECIFIC_GET_NDIS_SAP)(
    IN  struct _PX_CL_AF        *pClAf,
    IN  struct _PX_TAPI_LINE    *TapiLine
    );

//
// The CL_AF is created for each address family that the
// proxy opens.  There could be multiple address families
// per adapter.
//
typedef struct _PX_CL_AF {
    LIST_ENTRY          Linkage;
    PX_AF_STATE         State;
    ULONG               RefCount;

    NDIS_HANDLE         NdisAfHandle;
    struct _PX_ADAPTER  *Adapter;

    LIST_ENTRY          ClSapList;
    LIST_ENTRY          ClSapClosingList;

    LIST_ENTRY          VcList;
    LIST_ENTRY          VcClosingList;

    PPX_TAPI_PROVIDER   TapiProvider;

    //
    // Moves call params from NDIS to TAPI
    //
    AF_SPECIFIC_GET_NDIS_CALL_PARAMS    AfGetNdisCallParams;
    AF_SPECIFIC_GET_TAPI_CALL_PARAMS    AfGetTapiCallParams;
    AF_SPECIFIC_GET_NDIS_SAP            AfGetNdisSap;
    ULONG                               NdisCallParamSize;

    CO_ADDRESS_FAMILY   Af;
    PxBlockStruc        Block;
    NDIS_SPIN_LOCK      Lock;
} PX_CL_AF, *PPX_CL_AF;

typedef struct _PX_CL_SAP {
    LIST_ENTRY              Linkage;
    PX_SAP_STATE            State;
    ULONG                   Flags;
    ULONG                   RefCount;
    struct _PX_CL_AF        *ClAf;
    struct _PX_TAPI_LINE    *TapiLine;
    ULONG                   MediaModes;
    NDIS_HANDLE             NdisSapHandle;
    PCO_SAP                 CoSap;
} PX_CL_SAP, *PPX_CL_SAP;

typedef struct _PX_CM_SAP {
    LIST_ENTRY          Linkage;
    PX_SAP_STATE        State;
    ULONG               Flags;
    ULONG               RefCount;
    struct _PX_CM_AF   *CmAf;
    NDIS_HANDLE         NdisSapHandle;
    PCO_SAP             CoSap;
} PX_CM_SAP, *PPX_CM_SAP;

typedef struct _PX_VC {
    LIST_ENTRY              Linkage;        // Vc is linked into global table

    PX_VC_STATE             State;          // Vc's state (with call manager)
    PX_VC_STATE             PrevState;      // Vc's previous state
    PX_VC_HANDOFF_STATE     HandoffState;   // Vc's state (with client)
    ULONG                   RefCount;       // Reference Count
    ULONG                   Flags;          //
#define PX_VC_OWNER             0x00000001
#define PX_VC_IN_TABLE          0x00000002
#define PX_VC_CALLTIMER_STARTED 0x00000004
#define PX_VC_CLEANUP_CM        0x00000008
#define PX_VC_DROP_PENDING      0x00000010
#define PX_VC_INCALL_ABORTING   0x00000020
#define PX_VC_INCALL_ABORTED    0x00000040
#define PX_VC_OUTCALL_ABORTING  0x00000080
#define PX_VC_OUTCALL_ABORTED   0x00000100


    ULONG                   CloseFlags;
#define PX_VC_INCOMING_CLOSE    0x00000001
#define PX_VC_TAPI_DROP         0x00000002
#define PX_VC_TAPI_CLOSECALL    0x00000004
#define PX_VC_TAPI_CLOSE        0x00000008
#define PX_VC_UNBIND            0x00000010
#define PX_VC_CLOSE_AF          0x00000020
#define PX_VC_INCALL_TIMEOUT    0x00000040
#define PX_VC_CL_CLOSE_CALL     0x00000080
#define PX_VC_CM_CLOSE_REQ      0x00000100
#define PX_VC_CM_CLOSE_COMP     0x00000200
#define PX_VC_CM_CLOSE_FAIL     0x00000400

    //
    // Proxy as Client stuff
    //
    NDIS_HANDLE             ClVcHandle;     // Vc Handle (as Client)
    struct _PX_CL_SAP       *ClSap;         // Sap (incoming only)
    struct _PX_CL_AF        *ClAf;          // Adress family

    //
    // Proxy as Call Manager stuff
    //
    NDIS_HANDLE             CmVcHandle;     // Vc Handle (as cm)
    struct _PX_CM_SAP       *CmSap;         // Sap
    struct _PX_CM_AF        *CmAf;          // Address family

    struct _PX_ADAPTER      *Adapter;       // Adapter

    //
    // Tapi stuff
    //
    LIST_ENTRY              PendingDropReqs;   // list of pended drop requests
    
    struct _NDISTAPI_REQUEST    *PendingGatherDigits;
    NDIS_TIMER                  DigitTimer;
    ULONG                       ulMonitorDigitsModes;

    struct _PX_TAPI_LINE    *TapiLine;      // associated line
    struct _PX_TAPI_ADDR    *TapiAddr;      // associated address
    HTAPI_CALL              htCall;         // tapi's call handle
    HDRV_CALL               hdCall;         // our call handle (index into
                                            // the global vc table)

    ULONG                   ulCallInfoFieldsChanged;
    ULONG                   ulCallState;
    ULONG                   ulCallStateMode;
    PLINE_CALL_INFO         CallInfo;

    PCO_CALL_PARAMETERS     pCallParameters;

    NDIS_TIMER              InCallTimer;

    PxBlockStruc            Block;
    LIST_ENTRY              ClAfLinkage;
    LIST_ENTRY              CmAfLinkage;
    NDIS_SPIN_LOCK          Lock;               // Spinlock
} PX_VC, *PPX_VC;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\kdext\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdexts.h and stdexts.c.
*
* Copyright (c) 6/9/1995, Microsoft Corporation
*
* 6/9/1995 SanfordS Created
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]\n"
        ,"  help      - Prints short help text on all commands.\n"
         "  help -v   - Prints long help text on all commands.\n"
         "  help cmd  - Prints long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   dso
        ,"dso <struct> [field] [address]\n"
        ,"  - Dumps struct offsets and values, e.g:\n"
         "      dso PX_ADAPTER 806955b0\n"
         "      available structs:\n"
         "      PX_TAPI_LINE\n"
         "      PX_TAPI_ADDR\n"
         "      PX_TAPI_PROVIDER\n"
         "      TAPI_TSP_CB\n"
         "      TAPI_LINE_TABLE\n"
         "      TAPI_ADDR_TABLE\n"
         "      LINE_DEV_CAPS\n"
         "      LINE_ADDRESS_CAPS\n"
         "      LINE_ADDRESS_STATUS\n"
         "      LINE_DEV_STATUS\n"
         "      TSP_EVENT_LIST\n"
         "      VC_TABLE\n"
         "      PX_DEVICE_EXTENSION\n"
         "      PX_ADAPTER\n"
         "      PX_CM_AF\n"
         "      PX_CM_SAP\n"
         "      PX_CL_AF\n"
         "      PX_CL_SAP\n"
         "      PX_VC\n"
        ,""
        ,CUSTOM)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\kdext\dsocode.c ===
/****************************** Module Header ******************************\
* Module Name: dsocode.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file contains the dump structure offset (dso) extension. It is
*  included by $(ALT_PROJECT)\dsotable.c which is generated by structo.exe
*
* History:
* 06/17/96 GerardoB Created
\***************************************************************************/
#include <stdexts.h>

/***************************************************************************\
* dsoTerminateString
*
* This is used to "parse" the command line. It null-terminates a space
*  delimited string, returns its size and a pointer to the begining
*  of next string
*
* 06/17/96 Created Gerardob
\***************************************************************************/
LPSTR dsoTerminateString(LPSTR psz, PDWORD pdwSize)
{
    LPSTR pszWork = psz;

    while (*pszWork != 0) {
        if (*pszWork == ' ') {
            *pszWork++ = 0;
            break;
        }
        pszWork++;
    }

    *pdwSize = (DWORD)(pszWork - psz);
    if (*pszWork != 0) {
        (*pdwSize)--;
    }

    while ((*pszWork != 0) && (*pszWork == ' ')) {
        pszWork++;
    }

    return pszWork;
}
/***************************************************************************\
* dsoGetOffset
*
* If the highest order bit of psot->dwOffset is set, then the value is a
*  relative offset from the previous field; otherwise, it is the
*  actual field offset from the beginnig of the structure
*
* 06/20/96 Created Gerardob
\***************************************************************************/
UINT dsoGetOffset (PSTRUCTUREOFFSETSTABLE psot)
{
    if (!(psot->dwOffset & 0x80000000)) {
        return psot->dwOffset;
    } else {
        return ((psot->dwOffset & ~0x80000000) + dsoGetOffset(psot - 1));
    }
}
/***************************************************************************\
* dsoGetSize
*
* The field size is calculated by substracting its offset from the next
*  field's offset. If the struct has unions, several "fields" might have
*  the same offset, or a given table entry (i.e., a field) might have an
*  offset value greater than the offset value for the next entry (a union
*  of two structures).
*
* 06/26/96 Created Gerardob
\***************************************************************************/
UINT dsoGetSize (PSTRUCTUREOFFSETSTABLE psot, DWORD dwOffset)
{
    DWORD dwNextFieldOffset;

    do {
        psot++;
        dwNextFieldOffset = dsoGetOffset(psot);
    } while (dwNextFieldOffset <= dwOffset);

    return dwNextFieldOffset - dwOffset;
}
/***************************************************************************\
* dsoGetStruct
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTURESTABLE dosGetStruct (LPSTR pszStruct, DWORD dwSize)
{
    PSTRUCTURESTABLE pst = gst;

    /*
     * try an exact match
     */
    while (pst->pszName != NULL) {
        if (!_stricmp(pszStruct, pst->pszName)) {
            return pst;
        }
        pst++;
    }

    /*
     * Partial prefix match
     */
    pst = gst;
    while (pst->pszName != NULL) {
        if (!_strnicmp(pszStruct, pst->pszName, dwSize)) {
            return pst;
        }
        pst++;
    }

    return NULL;

}
/***************************************************************************\
* dsoGetField
*
* 07/03/96 Created Gerardob
\***************************************************************************/
PSTRUCTUREOFFSETSTABLE dosGetField (PSTRUCTUREOFFSETSTABLE psot, LPSTR pszField, DWORD dwSize)
{
    PSTRUCTUREOFFSETSTABLE psotFirst = psot;

    /*
     * try an exact match
     */
    while (psot->pszField != NULL) {
        if (!_stricmp(pszField, psot->pszField)) {
            return psot;
        }
        psot++;
    }

    /*
     * Partial prefix match
     */
    psot = psotFirst;
    while (psot->pszField != NULL) {
        if (!_strnicmp(pszField, psot->pszField, dwSize)) {
            return psot;
        }
        psot++;
    }
    return NULL;

}
/***************************************************************************\
* Idso
*
* !dso StructName [FieldName] [Address]
*
* 06/17/96 Created Gerardob
\***************************************************************************/
BOOL Idso(DWORD opts, LPSTR pszCmdLine)
{
    BOOL fOneField = FALSE;
    DWORD dwOptions;
    DWORD dwValue, dwSize, dwBytesRead, dwOffset, dwOffsetNext, dwFieldsPerRow, dwMoveSize;
    DWORD dwBuffer [20];  /* Make sure it has an even number of elemnts and at least 4*/
    const DWORD *pcdwLimit = dwBuffer + (sizeof(dwBuffer) / sizeof(*dwBuffer));
    DWORD *pdwValue;
    LPSTR pszField, pszAddress;
    PBYTE pBufferOffset;
    PSTRUCTURESTABLE pst;
    PSTRUCTUREOFFSETSTABLE psot;
    PVOID pAddress = NULL;

    if (pszCmdLine == NULL) {
        return FALSE;
    }

    /*
     * NULL terminate first argument and get a pointer to
     *  second one (presumably the field name)
     */
    /*
     * Get the options, if any
     */
    if (*pszCmdLine == '-') {
       dwOptions = GetOpts(&pszCmdLine, NULL);
    }

    /*
     * Find the struct table
     */
    pszField = dsoTerminateString(pszCmdLine, &dwSize);
    pst = dosGetStruct (pszCmdLine, dwSize);
    if (pst == NULL) {
        Print("Structure not found: %s\n", pszCmdLine);
        return TRUE;
    }

    /*
     * Got a table
     */
    psot = pst->psot;

    /*
     * If there is another argument, let's assume a field name follows
     */
    if (*pszField != 0) {
        /*
         * Find the field
         */
        pszAddress = dsoTerminateString(pszField, &dwSize);
        psot = dosGetField (psot, pszField, dwSize);

        /*
         * If it didn't find the field and an address was provided, game over.
         * Otherwise, the second parameter might be the address
         */
        if (psot == NULL) {
            if (*pszAddress != 0) {
                Print("Field not found: %s. Struct: %s\n", pszField, pst->pszName);
                return TRUE;
            } else {
                pszAddress = pszField;
                /*
                 * Reset psot since this argument was not a field
                 */
                psot = pst->psot;
            }
        } else {
            fOneField = TRUE;
        }

        /*
         * Get the pointer to the struct
         */
        if (*pszAddress != 0) {
            pAddress = EvalExp(pszAddress);
            if (pAddress == NULL) {
                /*
                 * EvalExp displayed the error message, so return silently
                 */
                return TRUE;
            }
        }

    } /* if (*pszField != 0) */


    /*
     * If a field name was specified, dump that field only
     * Otherwise, dump the whole table.
     */
    if (fOneField) {
        /*
         * If no address available, just display the field name and offset
         */
        dwOffset = dsoGetOffset(psot);
        Print ("Structure %s - Size: %#lx\n", pst->pszName, pst->dwSize);
        Print("Field: %s - Offset: %#lx\n", psot->pszField, dwOffset);
        if (pAddress == NULL) {
            return TRUE;
        }

        /*
         * Printing field value
         */

        /*123456789 1*/
        Print("Address   Value\n");

        dwBytesRead = 0;
        dwSize = dsoGetSize(psot, dwOffset);
        /*
         * Print 4 DWORDS per row; one row per loop
         */

        do { /* while ((int)dwSize > 0) */

            /*
             * Read values for next row
             */
            if (4 * sizeof(DWORD) >= dwSize) {
                dwMoveSize = dwSize;
            } else {
                dwMoveSize = 4 * sizeof(DWORD);
            }
            moveBlock(dwBuffer, (PBYTE)pAddress + dwOffset + dwBytesRead, dwMoveSize);
            pBufferOffset = (PBYTE)dwBuffer;

            /*
             * Print the address
             */
            Print("%08lx  ", (DWORD)((PBYTE)pAddress + dwOffset + dwBytesRead));
            /*
             * Keep track of bytes read (dwBytesRead) and bytes
             *  remaining to be read (dwSize)
             */
            dwBytesRead += dwMoveSize;
            dwSize -= dwMoveSize;
            /*
             * Print the values, one dword at the time
             */
            while (dwMoveSize >= sizeof(DWORD)) {
                Print("%08lx ", *((DWORD *)pBufferOffset));
                pBufferOffset += sizeof(DWORD);
                dwMoveSize -= sizeof(DWORD);
            }
            /*
             * If less than a DWORD left, zero extend and print a DWORD
             */
            if (dwMoveSize > 0) {
                dwValue = 0;
                memcpy(&dwValue, pBufferOffset, dwMoveSize);
                Print("%0*lx", dwMoveSize * 2, dwValue);
            }
            Print("\n");

        } while ((int)dwSize > 0);

        return TRUE;

    } /* if (fOneField) */


    /*
     * Printing all the fields.
     */
    Print ("Structure %s - Size: %#lx\n", pst->pszName, pst->dwSize);

    dwOffset = 0;
    pBufferOffset = NULL; /* Forces the local buffer to be loaded */
    dwFieldsPerRow = 0;


    /*
     * Loop through all fields in the table. Print one field per loop
     */
    while (psot->pszField != NULL) {
        /*
         * Print two fields per row
         */
        if (dwFieldsPerRow == 2) {
            Print("\n");
            dwFieldsPerRow = 1;
        } else {
            dwFieldsPerRow++;
        }

        /*
         * If no address provided, Print field name(s) and offset(s) only
         */
        if (pAddress == NULL) {
            Print("%03lx  %-34.33s", dsoGetOffset(psot), psot->pszField);
        } else {
            /*
             * Printing offsets and values.
             *
             * Get the size of the value and max it to one DWORD
             */
            dwOffsetNext = dsoGetOffset(psot + 1);
            if (dwOffsetNext > dwOffset) {
                dwSize = dwOffsetNext - dwOffset;
            } else {
                dwSize = dsoGetSize(psot, dwOffset);
            }
            if (dwSize > sizeof(DWORD)) {
                dwSize = sizeof(DWORD);
            }

            /*
             * Get a pointer to the value in the local buffer
             * If the value is not in the buffer, load it
             */
            pdwValue = (PDWORD)(pBufferOffset + dwOffset);
            if ((pdwValue < dwBuffer) || (pdwValue + dwSize > pcdwLimit)) {
                pBufferOffset = (PBYTE)dwBuffer - dwOffset;
                pdwValue = dwBuffer;

                if (sizeof(dwBuffer) >= pst->dwSize - dwOffset) {
                    dwMoveSize = pst->dwSize - dwOffset;
                } else {
                    dwMoveSize = sizeof(dwBuffer);
                }
                moveBlock((PBYTE)dwBuffer, (PBYTE)pAddress + dwOffset, dwMoveSize);

            }

            /*
             * Copy the value and print it
             */
            dwValue = 0; /* in case size < sizeof(DWORD) */
            memcpy(&dwValue, pdwValue, dwSize);
            Print("(%03lx) %08lx %-24.23s", dwOffset, dwValue, psot->pszField);
        } /* if (pAddress == NULL) */


        dwOffset = dwOffsetNext;
        psot++;

    } /* while (psot->pszField != NULL) */

    Print("\n");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\pxutils.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pxutils.c

Abstract:

    Utility routines called by entry point functions. Split out into
    a separate file to keep the "entry point" files clean.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm     02-15-96    Created
    arvindm     04-30-96    Port to NDIS 4.1
    rmachin     11-01-96    ATM - utils adapted for NDIS Proxy
    tonybe      01-23-98    rewrite and cleanup

Notes:

--*/

#include "precomp.h"
#include "atm.h"
#include "stdio.h"

#define MODULE_NUMBER   MODULE_UTIL
#define _FILENUMBER   'LITU'

#define MAX_SDU_SIZE        8192

PXTAPI_CALL_PARAM_ENTRY PxTapiCallParamList[] =
{
    PX_TCP_ENTRY(ulOrigAddressSize, ulOrigAddressOffset),
    PX_TCP_ENTRY(ulDisplayableAddressSize, ulDisplayableAddressOffset),
    PX_TCP_ENTRY(ulCalledPartySize, ulCalledPartyOffset),
    PX_TCP_ENTRY(ulCommentSize, ulCommentOffset),
    PX_TCP_ENTRY(ulUserUserInfoSize, ulUserUserInfoOffset),
    PX_TCP_ENTRY(ulHighLevelCompSize, ulHighLevelCompOffset),
    PX_TCP_ENTRY(ulLowLevelCompSize, ulLowLevelCompOffset),
    PX_TCP_ENTRY(ulDevSpecificSize, ulDevSpecificOffset)
};

#define PX_TCP_NUM_ENTRIES  (sizeof(PxTapiCallParamList) / sizeof(PXTAPI_CALL_PARAM_ENTRY))

PXTAPI_CALL_INFO_ENTRY PxTapiCallInfoList[] =
{
    PX_TCI_ENTRY(ulCallerIDSize, ulCallerIDOffset),
    PX_TCI_ENTRY(ulCallerIDNameSize, ulCallerIDNameOffset),
    PX_TCI_ENTRY(ulCalledIDSize, ulCalledIDOffset),
    PX_TCI_ENTRY(ulCalledIDNameSize, ulCalledIDNameOffset),
    PX_TCI_ENTRY(ulConnectedIDSize, ulConnectedIDOffset),
    PX_TCI_ENTRY(ulConnectedIDNameSize, ulConnectedIDNameOffset),
    PX_TCI_ENTRY(ulRedirectionIDSize, ulRedirectionIDOffset),
    PX_TCI_ENTRY(ulRedirectionIDNameSize, ulRedirectionIDNameOffset),
    PX_TCI_ENTRY(ulRedirectingIDSize, ulRedirectingIDOffset),
    PX_TCI_ENTRY(ulRedirectingIDNameSize, ulRedirectingIDNameOffset),
    PX_TCI_ENTRY(ulAppNameSize, ulAppNameOffset),
    PX_TCI_ENTRY(ulDisplayableAddressSize, ulDisplayableAddressOffset),
    PX_TCI_ENTRY(ulCalledPartySize, ulCalledPartyOffset),
    PX_TCI_ENTRY(ulCommentSize, ulCommentOffset),
    PX_TCI_ENTRY(ulDisplaySize, ulDisplayOffset),
    PX_TCI_ENTRY(ulUserUserInfoSize, ulUserUserInfoOffset),
    PX_TCI_ENTRY(ulHighLevelCompSize, ulHighLevelCompOffset),
    PX_TCI_ENTRY(ulLowLevelCompSize, ulLowLevelCompOffset),
    PX_TCI_ENTRY(ulChargingInfoSize, ulChargingInfoOffset),
    PX_TCI_ENTRY(ulTerminalModesSize, ulTerminalModesOffset),
    PX_TCI_ENTRY(ulDevSpecificSize, ulDevSpecificOffset)
};

#define PX_TCI_NUM_ENTRIES  (sizeof(PxTapiCallInfoList) / sizeof(PXTAPI_CALL_INFO_ENTRY))

BOOLEAN
PxIsAdapterAlreadyBound(
    PNDIS_STRING pDeviceName
    )
/*++

Routine Description:

    Check if we have already bound to a device (adapter).

Arguments:

    pDeviceName     - Points to device name to be checked.

Return Value:

    TRUE iff we already have an Adapter structure representing
    this device.

--*/
{
    PPX_ADAPTER     pAdapter;
    BOOLEAN         bFound = FALSE;
    PLIST_ENTRY     Entry;

    NdisAcquireSpinLock(&(DeviceExtension->Lock));

    Entry = DeviceExtension->AdapterList.Flink;

    pAdapter = CONTAINING_RECORD(Entry,
                                 PX_ADAPTER,
                                 Linkage);

    while ((PVOID)pAdapter != (PVOID)&DeviceExtension->AdapterList) {

        if ((pDeviceName->Length == pAdapter->DeviceName.Length) &&
            (NdisEqualMemory(pDeviceName->Buffer,
                             pAdapter->DeviceName.Buffer,
                             pDeviceName->Length) == (ULONG)1)) {
            bFound = TRUE;
            break;
        }

        Entry = pAdapter->Linkage.Flink;

        pAdapter = CONTAINING_RECORD(Entry,
                                     PX_ADAPTER,
                                     Linkage);
    }

    NdisReleaseSpinLock(&(DeviceExtension->Lock));

    return (bFound);
}

PPX_ADAPTER
PxAllocateAdapter(
    ULONG ulAdditionalLength
    )
/*++

Routine Description:
    Allocate a new Adapter structure, assign an adapter number to it, and
    chain it to the Global list of adapters. We maintain this list in
    ascending order by AdapterNo, which makes it easy to figure out the
    lowest unused AdapterNo.

Arguments:
    None

Return Value:
    Pointer to allocated adapter structure, if successful. NULL otherwise.

--*/
{
    PPX_ADAPTER     pNewAdapter;
    ULONG           SizeNeeded;

    SizeNeeded = sizeof(PX_ADAPTER) + ulAdditionalLength;

    PxAllocMem(pNewAdapter,
               SizeNeeded,
               PX_ADAPTER_TAG);

    if(pNewAdapter == (PPX_ADAPTER)NULL){
        return NULL;
    }

    NdisZeroMemory(pNewAdapter, SizeNeeded);

    //
    // Initialize the new adapter structure
    //
    pNewAdapter->State = PX_ADAPTER_OPENING;
    pNewAdapter->Sig = PX_ADAPTER_SIG;

    NdisAllocateSpinLock(&pNewAdapter->Lock);

    InitializeListHead(&pNewAdapter->CmAfList);
    InitializeListHead(&pNewAdapter->CmAfClosingList);
    InitializeListHead(&pNewAdapter->ClAfList);
    InitializeListHead(&pNewAdapter->ClAfClosingList);

    NdisAcquireSpinLock(&DeviceExtension->Lock);

    InsertTailList(&DeviceExtension->AdapterList, &pNewAdapter->Linkage);

    NdisReleaseSpinLock(&DeviceExtension->Lock);

    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("PxAllocAdapter: new adapter %p\n", pNewAdapter));

    return (pNewAdapter);
}

VOID
PxFreeAdapter(
    PPX_ADAPTER pAdapter
    )
/*++

Routine Description:
    Remove an adapter structure from the global list of adapters and free
    its memory.

Arguments:
    pAdapter    - pointer to Adapter to be released

Return Value:
    None

--*/
{
    PPX_ADAPTER *ppNextAdapter;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("PxFreeAdapter: pAdapter 0x%x\n", pAdapter));

    ASSERT(pAdapter->State == PX_ADAPTER_CLOSING);
    ASSERT(IsListEmpty(&pAdapter->CmAfList));
    ASSERT(IsListEmpty(&pAdapter->CmAfClosingList));
    ASSERT(IsListEmpty(&pAdapter->ClAfList));
    ASSERT(IsListEmpty(&pAdapter->ClAfClosingList));

    pAdapter->State = PX_ADAPTER_CLOSED;

    NdisAcquireSpinLock(&(DeviceExtension->Lock));

    RemoveEntryList(&pAdapter->Linkage);

    NdisReleaseSpinLock(&(DeviceExtension->Lock));

    NdisFreeSpinLock(&(pAdapter->Lock));

    PxFreeMem(pAdapter);
}

PPX_CM_AF
PxAllocateCmAf(
    IN  PCO_ADDRESS_FAMILY  pFamily
    )
{
    UINT        SizeNeeded;
    PPX_CM_AF   pCmAf;

    SizeNeeded = sizeof(PX_CM_AF);

    PxAllocMem(pCmAf, SizeNeeded, PX_CMAF_TAG);

    if(pCmAf == (PPX_CM_AF)NULL) {
        return NULL;
    }

    NdisZeroMemory((PUCHAR)pCmAf, SizeNeeded);

    NdisAllocateSpinLock(&(pCmAf->Lock));

    NdisMoveMemory(&pCmAf->Af, pFamily, sizeof(CO_ADDRESS_FAMILY));

    InitializeListHead(&pCmAf->CmSapList);
    InitializeListHead(&pCmAf->VcList);

    pCmAf->RefCount = 1;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("PxAllocCmAf: new af %p\n", pCmAf));

    return (pCmAf);
}

VOID
PxFreeCmAf(
    PPX_CM_AF    pCmAf
    )
{

    ASSERT(pCmAf->Linkage.Flink == pCmAf->Linkage.Blink);
    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("PxFreeCmAf: CmAf %p\n", pCmAf));
    NdisFreeSpinLock(&pCmAf->Lock);
    PxFreeMem(pCmAf);
}

PPX_CL_AF
PxAllocateClAf(
    IN  PCO_ADDRESS_FAMILY  pFamily,
    IN  PPX_ADAPTER         pAdapter
    )
/*++

Routine Description:
    Allocate a new AF block structure and queue it off the global list.

Arguments:
    None

Return Value:
    Pointer to allocated AF block structure, if successful. NULL otherwise.

--*/
{
    PPX_CL_AF   pClAf;

    PxAllocMem(pClAf, sizeof(PX_CL_AF), PX_CLAF_TAG);

    if(pClAf == (PPX_CL_AF)NULL) {
        return NULL;
    }

    NdisZeroMemory((PUCHAR)pClAf, sizeof(PX_CL_AF));

    PxInitBlockStruc(&pClAf->Block);

    NdisAllocateSpinLock(&(pClAf->Lock));

    NdisMoveMemory(&pClAf->Af, pFamily, sizeof(CO_ADDRESS_FAMILY));

    InitializeListHead(&pClAf->ClSapList);
    InitializeListHead(&pClAf->ClSapClosingList);
    InitializeListHead(&pClAf->VcList);
    InitializeListHead(&pClAf->VcClosingList);

    //
    // Specify any AF-specific functions
    //
    switch(pFamily->AddressFamily) {
        case CO_ADDRESS_FAMILY_Q2931:
            pClAf->AfGetNdisCallParams = PxAfXyzTranslateTapiCallParams;
            pClAf->AfGetTapiCallParams = PxAfXyzTranslateNdisCallParams;
            pClAf->AfGetNdisSap = PxAfXyzTranslateTapiSap;
            break;

        case CO_ADDRESS_FAMILY_TAPI_PROXY:
            pClAf->AfGetNdisCallParams = PxAfTapiTranslateTapiCallParams;
            pClAf->AfGetTapiCallParams = PxAfTapiTranslateNdisCallParams;
            pClAf->AfGetNdisSap = PxAfTapiTranslateTapiSap;
            break;

#if 0
        case CO_ADDRESS_FAMILY_L2TP:
        case CO_ADDRESS_FAMILY_IRDA:
            pClAf->AfGetNdisCallParams = GenericGetNdisCallParams;
            pClAf->AfGetTapiCallParams = GenericGetTapiCallParams;
            pClAf->AfGetNdisSap = GenericTranslateTapiSap;
            break;
#endif

        default:
            pClAf->AfGetNdisCallParams = PxAfXyzTranslateTapiCallParams;
            pClAf->AfGetTapiCallParams = PxAfXyzTranslateNdisCallParams;
            pClAf->AfGetNdisSap = PxAfXyzTranslateTapiSap;
            break;

    }

    pClAf->State = PX_AF_OPENING;
    pClAf->RefCount = 1;
    pClAf->Adapter = pAdapter;

    PXDEBUGP(PXD_INFO, PXM_UTILS, ("PxAllocateClAf: exit. new ClAf %p\n", pClAf));

    return (pClAf);
}


VOID
PxFreeClAf(
    PPX_CL_AF   pClAf
    )
/*++

Routine Description:
    Remove an AF block structure from the global list  and free
    its memory.

Arguments:
    pAdapter    - pointer to AF block to be released

Return Value:
    None

--*/
{
    PXDEBUGP(PXD_INFO, PXM_UTILS, ("PxFreeClAf: ClAf %p\n", pClAf));

    NdisFreeSpinLock(&(pClAf->Lock));

    PxFreeMem(pClAf);
}


PPX_CM_SAP
PxAllocateCmSap(
    PCO_SAP Sap
    )
{
    PPX_CM_SAP  pCmSap;
    ULONG       SizeNeeded;

    PXDEBUGP(PXD_INFO, PXM_UTILS, ("PxAllocateCmSap: Sap %p\n", Sap));

    SizeNeeded = sizeof(PX_CM_SAP) + sizeof(CO_SAP) +
        Sap->SapLength + sizeof(PVOID);

    PxAllocMem((PUCHAR)pCmSap, SizeNeeded, PX_CMSAP_TAG);

    if (pCmSap == NULL) {
        PXDEBUGP(PXD_WARNING, PXM_UTILS,
            ("PxAllocateCmSap: Allocation failed Size %d\n", SizeNeeded));
        return (NULL);
    }

    NdisZeroMemory(pCmSap, SizeNeeded);

    InterlockedExchange((PLONG)&pCmSap->State, PX_SAP_OPENED);

    pCmSap->CoSap = (PCO_SAP)
        ((PUCHAR)pCmSap + sizeof(PX_CM_SAP) + sizeof(PVOID));

    (ULONG_PTR)pCmSap->CoSap &= ~((ULONG_PTR)sizeof(PVOID) - 1);

    NdisMoveMemory(pCmSap->CoSap, Sap, sizeof(CO_SAP) - 1 + Sap->SapLength);

    return (pCmSap);
}

VOID
PxFreeCmSap(
    PPX_CM_SAP  pCmSap
    )
{
    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("PxFreeCmSap: CmSap %p\n", pCmSap));

    pCmSap->CoSap = NULL;

    PxFreeMem(pCmSap);
}

VOID
PxFreeClSap(
    PPX_CL_SAP  pClSap
    )
{

    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("PxFreeClSap: ClSap %p\n", pClSap));

    pClSap->CoSap = NULL;

    PxFreeMem(pClSap);
}

PPX_VC
PxAllocateVc(
    IN PPX_CL_AF    pClAf
    )
{
    PPX_VC  pVc;

    pVc =
        ExAllocateFromNPagedLookasideList(&VcLookaside);

    if (pVc == NULL) {
        return (NULL);
    }

    NdisZeroMemory(pVc, sizeof(PX_VC));

    NdisAllocateSpinLock(&pVc->Lock);

    NdisInitializeTimer(&pVc->InCallTimer,
                        PxIncomingCallTimeout,
                       (PVOID)pVc);

    PxInitBlockStruc(&pVc->Block);

    pVc->State = PX_VC_IDLE;

    InitializeListHead(&pVc->PendingDropReqs);

    //
    // This ref is removed when all vc activity 
    // between the proxy and the client is finished.  
    // For an outgoing call this is after the proxy
    // calls NdisClDeleteVc.  For an incoming call
    // this is after the call manager has called
    // PxClDeleteVc.
    //
    pVc->RefCount = 1;
    pVc->ClAf = pClAf;
    pVc->Adapter = pClAf->Adapter;

    return (pVc);
}

VOID
PxFreeVc(
    PPX_VC  pVc
    )
{
    PPX_TAPI_ADDR   TapiAddr;
    PPX_TAPI_LINE   TapiLine;

    if (pVc->CallInfo != NULL) {
        PxFreeMem(pVc->CallInfo);
        pVc->CallInfo = NULL;
    }

    if (pVc->pCallParameters != NULL) {
        PxFreeMem(pVc->pCallParameters);
        pVc->pCallParameters = NULL;
    }
    TapiAddr = pVc->TapiAddr;
    pVc->TapiAddr = NULL;

    TapiLine = pVc->TapiLine;
    pVc->TapiLine = NULL;

    if (TapiAddr != NULL) {
        InterlockedDecrement((PLONG)&TapiAddr->CallCount);
    }

    if (TapiLine != NULL) {
        InterlockedDecrement((PLONG)&TapiLine->DevStatus->ulNumActiveCalls);
    }

    NdisFreeSpinLock(&pVc->Lock);

    ExFreeToNPagedLookasideList(&VcLookaside, pVc);
}

#if 0
NDIS_STATUS
GenericGetNdisCallParams(
    IN  PPX_VC                  pProxyVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    TapiBuffer,
    OUT PCO_CALL_PARAMETERS *   pOutNdisCallParams
    )
/*++

Routine Description:

Copies everything we can from TAPI CallParams buffer for a generic WAN_CO call to a WAN_CO
call params buffer.


Arguments:
TapiBuffer  -- the TAPI call params buffer
pOutNdisCallParams  -- pointer to the NDIS call params buffer pointer

Return Value:

None

--*/
{

    PCO_CALL_PARAMETERS     pNdisCallParams;
    PCO_CALL_MANAGER_PARAMETERS pCallMgrParams;
    PCO_MEDIA_PARAMETERS    pMediaParams;
    PWAN_CO_CALLMGR_PARAMETERS   pWanCallMgrParams;
    PCO_MEDIA_PARAMETERS    pMediaParameters;
    LINE_CALL_PARAMS*           pTapiCallParams = (LINE_CALL_PARAMS*)&TapiBuffer->LineCallParams;
    ULONG               ulRequestSize;
    UNICODE_STRING      DialAddress;
    NDIS_STATUS         Status;
    LPCWSTR             lpcwszTemp;
    ULONG               i;

    PXDEBUGP(PXD_INFO, PXM_UTILS, ("GenericGetNdisCallParams: enter\n"));

//
// Set up CallParameters structure.
//
    ulRequestSize = sizeof(CO_CALL_PARAMETERS) +
                    sizeof(CO_CALL_MANAGER_PARAMETERS) +
                    sizeof(WAN_CO_CALLMGR_PARAMETERS) +
                    sizeof(CO_MEDIA_PARAMETERS);

    do
    {
        PxAllocMem(pNdisCallParams, ulRequestSize, PX_COCALLPARAMS_TAG);

        if (pNdisCallParams == (PCO_CALL_PARAMETERS)NULL)
        {
            PXDEBUGP(PXD_WARNING, PXM_UTILS, ("GenericGetNdisCallParams: alloc (%d) failed\n", ulRequestSize));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(pNdisCallParams, ulRequestSize);

        pCallMgrParams = (PCO_CALL_MANAGER_PARAMETERS)((PUCHAR)pNdisCallParams + sizeof(CO_CALL_PARAMETERS));
        pMediaParams = (PCO_MEDIA_PARAMETERS)((PUCHAR)pCallMgrParams +
                                              sizeof(CO_CALL_MANAGER_PARAMETERS) +
                                              sizeof(WAN_CO_CALLMGR_PARAMETERS));

        pNdisCallParams->CallMgrParameters = pCallMgrParams;
        pNdisCallParams->MediaParameters = pMediaParams;

        pCallMgrParams->CallMgrSpecific.ParamType = WAN_CO_CALLMGR_SPECIFIC;
        pCallMgrParams->CallMgrSpecific.Length = sizeof(WAN_CO_CALLMGR_PARAMETERS);

        pWanCallMgrParams = (PWAN_CO_CALLMGR_PARAMETERS)(pCallMgrParams->CallMgrSpecific.Parameters);
        pWanCallMgrParams->BearerType = pTapiCallParams->ulBearerMode;
        pWanCallMgrParams->MediaMode = pTapiCallParams->ulMediaMode;

        pWanCallMgrParams->MinRate = pTapiCallParams->ulMinRate;
        pWanCallMgrParams->MaxRate = pTapiCallParams->ulMaxRate;

        //
        // If there's a called address (should be), stick it in the
        // WAN call params
        //
        PxAssert (0 != TapiBuffer->ulDestAddressSize);
        lpcwszTemp = (LPWSTR) ((UCHAR *)TapiBuffer + TapiBuffer->ulDestAddressOffset);
        pWanCallMgrParams->CalledAddr.AddressLength = TapiBuffer->ulDestAddressSize;

        //
        // Move the address from the tapi buffer to the ndis buffer and
        // change from wchar to uchar.
        //
        for (i = 0;
            i < pWanCallMgrParams->CalledAddr.AddressLength;
            i++)
        {
            pWanCallMgrParams->CalledAddr.Address[i] = (UCHAR)lpcwszTemp[i];
        }

        pWanCallMgrParams->CalledAddr.Address[i] = '\0';
        pWanCallMgrParams->CalledAddr.Address[i+1] ='\0';
        pWanCallMgrParams->CalledAddr.Address[i+2] ='\0';

        PXDEBUGP(PXD_INFO, PXM_UTILS, ("CalledAddr %s\n", pWanCallMgrParams->CalledAddr.Address));

        //
        // If there's an originating address, stick it in the
        // WAN call params
        //
        if (0 != pTapiCallParams->ulOrigAddressSize)
        {     // Address of call originator
            ULONG   i;

            NdisMoveMemory(pWanCallMgrParams->OriginatingAddr.Address,
                           ((UCHAR *)pTapiCallParams + pTapiCallParams->ulOrigAddressOffset),
                           pTapiCallParams->ulOrigAddressSize);

            i = pWanCallMgrParams->OriginatingAddr.AddressLength =
                pTapiCallParams->ulOrigAddressSize;

            pWanCallMgrParams->OriginatingAddr.Address[i] = '\0';
            pWanCallMgrParams->OriginatingAddr.Address[i+1] ='\0';
            pWanCallMgrParams->OriginatingAddr.Address[i+2] ='\0';

            PXDEBUGP(PXD_INFO, PXM_UTILS, ("OriginatingAddr %s\n", pWanCallMgrParams->OriginatingAddr.Address));

        }

        if (0 != pTapiCallParams->ulLowLevelCompSize)
        {
            NdisMoveMemory ((UCHAR *)&pWanCallMgrParams->LowerLayerComp,
                            &pTapiCallParams->ulLowLevelCompOffset,
                            MIN (sizeof (WAN_LLI_COMP), pTapiCallParams->ulLowLevelCompSize));
        }

        if (0 != pTapiCallParams->ulHighLevelCompSize)
        {
            NdisMoveMemory ((UCHAR *)&pWanCallMgrParams->HigherLayerComp,
                            &pTapiCallParams->ulHighLevelCompOffset,
                            MIN (sizeof (WAN_HLI_COMP), pTapiCallParams->ulHighLevelCompSize));
        }

        if (0 != pTapiCallParams->ulDevSpecificSize)
        {
            pWanCallMgrParams->DevSpecificLength = pTapiCallParams->ulDevSpecificSize;
            NdisMoveMemory ((UCHAR *)&pWanCallMgrParams->DevSpecificData[0],
                            &pTapiCallParams->ulDevSpecificOffset,
                            pTapiCallParams->ulDevSpecificSize);
        }

        //
        // Set up the flowspec.
        // TBS: Start with a default flowspec that matches the service requirements for
        // specified mediamode. Then refine it.
        //
        if (!TapiBuffer->bUseDefaultLineCallParams)
        {
            PXDEBUGP(PXD_LOUD, PXM_UTILS, ("GenericGetNdisCallParams: moving TAPI call params\n"));

            //
            // These fields are in the FLOWSPEC sub-structure
            //
            pCallMgrParams->Transmit.TokenRate = pTapiCallParams->ulMaxRate;
            pCallMgrParams->Receive.TokenRate = pTapiCallParams->ulMaxRate;
            pCallMgrParams->Transmit.TokenBucketSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
            pCallMgrParams->Receive.TokenBucketSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
            pCallMgrParams->Transmit.MaxSduSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
            pCallMgrParams->Receive.MaxSduSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
            pCallMgrParams->Transmit.PeakBandwidth = pTapiCallParams->ulMaxRate;
            pCallMgrParams->Receive.PeakBandwidth = pTapiCallParams->ulMaxRate;

            if ((pTapiCallParams->ulBearerMode == LINEBEARERMODE_VOICE)  ||
                (pTapiCallParams->ulBearerMode == LINEBEARERMODE_SPEECH)  ||
                (pTapiCallParams->ulBearerMode == LINEBEARERMODE_ALTSPEECHDATA)  ||
                (pTapiCallParams->ulBearerMode == LINEBEARERMODE_MULTIUSE))
            {
                pCallMgrParams->Receive.ServiceType = SERVICETYPE_BESTEFFORT;
                pCallMgrParams->Transmit.ServiceType = SERVICETYPE_BESTEFFORT;
            }

            //
            // TBS: Should MediaMode determine AAL?
            //
        }

        Status = NDIS_STATUS_SUCCESS;
    }while (FALSE);

    *pOutNdisCallParams = pNdisCallParams;
    PXDEBUGP(PXD_INFO, PXM_UTILS, ("GenericGetNdisCallParams: exit: NdisCallParams = x%x\n", pNdisCallParams));

    return (Status);
}

NDIS_STATUS
GenericGetTapiCallParams(
    IN  PPX_VC                  pVc,
    IN  PCO_CALL_PARAMETERS     pCallParams
    )
/*++

Routine Description:

    Copies everything we can from NDIS CallParams buffer for a Q2931 call into TAPI
    call params buffer.


 Arguments:
    pCallParams         -- the NDIS call params buffer
    pVc                 -- pointer to a TAPI call

Return Value:

    None

--*/
{

    PCO_CALL_MANAGER_PARAMETERS pCallMgrParams;
    PWAN_CO_CALLMGR_PARAMETERS pWanCallMgrParams;
    LINE_CALL_INFO  *CallInfo;
    INT             VarDataUsed = 0;
    NDIS_STATUS     Status;
    PPX_TAPI_PROVIDER   TapiProvider;
    PPX_TAPI_LINE       TapiLine;
    PPX_TAPI_ADDR       TapiAddr;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("GenericGetTapiCallParams: enter. Call %x\n", pVc));

    pVc->pCallParameters =
        PxCopyCallParameters(pCallParams);

    if (pVc->pCallParameters == NULL) {

        PXDEBUGP(PXD_WARNING, PXM_CL,
            ("GenericGetTapiCallParams: failed to allocate memory for callparams\n"));

        return (NDIS_STATUS_RESOURCES);
    }

    Status = AllocateTapiCallInfo(pVc, NULL);
    if (Status != NDIS_STATUS_SUCCESS) {
        return (Status);
    }

    pCallMgrParams = (PCO_CALL_MANAGER_PARAMETERS)
                     ((PUCHAR)pCallParams +
                      sizeof(CO_CALL_PARAMETERS));
    pWanCallMgrParams = (PWAN_CO_CALLMGR_PARAMETERS)
                        pCallMgrParams->CallMgrSpecific.Parameters;

    TapiProvider = pVc->ClAf->TapiProvider;

    pVc->ulCallInfoFieldsChanged = 0;

    //
    // Need to find a line and an address for this puppy
    //
    if (!GetAvailLineFromProvider(TapiProvider, &TapiLine, &TapiAddr)) {

        return (NDIS_STATUS_RESOURCES);
    }

    pVc->TapiLine = TapiLine;
    pVc->TapiAddr = TapiAddr;
    InterlockedIncrement((PLONG)&TapiAddr->CallCount);
    InterlockedIncrement((PLONG)&TapiLine->DevStatus->ulNumActiveCalls);

    CallInfo = pVc->CallInfo;

    CallInfo->ulLineDeviceID = TapiLine->CmLineID;
    CallInfo->ulAddressID = TapiAddr->AddrId;
    CallInfo->ulOrigin = LINECALLORIGIN_INBOUND;

    //
    // Set up structure size
    //
    CallInfo->ulNeededSize = 
    CallInfo->ulUsedSize = 
        sizeof(LINE_CALL_INFO);// + LINE_CALL_INFO_VAR_DATA_SIZE;

    CallInfo->ulBearerMode =
        (LINEBEARERMODE_VOICE | LINEBEARERMODE_SPEECH |
         LINEBEARERMODE_ALTSPEECHDATA | LINEBEARERMODE_MULTIUSE);

    CallInfo->ulRate = 
        MIN(pCallMgrParams->Receive.PeakBandwidth, pCallMgrParams->Transmit.PeakBandwidth);

    CallInfo->ulRate = CallInfo->ulRate * 8;
    pVc->ulCallInfoFieldsChanged |= LINECALLINFOSTATE_RATE;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, ("GenericGetTapiCallParams: CallInfo->ulRate %x\n", CallInfo->ulRate));

    CallInfo->ulMediaMode = pWanCallMgrParams->MediaMode |
                            LINEMEDIAMODE_DIGITALDATA;

    CallInfo->ulAppSpecific = 0;
    CallInfo->ulCallID = 0;
    CallInfo->ulRelatedCallID = 0;
    CallInfo->ulCallParamFlags = 0;
    CallInfo->ulCallStates = LINECALLSTATE_IDLE |
                             LINECALLSTATE_OFFERING |
                             LINECALLSTATE_BUSY |
                             LINECALLSTATE_CONNECTED |
                             LINECALLSTATE_DISCONNECTED |
                             LINECALLSTATE_SPECIALINFO |
                             LINECALLSTATE_UNKNOWN;


    CallInfo->DialParams.ulDialPause = 0;
    CallInfo->DialParams.ulDialSpeed = 0;
    CallInfo->DialParams.ulDigitDuration = 0;
    CallInfo->DialParams.ulWaitForDialtone = 0;

    CallInfo->ulReason = LINECALLREASON_UNAVAIL;
    CallInfo->ulCompletionID = 0;

    CallInfo->ulCountryCode = 0;
    CallInfo->ulTrunk = (ULONG)-1;

    if (pWanCallMgrParams->OriginatingAddr.AddressLength != 0) {
        if ((VarDataUsed + pWanCallMgrParams->OriginatingAddr.AddressLength)
            <= LINE_CALL_INFO_VAR_DATA_SIZE) {
            CallInfo->ulCallerIDFlags = LINECALLPARTYID_ADDRESS;
            CallInfo->ulCallerIDSize = pWanCallMgrParams->OriginatingAddr.AddressLength;

            //
            // var data comes in the LINE_CALL_INFO_VAR_DATA_SIZE
            // space at the end of this structure.
            //
            CallInfo->ulCallerIDOffset = sizeof (LINE_CALL_INFO);

            NdisMoveMemory ( (USHORT *)(CallInfo)+CallInfo->ulCallerIDOffset,
                             &pWanCallMgrParams->OriginatingAddr.Address,
                             pWanCallMgrParams->OriginatingAddr.AddressLength);

            VarDataUsed +=  pWanCallMgrParams->OriginatingAddr.AddressLength;
            pVc->ulCallInfoFieldsChanged |= LINECALLINFOSTATE_ORIGIN;
        }
    } else {
        CallInfo->ulCallerIDFlags    =    LINECALLPARTYID_UNAVAIL;
        CallInfo->ulCallerIDSize = 0;
        CallInfo->ulCallerIDOffset = 0;
    }
    CallInfo->ulCallerIDNameSize = 0;
    CallInfo->ulCallerIDNameOffset = 0;

    if (pWanCallMgrParams->CalledAddr.AddressLength != 0) {
        if ((VarDataUsed + pWanCallMgrParams->CalledAddr.AddressLength)
            <= sizeof (LINE_CALL_INFO_VAR_DATA_SIZE)) {
            CallInfo->ulCalledIDFlags = LINECALLPARTYID_ADDRESS;
            CallInfo->ulCalledIDSize    =    pWanCallMgrParams->CalledAddr.AddressLength;

            //
            // var data comes in the LINE_CALL_INFO_VAR_DATA_SIZE
            // space at the end of this structure.
            //
            CallInfo->ulCalledIDOffset = sizeof (LINE_CALL_INFO) + VarDataUsed;

            NdisMoveMemory ( (USHORT *)(CallInfo)+CallInfo->ulCalledIDOffset,
                             &pWanCallMgrParams->CalledAddr.Address,
                             pWanCallMgrParams->CalledAddr.AddressLength);

            VarDataUsed +=  pWanCallMgrParams->CalledAddr.AddressLength;
            pVc->ulCallInfoFieldsChanged |= LINECALLINFOSTATE_CALLEDID;
        }
    } else {
        CallInfo->ulCalledIDFlags = LINECALLPARTYID_UNAVAIL;
        CallInfo->ulCalledIDSize = 0;
        CallInfo->ulCalledIDOffset = 0;
    }

    CallInfo->ulCalledIDNameSize = 0;
    CallInfo->ulCalledIDNameOffset = 0;

    CallInfo->ulConnectedIDFlags = LINECALLPARTYID_UNAVAIL;
    CallInfo->ulConnectedIDSize          =          0;
    CallInfo->ulConnectedIDOffset = 0;
    CallInfo->ulConnectedIDNameSize = 0;
    CallInfo->ulConnectedIDNameOffset = 0;

    CallInfo->ulRedirectionIDFlags = LINECALLPARTYID_UNAVAIL;
    CallInfo->ulRedirectionIDSize = 0;
    CallInfo->ulRedirectionIDOffset = 0;
    CallInfo->ulRedirectionIDNameSize    =    0;
    CallInfo->ulRedirectionIDNameOffset = 0;

    CallInfo->ulRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;
    CallInfo->ulRedirectingIDSize = 0;
    CallInfo->ulRedirectingIDOffset = 0;
    CallInfo->ulRedirectingIDNameSize = 0;
    CallInfo->ulRedirectingIDNameOffset = 0;

    CallInfo->ulDisplaySize = 0;
    CallInfo->ulDisplayOffset = 0;

    CallInfo->ulUserUserInfoSize = 0;
    CallInfo->ulUserUserInfoOffset = 0;

    CallInfo->ulHighLevelCompSize = 0;
    CallInfo->ulHighLevelCompOffset = 0;

    CallInfo->ulLowLevelCompSize = 0;
    CallInfo->ulLowLevelCompOffset = 0;

    CallInfo->ulChargingInfoSize = 0;
    CallInfo->ulChargingInfoOffset = 0;

    CallInfo->ulTerminalModesSize = 0;
    CallInfo->ulTerminalModesOffset = 0;

    CallInfo->ulDevSpecificSize = 0;
    CallInfo->ulDevSpecificOffset = 0;

    CallInfo->ulUsedSize += VarDataUsed;
    CallInfo->ulNeededSize = CallInfo->ulUsedSize;
    return (NDIS_STATUS_SUCCESS);
}

PPX_CL_SAP
GenericTranslateTapiSap(
    IN PPX_CL_AF        pClAf,
    IN PPX_TAPI_LINE    TapiLine
    )
{
    PCO_SAP             pCoSap;
    PPX_CL_SAP          pClSap;
    PWAN_CO_SAP         pWanSap;
    ULONG               SapLength;
    ULONG               MediaModes;
    ULONG               SizeNeeded;

    do {

        SapLength = sizeof(CO_SAP) + sizeof(WAN_CO_SAP);

        SizeNeeded = sizeof(PX_CL_SAP) + SapLength + sizeof(PVOID);

        PxAllocMem(pClSap, SizeNeeded, PX_CLSAP_TAG);

        if (pClSap == NULL) {
            return(NULL);
        }

        NdisZeroMemory(pClSap, SizeNeeded);

        pCoSap = (PCO_SAP)
            ((PUCHAR)pClSap + sizeof(PX_CL_SAP) + sizeof(PVOID));

        (ULONG_PTR)pCoSap &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        MediaModes = TapiLine->DevStatus->ulOpenMediaModes;

        pCoSap->SapType = 0;
        pCoSap->SapLength = sizeof(WAN_CO_SAP);

        pWanSap = (PWAN_CO_SAP)&pCoSap->Sap[0];
        pWanSap->BearerCaps = SAP_FIELD_ANY;
        pWanSap->MediaModes  = SAP_FIELD_ANY;
        pWanSap->CalledAddr.AddressLength = 0;
        pWanSap->HigherLayerComp.HighLayerInfoLength = 0;
        pWanSap->LowerLayerComp.InfoTransferCap = SAP_FIELD_ANY;
        pWanSap->LowerLayerComp.InfoTransferMode = SAP_FIELD_ANY;
        pWanSap->LowerLayerComp.InfoTransferSymmetry = SAP_FIELD_ANY;

        pClSap->CoSap = pCoSap;
        InterlockedExchange((PLONG)&pClSap->State, PX_SAP_OPENING);
        pClSap->ClAf = pClAf;
        pClSap->MediaModes = MediaModes;
        TapiLine->ClSap = pClSap;
        pClSap->TapiLine = TapiLine;

    } while (FALSE);

    return (pClSap);
}
#endif

NDIS_STATUS
PxAfXyzTranslateTapiCallParams(
    IN  PPX_VC                  pVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    pTapiParams,
    OUT PCO_CALL_PARAMETERS *   ppNdisCallParams
    )
/*++

Routine Description:

    Translate from TAPI-format to NDIS-format call parameters for an
    outgoing call. We request the Call Manager to do it.

    There is a lot of brute force copying in this routine. The goal is
    to get all parameters into one flat buffer to fit into an NDIS Request.

Arguments:

    pVc                 - the proxy VC to which the MakeCall will be directed
    pTapiParams         - Points to TAPI call parameters
    ppNdisCallParams    - where we return a pointer to NDIS call parameters.

Return Value:

    NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_XXX error otherwise.

--*/
{
    NDIS_STATUS                             Status;
    CO_TAPI_TRANSLATE_TAPI_CALLPARAMS *     pTranslateReq = NULL;
    LINE_CALL_PARAMS *                      pInLineCallParams;
    LINE_CALL_PARAMS *                      pDstLineCallParams;
    PCO_CALL_PARAMETERS                     pNdisCallParams;
    ULONG                                   RetryCount;
    ULONG                                   RequestSize;
    ULONG                                   InputParamSize;
    ULONG                                   DestAddrBytes;
    ULONG                                   i, BytesFilled;
    PUCHAR                                  pBuffer;
    PX_REQUEST                              ProxyRequest;
    PPX_REQUEST                             pProxyRequest = &ProxyRequest;
    PNDIS_REQUEST                           pNdisRequest;

    //
    //  Initialize.
    //
    Status = NDIS_STATUS_SUCCESS;
    pNdisCallParams = NULL;

    *ppNdisCallParams = NULL;
    DestAddrBytes = sizeof(WCHAR)*(pTapiParams->ulDestAddressSize);

    do {
        pInLineCallParams = (LINE_CALL_PARAMS*)&pTapiParams->LineCallParams;

        //
        //  Calculate space needed for the input parameters
        //
        InputParamSize = 
            sizeof(CO_TAPI_TRANSLATE_TAPI_CALLPARAMS) +
            DestAddrBytes + sizeof(LINE_CALL_PARAMS) + 
            sizeof(CO_CALL_PARAMETERS) + 1024 +
            3*sizeof(PVOID);

        //
        //  Add space for all var length fields in LINE_CALL_PARAMS.
        //
        for (i = 0; i < PX_TCP_NUM_ENTRIES; i++) {
            InputParamSize += 
                *(ULONG *)((PUCHAR)pInLineCallParams + PxTapiCallParamList[i].SizePointer);
            InputParamSize += sizeof(PVOID);
        }

        //
        //  We'll try this atmost twice: the second time would be
        //  if the Call Manager wants us to try again with more
        //  buffer space.
        //
        for (RetryCount = 0; RetryCount < 2; RetryCount++) {
            //
            //  Calculate total space required for the NDIS request.
            //
            RequestSize = InputParamSize + pVc->ClAf->NdisCallParamSize;

            //
            //  Allocate it.
            //
            PxAllocMem(pBuffer, RequestSize, PX_TRANSLATE_CALL);

            if (pBuffer == NULL) {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

            //
            //  Lay out and fill up the request.
            //
            pNdisRequest = &pProxyRequest->NdisRequest;

            pNdisRequest->RequestType = NdisRequestQueryInformation;

            pNdisRequest->DATA.QUERY_INFORMATION.Oid =
                OID_CO_TAPI_TRANSLATE_TAPI_CALLPARAMS;

            pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                pBuffer;

            pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                RequestSize;

            //
            //  InformationBuffer points to this:
            //
            pTranslateReq = (CO_TAPI_TRANSLATE_TAPI_CALLPARAMS *)pBuffer;

            pTranslateReq->ulLineID = ulLineID;
            pTranslateReq->ulAddressID = ulAddressID;
            pTranslateReq->ulFlags = CO_TAPI_FLAG_OUTGOING_CALL;

            pBuffer = 
                (UCHAR*)((ULONG_PTR)(pTranslateReq + 1) + sizeof(PVOID));
            (ULONG_PTR)pBuffer &= ~((ULONG_PTR)sizeof(PVOID) - 1);

            pTranslateReq->DestAddress.Offset =
                ((ULONG_PTR)pBuffer - 
                         (ULONG_PTR)&pTranslateReq->DestAddress);
            
            //
            //  Fill in the Destination Address.
            //
            pTranslateReq->DestAddress.MaximumLength = // same as Length below
                pTranslateReq->DestAddress.Length = (USHORT)DestAddrBytes;
            NdisMoveMemory(pBuffer,
                           (PUCHAR)((ULONG_PTR)pTapiParams + pTapiParams->ulDestAddressOffset),
                           DestAddrBytes);
            pBuffer += (DestAddrBytes + sizeof(PVOID));
            (ULONG_PTR)pBuffer &= ~((ULONG_PTR)sizeof(PVOID) - 1);

            pTranslateReq->LineCallParams.Offset =
                    (USHORT)((ULONG_PTR)pBuffer - (ULONG_PTR)&pTranslateReq->LineCallParams);

            pDstLineCallParams = (LINE_CALL_PARAMS *)pBuffer;

            //
            //  Copy in input parameters.
            //
            BytesFilled = PxCopyLineCallParams(pInLineCallParams,
                                               pDstLineCallParams);

            pDstLineCallParams->ulAddressMode = LINEADDRESSMODE_ADDRESSID;
            pDstLineCallParams->ulAddressID = ulAddressID;

            pTranslateReq->LineCallParams.MaximumLength = // same as Length below
            pTranslateReq->LineCallParams.Length = (USHORT)BytesFilled;

            pBuffer += (BytesFilled + sizeof(PVOID));
            (ULONG_PTR)pBuffer &= ~((ULONG_PTR)sizeof(PVOID) - 1);

            //
            //  Assign space for NDIS Call Parameters == remaining space.
            //
            pTranslateReq->NdisCallParams.MaximumLength = // same as Length below
            pTranslateReq->NdisCallParams.Length =
                (USHORT)(RequestSize - BytesFilled);

            pTranslateReq->NdisCallParams.Offset =
                (USHORT)((ULONG_PTR)pBuffer - (ULONG_PTR)&pTranslateReq->NdisCallParams);

            pNdisCallParams = (CO_CALL_PARAMETERS *)pBuffer;

            //
            //  Do the request.
            //
            PxInitBlockStruc(&pProxyRequest->Block);

            Status = NdisCoRequest(pVc->Adapter->ClBindingHandle,
                                   pVc->ClAf->NdisAfHandle,
                                   pVc->ClVcHandle,
                                   NULL,            // PartyHandle
                                   pNdisRequest);

            //
            //  Wait for it to complete if it pends.
            //
            if (Status == NDIS_STATUS_PENDING) {
                Status = PxBlock(&pProxyRequest->Block);
            }

            //
            //  Did the translation succeed?
            //
            if (Status == NDIS_STATUS_SUCCESS) {
                break;
            }

            //
            //  If the Call Manager needed more buffer, try again.
            //  Remember how much the Call Manager wanted so that we get
            //  smart the next time around.
            //
            if ((Status == NDIS_STATUS_INVALID_LENGTH) ||
                (Status == NDIS_STATUS_BUFFER_TOO_SHORT)) {
                //
                //  Should happen only if the supplied space for NDIS Call parameters
                //  is not sufficient. And we expect the CM to return the length
                //  it expects in "pTranslateReq->NdisCallParams.MaximumLength".
                //

                //
                //  Remember this new length for future translates.
                //
                pVc->ClAf->NdisCallParamSize =
                    pTranslateReq->NdisCallParams.Length;

                PxFreeMem(pTranslateReq);

                pTranslateReq = NULL;

            } else {
                //
                //  Major problem (e.g. the AF is closing).
                //
                break;
            }
        }

        //
        //  Check if translation was successful.
        //
        if (Status != NDIS_STATUS_SUCCESS) {
            break;
        }

        //
        //  Copy the NDIS Call Parameters into a separate block.
        //
        PxAssert(pNdisCallParams != NULL);

        *ppNdisCallParams = 
            PxCopyCallParameters(pNdisCallParams);

        if (*ppNdisCallParams == NULL) {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

    }
    while (FALSE);

    if (pTranslateReq != NULL) {
        PxFreeMem(pTranslateReq);
    }

    return (Status);
}

NDIS_STATUS
PxAfXyzTranslateNdisCallParams(
    IN  PPX_VC                  pVc,
    IN  PCO_CALL_PARAMETERS     pNdisCallParams
    )
/*++

Routine Description:

    Translate from NDIS-format to TAPI-format call parameters for an
    incoming call. We request the Call Manager to do it.

Arguments:

    pVc                 - the proxy VC on which the incoming call arrived.
    pNdisCallParams     - points to NDIS call parameters for the call

Return Value:

    NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_XXX error otherwise.

--*/
{
    ULONG                                   NdisParamLength;
    ULONG                                   RetryCount;
    ULONG                                   RequestSize;
    PUCHAR                                  pBuffer;
    ULONG                                   CallMgrParamsLength = 0;
    ULONG                                   MediaParamsLength = 0;
    NDIS_STATUS                             Status;
    PNDIS_REQUEST                           pNdisRequest;
    PPX_TAPI_PROVIDER                       TapiProvider;
    PPX_TAPI_LINE                           TapiLine;
    PPX_TAPI_ADDR                           TapiAddr;
    LINE_CALL_INFO *                        pLineCallInfo;
    PCO_CALL_PARAMETERS                     pReqNdisCallParams;
    CO_TAPI_TRANSLATE_NDIS_CALLPARAMS *     pTranslateReq = NULL;
    PX_REQUEST                              ProxyRequest;
    PPX_REQUEST                             pProxyRequest = &ProxyRequest;

    //
    //  Initialize.
    //
    TapiProvider = pVc->ClAf->TapiProvider;
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        pVc->pCallParameters =
            PxCopyCallParameters(pNdisCallParams);

        if (pVc->pCallParameters == NULL) {

            PXDEBUGP(PXD_WARNING, PXM_CL,
                ("PxAfXyzTranslateNdisCallParams: failed to allocate memory for callparams\n"));

            Status = NDIS_STATUS_RESOURCES;

            break;
        }

        //
        //  Calculate total length needed for NDIS parameters.
        //
        NdisParamLength = sizeof(CO_CALL_PARAMETERS);
        if (pNdisCallParams->CallMgrParameters) {
            CallMgrParamsLength = (sizeof(CO_CALL_MANAGER_PARAMETERS) +
                                ROUND_UP(pNdisCallParams->CallMgrParameters->CallMgrSpecific.Length));
            NdisParamLength += CallMgrParamsLength;
        }
            
        if (pNdisCallParams->MediaParameters) {
            MediaParamsLength = (sizeof(CO_MEDIA_PARAMETERS) +
                                ROUND_UP(pNdisCallParams->MediaParameters->MediaSpecific.Length));
            NdisParamLength += MediaParamsLength;
        }

        //
        //  Calculate total space needed for the input parameters
        //
        RequestSize =
            sizeof(CO_TAPI_TRANSLATE_NDIS_CALLPARAMS) + NdisParamLength +
            sizeof(LINE_CALL_INFO) + LINE_CALL_INFO_VAR_DATA_SIZE;

        //
        //  We'll try this atmost twice: the second time would be
        //  if the Call Manager wants us to try again with more
        //  buffer space.
        //
        for (RetryCount = 0; RetryCount < 2; RetryCount++) {

            //
            //  Allocate it.
            //
            PxAllocMem(pBuffer, RequestSize, PX_TRANSLATE_CALL);

            if (pBuffer == NULL) {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

            //
            //  Lay out and fill up the request.
            //
            pNdisRequest = &pProxyRequest->NdisRequest;

            pNdisRequest->RequestType = NdisRequestQueryInformation;
            pNdisRequest->DATA.QUERY_INFORMATION.Oid = OID_CO_TAPI_TRANSLATE_NDIS_CALLPARAMS;
            pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
            pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = RequestSize;

            //
            //  InformationBuffer points to this:
            //
            pTranslateReq = (CO_TAPI_TRANSLATE_NDIS_CALLPARAMS *)pBuffer;

            pTranslateReq->ulFlags = CO_TAPI_FLAG_INCOMING_CALL;

            pBuffer += sizeof(CO_TAPI_TRANSLATE_NDIS_CALLPARAMS);
            pTranslateReq->NdisCallParams.Offset =
                                (USHORT)((ULONG_PTR)pBuffer -
                                         (ULONG_PTR)&pTranslateReq->NdisCallParams);
            pTranslateReq->NdisCallParams.MaximumLength =
            pTranslateReq->NdisCallParams.Length = (USHORT)NdisParamLength;
            
            //
            //  Copy in the NDIS call parameters.
            //
            pReqNdisCallParams = (PCO_CALL_PARAMETERS)pBuffer;
            NdisZeroMemory(pReqNdisCallParams, NdisParamLength);

            pReqNdisCallParams->Flags = pNdisCallParams->Flags;

            pBuffer = (PUCHAR)((ULONG_PTR)pReqNdisCallParams + sizeof(CO_CALL_PARAMETERS));

            if (pNdisCallParams->CallMgrParameters) {
                pReqNdisCallParams->CallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)pBuffer;

                NdisMoveMemory(pReqNdisCallParams->CallMgrParameters,
                               pNdisCallParams->CallMgrParameters,
                               sizeof(*pNdisCallParams->CallMgrParameters));

                NdisMoveMemory(&pReqNdisCallParams->CallMgrParameters->CallMgrSpecific.Parameters[0],
                               &pNdisCallParams->CallMgrParameters->CallMgrSpecific.Parameters[0],
                               pNdisCallParams->CallMgrParameters->CallMgrSpecific.Length);

                pBuffer += CallMgrParamsLength;
            }

            if (pNdisCallParams->MediaParameters) {
                pReqNdisCallParams->MediaParameters = (PCO_MEDIA_PARAMETERS)pBuffer;

                NdisMoveMemory(pReqNdisCallParams->MediaParameters,
                               pNdisCallParams->MediaParameters,
                               sizeof(*pNdisCallParams->MediaParameters));

                NdisMoveMemory(&pReqNdisCallParams->MediaParameters->MediaSpecific.Parameters[0],
                               &pNdisCallParams->MediaParameters->MediaSpecific.Parameters[0],
                               pNdisCallParams->MediaParameters->MediaSpecific.Length);
                
                pBuffer += MediaParamsLength;
            }

            //
            //  Space for LINE_CALL_INFO == all that is left.
            //
            pLineCallInfo = (LINE_CALL_INFO *)pBuffer;
            pTranslateReq->LineCallInfo.Offset =
                                (USHORT)((ULONG_PTR)pBuffer -
                                         (ULONG_PTR)&pTranslateReq->LineCallInfo);
            pTranslateReq->LineCallInfo.MaximumLength =
            pTranslateReq->LineCallInfo.Length = (USHORT)(RequestSize -
                                                     pTranslateReq->LineCallInfo.Offset);

            PxInitBlockStruc(&pProxyRequest->Block);

            //
            //  Do the request.
            //
            Status = NdisCoRequest(pVc->Adapter->ClBindingHandle,
                                   pVc->ClAf->NdisAfHandle,
                                   pVc->ClVcHandle,
                                   NULL,            // PartyHandle
                                   pNdisRequest);

            //
            // This call will always return pending (ndis behavior) even
            // though the underlying call manager can never pend it
            // so make pending look like success.
            //
            if (Status == NDIS_STATUS_PENDING) {
                Status = NDIS_STATUS_SUCCESS;
            }

            //
            //  Did the translation succeed?
            //
            if (Status == NDIS_STATUS_SUCCESS) {
                break;
            }

            //
            //  If the Call Manager needed more buffer, try again.
            //
            if ((Status == NDIS_STATUS_INVALID_LENGTH) ||
                (Status == NDIS_STATUS_BUFFER_TOO_SHORT)) {

                //
                //  Should happen only if the supplied space for LINE_CALL_INFO
                //  is not sufficient. Get the desired length.
                //
                RequestSize =
                    pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded;

                PxFreeMem(pTranslateReq);
            }
        }


        if (Status != NDIS_STATUS_SUCCESS) {
            break;
        }

        //
        // Now that we have the Id's that this call came in on...
        // validate and setup tapiline/tapiaddr
        //

        //
        // Validate the lineid and get the line control block
        //
        if (!GetLineFromCmLineID(TapiProvider, 
                                 pLineCallInfo->ulLineDeviceID, 
                                 &TapiLine)) {

            PXDEBUGP (PXD_WARNING, PXM_UTILS, 
                      ("PxAfXyzTranslateNdisCallParams: Invalid LineID %d on Provider %p\n",
                       pLineCallInfo->ulLineDeviceID, TapiProvider));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisAcquireSpinLock(&TapiLine->Lock);

        //
        // Validate the addressid and get the address control block
        //
        if (!IsAddressValid(TapiLine, 
                            pLineCallInfo->ulAddressID, 
                            &TapiAddr)) {

            PXDEBUGP (PXD_WARNING, PXM_UTILS, 
                      ("PxAfXyzTranslateNdisCallParams: Invalid AddrID %d on TapiLine %p\n",
                       pLineCallInfo->ulAddressID, TapiLine));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisReleaseSpinLock(&TapiLine->Lock);

        NdisAcquireSpinLock(&pVc->Lock);

        pVc->TapiAddr = TapiAddr;
        pVc->TapiLine = TapiLine;

        InterlockedIncrement((PLONG)&TapiAddr->CallCount);
        InterlockedIncrement((PLONG)&TapiLine->DevStatus->ulNumActiveCalls);

        //
        //  Allocate CallInfo and copy in the LINE_CALL_INFO structure.
        //
        Status =
            AllocateTapiCallInfo(pVc, pLineCallInfo);

        if (Status != NDIS_STATUS_SUCCESS) {
            NdisReleaseSpinLock(&pVc->Lock);
            break;
        }

        pVc->CallInfo->ulLineDeviceID = TapiLine->CmLineID;
        pVc->CallInfo->ulAddressID = TapiAddr->AddrId;
        pVc->CallInfo->ulBearerMode = pLineCallInfo->ulBearerMode;
        pVc->CallInfo->ulMediaMode = pLineCallInfo->ulMediaMode;
        pVc->CallInfo->ulOrigin = LINECALLORIGIN_INBOUND;

        NdisReleaseSpinLock(&pVc->Lock);
    }
    while (FALSE);

    if (pTranslateReq != NULL) {
        PxFreeMem(pTranslateReq);
    }

    return (Status);
}


PPX_CL_SAP
PxAfXyzTranslateTapiSap(
    IN  PPX_CL_AF       pClAf,
    IN  PPX_TAPI_LINE   TapiLine
    )
/*++

Routine Description:

    Translate a SAP from TAPI-style (media modes) to a CO_SAP structure
    suitable for use with a Non-CO_ADDRESS_FAMILY_TAPI Call Manager.
    We actually request the call manager to do the translation. Theoretically
    the CM could return a list of SAPs for this media modes setting.

    For now, we assume the call manager returns one SAP. If this routine
    completes successfully, it would have set the pCoSap pointer within the
    AF Block to point to an appropriate SAP structure.

    TBD: Support multiple returned SAPs.

Arguments:

Return Value:

    NDIS_STATUS_SUCCESS if successful, else an appopriate NDIS error code.
--*/
{
    ULONG           SapLength;
    ULONG           RequestLength;
    ULONG           RetryCount;
    ULONG           MediaModes;
    ULONG           SizeNeeded;
    PUCHAR          pBuffer;
    PPX_CL_SAP      pClSap = NULL;
    PCO_SAP         pCoSap = NULL;
    NDIS_STATUS     Status;
    PNDIS_REQUEST   pNdisRequest;
    CO_TAPI_TRANSLATE_SAP   *pTranslateSap = NULL;
    PX_REQUEST      ProxyRequest;
    PPX_REQUEST     pProxyRequest = &ProxyRequest;

    //
    //  Initialize.
    //
    Status = NDIS_STATUS_SUCCESS;
    MediaModes = TapiLine->DevStatus->ulOpenMediaModes;

    do {
        //
        //  Compute an initial request length.
        //
        RequestLength =
            sizeof(CO_TAPI_TRANSLATE_SAP) + sizeof(CO_SAP) + 100;

        //
        //  Try this atmost twice. The second time is if the Call manager
        //  asks us to retry with more buffer space.
        //
        for (RetryCount = 0; RetryCount < 2; RetryCount++) {

            //
            //  Allocate it.
            //
            PxAllocMem(pBuffer, RequestLength, PX_TRANSLATE_SAP);

            if (pBuffer == NULL) {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            NdisZeroMemory(pBuffer, RequestLength);

            NdisZeroMemory(pProxyRequest, sizeof(PX_REQUEST));

            //
            //  InformationBuffer points to this:
            //
            pTranslateSap = (CO_TAPI_TRANSLATE_SAP *)pBuffer;

            pTranslateSap->ulLineID = TapiLine->CmLineID;
            pTranslateSap->ulAddressID = CO_TAPI_ADDRESS_ID_UNSPECIFIED;
            pTranslateSap->ulMediaModes = MediaModes;
            pTranslateSap->Reserved = 0;

            pNdisRequest =
                &pProxyRequest->NdisRequest;

            pNdisRequest->RequestType =
                NdisRequestQueryInformation;

            pNdisRequest->DATA.QUERY_INFORMATION.Oid =
                OID_CO_TAPI_TRANSLATE_TAPI_SAP;

            pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer =
                pBuffer;

            pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength =
                RequestLength;

            //
            //  Do the request.
            //
            PxInitBlockStruc(&pProxyRequest->Block);

            Status = NdisCoRequest(pClAf->Adapter->ClBindingHandle,
                                   pClAf->NdisAfHandle,
                                   NULL,
                                   NULL,
                                   pNdisRequest);

            //
            //  Wait for it to complete if it pends.
            //
            if (Status == NDIS_STATUS_PENDING) {
                Status = PxBlock(&pProxyRequest->Block);
            }

            //
            //  Did the translation succeed?
            //
            if (Status == NDIS_STATUS_SUCCESS) {
                break;
            }

            //
            //  If the Call Manager needed more buffer, try again.
            //
            if ((Status == NDIS_STATUS_INVALID_LENGTH) ||
                (Status == NDIS_STATUS_BUFFER_TOO_SHORT)) {
                //
                //  Get the desired length.
                //
                RequestLength =
                    pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded;
                PxFreeMem(pTranslateSap);
            }
        }

        if (Status != NDIS_STATUS_SUCCESS) {
            break;
        }

        //
        //  Got the SAP information successfully. Make a copy and save it
        //  in the AF block.
        //
        PxAssert(pTranslateSap->NumberOfSaps == 1); // TBD: allow more

        SapLength = pTranslateSap->NdisSapParams[0].Length;

        SizeNeeded = sizeof(PX_CL_SAP) + SapLength + sizeof(PVOID);

        PxAllocMem(pClSap, SizeNeeded, PX_CLSAP_TAG);

        if (pClSap == NULL) {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(pClSap, SizeNeeded);

        pCoSap = (PCO_SAP)
            ((PUCHAR)pClSap + sizeof(PX_CL_SAP) + sizeof(PVOID));

        (ULONG_PTR)pCoSap &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        PXDEBUGP(PXD_INFO, PXM_UTILS, ("TranslateXyzSap: New ClSap %p , Copying in from %p\n",
                    pClSap,
                    (PUCHAR)((ULONG_PTR)&pTranslateSap->NdisSapParams[0] +
                              pTranslateSap->NdisSapParams[0].Offset)));

        NdisMoveMemory(pCoSap,
                       (PUCHAR)((ULONG_PTR)&pTranslateSap->NdisSapParams[0] + pTranslateSap->NdisSapParams[0].Offset),
                       SapLength);

        pClSap->CoSap = pCoSap;
        InterlockedExchange((PLONG)&pClSap->State, PX_SAP_OPENING);
        pClSap->ClAf = pClAf;
        pClSap->MediaModes = MediaModes;
        TapiLine->ClSap = pClSap;
        pClSap->TapiLine = TapiLine;

    } while (FALSE);

    if (pTranslateSap != NULL) {
        PxFreeMem(pTranslateSap);
    }

    PXDEBUGP(PXD_INFO, PXM_UTILS, ("TranslateXyzSap: pClAf %p, pCoSap %p, Status %x\n",
                pClAf, pCoSap, Status));

    return (pClSap);
}


NDIS_STATUS
PxAfTapiTranslateTapiCallParams(
    IN  PPX_VC                  pVc,
    IN  ULONG                   ulLineID,
    IN  ULONG                   ulAddressID,
    IN  ULONG                   ulFlags,
    IN  PNDIS_TAPI_MAKE_CALL    pTapiParams,
    OUT PCO_CALL_PARAMETERS *   ppNdisCallParams
    )
/*++

Routine Description:

    Translate from TAPI-format to NDIS-format call parameters for an
    outgoing call. This is for the CO_ADDRESS_FAMILY_TAPI address family,
    so the translation involves encapsulating the TAPI parameters directly
    into an NDIS CO_CALL_PARAMETERS structure.

Arguments:

    pVc                 - the proxy VC to which the MakeCall will be directed
    ulLineID            - Line ID on which the call will be placed
    ulAddressID         - Address ID on which the call will be placed
    ulFlags             - should be CO_TAPI_FLAG_OUTGOING_CALL
    pTapiParams         - Points to TAPI call parameters
    ppNdisCallParams    - where we return a pointer to NDIS call parameters.

Return Value:

    NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_XXX error otherwise.

--*/
{
    INT i;
    NDIS_STATUS Status;
    ULONG HdrSize, MediaSpecificSize, TotalSize;
    ULONG BytesFilled;
    ULONG DestAddrBytes;
    PCO_CALL_PARAMETERS pNdisCallParams;
    PCO_CALL_MANAGER_PARAMETERS pCallMgrParams;
    PCO_MEDIA_PARAMETERS pMediaParams;
    LINE_CALL_PARAMS *pInLineCallParams;
    LINE_CALL_PARAMS *pOutLineCallParams;
    CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED *pCoTapiCallParams;
    UCHAR *pDest;

    //
    //  Initialize.
    //
    Status = NDIS_STATUS_SUCCESS;
    pNdisCallParams = NULL;
    *ppNdisCallParams = NULL;

    pInLineCallParams = (LINE_CALL_PARAMS *)&pTapiParams->LineCallParams;

    DestAddrBytes = sizeof(WCHAR)*(pTapiParams->ulDestAddressSize);

    do
    {
        //
        //  Compute the total space required.
        //  The fixed header first:
        //
        HdrSize = sizeof(CO_CALL_PARAMETERS) +
                  sizeof(CO_MEDIA_PARAMETERS) +
                  sizeof(CO_CALL_MANAGER_PARAMETERS) +
                  2*sizeof(PVOID);
        
        //
        //  Next the structure that will be overlayed on the Media-specific
        //  parameters section.
        //
        MediaSpecificSize = sizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS);

        //
        //  Space for Destination address from NDIS_TAPI_MAKE_CALL:
        //
        MediaSpecificSize += DestAddrBytes;
        MediaSpecificSize += sizeof(PVOID);

        //
        //  Add space for all the LINE_CALL_PARAMS components.
        //
        MediaSpecificSize += sizeof(LINE_CALL_PARAMS);
        MediaSpecificSize += 2*sizeof(PVOID);

        for (i = 0; i < PX_TCP_NUM_ENTRIES; i++) {
            MediaSpecificSize += *(ULONG *)
                ((PUCHAR)pInLineCallParams + PxTapiCallParamList[i].SizePointer);
            MediaSpecificSize += sizeof(PVOID);
        }

        //
        //  Allocate all that we need.
        //
        TotalSize = HdrSize + MediaSpecificSize;
        PxAllocMem(pNdisCallParams, TotalSize, PX_COCALLPARAMS_TAG);

        if (pNdisCallParams == NULL) {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(pNdisCallParams, TotalSize);

        pCallMgrParams = (PCO_CALL_MANAGER_PARAMETERS)
            ((ULONG_PTR)(pNdisCallParams + 1) + sizeof(PVOID));
        (ULONG_PTR)pCallMgrParams &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        pMediaParams = (PCO_MEDIA_PARAMETERS)
            ((ULONG_PTR)(pCallMgrParams + 1) + sizeof(PVOID));
        (ULONG_PTR)pMediaParams &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        //
        //  Lay out the NDIS Call parameters.
        //
        pNdisCallParams->Flags = 0;

        pNdisCallParams->CallMgrParameters = pCallMgrParams;
        pNdisCallParams->MediaParameters = pMediaParams;

        //
        // These fields are in the FLOWSPEC sub-structure
        //

        //
        // Have to convert bits per sec to Bytes per sec
        //
        pCallMgrParams->Transmit.TokenRate =
        pCallMgrParams->Receive.TokenRate =
        pCallMgrParams->Transmit.PeakBandwidth =
        pCallMgrParams->Receive.PeakBandwidth = pInLineCallParams->ulMaxRate/8;

        pCallMgrParams->Transmit.TokenBucketSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
        pCallMgrParams->Receive.TokenBucketSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
        pCallMgrParams->Transmit.MaxSduSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;
        pCallMgrParams->Receive.MaxSduSize = 4096; //UNSPECIFIED_FLOWSPEC_VALUE;

        pMediaParams->Flags = TRANSMIT_VC|RECEIVE_VC;
        pMediaParams->ReceivePriority = 0;
        pMediaParams->ReceiveSizeHint = MAX_SDU_SIZE;   // ToDo Guess!
        pMediaParams->MediaSpecific.ParamType = 0;
        pMediaParams->MediaSpecific.Length = MediaSpecificSize;

        pCoTapiCallParams = (CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED *)
                                &pMediaParams->MediaSpecific.Parameters[0];

        //
        //  Prepare the CO_TAPI Call parameters.
        //
        pCoTapiCallParams->ulLineID = ulLineID;
        pCoTapiCallParams->ulAddressID = ulAddressID;
        pCoTapiCallParams->ulFlags = ulFlags;

        //
        //  Destination Address follows the base CO_AF_TAPI_MAKE_CALL_PARAMETERS
        //  structure.
        //
        pDest = (UCHAR *)
            ((ULONG_PTR)(pCoTapiCallParams + 1) + sizeof(PVOID));
        (ULONG_PTR)pDest &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        pCoTapiCallParams->DestAddress.Length = // Same as MaximumLength below
        pCoTapiCallParams->DestAddress.MaximumLength = (USHORT)DestAddrBytes;
        pCoTapiCallParams->DestAddress.Offset =
                    (ULONG_PTR)pDest - (ULONG_PTR)&pCoTapiCallParams->DestAddress;
        NdisMoveMemory(pDest,
                       (UCHAR*)((ULONG_PTR)pTapiParams + pTapiParams->ulDestAddressOffset),
                       DestAddrBytes);

        pDest = (UCHAR*) 
            ((ULONG_PTR)(pDest + DestAddrBytes) + sizeof(PVOID));
        (ULONG_PTR)pDest &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        //
        //  LINE_CALL_PARAMS next. We'll fill in the lengths at the end.
        //  Remember the start of this structure.
        //
        pOutLineCallParams = (LINE_CALL_PARAMS*)pDest;

        pCoTapiCallParams->LineCallParams.Offset =
            (ULONG_PTR)pDest - (ULONG_PTR)&pCoTapiCallParams->LineCallParams;

        BytesFilled = PxCopyLineCallParams(pInLineCallParams,
                                           pOutLineCallParams);

        pOutLineCallParams->ulAddressMode = LINEADDRESSMODE_ADDRESSID;
        pOutLineCallParams->ulAddressID = ulAddressID;

        pCoTapiCallParams->LineCallParams.Length =  
        pCoTapiCallParams->LineCallParams.MaximumLength = 
            (USHORT)BytesFilled;

        //
        //  Set up the return value.
        //
        *ppNdisCallParams = pNdisCallParams;
        break;
    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS) {
        //
        //  Clean up.
        //
        if (pNdisCallParams != NULL) {
            PxFreeMem(pNdisCallParams);
        }
    }

    PXDEBUGP(PXD_VERY_LOUD, PXM_UTILS, ("AfTapi: Tapi to Ndis: pCallParams: %x, Status %x\n",
                *ppNdisCallParams, Status));

    return (Status);
}

ULONG
PxCopyLineCallParams(
    IN  LINE_CALL_PARAMS *pSrcLineCallParams,
    OUT LINE_CALL_PARAMS *pDstLineCallParams
    )
/*++

Routine Description:

    Utility routine to make a copy of LINE_CALL_PARAMS.

Arguments:

    pSrcLineCallParams  - Points to the copy source
    pDstLineCallParams  - Points to the copy destination. Assumed to
                          have sufficient room.

Return Value:

    Number of bytes we copied in.

--*/
{
    PUCHAR      pDest;
    PUCHAR      pTemp;
    ULONG       BytesFilled = 0;
    INT         i;

    //
    //  First copy the base structure.
    //
    pDest = (PUCHAR)pDstLineCallParams;
    NdisMoveMemory(pDest,
                   pSrcLineCallParams,
                   sizeof(*pDstLineCallParams));

    pTemp = pDest;
    pDest = (PUCHAR)
        ((ULONG_PTR)pDest + sizeof(*pDstLineCallParams) + sizeof(PVOID));
    (ULONG_PTR)pDest &= ~((ULONG_PTR)sizeof(PVOID) - 1);
    
    BytesFilled += (ULONG)((ULONG_PTR)pDest - (ULONG_PTR)pTemp);

    //
    //  Move on to the variable part.
    //

    //
    //  Get all the variable-length parts in.
    //
    for (i = 0; i < PX_TCP_NUM_ENTRIES; i++)
    {
        ULONG       Length;
        ULONG       SrcOffset;

        Length = *(ULONG *)((ULONG_PTR)pSrcLineCallParams +
                            PxTapiCallParamList[i].SizePointer);

        if (Length == 0)
        {
            continue;
        }

        //
        //  Get the source offset.
        //
        SrcOffset = *(ULONG *)((ULONG_PTR)pSrcLineCallParams +
                            PxTapiCallParamList[i].OffsetPointer);

        //
        //  Fill in the destination offset.
        //
        *(ULONG *)((PUCHAR)pDstLineCallParams + PxTapiCallParamList[i].OffsetPointer) =
                (ULONG)((ULONG_PTR)pDest - (ULONG_PTR)pDstLineCallParams);

        //
        //  Copy this thing in.
        //
        NdisMoveMemory(pDest,
                       (PUCHAR)((ULONG_PTR)pSrcLineCallParams + SrcOffset),
                       Length);
        
        pTemp = pDest;

        pDest = (PUCHAR)((ULONG_PTR)pDest + Length + sizeof(PVOID));
        (ULONG_PTR)pDest &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        BytesFilled += (ULONG)((ULONG_PTR)pDest - (ULONG_PTR)pTemp);
    }

    return (BytesFilled);
}

NDIS_STATUS
PxAfTapiTranslateNdisCallParams(
    IN  PPX_VC                  pVc,
    IN  PCO_CALL_PARAMETERS     pNdisCallParams
    )
/*++

Routine Description:

    Translate from NDIS-format to TAPI-format call parameters for an
    incoming call belonging to the CO_ADDRESS_FAMILY_TAPI AF. We expect
    the NDIS call parameters to contain TAPI style parameters, and they
    are copied directly into the DRVCALL structure.

Arguments:

    pVc                 - the proxy VC on which the incoming call arrived.
    pNdisCallParams     - points to NDIS call parameters for the call

Return Value:

    NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_XXX error otherwise.

--*/
{
    NDIS_STATUS                 Status;
    CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED * pCoTapiParams;
    LINE_CALL_INFO UNALIGNED *  pReceivedCallInfo;
    PPX_TAPI_PROVIDER           TapiProvider;
    PPX_TAPI_LINE               TapiLine;
    PPX_TAPI_ADDR               TapiAddr;

    //
    //  Initialize.
    //
    Status = NDIS_STATUS_SUCCESS;
    TapiProvider = pVc->ClAf->TapiProvider;

    do
    {
        pVc->pCallParameters =
            PxCopyCallParameters(pNdisCallParams);

        if (pVc->pCallParameters == NULL) {

            PXDEBUGP(PXD_WARNING, PXM_CL,
                ("PxAfTapiTranslateNdisCallParams: failed to allocate memory for callparams\n"));

            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        //  Some checks here. We might consider removing these and replacing them
        //  with asserts.
        //
        if ((pNdisCallParams == NULL) ||
            (pNdisCallParams->MediaParameters == NULL) ||
            (pNdisCallParams->MediaParameters->MediaSpecific.Length <
                sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)))
        {
            PXDEBUGP(PXD_FATAL, PXM_UTILS, ("AfTapiTranslateNdis: NULL/bad media params in %x\n",
                        pNdisCallParams));
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        pCoTapiParams = (CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED *)
                            &pNdisCallParams->MediaParameters->MediaSpecific.Parameters[0];
        if (pCoTapiParams->LineCallInfo.Length < sizeof(LINE_CALL_INFO))
        {
            PXDEBUGP(PXD_FATAL, PXM_UTILS, ("AfTapiTranslateNdis: bad length (%d) in CoTapiParams %x\n",
                    pCoTapiParams->LineCallInfo.Length,
                    pCoTapiParams));
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        //
        //  Get at the received LINE_CALL_INFO structure.
        //
        pReceivedCallInfo = (LINE_CALL_INFO UNALIGNED *)
                                ((ULONG_PTR)&pCoTapiParams->LineCallInfo +
                                    pCoTapiParams->LineCallInfo.Offset);

        //
        // Now that we have the Id's that this call came in on...
        // validate and setup tapiline/tapiaddr
        //

        //
        // Validate the lineid and get the line control block
        //
        if (!GetLineFromCmLineID(TapiProvider,
                                 pReceivedCallInfo->ulLineDeviceID, 
                                 &TapiLine)) {

            PXDEBUGP (PXD_WARNING, PXM_UTILS, ("PxAfTapiTranslateNdisCallParams: Invalid LineID %d on Provider %p\n",
                pReceivedCallInfo->ulLineDeviceID, TapiProvider));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisAcquireSpinLock(&TapiLine->Lock);

        //
        // Validate the addressid and get the address control block
        //
        if (!IsAddressValid(TapiLine, pReceivedCallInfo->ulAddressID, &TapiAddr)) {

            PXDEBUGP (PXD_WARNING, PXM_UTILS, ("PxAfTapiTranslateNdisCallParams: Invalid AddrID %d on TapiLine %p\n",
                pReceivedCallInfo->ulAddressID, TapiLine));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisReleaseSpinLock(&TapiLine->Lock);

        NdisAcquireSpinLock(&pVc->Lock);

        Status =
            AllocateTapiCallInfo(pVc, pReceivedCallInfo);

        if (Status != NDIS_STATUS_SUCCESS) {
            NdisReleaseSpinLock(&pVc->Lock);
            break;
        }

        pVc->TapiLine = TapiLine;
        pVc->TapiAddr = TapiAddr;
        InterlockedIncrement((PLONG)&TapiAddr->CallCount);
        InterlockedIncrement((PLONG)&TapiLine->DevStatus->ulNumActiveCalls);

        pVc->CallInfo->ulLineDeviceID = TapiLine->CmLineID;
        pVc->CallInfo->ulAddressID = TapiAddr->AddrId;
        //pVc->CallInfo->ulBearerMode = TapiLine->DevCaps->ulBearerModes;
        //pVc->CallInfo->ulMediaMode = TapiLine->DevCaps->ulMediaModes;
        pVc->CallInfo->ulOrigin = LINECALLORIGIN_INBOUND;

        NdisReleaseSpinLock(&pVc->Lock);

        //
        //  Done.
        //
        break;
    }
    while (FALSE);


    PXDEBUGP(PXD_VERY_LOUD, PXM_UTILS, ("AfTapi: Ndis to Tapi: Status %x\n", Status));

    return (Status);
}

PPX_CL_SAP
PxAfTapiTranslateTapiSap(
    IN PPX_CL_AF        pClAf,
    IN PPX_TAPI_LINE    TapiLine
    )
/*++

Routine Description:

    Translate a SAP from TAPI-style (media modes) to a CO_SAP structure
    suitable for use with a CO_ADDRESS_FAMILY_TAPI Call Manager. We actually
    stick the prepared CO_SAP structure's pointer into the AF Block.

Arguments:

Return Value:

    NDIS_STATUS_SUCCESS if successful, else an appopriate NDIS error code.

--*/
{
    PCO_SAP         pCoSap;
    PPX_CL_SAP      pClSap;
    PCO_AF_TAPI_SAP pAfTapiSap;
    ULONG           SapLength;
    ULONG           MediaModes;
    ULONG           SizeNeeded;

    do {
        SapLength = sizeof(CO_SAP) + sizeof(CO_AF_TAPI_SAP);

        SizeNeeded = sizeof(PX_CL_SAP) + sizeof(PVOID) + SapLength;

        PxAllocMem(pClSap, SizeNeeded, PX_CLSAP_TAG);

        if (pClSap == NULL) {
            break;
        }

        NdisZeroMemory(pClSap, SizeNeeded);

        pCoSap = (PCO_SAP)
            ((PUCHAR)pClSap + sizeof(PX_CL_SAP) + sizeof(PVOID));

        (ULONG_PTR)pCoSap &= ~((ULONG_PTR)sizeof(PVOID) - 1);

        MediaModes = TapiLine->DevStatus->ulOpenMediaModes;

        pCoSap->SapType = AF_TAPI_SAP_TYPE;
        pCoSap->SapLength = sizeof(CO_AF_TAPI_SAP);

        pAfTapiSap = (PCO_AF_TAPI_SAP)&pCoSap->Sap[0];
        pAfTapiSap->ulLineID = TapiLine->CmLineID;
        pAfTapiSap->ulAddressID = CO_TAPI_ADDRESS_ID_UNSPECIFIED;
        pAfTapiSap->ulMediaModes = MediaModes;

        pClSap->CoSap = pCoSap;
        InterlockedExchange((PLONG)&pClSap->State, PX_SAP_OPENING);
        pClSap->ClAf = pClAf;
        pClSap->MediaModes = MediaModes;
        TapiLine->ClSap = pClSap;
        pClSap->TapiLine = TapiLine;

    } while (FALSE);

    return (pClSap);
}

VOID
PxAfTapiFreeNdisSap(
    IN PPX_CL_AF    pClAf,
    IN PCO_SAP      pCoSap
    )
{
    //
    // We need to free the sap
    //

}

PCO_CALL_PARAMETERS
PxCopyCallParameters(
    IN  PCO_CALL_PARAMETERS     pCallParameters
    )
{
    ULONG                   Length;
    ULONG                   CallMgrParamsLength = 0;
    ULONG                   MediaParamsLength = 0;
    PCO_CALL_PARAMETERS     pProxyCallParams;
    PUCHAR                  pBuf;

    Length = sizeof(CO_CALL_PARAMETERS);

    if (pCallParameters->CallMgrParameters){
        CallMgrParamsLength = sizeof(CO_CALL_MANAGER_PARAMETERS) +
                              ROUND_UP(pCallParameters->CallMgrParameters->CallMgrSpecific.Length);

        Length += CallMgrParamsLength;
    }

    if (pCallParameters->MediaParameters) {
        MediaParamsLength = sizeof(CO_MEDIA_PARAMETERS) +
                            ROUND_UP(pCallParameters->MediaParameters->MediaSpecific.Length);

        Length += MediaParamsLength;
    }

    PxAllocMem(pProxyCallParams, Length, PX_COCALLPARAMS_TAG);

    if (pProxyCallParams)
    {
        NdisZeroMemory(pProxyCallParams, Length);

        pProxyCallParams->Flags = pCallParameters->Flags;

        pBuf = (PUCHAR)pProxyCallParams + sizeof(CO_CALL_PARAMETERS);

        if (pCallParameters->CallMgrParameters)
        {
            pProxyCallParams->CallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)pBuf;

            NdisMoveMemory(pProxyCallParams->CallMgrParameters,
                           pCallParameters->CallMgrParameters,
                           sizeof(*pCallParameters->CallMgrParameters));

            NdisMoveMemory(&pProxyCallParams->CallMgrParameters->CallMgrSpecific.Parameters[0],
                           &pCallParameters->CallMgrParameters->CallMgrSpecific.Parameters[0],
                           pCallParameters->CallMgrParameters->CallMgrSpecific.Length);

            pBuf += CallMgrParamsLength;
        }

        if (pCallParameters->MediaParameters)
        {
            pProxyCallParams->MediaParameters = (PCO_MEDIA_PARAMETERS)pBuf;

            NdisMoveMemory(pProxyCallParams->MediaParameters,
                           pCallParameters->MediaParameters,
                           sizeof(*pCallParameters->MediaParameters));

            NdisMoveMemory(&pProxyCallParams->MediaParameters->MediaSpecific.Parameters[0],
                           &pCallParameters->MediaParameters->MediaSpecific.Parameters[0],
                           pCallParameters->MediaParameters->MediaSpecific.Length);
        }
    }

    return (pProxyCallParams);
}

ULONG
PxMapNdisStatusToTapiDisconnectMode(
    IN  NDIS_STATUS             NdisStatus,
    IN  BOOLEAN                 bMakeCallStatus
    )
/*++

Routine Description:

   Maps an NDIS Status code passed to MakeCallComplete or IncomingCloseCall
   to its corresponding TAPI LINEDISCONNECTMODE_XXX code.

Arguments:

    NdisStatus          - the NDIS Status to be mapped
    bMakeCallStatus     - TRUE iff MakeCallComplete status. FALSE iff
                          IncomingCloseCall status.

Return Value:

    ULONG - the TAPI Disconnect Mode value.

--*/
{
    ULONG       ulDisconnectMode;

    switch (NdisStatus)
    {
        case NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL:
            ulDisconnectMode = LINEDISCONNECTMODE_NORMAL;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_UNKNOWN:
        case NDIS_STATUS_FAILURE:
            ulDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_REJECT:
        case NDIS_STATUS_NOT_ACCEPTED:
            ulDisconnectMode = LINEDISCONNECTMODE_REJECT;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_PICKUP:
            ulDisconnectMode = LINEDISCONNECTMODE_PICKUP;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_FORWARDED:
            ulDisconnectMode = LINEDISCONNECTMODE_FORWARDED;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_BUSY:
        case NDIS_STATUS_SAP_IN_USE:
            ulDisconnectMode = LINEDISCONNECTMODE_BUSY;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_NOANSWER:
            ulDisconnectMode = LINEDISCONNECTMODE_NOANSWER;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_BADADDRESS:
        case NDIS_STATUS_INVALID_ADDRESS:
            ulDisconnectMode = LINEDISCONNECTMODE_BADADDRESS;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_UNREACHABLE:
        case NDIS_STATUS_NO_ROUTE_TO_DESTINATION:
            ulDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_CONGESTION:
        case NDIS_STATUS_RESOURCES:
            ulDisconnectMode = LINEDISCONNECTMODE_CONGESTION;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_INCOMPATIBLE:
            ulDisconnectMode = LINEDISCONNECTMODE_INCOMPATIBLE;
            break;

        case NDIS_STATUS_TAPI_DISCONNECTMODE_UNAVAIL:
        case NDIS_STATUS_DEST_OUT_OF_ORDER:
            ulDisconnectMode = LINEDISCONNECTMODE_UNAVAIL;
            break;

        case NDIS_STATUS_SUCCESS:
            PxAssert(!bMakeCallStatus);
            ulDisconnectMode = LINEDISCONNECTMODE_NORMAL;
            break;

        default:
            ulDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;
            break;
    }

    return (ulDisconnectMode);
}

NTSTATUS
IntegerToChar (
    IN ULONG Value,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR IntegerChars[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    CHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length, Base;

    Shift = 0;
    Base = 10;

    s = &Result[ 32 ];
    *s = '\0';

    do {
        Digit = Value % Base;
        Value = Value / Base;

        *--s = IntegerChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG)(&Result[ 32 ] - s);

    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = '0';
            Length++;
        }
    }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
    } else {
        RtlMoveMemory( String, s, Length );

        if ((LONG)Length < OutputLength) {
            String[ Length ] = '\0';
        }
        return( STATUS_SUCCESS );
    }
}

NTSTATUS
IntegerToWChar (
    IN  ULONG Value,
    IN  LONG OutputLength,
    OUT PWCHAR String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR IntegerWChars[] = {L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7',
                             L'8', L'9', L'A', L'B', L'C', L'D', L'E', L'F'};
    WCHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length, Base;

    Shift = 0;
    Base = 10;

    s = &Result[ 32 ];
    *s = UNICODE_NULL;

    do {
        Digit = Value % Base;
        Value = Value / Base;

        *--s = IntegerWChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG)(&Result[ 32 ] - s);

    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = L'0';
            Length++;
        }
    }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
    } else {
        RtlMoveMemory( (CHAR *)String, (CHAR *)s, Length * sizeof(WCHAR) );

        if ((LONG)Length < OutputLength) {
            String[ Length ] = UNICODE_NULL;
        }
        return( STATUS_SUCCESS );
    }
}



BOOLEAN
PxAfAndSapFromDevClass(
    PPX_ADAPTER pAdapter,
    LPCWSTR     DevClass,
    PPX_CM_AF   *pCmAf,
    PPX_CM_SAP  *pCmSap
    )
{
    PPX_CM_AF   pAf;
    PPX_CM_SAP  pSap;
    BOOLEAN     SapFound;

    NdisAcquireSpinLock(&pAdapter->Lock);

    pAf = (PPX_CM_AF)pAdapter->CmAfList.Flink;

    *pCmAf = NULL;
    *pCmSap = NULL;
    SapFound = FALSE;

    while ((PVOID)pAf != (PVOID)&pAdapter->CmAfList) {

        NdisAcquireSpinLock(&pAf->Lock);

        pSap = (PPX_CM_SAP)pAf->CmSapList.Flink;

        while ((PVOID)pSap != (PVOID)&pAf->CmSapList) {

            if (_wcsicmp((CONST LPCWSTR)pSap->CoSap->Sap, DevClass) == 0) {
                SapFound = TRUE;
                *pCmAf = pAf;
                *pCmSap = pSap;
                REF_CM_AF(pAf);
                break;
            }

            pSap = (PPX_CM_SAP)pSap->Linkage.Flink;
        }

        NdisReleaseSpinLock(&pAf->Lock);

        if (SapFound) {
            break;
        }

        pAf = (PPX_CM_AF)pAf->Linkage.Flink;
    }

    NdisReleaseSpinLock(&pAdapter->Lock);

    return (SapFound);
}

VOID
GetAllDevClasses(
    PPX_ADAPTER pAdapter,
    LPCWSTR     DevClass,
    PULONG      DevClassSize
    )
{
    PPX_CM_AF   pAf;
    PPX_CM_SAP  pSap;
    ULONG       SizeLeft;
    ULONG       Size = 0;

    NdisAcquireSpinLock(&pAdapter->Lock);

    pAf = (PPX_CM_AF)pAdapter->CmAfList.Flink;

    SizeLeft = *DevClassSize;

    while ((PVOID)pAf != (PVOID)&pAdapter->CmAfList) {

        NdisAcquireSpinLock(&pAf->Lock);

        pSap = (PPX_CM_SAP)pAf->CmSapList.Flink;

        while ((PVOID)pSap != (PVOID)&pAf->CmSapList) {

            if (SizeLeft < pSap->CoSap->SapLength) {
                break;
            }

            NdisMoveMemory((PUCHAR)DevClass, 
                           pSap->CoSap->Sap,
                           pSap->CoSap->SapLength);

            //
            // Add the sizeof of the WCHAR for a WCHAR NULL
            // between each class.
            //
            Size += pSap->CoSap->SapLength + sizeof(WCHAR);
            (PUCHAR)DevClass += Size;
            SizeLeft -= Size;

            pSap = (PPX_CM_SAP)pSap->Linkage.Flink;
        }

        NdisReleaseSpinLock(&pAf->Lock);

        pAf = (PPX_CM_AF)pAf->Linkage.Flink;
    }

    NdisReleaseSpinLock(&pAdapter->Lock);

    *DevClassSize = Size;
}

VOID
PxStartIncomingCallTimeout(
    IN  PPX_VC  pVc
    )
{

    PXDEBUGP(PXD_LOUD, PXM_UTILS, 
             ("PxStartIcomingCallTimeout: VC %p/%x, ClVcH %x, ulCallSt %x, ulCallStMode %x\n",
              pVc, pVc->Flags,pVc->ClVcHandle,pVc->ulCallState,pVc->ulCallStateMode));

    if (!(pVc->Flags & PX_VC_CALLTIMER_STARTED)) {
        //
        // We need to ref the Vc for the timer
        // we are about to start
        //
        REF_VC(pVc);

        pVc->Flags |= PX_VC_CALLTIMER_STARTED;
        NdisSetTimer(&pVc->InCallTimer, 60000);
    }
}

VOID
PxStopIncomingCallTimeout(
    IN  PPX_VC  pVc
    )
{
    BOOLEAN     bCancelled;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, 
             ("PxStopIcomingCallTimeout: VC %p/%x, ClVcH %x, ulCallSt %x, ulCallStMode %x\n",
              pVc, pVc->Flags,pVc->ClVcHandle,pVc->ulCallState,pVc->ulCallStateMode));

    ASSERT(pVc->Flags & PX_VC_CALLTIMER_STARTED);

    NdisCancelTimer(&pVc->InCallTimer, &bCancelled);

    pVc->Flags &= ~PX_VC_CALLTIMER_STARTED;

    if (bCancelled) {
        // We do not need the full deref code because of the ref applied before
        // this routine is called
        pVc->RefCount--;
    }
}


VOID
PxIncomingCallTimeout(
    IN  PVOID   SystemSpecific1,
    IN  PVOID   FunctionContext,
    IN  PVOID   SystemSpecific2,
    IN  PVOID   SystemSpecific3
    )
{
    PPX_VC              pVc;

    pVc = (PPX_VC)FunctionContext;

    NdisAcquireSpinLock(&pVc->Lock);

    PXDEBUGP(PXD_WARNING, PXM_UTILS, 
             ("PxIncomingCallTimeout: VC %p/%x, ClVcH %x, ulCallSt %x, ulCallStMode %x\n",
              pVc, pVc->Flags,pVc->ClVcHandle,pVc->ulCallState,pVc->ulCallStateMode));

    pVc->Flags &= ~PX_VC_CALLTIMER_STARTED;

    pVc->CloseFlags |= PX_VC_INCALL_TIMEOUT;

    PxVcCleanup(pVc, 0);

    DEREF_VC_LOCKED(pVc);
}

//
// Called with the pVc->Lock held
//
VOID
PxCloseCallWithCm(
    PPX_VC      pVc
    )
{
    NDIS_STATUS Status;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, 
             ("PxCloseCallWithCm: Vc %p, State: %x, HandoffState: %x Flags %x\n",
              pVc, pVc->State, pVc->HandoffState, pVc->Flags));

    ASSERT(pVc->State == PX_VC_DISCONNECTING);

    pVc->Flags &= ~PX_VC_CLEANUP_CM;
    pVc->CloseFlags |= PX_VC_CM_CLOSE_REQ;

    NdisReleaseSpinLock(&pVc->Lock);

    Status =
        NdisClCloseCall(pVc->ClVcHandle, NULL, NULL, 0);

    if (Status != NDIS_STATUS_PENDING) {
        PxClCloseCallComplete(Status, 
                              (NDIS_HANDLE)pVc->hdCall, 
                              NULL);
    }

    NdisAcquireSpinLock(&pVc->Lock);
}

//
// Called with the pVc->Lock held
//
NDIS_STATUS
PxCloseCallWithCl(
    PPX_VC      pVc
    )
{
    NDIS_STATUS Status;

    PXDEBUGP(PXD_LOUD, PXM_UTILS, 
             ("PxCloseCallWithCl: Vc %p, State: %x, HandoffState: %x Flags %x\n",
              pVc, pVc->State, pVc->HandoffState, pVc->Flags));

    Status = NDIS_STATUS_PENDING;

    switch (pVc->HandoffState) {
        case PX_VC_HANDOFF_IDLE:
            //
            // We do not have a connection with a client
            // so just return.
            //
            Status = NDIS_STATUS_SUCCESS;
            break;

        case PX_VC_HANDOFF_OFFERING:
        case PX_VC_HANDOFF_DISCONNECTING:
            //
            // We have a connection with a client but it
            // is in a transient state.  Cleanup will
            // occur when the transient condition completes.
            //
            break;

        case PX_VC_HANDOFF_CONNECTED:

            //
            // We have an active connection with a client
            // so we need to tear it's part of the vc down now
            //
            pVc->HandoffState = PX_VC_HANDOFF_DISCONNECTING;

            NdisReleaseSpinLock(&pVc->Lock);

            NdisCmDispatchIncomingCloseCall(NDIS_STATUS_SUCCESS, 
                                            pVc->CmVcHandle, 
                                            NULL, 
                                            0);

            NdisAcquireSpinLock(&pVc->Lock);
            break;
        default:
            break;
    }

    return (Status);
}

#ifdef CODELETEVC_FIXED
//
// Called with pVc->Lock held
//
VOID
DoDerefVcWork(
    PPX_VC  pVc
    )
{
    NDIS_HANDLE ClVcHandle;
    BOOLEAN     VcOwner;

    if (pVc->Flags & PX_VC_IN_TABLE) {

        ClVcHandle = pVc->ClVcHandle;
        pVc->ClVcHandle = NULL;
        VcOwner = (pVc->Flags & PX_VC_OWNER) ? TRUE : FALSE;

        NdisReleaseSpinLock(&pVc->Lock);

        if (VcOwner && ClVcHandle != NULL) {
            NdisCoDeleteVc(ClVcHandle);
        }
        RemoveVcFromTable(pVc);

    } else {
        NdisReleaseSpinLock(&(pVc)->Lock);
    }

    PxFreeVc(pVc);
}
#else
//
// Called with pVc->Lock held
//
VOID
DoDerefVcWork(
    PPX_VC  pVc
    )
{
    NDIS_HANDLE ClVcHandle, CmVcHandle;
    BOOLEAN     VcOwner;

    if (pVc->Flags & PX_VC_IN_TABLE) {

        CmVcHandle = pVc->CmVcHandle;
        pVc->CmVcHandle = NULL;
        ClVcHandle = pVc->ClVcHandle;
        pVc->ClVcHandle = NULL;
        VcOwner = (pVc->Flags & PX_VC_OWNER) ? TRUE : FALSE;

        NdisReleaseSpinLock(&pVc->Lock);

        if (CmVcHandle != NULL) {
            NdisCoDeleteVc(CmVcHandle);
        }
        if (VcOwner && ClVcHandle != NULL) {
            NdisCoDeleteVc(ClVcHandle);
        }
        RemoveVcFromTable(pVc);
    } else {

        NdisReleaseSpinLock(&(pVc)->Lock);
    }

    PxFreeVc(pVc);
}
#endif

//
// Called with pClAf->Lock held
//
VOID
DoDerefClAfWork(
    PPX_CL_AF   pClAf
    )
{
    NDIS_STATUS _s;

    ASSERT(pClAf->State == PX_AF_CLOSING);

    NdisReleaseSpinLock(&pClAf->Lock);

    _s = NdisClCloseAddressFamily(pClAf->NdisAfHandle);

    if (_s != NDIS_STATUS_PENDING) {
        PxClCloseAfComplete(_s, pClAf);
    }
}

//
// Called with pCmAf->lock held
//
VOID
DoDerefCmAfWork(
    PPX_CM_AF   pCmAf
    )
{
    ASSERT(pCmAf->State == PX_AF_CLOSED);

    NdisReleaseSpinLock(&pCmAf->Lock);

    NdisCmCloseAddressFamilyComplete(NDIS_STATUS_SUCCESS, 
                                     pCmAf->NdisAfHandle);

    PxFreeCmAf(pCmAf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\kdext\kdexts.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:


Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <imagehlp.h>
#include <ntdbg.h>
#include <ntsdexts.h>
//#define NOEXTAPI
#include <wdbgexts.h>
#include <ntverp.h>
//#include <stdexts.h>

//
// globals
//
//EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
EXT_API_VERSION        ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
USHORT                 usProcessorArchitecture;
BOOL                   bDebuggingChecked;

PSZ szProcessorArchitecture[] = {
    "Intel",
    "MIPS",
    "Alpha",
    "PPC"
};
#define cArchitecture (sizeof(szProcessorArchitecture) / sizeof(PSZ))

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ULONG offKeProcessorArchitecture;
    ULONG Result;

    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bDebuggingChecked = (SavedMajorVersion == 0x0c);
    usProcessorArchitecture = (USHORT)-1;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\kdext\makefile.inc ===
pxext.c:  pxext.h

precomp.h:  pxext.h

pxext.pph:    pxext.h
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $(C_DEFINES) $** > $@

dsotable.c: pxext.pph pxext.txt dsocode.c
    @echo Creating $@
    structo -i h -p -s pxext.txt -o $@ pxext.pph

clean:
    del dsotable.c pxext.pph
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\pxtapi.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    Pctapi.h

Abstract:

    The module defines the TAPI data for
    the NDIS Proxy. It includes ndistapi.h (which contains data from tapi.h) and adds
	further definitions from tspi.h. We don't include tspi.h directly as it won't work for us.

Author:

	Richard Machin (RMachin)


Revision History:

    Who         When          	What
    --------    --------      	----------------------------------------------
    RMachin     01-13-97       	created (a *lot* of typing saved by Dan Knudson's
								Example Simple Pbx SP)

--*/
#ifndef _PX_TAPI_
#define _PX_TAPI_

#include "ndistapi.h"

//
// LINE stuff from tapi.h
//

#ifndef DECLARE_OPAQUE32
#define DECLARE_OPAQUE32(name)  struct name##__ { int unused; }; \
                typedef const struct name##__ FAR* name
#endif  // DECLARE_OPAQUE32


DECLARE_OPAQUE32(HDRVCALL);
DECLARE_OPAQUE32(HDRVLINE);

typedef HDRVCALL FAR * LPHDRVCALL;
typedef HDRVLINE FAR * LPHDRVLINE;

DECLARE_OPAQUE32(HTAPICALL);
DECLARE_OPAQUE32(HTAPILINE);

typedef HTAPICALL FAR * LPHTAPICALL;
typedef HTAPILINE FAR * LPHTAPILINE;

//
// from TAPI.H
//
#define LINE_REMOVE                25L             // TAPI v2.0

#define ALL_ADDRESS_FEATURES       (LINEADDRFEATURE_FORWARD          | \
                                    LINEADDRFEATURE_MAKECALL         | \
                                    LINEADDRFEATURE_PICKUP           | \
                                    LINEADDRFEATURE_SETMEDIACONTROL  | \
                                    LINEADDRFEATURE_SETTERMINAL      | \
                                    LINEADDRFEATURE_SETUPCONF        | \
                                    LINEADDRFEATURE_UNCOMPLETECALL   | \
                                    LINEADDRFEATURE_UNPARK)
#define ALL_ADDRESS_MODES          (LINEADDRESSMODE_ADDRESSID        | \
                                    LINEADDRESSMODE_DIALABLEADDR)
#define ALL_ADDRESS_STATES         (LINEADDRESSSTATE_OTHER           | \
                                    LINEADDRESSSTATE_DEVSPECIFIC     | \
                                    LINEADDRESSSTATE_INUSEZERO       | \
                                    LINEADDRESSSTATE_INUSEONE        | \
                                    LINEADDRESSSTATE_INUSEMANY       | \
                                    LINEADDRESSSTATE_NUMCALLS        | \
                                    LINEADDRESSSTATE_FORWARD         | \
                                    LINEADDRESSSTATE_TERMINALS       | \
                                    LINEADDRESSSTATE_CAPSCHANGE)
#define ALL_BEARER_MODES           (LINEBEARERMODE_VOICE             | \
                                    LINEBEARERMODE_SPEECH            | \
                                    LINEBEARERMODE_MULTIUSE          | \
                                    LINEBEARERMODE_DATA              | \
                                    LINEBEARERMODE_ALTSPEECHDATA     | \
                                    LINEBEARERMODE_NONCALLSIGNALING  | \
                                    LINEBEARERMODE_PASSTHROUGH)
#define ALL_BUSY_MODES             (LINEBUSYMODE_STATION             | \
                                    LINEBUSYMODE_TRUNK               | \
                                    LINEBUSYMODE_UNKNOWN             | \
                                    LINEBUSYMODE_UNAVAIL)
#define ALL_CALL_FEATURES          (LINECALLFEATURE_ACCEPT           | \
                                    LINECALLFEATURE_ADDTOCONF        | \
                                    LINECALLFEATURE_ANSWER           | \
                                    LINECALLFEATURE_BLINDTRANSFER    | \
                                    LINECALLFEATURE_COMPLETECALL     | \
                                    LINECALLFEATURE_COMPLETETRANSF   | \
                                    LINECALLFEATURE_DIAL             | \
                                    LINECALLFEATURE_DROP             | \
                                    LINECALLFEATURE_GATHERDIGITS     | \
                                    LINECALLFEATURE_GENERATEDIGITS   | \
                                    LINECALLFEATURE_GENERATETONE     | \
                                    LINECALLFEATURE_HOLD             | \
                                    LINECALLFEATURE_MONITORDIGITS    | \
                                    LINECALLFEATURE_MONITORMEDIA     | \
                                    LINECALLFEATURE_MONITORTONES     | \
                                    LINECALLFEATURE_PARK             | \
                                    LINECALLFEATURE_PREPAREADDCONF   | \
                                    LINECALLFEATURE_REDIRECT         | \
                                    LINECALLFEATURE_REMOVEFROMCONF   | \
                                    LINECALLFEATURE_SECURECALL       | \
                                    LINECALLFEATURE_SENDUSERUSER     | \
                                    LINECALLFEATURE_SETCALLPARAMS    | \
                                    LINECALLFEATURE_SETMEDIACONTROL  | \
                                    LINECALLFEATURE_SETTERMINAL      | \
                                    LINECALLFEATURE_SETUPCONF        | \
                                    LINECALLFEATURE_SETUPTRANSFER    | \
                                    LINECALLFEATURE_SWAPHOLD         | \
                                    LINECALLFEATURE_UNHOLD           | \
                                    LINECALLFEATURE_RELEASEUSERUSERINFO)
#define ALL_CALL_INFO_STATES       (LINECALLINFOSTATE_OTHER          | \
                                    LINECALLINFOSTATE_DEVSPECIFIC    | \
                                    LINECALLINFOSTATE_BEARERMODE     | \
                                    LINECALLINFOSTATE_RATE           | \
                                    LINECALLINFOSTATE_MEDIAMODE      | \
                                    LINECALLINFOSTATE_APPSPECIFIC    | \
                                    LINECALLINFOSTATE_CALLID         | \
                                    LINECALLINFOSTATE_RELATEDCALLID  | \
                                    LINECALLINFOSTATE_ORIGIN         | \
                                    LINECALLINFOSTATE_REASON         | \
                                    LINECALLINFOSTATE_COMPLETIONID   | \
                                    LINECALLINFOSTATE_TRUNK          | \
                                    LINECALLINFOSTATE_CALLERID       | \
                                    LINECALLINFOSTATE_CALLEDID       | \
                                    LINECALLINFOSTATE_CONNECTEDID    | \
                                    LINECALLINFOSTATE_REDIRECTIONID  | \
                                    LINECALLINFOSTATE_REDIRECTINGID  | \
                                    LINECALLINFOSTATE_DISPLAY        | \
                                    LINECALLINFOSTATE_USERUSERINFO   | \
                                    LINECALLINFOSTATE_HIGHLEVELCOMP  | \
                                    LINECALLINFOSTATE_LOWLEVELCOMP   | \
                                    LINECALLINFOSTATE_CHARGINGINFO   | \
                                    LINECALLINFOSTATE_TERMINAL       | \
                                    LINECALLINFOSTATE_DIALPARAMS     | \
                                    LINECALLINFOSTATE_MONITORMODES)
                                    //LINECALLINFOSTATE_NUMMONITORS not SP flag
                                    //LINECALLINFOSTATE_NUMOWNERINCR not SP flag
                                    //LINECALLINFOSTATE_NUMOWNERDECR not SP flag
#define ALL_CALL_PARTY_ID_FLAGS    (LINECALLPARTYID_BLOCKED          | \
                                    LINECALLPARTYID_OUTOFAREA        | \
                                    LINECALLPARTYID_NAME             | \
                                    LINECALLPARTYID_ADDRESS          | \
                                    LINECALLPARTYID_PARTIAL          | \
                                    LINECALLPARTYID_UNKNOWN          | \
                                    LINECALLPARTYID_UNAVAIL)
#define ALL_CALL_STATES            (LINECALLSTATE_IDLE               | \
                                    LINECALLSTATE_OFFERING           | \
                                    LINECALLSTATE_ACCEPTED           | \
                                    LINECALLSTATE_DIALTONE           | \
                                    LINECALLSTATE_DIALING            | \
                                    LINECALLSTATE_RINGBACK           | \
                                    LINECALLSTATE_BUSY               | \
                                    LINECALLSTATE_SPECIALINFO        | \
                                    LINECALLSTATE_CONNECTED          | \
                                    LINECALLSTATE_PROCEEDING         | \
                                    LINECALLSTATE_ONHOLD             | \
                                    LINECALLSTATE_CONFERENCED        | \
                                    LINECALLSTATE_ONHOLDPENDCONF     | \
                                    LINECALLSTATE_ONHOLDPENDTRANSFER | \
                                    LINECALLSTATE_DISCONNECTED       | \
                                    LINECALLSTATE_UNKNOWN)
#define ALL_DIAL_TONE_MODES        (LINEDIALTONEMODE_NORMAL          | \
                                    LINEDIALTONEMODE_SPECIAL         | \
                                    LINEDIALTONEMODE_INTERNAL        | \
                                    LINEDIALTONEMODE_EXTERNAL        | \
                                    LINEDIALTONEMODE_UNKNOWN         | \
                                    LINEDIALTONEMODE_UNAVAIL)
#define ALL_DISCONNECT_MODES       (LINEDISCONNECTMODE_NORMAL        | \
                                    LINEDISCONNECTMODE_UNKNOWN       | \
                                    LINEDISCONNECTMODE_REJECT        | \
                                    LINEDISCONNECTMODE_PICKUP        | \
                                    LINEDISCONNECTMODE_FORWARDED     | \
                                    LINEDISCONNECTMODE_BUSY          | \
                                    LINEDISCONNECTMODE_NOANSWER      | \
                                    LINEDISCONNECTMODE_BADADDRESS    | \
                                    LINEDISCONNECTMODE_UNREACHABLE   | \
                                    LINEDISCONNECTMODE_CONGESTION    | \
                                    LINEDISCONNECTMODE_INCOMPATIBLE  | \
                                    LINEDISCONNECTMODE_UNAVAIL       | \
                                    LINEDISCONNECTMODE_NODIALTONE)
#define ALL_MEDIA_MODES            (LINEMEDIAMODE_UNKNOWN            | \
                                    LINEMEDIAMODE_INTERACTIVEVOICE   | \
                                    LINEMEDIAMODE_AUTOMATEDVOICE     | \
                                    LINEMEDIAMODE_DATAMODEM          | \
                                    LINEMEDIAMODE_G3FAX              | \
                                    LINEMEDIAMODE_TDD                | \
                                    LINEMEDIAMODE_G4FAX              | \
                                    LINEMEDIAMODE_DIGITALDATA        | \
                                    LINEMEDIAMODE_TELETEX            | \
                                    LINEMEDIAMODE_VIDEOTEX           | \
                                    LINEMEDIAMODE_TELEX              | \
                                    LINEMEDIAMODE_MIXED              | \
                                    LINEMEDIAMODE_ADSI               | \
                                    LINEMEDIAMODE_VOICEVIEW)
#define ALL_LINE_DEV_CAP_FLAGS     (LINEDEVCAPFLAGS_CROSSADDRCONF    | \
                                    LINEDEVCAPFLAGS_HIGHLEVCOMP      | \
                                    LINEDEVCAPFLAGS_LOWLEVCOMP       | \
                                    LINEDEVCAPFLAGS_MEDIACONTROL     | \
                                    LINEDEVCAPFLAGS_MULTIPLEADDR     | \
                                    LINEDEVCAPFLAGS_CLOSEDROP        | \
                                    LINEDEVCAPFLAGS_DIALBILLING      | \
                                    LINEDEVCAPFLAGS_DIALQUIET        | \
                                    LINEDEVCAPFLAGS_DIALDIALTONE)
#define ALL_LINE_STATES            (LINEDEVSTATE_OTHER               | \
                                    LINEDEVSTATE_RINGING             | \
                                    LINEDEVSTATE_CONNECTED           | \
                                    LINEDEVSTATE_DISCONNECTED        | \
                                    LINEDEVSTATE_MSGWAITON           | \
                                    LINEDEVSTATE_MSGWAITOFF          | \
                                    LINEDEVSTATE_INSERVICE           | \
                                    LINEDEVSTATE_OUTOFSERVICE        | \
                                    LINEDEVSTATE_MAINTENANCE         | \
                                    LINEDEVSTATE_OPEN                | \
                                    LINEDEVSTATE_CLOSE               | \
                                    LINEDEVSTATE_NUMCALLS            | \
                                    LINEDEVSTATE_NUMCOMPLETIONS      | \
                                    LINEDEVSTATE_TERMINALS           | \
                                    LINEDEVSTATE_ROAMMODE            | \
                                    LINEDEVSTATE_BATTERY             | \
                                    LINEDEVSTATE_SIGNAL              | \
                                    LINEDEVSTATE_DEVSPECIFIC         | \
                                    LINEDEVSTATE_REINIT              | \
                                    LINEDEVSTATE_LOCK                | \
                                    LINEDEVSTATE_CAPSCHANGE          | \
                                    LINEDEVSTATE_CONFIGCHANGE        | \
                                    LINEDEVSTATE_TRANSLATECHANGE     | \
                                    LINEDEVSTATE_COMPLCANCEL         | \
                                    LINEDEVSTATE_REMOVED)
#define ALL_LINE_FEATURES          (LINEFEATURE_DEVSPECIFIC          | \
                                    LINEFEATURE_DEVSPECIFICFEAT      | \
                                    LINEFEATURE_FORWARD              | \
                                    LINEFEATURE_MAKECALL             | \
                                    LINEFEATURE_SETMEDIACONTROL      | \
                                    LINEFEATURE_SETTERMINAL)
#define ALL_SPECIAL_INFO           (LINESPECIALINFO_NOCIRCUIT        | \
                                    LINESPECIALINFO_CUSTIRREG        | \
                                    LINESPECIALINFO_REORDER          | \
                                    LINESPECIALINFO_UNKNOWN          | \
                                    LINESPECIALINFO_UNAVAIL)
#define ALL_ADDRESS_CAP_FLAGS      (LINEADDRCAPFLAGS_FWDNUMRINGS     | \
                                    LINEADDRCAPFLAGS_PICKUPGROUPID   | \
                                    LINEADDRCAPFLAGS_SECURE          | \
                                    LINEADDRCAPFLAGS_BLOCKIDDEFAULT  | \
                                    LINEADDRCAPFLAGS_BLOCKIDOVERRIDE | \
                                    LINEADDRCAPFLAGS_DIALED          | \
                                    LINEADDRCAPFLAGS_ORIGOFFHOOK     | \
                                    LINEADDRCAPFLAGS_DESTOFFHOOK     | \
                                    LINEADDRCAPFLAGS_FWDCONSULT      | \
                                    LINEADDRCAPFLAGS_SETUPCONFNULL   | \
                                    LINEADDRCAPFLAGS_AUTORECONNECT   | \
                                    LINEADDRCAPFLAGS_COMPLETIONID    | \
                                    LINEADDRCAPFLAGS_TRANSFERHELD    | \
                                    LINEADDRCAPFLAGS_TRANSFERMAKE    | \
                                    LINEADDRCAPFLAGS_CONFERENCEHELD  | \
                                    LINEADDRCAPFLAGS_CONFERENCEMAKE  | \
                                    LINEADDRCAPFLAGS_PARTIALDIAL     | \
                                    LINEADDRCAPFLAGS_FWDSTATUSVALID  | \
                                    LINEADDRCAPFLAGS_FWDINTEXTADDR   | \
                                    LINEADDRCAPFLAGS_FWDBUSYNAADDR   | \
                                    LINEADDRCAPFLAGS_ACCEPTTOALERT   | \
                                    LINEADDRCAPFLAGS_CONFDROP        | \
                                    LINEADDRCAPFLAGS_PICKUPCALLWAIT)

#endif // _PX_TAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\kdext\precomp.h ===
#ifndef __PRECOMP_H__
#define __PRECOMP_H__

#define NDIS_TAPI_CURRENT_VERSION 0x00030000

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <stdio.h>

#include <ndis.h>
#include <ndistapi.h>
#include <cxport.h>
#include <ip.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <ntddip.h>
#include <ipfilter.h>
#include <tdistat.h>
#include <wanpub.h>

#define FIELDOFFSET(type, field)    ((UINT)&(((type *)0)->field))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\kdext\pxext.h ===
#include <proxy.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\cm.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// cm.c
// RAS L2TP WAN mini-port/call-manager driver
// Call Manager routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"

#include "cm.tmh"

// Debug counts of client oddities that should not be happening.
//
ULONG g_ulUnexpectedInCallCompletes = 0;
ULONG g_ulCallsNotClosable = 0;
ULONG g_ulCompletingVcCorruption = 0;

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
BuildCallParametersShell(
    IN ADAPTERCB* pAdapter,
    IN ULONG ulIpAddress,
    IN ULONG ulBufferLength,
    OUT CHAR* pBuffer,
    OUT CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED** ppTiParams,
    OUT LINE_CALL_INFO** ppTcInfo,
    OUT L2TP_CALL_PARAMETERS** ppLcParams );

VOID
CallSetupComplete(
    IN VCCB* pVc );

TUNNELCB*
CreateTunnelCb(
    IN ADAPTERCB* pAdapter );

VOID
InactiveCallCleanUp(
    IN VCCB* pVc );

VOID
IncomingCallCompletePassive(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs );

VOID
DereferenceAf(
    IN ADAPTERCB* pAdapter );

VOID
DeregisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

VOID
LockIcs(
    IN VCCB* pVc,
    IN BOOLEAN fGrace );

NDIS_STATUS
QueryCmInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded );

VOID
ReferenceAf(
    IN ADAPTERCB* pAdapter );

VOID
RegisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

VOID
SetupVcComplete(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc );

VOID
TimerQTerminateComplete(
    IN TIMERQ* pTimerQ,
    IN VOID* pContext );

VOID
TunnelTqTerminateComplete(
    IN TIMERQ* pTimerQ,
    IN VOID* pContext );

VOID
UnlockIcs(
    IN VCCB* pVc,
    IN BOOLEAN fGrace );


//-----------------------------------------------------------------------------
// Call-manager handlers and completers
//-----------------------------------------------------------------------------

NDIS_STATUS
LcmCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext )

    // Standard 'CmCmOpenAfHandler' routine called by NDIS when a client
    // requests to open an address family.  See DDK doc.
    //
{
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hExistingAf;

    TRACE( TL_I, TM_Cm, ( "LcmCmOpenAf" ) );

    pAdapter = (ADAPTERCB* )CallMgrBindingContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    if (AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_TAPI_PROXY
        || AddressFamily->MajorVersion != NDIS_MajorVersion
        || AddressFamily->MinorVersion != NDIS_MinorVersion)
    {
        return NDIS_STATUS_BAD_VERSION;
    }

    // Save NDIS's AF handle in the adapter control block.  Interlock just in
    // case multiple clients attempt to open the AF, though don't expect this.
    //
    hExistingAf =
        InterlockedCompareExchangePointer(
            &pAdapter->NdisAfHandle, NdisAfHandle, NULL );
    if (hExistingAf)
    {
        // Our AF has already been opened.  Don't accept another open since
        // only only one would be able to register a SAP anyway.  This way we
        // don't have to be in the business of tracking multiple AF handles.
        //
        ASSERT( !"AF exists?" );
        return NDIS_STATUS_FAILURE;
    }

    ReferenceAdapter( pAdapter );
    ReferenceAf( pAdapter );

    // Since we support only a single address family, just return the adapter
    // as the address family context.
    //
    *CallMgrAfContext = (PNDIS_HANDLE )pAdapter;

    TRACE( TL_I, TM_Cm, ( "LcmCmOpenAf OK" ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
LcmCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext )

    // Standard 'CmCloseAfHandler' routine called by NDIS when a client
    // requests to close an address family.  See DDK doc.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_I, TM_Cm, ( "LcmCmCloseAf" ) );

    pAdapter = (ADAPTERCB* )CallMgrAfContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // This dereference will eventually lead to us calling
    // NdisMCmCloseAfComplete.
    //
    DereferenceAf( pAdapter );

    TRACE( TL_V, TM_Cm, ( "LcmCmCloseAf pending" ) );
    return NDIS_STATUS_PENDING;
}


NDIS_STATUS
LcmCmRegisterSap(
    IN NDIS_HANDLE CallMgrAfContext,
    IN PCO_SAP Sap,
    IN NDIS_HANDLE NdisSapHandle,
    OUT PNDIS_HANDLE CallMgrSapContext )

    // Standard 'LcmCmRegisterSapHandler' routine called by NDIS when the a
    // client registers a service access point.  See DDK doc.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    BOOLEAN fSapExists;
    BOOLEAN fInvalidSapData;

    TRACE( TL_I, TM_Cm, ( "LcmCmRegSap" ) );

    pAdapter = (ADAPTERCB* )CallMgrAfContext;

    // Our SAP context is just the address of the owning adapter control
    // block.  Set it now before scheduling work as NDIS doesn't handle the
    // case of SAP completion correctly otherwise (though it should).
    //
    *CallMgrSapContext = (NDIS_HANDLE )pAdapter;

    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        if (pAdapter->NdisSapHandle)
        {
            fSapExists = TRUE;
        }
        else
        {
            // Save NDIS's SAP handle in the adapter control block.
            //
            fSapExists = FALSE;

            // Extract the SAP line and address IDs and store for
            // regurgitation in incoming call dispatches.
            //
            if (Sap->SapType == AF_TAPI_SAP_TYPE
                && Sap->SapLength >= sizeof(CO_AF_TAPI_SAP))
            {
                CO_AF_TAPI_SAP* pSap;

                pSap = (CO_AF_TAPI_SAP* )(Sap->Sap);
                pAdapter->ulSapLineId = pSap->ulLineID;

                if (pSap->ulAddressID == 0xFFFFFFFF)
                {
                    // This means "any ID is OK" but when indicated back up
                    // NDPROXY doesn't recognize this code, so translate it to
                    // 0 here.
                    //
                    pAdapter->ulSapAddressId = 0;
                }
                else
                {
                    pAdapter->ulSapAddressId = pSap->ulAddressID;
                }

                pAdapter->NdisSapHandle = NdisSapHandle;
                fInvalidSapData = FALSE;
            }
            else
            {
                fInvalidSapData = TRUE;
            }
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (fSapExists)
    {
        TRACE( TL_A, TM_Cm, ( "SAP exists?" ) );
        WPLOG( LL_A, LM_Cm, ( "SAP exists?" ) );
        return NDIS_STATUS_SAP_IN_USE;
    }

    if (fInvalidSapData)
    {
        TRACE( TL_A, TM_Cm, ( "SAP data?" ) );
        WPLOG( LL_A, LM_Cm, ( "SAP data?" ) );
        return NDIS_STATUS_INVALID_DATA;
    }

    // TDI setup must be done at PASSIVE IRQL so schedule a routine to do it.
    //
    status = ScheduleWork( pAdapter, RegisterSapPassive, pAdapter );
    if (status != NDIS_STATUS_SUCCESS)
    {
        NdisAcquireSpinLock( &pAdapter->lockSap );
        {
            pAdapter->NdisSapHandle = NULL;
        }
        NdisReleaseSpinLock( &pAdapter->lockSap );
        return status;
    }

    TRACE( TL_V, TM_Cm, ( "LcmCmRegSap pending" ) );
    return NDIS_STATUS_PENDING;
}


VOID
RegisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to complete the registering of a SAP begun in
    // LcmCmRegisterSap.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hSap;

    TRACE( TL_N, TM_Cm, ( "RegSapPassive" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = (ADAPTERCB* )pContext;
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    // Open the TDI transport and start receiving datagrams.
    //
    status = TdixOpen( &pAdapter->tdix );

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        hSap = pAdapter->NdisSapHandle;

        if (status == NDIS_STATUS_SUCCESS)
        {
            // Mark the SAP active allowing references to be taken, and take
            // the initial reference for SAP registry, plus those for address
            // family and adapter.
            //
            SetFlags( &pAdapter->ulFlags, ACBF_SapActive );
            ASSERT( pAdapter->lSapRef == 0 );
            TRACE( TL_N, TM_Ref, ( "RefSap-ish to 1" ) );
            pAdapter->lSapRef = 1;
            ReferenceAdapter( pAdapter );
            ReferenceAf( pAdapter );
        }
        else
        {
            // Failed to get TDI set up, so NULL the SAP handle in the adapter
            // control block.
            //
            TRACE( TL_A, TM_Cm, ( "TdixOpen=$%08x?", status ) );
            WPLOG( LL_A, LM_Cm, ( "TdixOpen=$%08x?", status ) );
            pAdapter->NdisSapHandle = NULL;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    // Remove the reference for scheduled work.  Do this before telling NDIS
    // the SAP completed because if it failed it can call Halt and unload the
    // driver before we run again here which gives a C4 bugcheck.
    //
    DereferenceAdapter( pAdapter );

    // Report result to client.
    //
    TRACE( TL_I, TM_Cm, ( "NdisMCmRegSapComp" ) );
    NdisMCmRegisterSapComplete( status, hSap, (NDIS_HANDLE )pAdapter );
    TRACE( TL_I, TM_Cm, ( "NdisMCmRegSapComp done" ) );
}


NDIS_STATUS
LcmCmDeregisterSap(
    NDIS_HANDLE CallMgrSapContext )

    // Standard 'CmDeregisterSapHandler' routine called by NDIS when the a
    // client has requested to de-register a service access point.  See DDK
    // doc.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;

    TRACE( TL_I, TM_Cm, ( "LcmCmDeregSap" ) );

    pAdapter = (ADAPTERCB* )CallMgrSapContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        if (ReadFlags( &pAdapter->ulFlags ) & ACBF_SapActive)
        {
            ASSERT( pAdapter->NdisSapHandle );
            ClearFlags( &pAdapter->ulFlags, ACBF_SapActive );
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            TRACE( TL_A, TM_Cm, ( "No SAP active?" ) );
            WPLOG( LL_A, LM_Cm, ( "No SAP active?" ) );
            status = NDIS_STATUS_FAILURE;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (status == NDIS_STATUS_PENDING)
    {
        // Remove the reference for SAP registry.  Eventually, the SAP
        // references will fall to 0 and DereferenceSap will schedule
        // DeregisterSapPassive to complete the de-registry.
        //
        DereferenceSap( pAdapter );
    }

    TRACE( TL_V, TM_Cm, ( "LcmCmDeregSap=$%08x", status ) );
    return status;
}


VOID
DeregisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to complete the de-registering of a SAP begun in
    // LcmCmDeregisterSap.
    //
{
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hOldSap;

    TRACE( TL_I, TM_Cm, ( "DeregSapPassive" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = (ADAPTERCB* )pContext;
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    // Stop receiving datagrams (at least on behalf of this SAP) and
    // deregister the SAP.
    //
    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        hOldSap = pAdapter->NdisSapHandle;
        pAdapter->NdisSapHandle = NULL;
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    TdixClose( &pAdapter->tdix );

    // Remove the adapter references for the NdisSapHandle and for scheduled
    // work.  Remove the address family reference for the NdisSapHandle.  Do
    // all this before telling NDIS the deregister has completed because it
    // can call Halt and unload the driver before we run again here giving a
    // C4 bugcheck.
    //
    DereferenceAdapter( pAdapter );
    DereferenceAdapter( pAdapter );
    DereferenceAf( pAdapter );

    // Report result to client.
    //
    TRACE( TL_I, TM_Cm, ( "NdisMCmDeregSapComp" ) );
    NdisMCmDeregisterSapComplete( NDIS_STATUS_SUCCESS, hOldSap );
    TRACE( TL_I, TM_Cm, ( "NdisMCmDeregSapComp done" ) );
}


NDIS_STATUS
LcmCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext )

    // Standard 'CmCreateVc' routine called by NDIS in response to a
    // client's request to create a virtual circuit.  This
    // call must return synchronously.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB* pVc;

    pAdapter = (ADAPTERCB* )ProtocolAfContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // Allocate and zero a VC control block, then make any non-zero
    // initializations.
    //
    pVc = ALLOC_VCCB( pAdapter );
    if (!pVc)
    {
        WPLOG( LL_A, LM_Res, ( "Failed to allocate VCCB!" ) );
        return NDIS_STATUS_RESOURCES;
    }

    NdisZeroMemory( pVc, sizeof(*pVc) );

    TRACE( TL_I, TM_Cm, ( "LcmCmCreateVc $%p", pVc ) );
    WPLOG( LL_M, LM_Cm, ( "New CALL %p", pVc ) );

    // Zero the back pointer to the tunnel control block (above) and
    // initialize the detached link since clean-up may be required before this
    // block is ever linked into a tunnel chain.
    //
    InitializeListHead( &pVc->linkVcs );
    InitializeListHead( &pVc->linkRequestingVcs );
    InitializeListHead( &pVc->linkCompletingVcs );

    // Set a marker for easier memory dump browsing.
    //
    pVc->ulTag = MTAG_VCCB;

    // Save a back pointer to the adapter for use in LcmCmDeleteVc later.
    //
    ReferenceAdapter( pAdapter );
    pVc->pAdapter = pAdapter;

    // Initialize the VC and call spinlock and send/receive lists.
    //
    NdisAllocateSpinLock( &pVc->lockV );
    NdisAllocateSpinLock( &pVc->lockCall );
    InitializeListHead( &pVc->listSendsOut );
    InitializeListHead( &pVc->listOutOfOrder );

    // Save the NDIS handle of this VC for use in indications to NDIS later.
    //
    pVc->NdisVcHandle = NdisVcHandle;

    // Initialize the estimated round trip time and send timeout per the
    // suggestions in the draft/RFC.
    //
    pVc->ulRoundTripMs = L2TP_LnsDefaultPpd * 100;
    pVc->ulSendTimeoutMs = pVc->ulRoundTripMs;

    // Initialize link capabilities to the defaults for the adapter.
    //
    {
        NDIS_WAN_CO_INFO* pwci = &pAdapter->info;
        NDIS_WAN_CO_GET_LINK_INFO* pwcgli = &pVc->linkinfo;

        NdisZeroMemory( &pVc->linkinfo, sizeof(pVc->linkinfo) );
        pwcgli->MaxSendFrameSize = pwci->MaxFrameSize;
        pwcgli->MaxRecvFrameSize = pwci->MaxFrameSize;
        pwcgli->SendFramingBits = pwci->FramingBits;
        pwcgli->RecvFramingBits = pwci->FramingBits;
        pwcgli->SendACCM = pwci->DesiredACCM;
        pwcgli->RecvACCM = pwci->DesiredACCM;
    }

    // Default send window, "slow started".  This is typically adjusted based
    // on peer's Receive Window AVP when the call is created.
    //
    pVc->ulSendWindow = pAdapter->info.MaxSendWindow >> 1;
    if (pVc->ulSendWindow == 0)
    {
        pVc->ulSendWindow = 1;
    }

    // The VC control block's address is the VC context we return to NDIS.
    //
    *ProtocolVcContext = (NDIS_HANDLE )pVc;

    // Add a reference to the control block and the associated address family
    // that is removed by LmpCoDeleteVc.
    //
    ReferenceVc( pVc );
    ReferenceAf( pAdapter );

    TRACE( TL_V, TM_Cm, ( "LcmCmCreateVc=0" ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
LcmCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext )

    // Standard 'CmDeleteVc' routine called by NDIS in response to a
    // client's request to delete a virtual circuit.  This
    // call must return synchronously.
    //
{
    VCCB* pVc;

    TRACE( TL_I, TM_Cm, ( "LcmCmDelVc($%p)", ProtocolVcContext ) );

    pVc = (VCCB* )ProtocolVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        WPLOG( LL_A, LM_Cm, ( "VC %p invalid tag?", pVc ) );
        return NDIS_STATUS_INVALID_DATA;
    }

    // This flag catches attempts by the client to delete the VC twice.
    //
    if (ReadFlags( &pVc->ulFlags ) & VCBF_VcDeleted)
    {
        TRACE( TL_A, TM_Cm, ( "VC $%p re-deleted?", pVc ) );
        WPLOG( LL_A, LM_Cm, ( "VC %p re-deleted?", pVc ) );
        return NDIS_STATUS_FAILURE;
    }

    WPLOG( LL_M, LM_Cm, ( "Free CALL %p, Cid %d, Peer's Cid %d", pVc, pVc->usCallId, pVc->usAssignedCallId ) );
    
    SetFlags( &pVc->ulFlags, VCBF_VcDeleted );

    // Remove the references added by LcmCmCreateVc.
    //
    DereferenceAf( pVc->pAdapter );
    DereferenceVc( pVc );

    TRACE( TL_V, TM_Cm, ( "LcmCmDelVc=0" ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
LcmCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext )

    // Standard 'CmMakeCallHandler' routine called by NDIS when the a client
    // has requested to connect to a remote end-point.  See DDK doc.
    //
{
    NDIS_STATUS status;
    CO_SPECIFIC_PARAMETERS* pMSpecifics;
    CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED* pTmParams;
    LINE_CALL_PARAMS* pTcParams;
    L2TP_CALL_PARAMETERS* pLcParams;
    VCCB* pVc;
    TUNNELCB* pTunnel;
    ADAPTERCB* pAdapter;
    ULONG ulIpAddress;
    BOOLEAN fDefaultLcParams;
    BOOLEAN fExclusiveTunnel;

    TRACE( TL_I, TM_Cm, ( "LcmCmMakeCall" ) );

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( "!Vtag?" );
        WPLOG( LL_A, LM_Cm, ( "Vtag? %p?", pVc ) );
        return NDIS_STATUS_INVALID_DATA;
    }

    pAdapter = pVc->pAdapter;

    // L2TP has no concept of point-to-multi-point "parties".
    //
    if (CallMgrPartyContext)
    {
        *CallMgrPartyContext = NULL;
    }

    // Validate call parameters.
    //
    do
    {
        // Validate base call parameters.
        //
        {
            // L2TP provides switched VCs only.
            //
            if (CallParameters->Flags &
                    (PERMANENT_VC | BROADCAST_VC | MULTIPOINT_VC))
            {
                status = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }

            // We're supposed to set CALL_PARAMETERS_CHANGED on return if we
            // changed the call parameters, leaving a catch-22 if caller
            // already has it set.  Also, for TAPI address family, media call
            // parameters must be present, though call manager call parameters
            // are not.
            //
            if ((CallParameters->Flags & CALL_PARAMETERS_CHANGED)
                || !CallParameters->MediaParameters)
            {
                status = NDIS_STATUS_INVALID_DATA;
                break;
            }

            pMSpecifics = &CallParameters->MediaParameters->MediaSpecific;
            if (pMSpecifics->Length < sizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS))
            {
                status = NDIS_STATUS_INVALID_DATA;
                break;
            }

            pTmParams =
                (CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED* )&pMSpecifics->Parameters;

            if (pTmParams->LineCallParams.Length < sizeof(LINE_CALL_PARAMS))
            {
                status = NDIS_STATUS_INVALID_DATA;
                break;
            }

            pTcParams = (LINE_CALL_PARAMS* )
                (((CHAR UNALIGNED* )&pTmParams->LineCallParams)
                + pTmParams->LineCallParams.Offset);
        }

        // Validate call parameters.
        //
        {
            CHAR* pszAddress;

            // Caller must provide a destination IP address.  The address is
            // ANSI as are all non-format-coded strings to/from TAPI.
            //
            pszAddress =
                StrDupNdisVarDataDescStringToA( &pTmParams->DestAddress );
            if (!pszAddress)
            {
                status = NDIS_STATUS_RESOURCES;
                break;
            }

            ulIpAddress = IpAddressFromDotted( pszAddress );
            FREE_NONPAGED( pszAddress );
            if (ulIpAddress == 0 || 
                IPADDR_IS_BROADCAST(ulIpAddress) ||
                IPADDR_IS_MULTICAST(ulIpAddress))
            {
                status = NDIS_STATUS_INVALID_ADDRESS;
                break;
            }

            // Reject if unknown WAN-type bits are set.
            //
            if (pTcParams->ulMediaMode
                & ~(LINEMEDIAMODE_DATAMODEM | LINEMEDIAMODE_DIGITALDATA))
            {
                status = NDIS_STATUS_INVALID_DATA;
                break;
            }
        }

        // Validate L2TP call parameters.
        //
        // When caller doesn't provide L2TP-specific parameters a local block
        // with default values is substituted for the convenience of the rest
        // of the code.
        //
        {
            if (pTcParams->ulDevSpecificSize == sizeof(*pLcParams))
            {
                pLcParams = (L2TP_CALL_PARAMETERS* )
                    ((CHAR* )pTcParams) + pTcParams->ulDevSpecificOffset;
                fDefaultLcParams = FALSE;
            }
            else
            {
                pLcParams =
                    (L2TP_CALL_PARAMETERS* )ALLOC_NONPAGED(
                        sizeof(*pLcParams), MTAG_L2TPPARAMS );
                if (!pLcParams)
                {
                    WPLOG( LL_A, LM_Res, ( "Failed to allocate L2TP_CALL_PARAMETERS") );
                    status = NDIS_STATUS_RESOURCES;
                    break;
                }

                fDefaultLcParams = TRUE;
                NdisZeroMemory( pLcParams, sizeof(*pLcParams) );
                pLcParams->ulPhysicalChannelId = 0xFFFFFFFF;
            }
        }

        status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        return status;
    }

    // Stash the call parameters in the VC block.  Simultaneous MakeCalls on
    // the same VC is a client error, but it's easy to guard against so do
    // that here.
    //
    if (InterlockedCompareExchangePointer(
            &pVc->pMakeCall, CallParameters, NULL ))
    {
        ASSERT( !"Double MakeCall?" );
        if (fDefaultLcParams)
        {
            FREE_NONPAGED( pLcParams );
        }
        return NDIS_STATUS_CALL_ACTIVE;
    }

    pVc->pTmParams = pTmParams;
    pVc->pTcParams = pTcParams;
    pVc->pLcParams = pLcParams;

    // This VC's call is now cleanable, i.e. the base call clean up routine,
    // InactiveCallCleanUp, will now eventually be called.
    //
    do
    {
        // Convert parameter and configuration information to VC flags where
        // appropriate.
        //
        {
            ULONG ulMask = 0;

            if (CallParameters->MediaParameters->Flags
                    & RECEIVE_TIME_INDICATION)
            {
                ulMask |= VCBF_IndicateTimeReceived;
            }

            if (pAdapter->ulFlags & ACBF_OutgoingRoleLac)
            {
                ulMask |= VCBF_IncomingFsm;
            }

            if (fDefaultLcParams)
            {
                ulMask |= VCBF_DefaultLcParams;
            }

            if (ulMask)
            {
                SetFlags( &pVc->ulFlags, ulMask );
            }
        }

        // Take the next progressively increasing call serial number string.
        //
        NdisInterlockedIncrement( &pAdapter->ulCallSerialNumber );

        // Reserve a Call-ID slot in the adapter's table.
        //
        status = ReserveCallIdSlot( pVc );
        if (status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        // Create a new or find an existing tunnel control block for caller's
        // specified IP address in the adapter's list.  The returned block is
        // linked to the adapter and referenced.  The reference is the one for
        // linkage in the list, i.e. case (a).
        //
        fExclusiveTunnel = (BOOLEAN )
            ((fDefaultLcParams)
                ? !!(pAdapter->ulFlags & ACBF_ExclusiveTunnels)
                : !!(pLcParams->ulFlags & L2TPCPF_ExclusiveTunnel));

        pTunnel = SetupTunnel( pAdapter, ulIpAddress, 0, 0, fExclusiveTunnel );
        if (!pTunnel)
        {
            status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisAcquireSpinLock( &pTunnel->lockT );
        {
            if (ReadFlags( &pTunnel->ulFlags ) & TCBF_Closing)
            {
                // This is unlikely because SetupTunnel only finds non-closing
                // tunnels, but this check and linkage must occur atomically
                // under 'lockT'.  New VCs must not be linked onto closing
                // tunnels.
                //
                status = NDIS_STATUS_TAPI_DISCONNECTMODE_UNKNOWN;
            }
            else
            {
                // The call has an open operation pending and can accept close
                // requests.
                //
                SetFlags( &pVc->ulFlags,
                    VCBF_ClientOpenPending
                    | VCBF_CallClosableByClient
                    | VCBF_CallClosableByPeer );

                NdisAcquireSpinLock( &pTunnel->lockVcs );
                {
                    // Set the back pointer to it's tunnel.  The associated
                    // tunnel reference was taken by SetupTunnel above.
                    //
                    pVc->pTunnel = pTunnel;

                    // Link the VC into the tunnel's list of associated VCs.
                    //
                    InsertTailList( &pTunnel->listVcs, &pVc->linkVcs );
                }
                NdisReleaseSpinLock( &pTunnel->lockVcs );
            }
        }
        NdisReleaseSpinLock( &pTunnel->lockT );
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        CallCleanUp( pVc );
        return status;
    }

    // Schedule FsmOpenTunnel to kick off the combination of tunnel and call
    // creation state machines that will eventually call NdisMakeCallComplete
    // to notify caller of the result.  A happy side effect of the scheduling
    // is that the callback will occur at PASSIVE IRQL, the level at which TDI
    // clients must run.
    //
    pVc->state = CS_WaitTunnel;
    ScheduleTunnelWork(
        pTunnel, pVc, FsmOpenTunnel,
        0, 0, 0, 0, FALSE, FALSE );

    TRACE( TL_V, TM_Cm, ( "LcmCmMakeCall pending" ) );
    return NDIS_STATUS_PENDING;
}


NDIS_STATUS
LcmCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size )

    // Standard 'CmCloseCallHandler' routine called by NDIS when the a client
    // has requested to tear down a call.  See DDK doc.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    ULONG ulFlags;
    BOOLEAN fCallClosable;

    TRACE( TL_I, TM_Cm, ( "LcmCmCloseCall($%p)", CallMgrVcContext ) );

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pAdapter = pVc->pAdapter;

    NdisAcquireSpinLock( &pVc->lockV );
    {
        ulFlags = ReadFlags( &pVc->ulFlags );

        if (ulFlags & VCBF_WaitCloseCall)
        {
            // Note that we got the close from the client we were expecting.
            // This is helpful information when debugging, but is not
            // otherwise used.
            //
            ClearFlags( &pVc->ulFlags, VCBF_WaitCloseCall );
        }

        if (ulFlags & VCBF_CallClosableByClient)
        {
            fCallClosable = TRUE;

            // Accepting this close makes the call no longer closable by
            // client or peer.  Any peer operation that was pending is
            // cleared, and a client close becomes pending.  It is possible to
            // have both a client open and close pending at the same time.
            //
            ClearFlags( &pVc->ulFlags,
                (VCBF_CallClosableByClient
                 | VCBF_CallClosableByPeer
                 | VCBF_PeerClosePending
                 | VCBF_PeerOpenPending) );
            SetFlags( &pVc->ulFlags, VCBF_ClientClosePending );

            // If a client open is pending, it fails.
            //
            if (ulFlags & VCBF_ClientOpenPending)
            {
                pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
            }

            // Close the call, being graceful if possible.
            //
            ASSERT( pVc->pTunnel );
            ScheduleTunnelWork(
                pVc->pTunnel, pVc, FsmCloseCall,
                (ULONG_PTR )CRESULT_Administrative, (ULONG_PTR )GERR_None,
                0, 0, FALSE, FALSE );
        }
        else
        {
            TRACE( TL_A, TM_Cm, ( "Call not closable!" ) );
            WPLOG( LL_A, LM_Cm, ( "Call not closable, pVc = %p!", pVc ) );
            fCallClosable = FALSE;
        }
    }
    NdisReleaseSpinLock( &pVc->lockV );

    if (!fCallClosable)
    {
        // The call is not in a closable state.  Just fail the request
        // immediately.  Since the docs say the call must return PENDING, this
        // is done by calling the completion routine here, in typical NDIS
        // fashion.
        //
        ++g_ulCallsNotClosable;
        TRACE( TL_A, TM_Cm, ( "Call NdisMCmCloseCallComp(FAIL)!" ) );
        WPLOG( LL_A, LM_Cm, ( "Call NdisMCmCloseCallComp(FAIL)!" ) );
        NdisMCmCloseCallComplete(
            NDIS_STATUS_FAILURE, pVc->NdisVcHandle, NULL );
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseCallComp done" ) );

        // Careful, client may have deleted the VC, so 'pVc' must not be
        // referenced hereafter.
        //
    }

    TRACE( TL_V, TM_Cm, ( "LcmCmCloseCall pending" ) );
    return NDIS_STATUS_PENDING;
}


VOID
LcmCmIncomingCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmIncomingCallCompleteHandler' routine called by NDIS when
    // a client has responded to the call-managers's previously dispatched
    // incoming call.  See DDK doc.
    //
{
    VCCB* pVc;

    TRACE( TL_I, TM_Cm, ( "LcmCmInCallComp($%p,s=$%08x)", CallMgrVcContext, Status ) );

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"VTag" );
        return;
    }

    // The work is scheduled to avoid a possible recursive loop of completing
    // VCs that could overrun the stack.  See bug 370996.
    //
    ASSERT( pVc->pTunnel );
    ScheduleTunnelWork(
        pVc->pTunnel, pVc, IncomingCallCompletePassive,
        (ULONG )Status, 0, 0, 0, FALSE, FALSE );

    TRACE( TL_V, TM_Cm, ( "LcmCmInCallComp done" ) );
}


VOID
IncomingCallCompletePassive(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to complete an LcmCmIncomingCallComplete.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Cm, ( "InCallCompApc" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pVc->pAdapter;
    status = (NDIS_STATUS )(punpArgs[ 0 ]);
    FREE_TUNNELWORK( pAdapter, pWork );

    // Guard against a double-complete error by the client.
    //
    if (ReadFlags( &pVc->ulFlags ) & VCBF_WaitInCallComplete)
    {
        ClearFlags( &pVc->ulFlags, VCBF_WaitInCallComplete );

        if (status != NDIS_STATUS_SUCCESS)
        {
            pVc->usResult = CRESULT_Busy;
            pVc->usError = GERR_None;

            // Turn off the "call NdisMCmDispatchIncomingCloseCall if peer
            // terminates the call" flag.  It was turned on even though peer
            // pended, per JameelH.
            //
            ClearFlags( &pVc->ulFlags, VCBF_VcDispatched );
            
            WPLOG( LL_A, LM_Cm, ( "Failed pVc = %p,s= %08x!)", pVc, status ) );
        }

        SetupVcComplete( pTunnel, pVc );
    }
    else
    {
        ASSERT( !"Not expecting InCallComp?" );
        ++g_ulUnexpectedInCallCompletes;
    }

    // Remove the VC and call references covering the dispatched incoming
    // call.
    //
    DereferenceCall( pVc );
    DereferenceVc( pVc );
}


VOID
LcmCmActivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmActivateVcCompleteHandler' routine called by NDIS when the
    // mini-port has completed the call-manager's previous request to activate
    // a virtual circuit.  See DDK doc.
    //
{
    ASSERT( !"LcmCmActVcComp?" );
}


VOID
LcmCmDeactivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext )

    // Standard 'CmDeactivateVcCompleteHandler' routine called by NDIS when
    // the mini-port has completed the call-manager's previous request to
    // de-activate a virtual circuit.  See DDK doc.
    //
{
    ASSERT( !"LcmCmDeactVcComp?" );
}


NDIS_STATUS
LcmCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmModifyQoSCallHandler' routine called by NDIS when a client
    // requests a modification in the quality of service provided by the
    // virtual circuit.  See DDK doc.
    //
{
    TRACE( TL_N, TM_Cm, ( "LcmCmModQoS" ) );

    // There is no useful concept of quality of service for IP media.
    //
    return NDIS_STATUS_NOT_SUPPORTED;
}


NDIS_STATUS
LcmCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST NdisRequest )

    // Standard 'CmRequestHandler' routine called by NDIS in response to a
    // client's request for information from the call manager.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_STATUS status;

    TRACE( TL_I, TM_Cm, ( "LcmCmReq" ) );

    pAdapter = (ADAPTERCB* )CallMgrAfContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc && pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    switch (NdisRequest->RequestType)
    {
        case NdisRequestQueryInformation:
        {
            status = QueryCmInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.QUERY_INFORMATION.Oid,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded );
            break;
        }

        case NdisRequestSetInformation:
        {
            TRACE( TL_A, TM_Cm,
               ( "CmSetOID=%d?", NdisRequest->DATA.SET_INFORMATION.Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        default:
        {
            status = NDIS_STATUS_NOT_SUPPORTED;
            TRACE( TL_A, TM_Cm, ( "CmType=%d?", NdisRequest->RequestType ) );
            break;
        }
    }

    return status;
}


//-----------------------------------------------------------------------------
// Call utility routines (alphabetically)
// Some are used externally
//-----------------------------------------------------------------------------

VOID
ActivateCallIdSlot(
    IN VCCB* pVc )

    // Sets the address of the VC, 'pVc', in the adapter's table of Call-IDs
    // enabling receives on the Call-ID.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = pVc->pAdapter;

    if (pVc->usCallId > 0 && pVc->usCallId <= pAdapter->usMaxVcs)
    {
        ASSERT( pAdapter->ppVcs[ pVc->usCallId - 1 ] == (VCCB* )-1 );

        NdisAcquireSpinLock( &pAdapter->lockVcs );
        {
            pAdapter->ppVcs[ pVc->usCallId - 1 ] = pVc;
        }
        NdisReleaseSpinLock( &pAdapter->lockVcs );
    }
}


VOID
BuildCallParametersShell(
    IN ADAPTERCB* pAdapter,
    IN ULONG ulIpAddress,
    IN ULONG ulBufferLength,
    OUT CHAR* pBuffer,
    OUT CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED ** ppTiParams,
    OUT LINE_CALL_INFO** ppTcInfo,
    OUT L2TP_CALL_PARAMETERS** ppLcParams )

    // Loads caller's buffer 'pBuffer' of length 'ulBufferLength' bytes with a
    // CO_CALL_PARAMETERS structure containing default values.  Loads caller's
    // '*ppTiParams', '*ppTcInfo', and '*ppLcParams' with shortcut pointers to
    // the TAPI call and L2TP specific structures within the built
    // CO_CALL_PARAMETERS.  'PAdapter' is the adapter context.  'pUlIpAddress'
    // is the IP address of the peer in network byte order.
    //
{
    CO_CALL_PARAMETERS* pCp;
    CO_CALL_MANAGER_PARAMETERS* pCmp;
    CO_MEDIA_PARAMETERS* pMp;
    CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED * pTip;
    LINE_CALL_INFO* pLci;
    L2TP_CALL_PARAMETERS* pLcp;
    CHAR* pszCallerId;
    ULONG ulLciTotalSize;
    ULONG ulMediaSpecificSize;
    ULONG ulBytesPerSec;
    WCHAR* pszCallerID;

    NdisZeroMemory( pBuffer, ulBufferLength );

    pCp = (CO_CALL_PARAMETERS* )pBuffer;
    
    pCmp = (PCO_CALL_MANAGER_PARAMETERS ) ( (PUCHAR)(pCp + 1) + sizeof(PVOID) );
    (ULONG_PTR) pCmp &= ~( (ULONG_PTR) sizeof(PVOID) - 1 );
    pCp->CallMgrParameters = pCmp;
    
    pMp = (PCO_MEDIA_PARAMETERS ) ( (PUCHAR) (pCmp + 1) + sizeof(PVOID) );
    (ULONG_PTR) pMp &= ~( (ULONG_PTR) sizeof(PVOID) - 1 );
    pCp->MediaParameters = pMp;

    // This needs to be dynamic based on speed reported by TDI.
    //
    ulBytesPerSec = L2TP_LanBps / 8;
    pCmp->Transmit.TokenRate = ulBytesPerSec;
    pCmp->Transmit.PeakBandwidth = ulBytesPerSec;
    pCmp->Transmit.MaxSduSize = L2TP_MaxFrameSize;
    pCmp->Receive.TokenRate = ulBytesPerSec;
    pCmp->Receive.PeakBandwidth = ulBytesPerSec;
    pCmp->Receive.MaxSduSize = L2TP_MaxFrameSize;

    ulLciTotalSize =
        sizeof(*pLci)
        + sizeof(PVOID)
        + sizeof(*pLcp)
        + ((L2TP_MaxDottedIpLen + 1) * sizeof(WCHAR));

    ulMediaSpecificSize = sizeof(*pTip) + sizeof(PVOID) + ulLciTotalSize;

    pTip =
        (CO_AF_TAPI_INCOMING_CALL_PARAMETERS UNALIGNED* )pMp->MediaSpecific.Parameters;

    pLci = (LINE_CALL_INFO*) ( (PUCHAR) (pTip + 1) + sizeof(PVOID) );
    (ULONG_PTR) pLci &= ~( (ULONG_PTR) sizeof(PVOID) - 1 );

    pLcp = (L2TP_CALL_PARAMETERS*) ( (PUCHAR) (pLci + 1) + sizeof(PVOID) );
    (ULONG_PTR) pLcp &= ~( (ULONG_PTR) sizeof(PVOID) - 1 );

    pMp->ReceiveSizeHint = L2TP_MaxFrameSize;
    pMp->MediaSpecific.Length = ulMediaSpecificSize;
        
    pTip->LineCallInfo.Length = (USHORT )ulLciTotalSize;
    pTip->LineCallInfo.MaximumLength = (USHORT )ulLciTotalSize;
    pTip->LineCallInfo.Offset = (ULONG) ((CHAR*) pLci - (CHAR*) &pTip->LineCallInfo);

    pLci->ulTotalSize = ulLciTotalSize;
    pLci->ulNeededSize = ulLciTotalSize;
    pLci->ulUsedSize = ulLciTotalSize;
    pLci->ulLineDeviceID = pAdapter->ulSapLineId;
    pLci->ulAddressID = pAdapter->ulSapAddressId;
    pLci->ulDevSpecificSize = sizeof(*pLcp);
    pLci->ulDevSpecificOffset = (ULONG) ((CHAR*) pLcp - (CHAR*) pLci);
    pLci->ulBearerMode = LINEBEARERMODE_DATA;

    pLci->ulCallerIDOffset = pLci->ulDevSpecificOffset + pLci->ulDevSpecificSize;
    
    pszCallerID = (WCHAR*)(((CHAR* )pLci) + pLci->ulCallerIDOffset);
    DottedFromIpAddress( ulIpAddress, (CHAR* )pszCallerID, TRUE );
    pLci->ulCallerIDSize = (StrLenW( pszCallerID ) + 1) * sizeof(WCHAR);
    pLci->ulCallerIDFlags = LINECALLPARTYID_ADDRESS;

    pLcp->ulPhysicalChannelId = 0xFFFFFFFF;

    // Fill in shortcut outputs.
    //
    *ppTiParams = pTip;
    *ppTcInfo = pLci;
    *ppLcParams = pLcp;
}


VOID
CallCleanUp(
    IN VCCB* pVc )

    // De-associates the VC from the tunnel, preparing for and de-activating
    // the call.
    //
{
    NDIS_STATUS status;
    ULONG ulFlags;

    ulFlags = ReadFlags( &pVc->ulFlags );

    TRACE( TL_I, TM_Cm, ( "CallCleanUp(pV=$%p,cid=%d,act=%d)",
        pVc, (ULONG )pVc->usCallId, !!(ulFlags & VCBF_VcActivated) ) );
    ASSERT( pVc->ulTag == MTAG_VCCB );

    if (ReadFlags( &pVc->ulFlags ) & VCBF_VcActivated)
    {
        TRACE( TL_I, TM_Cm, ( "NdisMCmDeactVc" ) );
        status = NdisMCmDeactivateVc( pVc->NdisVcHandle );
        TRACE( TL_I, TM_Cm, ( "NdisMCmDeactVc=$%x", status ) );
        ASSERT( status == NDIS_STATUS_SUCCESS );

        ClearFlags( &pVc->ulFlags, VCBF_VcActivated );
        DereferenceCall( pVc );

        // The above actions lead to the call reference eventually going to 0,
        // at which time clean up resumes in DereferenceCall.
        //
    }
    else
    {
        InactiveCallCleanUp( pVc );
    }
}


VOID
CallSetupComplete(
    IN VCCB* pVc )

    // Clean up 'pVc' allocations used only at call setup, if any.
    //
{
    if (InterlockedExchangePointer( &pVc->pMakeCall, NULL ))
    {
        ASSERT( pVc->pTmParams );
        ASSERT( pVc->pTcParams );
        ASSERT( pVc->pLcParams );

        if (ReadFlags( &pVc->ulFlags ) & VCBF_DefaultLcParams)
        {
            // Caller did not provide any LcParams.  Free the 'default' version we
            // created for convenience.
            //
            FREE_NONPAGED( pVc->pLcParams );
        }

        pVc->pTmParams = NULL;
        pVc->pTcParams = NULL;
        pVc->pLcParams = NULL;
    }

    UnlockIcs( pVc, FALSE );
}


VOID
CloseCall(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to close the call on 'pVc'.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    BOOLEAN fCompleteVcs;

    TRACE( TL_I, TM_Fsm, ( "CloseCall(pV=$%p)", pVc ) );

    // No context information so just free the work item.
    //
    FREE_TUNNELWORK( pTunnel->pAdapter, pWork );

    // Close down the call.
    //
    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        NdisAcquireSpinLock( &pVc->lockV );
        {
            fCompleteVcs = CloseCall2(
                pTunnel, pVc, TRESULT_Shutdown, GERR_None );
        }
        NdisReleaseSpinLock( &pVc->lockV );

        if (fCompleteVcs)
        {
            CompleteVcs( pTunnel );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockT );
}


BOOLEAN
CloseCall2(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN USHORT usResult,
    IN USHORT usError )

    // Close the call on VC 'pVc' of tunnel 'pTunnel'.  'UsResult' and
    // 'usError' are the TRESULT_* and GERR_* codes to be reported in the
    // StopCCN message, if applicable.
    //
    // Returns true if caller should call CompleteVcs after releasing 'lockV'
    // or false if not.
    //
    // IMPORTANT: Caller must hold 'lockT' and 'lockV'.
    //
{
    ULONG ulFlags;

    // Check if another path has completed the VC already.  If so, there's no
    // reason to continue.  Without the local tunnel cancel optimization
    // below, this check can be removed entirely and everything safely falls
    // through.  This check should include all "non-completing" conditions in
    // CallTransitionComplete.
    //
    ulFlags = ReadFlags( &pVc->ulFlags );
    if (!(ulFlags & VCBM_Pending))
    {
        if (!(ulFlags & VCBF_CallClosableByPeer))
        {
            TRACE( TL_A, TM_Cm, ( "Not closable" ) );
            WPLOG( LL_A, LM_Cm, ( "pVc = %p not closable!", pVc ) );
            return FALSE;
        }
    }

    // For locally initiated tunnels, check if this VC is the only one on the
    // tunnel, and if so, close the tunnel directly which slams this call.
    // Without this, the call closure would still bring down the tunnel.
    // However, the tunnel would complete it's transition normally, then be
    // dropped.  This speeds things up a little, giving quick response in the
    // case where user cancels an attempt to connect to a wrong address or
    // non-responsive server.
    //
    if (!(ReadFlags( &pTunnel->ulFlags) & TCBF_PeerInitiated))
    {
        BOOLEAN fMultipleVcs;

        NdisAcquireSpinLock( &pTunnel->lockVcs );
        {
            fMultipleVcs =
                (pTunnel->listVcs.Flink != pTunnel->listVcs.Blink);
        }
        NdisReleaseSpinLock( &pTunnel->lockVcs );

        if (!fMultipleVcs)
        {
            ScheduleTunnelWork(
                pTunnel, NULL, FsmCloseTunnel,
                (ULONG_PTR )usResult,
                (ULONG_PTR )usError,
                0, 0, FALSE, FALSE );
            return FALSE;
        }
    }

    // Slam the call closed.
    //
    CallTransitionComplete( pTunnel, pVc, CS_Idle );
    return TRUE;
}


VOID
CloseTunnel(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to slam closed tunnel 'pTunnel'.  See also
    // FsmCloseTunnel, which is often more appropriate.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    TRACE( TL_I, TM_Fsm, ( "CloseTunnel(pT=$%p)", pTunnel ) );

    // No context information so just free the work item.
    //
    FREE_TUNNELWORK( pTunnel->pAdapter, pWork );

    // Close down the tunnel.
    //
    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        CloseTunnel2( pTunnel );
    }
    NdisReleaseSpinLock( &pTunnel->lockT );
}


VOID
CloseTunnel2(
    IN TUNNELCB* pTunnel )

    // Close the tunnel 'pTunnel'.
    //
    // IMPORTANT: Caller must hold 'lockT'.
    //
{
    SetFlags( &pTunnel->ulFlags, TCBF_Closing );
    TunnelTransitionComplete( pTunnel, CCS_Idle );
    CompleteVcs( pTunnel );
}


VOID
CompleteVcs(
    IN TUNNELCB* pTunnel )

    // Complete the pending operation for each of the VCs on the completing
    // list of tunnel 'pTunnel'.
    //
    // IMPORTANT: Caller must hold 'lockT'.  This routine may release and
    //            re-acquire 'lockT'.
    //
{
    while (!IsListEmpty( &pTunnel->listCompletingVcs ))
    {
        LIST_ENTRY* pLink;
        VCCB* pVc;
        NDIS_STATUS status;
        LINKSTATUSINFO info;
        ULONG ulFlags;
        NDIS_STATUS statusVc;

        if (pTunnel->listCompletingVcs.Flink->Flink
            == pTunnel->listCompletingVcs.Flink)
        {
            // This is a hack to work around a rare listCompletingVcs
            // corruption problem whose cause has me baffled.  When the
            // problem occurs, a VCCB with it's link initialized appears in
            // the list.  This code removes the corrupted case hopefully
            // resulting in exactly the same state as the normal path in the
            // "else" clause.
            //
            pLink = pTunnel->listCompletingVcs.Flink;
            InitializeListHead( &pTunnel->listCompletingVcs );
            ASSERT( FALSE );
            ++g_ulCompletingVcCorruption;
        }
        else
        {
            // Pop the next completing VC from the list.
            //
            pLink = RemoveHeadList( &pTunnel->listCompletingVcs );
        }

        InitializeListHead( pLink );

        // Take a reference covering use of the VC pointer obtained from the
        // completing list.
        //
        pVc = CONTAINING_RECORD( pLink, VCCB, linkCompletingVcs );
        ReferenceVc( pVc );
        
        ASSERT(ReadFlags(&pVc->ulFlags) & VCBF_CompPending);            
        ClearFlags( &pVc->ulFlags, VCBF_CompPending );

        TRACE( TL_V, TM_Cm, ( "CompleteVc $%p", pVc ) );

        NdisAcquireSpinLock( &pVc->lockV );
        {
            // Note the pending flags then clear them, to ensure that all
            // pending operations are completed exactly once.  This is
            // necessary since ClientOpen and ClientClose events may be
            // pending simultaneously.  (Thanks a lot NDIS guys).
            //
            ulFlags = ReadFlags( &pVc->ulFlags );
            ClearFlags( &pVc->ulFlags, VCBM_Pending );

            // Convert client close pending to client close completion,
            // for reference later when call references reach zero.  The
            // flag determines if NdisMCmCloseCallComplete must be called.
            //
            if (ulFlags & VCBF_ClientClosePending)
            {
                SetFlags( &pVc->ulFlags, VCBF_ClientCloseCompletion );
            }

            // Before releasing the lock, make "safe" copies of any VC
            // parameters we might need.
            //
            TransferLinkStatusInfo( pVc, &info );
            statusVc = pVc->status;
        }
        NdisReleaseSpinLock( &pVc->lockV );

        NdisReleaseSpinLock( &pTunnel->lockT );
        {
            if (ulFlags & VCBF_PeerOpenPending)
            {
                TRACE( TL_N, TM_Cm, ( "PeerOpen complete, s=$%x", statusVc ) );

                if (statusVc == NDIS_STATUS_SUCCESS)
                {
                    // Peer initiated call succeeded.
                    //
                    ASSERT( ulFlags & VCBF_VcDispatched );
                    TRACE( TL_I, TM_Cm, ( "NdisMCmDispCallConn" ) );
                    NdisMCmDispatchCallConnected( pVc->NdisVcHandle );
                    TRACE( TL_I, TM_Cm, ( "NdisMCmDispCallConn done" ) );

                    IndicateLinkStatus( pVc, &info );
                    CallSetupComplete( pVc );
                }
                else
                {
                    // Peer initiated call failed.
                    //
                    if (ulFlags & VCBF_VcDispatched)
                    {
                        SetFlags( &pVc->ulFlags, VCBF_WaitCloseCall );
                        TRACE( TL_A, TM_Cm, ( "Call NdisMCmDispInCloseCall(s=$%x)", statusVc ) );
                            
                        NdisMCmDispatchIncomingCloseCall(
                            statusVc, pVc->NdisVcHandle, NULL, 0 );
                        TRACE( TL_I, TM_Cm,
                            ( "NdisMCmDispInCloseCall done" ) );

                        // Client will call NdisClCloseCall which will get
                        // our LcmCloseCall handler called to clean up
                        // call setup, de-activate and delete the VC, as
                        // necessary.
                        //
                    }
                    else
                    {
                        // Return the VC to "just created" state.
                        //
                        CallCleanUp( pVc );
                    }
                }
            }
            else if (ulFlags & VCBF_ClientOpenPending)
            {
                TRACE( TL_N, TM_Cm, ( "ClientOpen complete, s=$%x", statusVc ) );

                if (statusVc == NDIS_STATUS_SUCCESS)
                {
                    // Client initiated open, i.e. MakeCall, succeeded.
                    //
                    // Activating the VC is a CoNDIS preliminary to reporting
                    // the MakeCall complete.  For L2TP, all it does is get
                    // the NDIS state flags set correctly.
                    //
                    TRACE( TL_I, TM_Cm, ( "Call NdisMCmActivateVc" ) );
                    ASSERT( pVc->pMakeCall );
                    status = NdisMCmActivateVc(
                        pVc->NdisVcHandle, pVc->pMakeCall );
                    TRACE( TL_I, TM_Cm, ( "NdisMCmActivateVc=$%x", status ) );
                    ASSERT( status == NDIS_STATUS_SUCCESS );

                    {
                        BOOLEAN fCallActive;

                        SetFlags( &pVc->ulFlags, VCBF_VcActivated );
                        fCallActive = ReferenceCall( pVc );
                        ASSERT( fCallActive );
                    }
                }

                // Update the call parameters
                pVc->pMakeCall->CallMgrParameters->Transmit.PeakBandwidth = 
                pVc->pMakeCall->CallMgrParameters->Transmit.TokenRate = 
                pVc->pMakeCall->CallMgrParameters->Receive.PeakBandwidth = 
                pVc->pMakeCall->CallMgrParameters->Receive.TokenRate = pVc->ulConnectBps / 8;

                TRACE( TL_I, TM_Cm, ( "Call NdisMCmMakeCallComp(s=$%x)", statusVc ) );
                
                ASSERT( pVc->pMakeCall );
                NdisMCmMakeCallComplete(
                    statusVc, pVc->NdisVcHandle, NULL, NULL, pVc->pMakeCall );
                    
                TRACE( TL_I, TM_Cm, ( "NdisMCmMakeCallComp done" ) );

                if (statusVc == NDIS_STATUS_SUCCESS)
                {
                    IndicateLinkStatus( pVc, &info );
                    CallSetupComplete( pVc );
                }
                else
                {
                    // Return the VC to "just created" state.
                    //
                    InactiveCallCleanUp( pVc );
                }
            }
            else if (ulFlags & VCBF_PeerClosePending )
            {
                TRACE( TL_N, TM_Cm, ( "PeerClose complete, s=$%x", statusVc ) );

                // Peer initiated close completed.
                //
                SetFlags( &pVc->ulFlags, VCBF_WaitCloseCall );
                TRACE( TL_I, TM_Cm, ( "Call NdisMCmDispInCloseCall(s=$%x)", statusVc ) );
                NdisMCmDispatchIncomingCloseCall(
                    statusVc, pVc->NdisVcHandle, NULL, 0 );
                TRACE( TL_I, TM_Cm, ( "NdisMCmDispInCloseCall done" ) );

                // Client will call NdisClCloseCall while processing the above
                // which will get our LcmCloseCall handler called to
                // de-activate and delete the VC, as necessary.
                //
            }
            else if (ulFlags & VCBF_ClientClosePending)
            {
                // This section eventually runs for all successful unclosed
                // calls, whether peer or client initiated or closed.
                //
                TRACE( TL_N, TM_Cm, ( "ClientClose complete" ) );

                // Deactivate the VC and return all sent packets to the client
                // above.  These events will eventually lead to the call being
                // dereferenced to zero, at which time the close is completed,
                // and if peer initiated, the VC is deleted.
                //
                // Note: When MakeCall is cancelled by a Close request, these
                //       actions occur during the InactiveCallCleanUp in the
                //       ClientOpenPending completion code handling, rather
                //       than the CallCleanUp (which leads to
                //       InactiveCallCleanUp) here.  In this case, this block
                //       does NOT run even though the ClientClosePending flag
                //       is set.  Consider this before adding code here.
                //
                CallCleanUp( pVc );
            }
        }
        NdisAcquireSpinLock( &pTunnel->lockT );

        // Remove the reference for use of the VC pointer from the completing
        // list.
        //
        DereferenceVc( pVc );
    }
}


TUNNELCB*
CreateTunnelCb(
    IN ADAPTERCB* pAdapter )

    // Allocates and initializes a tunnel control block from the pool
    // associated with 'pAdapter'.  Tunnels are created unreferenced.
    //
    // Returns the allocated control block or NULL if allocation failed.  The
    // allocated block must eventually be freed with FREE_TUNNELCB, typically
    // via DereferenceTunnel.
    //
    // IMPORTANT: Caller must hold the 'pAdapter->lockTunnels'.
    //
{
    TUNNELCB* pTunnel;

    pTunnel = ALLOC_TUNNELCB( pAdapter );
    if (pTunnel)
    {
        NdisZeroMemory( pTunnel, sizeof(*pTunnel ) );

        InitializeListHead( &pTunnel->linkTunnels );
        InitializeListHead( &pTunnel->listRequestingVcs );
        InitializeListHead( &pTunnel->listCompletingVcs );
        InitializeListHead( &pTunnel->listSendsOut );
        InitializeListHead( &pTunnel->listOutOfOrder );
        InitializeListHead( &pTunnel->listVcs );
        InitializeListHead( &pTunnel->listWork );

        NdisAllocateSpinLock( &pTunnel->lockT );
        NdisAllocateSpinLock( &pTunnel->lockWork );

        pTunnel->ulTag = MTAG_TUNNELCB;
        pTunnel->state = CCS_Idle;

        // Choose the next non-zero sequential tunnel identifier.
        //
        pTunnel->usTunnelId = GetNextTunnelId( pAdapter );

        // Default send window, "slow started".  This is typically adjusted
        // based on peer's Receive Window AVP when the tunnel is created, but
        // if he doesn't include one this default is used.
        //
        pTunnel->ulSendWindow = pAdapter->info.MaxSendWindow >> 1;
        if (pTunnel->ulSendWindow == 0)
        {
            pTunnel->ulSendWindow = 1;
        }

        // Initialize the estimated round trip time and send timeout per the
        // suggestions in the draft/RFC.
        //
        pTunnel->ulRoundTripMs = pAdapter->ulInitialSendTimeoutMs;
        pTunnel->ulSendTimeoutMs = pTunnel->ulRoundTripMs;

        pTunnel->ulMediaSpeed = L2TP_LanBps;

        pTunnel->pTimerQ = ALLOC_TIMERQ( pAdapter );
        if (!pTunnel->pTimerQ)
        {
            WPLOG( LL_A, LM_Res, ( "Failed to allocate TIMERQ") );
            pTunnel->ulTag = MTAG_FREED;
            FREE_TUNNELCB( pAdapter, pTunnel );
            return NULL;
        }

        TimerQInitialize( pTunnel->pTimerQ );
        ++pAdapter->ulTimers;

        if (pAdapter->pszPassword)
        {
            UNALIGNED ULONG* pul;

            // Password specified so peer should be authenticated.  Choose a
            // random challenge to send to peer.
            //
            pul = (UNALIGNED ULONG* )(pTunnel->achChallengeToSend);
            NdisGetCurrentSystemTime( (LARGE_INTEGER* )pul );
            pul[ 1 ] = PtrToUlong( pAdapter );
            pul[ 2 ] = PtrToUlong( pTunnel );
            pul[ 3 ] = PtrToUlong( &pul );
        }

        ReferenceAdapter( pAdapter );
        pTunnel->pAdapter = pAdapter;
        TRACE( TL_I, TM_Cm, ( "New TCB =$%p", pTunnel ) );
        WPLOG( LL_I, LM_Cm, ( "New TCB =$%p", pTunnel ) );
    }

    return pTunnel;
}


VOID
DereferenceAf(
    IN ADAPTERCB* pAdapter )

    // Removes a reference from the address family of adapter control block
    // 'pAdapter', and when frees the block when the last reference is
    // removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pAdapter->lAfRef );

    TRACE( TL_N, TM_Ref, ( "DerefAf to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        // Tell NDIS it's close is complete.
        //
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseAfComp" ) );
        NdisMCmCloseAddressFamilyComplete(
            NDIS_STATUS_SUCCESS, pAdapter->NdisAfHandle );
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseAfComp done" ) );

        // Remove the reference for the NdisAfHandle.
        //
        InterlockedExchangePointer( &pAdapter->NdisAfHandle, NULL );
        DereferenceAdapter( pAdapter );
    }
}


VOID
DereferenceCall(
    IN VCCB* pVc )

    // Removes a reference from the call active on 'pVc', invoking call clean
    // up when the value reaches zero.
    //
{
    LONG lRef;
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pLink;

    pAdapter = pVc->pAdapter;

    NdisAcquireSpinLock( &pVc->lockCall );
    {
        lRef = --pVc->lCallRef;
        TRACE( TL_N, TM_Ref, ( "DerefC to %d", pVc->lCallRef ) );
    }
    NdisReleaseSpinLock( &pVc->lockCall );

    if (lRef == 0)
    {
        InactiveCallCleanUp( pVc );
    }
}


VOID
DereferenceSap(
    IN ADAPTERCB* pAdapter )

    // Removes a reference from the SAP active on 'pAdapter', invoking
    // Deregiter SAP completion handling when the value reaches zero.
    //
{
    LONG lRef;
    NDIS_STATUS status;

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        lRef = --pAdapter->lSapRef;
        TRACE( TL_N, TM_Ref, ( "DerefSap to %d", pAdapter->lSapRef ) );
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (lRef == 0)
    {
        status = ScheduleWork( pAdapter, DeregisterSapPassive, pAdapter );
    }
}


LONG
DereferenceTunnel(
    IN TUNNELCB* pTunnel )

    // Dereference the tunnel control block 'pTunnel'.  If no longer
    // referenced, unlink, undo any TDIX reference, and free the tunnel
    // control block.
    //
    // This routine will not try to acquire 'lockT' or any 'lockV'.
    //
    // Returns the reference count after the dereference.
    //
{
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pLink;
    LONG lRef;

    pAdapter = pTunnel->pAdapter;

    NdisAcquireSpinLock( &pAdapter->lockTunnels );
    {
        lRef = --(pTunnel->lRef);
        TRACE( TL_N, TM_Ref, ( "DerefTcb to %d", lRef ) );
        ASSERT( lRef >= 0 );

        if (lRef == 0)
        {
            if (!(ReadFlags( &pTunnel->ulFlags )
                    & (TCBF_PeerInitiated | TCBF_Closing)))
            {
                // We initiated this tunnel and all it's calls have terminated
                // gracefully.  Initiate a graceful tunnel closing exchange.
                // We'll wind up back here with TCBF_Closing set.
                //
                ReferenceTunnel( pTunnel, TRUE );
                ScheduleTunnelWork(
                    pTunnel, NULL, FsmCloseTunnel,
                    (ULONG_PTR )TRESULT_General,
                    (ULONG_PTR )GERR_None,
                    0, 0, TRUE, FALSE );
            }
            else if (pTunnel->linkTunnels.Flink != &pTunnel->linkTunnels)
            {
                // The graceful closing exchange has completed or none is
                // indicated.  Time to stop all activity on the tunnel.
                //
                // Remove the tunnel from the adapter's list of active
                // tunnels.  Initialize the list link so it won't be done
                // again following the APCed TDIX clean up below.  Since there
                // are no VC references on the tunnel, no further receive path
                // events will touch this control block.
                //
                RemoveEntryList( &pTunnel->linkTunnels );
                InitializeListHead( &pTunnel->linkTunnels );

                if (ReadFlags( &pTunnel->ulFlags ) & TCBF_HostRouteAdded)
                {
                    // Undo the host route we added.
                    //
                    ReferenceTunnel( pTunnel, TRUE );
                    ScheduleTunnelWork(
                        pTunnel, NULL, DeleteHostRoute,
                        0, 0, 0, 0, TRUE, FALSE );
                }

                if (ReadFlags( &pTunnel->ulFlags ) & TCBF_TdixReferenced)
                {
                    // Undo our TDI extension context reference.
                    //
                    ReferenceTunnel( pTunnel, TRUE );
                    ScheduleTunnelWork(
                        pTunnel, NULL, CloseTdix,
                        0, 0, 0, 0, TRUE, FALSE );
                }
            }

            lRef = pTunnel->lRef;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockTunnels );

    if (lRef > 0)
    {
        return lRef;
    }

    TRACE( TL_N, TM_Res, ( "Freeing TCB..." ) );

    // Stop the timer queue, which causes a TE_Terminate event for any timers
    // still running.
    //
    TimerQTerminate(
        pTunnel->pTimerQ, TunnelTqTerminateComplete, pAdapter );

    // No references and all PASSIVE IRQL termination completed.  Finish
    // cleaning up the tunnel control block.
    //
    ASSERT( !pTunnel->pTqiHello );
    ASSERT( IsListEmpty( &pTunnel->listVcs ) );
    ASSERT( IsListEmpty( &pTunnel->listRequestingVcs ) );
    ASSERT( IsListEmpty( &pTunnel->listCompletingVcs ) );
    ASSERT( IsListEmpty( &pTunnel->listWork ) );
    ASSERT( IsListEmpty( &pTunnel->listSendsOut ) );
    ASSERT( IsListEmpty( &pTunnel->listOutOfOrder ) );

    WPLOG( LL_M, LM_Res, ( "Free TUNNEL %p to %!IPADDR!, Tid %d, Peer's Tid %d ", 
        pTunnel, pTunnel->address.ulIpAddress, pTunnel->usTunnelId, pTunnel->usAssignedTunnelId ) );
                            
    // Free the tunnel control block.
    //
    pTunnel->ulTag = MTAG_FREED;
    FREE_TUNNELCB( pAdapter, pTunnel );

    TRACE( TL_I, TM_Res, ( "TCB freed $%p", pTunnel ) );
    DereferenceAdapter( pAdapter );
    return 0;
}


VOID
DereferenceVc(
    IN VCCB* pVc )

    // Removes a reference to the VC control block 'pVc', and when frees the
    // block when the last reference is removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pVc->lRef );

    TRACE( TL_N, TM_Ref, ( "DerefV to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        ADAPTERCB* pAdapter;

        pAdapter = pVc->pAdapter;

        // Can make these assumptions because NDIS will not call the delete-VC
        // handler while the VC is active.  All the nasty VC clean up occurs
        // before the VC is deactivated and the call closed.
        //
        ASSERT( IsListEmpty( &pVc->listSendsOut ) );
        ASSERT( IsListEmpty( &pVc->listOutOfOrder ) );
        ASSERT( !pVc->pTqiDelayedAck );

        ASSERT( pVc->ulTag == MTAG_VCCB );
        pVc->ulTag = MTAG_FREED;

        FREE_VCCB( pAdapter, pVc );
        DereferenceAdapter( pAdapter );
        TRACE( TL_I, TM_Mp, ( "VCB freed $%p", pVc ) );
    }
}


VOID
InactiveCallCleanUp(
    IN VCCB* pVc )

    // Cleans up a deactivated call.  To clean up a call that might be active,
    // use CallCleanUp instead.  Returns the VC to "just created" state, in
    // case client decides to make another call without deleting the VC.
    //
{
    NDIS_STATUS status;
    ULONG ulFlags;
    BOOLEAN fVcCreated;
    ADAPTERCB* pAdapter;
    TUNNELCB* pTunnel;
    BOOLEAN fForceGarbageCollect;

    TRACE( TL_I, TM_Cm, ( "InactiveCallCleanUp(pV=$%p)", pVc ) );

    pAdapter = pVc->pAdapter;

    // Release any call parameter allocations and the call-ID slot, if any.
    //
    CallSetupComplete( pVc );
    fForceGarbageCollect = ReleaseCallIdSlot( pVc );

    // Disassociate the VC from the tunnel.  It is possible the no tunnel is
    // associated, though only if short of memory.
    //
    pTunnel = pVc->pTunnel;
    if (!pTunnel)
    {
        TRACE( TL_A, TM_Cm, ( "Inactive VC w/o tunnel" ) );
        return;
    }

    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        RemoveEntryList( &pVc->linkRequestingVcs );
        InitializeListHead( &pVc->linkRequestingVcs );

        NdisAcquireSpinLock( &pTunnel->lockVcs );
        {
            pVc->pTunnel = NULL;
            RemoveEntryList( &pVc->linkVcs );
            InitializeListHead( &pVc->linkVcs );
        }
        NdisReleaseSpinLock( &pTunnel->lockVcs );
    }
    NdisReleaseSpinLock( &pTunnel->lockT );

    // Flush queues, timers, and statistics.
    //
    NdisAcquireSpinLock( &pVc->lockV );
    {
        LIST_ENTRY* pLink;

        ulFlags = ReadFlags( &pVc->ulFlags );
        ASSERT( !(ulFlags & VCBF_VcActivated) );

        // Terminate any delayed acknowledge timer.
        //
        if (pVc->pTqiDelayedAck)
        {
            TimerQTerminateItem( pTunnel->pTimerQ, pVc->pTqiDelayedAck );
            pVc->pTqiDelayedAck = NULL;
        }

        // Flush any payloads from the "out" list.
        //
        while (!IsListEmpty( &pVc->listSendsOut ))
        {
            PAYLOADSENT* pPs;

            pLink = RemoveHeadList( &pVc->listSendsOut );
            InitializeListHead( pLink );
            pPs = CONTAINING_RECORD( pLink, PAYLOADSENT, linkSendsOut );

            TRACE( TL_I, TM_Cm, ( "Flush pPs=$%p", pPs ) );

            // Terminate the timer.  Doesn't matter if the terminate fails as
            // the expire handler will fail to get a call reference and do
            // nothing.
            //
            ASSERT( pPs->pTqiSendTimeout );
            TimerQTerminateItem( pTunnel->pTimerQ, pPs->pTqiSendTimeout );

            // Remove the context reference for linkage in the "out" queue.
            //
            pPs->status = NDIS_STATUS_FAILURE;
            DereferencePayloadSent( pPs );
        }

        // Discard any out-of-order packets.
        //
        while (!IsListEmpty( &pVc->listOutOfOrder ))
        {
            PAYLOADRECEIVED* pPr;

            pLink = RemoveHeadList( &pVc->listOutOfOrder );
            InitializeListHead( pLink );
            pPr = CONTAINING_RECORD(
                pLink, PAYLOADRECEIVED, linkOutOfOrder );

            TRACE( TL_I, TM_Cm, ( "Flush pPr=$%p", pPr ) );

            FreeBufferToPool(
                &pAdapter->poolFrameBuffers, pPr->pBuffer, TRUE );
            FREE_PAYLOADRECEIVED( pAdapter, pPr );
        }

        // Update the global statistics by adding in the values tabulated for
        // this call.  Also prints the statistics in some trace modes.
        //
        UpdateGlobalCallStats( pVc );
    }
    NdisReleaseSpinLock( &pVc->lockV );

    // Dereference the tunnel.  Careful, this makes 'pTunnel' invalid from
    // this point forward.
    //
    DereferenceTunnel( pTunnel );

    // Return the VC to "just created" state.
    //
    pVc->usAssignedCallId = 0;
    pVc->state = CS_Idle;
    ClearFlags( &pVc->ulFlags, 0xFFFFFFFF );
    pVc->usResult = 0;
    pVc->usError = 0;
    pVc->status = NDIS_STATUS_SUCCESS;
    pVc->ulConnectBps = 0;
    pVc->usNs = 0;
    pVc->ulMaxSendWindow = 0;
    pVc->ulAcksSinceSendTimeout = 0;
    pVc->lDeviationMs = 0;
    pVc->usNr = 0;
    NdisZeroMemory( &pVc->stats, sizeof(pVc->stats) );

    pVc->ulRoundTripMs = pAdapter->ulInitialSendTimeoutMs;
    pVc->ulSendTimeoutMs = pVc->ulRoundTripMs;

    pVc->ulSendWindow = pAdapter->info.MaxSendWindow >> 1;
    if (pVc->ulSendWindow == 0)
    {
        pVc->ulSendWindow = 1;
    }

    if (ulFlags & VCBF_ClientCloseCompletion)
    {
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseCallComp(OK)" ) );
        NdisMCmCloseCallComplete(
            NDIS_STATUS_SUCCESS, pVc->NdisVcHandle, NULL );
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseCallComp done" ) );

        // Careful, if this was a client created VC, client may have deleted
        // it, so 'pVc' must not be referenced hereafter in that case.
        //
    }

    // When peer initiates the call, we create the VC and so delete it
    // here.  Otherwise, client created it and we leave it to him to
    // delete it when he's ready.
    //
    if (ulFlags & VCBF_VcCreated)
    {
        NDIS_STATUS retStatus;

        TRACE( TL_I, TM_Recv, ( "NdisMCmDelVc" ) );
        retStatus = NdisMCmDeleteVc( pVc->NdisVcHandle );
        TRACE( TL_I, TM_Recv, ( "NdisMCmDelVc=$%x", retStatus ) );
        ASSERT( retStatus == NDIS_STATUS_SUCCESS );
        LcmCmDeleteVc( pVc );

        // Careful, 'pVc' has been deleted and must not be referenced
        // hereafter.
        //
    }

    // Create garbage collection events on all the pools if it was determined
    // above to be an appropriate time to do so, i.e. we just deactivated the
    // last active VC.
    //
    if (fForceGarbageCollect)
    {
        CollectBufferPoolGarbage( &pAdapter->poolFrameBuffers );
        CollectBufferPoolGarbage( &pAdapter->poolHeaderBuffers );
        CollectPacketPoolGarbage( &pAdapter->poolPackets );
    }
}


VOID
LockIcs(
    IN VCCB* pVc,
    IN BOOLEAN fGrace )

    // Lock the 'pVc->pInCallSetup' pointer.  If 'fGrace' is set, the "grace
    // period" reference is locked, and if not the "alloc" reference is
    // locked.  See also UnlockIcs.
    //
{
    SetFlags( &pVc->ulFlags, (fGrace) ? VCBF_IcsGrace : VCBF_IcsAlloc );
}


NDIS_STATUS
QueryCmInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded )

    // Handle Call Manager QueryInformation requests.  Arguments are as for
    // the standard NDIS 'MiniportQueryInformation' handler except this
    // routine does not count on being serialized with respect to other
    // requests.
    //
{
    #define L2TP_MaxLineName 64

    typedef struct
    L2TP_CO_TAPI_LINE_CAPS
    {
        CO_TAPI_LINE_CAPS caps;
        WCHAR achLineName[ L2TP_MaxLineName + 1 ];
    }
    L2TP_CO_TAPI_LINE_CAPS;

    NDIS_STATUS status;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;
    ULONG extension;
    ULONG ulPortIndex;
    CO_TAPI_CM_CAPS cmcaps;
    L2TP_CO_TAPI_LINE_CAPS l2tpcaps;
    CO_TAPI_ADDRESS_CAPS addrcaps;
    CO_TAPI_CALL_DIAGNOSTICS diags;

    status = NDIS_STATUS_SUCCESS;

    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof(ulInfo);

    switch (Oid)
    {
        case OID_CO_TAPI_CM_CAPS:
        {
            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_CM_CAPS)" ) );

            NdisZeroMemory( &cmcaps, sizeof(cmcaps) );

            // The LINE and ADDRESS CAPS OIDs will be requested after this
            // one.
            //
            cmcaps.ulCoTapiVersion = CO_TAPI_VERSION;
            cmcaps.ulNumLines = 1;
            // caps.ulFlags = 0;
            pInfo = &cmcaps;
            ulInfoLen = sizeof(cmcaps);
            break;
        }

        case OID_CO_TAPI_LINE_CAPS:
        {
            ULONG ulLineNameLen;
            WCHAR* pszLineName;
            CO_TAPI_LINE_CAPS* pInCaps;
            LINE_DEV_CAPS* pldc;

            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_LINE_CAPS)" ) );

            if (InformationBufferLength < sizeof(L2TP_CO_TAPI_LINE_CAPS))
            {
                status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            ASSERT( InformationBuffer );
            pInCaps = (CO_TAPI_LINE_CAPS* )InformationBuffer;

            NdisZeroMemory( &l2tpcaps, sizeof(l2tpcaps) );
            pldc = &l2tpcaps.caps.LineDevCaps;

            l2tpcaps.caps.ulLineID = pInCaps->ulLineID;

            pldc->ulTotalSize = pInCaps->LineDevCaps.ulTotalSize;
            pldc->ulNeededSize =
                (ULONG )((CHAR* )(&l2tpcaps + 1)
                       - (CHAR* )(&l2tpcaps.caps.LineDevCaps));
            pldc->ulUsedSize = pldc->ulNeededSize;

            // pldc->ulProviderInfoSize = 0;
            // pldc->ulProviderInfoOffset = 0;
            // pldc->ulSwitchInfoSize = 0;
            // pldc->ulSwitchInfoOffset = 0;

            pldc->ulPermanentLineID = l2tpcaps.caps.ulLineID;

            // Pass the DriverDesc from the registry as the line name.  TAPI
            // requires that this be a localizable string.
            //
            if (pAdapter->pszDriverDesc)
            {
                pszLineName = pAdapter->pszDriverDesc;
            }
            else
            {
                pszLineName = L"L2TP";
            }

            ulLineNameLen = StrLenW( pszLineName ) + 1;
            if (ulLineNameLen > L2TP_MaxLineName)
            {
                ulLineNameLen = L2TP_MaxLineName;
            }

            NdisMoveMemory(
                l2tpcaps.achLineName, pszLineName,
                ulLineNameLen * sizeof(WCHAR) );
            l2tpcaps.achLineName[ ulLineNameLen ] = L'\0';
            pldc->ulLineNameSize = ulLineNameLen * sizeof(WCHAR);
            pldc->ulLineNameOffset = (ULONG )
                ((CHAR* )l2tpcaps.achLineName - (CHAR* )pldc);
            pldc->ulStringFormat = STRINGFORMAT_UNICODE;

            // pldc->ulAddressModes = 0;

            pldc->ulNumAddresses = 1;
            pldc->ulBearerModes = LINEBEARERMODE_DATA;
            pldc->ulMaxRate = L2TP_LanBps;
            pldc->ulMediaModes = LINEMEDIAMODE_UNKNOWN | LINEMEDIAMODE_DIGITALDATA;

            // pldc->ulGenerateToneModes = 0;
            // pldc->ulGenerateToneMaxNumFreq = 0;
            // pldc->ulGenerateDigitModes = 0;
            // pldc->ulMonitorToneMaxNumFreq = 0;
            // pldc->ulMonitorToneMaxNumEntries = 0;
            // pldc->ulMonitorDigitModes = 0;
            // pldc->ulGatherDigitsMinTimeout = 0;
            // pldc->ulGatherDigitsMaxTimeout = 0;
            // pldc->ulMedCtlDigitMaxListSize = 0;
            // pldc->ulMedCtlMediaMaxListSize = 0;
            // pldc->ulMedCtlToneMaxListSize = 0;
            // pldc->ulMedCtlCallStateMaxListSize = 0;
            // pldc->ulDevCapFlags = 0;

            pldc->ulMaxNumActiveCalls = 1;

            // pldc->ulAnswerMode = 0;
            // pldc->ulRingModes = 0;
            // pldc->ulLineStates = 0;
            // pldc->ulUUIAcceptSize = 0;
            // pldc->ulUUIAnswerSize = 0;
            // pldc->ulUUIMakeCallSize = 0;
            // pldc->ulUUIDropSize = 0;
            // pldc->ulUUISendUserUserInfoSize = 0;
            // pldc->ulUUICallInfoSize = 0;
            // pldc->MinDialParams = 0;
            // pldc->MaxDialParams = 0;
            // pldc->DefaultDialParams = 0;
            // pldc->ulNumTerminals = 0;
            // pldc->ulTerminalCapsSize = 0;
            // pldc->ulTerminalCapsOffset = 0;
            // pldc->ulTerminalTextEntrySize = 0;
            // pldc->ulTerminalTextSize = 0;
            // pldc->ulTerminalTextOffset = 0;
            // pldc->ulDevSpecificSize = 0;
            // pldc->ulDevSpecificOffset = 0;
            // pldc->ulLineFeatures;
            // pldc->ulSettableDevStatus;
            // pldc->ulDeviceClassesSize;
            // pldc->ulDeviceClassesOffset;
            // pldc->PermanentLineGuid;

            pldc->ulAddressTypes = LINEADDRESSTYPE_IPADDRESS;

            // pldc->ProtocolGuid;
            // pldc->ulAvailableTracking;

            pInfo = &l2tpcaps;
            ulInfoLen = sizeof(l2tpcaps);
            break;
        }

        case OID_CO_TAPI_ADDRESS_CAPS:
        {
            CO_TAPI_ADDRESS_CAPS* pInCaps;
            LINE_ADDRESS_CAPS* plac;

            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_ADDRESS_CAPS)" ) );

            if (InformationBufferLength < sizeof(CO_TAPI_ADDRESS_CAPS))
            {
                status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            ASSERT( InformationBuffer );
            pInCaps = (CO_TAPI_ADDRESS_CAPS* )InformationBuffer;

            NdisZeroMemory( &addrcaps, sizeof(addrcaps) );

            addrcaps.ulLineID = pInCaps->ulLineID;
            addrcaps.ulAddressID = pInCaps->ulAddressID;

            plac = &addrcaps.LineAddressCaps;

            plac->ulTotalSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulNeededSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulUsedSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulLineDeviceID = addrcaps.ulLineID;
            // plac->ulAddressSize = 0;
            // plac->ulAddressOffset = 0;
            // plac->ulDevSpecificSize = 0;
            // plac->ulDevSpecificOffset = 0;
            // plac->ulAddressSharing = 0;
            // plac->ulAddressStates = 0;
            // plac->ulCallInfoStates = 0;
            // plac->ulCallerIDFlags = 0;
            // plac->ulCalledIDFlags = 0;
            // plac->ulConnectedIDFlags = 0;
            // plac->ulRedirectionIDFlags = 0;
            // plac->ulRedirectingIDFlags = 0;
            // plac->ulCallStates = 0;
            // plac->ulDialToneModes = 0;
            // plac->ulBusyModes = 0;
            // plac->ulSpecialInfo = 0;
            // plac->ulDisconnectModes = 0;

            plac->ulMaxNumActiveCalls = (ULONG )pAdapter->usMaxVcs;

            // plac->ulMaxNumOnHoldCalls = 0;
            // plac->ulMaxNumOnHoldPendingCalls = 0;
            // plac->ulMaxNumConference = 0;
            // plac->ulMaxNumTransConf = 0;
            // plac->ulAddrCapFlags = 0;
            // plac->ulCallFeatures = 0;
            // plac->ulRemoveFromConfCaps = 0;
            // plac->ulRemoveFromConfState = 0;
            // plac->ulTransferModes = 0;
            // plac->ulParkModes = 0;
            // plac->ulForwardModes = 0;
            // plac->ulMaxForwardEntries = 0;
            // plac->ulMaxSpecificEntries = 0;
            // plac->ulMinFwdNumRings = 0;
            // plac->ulMaxFwdNumRings = 0;
            // plac->ulMaxCallCompletions = 0;
            // plac->ulCallCompletionConds = 0;
            // plac->ulCallCompletionModes = 0;
            // plac->ulNumCompletionMessages = 0;
            // plac->ulCompletionMsgTextEntrySize = 0;
            // plac->ulCompletionMsgTextSize = 0;
            // plac->ulCompletionMsgTextOffset = 0;

            pInfo = &addrcaps;
            ulInfoLen = sizeof(addrcaps);
            break;
        }

        case OID_CO_TAPI_GET_CALL_DIAGNOSTICS:
        {
            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_GET_CALL_DIAGS)" ) );

            if (!pVc)
            {
                status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            NdisZeroMemory( &diags, sizeof(diags) );

            diags.ulOrigin =
                (ReadFlags( &pVc->ulFlags ) & VCBF_PeerInitiatedCall)
                    ? LINECALLORIGIN_EXTERNAL
                    : LINECALLORIGIN_OUTBOUND;
            diags.ulReason = LINECALLREASON_DIRECT;

            pInfo = &diags;
            ulInfoLen = sizeof(diags);
            break;
        }

        default:
        {
            TRACE( TL_A, TM_Cm, ( "QCm-OID=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        // Copy the found result to caller's buffer.
        //
        if (ulInfoLen > 0)
        {
            NdisMoveMemory( InformationBuffer, pInfo, ulInfoLen );
            DUMPDW( TL_N, TM_Mp, pInfo, ulInfoLen );
        }

        *BytesNeeded = *BytesWritten = ulInfoLen;
    }

    return status;
}


VOID
ReferenceAf(
    IN ADAPTERCB* pAdapter )

    // Adds areference to the address family of adapter block, 'pAdapter'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pAdapter->lAfRef );

    TRACE( TL_N, TM_Ref, ( "RefAf to %d", lRef ) );
}


BOOLEAN
ReferenceCall(
    IN VCCB* pVc )

    // Returns true if a reference is added to the active call on VC control
    // block, 'pVc', or false if no reference was added because no call is
    // active.
    //
{
    BOOLEAN fActive;

    NdisAcquireSpinLock( &pVc->lockCall );
    {
        if (ReadFlags( &pVc->ulFlags ) & VCBF_VcActivated)
        {
            fActive = TRUE;
            ++pVc->lCallRef;
            TRACE( TL_N, TM_Ref, ( "RefC to %d", pVc->lCallRef ) );
        }
        else
        {
            TRACE( TL_N, TM_Ref, ( "RefC denied" ) );
            fActive = FALSE;
        }
    }
    NdisReleaseSpinLock( &pVc->lockCall );

    return fActive;
}


BOOLEAN
ReferenceSap(
    IN ADAPTERCB* pAdapter )

    // Returns true if a reference is added to the active SAP on adapter
    // 'pAdapter', or false if no reference was added because no SAP is
    // active.
    //
{
    BOOLEAN fActive;

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        if (ReadFlags( &pAdapter->ulFlags ) & ACBF_SapActive)
        {
            fActive = TRUE;
            ++pAdapter->lSapRef;
            TRACE( TL_N, TM_Ref, ( "RefSap to %d", pAdapter->lSapRef ) );
        }
        else
        {
            TRACE( TL_N, TM_Ref, ( "RefSap denied" ) );
            fActive = FALSE;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    return fActive;
}


LONG
ReferenceTunnel(
    IN TUNNELCB* pTunnel,
    IN BOOLEAN fHaveLockTunnels )

    // Reference the tunnel control block 'pTunnel'.  'FHaveLockTunnels' is
    // set when the caller holds 'ADAPTERCB.lockTunnels'.
    //
    // Returns the reference count after the reference.
    //
{
    LONG lRef;
    ADAPTERCB* pAdapter;

    if (!fHaveLockTunnels)
    {
        pAdapter = pTunnel->pAdapter;
        NdisAcquireSpinLock( &pAdapter->lockTunnels );
    }

    lRef = ++(pTunnel->lRef);
    TRACE( TL_N, TM_Ref, ( "RefT to %d", lRef ) );

    if (!fHaveLockTunnels)
    {
        NdisReleaseSpinLock( &pAdapter->lockTunnels );
    }

    return lRef;
}


VOID
ReferenceVc(
    IN VCCB* pVc )

    // Adds a reference to the VC control block 'pVc'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pVc->lRef );

    TRACE( TL_N, TM_Ref, ( "RefV to %d", lRef ) );
    TRACE( TL_N, TM_Ref, ( "pVc = %p, RefV to %d", pVc, lRef ) );
}


BOOLEAN
ReleaseCallIdSlot(
    IN VCCB* pVc )

    // Releases 'pVc's reserved Call-ID slot in the adapter's VC table.
    //
    // Returns true if a release occurs and results in all slots being
    // available, false otherwise.
    //
{
    ADAPTERCB* pAdapter;
    USHORT usCallId;
    BOOLEAN fAllSlotsAvailable;

    pAdapter = pVc->pAdapter;
    usCallId = pVc->usCallId;
    pVc->usCallId = 0;
    fAllSlotsAvailable = FALSE;

    if (usCallId > 0 && usCallId <= pAdapter->usMaxVcs)
    {
        NdisAcquireSpinLock( &pAdapter->lockVcs );
        {
            pAdapter->ppVcs[ usCallId - 1 ] = NULL;
            ++(pAdapter->lAvailableVcSlots);

            if (pAdapter->lAvailableVcSlots >= (LONG )pAdapter->usMaxVcs)
            {
                fAllSlotsAvailable = TRUE;
            }
        }
        NdisReleaseSpinLock( &pAdapter->lockVcs );
    }

    return fAllSlotsAvailable;
}


NDIS_STATUS
ReserveCallIdSlot(
    IN VCCB* pVc )

    // Reserves a Call-ID slot for 'pVc' in the adapter's table.
    //
    // Returns NDIS_STATUS_SUCCESS if successful, or an error code.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB** ppVc;
    USHORT i;

    pAdapter = pVc->pAdapter;

    NdisAcquireSpinLock( &pAdapter->lockVcs );
    {
        // At this point, we have a VC for the received call request that's
        // been successfully activated and dispatched to the client.  Reserve
        // a Call-ID in the adapter's look-up table.
        //
        if (pAdapter->lAvailableVcSlots > 0)
        {
            for (i = 0, ppVc = pAdapter->ppVcs;
                 i < pAdapter->usMaxVcs;
                 ++i, ++ppVc)
            {
                if (!*ppVc)
                {
                    // The -1 reserves the ID.  If/when the call negotiation
                    // completes successfully it will be changed to the
                    // address of the VCCB.  Call-IDs are 1-based because L2TP
                    // reserves Call-ID 0 to mean the tunnel itself.
                    //
                    *ppVc = (VCCB* )-1;
                    pVc->usCallId = i + 1;
                    break;
                }
            }

            ASSERT( i < pAdapter->usMaxVcs );
            --(pAdapter->lAvailableVcSlots);
            status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            // No Call-ID slots available.  This means the client accepted the
            // VC even though it put us over our configured limit.  Something
            // is mismatched in the configuration.  Assign a Call-ID above the
            // table size for use only in terminating the call gracefully.
            //
            TRACE( TL_N, TM_Misc, ( "No Call-ID slots?" ) );
            pVc->usCallId = GetNextTerminationCallId( pAdapter );
            status = NDIS_STATUS_NOT_ACCEPTED;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockVcs );

    return status;
}


TUNNELCB*
SetupTunnel(
    IN ADAPTERCB* pAdapter,
    IN ULONG ulIpAddress,
    IN USHORT usUdpPort,
    IN USHORT usAssignedTunnelId,
    IN BOOLEAN fExclusive )

    // Sets up a tunnel to remote peer with IP address 'ulIpAddress' and
    // prepares it for sending or receiving messages.  'PAdapter' is the
    // owning adapter control block.  'UlIpAddress' is the remote peer's IP
    // address in network byte-order.  'UsAssignedTunnelId', if non-0,
    // indicates the assigned Tunnel-ID that must match in addition to the IP
    // address.  If 'FExclusive' is clear an existing tunnel to the peer is
    // acceptable.  If set, a new tunnel is created even if a matching one
    // already exists.
    //
    // Returns the address of the tunnel control block if successful, or NULL
    // if not.  If successful the block is already linked into the adapters
    // list of active tunnels and referenced, i.e. DereferenceTunnel must be
    // called during clean-up.
    //
{
    TUNNELCB* pTunnel;

    TRACE( TL_V, TM_Misc, ( "SetupTunnel" ) );

    NdisAcquireSpinLock( &pAdapter->lockTunnels );
    {
        // If an existing tunnel would be acceptable, find the first existing
        // tunnel with peer's IP address and, if non-0, assigned Tunnel-ID.
        // Typically, none will be found and we go on to create a new one
        // anyway.
        //
        pTunnel = (fExclusive)
            ? NULL
            : TunnelCbFromIpAddressAndAssignedTunnelId(
                  pAdapter, ulIpAddress, usUdpPort, usAssignedTunnelId );

        if (!pTunnel)
        {
            pTunnel = CreateTunnelCb( pAdapter );
            if (!pTunnel)
            {
                WPLOG( LL_A, LM_Res, ( "Failed to allocate TCB!" ) );
                NdisReleaseSpinLock( &pAdapter->lockTunnels );
                return NULL;
            }
            
            WPLOG( LL_M, LM_Cm, ( "New TUNNEL %p to %!IPADDR!", pTunnel, ulIpAddress) );

            // Associate peer's IP address with the tunnel.
            //
            pTunnel->address.ulIpAddress = ulIpAddress;

            // Link the block into the adapter's list of active tunnels.
            //
            InsertHeadList(
                &pAdapter->listTunnels, &pTunnel->linkTunnels );
        }
        else
        {
            TRACE( TL_A, TM_Cm, ( "Existing Tunnel %p", pTunnel ) );
            WPLOG( LL_M, LM_Cm, ( "Existing TUNNEL %p to %!IPADDR!", pTunnel, ulIpAddress) );
        }

        // Reference the tunnel control block.  Hereafter, clean-up must
        // include a call to DereferenceTunnel.
        //
        ReferenceTunnel( pTunnel, TRUE );
    }
    NdisReleaseSpinLock( &pAdapter->lockTunnels );

    return pTunnel;
}


VOID
SetupVcAsynchronously(
    IN TUNNELCB* pTunnel,
    IN ULONG ulIpAddress,
    IN CHAR* pBuffer,
    IN CONTROLMSGINFO* pControl )

    // Called by ReceiveControl to set up a VC for the incoming call described
    // in 'pInfo', 'pControl', and 'pBuffer' using the necessary asynchronous
    // CoNdis calls.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    INCALLSETUP* pIcs;
    NDIS_HANDLE NdisVcHandle;
    ULONG ulMask;
    BOOLEAN fTunnelClosing;
    BOOLEAN fCallActive;

    TRACE( TL_V, TM_Misc, ( "SetupVcAsync" ) );

    pAdapter = pTunnel->pAdapter;

    // Call our own CreateVc handler directly to allocate and initialize the
    // incoming call's VC.
    //
    status = LcmCmCreateVc( pAdapter, NULL, &pVc );
    if (status != NDIS_STATUS_SUCCESS)
    {
        ScheduleTunnelWork(
            pTunnel, NULL, FsmCloseTunnel,
            (ULONG_PTR )TRESULT_GeneralWithError,
            (ULONG_PTR )GERR_NoResources,
            0, 0, FALSE, FALSE );
        FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        return;
    }

    // Allocate an "incoming call setup" context and initialize it from the
    // receive buffer information arguments.
    //
    pIcs = ALLOC_INCALLSETUP( pAdapter );
    if (!pIcs)
    {
        WPLOG( LL_A, LM_Res, ( "Failed to allocate INCALLSETUP!" ) );
        LcmCmDeleteVc( pVc );
        ScheduleTunnelWork(
            pTunnel, NULL, FsmCloseTunnel,
            (ULONG_PTR )TRESULT_GeneralWithError,
            (ULONG_PTR )GERR_NoResources,
            0, 0, FALSE, FALSE );
        FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        return;
    }

    pIcs->pBuffer = pBuffer;
    NdisMoveMemory( &pIcs->control, pControl, sizeof(pIcs->control) );

    BuildCallParametersShell(
        pAdapter, ulIpAddress,
        sizeof(pIcs->achCallParams), pIcs->achCallParams,
        &pVc->pTiParams, &pVc->pTcInfo, &pVc->pLcParams );

    LockIcs( pVc, FALSE );
    pVc->pInCall = pIcs;

    // Default is success with errors filled in if they occur.
    //
    pVc->usResult = 0;
    pVc->usError = GERR_None;

    // Mark the call as initiated by the peer so we know which notifications
    // to give when the result is known.
    //
    ulMask = (VCBF_PeerInitiatedCall | VCBF_PeerOpenPending);
    if (*(pControl->pusMsgType) == CMT_ICRQ)
    {
        ulMask |= VCBF_IncomingFsm;
    }
    SetFlags( &pVc->ulFlags, ulMask );

    // Add a tunnel reference for this call on this VC, set the back pointer
    // to the owning tunnel, and link the VC into the tunnel's list of
    // associated VCs.
    //
    ReferenceTunnel( pTunnel, FALSE );
    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        if (ReadFlags( &pTunnel->ulFlags ) & TCBF_Closing)
        {
            // This is unlikely because SetupTunnel only finds non-closing
            // tunnels, but this check and linkage must occur atomically under
            // 'lockT'.  New VCs must not be linked onto closing tunnels.
            //
            fTunnelClosing = TRUE;
        }
        else
        {
            fTunnelClosing = FALSE;
            NdisAcquireSpinLock( &pTunnel->lockVcs );
            {
                pVc->pTunnel = pTunnel;
                InsertTailList( &pTunnel->listVcs, &pVc->linkVcs );
            }
            NdisReleaseSpinLock( &pTunnel->lockVcs );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockT );

    if (fTunnelClosing)
    {
        CallSetupComplete( pVc );
        LcmCmDeleteVc( pVc );
        FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        DereferenceTunnel( pTunnel );
        return;
    }

    // Peer MUST provide a Call-ID to pass back in the L2TP header of call
    // control and payload packets.
    //
    if (!pControl->pusAssignedCallId || *(pControl->pusAssignedCallId) == 0)
    {
        TRACE( TL_A, TM_Misc, ( "No assigned CID?" ) );
        WPLOG( LL_A, LM_Misc, ( "Failure - Peer doesn't provide a Call-ID!" ) );
        pVc->usResult = CRESULT_GeneralWithError;
        pVc->usError = GERR_BadCallId;
        SetupVcComplete( pTunnel, pVc );
        return;
    }

    // Check if the request has a chance of succeeding before getting the
    // client involved.
    //
    if (!(ReadFlags( &pVc->ulFlags ) & VCBF_IncomingFsm))
    {
        // Fail requests to our LAC requiring asynchronous PPP framing or an
        // analog or digital WAN connection.  NDISWAN doesn't provide
        // asynchronous PPP framing, and we don't currently support non-LAN
        // WAN relays.
        //
        if (!pControl->pulFramingType
            || !(*(pControl->pulFramingType) & FBM_Sync))
        {
            TRACE( TL_A, TM_Misc, ( "Not sync framing type?" ) );
            WPLOG( LL_A, LM_Misc, ( "Failure - Not supported framing type!" ) );

            if (!(pAdapter->ulFlags & ACBF_IgnoreFramingMismatch))
            {
                pVc->usResult = CRESULT_NoFacilitiesPermanent;
                pVc->usError = GERR_None;
                SetupVcComplete( pTunnel, pVc );
                return;
            }
        }

        if (pControl->pulBearerType
            && *(pControl->pulBearerType) != 0)
        {
            TRACE( TL_A, TM_Misc, ( "Cannot do bearer type" ) );
            WPLOG( LL_A, LM_Misc, ( "Failure - Not supported bearer type!" ) );
            pVc->usResult = CRESULT_NoFacilitiesPermanent;
            pVc->usError = GERR_None;
            SetupVcComplete( pTunnel, pVc );
            return;
        }
    }

    // Tell NDIS to notify the client of the new VC and give us it's handle.
    //
    ASSERT( pAdapter->NdisAfHandle );
    TRACE( TL_I, TM_Cm, ( "NdisMCmCreateVc" ) );
    status = NdisMCmCreateVc(
        pAdapter->MiniportAdapterHandle,
        pAdapter->NdisAfHandle,
        pVc,
        &pVc->NdisVcHandle );

    if (status != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_I, TM_Cm, ( "NdisMCmCreateVc=$%x,h=$%p", status, pVc->NdisVcHandle ) );
        WPLOG( LL_A, LM_Cm, ( "NdisMCmCreateVc failed, pVc = %p, s= %08x!", pVc, status ) );
        pVc->usResult = CRESULT_GeneralWithError;
        pVc->usError = GERR_NoResources;
        SetupVcComplete( pTunnel, pVc );
        return;
    }
    SetFlags( &pVc->ulFlags, VCBF_VcCreated );

    // Tell NDIS the VC is active.
    //
    TRACE( TL_I, TM_Cm, ( "NdisMCmActivateVc" ) );
    status = NdisMCmActivateVc(
        pVc->NdisVcHandle, (PCO_CALL_PARAMETERS )pVc->pInCall->achCallParams );

    if (status != NDIS_STATUS_SUCCESS )
    {
        TRACE( TL_A, TM_Cm, ( "NdisMCmActivateVc=$%x", status ) );
        WPLOG( LL_A, LM_Cm, ( "NdisMCmActivateVc failed, pVc = %p, s= %08x", pVc, status ) );
        pVc->usResult = CRESULT_GeneralWithError;
        pVc->usError = GERR_NoResources;
        SetupVcComplete( pTunnel, pVc );
        return;
    }

    // Mark that the call is active, a state where both client and peer close
    // requests should be accepted.
    //
    SetFlags( &pVc->ulFlags,
        (VCBF_VcActivated
         | VCBF_CallClosableByClient
         | VCBF_CallClosableByPeer) );
    fCallActive = ReferenceCall( pVc );
    ASSERT( fCallActive );

    // Tell NDIS to tell the client about the call.  The dispatched flag is
    // set here rather in the completion because, according to JameelH, it is
    // valid to call NdisMCmDispatchIncomingCloseCall even if client pends on
    // the dispatch.  A reference on the SAP must be held during the operation
    // since it uses the NdisSapHandle.  The reference is released as soon as
    // the call returns.  A VC reference is taken to prevent the VC from being
    // deleted before the completion handler is called.  The VC reference is
    // removed by the completion handler.
    //
    if (!ReferenceSap( pAdapter ))
    {
        pVc->usResult = CRESULT_NoFacilitiesTemporary;
        pVc->usError = GERR_None;
        SetupVcComplete( pTunnel, pVc );
        return;
    }

    fCallActive = ReferenceCall( pVc );
    ReferenceVc( pVc );
    ASSERT( fCallActive );
    SetFlags( &pVc->ulFlags, VCBF_WaitInCallComplete );
    TRACE( TL_I, TM_Cm, ( "Call NdisMCmDispInCall" ) );
    WPLOG( LL_M, LM_Cm, ( "Incoming CALL %p on TUNNEL %p", pVc, pTunnel) );
    status = NdisMCmDispatchIncomingCall(
        pAdapter->NdisSapHandle,
        pVc->NdisVcHandle,
        (CO_CALL_PARAMETERS* )pVc->pInCall->achCallParams );
    TRACE( TL_I, TM_Cm, ( "NdisMCmDispInCall=$%x", status ) );

    DereferenceSap( pAdapter );

    if (status == NDIS_STATUS_SUCCESS
        || status == NDIS_STATUS_PENDING)
    {
        SetFlags( &pVc->ulFlags, VCBF_VcDispatched );
    }

    if (status != NDIS_STATUS_PENDING)
    {
        LcmCmIncomingCallComplete( status, pVc, NULL );
    }

    // Next stop is our LcmCmIncomingCallComplete handler which will call
    // SetupVcComplete with client's reported status.
    //
}


VOID
SetupVcComplete(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc )

    // Called when the asynchronous incoming call VC setup result is known.
    // 'PVc' is the non-NULL set up VC, with 'usResult' and 'usError' fields
    // indicating the status thus far.  'PTunnel' is the associated tunnel.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    BOOLEAN fCallerFreesBuffer;
    ULONG ulcpVcs;
    VCCB** ppVcs;

    TRACE( TL_V, TM_Misc, ( "SetupVcComp,pVc=%p,cid=%d,r=%d,e=%d",
        pVc, (ULONG )pVc->usCallId, (ULONG )pVc->usResult, (ULONG )pVc->usError ) );

    pAdapter = pVc->pAdapter;

    // Lock up 'pInCall' because as soon as the call is activated the call can
    // be torn down and 'pInCall' destroyed.  See also comments in UnlockIcs.
    //
    LockIcs( pVc, TRUE );
    {
        // OK, we're done trying to to set up the VC asynchronously.  A VCCB
        // and INCALLSETUP were successfully allocated, which is the minimum
        // required to be graceful with peer.  Reserve a Call-ID in the
        // adapter's look-up table.
        //
        status = ReserveCallIdSlot( pVc );
        if (status == NDIS_STATUS_SUCCESS)
        {
            ActivateCallIdSlot( pVc );
        }
        else
        {
            pVc->usResult = CRESULT_Busy;
            pVc->usError = GERR_None;
        }

        // Duplicate the tail of the receive path processing that would have
        // occurred if we'd not been forced to go asynchronous.
        //
        NdisAcquireSpinLock( &pTunnel->lockT );
        {
            fCallerFreesBuffer =
                ReceiveControlExpected(
                    pTunnel, pVc,
                    pVc->pInCall->pBuffer, &pVc->pInCall->control );

            CompleteVcs( pTunnel );
        }
        NdisReleaseSpinLock( &pTunnel->lockT );

        if (fCallerFreesBuffer)
        {
            FreeBufferToPool(
                &pVc->pAdapter->poolFrameBuffers,
                pVc->pInCall->pBuffer, TRUE );
        }
        DBG_else
        {
            ASSERT( FALSE );
        }
    }
    UnlockIcs( pVc, TRUE );
}


VOID
TunnelTqTerminateComplete(
    IN TIMERQ* pTimerQ,
    IN VOID* pContext )

    // TIMERQTERMINATECOMPLETE handler for 'TUNNELCB.pTimerQ'.
    //
{
    ADAPTERCB* pAdapter;

    pAdapter = (ADAPTERCB* )pContext;
    --pAdapter->ulTimers;
    FREE_TIMERQ( pAdapter, pTimerQ );
}


VOID
UnlockIcs(
    IN VCCB* pVc,
    IN BOOLEAN fGrace )

    // Unlock the 'pVc->pInCallSetup' pointer.  If 'fGrace' is set, the "grace
    // period" reference is unlocked, and if not the "alloc" reference is
    // unlocked.  If both references are gone, then do the actual cleanup.
    //
    // Note: Regular reference counts don't work well here because there are
    //       several possible causes of the "alloc" unlock and they are not
    //       necessarily mutually exclusive.  However, we need to prevent the
    //       'pInCall' pointer from being freed until the incoming call
    //       response has been sent out, which in turn requires knowledge of
    //       whether the "activate for receive" succeeded.
    //
{
    INCALLSETUP *pInCall = NULL;
    ADAPTERCB *pAdapter;
    
    ClearFlags( &pVc->ulFlags, (fGrace) ? VCBF_IcsGrace : VCBF_IcsAlloc );

    if (!(ReadFlags( &pVc->ulFlags ) & (VCBF_IcsGrace | VCBF_IcsAlloc)))
    {
        NdisAcquireSpinLock(&pVc->lockV);
        if(pVc->pInCall)
        {
            pInCall = pVc->pInCall;
            pAdapter = pVc->pAdapter;
            pVc->pInCall = NULL;
            pVc->pTmParams = NULL;
            pVc->pTcParams = NULL;
            pVc->pLcParams = NULL;
        }
        NdisReleaseSpinLock(&pVc->lockV);
        
        if(pInCall != NULL)
        {
            FREE_INCALLSETUP( pAdapter, pInCall );
        }
    }
    
#if 0
    if (!(ReadFlags( &pVc->ulFlags ) & (VCBF_IcsGrace | VCBF_IcsAlloc))
        && pVc->pInCall)
    {
        FREE_INCALLSETUP( pAdapter, pInCall );
        pVc->pInCall = NULL;
        pVc->pTmParams = NULL;
        pVc->pTcParams = NULL;
        pVc->pLcParams = NULL;
    }

#endif    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\ndproxy\kdext\pxext.c ===
#include "precomp.h"
#pragma hdrstop

PSTR pszExtName = "PXKD";

#include <stdexts.h>
#include <stdexts.c>

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\bpool.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.h
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _BPOOL_H_
#define _BPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Buffer pool control block.  A buffer pool prevents fragmentation of the
// non-paged memory pool by allocating the memory for a group of buffers in a
// single contiguous block.  At user's option, the buffer pool routines may
// allocate a pool of NDIS_BUFFER buffer descriptors and associate each with
// the memory buffers sliced from the contiguous block.  This allows the
// buffer to be reused while the virtual->physical memory mapping is performed
// only once.  All necessary pool growth and shrinkage is handled internally.
//
typedef struct
_BUFFERPOOL
{
    // Size in bytes of an individual buffer in the pool.
    //
    ULONG ulBufferSize;

    // The optimal number of buffers to allocate in each buffer block.
    //
    ULONG ulBuffersPerBlock;

    // Maximum number of individual buffers that may be allocated in the
    // entire pool or 0 for unlimited.
    //
    ULONG ulMaxBuffers;

    // Current number of individual buffers allocated in the entire pool.
    //
    ULONG ulCurBuffers;

    // Garbage collection occurs after this many calls to FreeBufferToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Indicates an NDIS_BUFFER is to be associated with each individual
    // buffer in the pool.
    //
    BOOLEAN fAssociateNdisBuffer;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of BUFFERBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free BUFFERHEADs.  Each BUFFERHEAD in
    // the list is ready to go, i.e. it preceeds it's already allocated memory
    // buffer and, if appropriate, has an NDIS_BUFFER associated with it.
    // Access to the list is protected by 'lock' in this structure.
    // Interlocked push/pop is not used because (a) the list of blocks and the
    // list of buffers must lock each other and (b) double links are necessary
    // for garbage collection.
    //
    LIST_ENTRY listFreeBuffers;

    // This lock protects this structure and both the list of blocks and the
    // list of buffers.
    //
    NDIS_SPIN_LOCK lock;
}
BUFFERPOOL;


// Header of a single block of buffers from a buffer pool.  The BUFFERHEAD of
// the first buffer immediately follows.
//
typedef struct
_BUFFERBLOCKHEAD
{
    // Link to the prev/next buffer block header in the buffer pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_BUFFER descriptors associated with
    // this block, or NULL if none.  (Note: With the current NT implementation
    // of NDIS_BUFFER as MDL this is always NULL).
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the buffer pool.
    //
    BUFFERPOOL* pPool;

    // Number of individual buffers in this block.
    //
    ULONG ulBuffers;

    // Number of individual buffers in this block on the free list.
    //
    ULONG ulFreeBuffers;
}
BUFFERBLOCKHEAD;


// Header of an individual buffer.  The buffer memory itself immediately
// follows.
//
typedef struct
_BUFFERHEAD
{
    // Links to prev/next buffer header in the buffer pool's free list.
    //
    LIST_ENTRY linkFreeBuffers;

    // Back link to owning buffer block header.
    //
    BUFFERBLOCKHEAD* pBlock;

    // NDIS buffer descriptor of this buffer.  This is NULL unless the pool is
    // initialized with the 'fAssociateNdisBuffer' option.
    //
    NDIS_BUFFER* pNdisBuffer;
}
BUFFERHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag );

BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool );

CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool );

VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection );

NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer );

ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer );

NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer );

VOID
CollectBufferPoolGarbage(
    BUFFERPOOL* pPool );


#endif // BPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\debug.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// debug.c
// RAS L2TP WAN mini-port/call-manager driver
// Debug utilities and globals
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"


//-----------------------------------------------------------------------------
// Global data definitions
//-----------------------------------------------------------------------------

#ifdef TESTMODE
#define DEFAULTTRACELEVEL  TL_I
#define DEFAULTTRACEMASK TM_XCMsg
#else
#define DEFAULTTRACELEVEL TL_None
#define DEFAULTTRACEMASK TM_Base
#endif

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' are
// displayed.  All messages from any (TM_*) set(s) present in 'g_ulTraceMask'
// are displayed.
//
ULONG g_ulTraceLevel = DEFAULTTRACELEVEL;
ULONG g_ulTraceMask = DEFAULTTRACEMASK;


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------


#if DBG
VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks )

    // Tries to detect corruption in list 'pList', printing verbose linkage
    // output if 'fShowLinks' is set.
    //
{
    LIST_ENTRY* pLink;
    ULONG ul;

    ul = 0;
    for (pLink = pList->Flink;
         pLink != pList;
         pLink = pLink->Flink)
    {
        if (fShowLinks)
        {
            DbgPrint( "L2TP: CheckList($%p) Flink(%d)=$%p\n",
                pList, ul, pLink );
        }
        ++ul;
    }

    for (pLink = pList->Blink;
         pLink != pList;
         pLink = pLink->Blink)
    {
        if (fShowLinks)
        {
            DbgPrint( "L2TP: CheckList($%p) Blink(%d)=$%p\n",
                pList, ul, pLink );
        }
        --ul;
    }

    if (ul)
    {
        DbgBreakPoint();
    }
}
#endif


#if DBG
VOID
Dump(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )

    // Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
    // For example, with 'ulGroup' of 1, 2, and 4:
    //
    // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    // 0000 0000 0000 0000 0000 0000 0000 0000 |................|
    // 00000000 00000000 00000000 00000000 |................|
    //
    // If 'fAddress' is true, the memory address dumped is prepended to each
    // line.
    //
{
    while (cb)
    {
        INT cbLine;

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
    }
}
#endif


#if DBG
VOID
DumpLine(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress)
        DbgPrint( "L2TP: %p: ", p );
    else
        DbgPrint( "L2TP: " );

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\bpool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.c
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#include "l2tpp.h"

#include "bpool.tmh"

// Debug count of detected double-frees that should not be happening.
//
ULONG g_ulDoubleBufferFrees = 0;

// Debug  count of calls to NdisAllocateBuffer/NdisCopyBuffer/NdisFreeBuffer,
// where the total of Alloc and Copy should equal Free in idle state.
//
ULONG g_ulNdisAllocateBuffers = 0;
ULONG g_ulNdisCopyBuffers = 0;
ULONG g_ulNdisFreeBuffers = 0;

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool );

VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag )

    // Initialize caller's buffer pool control block 'pPool'.  'UlBufferSize'
    // is the size in bytes of an individual buffer.  'UlMaxBuffers' is the
    // maximum number of buffers allowed in the entire pool or 0 for
    // unlimited.  'UlBuffersPerBlock' is the number of buffers to include in
    // each block of buffers.  'UlFreesPerCollection' is the number of
    // FreeBufferToPool calls until the next garbage collect scan, or 0 for
    // default.  'FAssociateNdisBuffer' is set if an NDIS_BUFFER should be
    // allocated and associated with each individual buffer.  'UlTag' is the
    // memory identification tag to use when allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' buffer must be protected from multiple
    //            access during this call.
    //
{
    // The requested buffer size is padded, if necessary, so it alligns
    // properly when buffer blocks are layed out.  The alignment rule also
    // applies to the BUFFERBLOCKHEAD and BUFFERHEAD structures, which
    // currently align perfectly.  We will verify once here, rather than code
    // around everywhere else.
    //
    ASSERT( (ALIGN_UP( sizeof(BUFFERBLOCKHEAD), ULONGLONG )
        == sizeof(BUFFERBLOCKHEAD)) );
    ASSERT( (ALIGN_UP( sizeof(BUFFERHEAD), ULONGLONG )
        == sizeof(BUFFERHEAD)) );
    pPool->ulBufferSize = ALIGN_UP( ulBufferSize, ULONGLONG );

    pPool->ulMaxBuffers = ulMaxBuffers;
    pPool->ulBuffersPerBlock = ulBuffersPerBlock;
    pPool->ulFreesSinceCollection = 0;
    pPool->fAssociateNdisBuffer = fAssociateNdisBuffer;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 200 * pPool->ulBuffersPerBlock;
    }

    TRACE( TL_N, TM_Pool, ( "InitBp tag=$%08x buf=%d cnt=%d",
        pPool->ulTag, pPool->ulBufferSize, pPool->ulBuffersPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreeBuffers );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool )

    // Free up all resources allocated in buffer pool 'pPool'.  This is the
    // inverse of InitBufferPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    TRACE( TL_N, TM_Pool, ( "FreeBp" ) );

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        fSuccess = (pPool->ulCurBuffers == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );

    return fSuccess;
}


CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool )

    // Returns the address of the useable memory in an individual buffer
    // allocated from the pool 'pPool'.  The pool is expanded, if necessary,
    // but caller should still check for NULL return since the pool may have
    // been at maximum size.
    //
{
    LIST_ENTRY* pLink;
    BUFFERHEAD* pHead;
    CHAR* pBuffer;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreeBuffers ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreeBuffers );
            InitializeListHead( pLink );
            pHead = CONTAINING_RECORD( pLink, BUFFERHEAD, linkFreeBuffers );
            --pHead->pBlock->ulFreeBuffers;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (pLink)
    {
        pBuffer = (CHAR* )(pHead + 1);
    }
    else
    {
        // The free list was empty.  Try to expand the pool.
        //
        pBuffer = AddBufferBlockToPool( pPool );
    }

    DBG_if (pBuffer)
    {
        pHead = (BUFFERHEAD* )(pBuffer - sizeof(BUFFERHEAD));
        TRACE( TL_N, TM_Pool, ( "GetBfp=$%p, %d free",
            pBuffer, pHead->pBlock->ulFreeBuffers ) );
    }
    DBG_else
    {
        TRACE( TL_A, TM_Pool, ( "GetBfp failed?" ) );
    }

    return pBuffer;
}


VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection )

    // Returns 'pBuffer' to the pool of unused buffers 'pPool'.  'PBuffer'
    // must have been previously allocated with GetBufferFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddBufferToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;

    DBG_if (fGarbageCollection)
    {
        TRACE( TL_I, TM_Pool, ( "FreeBtoP($%p) %d free",
            pBuffer, pHead->pBlock->ulFreeBuffers + 1 ) );
    }

    // Requested by Chun Ye to catch IPSEC problem.
    //
    ASSERT( pHead->pNdisBuffer && !((MDL* )pHead->pNdisBuffer)->Next );

    NdisAcquireSpinLock( &pPool->lock );
    do
    {
        if (pHead->linkFreeBuffers.Flink != &pHead->linkFreeBuffers)
        {
            ASSERT( !"Double free?" );
            ++g_ulDoubleBufferFrees;
            break;
        }

        InsertHeadList( &pPool->listFreeBuffers, &pHead->linkFreeBuffers );
        ++pHead->pBlock->ulFreeBuffers;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the
                // pool not in use.
                //
                FreeUnusedBufferPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    while (FALSE);
    NdisReleaseSpinLock( &pPool->lock );
}


NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the NDIS_BUFFER associated with the buffer 'pBuffer' which was
    // obtained previously with GetBufferFromPool.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pNdisBuffer;
}


ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer )

    // Returns the original size of the buffer 'pBuffer' which was obtained
    // previously with GetBufferFromPool.  This is useful for undoing
    // NdisAdjustBufferLength.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->pPool->ulBufferSize;
}


NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the handle of the pool from which the NDIS_BUFFER associated
    // with the buffer 'pBuffer' was obtained.  Caller may use the handle to
    // pass to NdisCopyBuffer, one such use per buffer at a time.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->hNdisPool;
}


VOID
CollectBufferPoolGarbage(
    BUFFERPOOL* pPool )

    // Force a garbage collection event on the pool 'pPool'.
    //
{
    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        pPool->ulFreesSinceCollection = 0;
    }
    NdisReleaseSpinLock( &pPool->lock );
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool )

    // Allocate a new buffer block and add it to the buffer pool 'pPool'.
    //
    // Returns the address of the usable memory of an individual buffer
    // allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    BUFFERBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    BOOLEAN fAssociateNdisBuffer;
    CHAR* pReturn;

    TRACE( TL_A, TM_Pool, ( "AddBpBlock(%d+%d)",
        pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        // Save this for reference after the lock is released.
        //
        fAssociateNdisBuffer = pPool->fAssociateNdisBuffer;

        do
        {
            if (pPool->ulMaxBuffers
                && pPool->ulCurBuffers >= pPool->ulMaxBuffers)
            {
                // No can do.  The pool's already at maximum size.
                //
                TRACE( TL_A, TM_Pool, ( "Bp maxed?" ) );
                WPLOG( LL_A, LM_Pool, ( "Bp maxed?" ) );
                break;
            }

            // Calculate the contiguous block's size and the number of buffers
            // it will hold.
            //
            ulCount = pPool->ulBuffersPerBlock;
            if (pPool->ulMaxBuffers)
            {
                if (ulCount > pPool->ulMaxBuffers - pPool->ulCurBuffers)
                {
                    ulCount = pPool->ulMaxBuffers - pPool->ulCurBuffers;
                }
            }
            ulSize = sizeof(BUFFERBLOCKHEAD) +
                (ulCount * (sizeof(BUFFERHEAD) + pPool->ulBufferSize));

            // Allocate the contiguous memory block for the BUFFERBLOCK header
            // and the individual buffers.
            //
            pNew = ALLOC_NONPAGED( ulSize, pPool->ulTag );
            if (!pNew)
            {
                TRACE( TL_A, TM_Res, ( "Alloc BB?" ) );
                WPLOG( LL_A, LM_Res, ( "Alloc BB?" ) );
                break;
            }

            // Zero only the block header portion.
            //
            NdisZeroMemory( pNew, sizeof(BUFFERBLOCKHEAD) );

            if (fAssociateNdisBuffer)
            {
                // Allocate a pool of NDIS_BUFFER descriptors.
                //
                // Twice as many descriptors are allocated as buffers so
                // caller can use the PoolHandleForNdisCopyBufferFromBuffer
                // routine to obtain a pool handle to pass to the
                // NdisCopyBuffer used to trim the L2TP header from received
                // packets.  In the current NDIS implmentation on NT this does
                // nothing but return a NULL handle and STATUS_SUCCESS,
                // because NDIS_BUFFER's are just MDL's,
                // NdisAllocateBufferPool is basically a no-op, and for that
                // matter, NdisCopyBuffer doesn't really use the pool handle
                // it's passed.  It's cheap to stay strictly compliant here,
                // though, so we do that.
                //
                NdisAllocateBufferPool(
                    &status, &pNew->hNdisPool, ulCount * 2 );
                if (status != NDIS_STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Pool, ( "AllocBp=$%x?", status ) );
                    WPLOG( LL_A, LM_Pool, ( "AllocBp=$%x?", status ) );
                    break;
                }
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the buffers are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulBuffers = ulCount;
            pPool->ulCurBuffers += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            if (pNew->hNdisPool)
            {
                NdisFreeBufferPool( pNew->hNdisPool );
            }
            FREE_NONPAGED( pNew );
        }

        return NULL;
    }

    // Initialize each individual buffer slice and add it to the list of free
    // buffers.
    //
    {
        ULONG i;
        CHAR* pBuffer;
        BUFFERHEAD* pHead;

        pReturn = NULL;

        // For each slice of the block, where a slice consists of a BUFFERHEAD
        // and the buffer memory that immediately follows it...
        //
        for (i = 0, pHead = (BUFFERHEAD* )(pNew + 1);
             i < ulCount;
             ++i, pHead = (BUFFERHEAD* )
                      ((CHAR* )(pHead + 1) + pPool->ulBufferSize))
        {
            pBuffer = (CHAR* )(pHead + 1);

            InitializeListHead( &pHead->linkFreeBuffers );
            pHead->pBlock = pNew;
            pHead->pNdisBuffer = NULL;

            if (fAssociateNdisBuffer)
            {
                // Associate an NDIS_BUFFER descriptor from the pool we
                // allocated above.
                //
                NdisAllocateBuffer(
                    &status, &pHead->pNdisBuffer, pNew->hNdisPool,
                    pBuffer, pPool->ulBufferSize );

                if (status != NDIS_STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Pool, ( "AllocB=$%x?", status ) );
                    WPLOG( LL_A, LM_Pool, ( "AllocB=$%x?", status ) );
                    pHead->pNdisBuffer = NULL;
                    continue;
                }
                else
                {
                    NdisInterlockedIncrement( &g_ulNdisAllocateBuffers );
                }
            }

            if (pReturn)
            {
                // Add the constructed buffer to the list of free buffers.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreeBufferToPool( pPool, pBuffer, FALSE );
            }
            else
            {
                // The first successfully constructed buffer is returned by
                // this routine.
                //
                pReturn = pBuffer;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
{
    LIST_ENTRY* pLink;

    TRACE( TL_A, TM_Pool, ( "FreeUnusedBpBlocks" ) );

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        BUFFERBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, BUFFERBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreeBuffers >= pBlock->ulBuffers)
        {
            ULONG i;
            BUFFERHEAD* pHead;

            TRACE( TL_A, TM_Pool, ( "FreeBpBlock(%d-%d)",
                pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

            // Found a block with no buffers in use.  Walk the buffer block
            // removing each buffer from the pool's free list and freeing any
            // associated NDIS_BUFFER descriptor.
            //
            for (i = 0, pHead = (BUFFERHEAD* )(pBlock + 1);
                 i < pBlock->ulBuffers;
                 ++i, pHead = (BUFFERHEAD* )
                      (((CHAR* )(pHead + 1)) + pPool->ulBufferSize))
            {
                RemoveEntryList( &pHead->linkFreeBuffers );
                InitializeListHead( &pHead->linkFreeBuffers );

                if (pHead->pNdisBuffer)
                {
                    NdisFreeBuffer( pHead->pNdisBuffer );
                    NdisInterlockedIncrement( &g_ulNdisFreeBuffers );
                }
            }

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            InitializeListHead( pLink );
            pPool->ulCurBuffers -= pBlock->ulBuffers;

            if (pBlock->hNdisPool)
            {
                NdisFreeBufferPool( pBlock->hNdisPool );
            }

            FREE_NONPAGED( pBlock );
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ndis\rasl2tp\fsm.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// fsm.c
// RAS L2TP WAN mini-port/call-manager driver
// L2TP finite state machine routines
//
// 01/07/97 Steve Cobb


#include "l2tpp.h"

#include "fsm.tmh"

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
FsmInCallIdle(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmInCallWaitConnect(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmInCallEstablished(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmInCallWaitReply(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmOutCallBearerAnswer(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc );

VOID
FsmOutCallEstablished(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmOutCallIdle(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmOutCallWaitReply(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmOutCallWaitConnect(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CONTROLMSGINFO* pControl );

VOID
FsmTunnelEstablished(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl );

VOID
FsmTunnelIdle(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl );

VOID
FsmTunnelWaitCtlConnect(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl );

VOID
FsmTunnelWaitCtlReply(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl );

VOID
GetCcAvps(
    IN TUNNELCB* pTunnel,
    IN CONTROLMSGINFO* pControl,
    OUT USHORT* pusResult,
    OUT USHORT* pusError );

ULONG
StatusFromResultAndError(
    IN USHORT usResult,
    IN USHORT usError );


//-----------------------------------------------------------------------------
// FSM interface routines
//-----------------------------------------------------------------------------

BOOLEAN
FsmReceive(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN CHAR* pBuffer,
    IN CONTROLMSGINFO* pControl )

    // Dispatches a received control message to the appropriate FSM handler.
    // 'PTunnel' and 'pVc' are the tunnel and VC control blocks.  'PControl'
    // is the exploded description of the received control message.  'PBuffer'
    // is the receieve buffer.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
    // Returns true if the message was processed, false if
    // SetupVcAsynchronously was called.
    //
{
    TRACE( TL_V, TM_Cm, ( "FsmReceive" ) );

    if (pControl->fTunnelMsg)
    {
        switch (pTunnel->state)
        {
            case CCS_Idle:
            {
                FsmTunnelIdle( pTunnel, pControl );
                break;
            }

            case CCS_WaitCtlReply:
            {
                FsmTunnelWaitCtlReply( pTunnel, pControl );
                break;
            }

            case CCS_WaitCtlConnect:
            {
                FsmTunnelWaitCtlConnect( pTunnel, pControl );
                break;
            }

            case CCS_Established:
            {
                FsmTunnelEstablished( pTunnel, pControl );
                break;
            }
        }
    }
    else
    {
        if (!pVc)
        {
            if (*(pControl->pusMsgType) == CMT_ICRQ
                || *(pControl->pusMsgType) == CMT_OCRQ)
            {
                ULONG ulIpAddress;
                
                // Check if the MUST AVPs are present 
                if(!pControl->pusAssignedCallId || 
                    !pControl->pulCallSerialNumber)
                {
                    return TRUE;
                }

                // Peer wants to start a new call.  Set up a VC and dispatch
                // the received call request to the client above.  This is an
                // asynchronous operation that will eventually call
                // ReceiveControlExpected to finish processing the message.
                //
                ulIpAddress = pTunnel->address.ulIpAddress;
                NdisReleaseSpinLock( &pTunnel->lockT );
                {
                    SetupVcAsynchronously(
                        pTunnel, ulIpAddress, pBuffer, pControl );
                }
                NdisAcquireSpinLock( &pTunnel->lockT );
                return FALSE;
            }
            else
            {
                // Don't know what VC the call control message if for and it's
                // not a "create new call" request, so there's nothing useful
                // to do.  Ignore it.  Don't want to bring down the tunnel
                // because it may just be out of order.  One case is where
                // post-ICRQ packets are received before ICRQ is processed, to
                // create the VC block.
                //
                TRACE( TL_A, TM_Fsm, ( "CMT %d w/o VC?", *(pControl->pusMsgType) ) );
                WPLOG( LL_A, LM_Fsm, ( "CMT %d w/o VC?", *(pControl->pusMsgType) ) );
                return TRUE;
            }
        }

        NdisAcquireSpinLock( &pVc->lockV );
        {
            if (ReadFlags( &pVc->ulFlags ) & VCBF_IncomingFsm)
            {
                // L2TP Incoming Call FSM for both LAC/LNS.
                //
                switch (pVc->state)
                {
                    case CS_Idle:
                    {
                        FsmInCallIdle( pTunnel, pVc, pControl );
                        break;
                    }

                    case CS_WaitReply:
                    {
                        FsmInCallWaitReply( pTunnel, pVc, pControl );
                        break;
                    }

                    case CS_WaitConnect:
                    {
                        FsmInCallWaitConnect( pTunnel, pVc, pControl );
                        break;
                    }

                    case CS_Established:
                    {
                        FsmInCallEstablished( pTunnel, pVc, pControl );
                        break;
                    }
                }
            }
            else
            {
                // L2TP Outgoing Call FSM for both LAC/LNS.
                //
                switch (pVc->state)
                {
                    case CS_Idle:
                    {
                        FsmOutCallIdle( pTunnel, pVc, pControl );
                        break;
                    }

                    case CS_WaitReply:
                    {
                        FsmOutCallWaitReply( pTunnel, pVc, pControl );
                        break;
                    }

                    case CS_WaitConnect:
                    {
                        FsmOutCallWaitConnect( pTunnel, pVc, pControl );
                        break;
                    }

                    case CS_WaitCsAnswer:
                    {
                        // Because no WAN modes are supported and locks are
                        // held during the "null" WAN bearer answer, we should
                        // never be in this state on a received message.
                        //
                        ASSERT( FALSE );
                        break;
                    }

                    case CS_Established:
                    {
                        FsmOutCallEstablished( pTunnel, pVc, pControl );
                        break;
                    }
                }
            }
        }
        NdisReleaseSpinLock( &pVc->lockV );
    }

    return TRUE;
}


VOID
FsmOpenTunnel(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to handle a Control Connection (tunnel) Open
    // event.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Fsm, ( "FsmOpenTunnel" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = pVc->pAdapter;
    FREE_TUNNELWORK( pAdapter, pWork );

    status = NDIS_STATUS_SUCCESS;
    if (!(ReadFlags( &pTunnel->ulFlags ) & TCBF_TdixReferenced))
    {
        // Set up TDI for L2TP send/receive.
        //
        status = TdixOpen( &pAdapter->tdix );
        if (status == NDIS_STATUS_SUCCESS)
        {
            // Set this flag so TdixClose is called as the tunnel control
            // block is destroyed.
            //
            SetFlags( &pTunnel->ulFlags, TCBF_TdixReferenced );
        }
        else
        {
            TRACE( TL_A, TM_Fsm, ( "TdixOpen=$%08x", status ) );
            WPLOG( LL_A, LM_Fsm, ( "TdixOpen=$%08x", status ) );
        }
    }

    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        if (status == NDIS_STATUS_SUCCESS)
        {
            if (ReadFlags( &pTunnel->ulFlags ) & TCBF_Closing)
            {
                // New tunnel requests cannot be linked onto closing tunnels
                // as they would not be properly cleaned up.
                //
                TRACE( TL_A, TM_Fsm, ( "FOT aborted" ) );
                WPLOG( LL_A, LM_Fsm, ( "Can't open on an aborted tunnel" ) );
                status = NDIS_STATUS_TAPI_DISCONNECTMODE_UNKNOWN;
            }
        }

        if (status == NDIS_STATUS_SUCCESS)
        {
            if (ReadFlags( &pTunnel->ulFlags ) & TCBF_CcInTransition)
            {
                // The tunnel control channel is in the process of changing
                // states from Idle to Established or vice-versa.  Queue our
                // request to be resolved when the result is known.  See
                // TunnelTransitionComplete.
                //
                ASSERT(
                    pVc->linkRequestingVcs.Flink == &pVc->linkRequestingVcs );
                InsertTailList(
                    &pTunnel->listRequestingVcs, &pVc->linkRequestingVcs );
            }
            else
            {
                // The tunnel control channel is in the Idle or Established
                // states and no transition is underway.
                //
                if (pTunnel->state == CCS_Established)
                {
                    // The tunnel control channel is already up, so skip ahead
                    // to making a call to establish the data channel.
                    //
                    WPLOG( LL_M, LM_Fsm, ( "TUNNEL %p established, CALL %p", pTunnel, pVc) );
                    FsmOpenCall( pTunnel, pVc );
                }
                else
                {
                    // The tunnel control channel is down, so try to bring it
                    // up.
                    //
                    WPLOG( LL_M, LM_Fsm, ( "TUNNEL %p idle, CALL %p", pTunnel, pVc) );
                    FsmOpenIdleTunnel( pTunnel, pVc );
                }
            }
        }
        else
        {
            // Fail the call.
            //
            NdisAcquireSpinLock( &pVc->lockV );
            {
                pVc->status = status;
                CallTransitionComplete( pTunnel, pVc, CS_Idle );
            }
            NdisReleaseSpinLock( &pVc->lockV );

            CompleteVcs( pTunnel );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockT );
}


VOID
FsmOpenIdleTunnel(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc )

    // Initiate the tunnel connection on 'pTunnel' requested by 'pVc', i.e.
    // send the initial SCCRQ which kicks off the control connection (tunnel)
    // FSM.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    TRACE( TL_N, TM_Cm, ( "FsmOpenIdleTunnel" ) );
    ASSERT( pTunnel->state == CCS_Idle );

    SetFlags( &pTunnel->ulFlags, TCBF_CcInTransition );
    ASSERT( pVc->linkRequestingVcs.Flink == &pVc->linkRequestingVcs );
    InsertTailList( &pTunnel->listRequestingVcs, &pVc->linkRequestingVcs );

    pTunnel->state = CCS_WaitCtlReply;
    SendControl( pTunnel, NULL, CMT_SCCRQ, 0, 0, NULL, 0 );
}


VOID
FsmOpenCall(
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc )

    // Execute an "open" event for a call on 'pTunnel'/'pVc' playing the role
    // of the LAC/LNS indicated by the VCBF_IncomingFsm flag.  The owning
    // tunnel must be established first.
    //
{
    ULONG ulFlags;
    USHORT usMsgType;

    ulFlags = ReadFlags( &pVc->ulFlags );

    TRACE( TL_N, TM_Cm, ( "FsmCallOpen" ) );
    ASSERT( (ulFlags & VCBF_ClientOpenPending)
        || (ulFlags & VCBF_PeerOpenPending) );
    ASSERT( pVc->state == CS_Idle || pVc->state == CS_WaitTunnel );

    ActivateCallIdSlot( pVc );

    if (pVc->pAdapter->usPayloadReceiveWindow)
    {
        SetFlags( &pVc->ulFlags, VCBF_Sequencing );
    }

    usMsgType = (USHORT )((ulFlags & VCBF_IncomingFsm) ? CMT_ICRQ : CMT_OCRQ );

    pVc->state = CS_WaitReply;
    SendControl( pTunnel, pVc, usMsgType, 0, 0, NULL, 0 );
}


VOID
FsmCloseTunnel(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to close down 'pTunnel' gracefully.  Arg0 and
    // Arg1 are the result and error codes to send in the StopCCN message.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    USHORT usResult;
    USHORT usError;

    // Unpack context information, then free the work item.
    //
    usResult = (USHORT )(punpArgs[ 0 ]);
    usError = (USHORT )(punpArgs[ 1 ]);
    FREE_TUNNELWORK( pTunnel->pAdapter, pWork );

    ASSERT( usResult );

    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        if (pTunnel->state == CCS_Idle
            || pTunnel->state == CCS_WaitCtlReply)
        {
            TRACE( TL_I, TM_Cm,
                ( "FsmCloseTunnel(f=$%08x,r=%d,e=%d) now",
                ReadFlags( &pTunnel->ulFlags ),
                (UINT )usResult, (UINT )usError ) );

            // The tunnel's already idle so no closing exchange is necessary.
            // We also include the other state where we've had no response
            // from peer, but have sent our SCCRQ.  This is a tad rude to the
            // remote peer as we're deciding that it's more important to
            // respond quickly to our cancelling user than it is to wait for a
            // peer who may not be responding.  However, this is the trade-off
            // we've chosen.
            //
            CloseTunnel2( pTunnel );
        }
        else
        {
            TRACE( TL_I, TM_Cm,
                ( "FsmCloseTunnel(f=$%08x,r=%d,e=%d) grace",
                ReadFlags( &pTunnel->ulFlags ),
                (UINT )usResult, (UINT )usError ) );

            // Set flags and reference the tunnel for "graceful close".  The
            // reference is removed when the tunnel reaches idle state.
            //
            SetFlags( &pTunnel->ulFlags,
                (TCBF_Closing | TCBF_FsmCloseRef | TCBF_CcInTransition) );
            ReferenceTunnel( pTunnel, FALSE );

            // Initiate the closing exchange, holding the VC until the closing
            // message is acknowledged.
            //
            pTunnel->state = CCS_Idle;
            SendControl(
                pTunnel, NULL, CMT_StopCCN,
                (ULONG )usResult, (ULONG )usError, NULL, CSF_TunnelIdleOnAck );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockT );
}


VOID
FsmCloseCall(
    IN TUNNELWORK* pWork,
    IN TUNNELCB* pTunnel,
    IN VCCB* pVc,
    IN ULONG_PTR* punpArgs )

    // A PTUNNELWORK routine to close down the call on 'pVc' gracefully.  Arg0
    // and Arg1 are the result and error codes to send in the CDN message.
    //
    // This routine is called only at PASSIVE IRQL.
    //
{
    BOOLEAN fCompleteVcs;
    USHORT usResult;
    USHORT usError;

    // Unpack context information, then free the work item.
    //
    usResult = (USHORT )(punpArgs[ 0 ]);
    usError = (USHORT )(punpArgs[ 1 ]);
    FREE_TUNNELWORK( pTunnel->pAdapter, pWork );

    ASSERT( usResult );

    fCompleteVcs = FALSE;
    NdisAcquireSpinLock( &pTunnel->lockT );
    {
        NdisAcquireSpinLock( &pVc->lockV );
        {
            if (pVc->state == CS_Idle
                || pVc->state == CS_WaitTunnel
                || (ReadFlags( &pVc->ulFlags ) & VCBF_PeerClosePending))
            {
                TRACE( TL_I, TM_Cm,
                    ( "FsmCloseCall(f=$%08x,r=%d,e=%d) now",
                    ReadFlags( &pVc->ulFlags ),
                    (UINT )usResult, (UINT )usError ) );

                if (usResult == CRESULT_GeneralWithError)
                {
                    usResult = TRESULT_GeneralWithError;
                }
                else
                {
                    usResult = TRESULT_Shutdown;
                    usError = GERR_None;
                }

                // Slam the call closed.
                //
                fCompleteVcs = CloseCall2( pTunnel, pVc, usResult, usError );
            }
            else
            {
                TRACE( TL_I, TM_Cm,
                    ( "FsmCloseCall(f=$%08x,r=%d,e=%d) grace",
                    ReadFlags( &pVc->ulFlags ),
                    (UINT )usResult, (UINT )usError ) );

                // Initiate the closing exchange.
                //
                pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
                pVc->state = CS_Idle;
                SendControl(
                    pTunnel, pVc, CMT_CDN,
                    (ULONG )usResult, (ULONG )usError, NULL, CSF_CallIdleOnAck );
            }

        }
        NdisReleaseSpinLock( &pVc->lockV );

        if (fCompleteVcs)
        {
            CompleteVcs( pTunnel );
        }
    }
    NdisReleaseSpinLock( &pTunnel->lockT );
}


VOID
TunnelTransitionComplete(
    IN TUNNELCB* pTunnel,
    IN L2TPCCSTATE state )

    // Sets 'pTunnel's state to it's new CCS_Idle or CCS_Established 'state'
    // and kickstarts any MakeCall's that pended on the result.  If
    // established, adds the host route directing IP traffic to the L2TP peer
    // to the LAN card rather than the WAN (tunnel) adapter.
    //
    // IMPORTANT: Caller must hold 'pTunnel->lockT'.
    //
{
    NDIS_STATUS status;
    LIST_ENTRY list;
    LIST_ENTRY* pLink;
    ULONG ulFlags;
    VCCB* pVc;

    pTunnel->state = state;
    ClearFlags( &pTunnel->ulFlags, TCBF_CcInTransition );
    ulFlags = ReadFlags( &pTunnel->ulFlags );

    if (state == CCS_Established)
    {
        TRACE( TL_A, TM_Fsm, ( "TUNNEL %d UP", (ULONG )pTunnel->usTunnelId ) );
        WPLOG( LL_M, LM_Fsm, ( "TUNNEL %p UP, Tid %d, Peer's Tid %d", 
            pTunnel, pTunnel->usTunnelId, pTunnel->usAssignedTunnelId ) );

        // The tunnel any requesting VCs wanted established was established.
        // Skip ahead to establishing the outgoing calls.
        //
        while (!IsListEmpty( &pTunnel->listRequestingVcs ))
        {
            pLink = RemoveHeadList( &pTunnel->listRequestingVcs );
            InitializeListHead( pLink );
            pVc = CONTAINING_RECORD( pLink, VCCB, linkRequestingVcs );
            FsmOpenCall( pTunnel, pVc );
        }

        // Add the host route so traffic sent to the L2TP peer goes out the
        // LAN card instead of looping on the WAN (tunnel) interface, when
        // activated.
        //
        TRACE( TL_N, TM_Recv, ( "Schedule AddHostRoute" ) );
        ASSERT( !(ulFlags & TCBF_HostRouteAdded) );
        ScheduleTunnelWork(
            pTunnel, NULL, AddHostRoute,
            0, 0, 0, 0, FALSE, FALSE );
    }
    else
    {
        ASSERT( state == CCS_Idle );
        SetFlags( &pTunnel->ulFlags, TCBF_Closing );

        TRACE( TL_A, TM_Fsm,
            ( "%s TUNNEL %d DOWN",
            ((ulFlags & TCBF_PeerInitiated) ? "IN" : "OUT"),
            (ULONG )pTunnel->usTunnelId ) );

        WPLOG( LL_M, LM_Fsm, ( "%s TUNNEL %p DOWN, Tid %d, Peer's Tid %d", 
            ((ulFlags & TCBF_PeerInitiated) ? "IN" : "OUT"), pTunnel, 
            pTunnel->usTunnelId, pTunnel->usAssignedTunnelId ) );
                   
        // Any VCs associated with the tunnel are abruptly terminated.  This
        // is done by making it look like any pending operation has failed, or
        // if none is pending, that a bogus peer initiated close has
        // completed.
        //
        NdisAcquireSpinLock( &pTunnel->lockVcs );
        {
            for (pLink = pTunnel->listVcs.Flink;
                 pLink != &pTunnel->listVcs;
                 pLink = pLink->Flink)
            {
                

                pVc = CONTAINING_RECORD( pLink, VCCB, linkVcs );

                NdisAcquireSpinLock( &pVc->lockV );
                {
                    if (pVc->status == NDIS_STATUS_SUCCESS)
                    {
                        if (ulFlags & TCBF_PeerNotResponding)
                        {
                            // Line went down because peer stopped responding
                            // (or never responded).
                            //
                            pVc->status =
                                NDIS_STATUS_TAPI_DISCONNECTMODE_NOANSWER;
                        }
                        else
                        {
                            // Line went down for unknown reason.
                            //
                            pVc->status =
                                NDIS_STATUS_TAPI_DISCONNECTMODE_UNKNOWN;
                        }
                    }

                    CallTransitionComplete( pTunnel, pVc, CS_Idle );
                }
                NdisReleaseSpinLock( &pVc->lockV );
            }
        }
        NdisReleaseSpinLock( &pTunnel->lockVcs );

        ASSERT( IsListEmpty( &pTunnel->listRequestingVcs ) );

        // Flush the outstanding send list.
        //
        while (!IsListEmpty( &pTunnel->listSendsOut ))
        {
            CONTROLSENT* pCs;

            pLink = RemoveHeadList( &pTunnel->listSendsOut );
            InitializeListHead( pLink );
            pCs = CONTAINING_RECORD( pLink, CONTROLSENT, linkSendsOut );

            TRACE( TL_I, TM_Recv, ( "Flush pCs=$%p", pCs ) );

            // Terminate the timer.  Doesn't matter if the terminate fails as
            // the expire handler recognizes the context is not on the "out"
            // list and does nothing.
            //
            ASSERT( pCs->pTqiSendTimeout );
            TimerQTerminateItem( pTunnel->pTimerQ, pCs->pTqiSendTimeout );

            // Remove the context reference correspon