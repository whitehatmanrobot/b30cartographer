   ");
        return(TRUE);
    }

    if ( ((*Privilege).QuadPart == LpcReplyBoostPrivilege.QuadPart)) {
        printf("SeLpcReplyBoostPrivilege              ");
        return(TRUE);
    }

    if ( ((*Privilege).QuadPart == CreatePagefilePrivilege.QuadPart)) {
        printf("SeCreatePagefilePrivilege              ");
        return(TRUE);
    }

    if ( ((*Privilege).QuadPart == IncreaseBasePriorityPrivilege.QuadPart)) {
        printf("SeIncreaseBasePriorityPrivilege              ");
        return(TRUE);
    }

    if ( ((*Privilege).QuadPart == SystemProfilePrivilege.QuadPart)) {
        printf("SeSystemProfilePrivilege              ");
        return(TRUE);
    }

    if ( ((*Privilege).QuadPart == SystemtimePrivilege.QuadPart)) {
        printf("SeSystemtimePrivilege              ");
        return(TRUE);
    }

    if ( ((*Privilege).QuadPart == ProfileSingleProcessPrivilege.QuadPart)) {
        printf("SeProfileSingleProcessPrivilege              ");
        return(TRUE);
    }

    if ( ((*Privilege).QuadPart == CreatePermanentPrivilege.QuadPart)) {
        printf("SeCreatePermanentPrivilege              ");
        return(TRUE);
    }

    if ( ((*Privilege).QuadPart == BackupPrivilege.QuadPart)) {
        printf("SeBackupPrivilege              ");
        return(TRUE);
    }

    if ( ((*Privilege).QuadPart == RestorePrivilege.QuadPart)) {
        printf("SeRestorePrivilege              ");
        return(TRUE);
    }

    if ( ((*Privilege).QuadPart == ShutdownPrivilege.QuadPart)) {
        printf("SeShutdownPrivilege             ");
        return(TRUE);
    }

    if ( ((*Privilege).QuadPart == DebugPrivilege.QuadPart)) {
        printf("SeDebugPrivilege                ");
        return(TRUE);
    }

    if ( ((*Privilege).QuadPart == SystemEnvironmentPrivilege.QuadPart)) {
        printf("SeSystemEnvironmentPrivilege    ");
        return(TRUE);
    }

    return(FALSE);

}



VOID
DisplayPrivilege(
    PLUID_AND_ATTRIBUTES Privilege
    )
{


    if (!DisplayPrivilegeName(&Privilege->Luid)) {
        printf("(Unknown Privilege.  Value is: (0x%lx,0x%lx))",
               Privilege->Luid.HighPart,
               Privilege->Luid.LowPart
               );
    }



    //
    // Display the attributes assigned to the privilege.
    //

    printf("\n                           [");
    if (!(Privilege->Attributes & SE_PRIVILEGE_ENABLED)) {
        printf("Not ");
    }
    printf("Enabled");

    //printf(" / ");
    //if (!(Privilege->Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT)) {
    //    printf("Not ");
    //}
    //printf("Enabled By Default");


    printf("]\n");
    printf("                           ");


    return;

}


VOID
DisplaySecurityContext(
    IN HANDLE TokenHandle
    )
{

#define BUFFER_SIZE (2048)

    NTSTATUS Status;
    ULONG i;
    ULONG ReturnLength;
    TOKEN_STATISTICS ProcessTokenStatistics;
    GUID AuthenticationId;
    UCHAR Buffer[BUFFER_SIZE];


    PTOKEN_USER UserId;
    PTOKEN_OWNER DefaultOwner;
    PTOKEN_PRIMARY_GROUP PrimaryGroup;
    PTOKEN_GROUPS GroupIds;
    PTOKEN_PRIVILEGES Privileges;




    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    // Logon ID                                                            //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    Status = NtQueryInformationToken(
                 TokenHandle,                  // Handle
                 TokenStatistics,              // TokenInformationClass
                 &ProcessTokenStatistics,      // TokenInformation
                 sizeof(TOKEN_STATISTICS),     // TokenInformationLength
                 &ReturnLength                 // ReturnLength
                 );
    ASSERT(NT_SUCCESS(Status));
    AuthenticationId = ProcessTokenStatistics.AuthenticationId;

    printf("     Logon Session:        ");
    if (RtlEqualGuid(&AuthenticationId, &SystemAuthenticationId )) {
        printf("(System Logon Session)\n");
    } else {
        PrintGuid( &AuthenticationId );
    }




    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    // User Id                                                             //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    UserId = (PTOKEN_USER)&Buffer[0];
    Status = NtQueryInformationToken(
                 TokenHandle,              // Handle
                 TokenUser,                // TokenInformationClass
                 UserId,                   // TokenInformation
                 BUFFER_SIZE,              // TokenInformationLength
                 &ReturnLength             // ReturnLength
                 );


    ASSERT(NT_SUCCESS(Status));

    printf("           User id:        ");
    DisplayAccountSid( (PISID)UserId->User.Sid );





    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    // Default Owner                                                       //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    DefaultOwner = (PTOKEN_OWNER)&Buffer[0];

    Status = NtQueryInformationToken(
                 TokenHandle,              // Handle
                 TokenOwner,               // TokenInformationClass
                 DefaultOwner,             // TokenInformation
                 BUFFER_SIZE,              // TokenInformationLength
                 &ReturnLength             // ReturnLength
                 );


    ASSERT(NT_SUCCESS(Status));

    printf("     Default Owner:        ");
    DisplayAccountSid( (PISID)DefaultOwner->Owner );






    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    // Primary Group                                                       //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    PrimaryGroup = (PTOKEN_PRIMARY_GROUP)&Buffer[0];

    Status = NtQueryInformationToken(
                 TokenHandle,              // Handle
                 TokenPrimaryGroup,        // TokenInformationClass
                 PrimaryGroup,             // TokenInformation
                 BUFFER_SIZE,              // TokenInformationLength
                 &ReturnLength             // ReturnLength
                 );


    ASSERT(NT_SUCCESS(Status));

    printf("     Primary Group:        ");
    DisplayAccountSid( (PISID)PrimaryGroup->PrimaryGroup );






    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    // Group Ids                                                           //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    printf("\n");
    GroupIds = (PTOKEN_GROUPS)&Buffer[0];
    Status   = NtQueryInformationToken(
                   TokenHandle,              // Handle
                   TokenGroups,              // TokenInformationClass
                   GroupIds,                 // TokenInformation
                   BUFFER_SIZE,              // TokenInformationLength
                   &ReturnLength             // ReturnLength
                   );


    ASSERT(NT_SUCCESS(Status));

    //printf("  Number of groups:        %ld\n", GroupIds->GroupCount);
    printf("            Groups:        ");

    for (i=0; i < GroupIds->GroupCount; i++ ) {
        //printf("                           Group %ld: ", i);
        DisplayAccountSid( (PISID)GroupIds->Groups[i].Sid );
        printf("                           ");
    }





    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    // Privileges                                                          //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    printf("\n");
    Privileges = (PTOKEN_PRIVILEGES)&Buffer[0];
    Status   = NtQueryInformationToken(
                   TokenHandle,              // Handle
                   TokenPrivileges,          // TokenInformationClass
                   Privileges,               // TokenInformation
                   BUFFER_SIZE,              // TokenInformationLength
                   &ReturnLength             // ReturnLength
                   );


    ASSERT(NT_SUCCESS(Status));

    printf("        Privileges:        ");
    if (Privileges->PrivilegeCount > 0) {

        for (i=0; i < Privileges->PrivilegeCount; i++ ) {
            DisplayPrivilege( &(Privileges->Privileges[i]) );
        }
    } else {
        printf("(none assigned)\n");
    }



    return;

}


BOOLEAN
main()
{

    NTSTATUS Status;
    HANDLE ProcessToken;


    TSeVariableInitialization();    // Initialize global variables

    printf("\n");


    //
    // Open our process token
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_QUERY,
                 &ProcessToken
                 );
    if (!NT_SUCCESS(Status)) {
        printf("I'm terribly sorry, but you don't seem to have access to\n");
        printf("open your own process's token.\n");
        printf("\n");
        return(FALSE);
    }

    printf("Your process level security context is:\n");
    printf("\n");
    DisplaySecurityContext( ProcessToken );


    Status = NtClose( ProcessToken );

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\se\utseqos.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    utseqos.c

Abstract:

    Security component user-mode test.

    Security quality of service test from user mode.

Author:

    Jim Kelly (JimK) 27-June-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _TST_USER_  // User mode test

#include "tsecomm.c"     // Common routines
#include "ctseqos.c"     // quality of service tests



BOOLEAN
Test()
{
    BOOLEAN Result = TRUE;


    Result = CtSeQos();


    return Result;
}

BOOLEAN
main()
{
    return Test();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\ntvdmp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntvdmp.h

Abstract:

    Vdm Private include file for platform independent vdm support functions


Author:

    20-May-1994 Jonle

Revision History:

--*/


NTSTATUS
VdmQueryDirectoryFile(
    PVDMQUERYDIRINFO VdmQueryDir
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\se\uttoken.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    uttoken.c

Abstract:

    Security component user-mode test.

    Token Object test from user mode.

Author:

    Jim Kelly (JimK) 27-June-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _TST_USER_  // User mode test


#include "tsevars.c"    // Common test variables

#include "cttoken.c"     // Common accessibility test routines



BOOLEAN
Test()
{

    BOOLEAN Result = TRUE;

    DbgPrint("Se: Start User Mode Token Object Test...\n");

    Result = CTToken();

    DbgPrint("Se: End User Mode Token Object Test.\n");

    return Result;
}


BOOLEAN
__cdecl
main()
{
    return Test();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=vdm

TARGETNAME=vdm
TARGETTYPE=LIBRARY
TARGETPATH=obj

BUILD_PRODUCES=ntosvdm$(NT_UP)

INCLUDES=..;..\..\inc

MSC_WARNING_LEVEL=/W4 /WX

!IF $(386)
INCLUDES=$(INCLUDES);..\i386
!ENDIF

SOURCES=..\vdm.c
NTTARGETFILES=

i386_SOURCES=   ..\i386\vdmentry.c         \
                ..\i386\vdminit.c          \
                ..\i386\vdmnpx.c           \
                ..\i386\vdmop0f.asm        \
                ..\i386\vdmoprnd.asm       \
                ..\i386\vdmfault.c         \
                ..\i386\vdmprint.c         \
                ..\i386\strtexec.c         \
                ..\i386\rdwr.c             \
                ..\i386\vdmtrace.c         \
                ..\i386\vdmints.c          \
                ..\i386\vdmtib.c           \
                ..\i386\vdmuserrefs.c

UMTYPE=console

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\se\utsertl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    utsertl.c

Abstract:

    Security component user-mode test.
    Test security RTL routines from user mode.

Author:

    Jim Kelly (JimK) 13-Apr-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _TST_USER_      // User mode test

#include "tsevars.c"    // Common test variables

#include "ctsertl.c"    // Common RTL test routines


BOOLEAN
turtl()
{
    BOOLEAN Result;

    DbgPrint("Se: Start User Mode RTL Test...\n");

    Result = TestSeRtl();

    if (!Result) {
        DbgPrint("Se: ** User Mode RTL Test Failed **\n");
    }
    DbgPrint("Se: End User Mode RTL Test.\n");
    return Result;
}

NTSTATUS
__cdecl
main()
{
    turtl();

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\vdm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vdm.c

Abstract:

    This module supplies the entry point to the system for manipulating vdms.

Author:

    Dave Hastings (daveh) 6-Apr-1992

Revision History:

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses

#if defined (_X86_)
#include "vdmp.h"
#endif
#include <ntos.h>
#include <vdmntos.h>
#include <ntvdmp.h>

#include <zwapi.h>
#include <fsrtl.h>


typedef struct _QueryDirPoolData {
    KEVENT         kevent;
    UNICODE_STRING FileName;
    WCHAR          FileNameBuf[1];
} QDIR_POOLDATA, *PQDIR_POOLDATA;



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, VdmQueryDirectoryFile)
#endif

#if !defined(i386)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtVdmControl)
#endif

NTSTATUS
NtVdmControl(
    IN VDMSERVICECLASS Service,
    IN OUT PVOID ServiceData
    )
/*++

Routine Description:

    This routine is the entry point for controlling Vdms.
    On risc it returns STATUS_NOT_IMPLEMENTED.
    On 386 the entry point is in i386\vdmentry.c

Arguments:

    Service -- Specifies what service is to be performed
    ServiceData -- Supplies a pointer to service specific data

Return Value:


--*/
{
    PAGED_CODE();


    if (Service == VdmQueryDir) {
        return VdmQueryDirectoryFile(ServiceData);
        }

    return STATUS_NOT_IMPLEMENTED;

}
#endif


extern POBJECT_TYPE IoFileObjectType;

NTSTATUS
VdmQueryDirectoryFile(
    PVDMQUERYDIRINFO pVdmQueryDir
    )

/*++
    This VDM specific service allows vdm to restart searches at a specified
    location in the dir search by using the FileIndex, FileName parameters
    passed back from previous query calls.

    See NtQueryDirectoryFile for additional documentation.

Arguments: PVDMQUERYDIRINFO pVdmQueryDir

    FileHandle - Supplies a handle to the directory file for which information
        should be returned.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the contents of the directory.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileName - Supplies a file name within the specified directory.

    FileIndex - Supplies a file index within the specified directory.

    The FileInformationClass is assumed to be FILE_BOTH_DIR_INFORMATION
    The Caller's mode is assumed to be UserMode
    Synchronous IO is used

--*/

{
    KIRQL    irql;
    NTSTATUS status;
    PKEVENT  Event;

    HANDLE FileHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID FileInformation;
    ULONG Length;
    UNICODE_STRING FileName;
    PUNICODE_STRING pFileNameSrc;
    ULONG FileIndex;

    PQDIR_POOLDATA QDirPoolData = NULL;

    PMDL mdl;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PCHAR SystemBuffer;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT DeviceObject;


    PAGED_CODE();

    //
    // We assume that the caller is usermode, so verify all parameters
    // accordingly
    //

    try {

        //
        // Copy out the callers service data into local variables
        //
        ProbeForRead( pVdmQueryDir, sizeof(VDMQUERYDIRINFO), sizeof(ULONG));

        FileHandle      = pVdmQueryDir->FileHandle;
        FileInformation = pVdmQueryDir->FileInformation;
        Length          = pVdmQueryDir->Length;
        FileIndex       = pVdmQueryDir->FileIndex;
        pFileNameSrc    = pVdmQueryDir->FileName;

        //
        // Ensure that we have a valid file name string
        //

        //
        // check for pVdmQueryDir->Filename validity first
        //
        if (NULL == pFileNameSrc) {
           return(STATUS_INVALID_PARAMETER);
        }

        FileName = ProbeAndReadUnicodeString(pFileNameSrc);
        if (!FileName.Length ||
            FileName.Length > MAXIMUM_FILENAME_LENGTH<<1) {
            return(STATUS_INVALID_PARAMETER);
        }

        ProbeForRead(FileName.Buffer, FileName.Length, sizeof( UCHAR ));

        //
        // The FileInformation buffer must be writeable by the caller.
        //

        ProbeForWrite( FileInformation, Length, sizeof( ULONG ) );

        //
        // Ensure that the caller's supplied buffer is at least large enough
        // to contain the fixed part of the structure required for this
        // query.
        //

        if (Length < sizeof(FILE_BOTH_DIR_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }



        //
        // Allocate from nonpaged pool a buffer large enough to contain
        // the file name, and the kevent used to wait for io.
        //

        QDirPoolData = (PQDIR_POOLDATA) ExAllocatePoolWithQuotaTag(
                                           NonPagedPool,
                                           sizeof(QDIR_POOLDATA) + FileName.Length,
                                           ' MDV');

        //
        // Capture the file name string into the nonpaged pool block.
        //

        QDirPoolData->FileName.Length = FileName.Length;
        QDirPoolData->FileName.MaximumLength = FileName.Length;
        QDirPoolData->FileName.Buffer = QDirPoolData->FileNameBuf;
        RtlCopyMemory( QDirPoolData->FileNameBuf,
                       FileName.Buffer,
                       FileName.Length );


    } except(EXCEPTION_EXECUTE_HANDLER) {

        if (QDirPoolData) {
            ExFreePool(QDirPoolData);
        }

        return GetExceptionCode();
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_LIST_DIRECTORY,
                                        IoFileObjectType,
                                        UserMode,
                                        (PVOID *) &fileObject,
                                        (POBJECT_HANDLE_INFORMATION) NULL );
    if (!NT_SUCCESS( status )) {
        if (QDirPoolData) {
            ExFreePool(QDirPoolData);
        }
        return status;
    }

    //
    //  We don't handle FO_SYNCHRONOUS_IO, because it requires
    //  io internal functionality. Ntvdm can get away with this
    //  because it serializes access to the dir handle.
    //

    //
    // Initialize the kernel event that will signal I/O completion
    //
    Event = &QDirPoolData->kevent;
    KeInitializeEvent(Event, SynchronizationEvent, FALSE);


    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    DeviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( DeviceObject->StackSize, TRUE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        ObDereferenceObject( fileObject );
        if (QDirPoolData) {
            ExFreePool(QDirPoolData);
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->Flags = (ULONG)IRP_SYNCHRONOUS_API;
    irp->RequestorMode = UserMode;

    irp->UserIosb = &IoStatusBlock;
    irp->UserEvent = Event;

    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    SystemBuffer = NULL;


    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.AuxiliaryBuffer = NULL;
    irp->MdlAddress = NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    irpSp->MinorFunction = IRP_MN_QUERY_DIRECTORY;
    irpSp->FileObject = fileObject;


    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryDirectory.Length = Length;
    irpSp->Parameters.QueryDirectory.FileInformationClass = FileBothDirectoryInformation;
    irpSp->Parameters.QueryDirectory.FileIndex = FileIndex;

    if (QDirPoolData->FileName.Length) {
        irpSp->Parameters.QueryDirectory.FileName = &QDirPoolData->FileName;
    } else {
        irpSp->Parameters.QueryDirectory.FileName = NULL;
    }

    irpSp->Flags = SL_INDEX_SPECIFIED;


    //
    // Now determine whether this driver expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the driver's data will be copied into it.  Otherwise, a
    // Memory Descriptor List (MDL) is allocated and the caller's buffer is
    // locked down using it.
    //

    if (DeviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The file system wants buffered I/O.  Pass the address of the
        // "system buffer" in the IRP.  Note that we don't want the buffer
        // deallocated, nor do we want the I/O system to copy to a user
        // buffer, so we don't set the corresponding flags in irp->Flags.
        //


        try {

            //
            // Allocate the intermediary system buffer from nonpaged pool and
            // charge quota for it.
            //

            SystemBuffer = ExAllocatePoolWithQuotaTag( NonPagedPool,
                                                       Length,
                                                       ' MDV' );

            irp->AssociatedIrp.SystemBuffer = SystemBuffer;


        } except(EXCEPTION_EXECUTE_HANDLER) {

            IoFreeIrp(irp);

            ObDereferenceObject( fileObject );

            if (QDirPoolData) {
                ExFreePool(QDirPoolData);
            }

            return GetExceptionCode();
        }


    } else if (DeviceObject->Flags & DO_DIRECT_IO) {

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This is
        // done using an exception handler that will perform cleanup if the
        // operation fails.
        //

        mdl = (PMDL) NULL;

        try {

            //
            // Allocate an MDL, charging quota for it, and hang it off of the
            // IRP.  Probe and lock the pages associated with the caller's
            // buffer for write access and fill in the MDL with the PFNs of
            // those pages.
            //

            mdl = IoAllocateMdl( FileInformation, Length, FALSE, TRUE, irp );
            if (mdl == NULL) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }
            MmProbeAndLockPages( mdl, UserMode, IoWriteAccess );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            if (irp->MdlAddress != NULL) {
                 IoFreeMdl( irp->MdlAddress );
            }

            IoFreeIrp(irp);

            ObDereferenceObject( fileObject );

            if (QDirPoolData) {
                ExFreePool(QDirPoolData);
            }

            return GetExceptionCode();
        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access to
        // it.  It is now the driver's responsibility to do everything.
        //

        irp->UserBuffer = FileInformation;

    }


    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    KeRaiseIrql( APC_LEVEL, &irql );
    InsertHeadList( &irp->Tail.Overlay.Thread->IrpList,
                    &irp->ThreadListEntry );
    KeLowerIrql( irql );


    //
    // invoke the driver and wait for it to complete
    //

    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject(
                     Event,
                     UserRequest,
                     UserMode,
                     FALSE,
                     NULL );
    }

    if (NT_SUCCESS(status)) {
        status = IoStatusBlock.Status;
        if (NT_SUCCESS(status) || status == STATUS_BUFFER_OVERFLOW) {
            if (SystemBuffer) {
                try {
                    RtlCopyMemory( FileInformation,
                                   SystemBuffer,
                                   IoStatusBlock.Information
                                   );

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    status = GetExceptionCode();
                }
            }
        }
    }


    //
    // Cleanup any memory allocated
    //
    if (QDirPoolData) {
        ExFreePool(QDirPoolData);
    }

    if (SystemBuffer) {
        ExFreePool(SystemBuffer);
    }


    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\strtexec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    strtexec.c

Abstract:

    This module contains routines for switching to and from application
    mode in a VDM.

Author:

    Dave Hastings (daveh) 24-Apr-1992

Revision History:

--*/
#include "vdmp.h"

VOID
Ki386AdjustEsp0 (
    PKTRAP_FRAME TrapFrame
    );

VOID
VdmSwapContexts (
    PKTRAP_FRAME TrapFrame,
    IN PCONTEXT OutContextUserSpace,
    IN PCONTEXT InContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, VdmpStartExecution)
#pragma alloc_text(PAGE, VdmEndExecution)
#pragma alloc_text(PAGE, VdmSwapContexts)
#endif

NTSTATUS
VdmpStartExecution (
    VOID
    )
/*++

Routine Description:

    This routine causes execution of dos application code to begin.  The
    Dos application executes on the thread.  The Vdms context is loaded
    from the VDM_TIB for the thread.  The 32 bit context is stored into
    the MonitorContext.  Execution in the VDM context will continue until
    an event occurs that the monitor needs to service.  At that point,
    the information will be put into the VDM_TIB, and the call will
    return.

Arguments:

    None.

Return Value:

    TrapFrame->Eax for application mode, required for system sevices exit.

--*/
{
    PVDM_TIB VdmTib;
    PKTRAP_FRAME TrapFrame;
    PETHREAD Thread;
    KIRQL    OldIrql;
    BOOLEAN  IntsEnabled;
    NTSTATUS Status;
    CONTEXT VdmContext;

    PAGED_CODE();

    //
    // Form a pointer to the trap frame for the current thread
    //

    Thread = PsGetCurrentThread ();
    TrapFrame = VdmGetTrapFrame (&Thread->Tcb);

    //
    // Get the VdmTib
    //

    Status = VdmpGetVdmTib (&VdmTib);

    if (!NT_SUCCESS(Status)) {
       return STATUS_INVALID_SYSTEM_SERVICE;
    }

    KeRaiseIrql (APC_LEVEL, &OldIrql);

    try {

        //
        // Determine if interrupts are on or off
        //

        IntsEnabled = VdmTib->VdmContext.EFlags & EFLAGS_INTERRUPT_MASK
                   ? TRUE : FALSE;

        //
        // Check for timer ints to dispatch, However if interrupts are disabled
        // or there are hardware ints pending we postpone dispatching the timer
        // interrupt until interrupts are enabled.
        //

        if ((*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_INT_TIMER) &&
            IntsEnabled &&
            !(*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_INT_HARDWARE)) {

            VdmTib->EventInfo.Event = VdmIntAck;
            VdmTib->EventInfo.InstructionSize = 0;
            VdmTib->EventInfo.IntAckInfo = 0;
            KeLowerIrql(OldIrql);
            return STATUS_SUCCESS;
        }

        //
        // Perform IF to VIF translation if the processor
        // supports IF virtualization
        //

        if ((VdmTib->VdmContext.EFlags & EFLAGS_V86_MASK) &&
            (KeI386VirtualIntExtensions & V86_VIRTUAL_INT_EXTENSIONS)) {

            //
            // Translate IF to VIF
            //

            if (IntsEnabled) {
                VdmTib->VdmContext.EFlags |= EFLAGS_VIF;
            } else {
                VdmTib->VdmContext.EFlags &= ~EFLAGS_VIF;
                VdmTib->VdmContext.EFlags |= EFLAGS_INTERRUPT_MASK;
            }

            if (*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_INT_HARDWARE)
                VdmTib->VdmContext.EFlags |= EFLAGS_VIP;
            else
                VdmTib->VdmContext.EFlags &= ~EFLAGS_VIP;

        } else {

            //
            // Translate the real interrupt flag in the VdmContext to the
            // virtual interrupt flag in the VdmTib, and force real
            // interrupts enabled.
            //

            ASSERT(VDM_VIRTUAL_INTERRUPTS == EFLAGS_INTERRUPT_MASK);

            if (VdmTib->VdmContext.EFlags & EFLAGS_INTERRUPT_MASK) {
                InterlockedOr (FIXED_NTVDMSTATE_LINEAR_PC_AT, VDM_VIRTUAL_INTERRUPTS);
            } else {
                InterlockedAnd (FIXED_NTVDMSTATE_LINEAR_PC_AT, ~VDM_VIRTUAL_INTERRUPTS);
            }

            //
            // Insure that real interrupts are always enabled.
            //
            VdmTib->VdmContext.EFlags |= EFLAGS_INTERRUPT_MASK;
        }

        //
        // Before working on a trap frame, make sure that it's our own structure
        //

        VdmContext = VdmTib->VdmContext;

        if (!(VdmContext.EFlags & EFLAGS_V86_MASK) && !(VdmContext.SegCs & FRAME_EDITED)) {

            //
            // We will crash in KiServiceExit
            //

            KeLowerIrql(OldIrql);
            return(STATUS_INVALID_SYSTEM_SERVICE);
        }

        //
        // Switch from MonitorContext to VdmContext
        //

        VdmSwapContexts (TrapFrame,
                         &VdmTib->MonitorContext,
                         &VdmContext);

        //
        // Check for pending interrupts
        //

        if (IntsEnabled && (*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_INT_HARDWARE)) {
            VdmDispatchInterrupts(TrapFrame, VdmTib);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
       KeLowerIrql (OldIrql);
       Status = GetExceptionCode();
       return Status;
    }

    KeLowerIrql(OldIrql);

    return (NTSTATUS) TrapFrame->Eax;
}

VOID
VdmEndExecution (
    PKTRAP_FRAME TrapFrame,
    PVDM_TIB VdmTib
    )
/*++

Routine Description:

    This routine does the core work to end the execution

Arguments:

    None

Return Value:

    VOID, but exceptions can be thrown due to the user space accesses.

--*/
{
    CONTEXT VdmContext;
    KIRQL OldIrql;

    PAGED_CODE();

    ASSERT((TrapFrame->EFlags & EFLAGS_V86_MASK) ||
           (TrapFrame->SegCs != (KGDT_R3_CODE | RPL_MASK)) );

    //
    // Raise to APC_LEVEL to synchronize modification to the trap frame.
    //

    KeRaiseIrql (APC_LEVEL, &OldIrql);

    try {

        //
        // The return value must be put into the Monitorcontext, and set,
        // since we are probably returning to user mode via EXIT_ALL, and
        // the volatile registers will be restored.
        //

        VdmTib->MonitorContext.Eax = STATUS_SUCCESS;
        VdmContext = VdmTib->MonitorContext;

        if (!(VdmContext.EFlags & EFLAGS_V86_MASK) && !(VdmContext.SegCs & FRAME_EDITED)) {

            //
            // We will crash in KiServiceExit
            //

            leave;
        }

        //
        // Switch from MonitorContext to VdmContext
        //

        VdmSwapContexts (TrapFrame,
                         &VdmTib->VdmContext,
                         &VdmContext);

        //
        // Perform IF to VIF translation
        //

        //
        // If the processor supports IF virtualization
        //
        if ((VdmTib->VdmContext.EFlags & EFLAGS_V86_MASK) &&
            (KeI386VirtualIntExtensions & V86_VIRTUAL_INT_EXTENSIONS)) {

            //
            // Translate VIF to IF
            //
            if (VdmTib->VdmContext.EFlags & EFLAGS_VIF) {
                VdmTib->VdmContext.EFlags |= EFLAGS_INTERRUPT_MASK;
            } else {
                VdmTib->VdmContext.EFlags &= ~EFLAGS_INTERRUPT_MASK;
            }
            //
            // Turn off VIP and VIF to insure that nothing strange happens
            //
            TrapFrame->EFlags &= ~(EFLAGS_VIP | EFLAGS_VIF);
            VdmTib->VdmContext.EFlags &= ~(EFLAGS_VIP | EFLAGS_VIF);

        } else {

            //
            // Translate the virtual interrupt flag from the VdmTib back to the
            // real interrupt flag in the VdmContext
            //

            VdmTib->VdmContext.EFlags =
                (VdmTib->VdmContext.EFlags & ~EFLAGS_INTERRUPT_MASK)
                    | (*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_VIRTUAL_INTERRUPTS);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }

    KeLowerIrql (OldIrql);
    return;
}

VOID
VdmSwapContexts (
    PKTRAP_FRAME TrapFrame,
    IN PCONTEXT OutContextUserSpace,
    IN PCONTEXT InContext
    )
/*++

Routine Description:

    This routine unloads a CONTEXT from a KFRAME, and loads a different
    context in its place.

    ASSUMES that entry irql is APC_LEVEL, if it is not this routine
    may produce incorrect trapframes.

    BUGBUG: Could this routine be folded into KeContextToKframes ?

Arguments:

    TrapFrame - Supplies the trapframe to copy registers from.

    OutContextUserSpace - Supplies the context record to fill - this is a user
                          space argument that has been probed.  Our caller MUST
                          use an exception handler when calling us.

    InContext - Supplies the captured context record to copy from.

Return Value:

    VOID.  Exceptions may be thrown due to user space accesses.

--*/
{
    ULONG Eflags;
    ULONG V86Change;

    ASSERT (KeGetCurrentIrql () == APC_LEVEL);

    //
    // Move context from trap frame to outgoing context.
    //

    ASSERT (TrapFrame->DbgArgMark == 0xBADB0D00);

    if (TrapFrame->EFlags & EFLAGS_V86_MASK) {

        //
        // Move segment registers.
        //

        OutContextUserSpace->SegGs = TrapFrame->V86Gs;
        OutContextUserSpace->SegFs = TrapFrame->V86Fs;
        OutContextUserSpace->SegEs = TrapFrame->V86Es;
        OutContextUserSpace->SegDs = TrapFrame->V86Ds;
    }
    else if ((USHORT)TrapFrame->SegCs != (KGDT_R3_CODE | RPL_MASK)) {
        OutContextUserSpace->SegGs = TrapFrame->SegGs;
        OutContextUserSpace->SegFs = TrapFrame->SegFs;
        OutContextUserSpace->SegEs = TrapFrame->SegEs;
        OutContextUserSpace->SegDs = TrapFrame->SegDs;
    }

    OutContextUserSpace->SegCs = TrapFrame->SegCs;
    OutContextUserSpace->SegSs = TrapFrame->HardwareSegSs;

    //
    // Move General Registers.
    //

    OutContextUserSpace->Eax = TrapFrame->Eax;
    OutContextUserSpace->Ebx = TrapFrame->Ebx;
    OutContextUserSpace->Ecx = TrapFrame->Ecx;
    OutContextUserSpace->Edx = TrapFrame->Edx;
    OutContextUserSpace->Esi = TrapFrame->Esi;
    OutContextUserSpace->Edi = TrapFrame->Edi;

    //
    // Move Pointer registers.
    //

    OutContextUserSpace->Ebp = TrapFrame->Ebp;
    OutContextUserSpace->Esp = TrapFrame->HardwareEsp;
    OutContextUserSpace->Eip = TrapFrame->Eip;

    //
    // Move Flags.
    //

    OutContextUserSpace->EFlags = TrapFrame->EFlags;

    //
    // Move incoming context to trap frame.
    //

    TrapFrame->SegCs = InContext->SegCs;
    TrapFrame->HardwareSegSs = InContext->SegSs;

    //
    // Move General Registers.
    //

    TrapFrame->Eax = InContext->Eax;
    TrapFrame->Ebx = InContext->Ebx;
    TrapFrame->Ecx = InContext->Ecx;
    TrapFrame->Edx = InContext->Edx;
    TrapFrame->Esi = InContext->Esi;
    TrapFrame->Edi = InContext->Edi;

    //
    // Move Pointer registers.
    //

    TrapFrame->Ebp = InContext->Ebp;
    TrapFrame->HardwareEsp = InContext->Esp;
    TrapFrame->Eip = InContext->Eip;

    //
    // Move Flags.
    //

    Eflags = InContext->EFlags;

    if (Eflags & EFLAGS_V86_MASK) {
        Eflags &= KeI386EFlagsAndMaskV86;
        Eflags |= KeI386EFlagsOrMaskV86;
    }
    else {

        TrapFrame->SegCs |= 3;              // RPL 3 only
        TrapFrame->HardwareSegSs |= 3;      // RPL 3 only

        if (TrapFrame->SegCs < 8) {

            //
            // Create edited trap frame.
            //

            TrapFrame->SegCs = KGDT_R3_CODE | RPL_MASK;
        }

        Eflags &= EFLAGS_USER_SANITIZE;
        Eflags |= EFLAGS_INTERRUPT_MASK;
    }

    //
    // See if we are changing the EFLAGS_V86_MASK.
    //

    V86Change = Eflags ^ TrapFrame->EFlags;

    TrapFrame->EFlags = Eflags;

    if (V86Change & EFLAGS_V86_MASK) {

        //
        // Fix Esp 0 as necessary.
        //

        Ki386AdjustEsp0 (TrapFrame);

        if (TrapFrame->EFlags & EFLAGS_V86_MASK) {

            //
            // Move segment registers for the VDM.
            //

            TrapFrame->V86Gs = InContext->SegGs;
            TrapFrame->V86Fs = InContext->SegFs;
            TrapFrame->V86Es = InContext->SegEs;
            TrapFrame->V86Ds = InContext->SegDs;
            return;
        }
    }

    //
    // Move segment registers for the monitor.
    //

    TrapFrame->SegGs = InContext->SegGs;
    TrapFrame->SegFs = InContext->SegFs;
    TrapFrame->SegEs = InContext->SegEs;
    TrapFrame->SegDs = InContext->SegDs;

    //
    // We are going back to 32 bit monitor code.  Set Trapframe
    // exception list to END_OF_CHAIN such that we won't bugcheck
    // in KiExceptionExit.
    //

    TrapFrame->ExceptionList = EXCEPTION_CHAIN_END;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdm.inc ===
;++
;
;  Copyright (c) 1989  Microsoft Corporation
;
;  Module Name:
;
;     vdm.inc
;
;  Abstract:
;
;     This module contains the structure and constant definitions for
;     the vdm component
;
;  Author:
;
;     Dave Hastings (daveh) 20-Feb-1992
;
;  Revision History
;     Sudeepb (30-Nov-1992)
;     Merged all the equates in one place
;
;--
.386p

TRUE                    equ 1
FALSE                   equ 0

;
; Macro's to only do locked memory operations on MP systems
;

IFDEF NT_UP
MPLOCK equ <>
ELSE
MPLOCK equ <lock>
ENDIF

        page , 132
        subttl "Macro to dispatch exception"

;++
;
; Macro Description:
;
;    This macro allocates exception record on stack, sets up exception
;    record using specified parameters and finally sets up arguments
;    and calls _KiDispatchException.
;
; Arguments:
;
;    ExcepCode - Exception code to put into exception record
;    ExceptFlags - Exception flags to put into exception record
;    ExceptRecord - Associated exception record
;    ExceptAddress - Addr of instruction which the hardware exception occurs
;    NumParms - Number of additional parameters
;    ParameterList - the additional parameter list
;
; Return Value:
;
;    None.
;
;--

DISPATCH_EXCEPTION macro ExceptCode, ExceptFlags, ExceptRecord, ExceptAddress,\
                         NumParms, ParameterList
        local de10, de20

; Set up exception record for raising exception

?i      =       0
        sub     esp, ExceptionRecordSize + NumParms * 4
                                        ; allocate exception record
        mov     dword ptr [esp]+ErExceptionCode, ExceptCode
                                        ; set up exception code
        mov     dword ptr [esp]+ErExceptionFlags, ExceptFlags
                                        ; set exception flags
        mov     dword ptr [esp]+ErExceptionRecord, ExceptRecord
                                        ; set associated exception record
        mov     dword ptr [esp]+ErExceptionAddress, ExceptAddress
        mov     dword ptr [esp]+ErNumberParameters, NumParms
                                        ; set number of parameters
        IRP     z, <ParameterList>
        mov     dword ptr [esp]+(ErExceptionInformation+?i*4), z
?i      =       ?i + 1
        ENDM

; set up arguments and call _KiDispatchException

        mov     ecx, esp                ; (ecx)->exception record

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jz      de10

        mov     eax,0FFFFh
        jmp     de20

de10:   mov     eax,[ebp]+TsSegCs
de20:   and     eax,MODE_MASK

; 1 - set first chance TRUE
; eax - PreviousMode
; ebp - trap frame addr
; 0 - Null exception frame
; ecx - exception record addr

; dispatchexception as appropriate
        stdCall _KiDispatchException, <ecx, 0, ebp, eax, 1>
        add     esp,ExceptionRecordSize + NumParms*4

        ENDM


;
; Prefix Flags
;

PREFIX_ES               equ 00000100h
PREFIX_CS               equ 00000200h
PREFIX_SS               equ 00000400h
PREFIX_DS               equ 00000800h
PREFIX_FS               equ 00001000h
PREFIX_GS               equ 00002000h
PREFIX_OPER32           equ 00004000h
PREFIX_ADDR32           equ 00008000h
PREFIX_LOCK             equ 00010000h
PREFIX_REPNE            equ 00020000h
PREFIX_REP              equ 00040000h
PREFIX_SEG_ALL          equ 00003f00h

NUM_OPCODE              equ 255
;
; Reginfo structure
;

RegInfo struc
RiSegSs         dd 0
RiEsp           dd 0
RiEFlags        dd 0
RiSegCs         dd 0
RiEip           dd 0
RiTrapFrame     dd 0
RiCsLimit       dd 0
RiCsBase        dd 0
RiCsFlags       dd 0
RiSsLimit       dd 0
RiSsBase        dd 0
RiSsFlags       dd 0
RiPrefixFlags   dd 0
RiOperand       dd 0
RegInfo ends
REGINFOSIZE     EQU 56

MAX_VDM_ADDR    EQU 0FFFFFFH

DR7_GLOBAL      EQU 002AAH

;
;Fast Read/Write Defines
;

SVC_DEMFASTREAD     equ 42h
SVC_DEMFASTWRITE    equ 43h
DOS_BOP             equ 50h

;
;
; Size of Exception Record
;

ExceptionRecordSize = (ErNumberParameters + 4 + 3) AND 0fffffffcH ;

;
; Magic value
;

OPCODE_MAGIC    equ  00f5ah

;++
;       diBEGIN - BEGIN index table
;
;       ENTRY   name = name of di table
;               badindex = local label for unspecified entries
;
;       EXIT    ?sindex = specific entry index
;               ?badindex = default index for unspecified entries
;--

diBEGIN macro   name,badindex           ;; Beginning of dispatch table
        ?sopc  = 0
        ?badindex = badindex
name    label   byte                    ;; Start of dispatch table
endm

;++
;       dtI - SPECIFIC index table entry
;
;       ENTRY   opc = opcode value
;               index  = INDEX_ value corresponding to opcode
;               ?badindex = unspecified entry index
;               ?sopc = specific entry index
;
;       EXIT    Unspecified entries prior to "index" filled in;
;               Specified entry filled in.
;               ?sopc = next index to fill in;
;--

dtI     macro   opc,index               ;; Specific entry in dispatch table
        if ?sopc gt opc
            %out dtI: opcode out of order
            .err
        else
            if ?sopc lt opc             ;; Fill unspecified entries
                rept opc - ?sopc
                   db   ?badindex
                endm
            endif
            db    index                 ;; Specified entry
            ?sopc = opc+1               ;; Set new start index
        endif
endm

;++
;       diEND - END index table
;
;       ENTRY   index = highest entry in table
;               ?sopc = specific entry index
;
;       EXIT    rest of the table filled in
;--

diEND   macro   index                   ;; End of dispatch table
        if ?sopc lt index               ;; Fill in rest of table
            rept index - ?sopc
                db    ?badindex
            endm
        db      ?badindex               ;; fill in last entry of table!
        endif
endm


;++
;       dtBEGIN - BEGIN dispatch table
;
;       ENTRY   name = name of dt table
;               badaddr = local label for unspecified entries
;
;       EXIT    ?sindex = specific entry index
;               ?badaddr = default handler for unspecified entries
;--

dtBEGIN macro   name,badaddr            ;; Beginning of dispatch table
        ?sindex  = 0
        ?badaddr = badaddr
name    label   dword                   ;; Start of dispatch table
endm

;++
;       dtS - SPECIFIC dispatch table entry
;
;       ENTRY   index = index of entry
;               addr  = address of handler
;               ?badaddr = unspecified entry handler
;               ?sindex = specific entry index
;
;       EXIT    Unspecified entries prior to "index" filled in;
;               Specified entry filled in.
;               ?sindex = next index to fill in;
;--

dtS     macro   index,addr              ;; Specific entry in dispatch table
        if ?sindex gt index
            %out dtS: index out of order
            .err
        else
            if ?sindex lt index         ;; Fill unspecified entries
                rept index - ?sindex
                   dd   offset FLAT:?badaddr
                endm
            endif
            dd    offset FLAT:addr      ;; Specified entry
            ?sindex = index+1           ;; Set new start index
        endif
endm

;++
;       dtEND - END dispatch table
;
;       ENTRY   index = highest entry in table
;               ?sindex = specific entry index
;
;       EXIT    rest of the table filled in
;--

dtEND   macro   index                   ;; End of dispatch table
        if ?sindex lt index             ;; Fill in rest of table
            rept index - ?sindex
                dd    offset FLAT:?badaddr
            endm
        dd offset FLAT:?badaddr         ;; fill in last entry of table!
        endif
endm

;++
;       CsToLinearPM
;
;--

CsToLinearPM    macro sel, erraddr
        lea     eax,[esi].RiCsLimit
        push    eax
        lea     eax,[esi].RiCsBase
        push    eax
        lea     eax,[esi].RiCsFlags
        push    eax
        push    sel

        call    _Ki386GetSelectorParameters@16
        or      al,al
        jz      erraddr

        test    [esi].RiCsFlags,SEL_TYPE_EXECUTE
        jz      erraddr

        test    [esi].RiCsFlags,SEL_TYPE_2GIG
        jz      @f

        ; Correct limit value for granularity
        shl     [esi].RiCsLimit,12
        or      [esi].RiCsLimit,0FFFh
@@:
endm

;++
;       CsToLinearV86
;
;--

CsToLinearV86 macro
        movzx   eax,word ptr [esi].RiSegCs
        shl     eax,4
	mov	[esi].RiCsBase,eax
        mov     [esi].RiCsLimit,0FFFFh
        mov     [esi].RiCsFlags,0
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\rdwr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rdwr.c

Abstract:

    This module contains routines for read and write for NTDOS. These
    routines saves the switch to user mode. The BOP is handled in the
    kernel for performance reasons. These routines are called only for
    files. Local DOS devices and named pipe operations never come here.

Author:

    Sudeep Bharati (Sudeepb) 04-Mar-1993

Revision History:

--*/
#include "vdmp.h"

VOID
NTFastDOSIO (
    PKTRAP_FRAME TrapFrame,
    ULONG IoType
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NTFastDOSIO)
#endif

#define EFLAGS_CF               0x1
#define EFLAGS_ZF               0x40
#define GETFILEPOINTER(hi,lo)   (((ULONG)hi << 16) + (ULONG)lo)
#define GETHANDLE(hi,lo)        (HANDLE)(((ULONG)hi << 16) + (ULONG)lo)
#define GETBUFFER(hi,lo)        (((ULONG)hi << 4) + lo)
#define SVC_DEMFASTREAD         0x42
#define SVC_DEMFASTWRITE        0x43
#define CONSOLE_HANDLE_SIGNATURE 0x00000003
#define CONSOLE_HANDLE(HANDLE) (((ULONG)(HANDLE) & CONSOLE_HANDLE_SIGNATURE) == CONSOLE_HANDLE_SIGNATURE)
#define STD_INPUT_HANDLE       (ULONG)-10
#define STD_OUTPUT_HANDLE      (ULONG)-11
#define STD_ERROR_HANDLE       (ULONG)-12

VOID
NTFastDOSIO (
    PKTRAP_FRAME TrapFrame,
    ULONG IoType
    )
{
    HANDLE hFile;
    PVOID  lpBuf;
    ULONG  ulBX,ulSI;
    LARGE_INTEGER Large;
    PIO_STATUS_BLOCK IoStatusBlock;
    PFILE_POSITION_INFORMATION CurrentPosition;
    NTSTATUS Status;
    ULONG CountToIO;
    PFILE_END_OF_FILE_INFORMATION EndOfFile;
    PVDM_TIB VdmTib;
    KIRQL OldIrql;

    PAGED_CODE();

    //
    // Clear CF flag and assume success
    //

    TrapFrame->EFlags &= ~EFLAGS_CF;

    //
    // Validate the request
    //

    if (IoType != SVC_DEMFASTREAD && IoType != SVC_DEMFASTWRITE) {
        TrapFrame->EFlags |= EFLAGS_CF;
        return;
    }

    //
    // Signal softpc that we are doing disk io for idle detection.
    //

    try {
        *FIXED_NTVDMSTATE_LINEAR_PC_AT |= VDM_IDLEACTIVITY;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ASSERT (KeGetCurrentIrql () >= APC_LEVEL);
        TrapFrame->EFlags |= EFLAGS_CF;
        return;
    }

    Status = VdmpGetVdmTib(&VdmTib);

    if (!NT_SUCCESS(Status)) { // vdmtib is bad
       ASSERT (KeGetCurrentIrql () >= APC_LEVEL);
       TrapFrame->EFlags |= EFLAGS_CF;
       return;
    }

    IoStatusBlock = (PIO_STATUS_BLOCK) &VdmTib->TempArea1;
    CurrentPosition = (PFILE_POSITION_INFORMATION) &VdmTib->TempArea2;
    EndOfFile = (PFILE_END_OF_FILE_INFORMATION) CurrentPosition;

    try {
        ProbeForWrite (IoStatusBlock, sizeof (IO_STATUS_BLOCK), sizeof (UCHAR));
        ProbeForWrite (CurrentPosition, sizeof (FILE_END_OF_FILE_INFORMATION), sizeof (UCHAR));
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ASSERT (KeGetCurrentIrql () >= APC_LEVEL);
        TrapFrame->EFlags |= EFLAGS_CF;
        return;
    }

    // Get the NT handle
    hFile = GETHANDLE((TrapFrame->Eax & 0x0000ffff),(TrapFrame->Ebp & 0x0000ffff));

    // advance ip past the bop instruction
    // clear carry flag, assuming success
    TrapFrame->Eip += 4;
    ASSERT (KeGetCurrentIrql () >= APC_LEVEL);
    TrapFrame->EFlags &= ~EFLAGS_CF;

    if (CONSOLE_HANDLE(hFile) ||
        hFile == (HANDLE) STD_INPUT_HANDLE ||
        hFile == (HANDLE) STD_OUTPUT_HANDLE ||
        hFile == (HANDLE) STD_ERROR_HANDLE )
      {
        TrapFrame->EFlags |= EFLAGS_CF;
        return;
    }

    // Get the IO buffer
    lpBuf = (PVOID) GETBUFFER(TrapFrame->V86Ds, (TrapFrame->Edx & 0x0000ffff));

    // Get the Count
    CountToIO = TrapFrame->Ecx & 0x0000ffff;

    // Get Seek Parameters
    ulBX = TrapFrame->Ebx & 0x0000ffff;
    ulSI = TrapFrame->Esi & 0x0000ffff;


    //
    // Lower Irql to PASSIVE_LEVEL for io system
    //

    OldIrql = KeGetCurrentIrql();

    KeLowerIrql (PASSIVE_LEVEL);

    //
    // Check if we need to seek
    //

    if (!(TrapFrame->EFlags & EFLAGS_ZF)) {

        Large = RtlConvertUlongToLargeInteger(GETFILEPOINTER(ulBX,ulSI));

        try {
            CurrentPosition->CurrentByteOffset = Large;
        }
        except(EXCEPTION_EXECUTE_HANDLER) {
            goto ErrorExit; // we have caught an exception, error exit
        }

        Status = NtSetInformationFile (hFile,
                                       IoStatusBlock,
                                       CurrentPosition,
                                       sizeof(FILE_POSITION_INFORMATION),
                                       FilePositionInformation);

        if (!NT_SUCCESS(Status)) {
            goto ErrorExit;
        }

        try {
            if (CurrentPosition->CurrentByteOffset.LowPart == -1) {
                goto ErrorExit;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            goto ErrorExit;
        }
    }

    if (IoType == SVC_DEMFASTREAD) {

        Status = NtReadFile (hFile,
                             NULL,
                             NULL,
                             NULL,
                             IoStatusBlock,
                             (PVOID)lpBuf,
                             CountToIO,
                             NULL,
                             NULL);
    }
    else {

        if (CountToIO == 0) {

            Status = NtQueryInformationFile (hFile,
                                             IoStatusBlock,
                                             CurrentPosition,
                                             sizeof(FILE_POSITION_INFORMATION),
                                             FilePositionInformation);

            if (!NT_SUCCESS(Status)) {
                goto ErrorExit;
            }

            try {
                EndOfFile->EndOfFile = CurrentPosition->CurrentByteOffset;
            }
            except(EXCEPTION_EXECUTE_HANDLER) {
                goto ErrorExit; // we have caught an exception, error exit
            }

            Status = NtSetInformationFile (hFile,
                                           IoStatusBlock,
                                           EndOfFile,
                                           sizeof(FILE_END_OF_FILE_INFORMATION),
                                           FileEndOfFileInformation);

            if (NT_SUCCESS(Status)) {
                KeRaiseIrql(OldIrql, &OldIrql);
                return;
            }

            goto ErrorExit;
        }

        Status = NtWriteFile (hFile,
                              NULL,
                              NULL,
                              NULL,
                              IoStatusBlock,
                              (PVOID)lpBuf,
                              CountToIO,
                              NULL,
                              NULL);
    }

    if (Status == STATUS_PENDING) {

        //
        // Operation must complete before return & IoStatusBlock destroyed
        //

        Status = NtWaitForSingleObject (hFile, FALSE, NULL);

        if ( NT_SUCCESS(Status)) {
            try {
                Status = IoStatusBlock->Status;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }
        }
    }

    KeRaiseIrql(OldIrql, &OldIrql);

    if ( NT_SUCCESS(Status) ) {
        TrapFrame->Eax &= 0xffff0000;
        try {
            TrapFrame->Eax |= (USHORT) IoStatusBlock->Information;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }
    }
    else if (IoType == SVC_DEMFASTREAD && Status == STATUS_END_OF_FILE) {
        TrapFrame->Eax &= 0xffff0000;
    }
    else {
        ASSERT (KeGetCurrentIrql () >= APC_LEVEL);
        TrapFrame->EFlags |= EFLAGS_CF;
    }

    return;


ErrorExit:
    KeRaiseIrql(OldIrql, &OldIrql);
    ASSERT (KeGetCurrentIrql () >= APC_LEVEL);
    TrapFrame->EFlags |= EFLAGS_CF;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdmfault.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vdmfault.c

Abstract:

    This module contains the support for dispatching VDM page faults.

Author:

    Sudeep Bharati (sudeepb) 30-Aug-1992

Revision History:

--*/


#include "vdmp.h"

BOOLEAN
VdmDispatchPageFault(
    PKTRAP_FRAME TrapFrame,
    ULONG Mode,
    ULONG FaultAddr
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, VdmDispatchPageFault)
#endif

BOOLEAN
VdmDispatchPageFault(
    PKTRAP_FRAME TrapFrame,
    ULONG Mode,
    ULONG FaultAddr
    )

/*++

Routine Description:

    This routine dispatches a v86 mode page fault to the VDM monitor.
    It verifies that the fault occurred below 1MB.


Arguments:
    TrapFrame
    Mode - 0 - if read
	   1 - if write
    FaultAddr - faulting address

Return Value:

    True if successful, False otherwise

--*/
{
    PVDM_TIB VdmTib;
    NTSTATUS Status;
    KIRQL   OldIrql;

    PAGED_CODE();

    Status = VdmpGetVdmTib (&VdmTib);

    if (!NT_SUCCESS(Status)) {
       return FALSE;
    }

    KeRaiseIrql(APC_LEVEL, &OldIrql);

    //
    // VdmTib is in user mode memory
    //

    if ((TrapFrame->EFlags & EFLAGS_V86_MASK) ||
        (TrapFrame->SegCs != (KGDT_R3_CODE | RPL_MASK))) {

        //
        // If the faulting address is above 1MB return failure.
        //

        if (FaultAddr < 0x100000) {

            try {
                VdmTib->EventInfo.Event = VdmMemAccess;
                VdmTib->EventInfo.InstructionSize = 0;
                VdmTib->EventInfo.FaultInfo.FaultAddr = FaultAddr;
                VdmTib->EventInfo.FaultInfo.RWMode = Mode;
                VdmEndExecution(TrapFrame, VdmTib);
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }
        }
        else {
            Status = STATUS_ILLEGAL_INSTRUCTION;
        }
    }

    KeLowerIrql (OldIrql);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdminit.c ===
#include "vdmp.h"

#include <ntos.h>
#include <zwapi.h>
#include <ntconfig.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, VdmpInitialize)
#endif

#define KEY_VALUE_BUFFER_SIZE 1024

#if DEVL
ULONG VdmBopCount;
#endif

NTSTATUS
VdmpInitialize (
    PVDM_INITIALIZE_DATA VdmInitData
    )

/*++

Routine Description:

    Initialize the address space of a VDM.

Arguments:

    VdmInitData - Supplies the captured initialization data.

Return Value:

    NTSTATUS.

--*/

{
    PETHREAD CurrentThread;
    PVOID OriginalVdmObjects;
    NTSTATUS Status, StatusCopy;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING SectionName;
    UNICODE_STRING WorkString;
    ULONG ViewSize;
    LARGE_INTEGER ViewBase;
    PVOID BaseAddress;
    PVOID destination;
    HANDLE SectionHandle, RegistryHandle;
    PEPROCESS Process = PsGetCurrentProcess();
    ULONG ResultLength;
    ULONG Index;
    PCM_FULL_RESOURCE_DESCRIPTOR ResourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
    PKEY_VALUE_FULL_INFORMATION KeyValueBuffer;
    PCM_ROM_BLOCK BiosBlock;
    ULONG LastMappedAddress;
    PVDM_PROCESS_OBJECTS pVdmObjects;
    PVDMICAUSERDATA pIcaUserData;
    PVOID TrapcHandler;

    PAGED_CODE();

    NtCurrentTeb()->Vdm = NULL;

    //
    // Simple check to sure it is not already initialized.  A final synchronized
    // check is made farther down.
    //

    if (Process->VdmObjects) {
        return STATUS_UNSUCCESSFUL;
    }

    RtlInitUnicodeString (&SectionName, L"\\Device\\PhysicalMemory");

    InitializeObjectAttributes (&ObjectAttributes,
                                &SectionName,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL);

    Status = ZwOpenSection (&SectionHandle,
                            SECTION_ALL_ACCESS,
                            &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    pIcaUserData = VdmInitData->IcaUserData;
    TrapcHandler = VdmInitData->TrapcHandler;

    //
    // Copy the first page of memory into the VDM's address space
    //

    BaseAddress = 0;
    destination = 0;
    ViewSize = 0x1000;
    ViewBase.LowPart = 0;
    ViewBase.HighPart = 0;

    Status = ZwMapViewOfSection (SectionHandle,
                                 NtCurrentProcess(),
                                 &BaseAddress,
                                 0,
                                 ViewSize,
                                 &ViewBase,
                                 &ViewSize,
                                 ViewUnmap,
                                 0,
                                 PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
       ZwClose (SectionHandle);
       return Status;
    }

    StatusCopy = STATUS_SUCCESS;

    try {
        RtlCopyMemory (destination, BaseAddress, ViewSize);
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
       StatusCopy = GetExceptionCode ();
    }

    Status = ZwUnmapViewOfSection (NtCurrentProcess(), BaseAddress);

    if (!NT_SUCCESS(Status) || !NT_SUCCESS(StatusCopy)) {
        ZwClose (SectionHandle);
        return (NT_SUCCESS(Status) ? StatusCopy : Status);
    }

    //
    // Map Rom into address space
    //

    BaseAddress = (PVOID) 0x000C0000;
    ViewSize = 0x40000;
    ViewBase.LowPart = 0x000C0000;
    ViewBase.HighPart = 0;

    //
    // First unmap the reserved memory.  This must be done here to prevent
    // the virtual memory in question from being consumed by some other
    // alloc vm call.
    //

    Status = ZwFreeVirtualMemory (NtCurrentProcess(),
                                  &BaseAddress,
                                  &ViewSize,
                                  MEM_RELEASE);

    //
    // N.B.  This should probably take into account the fact that there are
    // a handful of error conditions that are ok (such as no memory to
    // release).
    //

    if (!NT_SUCCESS(Status)) {
        ZwClose (SectionHandle);
        return Status;
    }

    //
    // Set up and open KeyPath
    //

    InitializeObjectAttributes (&ObjectAttributes,
                                &CmRegistryMachineHardwareDescriptionSystemName,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                (HANDLE)NULL,
                                NULL);

    Status = ZwOpenKey (&RegistryHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        ZwClose(SectionHandle);
        return Status;
    }

    //
    // Allocate space for the data
    //

    KeyValueBuffer = ExAllocatePoolWithTag (PagedPool,
                                            KEY_VALUE_BUFFER_SIZE,
                                            ' MDV');

    if (KeyValueBuffer == NULL) {
        ZwClose(RegistryHandle);
        ZwClose(SectionHandle);
        return STATUS_NO_MEMORY;
    }

    //
    // Get the data for the rom information
    //

    RtlInitUnicodeString (&WorkString, L"Configuration Data");

    Status = ZwQueryValueKey (RegistryHandle,
                              &WorkString,
                              KeyValueFullInformation,
                              KeyValueBuffer,
                              KEY_VALUE_BUFFER_SIZE,
                              &ResultLength);

    if (!NT_SUCCESS(Status)) {
        ExFreePool(KeyValueBuffer);
        ZwClose(RegistryHandle);
        ZwClose(SectionHandle);
        return Status;
    }

    ResourceDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)
        ((PUCHAR) KeyValueBuffer + KeyValueBuffer->DataOffset);

    if ((KeyValueBuffer->DataLength < sizeof(CM_FULL_RESOURCE_DESCRIPTOR)) ||
        (ResourceDescriptor->PartialResourceList.Count < 2)) {

        //
        // No rom blocks.
        //

        ExFreePool(KeyValueBuffer);
        ZwClose(RegistryHandle);
        ZwClose(SectionHandle);
        return STATUS_SUCCESS;
    }

    PartialResourceDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
            ((PUCHAR)ResourceDescriptor +
            sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
            ResourceDescriptor->PartialResourceList.PartialDescriptors[0]
                .u.DeviceSpecificData.DataSize);


    if (KeyValueBuffer->DataLength < ((PUCHAR)PartialResourceDescriptor -
        (PUCHAR)ResourceDescriptor + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
        + sizeof(CM_ROM_BLOCK))) {

        ExFreePool(KeyValueBuffer);
        ZwClose(RegistryHandle);
        ZwClose(SectionHandle);
        return STATUS_ILL_FORMED_SERVICE_ENTRY;
    }

    BiosBlock = (PCM_ROM_BLOCK)((PUCHAR)PartialResourceDescriptor +
                    sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

    Index = PartialResourceDescriptor->u.DeviceSpecificData.DataSize /
                    sizeof(CM_ROM_BLOCK);

    //
    // N.B.  Rom blocks begin on 2K (not necessarily page) boundaries
    //       They end on 512 byte boundaries.  This means that we have
    //       to keep track of the last page mapped, and round the next
    //       Rom block up to the next page boundary if necessary.
    //

    LastMappedAddress = 0xC0000;

    while (Index) {

#if 0
        DbgPrint ("Bios Block, PhysAddr = %lx, size = %lx\n",
                    BiosBlock->Address,
                    BiosBlock->Size);
#endif

        if ((Index > 1) &&
            ((BiosBlock->Address + BiosBlock->Size) == BiosBlock[1].Address)) {

            //
            // Coalesce adjacent blocks
            //

            BiosBlock[1].Address = BiosBlock[0].Address;
            BiosBlock[1].Size += BiosBlock[0].Size;
            Index -= 1;
            BiosBlock += 1;
            continue;
        }

        BaseAddress = (PVOID)(BiosBlock->Address);
        ViewSize = BiosBlock->Size;

        if ((ULONG)BaseAddress < LastMappedAddress) {
            if (ViewSize > (LastMappedAddress - (ULONG)BaseAddress)) {
                ViewSize = ViewSize - (LastMappedAddress - (ULONG)BaseAddress);
                BaseAddress = (PVOID)LastMappedAddress;
            } else {
                ViewSize = 0;
            }
        }

        ViewBase.LowPart = (ULONG)BaseAddress;

        if (ViewSize > 0) {

            Status = ZwMapViewOfSection (SectionHandle,
                                         NtCurrentProcess(),
                                         &BaseAddress,
                                         0,
                                         ViewSize,
                                         &ViewBase,
                                         &ViewSize,
                                         ViewUnmap,
                                         MEM_DOS_LIM,
                                         PAGE_READWRITE);

            if (!NT_SUCCESS(Status)) {
                break;
            }

            LastMappedAddress = (ULONG)BaseAddress + ViewSize;
        }

        Index -= 1;
        BiosBlock += 1;
    }

    //
    // Free up the handles
    //

    ExFreePool(KeyValueBuffer);
    ZwClose(SectionHandle);
    ZwClose(RegistryHandle);

    //
    // Create VdmObjects structure
    //
    // N.B.  We don't use ExAllocatePoolWithQuota because it
    //       takes a reference to the process (which ExFreePool
    //       dereferences).  Since we expect to clean up on
    //       process deletion, we don't need or want the reference
    //       (which will prevent the process from being deleted)
    //

    pVdmObjects = ExAllocatePoolWithTag (NonPagedPool,
                                         sizeof(VDM_PROCESS_OBJECTS),
                                         ' MDV');

    if (pVdmObjects == NULL) {
        return STATUS_NO_MEMORY;
    }

    Status = PsChargeProcessPoolQuota (Process,
                                       NonPagedPool,
                                       sizeof(VDM_PROCESS_OBJECTS));

    if (!NT_SUCCESS (Status)) {
        ExFreePool (pVdmObjects);
        return Status;
    }

    RtlZeroMemory (pVdmObjects, sizeof(VDM_PROCESS_OBJECTS));

    ExInitializeFastMutex (&pVdmObjects->DelayIntFastMutex);
    KeInitializeSpinLock (&pVdmObjects->DelayIntSpinLock);
    InitializeListHead (&pVdmObjects->DelayIntListHead);

    pVdmObjects->pIcaUserData = ExAllocatePoolWithTag (PagedPool,
                                                       sizeof(VDMICAUSERDATA),
                                                       ' MDV');

    if (pVdmObjects->pIcaUserData == NULL) {
        PsReturnPoolQuota (Process, NonPagedPool, sizeof(VDM_PROCESS_OBJECTS));
        ExFreePool (pVdmObjects);
        return STATUS_NO_MEMORY;
    }

    Status = PsChargeProcessPoolQuota (Process,
                                       PagedPool,
                                       sizeof(VDMICAUSERDATA));

    if (!NT_SUCCESS (Status)) {
        PsReturnPoolQuota (Process, NonPagedPool, sizeof(VDM_PROCESS_OBJECTS));
        ExFreePool (pVdmObjects->pIcaUserData);
        ExFreePool (pVdmObjects);
        return Status;
    }

    try {

        //
        // Copy Ica addresses from service data (in user space) into
        // pVdmObjects->pIcaUserData
        //

        ProbeForRead(pIcaUserData, sizeof(VDMICAUSERDATA), sizeof(UCHAR));
        *pVdmObjects->pIcaUserData = *pIcaUserData;

        //
        // Probe static addresses in IcaUserData.
        //

        pIcaUserData = pVdmObjects->pIcaUserData;

        ProbeForWriteHandle (pIcaUserData->phWowIdleEvent);
        ProbeForWriteHandle (pIcaUserData->phMainThreadSuspended);

        ProbeForWrite (pIcaUserData->pIcaLock,
                       sizeof(RTL_CRITICAL_SECTION),
                       sizeof(UCHAR));

        ProbeForWrite (pIcaUserData->pIcaMaster,
                       sizeof(VDMVIRTUALICA),
                       sizeof(UCHAR));

        ProbeForWrite (pIcaUserData->pIcaSlave,
                       sizeof(VDMVIRTUALICA),
                       sizeof(UCHAR));

        ProbeForWriteUlong(pIcaUserData->pIretHooked);
        ProbeForWriteUlong(pIcaUserData->pDelayIrq);
        ProbeForWriteUlong(pIcaUserData->pUndelayIrq);
        ProbeForWriteUlong(pIcaUserData->pDelayIret);
        // We only reference the ULONG which contains the address of the
        // IretBop Table to push the address to the user stack and never
        // actually reference the table.
        ProbeForWriteUlong(pIcaUserData->pAddrIretBopTable);
        ProbeForReadSmallStructure(
                       pIcaUserData->pIcaTimeout,
                       sizeof(LARGE_INTEGER),
                       sizeof(ULONG));

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        PsReturnPoolQuota (Process, NonPagedPool, sizeof(VDM_PROCESS_OBJECTS));
        PsReturnPoolQuota(Process, PagedPool, sizeof(VDMICAUSERDATA));
        ExFreePool (pVdmObjects->pIcaUserData);
        ExFreePool (pVdmObjects);
        return Status;
    }

    //
    // Save a pointer to the main thread for the delayed interrupt DPC routine.
    // To keep the pointer to the main thread valid, reference the thread
    // and don't dereference it until process exit.
    //

    CurrentThread = PsGetCurrentThread ();

    ObReferenceObject (CurrentThread);

    pVdmObjects->MainThread = CurrentThread;

    ASSERT (pVdmObjects->VdmTib == NULL);

    //
    // Carefully mark the process as a vdm (as other threads may be racing to
    // do the same marking).
    //

    OriginalVdmObjects = InterlockedCompareExchangePointer (&Process->VdmObjects, pVdmObjects, NULL);

    if (OriginalVdmObjects != NULL) {
        PsReturnPoolQuota (Process, NonPagedPool, sizeof(VDM_PROCESS_OBJECTS));
        PsReturnPoolQuota(Process, PagedPool, sizeof(VDMICAUSERDATA));
        ExFreePool (pVdmObjects->pIcaUserData);
        ExFreePool (pVdmObjects);
        ObDereferenceObject (CurrentThread);
        return STATUS_UNSUCCESSFUL;
    }

    ASSERT (Process->VdmObjects == pVdmObjects);

    Process->Pcb.VdmTrapcHandler = TrapcHandler;

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdmentry.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vdmentry.c

Abstract:

    This function dispatches to the vdm services

Author:

    Dave Hastings (daveh) 6-Apr-1992

Notes:

    This module will be fleshed out when the great vdm code consolidation
    occurs, sometime soon after the functionality is done.

Revision History:

     24-Sep-1993 Jonle: reoptimize dispatcher to suit the number of services
                        add QueueInterrupt service

--*/

#include "vdmp.h"
#include <ntvdmp.h>

#define VDM_DEFAULT_PM_CLI_TIMEOUT 0xf
ULONG VdmpMaxPMCliTime;

BOOLEAN
VdmpIsVdmProcess(
    VOID
    );

NTSTATUS
VdmpQueryVdmProcess (
    PVDM_QUERY_VDM_PROCESS_DATA VdmProcessData
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, VdmpIsVdmProcess)
#pragma alloc_text(PAGE, VdmpQueryVdmProcess)
#pragma alloc_text(PAGE, NtVdmControl)
#endif

#if DBG
ULONG VdmInjectFailures;
#endif

BOOLEAN
VdmpIsVdmProcess(
    VOID
    )

/*++

Routine Description:

    This function verifies the caller is a VDM process.

Arguments:

    None.

Return Value:

    True if the caller is a VDM process.
    False if not
--*/

{
    PEPROCESS Process;
    PVDM_TIB VdmTib;
    NTSTATUS Status;

    PAGED_CODE();

    Process = PsGetCurrentProcess();

    if (Process->VdmObjects == NULL) {
        return FALSE;
    }

    //
    // Make sure the current thread has valid vdmtib.
    //

    Status = VdmpGetVdmTib(&VdmTib);
    if (!NT_SUCCESS(Status)) {
       return(FALSE);
    }

    //
    // More checking here ...
    //

    return TRUE;
}

NTSTATUS
NtVdmControl(
    IN VDMSERVICECLASS Service,
    IN OUT PVOID ServiceData
    )
/*++

Routine Description:

    386 specific routine which dispatches to the appropriate function
    based on service number.

Arguments:

    Service -- Specifies what service is to be performed
    ServiceData -- Supplies a pointer to service specific data

Return Value:

    if invalid service number: STATUS_INVALID_PARAMETER_1
    else see individual services.


--*/
{
    NTSTATUS Status;
    PVDM_PROCESS_OBJECTS pVdmObjects;
    VDM_INITIALIZE_DATA CapturedVdmInitializeData;
    PVDM_TIB VdmTib;

    PAGED_CODE();

    //
    // Allow any process to call this API to check if a process handle specifies
    // and NTVDM process.
    //
    if (Service == VdmQueryVdmProcess) {
        return VdmpQueryVdmProcess((PVDM_QUERY_VDM_PROCESS_DATA)ServiceData);
    }

    //
    // Make sure current process is VDMAllowed
    //

    if (!(PsGetCurrentProcess()->Flags & PS_PROCESS_FLAGS_VDM_ALLOWED)) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Make sure the caller is ntvdm.  Except ...
    //     VdmInitialize     - the vdm state is not fully initialized to
    //                         perform the check
    //

    if ((Service != VdmInitialize) &&
        (PsGetCurrentProcess()->VdmObjects == NULL)) {

        return STATUS_ACCESS_DENIED;
    }

    //
    // Some services required a valid VdmTib
    //

    Status = VdmpGetVdmTib(&VdmTib);
    if (!NT_SUCCESS(Status)) {
       VdmTib = NULL;
    }

    try {

        //
        //  Dispatch in descending order of frequency
        //
        if (Service == VdmStartExecution && VdmTib) {
            Status = VdmpStartExecution();
        } else if (Service == VdmQueueInterrupt) {
            Status = VdmpQueueInterrupt(ServiceData);
        } else if (Service == VdmDelayInterrupt) {
            Status = VdmpDelayInterrupt(ServiceData);
        } else if (Service == VdmQueryDir && VdmTib) {
            Status = VdmQueryDirectoryFile(ServiceData);
        } else if (Service == VdmInitialize) {
            VdmpMaxPMCliTime = VDM_DEFAULT_PM_CLI_TIMEOUT;
            ProbeForRead(ServiceData, sizeof(VDM_INITIALIZE_DATA), 1);
            RtlCopyMemory (&CapturedVdmInitializeData, ServiceData, sizeof (VDM_INITIALIZE_DATA));
            Status = VdmpInitialize(&CapturedVdmInitializeData);
        } else if (Service == VdmFeatures) {
            //
            // Verify that we were passed a valid user address
            //
            ProbeForWriteBoolean((PBOOLEAN)ServiceData);

            //
            // Return the appropriate feature bits to notify
            // ntvdm which modes (if any) fast IF emulation is
            // available for
            //

            *((PULONG)ServiceData) = KeI386VirtualIntExtensions &
                    ~PM_VIRTUAL_INT_EXTENSIONS;
            Status = STATUS_SUCCESS;

        } else if (Service == VdmSetInt21Handler && VdmTib) {
            ProbeForRead(ServiceData, sizeof(VDMSET_INT21_HANDLER_DATA), 1);

            Status = Ke386SetVdmInterruptHandler(
                KeGetCurrentThread()->ApcState.Process,
                0x21L,
                (USHORT)(((PVDMSET_INT21_HANDLER_DATA)ServiceData)->Selector),
                ((PVDMSET_INT21_HANDLER_DATA)ServiceData)->Offset,
                ((PVDMSET_INT21_HANDLER_DATA)ServiceData)->Gate32
                );

        } else if (Service == VdmPrinterDirectIoOpen && VdmTib) {
            Status = VdmpPrinterDirectIoOpen(ServiceData);
        } else if (Service == VdmPrinterDirectIoClose && VdmTib) {
            Status = VdmpPrinterDirectIoClose(ServiceData);
        } else if (Service == VdmPrinterInitialize && VdmTib) {
            Status = VdmpPrinterInitialize(ServiceData);
        } else if (Service == VdmSetLdtEntries && VdmTib) {
            ProbeForRead(ServiceData, sizeof(VDMSET_LDT_ENTRIES_DATA), 1);

            Status = PsSetLdtEntries(
                ((PVDMSET_LDT_ENTRIES_DATA)ServiceData)->Selector0,
                ((PVDMSET_LDT_ENTRIES_DATA)ServiceData)->Entry0Low,
                ((PVDMSET_LDT_ENTRIES_DATA)ServiceData)->Entry0Hi,
                ((PVDMSET_LDT_ENTRIES_DATA)ServiceData)->Selector1,
                ((PVDMSET_LDT_ENTRIES_DATA)ServiceData)->Entry1Low,
                ((PVDMSET_LDT_ENTRIES_DATA)ServiceData)->Entry1Hi
                );
        } else if (Service == VdmSetProcessLdtInfo && VdmTib) {
            PPROCESS_LDT_INFORMATION ldtInfo;
            ULONG length;

            ProbeForRead(ServiceData, sizeof(VDMSET_PROCESS_LDT_INFO_DATA), 1);

            ldtInfo = ((PVDMSET_PROCESS_LDT_INFO_DATA)ServiceData)->LdtInformation;
            length = ((PVDMSET_PROCESS_LDT_INFO_DATA)ServiceData)->LdtInformationLength;

            ProbeForRead(ldtInfo, length, 1);
            Status = PsSetProcessLdtInfo(ldtInfo, length);
        } else if (Service == VdmAdlibEmulation && VdmTib) {
            //
            // Ntvdm calls here to do adlib emulation under the following conditions:
            //   ADLIB_DIRECT_IO - only If a FM synth device is opened for exclusive access.
            //   ADLIB_KERNEL_EMULATION - otherwise.
            //   Note ADLIB_USER_EMULATION is defaulted.  It is basically used by external
            //   ADLIB/SB vdds.
            //
            ProbeForRead(ServiceData, sizeof(VDM_ADLIB_DATA), 1);
            pVdmObjects = PsGetCurrentProcess()->VdmObjects;

            if (((PVDM_ADLIB_DATA)ServiceData)->Action == ADLIB_DIRECT_IO) {
                Status = STATUS_ACCESS_DENIED;
            } else {
                pVdmObjects->AdlibAction        = ((PVDM_ADLIB_DATA)ServiceData)->Action;
                pVdmObjects->AdlibPhysPortStart = ((PVDM_ADLIB_DATA)ServiceData)->PhysicalPortStart;
                pVdmObjects->AdlibPhysPortEnd   = ((PVDM_ADLIB_DATA)ServiceData)->PhysicalPortEnd;
                pVdmObjects->AdlibVirtPortStart = ((PVDM_ADLIB_DATA)ServiceData)->VirtualPortStart;
                pVdmObjects->AdlibVirtPortEnd   = ((PVDM_ADLIB_DATA)ServiceData)->VirtualPortEnd;
                pVdmObjects->AdlibIndexRegister = 0;
                pVdmObjects->AdlibStatus        = 0x6;  // OPL2 emulation
                Status = STATUS_SUCCESS;
            }
        } else if (Service == VdmPMCliControl) {
            pVdmObjects = PsGetCurrentProcess()->VdmObjects;
            ProbeForRead(ServiceData, sizeof(VDM_PM_CLI_DATA), 1);

            Status = STATUS_SUCCESS;
            switch (((PVDM_PM_CLI_DATA)ServiceData)->Control) {
            case PM_CLI_CONTROL_DISABLE:
                pVdmObjects->VdmControl &= ~PM_CLI_CONTROL;
                break;
            case PM_CLI_CONTROL_ENABLE:
                pVdmObjects->VdmControl |= PM_CLI_CONTROL;
                if ((*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_VIRTUAL_INTERRUPTS) == 0) {
                    VdmSetPMCliTimeStamp(TRUE);
                }
                break;
            case PM_CLI_CONTROL_CHECK:
                VdmCheckPMCliTimeStamp();
                break;
            case PM_CLI_CONTROL_SET:
                VdmSetPMCliTimeStamp(FALSE);
                break;
            case PM_CLI_CONTROL_CLEAR:
                VdmClearPMCliTimeStamp();
                break;
            default:
                Status = STATUS_INVALID_PARAMETER_1;
            }
        } else {
            Status = STATUS_INVALID_PARAMETER_1;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
#if DBG
    if (PsGetCurrentProcess()->VdmObjects != NULL) {
        if (VdmInjectFailures != 0) {
            PS_SET_BITS (&PsGetCurrentProcess()->Flags,
                         PS_PROCESS_INJECT_INPAGE_ERRORS);
        }
    }
#endif

    ASSERT(KeGetCurrentIrql () == PASSIVE_LEVEL);
    return Status;

}

VOID
VdmCheckPMCliTimeStamp (
    VOID
    )

/*++

Routine Description:

    This routine checks if interrupts are disabled for too long by protected
    mode apps.  If ints are disabled for over predefined limit, they will be
    reenabled such that ntvdm will be able to dispatch pending interrupts.

    Note, V86 mode should NOT call this function.

Arguments:

    None.

Return Value:

    None.


--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects;
    PKPROCESS process = (PKPROCESS)PsGetCurrentProcess();
    NTSTATUS status;
    PVDM_TIB vdmTib;

    pVdmObjects = ((PEPROCESS)process)->VdmObjects;
    if (pVdmObjects->VdmControl & PM_CLI_CONTROL &&
        pVdmObjects->PMCliTimeStamp != 0) {
        if (((process->UserTime + 1)- pVdmObjects->PMCliTimeStamp) >= VdmpMaxPMCliTime) {
            pVdmObjects->PMCliTimeStamp = 0;
            try {

                *FIXED_NTVDMSTATE_LINEAR_PC_AT |= VDM_VIRTUAL_INTERRUPTS;
                status = VdmpGetVdmTib(&vdmTib);
                if (NT_SUCCESS(status)) {
                    vdmTib->VdmContext.EFlags |= EFLAGS_INTERRUPT_MASK;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }
        }
    }
}

VOID
VdmSetPMCliTimeStamp (
    BOOLEAN Reset
    )

/*++

Routine Description:

    This routine checks if interrupts are disabled for too long by protected
    mode apps.  If ints are disabled for over predefined limit, they will be
    reenabled such that ntvdm will be able to dispatch pending interrupts.

    Note, V86 mode should NOT call this function.

Arguments:

    Reset - a Bool value to indicate should we re-set the count if it is not zero

Return Value:

    None.


--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects;
    PKPROCESS process = (PKPROCESS)PsGetCurrentProcess();

    pVdmObjects = ((PEPROCESS)process)->VdmObjects;
    if (pVdmObjects->VdmControl & PM_CLI_CONTROL) {
        if (Reset || pVdmObjects->PMCliTimeStamp == 0) {
            pVdmObjects->PMCliTimeStamp = process->UserTime + 1;
        }
    }
}

VOID
VdmClearPMCliTimeStamp (
    VOID
    )

/*++

Routine Description:

    This routine checks if interrupts are disabled for too long by protected
    mode apps.  If ints are disabled for over predefined limit, they will be
    reenabled such that ntvdm will be able to dispatch pending interrupts.

    Note, V86 mode should NOT call this function.

Arguments:

    None.

Return Value:

    None.


--*/
{
    PVDM_PROCESS_OBJECTS pVdmObjects;

    pVdmObjects = PsGetCurrentProcess()->VdmObjects;
    if (pVdmObjects->VdmControl & PM_CLI_CONTROL) {
        pVdmObjects->PMCliTimeStamp = 0;
    }
}

NTSTATUS
VdmpQueryVdmProcess (
    PVDM_QUERY_VDM_PROCESS_DATA QueryVdmProcessData
    )

/*++

Routine Description:

    This routine checks if the process handle specifies a ntvdm process.
    If the specified process has VDM_ALLOW bit set and it has VdmObject kernel
    mode structure allocated, then it is a VDM process.

Arguments:

    QueryVdmProcessData - supplies a pointer to a user mode VDM_QUERY_VDM_PROCESS_DATA

Return Value:

    NTSTATUS
    The QueryVdmProcessData is filled in only when return status is STATUS_SUCCESS


--*/
{
    NTSTATUS st = STATUS_SUCCESS;
    HANDLE processHandle;
    PEPROCESS process;
    BOOLEAN flag;
    KPROCESSOR_MODE PreviousMode;

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {

            //
            // Verify that we were passed a valid user address
            //
            ProbeForRead(&(QueryVdmProcessData->ProcessHandle), sizeof(HANDLE), sizeof(UCHAR));

            processHandle = QueryVdmProcessData->ProcessHandle;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    } else {
        processHandle = QueryVdmProcessData->ProcessHandle;
    }
    st = ObReferenceObjectByHandle(
            processHandle,
            PROCESS_QUERY_INFORMATION,
            PsProcessType,
            KeGetPreviousMode(),
            (PVOID *)&process,
            NULL
            );

    if ( !NT_SUCCESS(st) ) {
        return st;
    }

    if (process->Flags & PS_PROCESS_FLAGS_VDM_ALLOWED && process->VdmObjects) {
        flag = TRUE;
    } else {
        flag = FALSE;
    }

    ObDereferenceObject(process);

    try {

        //
        // Verify the user address is writable.
        //

        ProbeForWrite(&(QueryVdmProcessData->IsVdmProcess), sizeof(BOOLEAN), sizeof(UCHAR));
        QueryVdmProcessData->IsVdmProcess = flag;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        st = GetExceptionCode();
    }

    return st;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdmop0f.asm ===
title "Opcode 0f Instruction Emulation"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    vdmop0f.asm
;
;Abstract:
;
;    This module contains the support for the 0f opcodes that are emulated
;    (such as LMSW, mov to/from CR0, mov to/from DR?).
;
;
;Author:
;
;    Dave Hastings (daveh) 23-Feb-1992
;
;Notes:
;
;    This file needs to be modified for Kenr's NPX changes, i.e. what to
;    do with CR0 values
;
;
;Revision History:
;
;--
.386p

        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
include mi386.inc
include vdm.inc

        page ,132
;   Force assume into place

_PAGE   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_PAGE   ENDS

_PAGE   SEGMENT DWORD USE32 PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING

        extrn OpcodeInvalid:proc
VdmOpcodeInvalid equ OpcodeInvalid

        extrn CheckEip:proc
        extrn VdmDecodeOperand:proc
        extrn RegTab:dword
        EXTRNP ___KeGetCurrentThread,0
        extrn  KiVdmSetUserCR0:proc
        extrn _VdmUserCr0MapOut:byte

;
; This table is used to dispatch the special register moves
;
; WARNING Trx not implemented.

SpecialRegTab dd offset VdmOpcodeGetCrx
        dd offset VdmOpcodeGetDrx
        dd offset VdmOpcodeSetCrx
        dd offset VdmOpcodeSetDrx
;        dd offset VdmOpcodeGetTrx
        dd offset VdmOpcodeInvalid
        dd offset VdmOpcodeInvalid
;        dd offset VdmOpcodeSetTrx
        dd offset VdmOpcodeInvalid

;
; This table is used to locate the debug register contents in the trap frame
; The values for DR4, DR5 should never be used, since these registers are
; reserved by intel
;
DrTab   dd TsDr0
        dd TsDr1
        dd TsDr2
        dd TsDr3
        dd 0BADF00Dh            ; hopefully this will fault if used (dr4)
        dd 0BADF00Dh            ; hopefully this will fault if used (dr5)
        dd TsDr6
        dd TsDr7

_PAGE   ENDS


_PAGE   SEGMENT DWORD USE32 PUBLIC 'CODE'
        ASSUME DS:FLAT, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl "Emulate 0f opcodes"
;++
;
;   Routine Description:
;
;       This routine dispatches for the opcode 0f emulation.  Currently,
;       only LMSW, MOV to/from CR0, and MOV to /from DRx are emulated.
;       The others cause access violations in user mode.
;
;       Interrupts are disabled upon entry, and enabled upon exit
;
;   Arguments:
;
;       esi = address of reg info
;
;   Returns:
;
;       EAX = true if the opcode was emulated.
;               reginfo updated
;       EAX = false if the opcode was not emulated
;
;
        public VdmOpcode0f
VdmOpcode0f proc


        push    ebp
        mov     ebp,esp
        push    edi

;
; Construct address of next opcode byte, and check for gp fault
;
        inc     [esi].RiEip
        call    CheckEip
        test    al,0fh
        jz      of40                    ; Gp fault, report error

        mov     edi,[esi].RiCsBase
        add     edi,[esi].RiEip
        movzx   edx,byte ptr [edi]
        cmp     edx,MI_LMSW_OPCODE
        jne     of10

        call    VdmOpcodeLmsw
        jmp     of30                    ; return

of10:   cmp     edx,MI_CLTS_OPCODE
        jne     of20

        call    VdmOpcodeClts
        jmp     of30                    ; return

of20:   cmp     edx,MI_GET_CRx_OPCODE
        jb      of40                    ; return error

        cmp     edx,MI_SET_TRx_OPCODE
        ja      of40                    ; return error

        sub     edx,MI_GET_CRx_OPCODE
        call    SpecialRegTab[edx * 4]

of30:
        pop     edi
        mov     esp,ebp
        pop     ebp

        ret

of40:   xor     eax,eax
        jmp     of30

VdmOpcode0f endp

        page ,132
        subttl "Emulate LMSW"
;++
;
;    Routine Desription:
;
;       This routine emulates the LMSW instruction.  It allows the dos
;       application to set or clear EM and MP.  It forces MP to be set
;       when EM is clear.  It ignores to change any of the other bits.
;
;    Arguments:
;
;       esi = pointer to reg info
;
;    Returns:
;
;       EAX = true if the opcode was emulated.
;               reginfo updated
;       EAX = false if the opcode was not emulated.
;
        public VdmOpcodeLmsw
VdmOpcodeLmsw proc

        push    ebp
        mov     ebp,esp
        push    edi
        push    esi
        push    ebx
;
; Check reg field of mod r/m byte to see if this is really an Lmsw
;

        inc     [esi].RiEip
        call    CheckEip
        test    al,0fh
        jz      ol30                    ; gp fault

        mov     edi,[esi].RiEip
        add     edi,[esi].RiCsBase
        movzx   edx,byte ptr [edi]
        and     edx,MI_REGMASK
        cmp     edx,MI_REGLMSW          ; check for the additional opcode bits
        jne     ol40                    ; not lmsw, return error.

;
; Turn off the 32 bit operand prefix (lmsw always uses 16 bit operands)
;
        and     [esi].RiPrefixFlags,NOT PREFIX_OPER32
;
; Get the linear address of the value to put into the MSW.
;
        mov     eax,1                   ; read operand
        call    VdmDecodeOperand

        test    al,0fh
        jz      ol30                    ; error reading operand

        mov     edi,[esi].RiOperand
        mov     eax,[edi]

        call    KiVdmSetUserCR0

        mov     eax,1                   ; indicate success
ol30:   pop     ebx
        pop     esi
        pop     edi
        mov     esp,ebp
        pop     ebp
        ret

ol40:   xor     eax,eax
        jmp     ol30

VdmOpcodeLmsw endp

        page ,132
        subttl "Emulate CLTS"
;++
;
;    Routine Description:
;
;       This routine emulates CLTS by ignoring it.
;
;    Arguments:
;
;       esi = pointer to reg info
;
;    Returns:
;
;       eax = 1
;
        public VdmOpcodeClts
VdmOpcodeClts proc
        inc     [esi].RiEip             ; skip second byte
        mov     eax,1
        ret
VdmOpcodeClts endp

        page ,132
        subttl "Emulate GetCRx"
;++
;
;    Routine Description:
;
;       This routine emulates the GetCRx opcodes.  For now, it returns the
;       contents of CR0 unmodified, and 0 for all other CR?
;
;    Arguments:
;
;       esi = pointer to reg info
;
;    Returns:
;
;       eax = true if the opcode was emulated
;               reginfo updated.
;       eax = false if the opcode was not emulated.
;
        public VdmOpcodeGetCrx
VdmOpcodeGetCrx proc

        push    ebp
        mov     ebp,esp
        push    edi

        inc     [esi].RiEip
        call    CheckEip
        test    al,0fh
        jz      ogc40                   ; Gp fault, report error

        mov     edi,[esi].RiEip
        add     edi,[esi].RiCsBase
        inc     [esi].RiEip
        movzx   edx,byte ptr [edi]
;
; Verify the Mod field for mov special
;
        and     edx,MI_MODMASK
        cmp     edx,MI_MODMOVSPEC       ; require for mov to/from special
        jne     short ogc50             ; return error

        movzx   edx,byte ptr [edi]
        test    edx,MI_REGMASK          ; mov from CR0?
        mov     eax,0                   ; assume 0
        jne     short ogc30

        mov     edi, PCR[PcPrcbData+PbCurrentThread]
        mov     edi,[edi].ThInitialStack        ; (edi) = fp save area
        sub     edi, NPX_FRAME_LENGTH
        mov     edi,[edi].FpCr0NpxState         ; get users bits
        and     edi, CR0_MP+CR0_EM+CR0_PE       ; mask
        movzx   edi,_VdmUserCr0MapOut[edi]      ; map to real settings

        mov     eax, cr0                        ; read CR0
        and     eax, not (CR0_MP+CR0_EM+CR0_TS) ; clear npx bits
        or      eax, edi                        ; set npx bits

;
; Pull the destination register from the R/M field
;
ogc30:  and     edx,MI_RMMASK
        mov     edi,[esi].RiTrapFrame
        mov     edx,RegTab[edx * 4]     ; get register offset
        mov     [edx + edi],eax         ; store CR? contents into register
        mov     eax,1
ogc40:  pop     edi
        mov     esp,ebp
        pop     ebp
        ret

ogc50:  xor     eax,eax
        jmp     ogc40

VdmOpcodeGetCrx endp


        page ,132
        subttl "Emulate SetCRx"
;++
;
;    Routine Description:
;
;       This routine emulates the SetCRx opcodes.  For now, it only emulates
;       set CR0, and only for the same conditions as LMSW.  It causes a fault
;       for all other CR?
;
;    Arguments:
;
;       esi = pointer to reg info
;
;    Returns:
;
;       eax = true if the opcode was emulated
;               reginfo updated.
;       eax = false if the opcode was not emulated.
;
        public VdmOpcodeSetCrx
VdmOpcodeSetCrx proc

        push    ebp
        mov     ebp,esp
        push    edi
        push    esi
        push    ebx

        inc     [esi].RiEip
        call    CheckEip
        test    al,0fh
        jz      osc40                   ; Gp fault, report error

        mov     edi,[esi].RiEip
        add     edi,[esi].RiCsBase
        inc     [esi].RiEip
        movzx   edx,byte ptr [edi]
;
; Verify the Mod field for mov special
;
        and     edx,MI_MODMASK
        cmp     edx,MI_MODMOVSPEC       ; require for mov to/from special
        jne     osc50                   ; return error

        movzx   edx,byte ptr [edi]
        test    edx,MI_REGMASK          ; mov to CR0?
        jne     osc50                   ; no, return error

;
; Get the source register from the R/M field
;
        and     edx,MI_RMMASK
        mov     edi,[esi].RiTrapFrame
        mov     edx,RegTab[edx * 4]     ; get register offset
        mov     eax,[edx + edi]         ; get CR? contents from register

        call    KiVdmSetUserCR0

        mov     eax,1
osc40:  pop     ebx
        pop     esi
        pop     edi
        mov     esp,ebp
        pop     ebp
        ret

osc50:  xor     eax,eax
        jmp     osc40

VdmOpcodeSetCrx endp

        page ,132
        subttl "Emulate GetDRx"
;++
;
;    Routine Description:
;
;       This routine emulates the GetDRx opcodes.  For DR0-DR3, it returns the
;       values from the user mode trap frame.  For DR4-DR5, it returns 0.  For
;       DR6 and DR7, it returns the bits from the user mode trap frame that are
;       settable from user mode.
;
;    Arguments:
;
;       esi = pointer to reg info
;
;    Returns:
;
;       eax = true if the opcode was emulated
;               reginfo updated.
;       eax = false if the opcode was not emulated.
;
        public VdmOpcodeGetDrx
VdmOpcodeGetDrx proc

ModRm   equ     [ebp - 4]

        push    ebp
        mov     ebp,esp
        sub     esp,4
        push    edi
        push    ecx

        inc     [esi].RiEip
        call    CheckEip
        test    al,0fh
        jz      ogd50                   ; Gp fault, report error

        mov     edi,[esi].RiEip
        add     edi,[esi].RiCsBase
        inc     [esi].RiEip
        movzx   edx,byte ptr [edi]
        mov     ModRm,edx
;
; Verify the Mod field
;
        and     edx,MI_MODMASK
        cmp     edx,MI_MODMOVSPEC       ; require for mov special
        jne     ogd60                   ; return error

        mov     edi,[esi].RiTrapFrame
;
; Get the Dr number
;
        mov     edx,ModRm
        and     edx,MI_REGMASK
        shr     edx,MI_REGSHIFT
;
; If it is DR4 or DR5, set the destination register to zero
;
        cmp     edx,4
        jb      ogd20

        cmp     edx,5
        ja      ogd20

        mov     eax,0                   ; set the destination to zero
        jmp     ogd40
;
; Otherwise, use the actual user mode register contents
;
ogd20:  mov     ecx,DrTab[edx * 4]
        mov     eax,[edi + ecx]         ; get register value
        cmp     edx,6                   ; do we need to sanitize?
        jb      ogd40                   ; no.

        cmp     edx,7
        je      ogd30

        and     eax,DR6_LEGAL
        jmp     ogd40

ogd30:  and     eax,DR7_LEGAL
;
; Get destination register from opcode, and store Dr contents
;
ogd40:  mov     edx,ModRm
        and     edx,MI_RMMASK
        mov     ecx,RegTab[edx * 4]
        mov     [ecx + edi],eax         ; set user mode register

        mov     eax,1                   ; indicate success
ogd50:  pop     ecx
        pop     edi
        mov     esp,ebp
        pop     ebp
        ret

ogd60:  xor     eax,eax                 ; indicate error
        jmp     ogd50

VdmOpcodeGetDrx endp

        page ,132
        subttl "Emulate SetDRx"
;++
;
;    Routine Description:
;
;       This routine emulates the SetDRx opcodes.  For DR0-DR3, it will set
;       the user mode register to any linear address up to 16MB.  For DR4-DR5,
;       it will ignore the instruction.  For DR6 and DR7, it will set the bits
;       that are user mode setable.  For DR7, it also translates the global
;       bits to local bits.
;
;    Arguments:
;
;       esi = pointer to reg info
;
;    Returns:
;
;       eax = true if the opcode was emulated
;               reginfo updated.
;       eax = false if the opcode was not emulated.
;
        public VdmOpcodeSetDrx
VdmOpcodeSetDrx proc

ModRm   equ     [ebp - 4]

        push    ebp
        mov     ebp,esp
        sub     esp,4
        push    edi
        push    ecx

        inc     [esi].RiEip
        call    CheckEip
        test    al,0fh
        jz      osd80                   ; Gp fault, report error

        mov     edi,[esi].RiEip
        add     edi,[esi].RiCsBase
        inc     [esi].RiEip
        movzx   edx,byte ptr [edi]
        mov     ModRm,edx
;
; Verify the Mod field
;
        and     edx,MI_MODMASK
        cmp     edx,MI_MODMOVSPEC       ; require for mov special
        jne     osd90                   ; return error
;
; Get value to put into debug register
;
        mov     edi,[esi].RiTrapFrame
        mov     edx,ModRm
        and     edx,MI_RMMASK
        mov     edx,RegTab[edx * 4]
        mov     eax,[edi + edx]
;
; Determine which debug register it goes into, and sanitize appropriately
;
        mov     edx,ModRm
        and     edx,MI_REGMASK
        shr     edx,MI_REGSHIFT
        cmp     edx,4
        jnb     osd20
;
; DR0-DR4, make linear address < 16MB
;
        and     eax,MAX_VDM_ADDR
        jmp     osd60

osd20:  cmp     edx,6
        jnb     osd30
;
; DR4-DR5, just return
;
        jmp     osd70                   ; return success

osd30:  cmp     edx,6
        jne     osd40

;
; DR6, mask for legal bits
;
        and     eax,DR6_LEGAL
        jmp     osd60

;
; DR7, mask for legal bits, and translate g to l, and activate debug
;
osd40:  mov     ecx,eax
        and     ecx,DR7_GLOBAL
        shr     ecx,1                   ; translate the G to L by shifting
        or      eax,ecx                 ; put in any new bits
        and     eax,DR7_LEGAL           ; sanitize the value

;
; Put the value into the user mode register
;
osd60:  mov     ecx,DrTab[edx * 4]
        mov     [edi + ecx],eax
        cmp     edx,7
        jne     osd70

        mov     ecx,eax
        stdCall ___KeGetCurrentThread
        test    ecx,DR7_ACTIVE
        jz      osd65

        mov     byte ptr [eax].ThDebugActive,1   ; set debugging active for this thread
        jmp     osd70

osd65:  mov     byte ptr [eax].ThDebugActive,0
osd70:  mov     eax,1
osd80:  pop     ecx
        pop     edi
        mov     esp,ebp
        pop     ebp
        ret

osd90:  xor     eax,eax
        jmp     osd80

VdmOpcodeSetDrx endp

_PAGE ends

      end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdmnpx.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vdmnpx.c

Abstract:

    This module contains the support for Vdm use of the npx.

Author:

    Dave Hastings (daveh) 02-Feb-1992


Revision History:
    18-Dec-1992 sudeepb Tuned all the routines for performance

--*/

#include "vdmp.h"
#include <ntos.h>
#include <vdmntos.h>

#ifdef ALLOC_PRAGMA
#pragma  alloc_text(PAGE, VdmDispatchIRQ13)
#pragma  alloc_text(PAGE, VdmSkipNpxInstruction)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
static const UCHAR MOD16[] = { 0, 1, 2, 0 };
static const UCHAR MOD32[] = { 0, 1, 4, 0 };
const UCHAR VdmUserCr0MapIn[] = {
    /* !EM !MP */       0,
    /* !EM  MP */       CR0_PE,             // Don't set MP, but shadow users MP setting
    /*  EM !MP */       CR0_EM,
    /*  EM  MP */       CR0_EM | CR0_MP
    };

const UCHAR VdmUserCr0MapOut[] = {
    /* !EM !MP !PE */   0,
    /* !EM !MP  PE */   CR0_MP,
    /* !EM  MP !PE */   CR0_MP,             // setting not valid
    /* !EM  MP  PE */   CR0_MP,             // setting not valid
    /*  EM !MP !PE */   CR0_EM,
    /*  EM !MP  PE */   CR0_EM | CR0_MP,    // setting not valid
    /*  EM  MP !PE */   CR0_EM | CR0_MP,
    /*  EM  MP  PE */   CR0_EM | CR0_MP     // setting not valid
    };


BOOLEAN
VdmDispatchIRQ13(
    PKTRAP_FRAME TrapFrame
    )
/*++

aRoutine Description:

    This routine reflects an IRQ 13 event to the usermode monitor for this
    vdm.  The IRQ 13 must be reflected to usermode, so that it can properly
    be raised as an interrupt through the virtual PIC.

Arguments:

    none

Return Value:

    TRUE if the event was reflected
    FALSE if not

--*/
{
    EXCEPTION_RECORD ExceptionRecord;
    PVDM_TIB VdmTib;
    BOOLEAN Success;
    NTSTATUS Status;

    PAGED_CODE();

    Status = VdmpGetVdmTib(&VdmTib);
    if (!NT_SUCCESS(Status)) {
       return FALSE;
    }

    Success = TRUE;

    try {
        VdmTib->EventInfo.Event = VdmIrq13;
        VdmTib->EventInfo.InstructionSize = 0L;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ExceptionRecord.ExceptionCode = GetExceptionCode();
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.NumberParameters = 0;
        ExRaiseException(&ExceptionRecord);
        Success = FALSE;
    }

    if (Success)  {             // insure that we do not redispatch an exception
        try {
            VdmEndExecution(TrapFrame,VdmTib);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }
    }

    return TRUE;
}

BOOLEAN
VdmSkipNpxInstruction(
    PKTRAP_FRAME TrapFrame,
    ULONG        Address32Bits,
    PUCHAR       istream,
    ULONG        InstructionSize
    )
/*++

Routine Description:

    This functions gains control when the system has no installed
    NPX support, but the thread has cleared its EM bit in CR0.

    The purpose of this function is to move the instruction
    pointer forward over the current NPX instruction.

Enviroment:

    V86 MODE ONLY, first opcode byte already verified to be 0xD8 - 0xDF.

Arguments:

Return Value:

    TRUE if trap frame was modified to skip the NPX instruction

--*/
{
    UCHAR       ibyte, Mod, rm;

    if (KeI386NpxPresent) {

        //
        // We should only get here if the thread is executing garbage so
        // just return and dispatch the error to the app.
        //

        return FALSE;
    }

    //
    // This NPX instruction should be skipped
    //

    //
    // Get ModR/M byte for NPX opcode
    //

    istream += 1;

    try {
        ibyte = *istream;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    InstructionSize += 1;

    if (ibyte <= 0xbf) {

        //
        // Within ModR/M range for addressing, process it.
        //

        Mod = ibyte >> 6;
        rm  = ibyte & 0x7;

        if (Address32Bits) {

            InstructionSize += MOD32 [Mod];

            if (Mod == 0  &&  rm == 5) {
                // disp 32
                InstructionSize += 4;
            }

            //
            // If SIB byte, read it
            //

            if (rm == 4) {
                istream += 1;

                try {
                    ibyte = *istream;
                } except (EXCEPTION_EXECUTE_HANDLER) { 
                    return FALSE;
                }

                InstructionSize += 1;

                if (Mod == 0  &&  (ibyte & 7) == 5) {
                    // disp 32
                    InstructionSize += 4;
                }
            }

        } else {
            InstructionSize += MOD16 [Mod];
            if (Mod == 0  &&  rm == 6) {
                // disp 16
                InstructionSize += 2;
            }
        }
    }

    //
    // Adjust Eip to skip NPX instruction
    //

    TrapFrame->Eip += InstructionSize;
    TrapFrame->Eip &= 0xffff;

    return TRUE;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\mp\makefile.inc ===
!INCLUDE ..\up\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdmoprnd.asm ===
title "Operand Decoding"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    vdmoprnd.asm
;
;Abstract:
;
;    This module contains support for decoding 386/486 instruction operands.
;    This is used by the opcode 0f emulation.
;
;
;Author:
;
;    Dave Hastings (daveh) 20-Feb-1992
;
;Notes:
;
;    The only instruction which uses the operand decodeing (3/10/92) is
;    LMSW.  This instruction only has 16 bit operands, so only the 16 bit
;    operand decode has been tested.  The 32 bit decode will be tested
;    (or removed?) during clean up, after code freeze.
;
;Revision History:
;
;--
.386p

        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
include mi386.inc
include vdm.inc
include vdmtib.inc

        page ,132

_PAGE   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING

        EXTRNP  _Ki386GetSelectorParameters,4
        extrn   CheckEip:proc

_PAGE   ENDS

PAGEDATA	SEGMENT  DWORD PUBLIC 'DATA'
;
; This table is used to dispatch base on the mod code for 16 bit address size.
; When these locations are dispatched to,
;       edi = linear address of next byte of instruction
;       esi = pointer to register info
;       ecx = R/M value for the instruction
modtab16 dd offset FLAT:do20            ; no displacement
         dd offset FLAT:do40            ; 8 bit displacement
         dd offset FLAT:do50            ; 16 bit displacement
         dd offset FLAT:do60            ; Register operand

;
; This table is used to dispatch based on the RM code for 16 bit address size.
; When these locations are dispatched to,
;       edi = pointer to trap frame
;       esi = pointer to register info
;       ebx = partial linear address of operand
rmtab16 dd offset FLAT:do70             ; [bx + si]
        dd offset FLAT:do80             ; [bx + di]
        dd offset FLAT:do90             ; [bp + si]
        dd offset FLAT:do100            ; [bp + di]
        dd offset FLAT:do95             ; [si]
        dd offset FLAT:do85             ; [di]
        dd offset FLAT:do105            ; [bp]
        dd offset FLAT:do75             ; [bx]

;
; This table is used to dispatch base on the mod code for 32 bit address size.
; When these locations are dispatched to,
;       edi = linear address of next byte of instruction
;       esi = pointer to register info
;       ecx = R/M value for the instruction
modtab32 dd offset FLAT:do220           ; no displacement
         dd offset FLAT:do240           ; 8 bit displacement
         dd offset FLAT:do250           ; 32 bit displacement
         dd offset FLAT:do260           ; Register operand

;
; This table is used to pick up register offsets in the trap frame.
; N.B.  This table cannot be used to find byte registers!!
;
        public RegTab
RegTab  dd TsEax
        dd TsEcx
        dd TsEdx
        dd TsEbx
        dd TsHardwareEsp
        dd TsEbp
        dd TsEsi
        dd TsEdi


PAGEDATA   ENDS


_PAGE   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:FLAT, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl "Decode Operands"
;++
;
;   Routine Description:
;
;       This routine decodes the operands for 386/486 instructions.  It returns
;       the linear address of the operand.  For register operands, this is
;       an address in the stack frame.  The read/write flag is used for
;       operand verification.
;
;   Arguments:
;
;       esi = address of reg info
;       eax = 1 -- Read of operand
;             0 -- Write of operand
;
;   Returns:
;
;       eax = True -- operand ok, and reg info operand field filled in
;       eax = False -- operand not ok.
;       reg info eip updated
;
;   Notes:
;
;       This routine DOES NOT decode the reg field of the mod r/m byte of the
;       opcode.  This is not a problem because it will only return one operand
;       address anyway.  It does not decode byte registers correctly!!.
;
;       check grow down ss handling

        public VdmDecodeOperand
VdmDecodeOperand proc

SegBase equ     [ebp] - 04h
SegLimit equ    [ebp] - 08h
SegFlags equ    [ebp] - 0ch
SelLookupResult equ [ebp] - 010h
ReadWrite equ   [ebp] - 014h
ModRm   equ     [ebp] - 018h
SIB     equ     [ebp] - 01ch

        push    ebp
        mov     ebp,esp
        sub     esp,01ch
        push    edi
        push    ecx
        push    ebx

        mov     ReadWrite,eax

;
; Get the info on DS (assumed default selector)
;
        lea     edx,SegLimit
        push    edx
        lea     edx,SegBase
        push    edx
        lea     edx,SegFlags
        push    edx
        mov     edi,[esi].RiTrapFrame
        push    [edi].TsSegDs
        call    VdmSegParams
        add     esp,010h
        mov     SelLookupResult,eax     ; check result after override check

        mov     edi,[esi].RiEip
        add     edi,[esi].RiCsBase
        call    CheckEip
        test    al,0fh
        jz      do200                   ; Gp fault, report error

        movzx   edx,byte ptr [edi]      ; get mod r/m byte
        inc     [esi].RiEip
        inc     edi
        mov     ecx,edx
        mov     ModRm,edx
        and     edx,MI_MODMASK
        shr     edx,MI_MODSHIFT         ; form jump table index from mod
        and     ecx,MI_RMMASK           ; form index for RM jump table
        test    [esi].RiPrefixFlags,PREFIX_ADDR32
        ; 32 bit segments.
        jnz     do210                   ; 32 bit instructions have diff form

        jmp     modtab16[edx * 4]

do20:
;
; These forms have no displacement, except for the "bp" form, which
; is just a 16 bit immediate displacement
;
        mov     ebx,0                   ; assume no displacement
        cmp     ecx,MI_RMBP
        jne     do30                    ; dispatch through jmp table

        call    CheckEip
        test    al,0fh
        jz      do200                   ; Gp fault, report error

        movzx   ebx,word ptr [edi]      ; get displacement
        inc     [esi].RiEip             ; update eip
        inc     [esi].RiEip
        jmp     do120                   ; go add in seg

do30:   mov     edi,[esi].RiTrapFrame
        jmp     rmtab16[ecx * 4]        ; go get register info.

do40:
;
; These forms have an 8 bit displacement
;
        call    CheckEip
        test    al,0fh
        jz      do200                   ; Gp fault, report error

        movsx   ebx,byte ptr [edi]
        inc     [esi].RiEip
        mov     edi,[esi].RiTrapFrame
        jmp     rmtab16[ecx * 4]

do50:
;
; These forms have an 16 bit displacement
;
        call    CheckEip
        test    al,0fh
        jz      do200                   ; Gp fault, report error

        movzx   ebx,word ptr [edi]
        inc     [esi].RiEip
        inc     [esi].RiEip
        mov     edi,[esi].RiTrapFrame
        jmp     rmtab16[ecx * 4]

do60:
;
; These forms are register operands
;
        mov     ebx,RegTab[ecx * 4]     ; get offset into stackframe
        add     ebx,[esi].RiTrapFrame   ; form linear address
        jmp     do194                   ; return success

do70:
;
; This is the [bx + si] operand
;
        movzx   edx,word ptr [edi].TsEsi
        add     ebx,edx

do75:
;
; This is the [bx] operand, and a fall through to finish forming [bx + si]
;
        movzx   edx,word ptr [edi].TsEbx
        add     ebx,edx
        jmp     do120                   ; go add seg info

do80:
;
; This is the [bx + di] operand
;
        movzx   edx,word ptr [edi].TsEbx
        add     ebx,edx

do85:
;
; This is the [di] operand, and the fall through to finish [bx + di]
;
        movzx   edx,word ptr [edi].TsEdi
        add     ebx,edx
        jmp     do120                   ; go add seg info

do90:
;
; This is the [bp + si] operand
;
        movzx   edx,word ptr [edi].TsEbp
        add     ebx,edx
;
; Change default segment to be ss
;
        lea     edx,SegLimit
        push    edx
        lea     edx,SegBase
        push    edx
        lea     edx,SegFlags
        push    edx
        mov     edi,[esi].RiTrapFrame
        push    [edi].TsHardwareSegSs
        call    VdmSegParams
        add     esp,010h
        mov     SelLookupResult,eax

do95:
;
; This is the [si] operand, and the fall through for forming [bp + si]
;
        movzx   edx,word ptr [edi].TsEsi
        add     ebx,edx
        jmp     do120                   ; go add seg info

do100:
;
; This is the [bp + di] operand
;
        movzx   edx,word ptr [edi].TsEdi
        add     ebx,edx

do105:
;
; This is the [bp] operand, and the fall through for forming [bp + di]
;
        movzx   edx,word ptr [edi].TsEbp
        add     ebx,edx
;
; Change default segment to be SS
;
        lea     edx,SegLimit
        push    edx
        lea     edx,SegBase
        push    edx
        lea     edx,SegFlags
        push    edx
        mov     edi,[esi].RiTrapFrame
        push    [edi].TsHardwareSegSs
        call    VdmSegParams
        add     esp,010h
        mov     SelLookupResult,eax

do120:  test    [esi].RiPrefixFlags,PREFIX_SEG_ALL  ; check for seg prefixes
        jz      do190                   ; no prefixes, use default.

        ; Note: we could use a bsr instruction here, but it has a high
        ;       overhead relative to a test and a jump, and I expect that
        ;       es overrides will be by far the most common
        mov     edi,[esi].RiTrapFrame
        test    [esi].RiPrefixFlags,PREFIX_ES
        jz      do130

        movzx   edx,word ptr [edi].TsSegEs
        jmp     do180

do130:  test    [esi].RiPrefixFlags,PREFIX_CS
        jz      do140

        movzx   edx,word ptr [edi].TsSegCs
        jmp     do180

do140:  test    [esi].RiPrefixFlags,PREFIX_SS
        jz      do150

        movzx   edx,word ptr [edi].TsHardwareSegSs
        jmp     do180

do150:  test    [esi].RiPrefixFlags,PREFIX_DS
        jz      do160

        movzx   edx,word ptr [edi].TsSegDs
        jmp     do180

do160:  test    [esi].RiPrefixFlags,PREFIX_FS
        jz      do170

        movzx   edx,word ptr [edi].TsSegFs
        jmp     do180

do170:  ; assert that seg gs bit is set
        movzx   edx,word ptr [edi].TsSegGs

;
; Get information on new default segment
;
do180:  lea     ecx,SegLimit
        push    ecx
        lea     ecx,SegBase
        push    ecx
        lea     ecx,SegFlags
        push    ecx
        push    edx
        call    VdmSegParams
        add     esp,010h
        mov     SelLookupResult,eax

        test    byte ptr SelLookupResult,0fh
        jz      do200                                   ; return error

        cmp     dword ptr ReadWrite,0
        jnz     do190                                   ; we can read all sels

        test    dword ptr SegFlags,SEL_TYPE_WRITE
        jz      do200                                   ; return error.

        cmp     ebx,SegLimit
        jae     do200                                   ; gp fault

do190:  add     ebx,SegBase
do194:  mov     [esi].RiOperand,ebx                     ; update op pointer
        mov     eax,1
do195:  pop     ebx
        pop     ecx
        pop     edi
        mov     esp,ebp
        pop     ebp
        ret

do200:  xor     eax,eax
        jmp     do195

;
; Get the SIB if there is one, and save it for later.
;
do210:  cmp     ecx,MI_RMSIB
        jne     do215                   ; no Sib, dispatch for displacement

        call    CheckEip
        test    al,0fh
        jz      do200                   ; report GP fault

        movzx   eax,byte ptr [edi]
        mov     Sib,eax
        inc     edi
        inc     [esi].RiEip
do215:  jmp     modtab32[edx * 4]

do220:
;
; These forms have no displacement, except for the "bp" form, which
; is just a 32 bit immediate displacement
;
        mov     ebx,0                   ; assume no displacement
        cmp     ecx,MI_RMBP
        jne     do270

        call    CheckEip
        test    al,0fh
        jz      do200                   ; Gp fault, report error

        mov     ebx,[edi]               ; get displacement
        add     [esi].RiEip,4           ; update eip
        jmp     do120                   ; go add in seg

do240:
;
; These forms have an 8 bit displacement
;
        call    CheckEip
        test    al,0fh
        jz      do200                   ; Gp fault, report error

        movsx   ebx,byte ptr [edi]
        inc     [esi].RiEip
        jmp     do270

do250:
;
; These forms have an 32 bit displacement
;
        call    CheckEip
        test    al,0fh
        jz      do200                   ; Gp fault, report error

        mov     ebx, [edi]
        add     [esi].RiEip,4
        jmp     do270

do260:
;
; These forms are register operands
;
        mov     ebx,RegTab[ecx * 4]     ; get offset into stackframe
        add     ebx,[esi].RiTrapFrame   ; form linear address
        jmp     do195                   ; return success

do270:
;
; Add in the RM portion of the effective address.
;
        cmp     ecx,MI_RMSIB
        je      do290                   ; handle SIB specially

        mov     edi,[esi].RiTrapFrame
        mov     edx,RegTab[ecx * 4]    ; get offset of register
        add     ebx,[edx+edi]           ; add register to displacement
        cmp     ecx,MI_RMBP             ; bp is base?
        je      do280                   ; set up ss as default

        jmp     do120                   ; get segment info.

do280:
;
; Change default segment to be SS
;
        lea     edx,SegLimit
        push    edx
        lea     edx,SegBase
        push    edx
        lea     edx,SegFlags
        push    edx
        mov     edi,[esi].RiTrapFrame
        push    [edi].TsHardwareSegSs
        call    VdmSegParams
        add     esp,010h
        mov     SelLookupResult,eax
        jmp     do120
do290:
;
;  Decode the Sib
;
        mov     edx,Sib
        mov     edi,[esi].RiTrapFrame
        and     edx,MI_SIB_BASEMASK     ; isolate base
        cmp     edx,MI_SIB_BASENONE     ; no base
        je      do300

        mov     eax,RegTab[edx * 4]
        add     ebx,[edi+eax]           ; get register contents, and add

do300:  mov     edx,Sib
        and     ecx,MI_SIB_INDEXMASK
        shr     ecx,MI_SIB_INDEXSHIFT   ; make index out of "index" field
        cmp     ecx,MI_SIB_INDEXNONE
        je      do310                   ; no index

        mov     eax,RegTab[ecx * 4]
        mov     eax,[eax+edi]           ; get reg contents for multiply.
        mov     ecx,Sib
        and     ecx,MI_SIB_SSMASK
        shr     ecx,MI_SIB_SSSHIFT      ; for shift count
        shl     eax,cl
        add     ebx,eax

do310:  cmp     edx,MI_SIB_BASENONE
        jne     do120

;
; If mod != 0, then we have to add in EBP, and make ss the default seg
;
        mov     edx,ModRm
        and     edx,MI_MODMASK
        shr     edx,MI_MODSHIFT
        cmp     edx,MI_MODNONE
        jne     do120
;
; Add in Ebp, and change default segment to ss
;
        add     ebx,[edi].TsEbp

        lea     edx,SegLimit
        push    edx
        lea     edx,SegBase
        push    edx
        lea     edx,SegFlags
        push    edx
        mov     edi,[esi].RiTrapFrame
        push    [edi].TsHardwareSegSs
        call    VdmSegParams
        add     esp,010h
        mov     SelLookupResult,eax
        jmp     do120                   ; add in segment info

VdmDecodeOperand endp

        public VdmSegParams
VdmSegParams proc

        push    edi
        mov     edi,[esi].RiTrapFrame
        test    dword ptr [edi].TsEFlags,EFLAGS_V86_MASK
        jz      vsp20

Segmt   equ     word ptr [ebp + 8]
SegFlags equ    [ebp + 0Ch]
SegBase equ     [ebp + 010h]
SegLimit equ    [ebp + 014h]

        pop     edi
        push    ebp
        mov     ebp,esp
        push    edi

        movzx   eax,Segmt
        shl     eax,4
        mov     edi,SegBase
        mov     [edi],eax
        mov     edi,SegLimit
        mov     dword ptr [edi],0FFFFh
        mov     edi,SegFlags
        mov     [edi],dword ptr SEL_TYPE_WRITE
        mov     eax,1

        pop     edi
        mov     esp,ebp
        pop     ebp
        ret

vsp20:  pop     edi
        jmp     _Ki386GetSelectorParameters@16

VdmSegParams endp
_PAGE   ENDS
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdmints.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vdmints.c

Abstract:

    Vdm kernel Virtual interrupt support

Author:

    13-Oct-1993 Jonathan Lew (Jonle)

Notes:


Revision History:


--*/

#include "vdmp.h"
#include <ntos.h>
#include <zwapi.h>

//
// Define thread priority boost for vdm hardware interrupt.
//

#define VDM_HWINT_INCREMENT     EVENT_INCREMENT

//
// internal function prototypes
//

VOID
VdmpQueueIntApcRoutine (
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

VOID
VdmpQueueIntNormalRoutine (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
VdmpDelayIntDpcRoutine (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
VdmpDelayIntApcRoutine (
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

int
VdmpRestartDelayedInterrupts (
    PVDMICAUSERDATA pIcaUserData
    );

int
VdmpIcaScan (
     PVDMICAUSERDATA  pIcaUserData,
     PVDMVIRTUALICA   pIcaAdapter
     );

int
VdmpIcaAccept (
     PVDMICAUSERDATA  pIcaUserData,
     PVDMVIRTUALICA   pIcaAdapter
     );

ULONG
GetIretHookAddress (
    PKTRAP_FRAME    TrapFrame,
    PVDMICAUSERDATA pIcaUserData,
    int IrqNum
    );

VOID
PushRmInterrupt (
    PKTRAP_FRAME TrapFrame,
    ULONG IretHookAddress,
    PVDM_TIB VdmTib,
    ULONG InterruptNumber
    );

NTSTATUS
PushPmInterrupt (
    PKTRAP_FRAME TrapFrame,
    ULONG IretHookAddress,
    PVDM_TIB VdmTib,
    ULONG InterruptNumber
    );

VOID
VdmpRundownRoutine (
    IN PKAPC Apc
    );

NTSTATUS
VdmpEnterIcaLock (
    IN PRTL_CRITICAL_SECTION pIcaLock,
    IN PLARGE_INTEGER Timeout
    );

NTSTATUS
VdmpLeaveIcaLock (
    IN PRTL_CRITICAL_SECTION pIcaLock
    );

int
VdmpExceptionHandler (
    IN PEXCEPTION_POINTERS ExceptionInfo
    );

#pragma alloc_text(PAGE, VdmpQueueIntNormalRoutine)
#pragma alloc_text(PAGE, VdmDispatchInterrupts)
#pragma alloc_text(PAGE, VdmpRestartDelayedInterrupts)
#pragma alloc_text(PAGE, VdmpIcaScan)
#pragma alloc_text(PAGE, VdmpIcaAccept)
#pragma alloc_text(PAGE, GetIretHookAddress)
#pragma alloc_text(PAGE, PushRmInterrupt)
#pragma alloc_text(PAGE, PushPmInterrupt)
#pragma alloc_text(PAGE, VdmpDispatchableIntPending)
#pragma alloc_text(PAGE, VdmpIsThreadTerminating)
#pragma alloc_text(PAGE, VdmpRundownRoutine)
#pragma alloc_text(PAGE, VdmpExceptionHandler)
#pragma alloc_text(PAGE, VdmpEnterIcaLock)
#pragma alloc_text(PAGE, VdmpLeaveIcaLock)

extern POBJECT_TYPE ExSemaphoreObjectType;
extern POBJECT_TYPE ExEventObjectType;

#if DBG

//
// Make this variable nonzero to enable stricter ntvdm checking.  Note this
// cannot be left on by default because a malicious app can provoke the asserts.
//

ULONG VdmStrict;
#endif

NTSTATUS
VdmpQueueInterrupt(
    IN HANDLE ThreadHandle
    )

/*++

Routine Description:

    Queues a user mode APC to the specifed application thread
    which will dispatch an interrupt.

    if APC is already queued to specified thread
       does nothing

    if APC is queued to the wrong thread
       dequeue it

    Reset the user APC for the specifed thread

    Insert the APC in the queue for the specifed thread

Arguments:

    ThreadHandle - handle of thread to insert QueueIntApcRoutine

Return Value:

    NTSTATUS.

--*/

{

    KIRQL OldIrql;
    PEPROCESS Process;
    PETHREAD Thread;
    NTSTATUS Status;
    PVDM_PROCESS_OBJECTS pVdmObjects;

    PAGED_CODE();

    Status = ObReferenceObjectByHandle(ThreadHandle,
                                       THREAD_QUERY_INFORMATION,
                                       PsThreadType,
                                       KeGetPreviousMode(),
                                       &Thread,
                                       NULL
                                       );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Process = PsGetCurrentProcess();
    if (Process != Thread->ThreadsProcess || Process->VdmObjects == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
    }
    else {

        //
        // Insert kernel APC.
        //
        // N.B. The delay interrupt lock is used to synchronize access to APC
        //      objects that are manipulated by VDM.
        //

        pVdmObjects = Process->VdmObjects;
        ExAcquireSpinLock(&pVdmObjects->DelayIntSpinLock, &OldIrql);
        if (!KeVdmInsertQueueApc(&pVdmObjects->QueuedIntApc,
                                 &Thread->Tcb,
                                 KernelMode,
                                 VdmpQueueIntApcRoutine,
                                 VdmpRundownRoutine,
                                 VdmpQueueIntNormalRoutine, // normal routine
                                 (PVOID)KernelMode,      // NormalContext
                                 VDM_HWINT_INCREMENT))

        {
            Status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            Status = STATUS_SUCCESS;
        }

        ExReleaseSpinLock(&pVdmObjects->DelayIntSpinLock, OldIrql);
    }

    ObDereferenceObject(Thread);
    return Status;
}

VOID
VdmpQueueIntApcRoutine (
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    Kernel and User mode Special Apc routine to dispatch virtual
    interrupts to the vdm.

    For KernelMode routine:
        if vdm is running in application mode
           queue a UserModeApc to the same thread
        else do nothing

    For UserMode routine
        if vdm is running in application mode dispatch virtual interrupts
        else do nothing

Arguments:

    Apc - Supplies a pointer to the APC object used to invoke this routine.

    NormalRoutine - Supplies a pointer to a pointer to the normal routine
                    function that was specified when the APC was initialized.

    NormalContext - Supplies a pointer to the processor mode
        specifying that this is a Kernel Mode or UserMode apc

    SystemArgument1 -

    SystemArgument2 - NOT USED
        Supplies a set of two pointers to two arguments that contain
        untyped data.

Return Value:

    None.

--*/

{
    LONG VdmState;
    KIRQL OldIrql;
    PVDM_PROCESS_OBJECTS pVdmObjects;
    NTSTATUS     Status;
    PETHREAD     Thread;
    PKTRAP_FRAME TrapFrame;
    PVDM_TIB     VdmTib;
    BOOLEAN      AppMode;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // Clear address of thread object in APC object.
    //
    // N.B. The delay interrupt lock is used to synchronize access to APC
    //      objects that are manipulated by VDM.
    //

    pVdmObjects = PsGetCurrentProcess()->VdmObjects;
    ExAcquireSpinLock(&pVdmObjects->DelayIntSpinLock, &OldIrql);
    KeVdmClearApcThreadAddress(Apc);
    ExReleaseSpinLock(&pVdmObjects->DelayIntSpinLock, OldIrql);

    //
    // Get the trap frame for the current thread if it is not terminating.
    //

    Thread = PsGetCurrentThread();
    if (PsIsThreadTerminating(Thread)) {
        return;
    }

    TrapFrame = VdmGetTrapFrame(&Thread->Tcb);
    AppMode = (BOOLEAN)(TrapFrame->EFlags & EFLAGS_V86_MASK ||
                        TrapFrame->SegCs != (KGDT_R3_CODE | RPL_MASK));

    try {

        //
        // If we are in the middle of screen switch, send the main thread
        // back to the monitor context to be suspended there.
        //
        if (*(KPROCESSOR_MODE *)NormalContext == UserMode) {
            if (*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_HANDSHAKE && AppMode) {
                Status = VdmpGetVdmTib(&VdmTib);
                if (NT_SUCCESS(Status)) {

                    *FIXED_NTVDMSTATE_LINEAR_PC_AT = *FIXED_NTVDMSTATE_LINEAR_PC_AT & ~VDM_HANDSHAKE;
                    VdmTib->EventInfo.Event = VdmHandShakeAck;
                    VdmTib->EventInfo.InstructionSize = 0;
                    VdmTib->EventInfo.IntAckInfo = 0;
                    VdmEndExecution(TrapFrame, VdmTib);
                    KeBoostPriorityThread (KeGetCurrentThread(), VDM_HWINT_INCREMENT);
                }
                return;
            }
        } else if (*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_HANDSHAKE && AppMode) {

            //
            // If we are running at application mode and in the middle of screen
            // switch, we will signal the event to let screen switch continue.
            // This is fine because:
            // 1. The incoming user apc will send the main thread back to monitor context
            // 2. The kernel mode IO handlers are running at APC level.  If we can get
            //    here, the IO handlers are done
            //
            HANDLE SuspendedHandle;
            PKEVENT SuspendedEvent;

            try {
                SuspendedHandle = *pVdmObjects->pIcaUserData->phMainThreadSuspended;
                Status = ObReferenceObjectByHandle (SuspendedHandle,
                                                    EVENT_MODIFY_STATE,
                                                    ExEventObjectType,
                                                    UserMode,
                                                    &SuspendedEvent,
                                                    NULL);
                if (NT_SUCCESS(Status)) {
                    KeSetEvent(SuspendedEvent, EVENT_INCREMENT, FALSE);
                    ObDereferenceObject(SuspendedEvent);
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
            }
        }

        //
        // if no pending interrupts, ignore this APC.
        //

        if (!(*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_INTERRUPT_PENDING)) {
            return;
        }

        if (VdmpDispatchableIntPending(TrapFrame->EFlags)) {

            //
            // if we are in v86 mode or segmented protected mode
            // then queue the UserMode Apc, which will dispatch
            // the hardware interrupt
            //

            if ((TrapFrame->EFlags & EFLAGS_V86_MASK) ||
                (TrapFrame->SegCs != (KGDT_R3_CODE | RPL_MASK))) {

                if (*(KPROCESSOR_MODE *)NormalContext == KernelMode) {

                    //
                    // Insert user APC.
                    //
                    // N.B. The delay interrupt lock is used to synchronize
                    //      access to APC objects that are manipulated by VDM.
                    //

                    VdmState = *FIXED_NTVDMSTATE_LINEAR_PC_AT;

                    ExAcquireSpinLock(&pVdmObjects->DelayIntSpinLock,
                                      &OldIrql);

                    KeVdmInsertQueueApc(&pVdmObjects->QueuedIntUserApc,
                                        &Thread->Tcb,
                                        UserMode,
                                        VdmpQueueIntApcRoutine,
                                        VdmpRundownRoutine,
                                        NULL,                  // normal routine
                                        (PVOID)UserMode,       // NormalContext
                                        VdmState & VDM_INT_HARDWARE
                                          ? VDM_HWINT_INCREMENT : 0);

                    ExReleaseSpinLock(&pVdmObjects->DelayIntSpinLock, OldIrql);
                }
                else {
                     ASSERT(*NormalContext == (PVOID)UserMode);

                     Status = VdmpGetVdmTib(&VdmTib);
                     if (!NT_SUCCESS(Status)) {
                        return;
                     }


                     //VdmTib = (PsGetCurrentProcess()->VdmObjects)->VdmTib;
                     // VdmTib =
                     //    ((PVDM_PROCESS_OBJECTS)(PsGetCurrentProcess()->VdmObjects))->VdmTib;

                        //
                        // If there are no hardware ints, dispatch timer ints
                        // else dispatch hw interrupts
                        //
                     if (*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_INT_TIMER &&
                         !(*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_INT_HARDWARE))
                       {
                         VdmTib->EventInfo.Event = VdmIntAck;
                         VdmTib->EventInfo.InstructionSize = 0;
                         VdmTib->EventInfo.IntAckInfo = 0;
                         VdmEndExecution(TrapFrame, VdmTib);
                     }
                     else {
                         VdmDispatchInterrupts (TrapFrame, VdmTib);
                     }
                }
            }
            else {

                //
                // If we are not in application mode and wow is all blocked
                // then Wake up WowExec by setting the wow idle event
                //

                if (*NormalRoutine && !(*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_WOWBLOCKED)) {
                    *NormalRoutine = NULL;
                }
            }
        }
        // WARNING this may set VIP for flat if VPI is ever set in CR4
        else if ((TrapFrame->EFlags & EFLAGS_V86_MASK) &&
                 (KeI386VirtualIntExtensions & V86_VIRTUAL_INT_EXTENSIONS)) {

            //
            // The CPU traps EVERY instruction if VIF and VIP are both ON.
            // Make sure that you set VIP ON only when  there are pending
            // interrupts, i.e. (*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_INTERRUPT_PENDING) != 0.
            //

#if DBG
            if (VdmStrict) {
                ASSERT(*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_INTERRUPT_PENDING);
            }
#endif
            ASSERT (KeGetCurrentIrql () >= APC_LEVEL);

            TrapFrame->EFlags |= EFLAGS_VIP;
        }
    }
    except(VdmpExceptionHandler(GetExceptionInformation()))  {
#if 0
        VdmDispatchException(TrapFrame,
                             GetExceptionCode(),
                             (PVOID)TrapFrame->Eip,
                             0,0,0,0   // no parameters
                             );
#endif
    }
}

VOID
VdmpQueueIntNormalRoutine (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:



Arguments:


Return Value:

    None.

--*/

{
    PETHREAD Thread;
    PKEVENT  Event;
    NTSTATUS Status;
    PKTRAP_FRAME TrapFrame;
    PVDM_PROCESS_OBJECTS pVdmObjects;
    HANDLE CapturedHandle;

    UNREFERENCED_PARAMETER (NormalContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);


    //
    // Wake up WowExec by setting the wow idle event
    //

    pVdmObjects = PsGetCurrentProcess()->VdmObjects;

    try {
        CapturedHandle = *pVdmObjects->pIcaUserData->phWowIdleEvent;
    }
    except(VdmpExceptionHandler(GetExceptionInformation()))  {
        Thread    = PsGetCurrentThread();
        TrapFrame = VdmGetTrapFrame(&Thread->Tcb);
#if 0
        VdmDispatchException(TrapFrame,
                             GetExceptionCode(),
                             (PVOID)TrapFrame->Eip,
                             0,0,0,0   // no parameters
                             );
#endif
        return;
    }

    Status = ObReferenceObjectByHandle (CapturedHandle,
                                        EVENT_MODIFY_STATE,
                                        ExEventObjectType,
                                        UserMode,
                                        &Event,
                                        NULL);

    if (NT_SUCCESS(Status)) {
        KeSetEvent(Event, EVENT_INCREMENT, FALSE);
        ObDereferenceObject(Event);
    }
}

VOID
VdmRundownDpcs (
    IN PEPROCESS Process
    )
{
    PVDM_PROCESS_OBJECTS pVdmObjects;
    PETHREAD Thread, MainThread;
    PDELAYINTIRQ pDelayIntIrq;
    KIRQL OldIrql;
    PLIST_ENTRY Next;

    pVdmObjects = Process->VdmObjects;

    //
    // Free up the DelayedIntList, canceling pending timers.
    //

    KeAcquireSpinLock (&pVdmObjects->DelayIntSpinLock, &OldIrql);

    Next = pVdmObjects->DelayIntListHead.Flink;

    while (Next != &pVdmObjects->DelayIntListHead) {
        pDelayIntIrq = CONTAINING_RECORD(Next, DELAYINTIRQ, DelayIntListEntry);
        Next = Next->Flink;
        if (KeCancelTimer (&pDelayIntIrq->Timer)) {
            Thread = pDelayIntIrq->Thread;
            pDelayIntIrq->Thread = NULL;
            if (Thread != NULL) {
                ObDereferenceObject (Thread);
            }
            MainThread = pDelayIntIrq->MainThread;
            pDelayIntIrq->MainThread = NULL;
            if (MainThread != NULL) {
                ObDereferenceObject (MainThread);
            }

            ObDereferenceObject (Process);
        }
    }

    if (pVdmObjects->MainThread != NULL) {
        ObDereferenceObject (pVdmObjects->MainThread);
        pVdmObjects->MainThread = NULL;
    }

    KeReleaseSpinLock (&pVdmObjects->DelayIntSpinLock, OldIrql);
}

NTSTATUS
VdmpEnterIcaLock (
    IN PRTL_CRITICAL_SECTION pIcaLock,
    IN PLARGE_INTEGER Timeout
    )

/*++

Routine Description:

    This function enters a usermode critical section, with a fixed timeout
    of several minutes.

    Touching the critical section may cause an exception to be raised which
    the caller must handle, since the critical section is in usermode
    memory.

Arguments:

    CriticalSection - supplies a pointer to a critical section.

    Timeout - supplies a pointer to a large integer which specifies the timeout value
              for waiting on critical section.

Return Value:

    STATUS_SUCCESS - wait was satisfied and the thread owns the CS

    STATUS_INVALID_HANDLE - no semaphore available to wait on.

    STATUS_TIMEOUT

--*/

{
    HANDLE UniqueThread;
    NTSTATUS Status;

    UniqueThread = NtCurrentTeb()->ClientId.UniqueThread;

    if (pIcaLock->LockSemaphore == 0) {

        //
        // Lazy creates not permitted.
        //

        return STATUS_INVALID_HANDLE;
    }

    if (InterlockedIncrement (&pIcaLock->LockCount) == 0) {

        //
        // Set the current thread as the owner of critical section with
        // recursion count of 1.
        //

        pIcaLock->OwningThread = UniqueThread;
        pIcaLock->RecursionCount = 1;

        return STATUS_SUCCESS;
    }

    //
    // If the current thread already owns the critical section, increment
    // the recursion count.
    //

    if (pIcaLock->OwningThread == UniqueThread) {
        pIcaLock->RecursionCount += 1;
        return STATUS_SUCCESS;
    }

    //
    // Another thread owns the critical section so wait on the
    // lock semaphore.
    //

    do {

        Status = NtWaitForSingleObject (pIcaLock->LockSemaphore,
                                        0,
                                        Timeout);

        if (Status == STATUS_SUCCESS) {
            pIcaLock->OwningThread = UniqueThread;
            pIcaLock->RecursionCount = 1;
            return STATUS_SUCCESS;
        }

        //
        // If !NT_SUCCESS(Status), return that error.
        //
        // Otherwise some other less severe error occurred, in which case
        // if the thread is terminating then fail.
        //
        // Note: we may wake for user APCs even though we are non alertable,
        // because the vdm hw int dispatching code, and PsThread
        // termination code forces these to occur.
        //

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // Check for termination of self.
        //

        Status = VdmpIsThreadTerminating (UniqueThread);

        if (Status != STATUS_SUCCESS) {
            return Status;
        }

        Status = VdmpIsThreadTerminating (pIcaLock->OwningThread);

        if (Status != STATUS_SUCCESS) {
            return Status;
        }

    } while (TRUE);
}

NTSTATUS
VdmpLeaveIcaLock (
    IN PRTL_CRITICAL_SECTION pIcaLock
    )

/*++

    Routine Description:

    This function leaves a usermode critical section.

    Touching the critical section may cause an exception to be raised which
    the caller must handle, since the critical section is in usermode
    memory.

Arguments:

    CriticalSection - supplies a pointer to a critical section.

Return Value:

    STATUS_SUCCESS

    STATUS_TIMEOUT

    STATUS_INVALID_OWNER

    or NTSTATUS code from NtReleaseSemaphore

--*/

{
    HANDLE UniqueThread;

    UniqueThread = NtCurrentTeb()->ClientId.UniqueThread;

    if (pIcaLock->OwningThread != UniqueThread) {
        return STATUS_INVALID_OWNER;
    }

    pIcaLock->RecursionCount -= 1;

    if (pIcaLock->RecursionCount != 0) {
        InterlockedDecrement (&pIcaLock->LockCount);
        return STATUS_SUCCESS;
    }

    pIcaLock->OwningThread = NULL;

    if (InterlockedDecrement (&pIcaLock->LockCount) < 0) {
        return STATUS_SUCCESS;
    }

    //
    // Threads are waiting on the lock semaphore, signal one now.
    //

    return NtSetEvent (pIcaLock->LockSemaphore, 0);
}

NTSTATUS
VdmDispatchInterrupts (
    PKTRAP_FRAME TrapFrame,
    PVDM_TIB     VdmTib
    )

/*++

Routine Description:

    This routine dispatches interrupts to the vdm.
    Assumes that we are in application mode and NOT MONITOR context.
    This routine may switch from application context back to monitor
    context, if it cannot handle the interrupt (Ica in AEOI, or timer
    int pending).

Arguments:

    TrapFrame address of current trapframe
    VdmTib    address of current vdm tib

Return Value:

    None.

--*/

{
    NTSTATUS   Status;
    ULONG      IretHookAddress;
    ULONG      InterruptNumber;
    int        IrqLineNum;
    PVDMICAUSERDATA  pIcaUserData;
    PVDMVIRTUALICA   pIcaAdapter;
    VDMEVENTCLASS  VdmEvent = VdmMaxEvent;

    PAGED_CODE();

    pIcaUserData = ((PVDM_PROCESS_OBJECTS)PsGetCurrentProcess()->VdmObjects)->pIcaUserData;

    try {

        //
        // Take the Ica Lock, if this fails raise status as we can't
        // safely recover the critical section state
        //

        Status = VdmpEnterIcaLock (pIcaUserData->pIcaLock, pIcaUserData->pIcaTimeout);

        if (!NT_SUCCESS(Status)) {
            ExRaiseStatus(Status);
        }

        if (*pIcaUserData->pUndelayIrq) {
            VdmpRestartDelayedInterrupts(pIcaUserData);
        }

VDIretry:

        //
        // Clear the VIP bit
        //

        if ((TrapFrame->EFlags & EFLAGS_V86_MASK) &&
            (KeI386VirtualIntExtensions & V86_VIRTUAL_INT_EXTENSIONS)) {

            ASSERT (KeGetCurrentIrql () >= APC_LEVEL);

            TrapFrame->EFlags &= ~EFLAGS_VIP;
        }


        //
        // Mark the vdm state as hw int dispatched. Must use the lock as
        // kernel mode DelayedIntApcRoutine changes the bit as well
        //

        InterlockedAnd (FIXED_NTVDMSTATE_LINEAR_PC_AT, ~VDM_INT_HARDWARE);

        pIcaAdapter = pIcaUserData->pIcaMaster;
        IrqLineNum = VdmpIcaAccept(pIcaUserData, pIcaAdapter);

        if (IrqLineNum >= 0) {
            UCHAR bit = (UCHAR)(1 << IrqLineNum);

            if (pIcaUserData->pIcaMaster->ica_ssr & bit) {
                pIcaAdapter = pIcaUserData->pIcaSlave;
                IrqLineNum = VdmpIcaAccept(pIcaUserData, pIcaAdapter);
                if (IrqLineNum < 0) {
                    pIcaUserData->pIcaMaster->ica_isr &= ~bit;
                }
            }
        }

        //
        // Skip spurious ints
        //

        if (IrqLineNum < 0)  {

            //
            // Check for delayed interrupts which need to be restarted
            //

            if (*pIcaUserData->pUndelayIrq &&
                VdmpRestartDelayedInterrupts(pIcaUserData) != -1) {
                goto VDIretry;
            }

            Status = VdmpLeaveIcaLock (pIcaUserData->pIcaLock);

            if (!NT_SUCCESS(Status)) {
                ExRaiseStatus(Status);
            }

            return Status;
        }

        //
        // Capture the AutoEoi mode case for special handling
        //

        if (pIcaAdapter->ica_mode & ICA_AEOI) {
            VdmEvent = VdmIntAck;
            VdmTib->EventInfo.IntAckInfo = VDMINTACK_AEOI;
            if (pIcaAdapter == pIcaUserData->pIcaSlave) {
                VdmTib->EventInfo.IntAckInfo |= VDMINTACK_SLAVE;
            }
        }

        InterruptNumber = IrqLineNum + pIcaAdapter->ica_base;

        //
        // Get the IretHookAddress ... if any
        //

        if (pIcaAdapter == pIcaUserData->pIcaSlave) {
            IrqLineNum += 8;
        }

        IretHookAddress = GetIretHookAddress (TrapFrame,
                                              pIcaUserData,
                                              IrqLineNum);

        if (*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_TRACE_HISTORY) {
            VdmTraceEvent (VDMTR_KERNEL_HW_INT,
                           (USHORT)InterruptNumber,
                           0,
                           TrapFrame);
        }

        //
        // Push the interrupt frames
        //

        if (TrapFrame->EFlags & EFLAGS_V86_MASK) {

            PushRmInterrupt (TrapFrame,
                             IretHookAddress,
                             VdmTib,
                             InterruptNumber);
        }
        else {
            Status = PushPmInterrupt (TrapFrame,
                                      IretHookAddress,
                                      VdmTib,
                                      InterruptNumber);

            if (!NT_SUCCESS(Status)) {
                VdmpLeaveIcaLock (pIcaUserData->pIcaLock);
                ExRaiseStatus (Status);
            }
        }

        //
        // Disable interrupts and the trap flag
        //

        if ((TrapFrame->EFlags & EFLAGS_V86_MASK) &&
            (KeI386VirtualIntExtensions & V86_VIRTUAL_INT_EXTENSIONS)) {
            TrapFrame->EFlags &= ~EFLAGS_VIF;
        } else {
            *FIXED_NTVDMSTATE_LINEAR_PC_AT &= ~VDM_VIRTUAL_INTERRUPTS;
        }

        ASSERT (KeGetCurrentIrql () >= APC_LEVEL);
        TrapFrame->EFlags &= ~(EFLAGS_NT_MASK | EFLAGS_TF_MASK);

        KeBoostPriorityThread (KeGetCurrentThread(), VDM_HWINT_INCREMENT);

        //
        // Release the Ica lock
        //

        Status = VdmpLeaveIcaLock (pIcaUserData->pIcaLock);

        if (!NT_SUCCESS(Status)) {
            ExRaiseStatus (Status);
        }

        //
        // check to see if we are supposed to switch back to monitor context
        //
        if (VdmEvent != VdmMaxEvent) {
            VdmTib->EventInfo.Event = VdmIntAck;
            VdmTib->EventInfo.InstructionSize = 0;
            VdmEndExecution(TrapFrame, VdmTib);
        }
    }
    except (VdmpExceptionHandler(GetExceptionInformation())) {
        Status = GetExceptionCode();
    }

    return Status;
}

int
VdmpRestartDelayedInterrupts (
    PVDMICAUSERDATA pIcaUserData
    )
{
    int line;

    PAGED_CODE();

    try {
        *pIcaUserData->pUndelayIrq = 0;

        line = VdmpIcaScan(pIcaUserData, pIcaUserData->pIcaSlave);
        if (line != -1) {
            // set the slave
            pIcaUserData->pIcaSlave->ica_int_line = line;
            pIcaUserData->pIcaSlave->ica_cpu_int = TRUE;

            // set the master cascade
            line = pIcaUserData->pIcaSlave->ica_ssr;
            pIcaUserData->pIcaMaster->ica_irr |= 1 << line;
            pIcaUserData->pIcaMaster->ica_count[line]++;
        }

        line = VdmpIcaScan(pIcaUserData, pIcaUserData->pIcaMaster);

        if (line != -1) {
            pIcaUserData->pIcaMaster->ica_cpu_int = TRUE;
            pIcaUserData->pIcaMaster->ica_int_line = TRUE;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        line = -1;
        NOTHING;
    }

    return line;
}

int
VdmpIcaScan (
     PVDMICAUSERDATA  pIcaUserData,
     PVDMVIRTUALICA   pIcaAdapter
     )

/*++

Routine Description:

   Similar to softpc\base\system\ica.c - scan_irr(),

   Check the IRR, the IMR and the ISR to determine which interrupt
   should be delivered.

   A bit set in the IRR will generate an interrupt if:
     IMR bit, DelayIret bit, DelayIrq bit AND ISR higher priority bits
     are clear (unless Special Mask Mode, in which case ISR is ignored)

   If there is no bit set, then return -1


Arguments:
    PVDMICAUSERDATA  pIcaUserData   - addr of ica userdata
    PVDMVIRTUALICA   pIcaAdapter    - addr of ica adapter


Return Value:

    int IrqLineNum for the specific adapter (0 to 7)
    -1 for none

--*/

{
   int   i,line;
   UCHAR bit;
   ULONG IrrImrDelay;
   ULONG ActiveIsr;

   PAGED_CODE();

   IrrImrDelay = *pIcaUserData->pDelayIrq | *pIcaUserData->pDelayIret;
   if (pIcaAdapter == pIcaUserData->pIcaSlave) {
       IrrImrDelay >>= 8;
       }

   IrrImrDelay = pIcaAdapter->ica_irr & ~(pIcaAdapter->ica_imr | (UCHAR)IrrImrDelay);

   if (IrrImrDelay)  {

        /*
         * Does the current mode require the ica to prevent
         * interrupts if that line is still active (ie in the isr)?
         *
         * Normal Case: Used by DOS and Win3.1/S the isr prevents interrupts.
         * Special Mask Mode, Special Fully Nested Mode do not block
         * interrupts using bits in the isr. SMM is the mode used
         * by Windows95 and Win3.1/E.
         *
         */
       ActiveIsr = (pIcaAdapter->ica_mode & (ICA_SMM|ICA_SFNM))
                      ? 0 : pIcaAdapter->ica_isr;

       for(i = 0; i < 8; i++)  {
           line = (pIcaAdapter->ica_hipri + i) & 7;
           bit = (UCHAR) (1 << line);
           if (ActiveIsr & bit) {
               break;            /* No nested interrupt possible */
               }

           if (IrrImrDelay & bit) {
               return line;
               }
           }
       }

  return -1;
}

int
VdmpIcaAccept(
     PVDMICAUSERDATA  pIcaUserData,
     PVDMVIRTUALICA   pIcaAdapter
     )

/*++

Routine Description:

   Does the equivalent of a cpu IntAck cycle retrieving the Irql Line Num
   for interrupt dispatch, and setting the ica state to reflect that
   the interrupt is in service.

   Similar to softpc\base\system\ica.c - ica_accept() scan_irr(),
   except that this code rejects interrupt dispatching if the ica
   is in Auto-EOI as this may involve a new interrupt cycle, and
   eoi hooks to be activated.

Arguments:
    PVDMICAUSERDATA  pIcaUserData   - addr of ica userdata
    PVDMVIRTUALICA   pIcaAdapter    - addr of ica adapter


Return Value:

    ULONG IrqLineNum for the specific adapter (0 to 7)
    returns -1 if there are no interrupts to generate (spurious ints
               are normally done on line 7

--*/

{
    int line;
    UCHAR bit;

    PAGED_CODE();

    //
    // Drop the INT line, and scan the ica
    //
    pIcaAdapter->ica_cpu_int = FALSE;

    try {
        line = VdmpIcaScan(pIcaUserData, pIcaAdapter);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return -1;
    }

    if (line < 0) {
        return -1;
    }

    bit = (UCHAR)(1 << line);
    pIcaAdapter->ica_isr |= bit;

    //
    // decrement the count and clear the IRR bit
    // ensure the count doesn't wrap past zero.
    //

    if (--(pIcaAdapter->ica_count[line]) <= 0)  {
        pIcaAdapter->ica_irr &= ~bit;
        pIcaAdapter->ica_count[line] = 0;
    }

    return line;
}

ULONG
GetIretHookAddress(
    PKTRAP_FRAME    TrapFrame,
    PVDMICAUSERDATA pIcaUserData,
    int IrqNum
    )

/*++

Routine Description:

    Retrieves the IretHookAddress from the real mode\protect mode
    iret hook bop table. This function is equivalent to
    softpc\base\system\ica.c - ica_iret_hook_needed()

Arguments:

    TrapFrame       - address of current trapframe
    pIcaUserData    - addr of ica data
    IrqNum          - IrqLineNum

Return Value:

    ULONG IretHookAddress. seg:offset or sel:offset Iret Hook,
                           0 if none
--*/

{
    ULONG  IrqMask;
    ULONG  AddrBopTable;
    int    IretBopSize;

    PAGED_CODE();

    IrqMask = 1 << IrqNum;
    if (!(IrqMask & *pIcaUserData->pIretHooked) ||
        !*pIcaUserData->pAddrIretBopTable )
      {
        return 0;
        }

    if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
        AddrBopTable = *pIcaUserData->pAddrIretBopTable;
        IretBopSize  = VDM_RM_IRETBOPSIZE;
        }
    else {
        AddrBopTable = (VDM_PM_IRETBOPSEG << 16) | VDM_PM_IRETBOPOFF;
        IretBopSize  = VDM_PM_IRETBOPSIZE;
        }

    *pIcaUserData->pDelayIret |= IrqMask;

    return AddrBopTable + IretBopSize * IrqNum;
}

VOID
PushRmInterrupt(
    PKTRAP_FRAME TrapFrame,
    ULONG   IretHookAddress,
    PVDM_TIB VdmTib,
    ULONG InterruptNumber
    )

/*++

Routine Description:

    Pushes RealMode interrupt frame onto the UserMode stack in the TrapFrame

Arguments:

    TrapFrame          - address of current trapframe
    IretHookAddress    - address of Iret Hook, 0 if none
    VdmTib             - address of current vdm tib
    InterruptNumber    - interrupt number to reflect


Return Value:

    None.

--*/

{
    ULONG      UserSS;
    USHORT     UserSP;
    USHORT     NewCS;
    USHORT     NewIP;
    PVDM_INTERRUPTHANDLER IntHandler;

    PAGED_CODE();

    //
    // Get pointers to current stack
    //

    UserSS  = TrapFrame->HardwareSegSs << 4;
    UserSP  = (USHORT) TrapFrame->HardwareEsp;

    //
    //  load interrupt stack frame, pushing flags, Cs and ip
    //

    try {
        ProbeForReadSmallStructure (UserSS + UserSP - 3 * sizeof (USHORT),
                                    3 * sizeof (USHORT),
                                    sizeof (UCHAR));
        UserSP -= 2;
        *(PUSHORT)(UserSS + UserSP) = (USHORT)TrapFrame->EFlags;
        UserSP -= 2;
        *(PUSHORT)(UserSS + UserSP) = (USHORT)TrapFrame->SegCs;
        UserSP -= 2;
        *(PUSHORT)(UserSS + UserSP) = (USHORT)TrapFrame->Eip;

        //
        // load IretHook stack frame if one exists
        //

        if (IretHookAddress) {
            ProbeForReadSmallStructure (UserSS + UserSP - 3 * sizeof (USHORT),
                                        3 * sizeof (USHORT),
                                        sizeof (UCHAR));
           UserSP -= 2;
           *(PUSHORT)(UserSS + UserSP) = (USHORT)(TrapFrame->EFlags & ~EFLAGS_TF_MASK);
           UserSP -= 2;
           *(PUSHORT)(UserSS + UserSP) = (USHORT)(IretHookAddress >> 16);
           UserSP -= 2;
           *(PUSHORT)(UserSS + UserSP) = (USHORT)IretHookAddress;
        }

        //
        //  Set new sp, ip, and cs.
        //

        IntHandler = &VdmTib->VdmInterruptTable[InterruptNumber];
        ProbeForReadSmallStructure (&IntHandler[InterruptNumber],
                                    sizeof (VDM_INTERRUPTHANDLER),
                                    sizeof (UCHAR));
        if (IntHandler->Flags & VDM_INT_HOOKED) {
            NewCS = (USHORT) (VdmTib->DpmiInfo.DosxRmReflector >> 16);
            NewIP = (USHORT) VdmTib->DpmiInfo.DosxRmReflector;

            //
            // now encode the interrupt number into CS
            //

            NewCS = (USHORT) (NewCS - InterruptNumber);
            NewIP = (USHORT) (NewIP + (InterruptNumber*16));

        } else {
            PUSHORT pIvtEntry = (PUSHORT) (InterruptNumber * 4);

            ProbeForReadSmallStructure (pIvtEntry,
                                        sizeof (USHORT) * 2,
                                        sizeof (UCHAR));
            NewIP = *pIvtEntry++;
            NewCS = *pIvtEntry;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return;
    }

    TrapFrame->HardwareEsp =  UserSP;
    TrapFrame->Eip         =  NewIP;

    ASSERT (KeGetCurrentIrql () >= APC_LEVEL);

    if ((TrapFrame->EFlags & EFLAGS_V86_MASK) == 0) {
        NewCS = SANITIZE_SEG (NewCS, UserMode);
        if (NewCS < 8) {
            NewCS = KGDT_R3_CODE | RPL_MASK;
        }
    }
    TrapFrame->SegCs       =  NewCS;
}

NTSTATUS
PushPmInterrupt(
    PKTRAP_FRAME TrapFrame,
    ULONG IretHookAddress,
    PVDM_TIB VdmTib,
    ULONG InterruptNumber
    )

/*++

Routine Description:

    Pushes ProtectMode interrupt frame onto the UserMode stack in the TrapFrame
    Raises an exception if an invalid stack is found

Arguments:

    TrapFrame       - address of current trapframe
    IretHookAddress - address of Iret Hook, 0 if none
    VdmTib          - address of current vdm tib
    InterruptNumber - interrupt number to reflect

Return Value:

    None.

--*/

{
    ULONG   Flags,Base,Limit;
    ULONG   VdmSp, VdmSpOrg;
    PUSHORT VdmStackPointer;
    BOOLEAN Frame32 = (BOOLEAN) VdmTib->DpmiInfo.Flags;
    PVDM_INTERRUPTHANDLER IntHandler;
    USHORT  NewCS;

    PAGED_CODE();

    //
    // Switch to "locked" dpmi stack if lock count is zero
    // This emulates the win3.1 Begin_Use_Locked_PM_Stack function.
    //

    try {
        if (!VdmTib->DpmiInfo.LockCount++) {
            VdmTib->DpmiInfo.SaveEsp        = TrapFrame->HardwareEsp;
            VdmTib->DpmiInfo.SaveEip        = TrapFrame->Eip;
            VdmTib->DpmiInfo.SaveSsSelector = (USHORT) TrapFrame->HardwareSegSs;
            TrapFrame->HardwareEsp       = 0x1000;
            TrapFrame->HardwareSegSs     = (ULONG) VdmTib->DpmiInfo.SsSelector | 0x7;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode ();
    }

    //
    // Use Sp or Esp ?
    //
    if (!Ki386GetSelectorParameters((USHORT)TrapFrame->HardwareSegSs,
                                    &Flags, &Base, &Limit)) {
        return STATUS_ACCESS_VIOLATION;
    }

    //
    // Adjust the limit for page granularity
    //
    if (Flags & SEL_TYPE_2GIG) {
        Limit = (Limit << 12) | 0xfff;
        }
    if (Limit != 0xffffffff) Limit++;

    VdmSp = (Flags & SEL_TYPE_BIG) ? TrapFrame->HardwareEsp
                                   : (USHORT)TrapFrame->HardwareEsp;

    //
    // Get pointer to current stack
    //
    VdmStackPointer = (PUSHORT)(Base + VdmSp);


    //
    // Create enough room for iret hook frame
    //
    VdmSpOrg = VdmSp;
    if (IretHookAddress) {
        if (Frame32) {
            VdmSp -= 3*sizeof(ULONG);
        } else {
            VdmSp -= 3*sizeof(USHORT);
        }
    }

    //
    // Create enough room for 2 iret frames
    //

    if (Frame32) {
        VdmSp -= 6*sizeof(ULONG);
    } else {
        VdmSp -= 6*sizeof(USHORT);
    }

    //
    // Set Final Value of Sp\Esp, do this before checking stack
    // limits so that invalid esp is visible to debuggers
    //
    if (Flags & SEL_TYPE_BIG) {
        TrapFrame->HardwareEsp = VdmSp;
    } else {
        TrapFrame->HardwareEsp = (USHORT)VdmSp;
    }


    //
    // Check stack limits
    // If any of the following conditions are TRUE
    //    - New stack pointer wraps (not enuf space)
    //    - If normal stack and Sp not below limit
    //    - If Expand Down stack and Sp not above limit
    //
    // Then raise a Stack Fault
    //
    if ( VdmSp >= VdmSpOrg ||
         !(Flags & SEL_TYPE_ED) && VdmSpOrg > Limit ||
         (Flags & SEL_TYPE_ED) && VdmSp < Limit ) {
        return STATUS_ACCESS_VIOLATION;
    }

    //
    // Build the Hw Int iret frame
    //

    try {
        if (Frame32) {
            //
            // Probe the stack pointer to make sure its good. We probe for read here
            // as we are faster. The code is going to write the addresses anyway.
            //
            ProbeForReadSmallStructure (VdmStackPointer - 6 * sizeof (ULONG),
                                        6 * sizeof (ULONG),
                                        sizeof (UCHAR));

            VdmStackPointer -= 2;
            *(PULONG)VdmStackPointer = TrapFrame->EFlags;

            VdmStackPointer -= 2;
            *(PUSHORT)VdmStackPointer = (USHORT)TrapFrame->SegCs;

            VdmStackPointer -= 2;
            *(PULONG)VdmStackPointer = TrapFrame->Eip;

            VdmStackPointer -= 2;
            *(PULONG)VdmStackPointer = TrapFrame->EFlags & ~EFLAGS_TF_MASK;

            VdmStackPointer -= 2;
            *(PULONG)VdmStackPointer = VdmTib->DpmiInfo.DosxIntIretD >> 16;

            VdmStackPointer -= 2;
            *(PULONG)VdmStackPointer = VdmTib->DpmiInfo.DosxIntIretD & 0xffff;

        } else {
            ProbeForReadSmallStructure (VdmStackPointer - 6 * sizeof (USHORT),
                                        6 * sizeof (USHORT),
                                        sizeof (UCHAR));

            VdmStackPointer -= 1;
            *VdmStackPointer = (USHORT)TrapFrame->EFlags;

            VdmStackPointer -= 1;
            *VdmStackPointer = (USHORT)TrapFrame->SegCs;

            VdmStackPointer -= 1;
            *VdmStackPointer = (USHORT)TrapFrame->Eip;

            VdmStackPointer -= 1;
            *VdmStackPointer = (USHORT)(TrapFrame->EFlags & ~EFLAGS_TF_MASK);

            VdmStackPointer -= 2;
            *(PULONG)VdmStackPointer = VdmTib->DpmiInfo.DosxIntIret;
        }

        //
        // Point cs and ip at interrupt handler
        //
        IntHandler = &VdmTib->VdmInterruptTable[InterruptNumber];
        ProbeForReadSmallStructure (&IntHandler[InterruptNumber],
                                    sizeof (VDM_INTERRUPTHANDLER),
                                    sizeof (UCHAR));
        NewCS = IntHandler->CsSelector | 0x7;
        if ((TrapFrame->EFlags & EFLAGS_V86_MASK) == 0) {
            NewCS = SANITIZE_SEG (NewCS, UserMode);
            if (NewCS < 8) {
                NewCS = KGDT_R3_CODE | RPL_MASK;
            }
        }
        TrapFrame->SegCs = NewCS;
        TrapFrame->Eip   = IntHandler->Eip;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode ();
    }

    //
    // Turn off trace bit so we don't trace the iret hook
    //
    ASSERT (KeGetCurrentIrql () >= APC_LEVEL);

    TrapFrame->EFlags &= ~EFLAGS_TF_MASK;

    //
    // Build the Irethook Iret frame, if one exists
    //
    if (IretHookAddress) {
        ULONG SegCs, Eip;

        //
        // Point cs and eip at the iret hook, so when we build
        // the frame below, the correct contents are set
        //
        SegCs = IretHookAddress >> 16;
        Eip   = IretHookAddress & 0xFFFF;


        try {
            if (Frame32) {

                ProbeForReadSmallStructure (VdmStackPointer - 3 * sizeof (ULONG),
                                            3 * sizeof (ULONG),
                                            sizeof (UCHAR));

                VdmStackPointer -= 2;
                *(PULONG)VdmStackPointer = TrapFrame->EFlags;

                VdmStackPointer -= 2;
                *VdmStackPointer = (USHORT)SegCs;

                VdmStackPointer -= 2;
                *(PULONG)VdmStackPointer = Eip;

            } else {

                ProbeForReadSmallStructure (VdmStackPointer - 3 * sizeof (USHORT),
                                            3 * sizeof (USHORT),
                                            sizeof (UCHAR));

                VdmStackPointer -= 1;
                *VdmStackPointer = (USHORT)TrapFrame->EFlags;

                VdmStackPointer -= 1;
                *VdmStackPointer = (USHORT)SegCs;

                VdmStackPointer -= 1;
                *VdmStackPointer = (USHORT)Eip;

            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode ();
        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS
VdmpDelayInterrupt (
    PVDMDELAYINTSDATA pdsd
    )

/*++

Routine Description:

    Sets a timer to dispatch the delayed interrupt through KeSetTimer.
    When the timer fires a user mode APC is queued to queue the interrupt.

    This function uses lazy allocation routines to allocate internal
    data structures (nonpaged pool) on a per Irq basis, and needs to
    be notified when specific Irq Lines no longer need Delayed
    Interrupt services.

    The caller must own the IcaLock to synchronize access to the
    Irq lists.

    WARNING: - Until the Delayed interrupt fires or is cancelled,
               the specific Irq line will not generate any interrupts.

             - The APC routine, does not take the HostIca lock, when
               unblocking the IrqLine. Devices which use delayed Interrupts
               should not queue ANY additional interrupts for the same IRQ
               line until the delayed interrupt has fired or been cancelled.

Arguments:

    pdsd.Delay         Delay Interval in usecs
                       if Delay is 0xFFFFFFFF then per Irq Line nonpaged
                           data structures are freed. No Timers are set.
                       else the Delay is used as the timer delay.

    pdsd.DelayIrqLine  IrqLine Number

    pdsd.hThread       Thread Handle of CurrentMonitorTeb


Return Value:

    NTSTATUS.

--*/

{
    VDMDELAYINTSDATA Capturedpdsd;
    PVDM_PROCESS_OBJECTS pVdmObjects;
    PLIST_ENTRY   Next;
    PEPROCESS     Process;
    PDELAYINTIRQ  pDelayIntIrq;
    PDELAYINTIRQ  NewIrq;
    PETHREAD      Thread, MainThread;
    NTSTATUS      Status;
    KIRQL         OldIrql;
    ULONG         IrqLine;
    ULONG         Delay;
    PULONG        pDelayIrq;
    PULONG        pUndelayIrq;
    LARGE_INTEGER liDelay;
    LOGICAL       FreeIrqLine;
    LOGICAL       AlreadyInUse;

    //
    // Get a pointer to pVdmObjects
    //
    Process = PsGetCurrentProcess();
    pVdmObjects = Process->VdmObjects;

    if (pVdmObjects == NULL) {
        return STATUS_INVALID_PARAMETER_1;
    }

    Status = STATUS_SUCCESS;
    Thread = MainThread = NULL;
    FreeIrqLine = TRUE;
    AlreadyInUse = FALSE;

    try {

        //
        // Probe the parameters
        //

        ProbeForRead(pdsd, sizeof(VDMDELAYINTSDATA), sizeof(ULONG));
        RtlCopyMemory (&Capturedpdsd, pdsd, sizeof (VDMDELAYINTSDATA));

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Form a BitMask for the IrqLine Number
    //

    IrqLine = 1 << Capturedpdsd.DelayIrqLine;
    if (!IrqLine) {
        return STATUS_INVALID_PARAMETER_2;
    }

    ExAcquireFastMutex(&pVdmObjects->DelayIntFastMutex);

    pDelayIrq = pVdmObjects->pIcaUserData->pDelayIrq;
    pUndelayIrq = pVdmObjects->pIcaUserData->pUndelayIrq;

    try {

        ProbeForWriteUlong(pDelayIrq);
        ProbeForWriteUlong(pUndelayIrq);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ExReleaseFastMutex(&pVdmObjects->DelayIntFastMutex);
        return GetExceptionCode();
    }

    pDelayIntIrq = NULL;        // satisfy no_opt compilation

    //
    // Convert the Delay parameter into hundredths of nanosecs
    //

    Delay = Capturedpdsd.Delay;

    //
    // Check to see if we need to reset the timer resolution
    //

    if (Delay == 0xFFFFFFFF) {
        ZwSetTimerResolution(KeMaximumIncrement, FALSE, &Delay);
        NewIrq = NULL;
        goto FindIrq;
    }

    FreeIrqLine = FALSE;

    //
    // Convert delay to hundreths of nanosecs
    // and ensure min delay of 1 msec
    //

    Delay = Delay < 1000 ? 10000 : Delay * 10;

    //
    // If the delay time is close to the system's clock rate
    // then adjust the system's clock rate and if needed
    // the delay time so that the timer will fire before the
    // the due time.
    //

    if (Delay < 150000) {

         ULONG ul = Delay >> 1;

         if (ul < KeTimeIncrement && KeTimeIncrement > KeMinimumIncrement) {
             ZwSetTimerResolution(ul, TRUE, (PULONG)&liDelay.LowPart);
         }

         if (Delay < KeTimeIncrement) {
             // can't set system clock rate low enuf, so use half delay
             Delay >>= 1;
         }
         else if (Delay < (KeTimeIncrement << 1)) {
             // Real close to the system clock rate, lower delay
             // proportionally, to avoid missing clock cycles.
             Delay -= KeTimeIncrement >> 1;
         }
    }

    //
    // Reference the Target Thread
    //

    Status = ObReferenceObjectByHandle (Capturedpdsd.hThread,
                                        THREAD_QUERY_INFORMATION,
                                        PsThreadType,
                                        KeGetPreviousMode(),
                                        &Thread,
                                        NULL);

    if (!NT_SUCCESS(Status)) {
        ExReleaseFastMutex(&pVdmObjects->DelayIntFastMutex);
        return Status;
    }

    MainThread = pVdmObjects->MainThread;

    ObReferenceObject (MainThread);

    NewIrq = NULL;

FindIrq:

    ExAcquireSpinLock(&pVdmObjects->DelayIntSpinLock, &OldIrql);

    //
    // Search the DelayedIntList for a matching Irq Line.
    //

    Next = pVdmObjects->DelayIntListHead.Flink;
    while (Next != &pVdmObjects->DelayIntListHead) {
        pDelayIntIrq = CONTAINING_RECORD(Next, DELAYINTIRQ, DelayIntListEntry);
        if (pDelayIntIrq->IrqLine == IrqLine) {
            break;
        }
        Next = Next->Flink;
    }

    if (Next == &pVdmObjects->DelayIntListHead) {

        pDelayIntIrq = NULL;

        if (FreeIrqLine) {
            goto VidExit;
        }

        if (NewIrq == NULL) {

            ExReleaseSpinLock(&pVdmObjects->DelayIntSpinLock, OldIrql);

            //
            // If a DelayIntIrq does not exist for this irql, allocate one
            // from nonpaged pool and initialize it
            //

            NewIrq = ExAllocatePoolWithTag (NonPagedPool,
                                            sizeof(DELAYINTIRQ),
                                            ' MDV');

            if (!NewIrq) {
                Status = STATUS_NO_MEMORY;
                AlreadyInUse = TRUE;
                goto VidExit2;
            }

            try {
                PsChargePoolQuota(Process, NonPagedPool, sizeof(DELAYINTIRQ));
            }
            except(EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
                ExFreePool(NewIrq);
                AlreadyInUse = TRUE;
                goto VidExit2;
            }

            RtlZeroMemory(NewIrq, sizeof(DELAYINTIRQ));
            NewIrq->IrqLine = IrqLine;

            KeInitializeTimer(&NewIrq->Timer);

            KeInitializeDpc(&NewIrq->Dpc,
                            VdmpDelayIntDpcRoutine,
                            Process);

            goto FindIrq;
        }

        InsertTailList (&pVdmObjects->DelayIntListHead,
                        &NewIrq->DelayIntListEntry);

        pDelayIntIrq = NewIrq;
    }
    else if (NewIrq != NULL) {
        ExFreePool (NewIrq);
        PsReturnPoolQuota (Process, NonPagedPool, sizeof(DELAYINTIRQ));
    }

    if (Delay == 0xFFFFFFFF) {
         if (pDelayIntIrq->InUse == VDMDELAY_KTIMER) {
             pDelayIntIrq->InUse = VDMDELAY_NOTINUSE;
             pDelayIntIrq = NULL;
         }
    }
    else if (pDelayIntIrq->InUse == VDMDELAY_NOTINUSE) {
         liDelay = RtlEnlargedIntegerMultiply(Delay, -1);
         if (KeSetTimerEx (&pDelayIntIrq->Timer, liDelay, 0, &pDelayIntIrq->Dpc) == FALSE) {
            ObReferenceObject(Process);
         }
    }

VidExit:

    if (pDelayIntIrq && !pDelayIntIrq->InUse) {

        if (NT_SUCCESS(Status)) {
            //
            // Save PETHREAD of Target thread for the dpc routine
            // the DPC routine will deref the threads.
            //
            pDelayIntIrq->InUse = VDMDELAY_KTIMER;
            pDelayIntIrq->Thread = Thread;
            Thread = NULL;
            pDelayIntIrq->MainThread = MainThread;
            MainThread = NULL;
        }
        else {
            pDelayIntIrq->InUse = VDMDELAY_NOTINUSE;
            pDelayIntIrq->Thread = NULL;
            FreeIrqLine = TRUE;
        }
    }
    else {
        AlreadyInUse = TRUE;
    }


    ExReleaseSpinLock(&pVdmObjects->DelayIntSpinLock, OldIrql);

VidExit2:

    try {
        if (FreeIrqLine) {
            *pDelayIrq &= ~IrqLine;
            InterlockedOr ((PLONG)pUndelayIrq, IrqLine);
        }
        else  if (!AlreadyInUse) {  // TakeIrqLine
            *pDelayIrq |= IrqLine;
            InterlockedAnd ((PLONG)pUndelayIrq, ~IrqLine);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)  {
        Status = GetExceptionCode();
    }

    ExReleaseFastMutex(&pVdmObjects->DelayIntFastMutex);

    if (Thread) {
        ObDereferenceObject(Thread);
    }

    if (MainThread) {
        ObDereferenceObject(MainThread);
    }

    return Status;

}

VOID
VdmpDelayIntDpcRoutine (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is the DPC routine that is called when a DelayedInterrupt
    timer expires. Its function is to insert the associated APC into the
    target thread's APC queue.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Supplies a pointer to the Target EProcess

    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to
        two arguments that contain untyped data that are
        NOT USED.


Return Value:

    None.

--*/

{
    LOGICAL      FreeEntireVdm;
    PVDM_PROCESS_OBJECTS pVdmObjects;
    PEPROCESS    Process;
    PETHREAD     Thread, MainThread;
    PLIST_ENTRY  Next;
    PDELAYINTIRQ pDelayIntIrq;

    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    FreeEntireVdm = FALSE;

    //
    // Get address of Process VdmObjects
    //

    Process = (PEPROCESS)DeferredContext;
    pVdmObjects = (PVDM_PROCESS_OBJECTS)Process->VdmObjects;

    ASSERT (KeGetCurrentIrql () == DISPATCH_LEVEL);
    ExAcquireSpinLockAtDpcLevel(&pVdmObjects->DelayIntSpinLock);

    //
    // Search the DelayedIntList for the matching Dpc.
    //

    Next = pVdmObjects->DelayIntListHead.Flink;
    while (Next != &pVdmObjects->DelayIntListHead) {
        pDelayIntIrq = CONTAINING_RECORD(Next,DELAYINTIRQ,DelayIntListEntry);
        if (&pDelayIntIrq->Dpc == Dpc) {
            Thread = pDelayIntIrq->Thread;
            pDelayIntIrq->Thread = NULL;
            MainThread = pDelayIntIrq->MainThread;
            pDelayIntIrq->MainThread = NULL;
            if (pDelayIntIrq->InUse) {

                if ((Thread && KeVdmInsertQueueApc(&pDelayIntIrq->Apc,
                                    &Thread->Tcb,
                                    KernelMode,
                                    VdmpDelayIntApcRoutine,
                                    VdmpRundownRoutine,
                                    VdmpQueueIntNormalRoutine, // normal routine
                                    NULL,                      // NormalContext
                                    VDM_HWINT_INCREMENT
                                    ))
                ||

                (MainThread && KeVdmInsertQueueApc(&pDelayIntIrq->Apc,
                                    &MainThread->Tcb,
                                    KernelMode,
                                    VdmpDelayIntApcRoutine,
                                    VdmpRundownRoutine,
                                    VdmpQueueIntNormalRoutine, // normal routine
                                    NULL,                      // NormalContext
                                    VDM_HWINT_INCREMENT
                                    )))
                {
                    pDelayIntIrq->InUse  = VDMDELAY_KAPC;
                }
                else {
                    // This hwinterrupt line is blocked forever.
                    pDelayIntIrq->InUse  = VDMDELAY_NOTINUSE;
                }
            }

            ExReleaseSpinLockFromDpcLevel(&pVdmObjects->DelayIntSpinLock);

            if (Thread) {
                ObDereferenceObject (Thread);
            }

            if (MainThread) {
                ObDereferenceObject (MainThread);
            }

            ObDereferenceObject (Process);
            return;
        }

        Next = Next->Flink;
    }

    ExReleaseSpinLockFromDpcLevel(&pVdmObjects->DelayIntSpinLock);
    return;
}

VOID
VdmpDelayIntApcRoutine (
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function is the special APC routine that is called to
    dispatch a delayed interrupt. This routine clears the IrqLine
    bit, VdmpQueueIntApcRoutine will restart interrupts.

Arguments:

    Apc - Supplies a pointer to the APC object used to invoke this routine.

    NormalRoutine - Supplies a pointer to a pointer to an optional
        normal routine, which is executed when wow is blocked.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized and is
        NOT USED.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to
        two arguments that contain untyped data that are
        NOT USED.

Return Value:

    None.

--*/

{
    KIRQL           OldIrql;
    PLIST_ENTRY     Next;
    PDELAYINTIRQ    pDelayIntIrq;
    KPROCESSOR_MODE ProcessorMode;
    PULONG          pDelayIrq;
    PULONG          pUndelayIrq;
    PULONG          pDelayIret;
    ULONG           IrqLine;
    LOGICAL         FreeIrqLine;
    LOGICAL         QueueApc;
    PVDM_PROCESS_OBJECTS pVdmObjects;

    UNREFERENCED_PARAMETER (NormalContext);

    FreeIrqLine = FALSE;
    IrqLine = 0;               // satisfy no_opt compilation

    //
    // Clear address of thread object in APC object.
    //
    // N.B. The delay interrupt lock is used to synchronize access to APC
    //      objects that are manipulated by VDM.
    //

    pVdmObjects = PsGetCurrentProcess ()->VdmObjects;
    ExAcquireFastMutex (&pVdmObjects->DelayIntFastMutex);
    ExAcquireSpinLock (&pVdmObjects->DelayIntSpinLock, &OldIrql);
    KeVdmClearApcThreadAddress (Apc);

    //
    // Search the DelayedIntList for the pDelayIntIrq.
    //

    Next = pVdmObjects->DelayIntListHead.Flink;
    while (Next != &pVdmObjects->DelayIntListHead) {

        pDelayIntIrq = CONTAINING_RECORD(Next,DELAYINTIRQ,DelayIntListEntry);
        if (&pDelayIntIrq->Apc == Apc) {

            //
            // Found the IrqLine in the DelayedIntList, restart interrupts.
            //

            if (pDelayIntIrq->InUse) {
                pDelayIntIrq->InUse = VDMDELAY_NOTINUSE;
                IrqLine = pDelayIntIrq->IrqLine;
                FreeIrqLine = TRUE;
            }
            break;
        }
        Next = Next->Flink;
    }

    ExReleaseSpinLock (&pVdmObjects->DelayIntSpinLock, OldIrql);

    if (FreeIrqLine == FALSE) {
        ExReleaseFastMutex (&pVdmObjects->DelayIntFastMutex);
        return;
    }

    pDelayIrq = pVdmObjects->pIcaUserData->pDelayIrq;
    pUndelayIrq = pVdmObjects->pIcaUserData->pUndelayIrq;
    pDelayIret = pVdmObjects->pIcaUserData->pDelayIret;

    QueueApc = FALSE;

    try {

        //
        // These variables are being modified without holding the
        // ICA lock. This should be OK because none of the ntvdm
        // devices (timer, mouse etc. should ever do a delayed int
        // while a previous delayed interrupt is still pending.
        //

        *pDelayIrq &= ~IrqLine;
        InterlockedOr ((PLONG)pUndelayIrq, IrqLine);

        //
        // If we are waiting for an iret hook we have nothing left to do
        // since the iret hook will restart interrupts.
        //

        if (!(IrqLine & *pDelayIret)) {

           //
           // set hardware int pending
           //

           InterlockedOr (FIXED_NTVDMSTATE_LINEAR_PC_AT, VDM_INT_HARDWARE);

           //
           // Queue a usermode APC to dispatch interrupts, note
           // try protection is not needed.
           //

           if (NormalRoutine) {
               QueueApc = TRUE;
           }
        }
    }
    except(VdmpExceptionHandler(GetExceptionInformation())) {
        NOTHING;
    }

    if (QueueApc == TRUE) {
        ProcessorMode = KernelMode;
        VdmpQueueIntApcRoutine(Apc,
                               NormalRoutine,
                               (PVOID *)&ProcessorMode,
                               SystemArgument1,
                               SystemArgument2);
    }

    ExReleaseFastMutex(&pVdmObjects->DelayIntFastMutex);
    return;
}

BOOLEAN
VdmpDispatchableIntPending(
    ULONG EFlags
    )

/*++

Routine Description:

    This routine determines whether or not there is a dispatchable
    virtual interrupt to dispatch.

Arguments:

    EFlags -- supplies a pointer to the EFlags to be checked

Return Value:

    True -- a virtual interrupt should be dispatched
    False -- no virtual interrupt should be dispatched

--*/

{
    PAGED_CODE();

    //
    // The accesses to FIXED_NTVDMSTATE_LINEAR_PC_AT may be invalid so
    // wrap this in an exception handler.
    //

    try {

        if (EFlags & EFLAGS_V86_MASK) {
            if (KeI386VirtualIntExtensions & V86_VIRTUAL_INT_EXTENSIONS) {
                if(0 != (EFlags & EFLAGS_VIF)) {
                    return TRUE;
                }
            } else if (0 != (*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_VIRTUAL_INTERRUPTS)) {
                return TRUE;
            }
        } else {
                if ((*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_VIRTUAL_INTERRUPTS) == 0) {
                    VdmCheckPMCliTimeStamp();
                }

                //
                // Check again.  The call to VdmCheckPMCliTimeStamp may enable it.
                //

                if (0 != (*FIXED_NTVDMSTATE_LINEAR_PC_AT & VDM_VIRTUAL_INTERRUPTS)) {
                    return TRUE;
                }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    return FALSE;
}

NTSTATUS
VdmpIsThreadTerminating(
    HANDLE ThreadId
    )

/*++

Routine Description:

    This routine determines if the specified thread is terminating or not.

Arguments:

Return Value:

    True --
    False -

--*/

{
    CLIENT_ID     Cid;
    PETHREAD      Thread;
    NTSTATUS      Status;

    PAGED_CODE();

    //
    // If the owning thread juest exited the IcaLock the
    // OwningThread Tid may be NULL, return success, since
    // we don't know what the owning thread's state was.
    //

    if (!ThreadId) {
        return STATUS_SUCCESS;
    }

    Cid.UniqueProcess = NtCurrentTeb()->ClientId.UniqueProcess;
    Cid.UniqueThread  = ThreadId;

    Status = PsLookupProcessThreadByCid (&Cid, NULL, &Thread);

    if (NT_SUCCESS(Status)) {
        Status = PsIsThreadTerminating(Thread) ? STATUS_THREAD_IS_TERMINATING
                                               : STATUS_SUCCESS;
        ObDereferenceObject(Thread);
    }

    return Status;
}

VOID
VdmpRundownRoutine (
    IN PKAPC Apc
    )

/*++

Routine Description:

    The function is the rundown routine for VDM APCs and is called on thread
    termination. The fact that this function is called means that none of the
    APC objects specified by the process VDM structure will not get freed.
    They must be freed when the process terminates.

Arguments:

    Apc - Supplies a pointer to an APC object to be rundown.

Return Value:

    None.

--*/

{

    //
    // Clear the Irqline, but don't requeue the APC.
    //

    VdmpDelayIntApcRoutine(Apc, NULL, NULL, NULL, NULL);
    return;
}

int
VdmpExceptionHandler (
    IN PEXCEPTION_POINTERS ExceptionInfo
    )
{

#if DBG
    PEXCEPTION_RECORD ExceptionRecord;
    ULONG NumberParameters;
    PULONG ExceptionInformation;
#endif

    PAGED_CODE();

#if DBG

    ExceptionRecord = ExceptionInfo->ExceptionRecord;
    DbgPrint("VdmExRecord ExCode %x Flags %x Address %x\n",
             ExceptionRecord->ExceptionCode,
             ExceptionRecord->ExceptionFlags,
             ExceptionRecord->ExceptionAddress
             );

    NumberParameters = ExceptionRecord->NumberParameters;
    if (NumberParameters) {
        DbgPrint("VdmExRecord Parameters:\n");

        ExceptionInformation = ExceptionRecord->ExceptionInformation;
        while (NumberParameters--) {
           DbgPrint("\t%x\n", *ExceptionInformation);
           }
        }

#else
    UNREFERENCED_PARAMETER (ExceptionInfo);
#endif

    return EXCEPTION_EXECUTE_HANDLER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdmtib.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vdmtib.c

Abstract:

    This module contains routines that provide secure access to
    the vdmtib from user-mode or kernel-mode object

Author:

    Vadim Bluvshteyn (vadimb) Jul-28-1998

Revision History:

--*/


#include "vdmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, VdmpGetVdmTib)
#endif

NTSTATUS
VdmpGetVdmTib(
   OUT PVDM_TIB *ppVdmTib
   )

/*++

Routine Description:

Arguments:

Return Value:

    NTStatus reflecting results of the probe made to the user-mode
    vdmtib memory

--*/
{
    PVDM_TIB VdmTib;
    NTSTATUS Status = STATUS_SUCCESS;
    PAGED_CODE();

    try {

        VdmTib = NtCurrentTeb()->Vdm;
        if (VdmTib == NULL) {
            Status = STATUS_UNSUCCESSFUL;
            leave;
        }

        //
        // Make sure it is a valid VdmTib
        //

        ProbeForWriteSmallStructure(VdmTib, sizeof(VDM_TIB), sizeof(UCHAR));

        if (VdmTib->Size != sizeof(VDM_TIB)) {
            Status = STATUS_UNSUCCESSFUL;
            VdmTib = NULL;
            leave;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    *ppVdmTib = VdmTib;

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdmprint.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vdmprint.c

Abstract:

    This module contains the support for printing ports which could be
    handled in kernel without going to ntvdm.exe

Author:

    Sudeep Bharati (sudeepb) 16-Jan-1993

Revision History:
    William Hsieh (williamh) 31-May-1996
        rewrote for Dongle support

--*/


#include "vdmp.h"
#include <ntddvdm.h>

NTSTATUS
VdmpFlushPrinterWriteData (
    IN USHORT Adapter
    );

#define DATA_PORT_OFFSET	0
#define STATUS_PORT_OFFSET	1
#define CONTROL_PORT_OFFSET	2

#define LPT1_PORT_STATUS        0x3bd
#define LPT2_PORT_STATUS        0x379
#define LPT3_PORT_STATUS        0x279
#define LPT_MASK                0xff0
#define IRQ                     0x10

#define NOTBUSY                 0x80
#define HOST_LPT_BUSY           (1 << 0)
#define STATUS_REG_MASK         0x07


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, VdmPrinterStatus)
#pragma alloc_text(PAGE, VdmPrinterWriteData)
#pragma alloc_text(PAGE, VdmpFlushPrinterWriteData)
#pragma alloc_text(PAGE, VdmpPrinterInitialize)
#pragma alloc_text(PAGE, VdmpPrinterDirectIoOpen)
#pragma alloc_text(PAGE, VdmpPrinterDirectIoClose)
#endif



BOOLEAN
VdmPrinterStatus (
    IN ULONG iPort,
    IN ULONG cbInstructionSize,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine handles the read operation on the printer status port

Arguments:
    iPort              - port on which the io was trapped
    cbInstructionSize  - Instruction size to update TsEip
    TrapFrame          - Trap Frame

Return Value:

    True if successful, False otherwise

--*/
{
    UCHAR PrtMode;
    HANDLE PrintHandle;
    volatile PUCHAR HostStatus;
    volatile PUCHAR AdapterStatus;
    volatile PUCHAR AdapterControl;
    USHORT adapter;
    KIRQL OldIrql;
    PVDM_TIB VdmTib;
    NTSTATUS Status;
    PULONG printer_status;
    LOGICAL IssueIoControl;
    PVDM_PRINTER_INFO PrtInfo;
    PIO_STATUS_BLOCK IoStatusBlock;
    PVDM_PROCESS_OBJECTS VdmObjects;

    PAGED_CODE();

    Status = VdmpGetVdmTib(&VdmTib);

    if (!NT_SUCCESS(Status)) {
       return FALSE;
    }

    OldIrql = PASSIVE_LEVEL;
    PrintHandle = (HANDLE)-1;
    PrtInfo = &VdmTib->PrinterInfo;
    IoStatusBlock = (PIO_STATUS_BLOCK) &VdmTib->TempArea1;
    printer_status = &VdmTib->PrinterInfo.prt_Scratch;
    IssueIoControl = FALSE;

    try {

        //
        // First figure out which PRT we are dealing with. The
        // port addresses in the PrinterInfo are base address of each
        // PRT sorted in the adapter order.
        //

        *FIXED_NTVDMSTATE_LINEAR_PC_AT |= VDM_IDLEACTIVITY;

        if ((USHORT)iPort == PrtInfo->prt_PortAddr[0] + STATUS_PORT_OFFSET) {
            adapter = 0;
        }
        else if ((USHORT)iPort == PrtInfo->prt_PortAddr[1] + STATUS_PORT_OFFSET) {
            adapter = 1;
        }
        else if ((USHORT)iPort == PrtInfo->prt_PortAddr[2] + STATUS_PORT_OFFSET) {
            adapter = 2;
        }
        else {
            // something must be wrong in our code, better check it out
            ASSERT (FALSE);
            return FALSE;
        }

        PrtMode = PrtInfo->prt_Mode[adapter];

        VdmObjects = (PVDM_PROCESS_OBJECTS) (PsGetCurrentProcess()->VdmObjects);

        AdapterStatus = VdmObjects->PrinterStatus + adapter;

        if (PRT_MODE_SIMULATE_STATUS_PORT == PrtMode) {

            //
            // We are simulating a printer status read.
            // Get the current status from softpc.
            //

            HostStatus = VdmObjects->PrinterHostState + adapter;

            if (!(*AdapterStatus & NOTBUSY) && !(*HostStatus & HOST_LPT_BUSY)) {

                AdapterControl = VdmObjects->PrinterControl + adapter;

                if (*AdapterControl & IRQ) {
                    return FALSE;
                }
                *AdapterStatus = (*AdapterStatus | NOTBUSY);
            }
            *printer_status = (ULONG)(*AdapterStatus | STATUS_REG_MASK);

            TrapFrame->Eax &= 0xffffff00;
            TrapFrame->Eax |= (UCHAR)*printer_status;
            TrapFrame->Eip += cbInstructionSize;
        }
        else if (PRT_MODE_DIRECT_IO == PrtMode) {

            //
            // We have to read the I/O directly (of course, through file system
            // which in turn goes to the driver).
            // Before performing the read, flush out all pending output data
            // in our buffer. This is done because the status we are about
            // to read may depend on the pending output data.
            //

            if (PrtInfo->prt_BytesInBuffer[adapter]) {
                Status = VdmpFlushPrinterWriteData (adapter);
#ifdef DBG
                if (!NT_SUCCESS(Status)) {
                    DbgPrint("VdmPrintStatus: failed to flush buffered data, status = %ls\n", Status);
                }
#endif
            }

            //
            // Capture this argument first as this reference may cause an
            // exception.
            //

            PrintHandle = PrtInfo->prt_Handle[adapter];

            //
            // Lower irql to PASSIVE before doing any I/O.
            //

            OldIrql = KeGetCurrentIrql ();

            KeLowerIrql (PASSIVE_LEVEL);

            IssueIoControl = TRUE;
        }
        else {

            //
            // We don't simulate it here.
            //

            return FALSE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (IssueIoControl == TRUE) {

        Status = NtDeviceIoControlFile(PrintHandle,
                                       NULL,        // notification event
                                       NULL,        // APC routine
                                       NULL,        // Apc Context
                                       IoStatusBlock,
                                       IOCTL_VDM_PAR_READ_STATUS_PORT,
                                       NULL,
                                       0,
                                       printer_status,
                                       sizeof(ULONG));

        try {

            if (!NT_SUCCESS(Status) || !NT_SUCCESS(IoStatusBlock->Status)) {

                //
                // fake a status to make it looks like the port is not connected
                // to a printer.
                //

                *printer_status = 0x7F;
#ifdef DBG
                DbgPrint("VdmPrinterStatus: failed to get status from printer, status = %lx\n", Status);
#endif
                //
                // Always tell the caller that we have simulated the operation.
                //

                Status = STATUS_SUCCESS;
            }

            TrapFrame->Eax &= 0xffffff00;
            TrapFrame->Eax |= (UCHAR)*printer_status;
            TrapFrame->Eip += cbInstructionSize;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }

        //
        // Regardless of any exceptions that may have occurred, we must
        // restore our caller's IRQL since we lowered it.
        //

        KeRaiseIrql (OldIrql, &OldIrql);
    }

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
VdmPrinterWriteData (
    IN ULONG iPort,
    IN ULONG cbInstructionSize,
    IN PKTRAP_FRAME TrapFrame
    )
{
    PVDM_PRINTER_INFO   PrtInfo;
    USHORT   adapter;
    PVDM_TIB VdmTib;
    NTSTATUS Status;

    PAGED_CODE();

    Status = VdmpGetVdmTib(&VdmTib);

    if (!NT_SUCCESS(Status)) {
       return FALSE;
    }

    PrtInfo = &VdmTib->PrinterInfo;

    try {

        //
        // First figure out which PRT we are dealing with. The
        // port addresses in the PrinterInfo are base address of each
        // PRT sorted in the adapter order.
        //

        *FIXED_NTVDMSTATE_LINEAR_PC_AT |= VDM_IDLEACTIVITY;

        if ((USHORT)iPort == PrtInfo->prt_PortAddr[0] + DATA_PORT_OFFSET) {
            adapter = 0;
        }
        else if ((USHORT)iPort == PrtInfo->prt_PortAddr[1] + DATA_PORT_OFFSET) {
            adapter = 1;
        }
        else if ((USHORT)iPort == PrtInfo->prt_PortAddr[2] + DATA_PORT_OFFSET) {
            adapter = 2;
        }
        else {
            // something must be wrong in our code, better check it out
            ASSERT(FALSE);
            return FALSE;
        }

        if (PRT_MODE_DIRECT_IO == PrtInfo->prt_Mode[adapter]) {

            PrtInfo->prt_Buffer[adapter][PrtInfo->prt_BytesInBuffer[adapter]] = (UCHAR)TrapFrame->Eax;

            //
            // buffer full, then flush it out
            //

            if (++PrtInfo->prt_BytesInBuffer[adapter] >= PRT_DATA_BUFFER_SIZE) {
                VdmpFlushPrinterWriteData(adapter);
            }

            TrapFrame->Eip += cbInstructionSize;
        }
        else {
            Status = STATUS_ILLEGAL_INSTRUCTION;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }
    return TRUE;

}

NTSTATUS
VdmpFlushPrinterWriteData (
    IN USHORT adapter
    )
{
    KIRQL OldIrql;
    PVDM_TIB VdmTib;
    HANDLE PrintHandle;
    NTSTATUS Status;
    PVDM_PRINTER_INFO PrtInfo;
    PIO_STATUS_BLOCK IoStatusBlock;
    PVOID InputBuffer;
    ULONG InputBufferLength;

    PAGED_CODE();

    Status = VdmpGetVdmTib (&VdmTib);

    if (!NT_SUCCESS(Status)) {
       return FALSE;
    }

    InputBuffer = NULL;
    InputBufferLength = 0;
    PrintHandle = (HANDLE)-1;

    PrtInfo = &VdmTib->PrinterInfo;
    IoStatusBlock = (PIO_STATUS_BLOCK)&VdmTib->TempArea1;

    try {
        if (PrtInfo->prt_Handle[adapter] &&
            PrtInfo->prt_BytesInBuffer[adapter] &&
            PRT_MODE_DIRECT_IO == PrtInfo->prt_Mode[adapter]) {

            PrintHandle = PrtInfo->prt_Handle[adapter];
            InputBuffer = &PrtInfo->prt_Buffer[adapter][0];
            InputBufferLength = PrtInfo->prt_BytesInBuffer[adapter];
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (NT_SUCCESS(Status)) {
        OldIrql = KeGetCurrentIrql();

        KeLowerIrql(PASSIVE_LEVEL);

        Status = NtDeviceIoControlFile(PrintHandle,
                                       NULL,        // notification event
                                       NULL,        // APC routine
                                       NULL,        // APC context
                                       IoStatusBlock,
                                       IOCTL_VDM_PAR_WRITE_DATA_PORT,
                                       InputBuffer,
                                       InputBufferLength,
                                       NULL,
                                       0);

        try {
            PrtInfo->prt_BytesInBuffer[adapter] = 0;
            if (!NT_SUCCESS(Status)) {
#ifdef DBG
                DbgPrint("IOCTL_VDM_PAR_WRITE_DATA_PORT failed %lx %x\n",
                     Status, IoStatusBlock->Status);
#endif
                Status = IoStatusBlock->Status;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }

        KeRaiseIrql (OldIrql, &OldIrql);
    }

    return Status;

}


NTSTATUS
VdmpPrinterInitialize (
    IN PVOID ServiceData
    )
/*++

Routine Description:

    This routine probes and caches the data associated with kernel
    mode printer emulation.

Arguments:

    ServiceData - Not used.

Return Value:


--*/
{
    PUCHAR State, PrtStatus, Control, HostState;
    PVDM_TIB VdmTib;
    PVDM_PROCESS_OBJECTS VdmObjects;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER (ServiceData);

    //
    // Note:  We only support two printers in the kernel.
    //

    Status = VdmpGetVdmTib(&VdmTib);

    if (!NT_SUCCESS(Status)) {
       return FALSE;
    }

    try {
        State = VdmTib->PrinterInfo.prt_State;
        PrtStatus = VdmTib->PrinterInfo.prt_Status;
        Control = VdmTib->PrinterInfo.prt_Control;
        HostState = VdmTib->PrinterInfo.prt_HostState;

        //
        // Probe the locations for two printers
        //
        ProbeForWrite(
            State,
            2 * sizeof(UCHAR),
            sizeof(UCHAR)
            );

        ProbeForWrite(
            PrtStatus,
            2 * sizeof(UCHAR),
            sizeof(UCHAR)
            );

        ProbeForWrite(
            Control,
            2 * sizeof(UCHAR),
            sizeof(UCHAR)
            );

        ProbeForWrite(
            HostState,
            2 * sizeof(UCHAR),
            sizeof(UCHAR)
            );

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        State = 0;              // satisfy no_opt compilation
        PrtStatus = 0;          // satisfy no_opt compilation
        Control = 0;            // satisfy no_opt compilation
        HostState = 0;          // satisfy no_opt compilation
    }

    if (NT_SUCCESS(Status)) {
        VdmObjects = PsGetCurrentProcess()->VdmObjects;
        VdmObjects->PrinterState = State;
        VdmObjects->PrinterStatus = PrtStatus;
        VdmObjects->PrinterControl = Control;
        VdmObjects->PrinterHostState = HostState;
    }

    return Status;
}

NTSTATUS
VdmpPrinterDirectIoOpen (
    IN PVOID ServiceData
    )
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER (ServiceData);

    return STATUS_SUCCESS;

}
NTSTATUS
VdmpPrinterDirectIoClose (
    IN PVOID ServiceData
    )
{
    LOGICAL FlushData;
    NTSTATUS Status;
    PVDM_PRINTER_INFO PrtInfo;
    USHORT Adapter;
    PVDM_TIB VdmTib;

    PAGED_CODE();

    if (NULL == ServiceData) {
        return STATUS_ACCESS_VIOLATION;
    }

    //
    // First we fetch vdm tib and do some damage control in case
    // this is bad user-mode memory
    // PrtInfo points to a stricture

    try {
        VdmTib = NtCurrentTeb()->Vdm;
        if (VdmTib == NULL) {
            return STATUS_ACCESS_VIOLATION;
        }

        ProbeForWrite(VdmTib, sizeof(VDM_TIB), sizeof(UCHAR));

        //
        // Now verify that servicedata ptr is valid.
        //

        ProbeForRead(ServiceData, sizeof(USHORT), sizeof(UCHAR));
        Adapter = *(PUSHORT)ServiceData;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    Status = STATUS_SUCCESS;

    PrtInfo = &VdmTib->PrinterInfo;

    FlushData = FALSE;

    try {
        if (Adapter < VDM_NUMBER_OF_LPT) {
            if (PRT_MODE_DIRECT_IO == PrtInfo->prt_Mode[Adapter] &&
                PrtInfo->prt_BytesInBuffer[Adapter]) {

                FlushData = TRUE;
            }
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
         Status = GetExceptionCode();
    }

    if (FlushData == TRUE) {
        Status = VdmpFlushPrinterWriteData (Adapter);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdmuserrefs.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vdmuserrefs.c

Abstract:

    This module contains routines that probe and fetch from the
    instruction stream to make the vdm bop support solid.

Author:

    Neill Clift (NeillC) 27-Jun-2001

Revision History:

--*/


#include "vdmp.h"

#pragma alloc_text (PAGE, VdmFetchBop1)
#pragma alloc_text (PAGE, VdmFetchBop4)
#pragma alloc_text (PAGE, VdmDispatchOpcodeV86_try)
#pragma alloc_text (PAGE, VdmTibPass1)
#pragma alloc_text (PAGE, VdmDispatchBop)
#pragma alloc_text (PAGE, VdmFetchULONG)

VOID
NTFastDOSIO (
    PKTRAP_FRAME TrapFrame,
    ULONG IoType
    );

ULONG
VdmFetchBop4 (
    IN PVOID Pc
    )
/*++

Routine Description:

    This routine reads up to 4 bytes of bop instruction data

Arguments:

    Pc - Program counter fetched from the faulting instruction's trap frame.

Return Value:

    ULONG - Up to 4 bytes of instruction stream. Unfetchable bytes are zeroed.

--*/
{
    ULONG Value;
    ULONG i;
    BOOLEAN DidProbe;

    DidProbe = FALSE;
    try {
        ProbeForReadSmallStructure (Pc, sizeof (UCHAR), sizeof (UCHAR));
        DidProbe = TRUE;
        return *(PULONG)Pc;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (DidProbe == FALSE) {
            return 0;
        }
    }

    Value = 0;
    try {
        for (i = 0; i < sizeof (ULONG); i++) {
            Value += (((PUCHAR)Pc)[i])<<(i*8);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }
    return Value;
}

ULONG
VdmFetchULONG (
    IN PVOID Pc
    )
/*++

Routine Description:

    This routine reads 4 bytes from the user address space

Arguments:

    Pc - Program counter fetched from the faulting instruction's trap frame.

Return Value:

    ULONG - 4 bytes of user mode data

--*/
{
    try {
        ProbeForReadSmallStructure (Pc, sizeof (ULONG), sizeof (UCHAR));
        return *(PULONG)Pc;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }

}
ULONG
VdmFetchBop1 (
    IN PVOID Pc
    )
/*++

Routine Description:

    This routine reads a single byte of bop instruction data.

Arguments:

    Pc - Program counter fetched from the faulting instruction's trap frame

Return Value:

    ULONG - 1 byte of instruction stream or zero if unreadable

--*/
{

    try {
        ProbeForReadSmallStructure (Pc, sizeof (UCHAR), sizeof (UCHAR));
        return *(PUCHAR)Pc;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }

}

ULONG
VdmDispatchOpcodeV86_try (
    IN PKTRAP_FRAME TrapFrame
    )
/*++

Routine Description:

    This routine is just a shell around trap.asm code to handle faulting
    instruction stream references. This routines is called at APC_LEVEL
    to prevent NtSetContextThread from changing the EIP after its been probed
    earlier.

Arguments:

    Pc - Program counter fetched from the faulting instructions trap frame

Return Value:

    ULONG - 1 byte of instruction stream or zero if unreadable

--*/
{
    try {
        return Ki386DispatchOpcodeV86 (TrapFrame);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }
}

ULONG
VdmDispatchOpcode_try (
    IN PKTRAP_FRAME TrapFrame
    )
/*++

Routine Description:

    This routine is just a shell around trap.asm code to handle faulting
    instruction stream references. This routines is called at APC_LEVEL
    to prevent NtSetContextThread from changing the EIP after its been probed
    earlier.

Arguments:

    Pc - Program counter fetched from the faulting instructions trap frame

Return Value:

    ULONG - 1 byte of instruction stream or zero if unreadable

--*/
{
    try {
        return Ki386DispatchOpcode (TrapFrame);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }
}

PVOID
VdmTibPass1 (
    IN ULONG Cs,
    IN ULONG Eip,
    IN ULONG Ebx
    )
{
    PVDM_TIB VdmTib;

    //
    // Copy the specified registers to the VDM Tib communication area,
    // using proper probing and exception handling.
    //

    try {

        VdmTib = NtCurrentTeb()->Vdm;

        ProbeForWrite (VdmTib, sizeof(VDM_TIB), sizeof(UCHAR));

        VdmTib->VdmContext.Ebx = Ebx;
        VdmTib->VdmContext.Eip = Eip;
        VdmTib->VdmContext.SegCs = Cs;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

    return VdmTib;
}

#define BOP_INSTRUCTION     0xC4C4
#define SVC_DEMFASTREAD     0x42
#define SVC_DEMFASTWRITE    0x43
#define DOS_BOP             0x50

extern ULONG VdmBopCount;

LOGICAL
VdmDispatchBop (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine attempts to decode and execute the user instruction.  If
    this cannot be done, FALSE is returned and the ntvdm monitor must handle
    it.

Arguments:

    TrapFrame - Supplies a pointer to register trapframe.

Return Value:

    TRUE if the opcode was handled here.

    FALSE if not (ie: the caller must reflect this instruction to ntvdm
          to handle on behalf of the 16-bit app).

Environment:

    Kernel mode, APC_LEVEL.

--*/

{
    LOGICAL RetVal;
    BOOLEAN GotSelector;
    PVDM_TIB VdmTib;
    ULONG SegCs;
    ULONG LinearEIP;
    ULONG Flags;
    ULONG Base;
    ULONG Limit;
    ULONG IoType = 0;
    LOGICAL DoFastIo;

    if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
        SegCs = TrapFrame->SegCs & 0xFFFF;
        LinearEIP = (SegCs << 4) + (TrapFrame->Eip & 0xffff);
    }
    else {
        GotSelector = Ki386GetSelectorParameters ((USHORT) TrapFrame->SegCs,
                                                  &Flags,
                                                  &Base,
                                                  &Limit);

        if (GotSelector == FALSE) {
            return TRUE;
        }

        LinearEIP = Base + TrapFrame->Eip;
    }

    DoFastIo = FALSE;
    RetVal = TRUE;

    try {

        ProbeForReadSmallStructure (LinearEIP, sizeof (UCHAR), sizeof (UCHAR));

        if (*(PUSHORT)LinearEIP != BOP_INSTRUCTION) {
            RetVal = FALSE;
            leave;
        }

        //
        // Check the BOP number.
        //

        if (*(PUCHAR)(LinearEIP + 2) == DOS_BOP) {

            if ((*(PUCHAR)(LinearEIP + 3) == SVC_DEMFASTREAD) ||
                (*(PUCHAR)(LinearEIP + 3) == SVC_DEMFASTWRITE)) {

                //
                // Take the fast I/O path.
                //

                IoType = (ULONG)(*(PUCHAR)(LinearEIP + 3));

                DoFastIo = TRUE;
                leave;
            }
        }

        VdmBopCount += 1;

        VdmTib = NtCurrentTeb()->Vdm;

        ProbeForWrite (VdmTib, sizeof(VDM_TIB), sizeof(UCHAR));

        VdmTib->EventInfo.Event = VdmBop;
        VdmTib->EventInfo.BopNumber = *(PUCHAR)(LinearEIP + 2);
        VdmTib->EventInfo.InstructionSize = 3;

        VdmEndExecution (TrapFrame, VdmTib);


    } except (EXCEPTION_EXECUTE_HANDLER) {
        RetVal = FALSE;
        NOTHING;        // Fall through
    }

    if (DoFastIo) {
        NTFastDOSIO (TrapFrame, IoType);
    }

    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdmp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    vdmp.h

Abstract:

    This is the private include file for the vdm component

Author:

    Dave Hastings (daveh) 24-Apr-1992

Revision History:

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4232)   // dllimport not static
#pragma warning(disable:4206)   // translation unit empty

#include <ntos.h>
#include <nturtl.h>
#include <vdmntos.h>

//
// internal function prototypes
//

NTSTATUS
VdmpInitialize(
    PVDM_INITIALIZE_DATA VdmInitData
    );

#if 0
BOOLEAN
VdmIoInitialize(
    VOID
    );

#endif

NTSTATUS
VdmpStartExecution(
    VOID
    );


VOID
VdmSwapContexts(
    IN PKTRAP_FRAME TrapFrame,
    IN PCONTEXT InContext,
    IN PCONTEXT OutContext
    );

NTSTATUS
VdmpQueueInterrupt(
    IN HANDLE ThreadHandle
    );


NTSTATUS
VdmpDelayInterrupt(
    PVDMDELAYINTSDATA pdsd
    );

BOOLEAN
VdmpDispatchableIntPending(
    IN ULONG EFlags
    );

NTSTATUS
VdmpIsThreadTerminating(
    HANDLE ThreadId
    );


#if 0
BOOLEAN
VdmDispatchUnalignedIoToHandler(
    IN PVDM_IO_HANDLER VdmIoHandler,
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Read,
    IN OUT PULONG Data
    );

BOOLEAN
VdmDispatchIoToHandler(
    IN PVDM_IO_HANDLER VdmIoHandler,
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Read,
    IN OUT PULONG Data
    );

BOOLEAN
VdmDispatchStringIoToHandler(
    IN PVDM_IO_HANDLER VdmIoHandler,
    IN ULONG PortNumber,
    IN ULONG Size,
    IN ULONG Count,
    IN BOOLEAN Read,
    IN ULONG Data
    );

BOOLEAN
VdmCallStringIoHandler(
    IN PVDM_IO_HANDLER VdmIoHandler,
    IN PVOID StringIoRoutine,
    IN ULONG PortNumber,
    IN ULONG Size,
    IN ULONG Count,
    IN BOOLEAN Read,
    IN ULONG Data
    );

VOID
VdmSetBits(
    PULONG Location,
    ULONG Flag
    );

VOID
VdmResetBits(
    PULONG Location,
    ULONG Flag
    );

BOOLEAN
VdmGetSelectorParameters(
    IN USHORT Selector,
    OUT PULONG Flags,
    OUT PULONG Base,
    OUT PULONG Limit
    );

BOOLEAN
VdmConvertToLinearAddress(
    IN ULONG SegmentedAddress,
    OUT PVOID *LinearAddress
    );


#endif

BOOLEAN
VdmPrinterStatus(
    ULONG iPort,
    ULONG cbInstructionSize,
    PKTRAP_FRAME TrapFrame
);
BOOLEAN
VdmPrinterWriteData(
    ULONG iPort,
    ULONG cbInstructionSize,
    PKTRAP_FRAME TrapFrame
);
NTSTATUS
VdmpPrinterDirectIoOpen(
    PVOID ServiceData
);
NTSTATUS
VdmpPrinterDirectIoClose(
    PVOID ServiceData
);

VOID
VdmTraceEvent(
    USHORT Type,
    USHORT wData,
    USHORT lData,
    PKTRAP_FRAME TrapFrame
    );

NTSTATUS
VdmpPrinterInitialize(
    PVOID ServiceData
    );

NTSTATUS
VdmpGetVdmTib(
   OUT PVDM_TIB *ppVdmTib
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\halverifier.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   halverifier.c

Abstract:

    This module contains the routines to verify hal usage & apis.

Author:

    Jordan Tigani (jtigani) 12-Nov-1999

Revision History:

--*/

#ifndef _HAL_VERIFIER_
#define _HAL_VERIFIER_

VOID
VfHalVerifierInitialize(
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\up\makefile.inc ===
..\$(TARGET_DIRECTORY)\genvdmtb.c: ..\$(TARGET_DIRECTORY)\genvdmtb.m4
        m4 < $** > ..\$(TARGET_DIRECTORY)\genvdmtb.c

obj\$(TARGET_DIRECTORY)\genvdmtb.obj: ..\$(TARGET_DIRECTORY)\genvdmtb.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\vdm\i386\vdmtrace.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vdmtrace.c

Abstract:

    This module contains the support maintaining the VDM trace log.

Author:

    Neil Sandlin (neilsa) 15-Sep-1996

Revision History:

--*/


#include "vdmp.h"

VOID
VdmTraceEvent(
    USHORT Type,
    USHORT wData,
    USHORT lData,
    PKTRAP_FRAME TrapFrame
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, VdmTraceEvent)
#endif

VOID
VdmTraceEvent(
    USHORT Type,
    USHORT wData,
    USHORT lData,
    PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:



Arguments:

Return Value:

    None

--*/
{
#if 0
	// This code represents a security problem.  Since it is only used
	// on special occasions, it won't be built into the standard build.
	// Individuals wishing to use it can build themselves a kernel with
	// it in.
    PVDM_TIB VdmTib;
    NTSTATUS Status = STATUS_SUCCESS;
    KIRQL   OldIrql;
    PVDM_TRACEENTRY pEntry;
    PVDM_TRACEINFO pInfo;
    LARGE_INTEGER CurTime, DiffTime;


    PAGED_CODE();
#if 0
    //
    // Raise Irql to APC level...
    //
    KeRaiseIrql(APC_LEVEL, &OldIrql);

    //
    // VdmTib is in user mode memory
    //
    try {
#endif
        if ((*FIXED_NTVDMSTATE_LINEAR) & VDM_TRACE_HISTORY)) {

            //
            // Get a pointer to the VdmTib
            //
            VdmTib = NtCurrentTeb()->Vdm;

            if (VdmTib->TraceInfo.pTraceTable) {
           
                pEntry = &VdmTib->TraceInfo.pTraceTable[VdmTib->TraceInfo.CurrentEntry];
               
                pEntry->Type = Type;
                pEntry->wData = wData;
                pEntry->lData = lData;

                switch (VdmTib->TraceInfo.Flags & VDMTI_TIMER_MODE) {
                case VDMTI_TIMER_TICK:
                    CurTime.LowPart = NtGetTickCount();
                    pEntry->Time = CurTime.LowPart - VdmTib->TraceInfo.TimeStamp.LowPart;
                    VdmTib->TraceInfo.TimeStamp.LowPart = CurTime.LowPart;
                    break;

                case VDMTI_TIMER_PERFCTR:
                    pEntry->Time = 0;
                    break;

                case VDMTI_TIMER_STAT:
                    pEntry->Time = 0;
                    break;

                }
               
                pEntry->eax = TrapFrame->Eax;
                pEntry->ebx = TrapFrame->Ebx;
                pEntry->ecx = TrapFrame->Ecx;
                pEntry->edx = TrapFrame->Edx;
                pEntry->esi = TrapFrame->Esi;
                pEntry->edi = TrapFrame->Edi;
                pEntry->ebp = TrapFrame->Ebp;
                pEntry->esp = TrapFrame->HardwareEsp;
                pEntry->eip = TrapFrame->Eip;
                pEntry->eflags = TrapFrame->EFlags;
               
                pEntry->cs = (USHORT) TrapFrame->SegCs;
                pEntry->ds = (USHORT) TrapFrame->SegDs;
                pEntry->es = (USHORT) TrapFrame->SegEs;
                pEntry->fs = (USHORT) TrapFrame->SegFs;
                pEntry->gs = (USHORT) TrapFrame->SegGs;
                pEntry->ss = (USHORT) TrapFrame->HardwareSegSs;
               
                if (++VdmTib->TraceInfo.CurrentEntry >=
                   (VdmTib->TraceInfo.NumPages*4096/sizeof(VDM_TRACEENTRY))) {
                    VdmTib->TraceInfo.CurrentEntry = 0;
                }
            }
        }

#if 0
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    KeLowerIrql(OldIrql);
#endif
#else
    UNREFERENCED_PARAMETER (Type);
    UNREFERENCED_PARAMETER (wData);
    UNREFERENCED_PARAMETER (lData);
    UNREFERENCED_PARAMETER (TrapFrame);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfbugcheck.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfbugcheck.h

Abstract:

    This header defines the prototypes and constants required for verifier
    bugchecks.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Revision History:

    AdriaO  02/21/2000  - Moved from ntos\io\ioassert.h

--*/

#ifndef _VFBUGCHECK_H_
#define _VFBUGCHECK_H_

extern LONG         IovpInitCalled;

#define KDASSERT(x) { if (KdDebuggerEnabled) { ASSERT(x) ; } }

#define ASSERT_SPINLOCK_HELD(x)

#define DCPARAM_ROUTINE         0x00000001
#define DCPARAM_IRP             0x00000008
#define DCPARAM_IRPSNAP         0x00000040
#define DCPARAM_DEVOBJ          0x00000200
#define DCPARAM_STATUS          0x00001000
#define DCPARAM_ULONG           0x00008000
#define DCPARAM_PVOID           0x00040000

#define WDM_FAIL_ROUTINE(ParenWrappedParamList) \
{ \
    if (IovpInitCalled) { \
        VfBugcheckThrowIoException##ParenWrappedParamList;\
    } \
}

VOID
FASTCALL
VfBugcheckInit(
    VOID
    );

NTSTATUS
VfBugcheckThrowIoException(
    IN DCERROR_ID           MessageIndex,
    IN ULONG                MessageParameterMask,
    ...
    );

NTSTATUS
VfBugcheckThrowException(
    IN PVFMESSAGE_TEMPLATE_TABLE    MessageTable        OPTIONAL,
    IN VFMESSAGE_ERRORID            MessageID,
    IN PCSTR                        MessageParamFormat,
    IN va_list *                    MessageParameters
    );

#endif // _VFBUGCHECK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=verifier

TARGETNAME=verifier
TARGETTYPE=LIBRARY
TARGETPATH=obj

BUILD_PRODUCES=ntosverifier$(NT_UP)

INCLUDES=..\..\inc;..\..\..\ke;$(WINDOWS_INC_PATH)


C_DEFINES=$(C_DEFINES)

MSC_WARNING_LEVEL=/W4 /WX

SOURCES= \
        ..\vfbugcheck.c         \
        ..\vfddi.c              \
        ..\vfdeadlock.c         \
        ..\vfdebug.c            \
        ..\vfdevobj.c           \
        ..\vffileio.c           \
        ..\vffilter.c           \
        ..\vfhal.c              \
        ..\vfinit.c             \
        ..\vfirp.c              \
        ..\vfirpdb.c            \
        ..\vfirplog.c           \
        ..\vfgeneric.c          \
        ..\vfmajor.c            \
        ..\vfmessage.c          \
        ..\vfpacket.c           \
        ..\vfpnp.c              \
        ..\vfpower.c            \
        ..\vfprint.c            \
        ..\vfrandom.c           \
        ..\vfsettings.c         \
        ..\vfstack.c            \
        ..\vfutil.c             \
        ..\vfwmi.c              \
        ..\vfzwapi.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfddi.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    vfddi.h

Abstract:

    This header contains prototypes for verifier device driver interfaces.

Author:

    Adrian J. Oney (adriao) 26-Apr-2001

Environment:

    Kernel mode

Revision History:

--*/

VOID
VfDdiInit(
    VOID
    );

VOID
VfDdiExposeWmiObjects(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfbugcheck.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfbugcheck.c

Abstract:

    This module implements support for verifier bugchecks.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO  02/21/2000  - Moved from ntos\io\ioassert.c

--*/

//
// Disable W4 level warnings generated by public headers.
//

#include "vfpragma.h"


#include "..\io\iop.h" // Includes vfdef.h
#include "vibugcheck.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,     VfBugcheckInit)
#pragma alloc_text(PAGEVRFY, VfBugcheckThrowIoException)
#pragma alloc_text(PAGEVRFY, VfBugcheckThrowException)
#pragma alloc_text(PAGEVRFY, ViBucheckProcessParams)
#pragma alloc_text(PAGEVRFY, ViBugcheckProcessMessageText)
#pragma alloc_text(PAGEVRFY, ViBugcheckApplyControl)
#pragma alloc_text(PAGEVRFY, ViBugcheckHalt)
#pragma alloc_text(PAGEVRFY, ViBugcheckPrintBuffer)
#pragma alloc_text(PAGEVRFY, ViBugcheckPrintParamData)
#pragma alloc_text(PAGEVRFY, ViBugcheckPrintUrl)
#pragma alloc_text(PAGEVRFY, ViBugcheckPrompt)
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEVRFD")
#endif

ULONG           ViBugCheckInitialControl;
ULONG           ViBugCheckControlOverride;
UNICODE_STRING  ViBugCheckEmptyString;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGEVRFC")
#endif

//
// When invoking the driver check macro's, pass Irps first, Routines second,
// DevObj's third, and any Status's last...
//
const DCPARAM_TYPE_ENTRY ViBugCheckParamTable[] = {
    { DCPARAM_ROUTINE, "Routine"    },
    { DCPARAM_IRP,     "Irp"        },
    { DCPARAM_IRPSNAP, "Snapshot"   },
    { DCPARAM_DEVOBJ,  "DevObj"     },
    { DCPARAM_STATUS,  "Status"     },
    { DCPARAM_ULONG,   "Ulong"      },
    { DCPARAM_PVOID,   "Pvoid"      }
};


VOID
FASTCALL
VfBugcheckInit(
    VOID
    )
/*++

Routine Description:

    This routine initializes the verifier bugcheck support routines.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ViBugCheckInitialControl = 0;
    ViBugCheckControlOverride = 0;
    RtlInitUnicodeString(&ViBugCheckEmptyString, NULL);
}


NTSTATUS
VfBugcheckThrowIoException(
    IN DCERROR_ID           MessageID,
    IN ULONG                MessageParameterMask,
    ...
    )
/*++

   Description:

      This routine processes an assert and provides options for removing the
      breakpoint, changing to just a text-out, etc.

    DCPARAM_IRP*(count)+DCPARAM_ROUTINE*(count)+DCPARAM_DEVOBJ*(count),
        irp1,
        irp2,
        irp3,
        routine1,
        ..,
        ..,
        devobj1,

    count can be a max of 3.

   Notes:

      The text will automagically be formatted and printed as such:

      ASSERTION CLASS: ASSERTION TEXT ASSERTION TEXT ASSERTION
                       TEXT ASSERTION TEXT ...

--*/
{
    PVFMESSAGE_TEMPLATE_TABLE ioVerifierTable;
    UCHAR paramFormat[9*3*ARRAY_COUNT(ViBugCheckParamTable)+1];
    ULONG paramType, paramMask, curMask;
    NTSTATUS status;
    va_list arglist;

    curMask = MessageParameterMask;
    paramFormat[0] = '\0';

    for(paramType=0; paramType<ARRAY_COUNT(ViBugCheckParamTable); paramType++) {

        paramMask = ViBugCheckParamTable[paramType].DcParamMask;
        while(curMask & (paramMask*3)) {

            strcat(
                (char *) paramFormat,
                ViBugCheckParamTable[paramType].DcParamName
                );

            curMask -= paramMask;
        }
    }

    VfMessageRetrieveInternalTable(
        VFMESSAGE_TABLE_IOVERIFIER,
        &ioVerifierTable
        );

    va_start(arglist, MessageParameterMask);

    status = VfBugcheckThrowException(
        ioVerifierTable,
        (VFMESSAGE_ERRORID) MessageID,
        (PCSTR) paramFormat,
        &arglist
        );

    va_end(arglist);

    return status;
}


NTSTATUS
VfBugcheckThrowException(
    IN PVFMESSAGE_TEMPLATE_TABLE    MessageTable        OPTIONAL,
    IN VFMESSAGE_ERRORID            MessageID,
    IN PCSTR                        MessageParamFormat,
    IN va_list *                    MessageParameters
    )
/*++

   Description:

      This routine displays an assert and provides options for
      removing the breakpoint, changing to just a text-out, etc.

   Arguments:

   Notes:

      The text will automagically be formatted and printed as such:

      ASSERTION CLASS: ASSERTION TEXT ASSERTION TEXT ASSERTION
                       TEXT ASSERTION TEXT ...

--*/
{
    UCHAR finalBuffer[512];
    NTSTATUS status;
    DC_CHECK_DATA dcCheckData;
    PVOID dcParamArray[3*ARRAY_COUNT(ViBugCheckParamTable)];
    BOOLEAN exitAssertion;

    //
    // Preinit
    //
    RtlZeroMemory(dcParamArray, sizeof(dcParamArray));

    //
    // Determine what our basic policy towards this check will be and fill out
    // the dcCheckData structure as well as we can.
    //
    ViBucheckProcessParams(
        MessageTable,
        MessageID,
        MessageParamFormat,
        MessageParameters,
        dcParamArray,
        &dcCheckData
        );

    if (!ViBugcheckApplyControl(&dcCheckData)) {

        //
        // Nothing to see here, just ignore the assert...
        //
        return STATUS_SUCCESS;
    }

    //
    // We are going to express our disatifaction somehow. Expand out the
    // message we've prepared for this scenario.
    //
    status = ViBugcheckProcessMessageText(
        sizeof(finalBuffer),
        (PSTR)finalBuffer,
        &dcCheckData
        );

    if (!NT_SUCCESS(status)) {

        ASSERT(0);

        //
        // Something went wrong with the index lookup!
        //
        return status;
    }

    do {

        ViBugcheckPrintBuffer(&dcCheckData);
        ViBugcheckPrintParamData(&dcCheckData);
        ViBugcheckPrintUrl(&dcCheckData);
        ViBugcheckHalt(&dcCheckData);
        ViBugcheckPrompt(&dcCheckData, &exitAssertion);

    } while (!exitAssertion);

    return status;
}


VOID
ViBucheckProcessParams(
    IN  PVFMESSAGE_TEMPLATE_TABLE   MessageTable        OPTIONAL,
    IN  VFMESSAGE_ERRORID           MessageID,
    IN  PCSTR                       MessageParamFormat,
    IN  va_list *                   MessageParameters,
    IN  PVOID *                     DcParamArray,
    OUT PDC_CHECK_DATA              DcCheckData
    )
{
    PVOID culpritAddress;
    ULONG i, paramType, paramLen;
    char ansiDriverName[81];
    NTSTATUS status;
    ULONG paramIndices[ARRAY_COUNT(ViBugCheckParamTable)];
    PCSTR format;

    //
    // First we grab parameter off the stack and slot them appropriately into
    // our array of "things".
    //
    // The array is in groups of three for each possible member of a given type
    // (three irps, three routines, three device objects, etc). Items not
    // referenced in are set to NULL.
    //
    RtlZeroMemory(paramIndices, sizeof(paramIndices));
    format = MessageParamFormat;
    while(*format) {

        if ((format[0] == ' ')||(format[0] == '%')) {

            format++;
            continue;
        }

        for(paramType = 0;
            paramType < ARRAY_COUNT(ViBugCheckParamTable);
            paramType++) {

            paramLen = (ULONG)strlen(ViBugCheckParamTable[paramType].DcParamName);

            if (!_strnicmp(ViBugCheckParamTable[paramType].DcParamName, format, paramLen)) {

                //
                // Match! Advance the pointer...
                //
                format += paramLen;

                //
                // If the caller specified an index, grab it. Otherwise infer.
                //
                if ((format[0] >= '1') && (format[0] <= '3')) {

                    i = format[0] - '1';
                    format++;

                } else {

                    i = paramIndices[paramType];
                    ASSERT(i < 3);
                }

                if (i < 3) {

                    //
                    // Param number is within bounds.
                    //
                    DcParamArray[paramType*3+i] = va_arg(*MessageParameters, PVOID);
                }

                //
                // Update the current parameter index for the given type.
                //
                paramIndices[paramType] = i+1;

                //
                // Get out early
                //
                break;
            }
        }

        if (paramType == ARRAY_COUNT(ViBugCheckParamTable)) {

            //
            // We could'nt find an entry matching the format text. Bail.
            //
            ASSERT(paramType != ARRAY_COUNT(ViBugCheckParamTable));
            break;
        }
    }

    //
    // Pre-init unhelpful answers...
    //
    DcCheckData->DriverName = &ViBugCheckEmptyString;
    DcCheckData->OffsetIntoImage = 0;
    DcCheckData->InVerifierList = FALSE;
    culpritAddress = DcParamArray[0];

    //
    // Extract the culprit's name if possible...
    //
    if (culpritAddress) {

        status = KevUtilAddressToFileHeader(
            (PVOID) culpritAddress,
            (PUINT_PTR)(&DcCheckData->OffsetIntoImage),
            &DcCheckData->DriverName,
            &DcCheckData->InVerifierList
            );

        if (!NT_SUCCESS(status)) {

            //
            // IF we don't know who it is, assert anyway.
            //
            DcCheckData->InVerifierList = TRUE;
        }
    }

    //
    // Record
    //
    DcCheckData->CulpritAddress = culpritAddress;
    DcCheckData->DcParamArray = DcParamArray;
    DcCheckData->MessageID = MessageID;

    //
    // Get an ANSI version of the driver name.
    //
    KeBugCheckUnicodeToAnsi(
        DcCheckData->DriverName,
        ansiDriverName,
        sizeof(ansiDriverName)
        );

    //
    // Retrieve a pointer to the appropriate message data.
    //
    VfMessageRetrieveErrorData(
        MessageTable,
        MessageID,
        ansiDriverName,
        &DcCheckData->BugCheckMajor,
        &DcCheckData->AssertionClass,
        &DcCheckData->MessageTextTemplate,
        &DcCheckData->Control
        );
}


NTSTATUS
FASTCALL
ViBugcheckProcessMessageText(
    IN ULONG               MaxOutputBufferSize,
    OUT PSTR               OutputBuffer,
    IN OUT PDC_CHECK_DATA  DcCheckData
    )
{
    ULONG paramType, maxParameterTypes;
    ULONG arrayIndex, paramLength;
    char const* messageHead;
    PSTR newMessage;
    LONG charsRemaining, length;

    //
    // Get the message text.
    //
    messageHead = DcCheckData->MessageTextTemplate;

    //
    // Now manually build out the message.
    //
    newMessage = OutputBuffer;
    charsRemaining = (MaxOutputBufferSize/sizeof(UCHAR))-1;
    maxParameterTypes = ARRAY_COUNT(ViBugCheckParamTable);

    while(*messageHead != '\0') {

        if (charsRemaining <= 0) {

            return STATUS_BUFFER_OVERFLOW;
        }

        if (*messageHead != '%') {

            *newMessage = *messageHead;
            newMessage++;
            messageHead++;
            charsRemaining--;

        } else {

            for(paramType = 0; paramType < maxParameterTypes; paramType++) {

                paramLength = (ULONG)strlen(ViBugCheckParamTable[paramType].DcParamName);

                //
                // Do we have a match?
                //
                // N.B. - We don't do any case 'de-sensitizing' anywhere, so
                //        everything's cases must match!
                //
                if (RtlCompareMemory(
                    messageHead+1,
                    ViBugCheckParamTable[paramType].DcParamName,
                    paramLength*sizeof(UCHAR)) == paramLength*sizeof(UCHAR)) {

                    arrayIndex = paramType*3;
                    messageHead += (paramLength+1);

                    //
                    // Was an index passed in (ie, "3rd" irp requested)?
                    //
                    if ((*messageHead >= '1') && (*messageHead <= '3')) {

                        //
                        // Adjust table index appropriately.
                        //
                        arrayIndex += (*messageHead - '1') ;
                        messageHead++;
                    }

                    if ((arrayIndex < 6) || (arrayIndex >=9)) {

                        //
                        // Normal param, print the pointer
                        //
                        length = _snprintf(
                            newMessage,
                            charsRemaining+1,
                            "%p",
                            DcCheckData->DcParamArray[arrayIndex]
                            );

                    } else {

                        //
                        // IRP Snapshot, extract the IRP and print that
                        //
                        length = _snprintf(
                            newMessage,
                            charsRemaining+1,
                            "%p",
                            ((PIRP_MINI_SNAPSHOT) DcCheckData->DcParamArray[arrayIndex])->Irp
                            );
                    }

                    if (length == -1) {

                        return STATUS_BUFFER_OVERFLOW;
                    }

                    charsRemaining -= length;
                    newMessage += length;
                    break;
                }
            }

            if (paramType == maxParameterTypes) {

                //
                // Either the message we looked up is malformed, we don't recognize
                // the %thing it is talking about, or this is %%!
                //
                *newMessage = *messageHead;
                messageHead++;
                newMessage++;
                charsRemaining--;

                if (*messageHead == '%') {

                    messageHead++;
                }
            }
        }
    }

    //
    // Null-terminate it (we have room because we took one off the buffer size
    // above).
    //
    *newMessage = '\0';

    DcCheckData->ClassText = DcCheckData->AssertionClass->MessageClassText;
    DcCheckData->AssertionText = OutputBuffer;
    return STATUS_SUCCESS;
}


BOOLEAN
FASTCALL
ViBugcheckApplyControl(
    IN OUT PDC_CHECK_DATA  DcCheckData
    )
{
    ULONG assertionControl;

    if (ViBugCheckControlOverride) {

        assertionControl = ViBugCheckControlOverride;

    } else if (DcCheckData->Control) {

        //
        // Initialize the control if appropo
        //
        if (!((*DcCheckData->Control) & VFM_FLAG_INITIALIZED)) {

            *DcCheckData->Control |= (
                VFM_FLAG_INITIALIZED | ViBugCheckInitialControl |
                DcCheckData->AssertionClass->ClassFlags );
        }

        assertionControl = *DcCheckData->Control;

    } else {

        assertionControl =
            ( ViBugCheckInitialControl |
              DcCheckData->AssertionClass->ClassFlags );
    }

    if (assertionControl & VFM_FLAG_CLEARED) {

        //
        // If the breakpoint was cleared, then return, print/rip not.
        //
        return FALSE;
    }

    if ((!(assertionControl & VFM_IGNORE_DRIVER_LIST)) &&
        (!DcCheckData->InVerifierList)) {

        //
        // Not of interest, skip this one.
        //
        return FALSE;
    }

    //
    // If there is no debugger, don't halt the machine. We are probably
    // ripping like mad and the user just wants to be able to boot.
    // The one exception is if VFM_DEPLOYMENT_FAILURE is set. Then we shall
    // invoke the driver bugcheck...
    //
    if ((!KdDebuggerEnabled) && (!(assertionControl & VFM_DEPLOYMENT_FAILURE))) {

        return FALSE;
    }

    //
    // Record our intentions and continue.
    //
    DcCheckData->AssertionControl = assertionControl;
    return TRUE;
}


VOID
FASTCALL
ViBugcheckHalt(
    IN PDC_CHECK_DATA DcCheckData
    )
{
    PVOID parameterArray[4];
    char captionBuffer[256];
    char ansiDriverName[81];

    //
    // Do not bugcheck if a kernel debugger is attached, nor if this isn't a
    // fatal error.
    //
    if (KdDebuggerEnabled ||
        (!(DcCheckData->AssertionControl & VFM_DEPLOYMENT_FAILURE))) {

        return;
    }

    //
    // We are here because VFM_DEPLOYMENT_FAILURE is set. We use
    // FATAL_UNHANDLED_HARD_ERROR so that we can give a
    // descriptive text string for the problem.
    //
    parameterArray[0] = (PVOID)(ULONG_PTR)(DcCheckData->MessageID);
    parameterArray[1] = DcCheckData->CulpritAddress;
    parameterArray[2] = DcCheckData->DcParamArray[3];
    parameterArray[3] = DcCheckData->DcParamArray[9];

    if (DcCheckData->BugCheckMajor == DRIVER_VERIFIER_IOMANAGER_VIOLATION) {

        KeBugCheckUnicodeToAnsi(
            DcCheckData->DriverName,
            ansiDriverName,
            sizeof(ansiDriverName)
            );

        _snprintf(
            captionBuffer,
            sizeof(captionBuffer),
            "IO SYSTEM VERIFICATION ERROR in %s (%s %x)\n[%s+%x at %p]\n",
            ansiDriverName,
            DcCheckData->ClassText,
            DcCheckData->MessageID,
            ansiDriverName,
            DcCheckData->OffsetIntoImage,
            DcCheckData->CulpritAddress
            );

        KeBugCheckEx(
            FATAL_UNHANDLED_HARD_ERROR,
            DcCheckData->BugCheckMajor,
            (ULONG_PTR) parameterArray,
            (ULONG_PTR) captionBuffer,
            (ULONG_PTR) "" // DcCheckData->AssertionText is too technical
            );

    } else {

        KeBugCheckEx(
            DcCheckData->BugCheckMajor,
            DcCheckData->MessageID,
            (ULONG_PTR) DcCheckData->DcParamArray[9],
            (ULONG_PTR) DcCheckData->DcParamArray[15],
            (ULONG_PTR) DcCheckData->DcParamArray[16]
            );
    }
}


VOID
FASTCALL
ViBugcheckPrintBuffer(
    IN PDC_CHECK_DATA DcCheckData
    )
{
    UCHAR buffer[82];
    UCHAR classBuf[81];
    UCHAR callerBuf[81+40];
    UCHAR ansiDriverName[81];
    LONG  lMargin, i, lMarginCur, rMargin=78;
    PSTR lineStart, lastWord, current, lMarginText;

    //
    // Put down a carriage return
    //
    DbgPrint("\n") ;

    //
    // Drop a banner if this is a fatal assert or a logo failure.
    //
    if (DcCheckData->AssertionControl &
        (VFM_DEPLOYMENT_FAILURE | VFM_LOGO_FAILURE)) {

        DbgPrint(
            "***********************************************************************\n"
            "* THIS VALIDATION BUG IS FATAL AND WILL CAUSE THE VERIFIER TO HALT    *\n"
            "* WINDOWS (BUGCHECK) WHEN THE MACHINE IS NOT UNDER A KERNEL DEBUGGER! *\n"
            "***********************************************************************\n"
            "\n"
            );
    }

    //
    // Prepare left margin (ClassText)
    //
    if (DcCheckData->ClassText != NULL) {

        lMargin = (LONG)strlen(DcCheckData->ClassText)+2;

        DbgPrint("%s: ", DcCheckData->ClassText);

    } else {

        lMargin = 0;
    }

    if (lMargin+1>=rMargin) {

        lMargin=0;
    }

    for(i=0; i<lMargin; i++) classBuf[i] = ' ';
    classBuf[lMargin] = '\0';
    lMarginText = (PSTR)(classBuf+lMargin);
    lMarginCur = lMargin;

    lineStart = lastWord = current = DcCheckData->AssertionText;

    //
    // Print out culprit if we have him...
    //
    if (DcCheckData->CulpritAddress) {

        if (DcCheckData->DriverName->Length) {

            KeBugCheckUnicodeToAnsi(
                DcCheckData->DriverName,
                (PSTR)ansiDriverName,
                sizeof(ansiDriverName)
                );

            sprintf((PCHAR)callerBuf, "[%s @ 0x%p] ",
                ansiDriverName,
                DcCheckData->CulpritAddress
                );

        } else {

            sprintf((PCHAR)callerBuf, "[0x%p] ", DcCheckData->CulpritAddress);
        }

        DbgPrint("%s", callerBuf);
        lMarginCur += (LONG)strlen((PCHAR)callerBuf);
    }

    //
    // Format and print our assertion text
    //
    while(*current) {

        if (*current == ' ') {

            if ((current - lineStart) >= (rMargin-lMarginCur-1)) {

                DbgPrint("%s", lMarginText);
                lMarginText = (PSTR)classBuf;
                lMarginCur = lMargin;

                if ((lastWord-lineStart)<rMargin) {

                    memcpy(buffer, lineStart, (ULONG)(lastWord-lineStart)*sizeof(UCHAR));
                    buffer[lastWord-lineStart] = '\0';
                    DbgPrint("%s\n", buffer);

                }

                lineStart = lastWord+1;
            }

            lastWord = current;
        }

        current++;
    }

    if ((current - lineStart) >= (rMargin-lMarginCur-1)) {

        DbgPrint("%s", lMarginText);
        lMarginText = (PSTR)classBuf;

        if ((lastWord-lineStart)<rMargin) {

            memcpy(buffer, lineStart, (ULONG)(lastWord-lineStart)*sizeof(UCHAR));
            buffer[lastWord-lineStart] = '\0';
            DbgPrint("%s\n", buffer);
        }

        lineStart = lastWord+1;
    }

    if (lineStart<current) {

        DbgPrint("%s%s\n", lMarginText, lineStart);
    }
}


VOID
FASTCALL
ViBugcheckPrintParamData(
    IN PDC_CHECK_DATA DcCheckData
    )
{
    if (DcCheckData->DcParamArray[3]) {

        VfPrintDumpIrp((PIRP) DcCheckData->DcParamArray[3]);
    }

    if (DcCheckData->DcParamArray[6]) {

        VfPrintDumpIrpStack(
            &((PIRP_MINI_SNAPSHOT) DcCheckData->DcParamArray[6])->IoStackLocation
            );
    }
}


VOID
FASTCALL
ViBugcheckPrintUrl(
    IN PDC_CHECK_DATA DcCheckData
    )
{
    DbgPrint(
        "http://www.microsoft.com/hwdq/bc/default.asp?os=%d.%d.%d&major=0x%x&minor=0x%x&lang=0x%x\n",
        VER_PRODUCTMAJORVERSION,
        VER_PRODUCTMINORVERSION,
        VER_PRODUCTBUILD,
        DcCheckData->BugCheckMajor,
        DcCheckData->MessageID,
        9 // English
        );
}


VOID
FASTCALL
ViBugcheckPrompt(
    IN      PDC_CHECK_DATA  DcCheckData,
    OUT     PBOOLEAN        ExitAssertion
    )
{
    char response[2];
    ULONG assertionControl;
    BOOLEAN waitForInput;

    assertionControl = DcCheckData->AssertionControl;

    *ExitAssertion = TRUE;

    //
    // Vocalize if so ordered.
    //
    if (assertionControl & VFM_FLAG_BEEP) {

        DbgPrint("%c", 7);
    }

    if (assertionControl & VFM_FLAG_ZAPPED) {

        return;
    }

    //
    // Wait for input...
    //
    waitForInput = TRUE;
    while(waitForInput) {

        if (DcCheckData->Control) {

            DbgPrompt( "Break, Ignore, Zap, Remove, Disable all (bizrd)? ", response, sizeof( response ));
        } else {

            DbgPrompt( "Break, Ignore, Disable all (bid)? ", response, sizeof( response ));
        }

        switch (response[0]) {

            case 'B':
            case 'b':
                DbgPrint("Breaking in... (press g<enter> to return to assert menu)\n");
                DbgBreakPoint();
                waitForInput = FALSE;
                *ExitAssertion = FALSE;
                break;

            case 'I':
            case 'i':
                waitForInput = FALSE;
                break;

            case 'Z':
            case 'z':
                if (DcCheckData->Control) {

                   DbgPrint("Breakpoint zapped (OS will print text and return)\n");
                   assertionControl |= VFM_FLAG_ZAPPED;
                   assertionControl &=~ VFM_FLAG_BEEP;
                   waitForInput = FALSE;
                }
                break;

            case 'D':
            case 'd':
                ViBugCheckControlOverride = VFM_FLAG_CLEARED;
                DbgPrint("Verification asserts disabled.\n");
                waitForInput = FALSE;
                break;

            case 'R':
            case 'r':
                if (DcCheckData->Control) {

                   DbgPrint("Breakpoint removed\n") ;
                   assertionControl |= VFM_FLAG_CLEARED;
                   waitForInput = FALSE;
                }
                break;
        }
    }

    if (DcCheckData->Control) {
        *DcCheckData->Control = assertionControl;
    }
}


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfdeadlock.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

   vfdeadlock.h

Abstract:

    Detect deadlocks in arbitrary synchronization objects.

Author:

    Jordan Tigani (jtigani) 2-May-2000
    Silviu Calinoiu (silviuc) 9-May-2000


Revision History:

--*/

#ifndef _VF_DEADLOCK_
#define _VF_DEADLOCK_

//
// Deadlock detection package initialization.
//

VOID 
VfDeadlockDetectionInitialize(
    );

//
// Functions called from IovCallDriver (driver verifier replacement for
// IoCallDriver) just before and after the real call to the driver is made.
//

BOOLEAN
VfDeadlockBeforeCallDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

VOID
VfDeadlockAfterCallDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN BOOLEAN PagingIrp
    );

//
// Maximum depth of stack traces captured.
//

#define VI_MAX_STACK_DEPTH 8

#define NO_OF_DEADLOCK_PARTICIPANTS 32

//
// VI_DEADLOCK_NODE
//

typedef struct _VI_DEADLOCK_NODE {

    //
    // Node representing the acquisition of the previous resource.
    //

    struct _VI_DEADLOCK_NODE * Parent;

    //
    // Node representing the next resource acquisitions, that are
    // done after acquisition of the current resource.
    //

    struct _LIST_ENTRY ChildrenList;

    //
    // Field used to chain siblings in the tree. A parent node has the
    // ChildrenList field as the head of the children list that is chained
    // with the Siblings field.
    //

    struct _LIST_ENTRY SiblingsList;

    union {
        
        //
        // List of nodes representing the same resource acquisition
        // as the current node but in different contexts (lock combinations).
        //

        struct _LIST_ENTRY ResourceList;

        //
        // Used to chain free nodes. This is used only after the node has
        // been deleted (resource was freed). Nodes are kept in a cache
        // to reduce contention for the kernel pool.
        //
        
        struct _LIST_ENTRY FreeListEntry;
    };

    //
    // Back pointer to the descriptor for this resource.
    //

    struct _VI_DEADLOCK_RESOURCE * Root;

    //
    // When we find a deadlock, we keep this info around in order to
    // be able to identify the parties involved who have caused
    // the deadlock.
    //

    struct _VI_DEADLOCK_THREAD * ThreadEntry;

    //
    // Fields used for decision making within the deadlock analysis 
    // algorithm.
    //
    // Active: 1 if the node represents a resource currently acquired,
    //     0 if resource was acquired in the past.
    //
    // OnlyTryAcquiredUsed: 1 if resource was always acquired with TryAcquire.
    //     0 if at least once normal acquire was used. A node that uses
    //     only TryAcquire cannot be involved in a deadlock.
    //
    // ReleasedOutOfOrder: 1 if the resource was at least once released 
    //     out of order. The flag is used while looking for cycles because
    //     this type of nodes will appear as part of the cycle but there is
    //     no deadlock.
    //
    // SequenceNumber: field that gets a unique stamp during each deadlock
    //     analysis run. It helps figure out if the node was touched 
    //     already in the current graph traversal.
    //

    struct {

        ULONG Active : 1;
        ULONG OnlyTryAcquireUsed : 1;         
        ULONG ReleasedOutOfOrder : 1;
        ULONG SequenceNumber : 29;
    };

    //
    // Stack traces for the resource acquisition moment.
    // Used when displaying deadlock proofs. On free builds
    // anything other than the first entry (return address)
    // may be bogus in case stack trace capturing failed.
    //
   
    PVOID StackTrace[VI_MAX_STACK_DEPTH];
    PVOID ParentStackTrace[VI_MAX_STACK_DEPTH];

} VI_DEADLOCK_NODE, *PVI_DEADLOCK_NODE;

//
// VI_DEADLOCK_RESOURCE
//

typedef struct _VI_DEADLOCK_RESOURCE {

    //
    // Resource type (mutex, spinlock, etc.).
    //

    VI_DEADLOCK_RESOURCE_TYPE Type;

    //
    // Resource flags
    //    
    // NodeCount : number of resource nodes created for this resource.
    //
    // RecursionCount : number of times this resource has been recursively acquired 
    //     It makes sense to put this counter in the resource because as long as
    //     resource is acquired only one thread can operate on it.
    //

    struct {       
        ULONG NodeCount : 16;
        ULONG RecursionCount : 16;
    };

    //
    // The address of the synchronization object used by the kernel.
    //

    PVOID ResourceAddress;

    //
    // The thread that currently owns the resource. The field is
    // null if nobody owns the resource.
    //
    
    struct _VI_DEADLOCK_THREAD * ThreadOwner;

    //
    // List of resource nodes representing acquisitions of this resource.
    //

    LIST_ENTRY ResourceList;

    union {

        //
        // List used for chaining resources from a hash bucket.
        //
        
        LIST_ENTRY HashChainList;
        
        //
        // Used to chain free resources. This list is used only after
        // the resource has been freed and we put the structure
        // into a cache to reduce kernel pool contention.
        //

        LIST_ENTRY FreeListEntry;
    };

    //
    // Stack trace of the resource creator. On free builds we
    // may have here only a return address that is bubbled up
    // from verifier thunks. 
    //
  
    PVOID StackTrace [VI_MAX_STACK_DEPTH];
    
    //
    // Stack trace for last acquire
    //

    PVOID LastAcquireTrace [VI_MAX_STACK_DEPTH];
    
    //
    // Stack trace for last release
    //

    PVOID LastReleaseTrace [VI_MAX_STACK_DEPTH];

} VI_DEADLOCK_RESOURCE, * PVI_DEADLOCK_RESOURCE;

//
// VI_DEADLOCK_THREAD
//

typedef struct _VI_DEADLOCK_THREAD {

    //
    // Kernel thread address
    //

    PKTHREAD Thread;

    //
    // The node representing the last resource acquisition made by
    // this thread.
    //

    //
    // We have separate graph branches for spinlocks and other types
    // of locks (fast mutex, mutex). The thread keeps a list of both types
    // so that we can properly release locks
    //

    PVI_DEADLOCK_NODE CurrentSpinNode;
    PVI_DEADLOCK_NODE CurrentOtherNode;

    union {

        //
        // Thread list. It is used for chaining into a hash bucket.
        //
        
        LIST_ENTRY ListEntry;

        //
        // Used to chain free nodes. The list is used only after we decide
        // to delete the thread structure (possibly because it does not
        // hold resources anymore). Keeping the structures in a cache
        // reduces pool contention.
        //

        LIST_ENTRY FreeListEntry;
    };

    //
    // Count of resources currently acquired by a thread. When this becomes
    // zero the thread will be destroyed. The count goes up during acquire
    // and down during release.
    //

    ULONG NodeCount;

    //
    // This counter is used to count how many IoCallDriver() calls with
    // paging IRPs are active for this thread. This information is necessary
    // to decide if we should temporarily disable deadlock verification
    // to avoid known lack of lock hierarchy issues in file system drivers.
    //

    ULONG PagingCount;

} VI_DEADLOCK_THREAD, *PVI_DEADLOCK_THREAD;

//
// Deadlock verifier globals
//

typedef struct _VI_DEADLOCK_GLOBALS {

    //
    // Structure counters: [0] - current, [1] - maximum
    //

    ULONG Nodes[2];
    ULONG Resources[2];
    ULONG Threads[2];

    //
    // Maximum times for Acquire() and Release() in ticks.
    //

    LONGLONG TimeAcquire;
    LONGLONG TimeRelease;

    //
    // Total number of kernel pool bytes used by the deadlock verifier
    //
    
    SIZE_T BytesAllocated;

    //
    // Resource and thread collection.
    //

    PLIST_ENTRY ResourceDatabase;
    PLIST_ENTRY ThreadDatabase;   
    
    //
    // How many times ExAllocatePool failed on us?
    // If this is >0 we stop deadlock verification.
    //

    ULONG AllocationFailures;

    //
    // How many nodes have been trimmed when we decided to forget
    // partially the history of some resources.
    //

    ULONG NodesTrimmedBasedOnAge;
    ULONG NodesTrimmedBasedOnCount;

    //
    // Deadlock analysis statistics
    //

    ULONG NodesSearched;
    ULONG MaxNodesSearched;
    ULONG SequenceNumber;

    ULONG RecursionDepthLimit;
    ULONG SearchedNodesLimit;

    ULONG DepthLimitHits;
    ULONG SearchLimitHits;

    //
    // Number of times we have to exonerate a deadlock because
    // it was protected by a common resource (e.g. thread 1 takes ABC, 
    // thread 2 takes ACB -- this will get flagged initially by our algorithm 
    // since B&C are taken out of order but is not actually a deadlock.
    //
    
    ULONG ABC_ACB_Skipped;

    ULONG OutOfOrderReleases;
    ULONG NodesReleasedOutOfOrder;

#if DBG
    //
    // How many locks are held simultaneously while the system is running?
    //

    ULONG NodeLevelCounter[8];
    ULONG GraphNodes[8];
#endif
    
    ULONG TotalReleases;
    ULONG RootNodesDeleted;

    //
    // Used to control how often we delete portions of the dependency
    // graph.
    //

    ULONG ForgetHistoryCounter;

    //
    // How often was a worker items dispatched to trim the
    // pool cache.
    //

    ULONG PoolTrimCounter;
    
    //
    // Caches of freed structures (thread, resource, node) used to
    // decrease kernel pool contention.
    //

    LIST_ENTRY FreeResourceList;    
    LIST_ENTRY FreeThreadList;
    LIST_ENTRY FreeNodeList;

    ULONG FreeResourceCount;
    ULONG FreeThreadCount;
    ULONG FreeNodeCount;   

    //
    // Resource address that caused the deadlock
    //

    PVOID Instigator;

    //
    // Number of participants in the deadlock
    //

    ULONG NumberOfParticipants;

    //
    // List of the nodes that participate in the deadlock
    //

    PVI_DEADLOCK_NODE Participant [NO_OF_DEADLOCK_PARTICIPANTS];

    LOGICAL CacheReductionInProgress;
} VI_DEADLOCK_GLOBALS, *PVI_DEADLOCK_GLOBALS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfdebug.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    vfdebug.c

Abstract:

    This module contains the neccessary code for controlling driver verifier
    debug output.

Author:

    Adrian J. Oney (AdriaO) May 5, 2000.

Revision History:


--*/

#include "vfdef.h"

//
// Today, all we need is this simple pre-inited ULONG.
//
#if DBG
ULONG VfSpewLevel = 0;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfdeadlock.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

   vfdeadlock.c

Abstract:

    Detect deadlocks in arbitrary kernel synchronization objects.

Author:

    Jordan Tigani (jtigani) 2-May-2000
    Silviu Calinoiu (silviuc) 9-May-2000

Revision History:

    Silviu Calinoiu (silviuc) 30-Sep-2000
    
        Rewrote garbage collection of resources since now we have support
        from ExFreePool. 
        
        Got rid of the ref/deref scheme for threads.
        
        Major optimization work.

--*/

/*++

    The Deadlock Verifier
    
    The deadlock verifier is used to detect potential deadlocks. It does this
    by acquiring the history of how resources are acquired and trying to figure
    out on the fly if there are any potential lock hierarchy issues. The algorithms
    for finding cycles in the lock dependency graph is totally "blind". This means
    that if a driver acquires lock A then B in one place and lock B then A in 
    another this will be triggered as a deadlock issue. This will happen even if you 
    can build a proof based on other contextual factors that the deadlock can never
    happen. 
    
    The deadlock verifier assumes there are four operations during the lifetime
    of a resource: initialize(), acquire(), release() and free(). The only one that
    is caught 100% of the time is free() due to special support from the kernel
    pool manager. The other ones can be missed if the operations are performed
    by an unverified driver or by kernel with kernel verifier disabled. The most
    typical of these misses is the initialize(). For example the kernel initializes
    a resource and then passes it to a driver to be used in acquire()/releae() cycles.
    This situation is covered 100% by the deadlock verifier. It will never complain
    about "resource uninitialized" issues.
    
    Missing acquire() or release() operations is trickier to deal with. 
    This can happen if the a verified driver acquires a resource and then another
    driver that is not verified releases it or viceversa. This is in and on itself
    a very bad programming practive and therefore the deadlock verifier will flag
    these issues. As a side note we cannot do too much about working around them
    given that we would like to. Also, because missing acquire() or release()
    operations puts deadlock verifier internal structures into inconsistent
    states these failures are difficult to debug.
    
    The deadlock verifier stores the lock dependency graph using three types
    of structures: THREAD, RESOURCE, NODE.

    For every active thread in the system that holds at least one resource
    the package maintains a THREAD structure. This gets created when a thread
    acquires first resource and gets destroyed when thread releases the last
    resource. If a thread does not hold any resource it will not have a
    corresponding THREAD structure.

    For every resource in the system there is a RESOURCE structure. This is created
    when Initialize() is called in a verified driver or we first encounter an
    Acquire() in a verified driver. Note that a resource can be initialized in
    an unverified driver and then passed to a verified driver for use. Therefore
    we can encounter Acquire() operations for resources that are not in the
    deadlock verifier database. The resource gets deleted from the database when
    the memory containing it is freed either because ExFreePool gets called or

    Every acquisition of a resource is modeled by a NODE structure. When a thread
    acquires resource B while holding A the deadlock verifier  will create a NODE 
    for B and link it to the node for A. 

    There are three important functions that make the interface with the outside
    world.

        VfDeadlockInitializeResource   hook for resource initialization
        VfDeadlockAcquireResource      hook for resource acquire
        VfDeadlockReleaseResource      hook for resource release
        VerifierDeadlockFreePool       hook called from ExFreePool for every free()


--*/

#include "vfdef.h"

//
// *TO DO* LIST
//
// [-] Hook KeTryAcquireSpinLock
// [-] Implement dynamic reset scheme for weird situations
// [-] Implement Strict and VeryStrict scheme.
//

//
// Put all verifier globals into the verifier data section so
// that it can be paged out whenever verifier is not enabled.
// Note that this declaration affects all global declarations
// within the module since there is no `data_seg()' counterpart.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEVRFD")
#endif

//
// Enable/disable the deadlock detection package. This can be used
// to disable temporarily the deadlock detection package.
//
                
BOOLEAN ViDeadlockDetectionEnabled;

//
// If true we will complain about release() without acquire() or acquire()
// while we think the resource is still owned. This can happen legitimately
// if a lock is shared between drivers and for example acquire() happens in
// an unverified driver and release() in a verified one or viceversa. The
// safest thing would be to enable this checks only if kernel verifier and
// dirver verifier for all drivers are enabled.
//

BOOLEAN ViDeadlockStrict;

//
// If true we will complain about uninitialized and double initialized
// resources. If false we resolve quitely these issues on the fly by 
// simulating an initialize ourselves during the acquire() operation.
// This can happen legitimately if the resource is initialized in an
// unverified driver and passed to a verified one to be used. Therefore
// the safest thing would be to enable this only if kernel verifier and
// all driver verifier for all dirvers are enabled.
//

BOOLEAN ViDeadlockVeryStrict;

//
// The way to deal with release() without acquire() issues is to reset
// the deadlock verifier completely. Here we keep a counter of how often
// does this happen.
//

ULONG ViDeadlockResets;

//
// If this is true only spinlocks are verified. All other resources
// are just ignored. 
//

BOOLEAN ViDeadlockVerifyOnlySpinlocks;

ULONG ViVerifyOnlySpinlocksFromRegistry;

//
// AgeWindow is used while trimming the graph nodes that have not
// been accessed in a while. If the global age minus the age of the node
// is bigger than the age window then the node is a candidate for trimming.
//
// The TrimThreshold variable controls if the trimming will start for a 
// resource. As long as a resource has less than TrimThreshold nodes we will
// not apply the ageing algorithm to trim nodes for that resource. 
//

ULONG ViDeadlockAgeWindow = 0x2000;

ULONG ViDeadlockTrimThreshold = 0x100;

//
// Various deadlock verification flags flags
//
// Recursive aquisition ok: mutexes can be recursively acquired
//
// No initialization function: if resource type does not have such a function
//     we cannot expect that in acquire() the resource is already initialized
//     by a previous call to initialize(). Fast mutexes are like this.
//
// Reverse release ok: release is not done in the same order as acquire
//
// Reinitialize ok: sometimes they reinitialize the resource.
//
// Note that a resource might appear as uninitialized if it is initialized
// in an unverified driver and then passed to a verified driver that calls
// acquire(). This is for instance the case with device extensions that are
// allocated by the kernel but used by a particular driver.
//
// silviuc: based on this maybe we should drop the whole not initialized thing?
//

#define VI_DEADLOCK_FLAG_RECURSIVE_ACQUISITION_OK       0x0001 
#define VI_DEADLOCK_FLAG_NO_INITIALIZATION_FUNCTION     0x0002
#define VI_DEADLOCK_FLAG_REVERSE_RELEASE_OK             0x0004
#define VI_DEADLOCK_FLAG_REINITIALIZE_OK                0x0008
#define VI_DEADLOCK_FLAG_RELEASE_DIFFERENT_THREAD_OK    0x0010

//
// Specific verification flags for each resource type. The
// indeces in the vector match the values for the enumeration
// type VI_DEADLOCK_RESOURCE_TYPE from ntos\inc\verifier.h.
//
// ISSUE: SilviuC: should place compile asserts here to enforce same order
//

ULONG ViDeadlockResourceTypeInfo[VfDeadlockTypeMaximum] =
{
    // ViDeadlockUnknown //
    0,

    // ViDeadlockMutex//
    VI_DEADLOCK_FLAG_RECURSIVE_ACQUISITION_OK |
    VI_DEADLOCK_FLAG_REVERSE_RELEASE_OK |
    0,

    // ViDeadlockMutexAbandoned//
    VI_DEADLOCK_FLAG_RECURSIVE_ACQUISITION_OK |
    VI_DEADLOCK_FLAG_REVERSE_RELEASE_OK |
    VI_DEADLOCK_FLAG_RELEASE_DIFFERENT_THREAD_OK |
    0,

    // ViDeadlockFastMutex //
    VI_DEADLOCK_FLAG_NO_INITIALIZATION_FUNCTION |
    0,

    // ViDeadlockFastMutexUnsafe //
    VI_DEADLOCK_FLAG_NO_INITIALIZATION_FUNCTION | 
    VI_DEADLOCK_FLAG_REVERSE_RELEASE_OK |
    0,

    // ViDeadlockSpinLock //
    VI_DEADLOCK_FLAG_REVERSE_RELEASE_OK | 
    VI_DEADLOCK_FLAG_REINITIALIZE_OK |
    0,

    // ViDeadlockQueuedSpinLock //
    VI_DEADLOCK_FLAG_NO_INITIALIZATION_FUNCTION |
    0,
};

//
// Control debugging behavior. A zero value means bugcheck for every failure.
//

ULONG ViDeadlockDebug;

//
// Various health indicators
//

struct {

    ULONG AllocationFailures : 1;
    ULONG KernelVerifierEnabled : 1;
    ULONG DriverVerifierForAllEnabled : 1;
    ULONG SequenceNumberOverflow : 1;
    ULONG DeadlockParticipantsOverflow : 1;
    ULONG ResourceNodeCountOverflow : 1;
    ULONG Reserved : 15;

} ViDeadlockState;

//
// Maximum number of locks acceptable to be hold simultaneously
//

ULONG ViDeadlockSimultaneousLocksLimit = 10;

//
// Deadlock verifier specific issues (bugs)
//
// SELF_DEADLOCK
//
//     Acquiring the same resource recursively.
//
// DEADLOCK_DETECTED
//
//     Plain deadlock. Need the previous information
//     messages to build a deadlock proof.
//
// UNINITIALIZED_RESOURCE
//
//     Acquiring a resource that was never initialized.
//
// UNEXPECTED_RELEASE
//
//     Releasing a resource which is not the last one
//     acquired by the current thread. Spinlocks are handled like this
//     in a few drivers. It is not a bug per se.
//
// UNEXPECTED_THREAD
//
//     Current thread does not have any resources acquired. This may be legit if
//     we acquire in one thread and release in another. This would be bad programming
//     practice but not a crash waiting to happen per se.
//
// MULTIPLE_INITIALIZATION
//
//      Attempting to initialize a second time the same resource.
//
// THREAD_HOLDS_RESOURCES
//
//      Thread was killed while holding resources or a resource is being
//      deleted while holding resources.
//

#define VI_DEADLOCK_ISSUE_SELF_DEADLOCK           0x1000
#define VI_DEADLOCK_ISSUE_DEADLOCK_DETECTED       0x1001
#define VI_DEADLOCK_ISSUE_UNINITIALIZED_RESOURCE  0x1002
#define VI_DEADLOCK_ISSUE_UNEXPECTED_RELEASE      0x1003
#define VI_DEADLOCK_ISSUE_UNEXPECTED_THREAD       0x1004
#define VI_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION 0x1005
#define VI_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES  0x1006
#define VI_DEADLOCK_ISSUE_UNACQUIRED_RESOURCE     0x1007

//
// Performance counters read from registry.
//

ULONG ViSearchedNodesLimitFromRegistry;
ULONG ViRecursionDepthLimitFromRegistry;

//
// Water marks for the cache of freed structures.
//
// N.B. The `MAX_FREE' value will trigger a trim and the 
// `TRIM_TARGET' will be the trim goal. The trim target must 
// be meaningfully lower than the free watermark to avoid a
// chainsaw effect where we get one above free highwater mark,
// we trim to the mark and next free will trigger a repeat.
// Since trimming is done in worker threads this will put a lot
// of unnecessary strain on the system.
//

#define VI_DEADLOCK_MAX_FREE_THREAD    0x40
#define VI_DEADLOCK_MAX_FREE_NODE      0x80
#define VI_DEADLOCK_MAX_FREE_RESOURCE  0x80

#define VI_DEADLOCK_TRIM_TARGET_THREAD    0x20
#define VI_DEADLOCK_TRIM_TARGET_NODE      0x40
#define VI_DEADLOCK_TRIM_TARGET_RESOURCE  0x40

WORK_QUEUE_ITEM ViTrimDeadlockPoolWorkItem;

//
// Amount of memory preallocated if kernel verifier
// is enabled. If kernel verifier is enabled no memory
// is ever allocated from kernel pool except in the
// DeadlockDetectionInitialize() routine.
//

ULONG ViDeadlockReservedThreads = 0x200;
ULONG ViDeadlockReservedNodes = 0x4000;
ULONG ViDeadlockReservedResources = 0x2000;

//
// Block types that can be allocated.
//

typedef enum {

    ViDeadlockUnknown = 0,
    ViDeadlockResource,
    ViDeadlockNode,
    ViDeadlockThread

} VI_DEADLOCK_ALLOC_TYPE;

//
// VI_DEADLOCK_GLOBALS
//

#define VI_DEADLOCK_HASH_BINS 0x3FF

PVI_DEADLOCK_GLOBALS ViDeadlockGlobals;

//
// Default maximum recursion depth for the deadlock 
// detection algorithm. This can be overridden by registry.
//

#define VI_DEADLOCK_MAXIMUM_DEGREE 4

//
// Default maximum number of searched nodes for the deadlock 
// detection algorithm. This can be overridden by registry.
//

#define VI_DEADLOCK_MAXIMUM_SEARCH 1000

//
//  Verifier deadlock detection pool tag.
//

#define VI_DEADLOCK_TAG 'kclD'

//
// Controls how often ForgetResourceHistory gets called.
//

#define VI_DEADLOCK_FORGET_HISTORY_FREQUENCY  16


NTSYSAPI
USHORT
NTAPI
RtlCaptureStackBackTrace(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash
   );

/////////////////////////////////////////////////////////////////////
/////////////////////////////// Internal deadlock detection functions
/////////////////////////////////////////////////////////////////////

VOID
VfDeadlockDetectionInitialize (
    );

VOID
VfDeadlockDetectionCleanup (
    );

VOID
ViDeadlockDetectionReset (
    );

PLIST_ENTRY
ViDeadlockDatabaseHash(
    IN PLIST_ENTRY Database,
    IN PVOID Address
    );

BOOLEAN
ViDeadlockIsDriverInList (
    PUNICODE_STRING BigString,
    PUNICODE_STRING Match
    );

PVI_DEADLOCK_RESOURCE
ViDeadlockSearchResource(
    IN PVOID ResourceAddress
    );

BOOLEAN
ViDeadlockSimilarNode (
    IN PVOID Resource,
    IN BOOLEAN TryNode,
    IN PVI_DEADLOCK_NODE Node
    );

BOOLEAN
ViDeadlockCanProceed (
    IN PVOID Resource, OPTIONAL
    IN PVOID CallAddress, OPTIONAL
    IN VI_DEADLOCK_RESOURCE_TYPE Type OPTIONAL
    );

BOOLEAN
ViDeadlockAnalyze(
    IN PVOID ResourceAddress,
    IN PVI_DEADLOCK_NODE CurrentNode,
    IN BOOLEAN FirstCall,
    IN ULONG Degree
    );

PVI_DEADLOCK_THREAD
ViDeadlockSearchThread (
    PKTHREAD Thread
    );

PVI_DEADLOCK_THREAD
ViDeadlockAddThread (
    PKTHREAD Thread,
    PVOID ReservedThread
    );

VOID
ViDeadlockDeleteThread (
    PVI_DEADLOCK_THREAD Thread,
    BOOLEAN Cleanup
    );

BOOLEAN
ViDeadlockAddResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type,
    IN PVOID Caller,
    IN PVOID ReservedResource
    );

PVOID
ViDeadlockAllocate (
    VI_DEADLOCK_ALLOC_TYPE Type
    );

VOID
ViDeadlockFree (
    PVOID Object,
    VI_DEADLOCK_ALLOC_TYPE Type
    );

VOID
ViDeadlockTrimPoolCache (
    VOID
    );

VOID
ViDeadlockTrimPoolCacheWorker (
    PVOID
    );

PVOID
ViDeadlockAllocateFromPoolCache (
    PULONG Count,
    ULONG MaximumCount,
    PLIST_ENTRY List,
    SIZE_T Offset
    );

VOID
ViDeadlockFreeIntoPoolCache (
    PVOID Object,
    PULONG Count,
    PLIST_ENTRY List,
    SIZE_T Offset
    );

VOID
ViDeadlockReportIssue (
    ULONG_PTR Param1,
    ULONG_PTR Param2,
    ULONG_PTR Param3,
    ULONG_PTR Param4
    );

VOID
ViDeadlockAddParticipant(
    PVI_DEADLOCK_NODE Node
    );

VOID
ViDeadlockDeleteResource (
    PVI_DEADLOCK_RESOURCE Resource,
    BOOLEAN Cleanup
    );

VOID
ViDeadlockDeleteNode (
    PVI_DEADLOCK_NODE Node,
    BOOLEAN Cleanup
    );

ULONG
ViDeadlockNodeLevel (
    PVI_DEADLOCK_NODE Node
    );

BOOLEAN
ViDeadlockCertify(
    VOID
    );

BOOLEAN
ViDeadlockDetectionIsLockedAlready (
    );

VOID
ViDeadlockDetectionLock (
    PKIRQL OldIrql
    );

VOID
ViDeadlockDetectionUnlock (
    KIRQL OldIrql
    );

VOID
ViDeadlockCheckThreadConsistency (
    PVI_DEADLOCK_THREAD Thread,
    BOOLEAN Recursion
    );

VOID
ViDeadlockCheckNodeConsistency (
    PVI_DEADLOCK_NODE Node,
    BOOLEAN Recursion
    );

VOID
ViDeadlockCheckResourceConsistency (
    PVI_DEADLOCK_RESOURCE Resource,
    BOOLEAN Recursion
    );

PVI_DEADLOCK_THREAD
ViDeadlockCheckThreadReferences (
    PVI_DEADLOCK_NODE Node
    );

BOOLEAN
ViIsThreadInsidePagingCodePaths (
    );

VOID 
ViDeadlockCheckDuplicatesAmongChildren (
    PVI_DEADLOCK_NODE Parent,
    PVI_DEADLOCK_NODE Child
    );

VOID 
ViDeadlockCheckDuplicatesAmongRoots (
    PVI_DEADLOCK_NODE Root
    );

LOGICAL
ViDeadlockSimilarNodes (
    PVI_DEADLOCK_NODE NodeA,
    PVI_DEADLOCK_NODE NodeB
    );

VOID
ViDeadlockMergeNodes (
    PVI_DEADLOCK_NODE NodeTo,
    PVI_DEADLOCK_NODE NodeFrom
    );

VOID
ViDeadlockTrimResources (
    PLIST_ENTRY HashList
    );

VOID
ViDeadlockForgetResourceHistory (
    PVI_DEADLOCK_RESOURCE Resource,
    ULONG TrimThreshold,
    ULONG AgeThreshold
    );

VOID
ViDeadlockCheckStackLimits (
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGEVRFY, VfDeadlockDetectionInitialize)
#pragma alloc_text(PAGEVRFY, VfDeadlockInitializeResource)
#pragma alloc_text(PAGEVRFY, VfDeadlockAcquireResource)
#pragma alloc_text(PAGEVRFY, VfDeadlockReleaseResource)
#pragma alloc_text(PAGEVRFY, VfDeadlockDeleteMemoryRange)
#pragma alloc_text(PAGEVRFY, VfDeadlockDetectionCleanup)
#pragma alloc_text(PAGEVRFY, ViDeadlockDetectionReset)

#pragma alloc_text(PAGEVRFY, ViDeadlockDetectionLock)
#pragma alloc_text(PAGEVRFY, ViDeadlockDetectionUnlock)
#pragma alloc_text(PAGEVRFY, ViDeadlockDetectionIsLockedAlready)

#pragma alloc_text(PAGEVRFY, ViDeadlockCanProceed)
#pragma alloc_text(PAGEVRFY, ViDeadlockAnalyze)
#pragma alloc_text(PAGEVRFY, ViDeadlockDatabaseHash)

#pragma alloc_text(PAGEVRFY, ViDeadlockSearchResource)

#pragma alloc_text(PAGEVRFY, ViDeadlockSimilarNode)

#pragma alloc_text(PAGEVRFY, ViDeadlockSearchThread)
#pragma alloc_text(PAGEVRFY, ViDeadlockAddThread)
#pragma alloc_text(PAGEVRFY, ViDeadlockDeleteThread)
#pragma alloc_text(PAGEVRFY, ViDeadlockAddResource)

#pragma alloc_text(PAGEVRFY, ViDeadlockAllocate)
#pragma alloc_text(PAGEVRFY, ViDeadlockFree)
#pragma alloc_text(PAGEVRFY, ViDeadlockTrimPoolCache)
#pragma alloc_text(PAGEVRFY, ViDeadlockTrimPoolCacheWorker)
#pragma alloc_text(PAGEVRFY, ViDeadlockAllocateFromPoolCache)
#pragma alloc_text(PAGEVRFY, ViDeadlockFreeIntoPoolCache)

#pragma alloc_text(PAGEVRFY, ViDeadlockReportIssue)
#pragma alloc_text(PAGEVRFY, ViDeadlockAddParticipant)

#pragma alloc_text(PAGEVRFY, ViDeadlockDeleteResource)
#pragma alloc_text(PAGEVRFY, ViDeadlockDeleteNode)
#pragma alloc_text(PAGEVRFY, ViDeadlockNodeLevel)
#pragma alloc_text(PAGEVRFY, ViDeadlockCertify)

#pragma alloc_text(PAGEVRFY, VerifierDeadlockFreePool)

#pragma alloc_text(PAGEVRFY, ViDeadlockCheckResourceConsistency)
#pragma alloc_text(PAGEVRFY, ViDeadlockCheckThreadConsistency)
#pragma alloc_text(PAGEVRFY, ViDeadlockCheckNodeConsistency)
#pragma alloc_text(PAGEVRFY, ViDeadlockCheckThreadReferences)

#pragma alloc_text(PAGEVRFY, VfDeadlockBeforeCallDriver)
#pragma alloc_text(PAGEVRFY, VfDeadlockAfterCallDriver)
#pragma alloc_text(PAGEVRFY, ViIsThreadInsidePagingCodePaths)

#pragma alloc_text(PAGEVRFY, ViDeadlockCheckDuplicatesAmongChildren)
#pragma alloc_text(PAGEVRFY, ViDeadlockCheckDuplicatesAmongRoots)
#pragma alloc_text(PAGEVRFY, ViDeadlockSimilarNodes)
#pragma alloc_text(PAGEVRFY, ViDeadlockMergeNodes)

#pragma alloc_text(PAGEVRFY, ViDeadlockTrimResources)
#pragma alloc_text(PAGEVRFY, ViDeadlockForgetResourceHistory)

#pragma alloc_text(PAGEVRFY, ViDeadlockCheckStackLimits)

#endif

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Lock/unlock deadlock verifier 
/////////////////////////////////////////////////////////////////////

//
// Global `deadlock lock database' lock
//

KSPIN_LOCK ViDeadlockDatabaseLock;
PKTHREAD ViDeadlockDatabaseOwner;


VOID
ViDeadlockDetectionLock (
    PKIRQL OldIrql
    )
{
    KeAcquireSpinLock(&ViDeadlockDatabaseLock, (OldIrql));               
    ViDeadlockDatabaseOwner = KeGetCurrentThread ();                     
}


VOID
ViDeadlockDetectionUnlock (
    KIRQL OldIrql
    )
{
    ViDeadlockDatabaseOwner = NULL;                                      
    KeReleaseSpinLock(&ViDeadlockDatabaseLock, OldIrql);                 
}


BOOLEAN
ViDeadlockDetectionIsLockedAlready (
    )
{
    PVOID CurrentThread;
    PVOID CurrentOwner;

    ASSERT (ViDeadlockGlobals);
    ASSERT (ViDeadlockDetectionEnabled);
    
    //
    // Figure out if are in a recursive call into the deadlock verifier.
    // This can happen if we try to allocate/free pool while we execute
    // code in the deadlock verifier.
    //
    // silviuc: can this be done instead with a simple read ?
    //

    CurrentThread = (PVOID) KeGetCurrentThread();
    
    CurrentOwner = InterlockedCompareExchangePointer (&ViDeadlockDatabaseOwner,
                                                      CurrentThread,
                                                      CurrentThread);

    if (CurrentOwner == CurrentThread) {
        
        return TRUE;    
    }
    else {
        
        return FALSE;
    }
}


/////////////////////////////////////////////////////////////////////
///////////////////// Initialization and deadlock database management
/////////////////////////////////////////////////////////////////////

PLIST_ENTRY
ViDeadlockDatabaseHash(
    IN PLIST_ENTRY Database,
    IN PVOID Address
    )
/*++

Routine Description:

    This routine hashes the resource address into the deadlock database.
    The hash bin is represented by a list entry.

    NOTE -- be careful modifying the method used for hashing --
        we currently hash based on the PFN or page number of 
        the address given. This knowledge is used to optimize
        the number of hash bins needed to look through
        in order to delete addresses. For example, suppose
        the address was 0x1020. This is PFN 1 and if we were 
        deleting addresses 0x1020-0x1040, we'd only have to
        look in a single hash bin to find and remove the 
        address. Read VfDeadlockDeleteMemoryRange() for more details.
        
Arguments:

    ResourceAddress: Address of the resource that is being hashed

Return Value:

    PLIST_ENTRY -- the list entry associated with the hash bin we land in.

--*/
{
    return Database + ((((ULONG_PTR)Address)>> PAGE_SHIFT) % VI_DEADLOCK_HASH_BINS);
}


VOID
VfDeadlockDetectionInitialize(
    IN LOGICAL VerifyAllDrivers,
    IN LOGICAL VerifyKernel
    )
/*++

Routine Description:

    This routine initializes the data structures necessary for detecting
    deadlocks in kernel synchronization objects.

Arguments:

    VerifyAllDrivers - Supplies TRUE if we are verifying all drivers.

    VerifyKernel - Supplies TRUE if we are verifying the kernel.

Return Value:

    None. If successful ViDeadlockGlobals will point to a fully initialized
    structure.

Environment:

    System initialization only.

--*/
{
    ULONG I;
    SIZE_T TableSize;
    PLIST_ENTRY Current;
    PVOID Block;

    //
    // Allocate the globals structure. ViDeadlockGlobals value is
    // used to figure out if the whole initialization was successful
    // or not.
    //

    ViDeadlockGlobals = ExAllocatePoolWithTag (NonPagedPool, 
                                               sizeof (VI_DEADLOCK_GLOBALS),
                                               VI_DEADLOCK_TAG);

    if (ViDeadlockGlobals == NULL) {
        goto Failed;
    }

    RtlZeroMemory (ViDeadlockGlobals, sizeof (VI_DEADLOCK_GLOBALS));

    ExInitializeWorkItem (&ViTrimDeadlockPoolWorkItem,
                          ViDeadlockTrimPoolCacheWorker,
                          NULL);

    //
    // Allocate hash tables for resources and threads.
    //

    TableSize = sizeof (LIST_ENTRY) * VI_DEADLOCK_HASH_BINS;

    ViDeadlockGlobals->ResourceDatabase = ExAllocatePoolWithTag (NonPagedPool, 
                                                                 TableSize,
                                                                 VI_DEADLOCK_TAG);

    if (!ViDeadlockGlobals->ResourceDatabase) {
        return;
    }

    ViDeadlockGlobals->ThreadDatabase = ExAllocatePoolWithTag (NonPagedPool, 
                                                               TableSize,
                                                               VI_DEADLOCK_TAG);

    if (!ViDeadlockGlobals->ThreadDatabase) {
        goto Failed;
    }

    //
    // Initialize the free lists.
    //

    InitializeListHead(&ViDeadlockGlobals->FreeResourceList);
    InitializeListHead(&ViDeadlockGlobals->FreeThreadList);
    InitializeListHead(&ViDeadlockGlobals->FreeNodeList);

    //
    // Initialize hash bins and database lock.
    //    

    for (I = 0; I < VI_DEADLOCK_HASH_BINS; I += 1) {

        InitializeListHead(&(ViDeadlockGlobals->ResourceDatabase[I]));        
        InitializeListHead(&ViDeadlockGlobals->ThreadDatabase[I]);    
    }

    KeInitializeSpinLock (&ViDeadlockDatabaseLock);    

    //
    // Did user request only spin locks? This relieves the
    // memory consumption.
    //

    if (ViVerifyOnlySpinlocksFromRegistry) {
        ViDeadlockVerifyOnlySpinlocks = TRUE;
    }
    
    //
    // Initialize deadlock analysis parameters
    //

    ViDeadlockGlobals->RecursionDepthLimit = (ViRecursionDepthLimitFromRegistry) ?
                                            ViRecursionDepthLimitFromRegistry : 
                                            VI_DEADLOCK_MAXIMUM_DEGREE;

    ViDeadlockGlobals->SearchedNodesLimit = (ViSearchedNodesLimitFromRegistry) ?
                                            ViSearchedNodesLimitFromRegistry :
                                            VI_DEADLOCK_MAXIMUM_SEARCH;

    //
    // Preallocate all resources if kernel verifier is enabled.
    //

    if (VerifyKernel) {

        PVOID PoolBlock;

        for (I = 0; I < ViDeadlockReservedThreads; I += 1) {

            PoolBlock = ExAllocatePoolWithTag( NonPagedPool, 
                                               sizeof (VI_DEADLOCK_THREAD),
                                               VI_DEADLOCK_TAG);

            if (PoolBlock == NULL) {
                goto Failed;
            }

            ViDeadlockGlobals->BytesAllocated += sizeof (VI_DEADLOCK_THREAD);
            ViDeadlockGlobals->Threads[0] += 1;
            ViDeadlockFree (PoolBlock, ViDeadlockThread);
        }

        for (I = 0; I < ViDeadlockReservedNodes; I += 1) {

            PoolBlock = ExAllocatePoolWithTag( NonPagedPool, 
                                               sizeof (VI_DEADLOCK_NODE),
                                               VI_DEADLOCK_TAG);

            if (PoolBlock == NULL) {
                goto Failed;
            }

            ViDeadlockGlobals->BytesAllocated += sizeof (VI_DEADLOCK_NODE);
            ViDeadlockGlobals->Nodes[0] += 1;
            ViDeadlockFree (PoolBlock, ViDeadlockNode);
        }

        for (I = 0; I < ViDeadlockReservedResources; I += 1) {

            PoolBlock = ExAllocatePoolWithTag( NonPagedPool, 
                                               sizeof (VI_DEADLOCK_RESOURCE),
                                               VI_DEADLOCK_TAG);

            if (PoolBlock == NULL) {
                goto Failed;
            }

            ViDeadlockGlobals->BytesAllocated += sizeof (VI_DEADLOCK_RESOURCE);
            ViDeadlockGlobals->Resources[0] += 1;
            ViDeadlockFree (PoolBlock, ViDeadlockResource);
        }
    }

    //
    // Mark that everything went fine and return
    //

    if (VerifyKernel) {
        ViDeadlockState.KernelVerifierEnabled = 1;
    }

    if (VerifyAllDrivers) {

        ViDeadlockState.DriverVerifierForAllEnabled = 1;

        ViDeadlockStrict = TRUE;
        
        if (ViDeadlockState.KernelVerifierEnabled == 1) {

            //
            // silviuc: The VeryStrict option is unfunctional right now because
            // KeInitializeSpinLock is a kernel routine and therefore
            // cannot be hooked for kernel locks. 
            //

            // ViDeadlockVeryStrict = TRUE;
        }
    }

    ViDeadlockDetectionEnabled = TRUE;
    return;

Failed:

    //
    // Cleanup if any of our allocations failed
    //

    Current = ViDeadlockGlobals->FreeNodeList.Flink;

    while (Current != &(ViDeadlockGlobals->FreeNodeList)) {

        Block = (PVOID) CONTAINING_RECORD (Current,
                                           VI_DEADLOCK_NODE,
                                           FreeListEntry);

        Current = Current->Flink;
        ExFreePool (Block);
    }

    Current = ViDeadlockGlobals->FreeNodeList.Flink;

    while (Current != &(ViDeadlockGlobals->FreeResourceList)) {

        Block = (PVOID) CONTAINING_RECORD (Current,
                                           VI_DEADLOCK_RESOURCE,
                                           FreeListEntry);

        Current = Current->Flink;
        ExFreePool (Block);
    }

    Current = ViDeadlockGlobals->FreeNodeList.Flink;

    while (Current != &(ViDeadlockGlobals->FreeThreadList)) {

        Block = (PVOID) CONTAINING_RECORD (Current,
                                           VI_DEADLOCK_THREAD,
                                           FreeListEntry);

        Current = Current->Flink;
        ExFreePool (Block);
    }

    if (NULL != ViDeadlockGlobals->ResourceDatabase) {
        ExFreePool(ViDeadlockGlobals->ResourceDatabase);
    }

    if (NULL != ViDeadlockGlobals->ThreadDatabase) {
        ExFreePool(ViDeadlockGlobals->ThreadDatabase);
    }

    if (NULL != ViDeadlockGlobals) {
        ExFreePool(ViDeadlockGlobals);

        //
        // Important to set this to null for failure because it is
        // used to figure out if the package got initialized or not.
        //

        ViDeadlockGlobals = NULL;
    }        
    
    return;
}


VOID
VfDeadlockDetectionCleanup (
    )
/*++

Routine Description:

    This routine tears down all deadlock verifier internal structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG Index;
    PLIST_ENTRY Current;
    PVI_DEADLOCK_RESOURCE Resource;
    PVI_DEADLOCK_THREAD Thread;
    PVOID Block;

    //
    // If we are not initialized then nothing to do.
    //
    
    if (ViDeadlockGlobals == NULL) {
        return;
    }

    //
    // Iterate all resources and delete them. This will also delete
    // all nodes associated with resources.
    //

    for (Index = 0; Index < VI_DEADLOCK_HASH_BINS; Index += 1) {

        Current = ViDeadlockGlobals->ResourceDatabase[Index].Flink;

        while (Current != &(ViDeadlockGlobals->ResourceDatabase[Index])) {


            Resource = CONTAINING_RECORD (Current,
                                          VI_DEADLOCK_RESOURCE,
                                          HashChainList);

            Current = Current->Flink;

            ViDeadlockDeleteResource (Resource, TRUE);
        }
    }

    //
    // Iterate all threads and delete them.
    //
 
    for (Index = 0; Index < VI_DEADLOCK_HASH_BINS; Index += 1) {
        Current = ViDeadlockGlobals->ThreadDatabase[Index].Flink;

        while (Current != &(ViDeadlockGlobals->ThreadDatabase[Index])) {

            Thread = CONTAINING_RECORD (Current,
                                        VI_DEADLOCK_THREAD,
                                        ListEntry);

            Current = Current->Flink;

            ViDeadlockDeleteThread (Thread, TRUE);
        }
    }

    //
    // Everything should be in the pool caches by now.
    //

    ASSERT (ViDeadlockGlobals->BytesAllocated == 0);

    //
    // Free pool caches.
    //

    Current = ViDeadlockGlobals->FreeNodeList.Flink;

    while (Current != &(ViDeadlockGlobals->FreeNodeList)) {

        Block = (PVOID) CONTAINING_RECORD (Current,
                                           VI_DEADLOCK_NODE,
                                           FreeListEntry);

        Current = Current->Flink;
        ExFreePool (Block);
    }

    Current = ViDeadlockGlobals->FreeNodeList.Flink;

    while (Current != &(ViDeadlockGlobals->FreeResourceList)) {

        Block = (PVOID) CONTAINING_RECORD (Current,
                                           VI_DEADLOCK_RESOURCE,
                                           FreeListEntry);

        Current = Current->Flink;
        ExFreePool (Block);
    }

    Current = ViDeadlockGlobals->FreeNodeList.Flink;

    while (Current != &(ViDeadlockGlobals->FreeThreadList)) {

        Block = (PVOID) CONTAINING_RECORD (Current,
                                           VI_DEADLOCK_THREAD,
                                           FreeListEntry);

        Current = Current->Flink;
        ExFreePool (Block);
    }

    //
    // Free databases and global structure
    //

    ExFreePool (ViDeadlockGlobals->ResourceDatabase);    
    ExFreePool (ViDeadlockGlobals->ThreadDatabase);    

    ExFreePool(ViDeadlockGlobals);    

    ViDeadlockGlobals = NULL;
    ViDeadlockDetectionEnabled = FALSE;
}


VOID
ViDeadlockDetectionReset (
    )
/*++

Routine Description:

    This routine resets all internal deadlock verifier structures. All nodes,
    resources, threads are forgotten. They will all go into free pool caches
    ready to be used in a new life cycle.
    
    The function is usually called with the deadlock verifier lock held.
    It will not touch the lock at all therefore the caller will still
    hold the lock after return.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG Index;
    PLIST_ENTRY Current;
    PVI_DEADLOCK_RESOURCE Resource;
    PVI_DEADLOCK_THREAD Thread;

    //
    // If we are not initialized or not enabled then nothing to do.
    //
    
    if (ViDeadlockGlobals == NULL || ViDeadlockDetectionEnabled == FALSE) {
        return;
    }

    ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread());

    //
    // Iterate all resources and delete them. This will also delete
    // all nodes associated with resources.
    //

    for (Index = 0; Index < VI_DEADLOCK_HASH_BINS; Index += 1) {

        Current = ViDeadlockGlobals->ResourceDatabase[Index].Flink;

        while (Current != &(ViDeadlockGlobals->ResourceDatabase[Index])) {


            Resource = CONTAINING_RECORD (Current,
                                          VI_DEADLOCK_RESOURCE,
                                          HashChainList);

            Current = Current->Flink;

            ViDeadlockDeleteResource (Resource, TRUE);
        }
    }

    //
    // Iterate all threads and delete them.
    //
 
    for (Index = 0; Index < VI_DEADLOCK_HASH_BINS; Index += 1) {
        Current = ViDeadlockGlobals->ThreadDatabase[Index].Flink;

        while (Current != &(ViDeadlockGlobals->ThreadDatabase[Index])) {

            Thread = CONTAINING_RECORD (Current,
                                        VI_DEADLOCK_THREAD,
                                        ListEntry);

            Current = Current->Flink;

            ViDeadlockDeleteThread (Thread, TRUE);
        }
    }

    //
    // Everything should be in the pool caches by now.
    //

    ASSERT (ViDeadlockGlobals->BytesAllocated == 0);

    //
    // Update counters and forget past failures.
    //

    ViDeadlockGlobals->AllocationFailures = 0;
    ViDeadlockResets += 1;
}


BOOLEAN
ViDeadlockCanProceed (
    IN PVOID Resource, OPTIONAL
    IN PVOID CallAddress, OPTIONAL
    IN VI_DEADLOCK_RESOURCE_TYPE Type OPTIONAL
    )
/*++

Routine Description:

    This routine is called by deadlock verifier exports (initialize,
    acquire, release) to figure out if deadlock verification should
    proceed for the current operation. There are several reasons
    why the return should be false. We failed to initialize the
    deadlock verifier package or the caller is an amnestied driver
    or the deadlock verification is temporarily disabled, etc.

Arguments:

    Resource - address of the kernel resource operated upon 
    
    CallAddress - address of the caller for the operation

Return Value:

    True if deadlock verification should proceed for the current
    operation.

Environment:

    Internal. Called by deadlock verifier exports.

--*/
{
#if defined(_X86_)
    ULONG flags;
#endif

    //
    // From ntos\mm\mi.h - this lock is acquired with
    // KeTryAcquireSpinLock which cannot be hooked for
    // kernel code.
    //

    extern KSPIN_LOCK MmExpansionLock;

    UNREFERENCED_PARAMETER (CallAddress);

    //
    // Skip for machines with more than 4 processors because 
    // it is too slow and all code is protected
    // by one single lock and this becomes a bottleneck.
    // Note. We cannot check for this during VfDeadlockDetectionInitialize
    // because at that time the system runs uniprocessor.
    //

    if (KeNumberProcessors > 4) {
        return FALSE;
    }

    //
    // Skip if package not initialized
    //

    if (ViDeadlockGlobals == NULL) {
        return FALSE;
    }

    //
    // Skip is package is disabled
    //

    if (! ViDeadlockDetectionEnabled) {
        return FALSE;
    }
        
    //
    // Skip if operation happens above DPC level. This avoids a case
    // where KeAcquireSpinlockRaiseToSynch is used to acquire a spinlock. 
    // During lock release when we need to acquire the deadlock verifier lock
    // driver verifier will complain about lowering the IRQL. Since this is a
    // very uncommon interface it is not worth for now to add the code to
    // actually verify operations on this lock (MmProtectedPteLock). That would
    // require first to add thunking code in driver verifier for raisetosynch
    // interface.
    //

    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
        return FALSE;
    }

#if defined(_X86_)

    _asm {
        pushfd
        pop     eax
        mov     flags, eax
    }

    if ((flags & EFLAGS_INTERRUPT_MASK) == 0) {
        return FALSE;
    }

#endif

#if defined(_AMD64_)
    if ((GetCallersEflags () & EFLAGS_IF_MASK) == 0) {
        return FALSE;
    }
#endif

    //
    // Check if anybody switched the stack.
    //

    ViDeadlockCheckStackLimits ();

    //
    // If it is only as spinlock affair then skip.
    //

    if (Type != VfDeadlockUnknown) {

        if (ViDeadlockVerifyOnlySpinlocks && Type != VfDeadlockSpinLock) {
            return FALSE;
        }
    }

    //
    // We do not check the deadlock verifier lock
    //

    if (Resource == &ViDeadlockDatabaseLock) {
        return FALSE;
    }

    //
    // Skip kernel locks acquired with KeTryAcquireSpinLock
    //

    if (Resource == &MmExpansionLock) {
        return FALSE;
    }

    //
    // Figure out if are in a recursive call into the deadlock verifier.
    // This can happen if we try to allocate/free pool while we execute
    // code in the deadlock verifier.
    //

    if (ViDeadlockDetectionIsLockedAlready ()) {
        return FALSE;
    }

    //
    // Skip if we ever encountered an allocation failure
    //

    if (ViDeadlockGlobals->AllocationFailures > 0) {
        return FALSE;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// Deadlock detection logic
/////////////////////////////////////////////////////////////////////


BOOLEAN
ViDeadlockAnalyze(
    IN PVOID ResourceAddress,
    IN PVI_DEADLOCK_NODE AcquiredNode,
    IN BOOLEAN FirstCall,
    IN ULONG Degree
    )
/*++

Routine Description:

    This routine determines whether the acquisition of a certain resource
    could result in a deadlock.

    The routine assumes the deadlock database lock is held.

Arguments:

    ResourceAddress - address of the resource that will be acquired

    AcquiredNode - a node representing the most recent resource acquisition
        made by the thread trying to acquire `ResourceAddress'.

    FirstCall - true if this is not a recursive call made from within the
        function. It is used for doing one time per analysis only operations.

    Degree - depth of recursion.

Return Value:

    True if deadlock detected, false otherwise.

--*/
{
    PVI_DEADLOCK_NODE CurrentNode;
    PVI_DEADLOCK_RESOURCE CurrentResource;
    PVI_DEADLOCK_NODE CurrentParent;
    BOOLEAN FoundDeadlock;
    PLIST_ENTRY Current;

    ASSERT (AcquiredNode);

    //
    // Setup global counters.
    //

    if (FirstCall) {
        
        ViDeadlockGlobals->NodesSearched = 0;
        ViDeadlockGlobals->SequenceNumber += 1;
        ViDeadlockGlobals->NumberOfParticipants = 0;                
        ViDeadlockGlobals->Instigator = NULL;

        if (ViDeadlockGlobals->SequenceNumber == ((1 << 30) - 2)) {
            ViDeadlockState.SequenceNumberOverflow = 1;
        }
    }

    //
    // If our node is already stamped with the current sequence number
    // then we have been here before in the current search. There is a very
    // remote possibility that the node was not touched in the last
    // 2^N calls to this function and the sequence number counter
    // overwrapped but we can live with this.
    //

    if (AcquiredNode->SequenceNumber == ViDeadlockGlobals->SequenceNumber) {
        return FALSE;
    }

    //
    // Update the counter of nodes touched in this search
    //

    ViDeadlockGlobals->NodesSearched += 1;
    
    //
    // Stamp node with current sequence number.
    //

    AcquiredNode->SequenceNumber = ViDeadlockGlobals->SequenceNumber;

    //
    // Stop recursion if it gets too deep.
    //
    
    if (Degree > ViDeadlockGlobals->RecursionDepthLimit) {

        ViDeadlockGlobals->DepthLimitHits += 1;
        return FALSE;
    }

    //
    // Stop recursion if it gets too lengthy
    //

    if (ViDeadlockGlobals->NodesSearched >= ViDeadlockGlobals->SearchedNodesLimit) {

        ViDeadlockGlobals->SearchLimitHits += 1;
        return FALSE;
    }

    //
    // Check if AcquiredNode's resource equals ResourceAddress.
    // This is the final point for a deadlock detection because
    // we managed to find a path in the graph that leads us to the
    // same resource as the one to be acquired. From now on we
    // will start returning from recursive calls and build the
    // deadlock proof along the way.
    //

    ASSERT (AcquiredNode->Root);

    if (ResourceAddress == AcquiredNode->Root->ResourceAddress) {

        if (AcquiredNode->ReleasedOutOfOrder == 0) {
            
            ASSERT (FALSE == FirstCall);

            FoundDeadlock = TRUE;

            ViDeadlockAddParticipant (AcquiredNode);

            goto Exit;
        }
    }

    //
    // Iterate all nodes in the graph using the same resource from AcquiredNode.
    //

    FoundDeadlock = FALSE;

    CurrentResource = AcquiredNode->Root;

    Current = CurrentResource->ResourceList.Flink;

    while (Current != &(CurrentResource->ResourceList)) {

        CurrentNode = CONTAINING_RECORD (Current,
                                         VI_DEADLOCK_NODE,
                                         ResourceList);

        ASSERT (CurrentNode->Root);
        ASSERT (CurrentNode->Root == CurrentResource);

        //
        // Mark node as visited
        //

        CurrentNode->SequenceNumber = ViDeadlockGlobals->SequenceNumber;

        //
        // Check recursively the parent of the CurrentNode. This will check the 
        // whole parent chain eventually through recursive calls.
        //

        CurrentParent = CurrentNode->Parent;

        if (CurrentParent != NULL) {

            //
            // If we are traversing the Parent chain of AcquiredNode we do not
            // increment the recursion Degree because we know the chain will
            // end. For calls to other similar nodes we have to protect against
            // too much recursion (time consuming).
            //

            if (CurrentNode != AcquiredNode) {

                //
                // Recurse across the graph
                //

                FoundDeadlock = ViDeadlockAnalyze (ResourceAddress,
                                                   CurrentParent,
                                                   FALSE,
                                                   Degree + 1);

            }
            else {

                //
                // Recurse down the graph
                //
                
                FoundDeadlock = ViDeadlockAnalyze (ResourceAddress,
                                                   CurrentParent,
                                                   FALSE,
                                                   Degree);
                                
            }

            if (FoundDeadlock) {

                //
                // Here we might skip adding a node that was released out of order.
                // This will make cycle reporting cleaner but it will be more
                // difficult to understand the actual issue. So we will pass
                // for now.
                //

                ViDeadlockAddParticipant(CurrentNode);

                if (CurrentNode != AcquiredNode) {

                    ViDeadlockAddParticipant(AcquiredNode);

                }

                goto Exit;
            }
        }

        Current = Current->Flink;
    }


    Exit:

    if (FoundDeadlock && FirstCall) {

        //
        // Make sure that the deadlock does not look like ABC - ACB.
        // These sequences are protected by a common resource and therefore
        // this is not a real deadlock.
        //

        if (ViDeadlockCertify ()) {

            //
            // Print deadlock information and save the address so the 
            // debugger knows who caused the deadlock.
            //

            ViDeadlockGlobals->Instigator = ResourceAddress;
            
            DbgPrint("****************************************************************************\n");
            DbgPrint("**                                                                        **\n");
            DbgPrint("** Deadlock detected! Type !deadlock in the debugger for more information **\n");
            DbgPrint("**                                                                        **\n");
            DbgPrint("****************************************************************************\n");

            ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_DEADLOCK_DETECTED,
                                   (ULONG_PTR)ResourceAddress,
                                   (ULONG_PTR)AcquiredNode,
                                   0);

            //
            // It is impossible to continue at this point.
            //

            return FALSE;

        } else {

            //
            // If we decided that this was not a deadlock after all, set the return value
            // to not return a deadlock
            //

            FoundDeadlock = FALSE;
        }
    }

    if (FirstCall) {

        if (ViDeadlockGlobals->NodesSearched > ViDeadlockGlobals->MaxNodesSearched) {

            ViDeadlockGlobals->MaxNodesSearched = ViDeadlockGlobals->NodesSearched;
        }
    }

    return FoundDeadlock;
}


BOOLEAN
ViDeadlockCertify(
    )
/*++

Routine Description:

    A potential deadlock has been detected. However our algorithm will generate
    false positives in a certain case -- if two deadlocking nodes are ever taken
    after the same node -- i.e. A->B->C A->C->B. While this can be considered
    bad programming practice it is not really a deadlock and we should not
    bugcheck.

    Also we must check to make sure that there are no nodes at the top of the
    deadlock chains that have only been acquired with try-acquire... this does
    not cause a real deadlock.

    The deadlock database lock should be held.

Arguments:

    None.

Return Value:

    True if this is really a deadlock, false to exonerate.

--*/
{
    PVI_DEADLOCK_NODE innerNode,outerNode;
    ULONG innerParticipant,outerParticipant;
    ULONG numberOfParticipants;

    ULONG currentParticipant;
        
    numberOfParticipants = ViDeadlockGlobals->NumberOfParticipants;
    
    //
    // Note -- this isn't a particularly efficient way to do this. However,
    // it is a particularly easy way to do it. This function should be called
    // extremely rarely -- so IMO there isn't really a problem here.
    //

    //
    // Outer loop
    //
    outerParticipant = numberOfParticipants;
    while(outerParticipant > 1) {
        outerParticipant--;
        
        for (outerNode = ViDeadlockGlobals->Participant[outerParticipant]->Parent;
            outerNode != NULL;
            outerNode = outerNode->Parent ) {

            //
            // Inner loop
            //
            innerParticipant = outerParticipant-1;
            while (innerParticipant) {
                innerParticipant--;
                
                for(innerNode = ViDeadlockGlobals->Participant[innerParticipant]->Parent;
                    innerNode != NULL;
                    innerNode = innerNode->Parent) {

                    if (innerNode->Root->ResourceAddress == outerNode->Root->ResourceAddress) {
                        //
                        // The twain shall meet -- this is not a deadlock
                        //
                        ViDeadlockGlobals->ABC_ACB_Skipped++;											
                        return FALSE;
                    }
                }

            }
        }
    }

    for (currentParticipant = 1; currentParticipant < numberOfParticipants; currentParticipant += 1) {
        if (ViDeadlockGlobals->Participant[currentParticipant]->Root->ResourceAddress == 
            ViDeadlockGlobals->Participant[currentParticipant-1]->Root->ResourceAddress) {
            //
            // This is the head of a chain...
            //
            if (ViDeadlockGlobals->Participant[currentParticipant-1]->OnlyTryAcquireUsed == TRUE) {
                //
                // Head of a chain used only try acquire. This can never cause a deadlock.
                //
                return FALSE;

            }
        }

    }

    

    return TRUE;

}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////// Resource management
/////////////////////////////////////////////////////////////////////

PVI_DEADLOCK_RESOURCE
ViDeadlockSearchResource(
    IN PVOID ResourceAddress
    )
/*++

Routine Description:

    This routine finds the resource descriptor structure for a
    resource if one exists.

Arguments:

    ResourceAddress: Address of the resource in question (as used by
       the kernel).     

Return Value:

    PVI_DEADLOCK_RESOURCE structure describing the resource, if available,
    or else NULL

    Note. The caller of the function should hold the database lock.

--*/
{
    PLIST_ENTRY ListHead;
    PLIST_ENTRY Current;
    PVI_DEADLOCK_RESOURCE Resource;

    ListHead = ViDeadlockDatabaseHash (ViDeadlockGlobals->ResourceDatabase, 
                                       ResourceAddress);    

    if (IsListEmpty (ListHead)) {
        return NULL;
    }

    //
    // Trim resources from this hash list. It has nothing to do with searching
    // but it is a good place to do this operation.
    //

    ViDeadlockTrimResources (ListHead);

    //
    // Now search the bucket for our resource.
    //

    Current = ListHead->Flink;

    while (Current != ListHead) {

        Resource = CONTAINING_RECORD(Current,
                                     VI_DEADLOCK_RESOURCE,
                                     HashChainList);

        if (Resource->ResourceAddress == ResourceAddress) {          
                        
            return Resource;
        }

        Current = Current->Flink;
    }

    return NULL;
}


BOOLEAN
VfDeadlockInitializeResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type,
    IN PVOID Caller,
    IN BOOLEAN DoNotAcquireLock
    )
/*++

Routine Description:

    This routine adds an entry for a new resource to our deadlock detection
    database.

Arguments:

    Resource: Address of the resource in question as used by the kernel.

    Type: Type of the resource.
    
    Caller: address of the caller
    
    DoNotAcquireLock: if true it means the call is done internally and the
        deadlock verifier lock is already held.

Return Value:

    True if we created and initialized a new RESOURCE structure.

--*/
{
    PVOID ReservedResource;
    BOOLEAN Result;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER (DoNotAcquireLock);

    //
    // If we are not initialized or package is not enabled
    // we return immediately.
    //

    if (! ViDeadlockCanProceed(Resource, Caller, Type)) {
        return FALSE;
    }

    ReservedResource = ViDeadlockAllocate (ViDeadlockResource);

    ViDeadlockDetectionLock (&OldIrql);

    Result = ViDeadlockAddResource (Resource,
                                    Type,
                                    Caller,
                                    ReservedResource);

    ViDeadlockDetectionUnlock (OldIrql);
    return Result;
}

 
BOOLEAN
ViDeadlockAddResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type,
    IN PVOID Caller,
    IN PVOID ReservedResource
    )
/*++

Routine Description:

    This routine adds an entry for a new resource to our deadlock detection
    database.

Arguments:

    Resource: Address of the resource in question as used by the kernel.

    Type: Type of the resource.
    
    Caller: address of the caller
    
    ReservedResource: block of memory to be used by the new resource.        

Return Value:

    True if we created and initialized a new RESOURCE structure.

--*/
{
    PLIST_ENTRY HashBin;
    PVI_DEADLOCK_RESOURCE ResourceRoot;
    PKTHREAD Thread;
    ULONG HashValue;
    ULONG DeadlockFlags;
    BOOLEAN ReturnValue = FALSE;

    //
    // Check if this resource was initialized before.
    // This would be a bug in most of the cases.
    //

    ResourceRoot = ViDeadlockSearchResource (Resource);

    if (ResourceRoot) {        

        DeadlockFlags = ViDeadlockResourceTypeInfo[Type];
        
        //
        // Check if we are reinitializing a good resource. This is a valid 
        // operation (although weird) only for spinlocks. Some drivers do that.
        //
        // silviuc: should we enforce here for the resource to be released first?
        //
        
        if(! (DeadlockFlags & VI_DEADLOCK_FLAG_REINITIALIZE_OK)) {            

            ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION,
                                   (ULONG_PTR)Resource,
                                   (ULONG_PTR)ResourceRoot,
                                   0);
        }

        //
        // Well, the resource has just been reinitialized. We will live with 
        // that. We will break though if we reinitialize a resource that is
        // acquired. In principle this state might be bogus if we missed 
        // a release() operation.
        //

        if (ResourceRoot->ThreadOwner != NULL) {
            
            ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION,
                                   (ULONG_PTR)Resource,
                                   (ULONG_PTR)ResourceRoot,
                                   1);
        }

        ReturnValue = TRUE;
        goto Exit;
    }

    //
    // At this point we know for sure the resource is not represented in the
    // deadlock verifier database.
    //

    ASSERT (ViDeadlockSearchResource (Resource) == NULL);

    Thread = KeGetCurrentThread();

    //
    // Check to see if the resource is on the stack. 
    // If it is we will not verify it.
    //
    // SilviuC: what about the DPC stack ? We will ignore this issue for now.
    //

    if ((ULONG_PTR) Resource < (ULONG_PTR) Thread->InitialStack &&
        (ULONG_PTR) Resource > (ULONG_PTR) Thread->StackLimit ) {

        ReturnValue = FALSE;
        goto Exit;
    }

    //
    // Use reserved memory for the new resource.
    // Set ReservedResource to null to signal that memory has 
    // been used. This will prevent freeing it at the end.
    //

    ResourceRoot = ReservedResource;
    ReservedResource = NULL;

    if (ResourceRoot == NULL) {
        
        ReturnValue = FALSE;
        goto Exit;
    }
    
    //
    // Fill information about resource.
    //

    RtlZeroMemory (ResourceRoot, sizeof(VI_DEADLOCK_RESOURCE));

    ResourceRoot->Type = Type;
    ResourceRoot->ResourceAddress = Resource;

    InitializeListHead (&ResourceRoot->ResourceList);

    //
    // Capture the stack trace of the guy that creates the resource first.
    // This should happen when resource gets initialized or during the first
    // acquire.
    //    

    RtlCaptureStackBackTrace (2,
                              VI_MAX_STACK_DEPTH,
                              ResourceRoot->StackTrace,
                              &HashValue);    

    ResourceRoot->StackTrace[0] = Caller;
    
    //
    // Figure out which hash bin this resource corresponds to.
    //

    HashBin = ViDeadlockDatabaseHash (ViDeadlockGlobals->ResourceDatabase, Resource);
    
    //
    // Now add to the corrsponding hash bin
    //

    InsertHeadList(HashBin, &ResourceRoot->HashChainList);

    ReturnValue = TRUE;

    Exit:

    if (ReservedResource) {
        ViDeadlockFree (ReservedResource, ViDeadlockResource);
    }
    
    return ReturnValue;
}


BOOLEAN
ViDeadlockSimilarNode (
    IN PVOID Resource,
    IN BOOLEAN TryNode,
    IN PVI_DEADLOCK_NODE Node
    )
/*++

Routine description:

    This routine determines if an acquisition with the (resource, try)
    characteristics is already represented in the Node parameter.
    
    We used to match nodes based on (resource, thread, stack trace, try)
    4-tuplet but this really causes an explosion in the number of nodes.
    Such a method would yield more accurate proofs but does not affect
    the correctness of the deadlock detection algorithms.
        
Return value:    

    True if similar node.
    
 --*/
{
    ASSERT (Node);
    ASSERT (Node->Root);

    if (Resource == Node->Root->ResourceAddress 
        && TryNode == Node->OnlyTryAcquireUsed) {

        //
        // Second condition is important to keep nodes for TryAcquire operations
        // separated from normal acquires. A TryAcquire cannot cause a deadlock
        // and therefore we have to be careful not to report bogus deadlocks.
        //

        return TRUE;
    }
    else {

        return FALSE;
    }
}


VOID
VfDeadlockAcquireResource( 
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type,
    IN PKTHREAD Thread,
    IN BOOLEAN TryAcquire,
    IN PVOID Caller
    )
/*++

Routine Description:

    This routine makes sure that it is ok to acquire the resource without
    causing a deadlock. It will also update the resource graph with the new
    resource acquisition.

Arguments:

    Resource: Address of the resource in question as used by kernel.

    Type: Type of the resource.
    
    Thread: thread attempting to acquire the resource
    
    TryAcquire: true if this is a tryacquire() operation
    
    Caller: address of the caller

Return Value:

    None.

--*/
{
    PKTHREAD CurrentThread;
    PVI_DEADLOCK_THREAD ThreadEntry;
    KIRQL OldIrql = 0;
    PVI_DEADLOCK_NODE CurrentNode;
    PVI_DEADLOCK_NODE NewNode;
    PVI_DEADLOCK_RESOURCE ResourceRoot;
    PLIST_ENTRY Current;
    ULONG HashValue;
    ULONG DeadlockFlags;
    BOOLEAN CreatingRootNode = FALSE;
    BOOLEAN ThreadCreated = FALSE;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;
    BOOLEAN AddResult;
    PVOID ReservedThread;
    PVOID ReservedNode;
    PVOID ReservedResource;
    PVI_DEADLOCK_NODE ThreadCurrentNode;

    CurrentNode = NULL;
    ThreadEntry = NULL;
    ThreadCurrentNode = NULL;

    //
    // If we are not initialized or package is not enabled
    // we return immediately.
    //

    if (! ViDeadlockCanProceed(Resource, Caller, Type)) {
        return;
    }

    //
    // Skip if the current thread is inside paging code paths.
    //

    if (ViIsThreadInsidePagingCodePaths ()) {
        return;
    }

    CurrentThread = Thread;

    DeadlockFlags = ViDeadlockResourceTypeInfo[Type];

    //
    // Before getting into the real stuff trim the pool cache.
    // This needs to happen out of any locks.
    //

    ViDeadlockTrimPoolCache ();

    //
    // Reserve resources that might be needed. If upon exit these
    // variables are null it means the allocation either failed or was used.
    // In both cases we do not need to free anything.
    //

    ReservedThread = ViDeadlockAllocate (ViDeadlockThread);
    ReservedNode = ViDeadlockAllocate (ViDeadlockNode);
    ReservedResource = ViDeadlockAllocate (ViDeadlockResource);

    //
    // Lock the deadlock database.
    //

    ViDeadlockDetectionLock( &OldIrql );

    KeQueryTickCount (&StartTime);

    //
    // Allocate a node that might be needed. If we will not use it
    // we will deallocate it at the end. If we fail to allocate
    // we will return immediately.
    //
    
    NewNode = ReservedNode;
    ReservedNode = NULL;

    if (NewNode == NULL) {
        goto Exit;
    }

    //
    // Find the thread descriptor. If there is none we will create one.
    //

    ThreadEntry = ViDeadlockSearchThread (CurrentThread);        

    if (ThreadEntry == NULL) {

        ThreadEntry = ViDeadlockAddThread (CurrentThread, ReservedThread);
        ReservedThread = NULL;

        if (ThreadEntry == NULL) {

            //
            // If we cannot allocate a new thread entry then
            // no deadlock detection will happen.
            //

            goto Exit;
        }

        ThreadCreated = TRUE;
    }

#if DBG
    if (Type == VfDeadlockSpinLock) {
        
        if (ThreadEntry->CurrentSpinNode != NULL) {

            ASSERT(ThreadEntry->CurrentSpinNode->Root->ThreadOwner == ThreadEntry);
            ASSERT(ThreadEntry->CurrentSpinNode->ThreadEntry == ThreadEntry);
            ASSERT(ThreadEntry->NodeCount != 0);
            ASSERT(ThreadEntry->CurrentSpinNode->Active != 0);
            ASSERT(ThreadEntry->CurrentSpinNode->Root->NodeCount != 0);

        } 
    }
    else {

        if (ThreadEntry->CurrentOtherNode != NULL) {

            ASSERT(ThreadEntry->CurrentOtherNode->Root->ThreadOwner == ThreadEntry);
            ASSERT(ThreadEntry->CurrentOtherNode->ThreadEntry == ThreadEntry);
            ASSERT(ThreadEntry->NodeCount != 0);
            ASSERT(ThreadEntry->CurrentOtherNode->Active != 0);
            ASSERT(ThreadEntry->CurrentOtherNode->Root->NodeCount != 0);

        } 
    }
#endif

    //
    // Find the resource descriptor. If we do not find a descriptor
    // we will create one on the fly.
    //

    ResourceRoot = ViDeadlockSearchResource (Resource);

    if (ResourceRoot == NULL) {

        //
        // Could not find the resource descriptor therefore we need to create one.
        // Note that we will not complain about the resource not being initialized
        // before because there are legitimate reasons for this to happen. For 
        // example the resource was initialized in an unverified driver and then
        // passed to a verified driver that caled acquire().
        //

        if (ViDeadlockVeryStrict) {

            ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_UNINITIALIZED_RESOURCE,
                                   (ULONG_PTR) Resource,
                                   (ULONG_PTR) NULL,
                                   (ULONG_PTR) NULL);
        }

        AddResult = ViDeadlockAddResource (Resource, 
                                           Type, 
                                           Caller, 
                                           ReservedResource);

        ReservedResource = NULL;

        if (AddResult == FALSE) {

            //
            // If we failed to add the resource then no deadlock detection.
            //

            if (ThreadCreated) {                    
                ViDeadlockDeleteThread (ThreadEntry, FALSE);
            }

            goto Exit;
        }

        //
        // Search again the resource. This time we should find it.
        //

        ResourceRoot = ViDeadlockSearchResource (Resource);
    }
    
    //
    // At this point we have a THREAD and a RESOURCE to play with.
    // In addition we are just about to acquire the resource which means
    // there should not be another thread owning unless it is a recursive
    // acquisition.
    //

    ASSERT (ResourceRoot);
    ASSERT (ThreadEntry); 

    if (Type == VfDeadlockSpinLock) {
        ThreadCurrentNode = ThreadEntry->CurrentSpinNode;
    }
    else {
        ThreadCurrentNode = ThreadEntry->CurrentOtherNode;
    }

    //
    // Since we just acquired the resource the valid value for ThreadOwner is
    // null or ThreadEntry (for a recursive acquisition). This might not be
    // true if we missed a release() from an unverified driver. So we will
    // not complain about it. We will just put the resource in a consistent
    // state and continue;
    //    

    if (ResourceRoot->ThreadOwner) {
        if (ResourceRoot->ThreadOwner != ThreadEntry) {
            ResourceRoot->RecursionCount = 0;
        }
        else {
            ASSERT (ResourceRoot->RecursionCount > 0);
        }
    }
    else {
        ASSERT (ResourceRoot->RecursionCount == 0);
    }

    ResourceRoot->ThreadOwner = ThreadEntry;    
    ResourceRoot->RecursionCount += 1;

    //
    // Check if thread holds any resources. If it does we will have to determine
    // at that local point in the dependency graph if we need to create a
    // new node. If this is the first resource acquired by the thread we need
    // to create a new root node or reuse one created in the past.
    //    

    if (ThreadCurrentNode != NULL) {

        //
        // If we get here, the current thread had already acquired resources.        
        // Check to see if this resource has already been acquired.
        // 

        if (ResourceRoot->RecursionCount > 1) {

            //
            // Recursive acquisition is OK for some resources...
            //
            
            if ((DeadlockFlags & VI_DEADLOCK_FLAG_RECURSIVE_ACQUISITION_OK) != 0) {            

                //
                // Recursion can't cause a deadlock. Don't set CurrentNode 
                // since we don't want to move any pointers.
                //

                goto Exit;

            } else {

                //
                // This is a recursive acquire for a resource type that is not allowed
                // to acquire recursively. Note on continuing from here: we have a recursion
                // count of two which will come in handy when the resources are released.
                //

                ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_SELF_DEADLOCK,
                                       (ULONG_PTR)Resource,
                                       (ULONG_PTR)ResourceRoot,
                                       (ULONG_PTR)ThreadEntry);

                goto Exit;
            }
        }

        //
        // If link already exists, update pointers and exit.
        // otherwise check for deadlocks and create a new node        
        //

        Current = ThreadCurrentNode->ChildrenList.Flink;

        while (Current != &(ThreadCurrentNode->ChildrenList)) {

            CurrentNode = CONTAINING_RECORD (Current,
                                             VI_DEADLOCK_NODE,
                                             SiblingsList);

            Current = Current->Flink;

            if (ViDeadlockSimilarNode (Resource, TryAcquire, CurrentNode)) {

                //
                // We have found a link. A link that already exists doesn't have 
                // to be checked for a deadlock because it would have been caught 
                // when the link was created in the first place. We can just update 
                // the pointers to reflect the new resource acquired and exit.
                //
                // We apply our graph compression function to minimize duplicates.
                //                
                
                ViDeadlockCheckDuplicatesAmongChildren (ThreadCurrentNode,
                                                        CurrentNode);

                goto Exit;
            }
        }

        //
        // Now we know that we're in it for the long haul. We must create a new
        // link and make sure that it doesn't cause a deadlock. Later in the 
        // function CurrentNode being null will signify that we need to create
        // a new node.
        //

        CurrentNode = NULL;

        //
        // We will analyze deadlock if the resource just about to be acquired
        // was acquired before and there are nodes in the graph for the
        // resource. Try acquire can not be the cause of a deadlock. 
        // Don't analyze on try acquires.
        //

        if (ResourceRoot->NodeCount > 0 && TryAcquire == FALSE) {

            if (ViDeadlockAnalyze (Resource,  ThreadCurrentNode, TRUE, 0)) {

                //
                // If we are here we detected deadlock. The analyze() function
                // does all the reporting. Being here means we hit `g' in the 
                // debugger. We will just exit and do not add this resource 
                // to the graph.
                //

                goto Exit;
            }
        }
    }
    else {

        //
        // Thread does not have any resources acquired. We have to figure out
        // if this is a scenario we have encountered in the past by looking
        // at all nodes (that are roots) for the resource to be acquired.
        // Note that all this is bookkeeping but we cannot encounter a deadlock
        // from now on.
        //

        PLIST_ENTRY CurrentListEntry;
        PVI_DEADLOCK_NODE Node = NULL;
        BOOLEAN FoundNode = FALSE;

        CurrentListEntry = ResourceRoot->ResourceList.Flink;

        while (CurrentListEntry != &(ResourceRoot->ResourceList)) {

            Node = CONTAINING_RECORD (CurrentListEntry,
                                      VI_DEADLOCK_NODE,
                                      ResourceList);

            CurrentListEntry = Node->ResourceList.Flink;

            if (Node->Parent == NULL) {

                if (ViDeadlockSimilarNode (Resource, TryAcquire, Node)) {

                    //
                    // We apply our graph compression function to minimize duplicates.
                    //

                    ViDeadlockCheckDuplicatesAmongRoots (Node);

                    FoundNode = TRUE;
                    break;
                }
            }
        }

        if (FoundNode) {

            CurrentNode = Node;

            goto Exit;
        }
        else {

            CreatingRootNode = TRUE;
        }
    }

    //
    // At this moment we know for sure the new link will not cause
    // a deadlock. We will create the new resource node.
    //
    
    if (NewNode != NULL) {

        CurrentNode = NewNode;

        //
        // Set newnode to NULL to signify it has been used -- otherwise it 
        // will get freed at the end of this function.
        //
        
        NewNode = NULL;

        //
        // Initialize the new resource node
        //

        RtlZeroMemory (CurrentNode, sizeof *CurrentNode);
        
        CurrentNode->Active = 0;
        CurrentNode->Parent = ThreadCurrentNode;
        CurrentNode->Root = ResourceRoot;
        CurrentNode->SequenceNumber = ViDeadlockGlobals->SequenceNumber;

        InitializeListHead (&(CurrentNode->ChildrenList));

        //
        // Mark the TryAcquire type of the node. 
        //

        CurrentNode->OnlyTryAcquireUsed = TryAcquire;

        //
        // Add to the children list of the parent.
        //

        if (! CreatingRootNode) {

            InsertHeadList(&(ThreadCurrentNode->ChildrenList),
                           &(CurrentNode->SiblingsList));
        }

        //
        // Register the new resource node in the list of nodes maintained
        // for this resource.
        //

        InsertHeadList(&(ResourceRoot->ResourceList),
                       &(CurrentNode->ResourceList));

        ResourceRoot->NodeCount += 1;

        if (ResourceRoot->NodeCount > 0xFFF0) {
            ViDeadlockState.ResourceNodeCountOverflow = 1;
        }

        //
        // Add to the graph statistics.
        //
#if DBG
        {
            ULONG Level;

            Level = ViDeadlockNodeLevel (CurrentNode);

            if (Level < 8) {
                ViDeadlockGlobals->GraphNodes[Level] += 1;
            }
        }
#endif
    }

    //
    //  Exit point.
    //

    Exit:

    //
    // Add information we use to identify the culprit should
    // a deadlock occur
    //

    if (CurrentNode) {

        ASSERT (ThreadEntry);
        ASSERT (ThreadCurrentNode == CurrentNode->Parent);

        CurrentNode->Active = 1;

        //
        // The node should have thread entry field null either because
        // it was newly created or because the node was released in the
        // past and therefore the field was zeroed.
        //
        // silviuc: true? What about if we miss release() operations.
        //

        ASSERT (CurrentNode->ThreadEntry == NULL);

        CurrentNode->ThreadEntry = ThreadEntry;

        if (Type == VfDeadlockSpinLock) {
            ThreadEntry->CurrentSpinNode = CurrentNode;
        }
        else {
            ThreadEntry->CurrentOtherNode = CurrentNode;
        }
        
        ThreadEntry->NodeCount += 1;

#if DBG
        if (ThreadEntry->NodeCount <= 8) {
            ViDeadlockGlobals->NodeLevelCounter[ThreadEntry->NodeCount - 1] += 1;
        }
        else {
            ViDeadlockGlobals->NodeLevelCounter[7] += 1;
        }
#endif

        //
        // If we have a parent, save the parent's stack trace
        //             
        
        if (CurrentNode->Parent) {

            RtlCopyMemory(CurrentNode->ParentStackTrace, 
                          CurrentNode->Parent->StackTrace, 
                          sizeof (CurrentNode->ParentStackTrace));
        }

        //
        // Capture stack trace for the current acquire. 
        //

        RtlCaptureStackBackTrace (2,
                                  VI_MAX_STACK_DEPTH,
                                  CurrentNode->StackTrace,
                                  &HashValue);

        if (CurrentNode->Parent) {
            CurrentNode->ParentStackTrace[0] = CurrentNode->Parent->StackTrace[0];
        }

        CurrentNode->StackTrace[0] = Caller;

        //
        // Copy the trace for the last acquire in the resource object.
        //

        RtlCopyMemory (CurrentNode->Root->LastAcquireTrace,
                       CurrentNode->StackTrace,
                       sizeof (CurrentNode->Root->LastAcquireTrace));
    }

    //
    // We allocated space for a new node but it didn't get used -- put it back 
    // in the list (don't worry this doesn't do a real 'free' it just puts it 
    // in a free list).
    //

    if (NewNode != NULL) {

        ViDeadlockFree (NewNode, ViDeadlockNode);
    }
    
    //
    // Release deadlock database and return.
    //

    KeQueryTickCount (&EndTime);

    if (EndTime.QuadPart - StartTime.QuadPart > ViDeadlockGlobals->TimeAcquire) {
        ViDeadlockGlobals->TimeAcquire = EndTime.QuadPart - StartTime.QuadPart;
    }

    //
    // Free up unused reserved resources
    //

    if (ReservedResource) {
        ViDeadlockFree (ReservedResource, ViDeadlockResource);
    }

    if (ReservedNode) {
        ViDeadlockFree (ReservedNode, ViDeadlockNode);
    }

    if (ReservedThread) {
        ViDeadlockFree (ReservedThread, ViDeadlockThread);
    }

    ViDeadlockDetectionUnlock( OldIrql );

    return;
}


VOID
VfDeadlockReleaseResource( 
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type,
    IN PKTHREAD Thread,
    IN PVOID Caller
    )
/*++

Routine Description:

    This routine does the maintenance necessary to release resources from our
    deadlock detection database.

Arguments:

    Resource: Address of the resource in question.
    
    Thread: thread releasing the resource. In most of the cases this is the
        current thread but it might be different for resources that can be
        acquired in one thread and released in another one.
    
    Caller: address of the caller of release()

Return Value:

    None.
--*/

{
    PKTHREAD CurrentThread;
    PVI_DEADLOCK_THREAD ThreadEntry;
    KIRQL OldIrql = 0;
    PVI_DEADLOCK_RESOURCE ResourceRoot;
    PVI_DEADLOCK_NODE ReleasedNode;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;
    ULONG HashValue;
    PVI_DEADLOCK_NODE ThreadCurrentNode;
    ULONG DeadlockFlags;
    LOGICAL ReleasedByAnotherThread;

    UNREFERENCED_PARAMETER (Caller);

    DeadlockFlags = ViDeadlockResourceTypeInfo[Type];
    ReleasedByAnotherThread = FALSE;

    //
    // If we aren't initialized or package is not enabled
    // we return immediately.
    //

    if (! ViDeadlockCanProceed(Resource, Caller, Type)) {
        return;
    }

    //
    // Skip if the current thread is inside paging code paths.
    //

    if (ViIsThreadInsidePagingCodePaths ()) {
        return;
    }

    ReleasedNode = NULL;
    CurrentThread = Thread;
    ThreadEntry = NULL;

    ViDeadlockDetectionLock( &OldIrql );

    KeQueryTickCount (&StartTime);

    ResourceRoot = ViDeadlockSearchResource (Resource);

    if (ResourceRoot == NULL) {

        //
        // Release called with a resource address that was never
        // stored in our resource database. This can happen in
        // the following circumstances:
        //
        // (a) resource is released but we never seen it before 
        //     because it was acquired in an unverified driver.
        //
        // (b) we have encountered allocation failures that prevented
        //     us from completing an acquire() or initialize().
        //
        // All are legitimate cases and therefore we just ignore the
        // release operation.
        //

        goto Exit;
    }

    //
    // Check if we are trying to release a resource that was never
    // acquired.
    //

    if (ResourceRoot->RecursionCount == 0) {
    
        ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_UNACQUIRED_RESOURCE,
                               (ULONG_PTR)Resource,
                               (ULONG_PTR)ResourceRoot,
                               (ULONG_PTR)ViDeadlockSearchThread(CurrentThread));
        goto Exit;
    }    

    //
    // Look for this thread in our thread list. Note we are looking actually 
    // for the thread that acquired the resource -- not the current one
    // It should, in fact be the current one, but if the resource is being released 
    // in a different thread from the one it was acquired in, we need the original.
    //

    ASSERT (ResourceRoot->RecursionCount > 0);
    ASSERT (ResourceRoot->ThreadOwner);

    ThreadEntry = ResourceRoot->ThreadOwner;

    if (ThreadEntry->Thread != CurrentThread) {

        //
        // Someone acquired a resource that is released in another thread.
        // This is bad design but we have to live with it.
        // However if this occurs, we may call a non-deadlock a deadlock.
        // For example, we see a simple deadlock -- AB BA
        // If another thread releases B, there won't actually
        // be a deadlock. Kind of annoying and ugly. This can be 
        // avoided by setting to one the ReleasedOutOfOrder bit in the
        // NODE structure. This way we will ignore it while looking for cycles. 
        // This happens later in the function when we get a node to work with.
        //

#if DBG
        if ((DeadlockFlags & VI_DEADLOCK_FLAG_RELEASE_DIFFERENT_THREAD_OK) == 0) {
            
            DbgPrint("Thread %p acquired resource %p but thread %p released it\n",
                ThreadEntry->Thread, Resource, CurrentThread );

            ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_UNEXPECTED_THREAD,
                                   (ULONG_PTR)Resource,
                                   (ULONG_PTR)ThreadEntry->Thread,
                                   (ULONG_PTR)CurrentThread);
        }
#endif

        //
        // If we don't want this to be fatal, in order to
        // continue we must pretend that the current
        // thread is the resource's owner.
        //
        
        CurrentThread = ThreadEntry->Thread;
        ReleasedByAnotherThread = TRUE;
    }
    
    //
    // In this moment we have a resource (ResourceRoot) and a
    // thread (ThreadEntry) to play with.
    //

    ASSERT (ResourceRoot && ThreadEntry);

    if (ResourceRoot->Type == VfDeadlockSpinLock) {
        ThreadCurrentNode = ThreadEntry->CurrentSpinNode;
    }
    else {
        ThreadCurrentNode = ThreadEntry->CurrentOtherNode;
    }

    ASSERT (ThreadCurrentNode);
    ASSERT (ThreadCurrentNode->Root);
    ASSERT (ThreadEntry->NodeCount > 0);

    ResourceRoot->RecursionCount -= 1;
    
    if (ResourceRoot->RecursionCount > 0) {

        //
        // Just decrement the recursion count and do not change any state
        //        

        goto Exit;
    }

    //
    // Wipe out the resource owner.
    //
    
    ResourceRoot->ThreadOwner = NULL;
  
    ViDeadlockGlobals->TotalReleases += 1;
        
    //
    // Check for out of order releases
    //

    if (ThreadCurrentNode->Root != ResourceRoot) {

        ViDeadlockGlobals->OutOfOrderReleases += 1;
        
        //
        // Getting here means that somebody acquires a then b then tries
        // to release a before b. This is bad for certain kinds of resources,
        // and for others we have to look the other way.
        //

        if ((ViDeadlockResourceTypeInfo[ThreadCurrentNode->Root->Type] &
            VI_DEADLOCK_FLAG_REVERSE_RELEASE_OK) == 0) {
            
            DbgPrint("Deadlock detection: Must release resources in reverse-order\n");
            DbgPrint("Resource %p acquired before resource %p -- \n"
                     "Current thread (%p) is trying to release it first\n",
                     Resource,
                     ThreadCurrentNode->Root->ResourceAddress,
                     ThreadEntry);

            ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_UNEXPECTED_RELEASE,
                                   (ULONG_PTR)Resource,
                                   (ULONG_PTR)ThreadCurrentNode->Root->ResourceAddress,
                                   (ULONG_PTR)ThreadEntry);
        }

        //
        // We need to mark the node for the out of order released resource as
        // not active so that other threads will be able to acquire it.
        //

        {
            PVI_DEADLOCK_NODE Current;

            ASSERT (ThreadCurrentNode->Active == 1);
            ASSERT (ThreadCurrentNode->ThreadEntry == ThreadEntry);

            Current = ThreadCurrentNode;

            while (Current != NULL) {

                if (Current->Root == ResourceRoot) {

                    ASSERT (Current->Active == 1);
                    ASSERT (Current->Root->RecursionCount == 0);
                    ASSERT (Current->ThreadEntry == ThreadEntry);

                    Current->Active = 0;
                    ReleasedNode = Current;
                    
                    break;
                }

                Current = Current->Parent;
            }
            
            if (Current == NULL) {
                
                //
                // If we do not manage to find an active node we must be in an
                // weird state. The resource must be here or else we would have 
                // gotten an `unexpected release' bugcheck.
                //

                ASSERT (0);
            }
            else {

                //
                // Mark the fact that this node represents a resource
                // that can be released out of order. This information is
                // important while looking for cycles because this type of
                // nodes cannot cause a deadlock.
                //

                if (Current->ReleasedOutOfOrder == 0) {
                    ViDeadlockGlobals->NodesReleasedOutOfOrder += 1;
                }

                Current->ReleasedOutOfOrder = 1;
            }
        }

    } else {

        //
        // We need to release the top node held by the thread.
        //

        ASSERT (ThreadCurrentNode->Active);

        ReleasedNode = ThreadCurrentNode;
        ReleasedNode->Active = 0;
    }

    //
    // Put the `CurrentNode' field of the thread in a consistent state.
    // It should point to the most recent active node that it owns.
    //

    if (ResourceRoot->Type == VfDeadlockSpinLock) {
        
        while (ThreadEntry->CurrentSpinNode) {

            if (ThreadEntry->CurrentSpinNode->Active == 1) {
                if (ThreadEntry->CurrentSpinNode->ThreadEntry == ThreadEntry) {
                    break;
                }
            }

            ThreadEntry->CurrentSpinNode = ThreadEntry->CurrentSpinNode->Parent;
        }
    }
    else {
        
        while (ThreadEntry->CurrentOtherNode) {

            if (ThreadEntry->CurrentOtherNode->Active == 1) {
                if (ThreadEntry->CurrentOtherNode->ThreadEntry == ThreadEntry) {
                    break;
                }
            }

            ThreadEntry->CurrentOtherNode = ThreadEntry->CurrentOtherNode->Parent;
        }
    }

    Exit:

    //
    // Properly release the node if there is one to be released.
    //

    if (ReleasedNode) {

        ASSERT (ReleasedNode->Active == 0);
        ASSERT (ReleasedNode->Root->ThreadOwner == 0);
        ASSERT (ReleasedNode->Root->RecursionCount == 0);
        ASSERT (ReleasedNode->ThreadEntry == ThreadEntry);
        ASSERT (ThreadEntry->NodeCount > 0);
        
        if (ResourceRoot->Type == VfDeadlockSpinLock) {
            ASSERT (ThreadEntry->CurrentSpinNode != ReleasedNode);
        }
        else {
            ASSERT (ThreadEntry->CurrentOtherNode != ReleasedNode);
        }

        ReleasedNode->ThreadEntry = NULL;
        ThreadEntry->NodeCount -= 1;

        //
        // Mark the node to be released if released by a different thread
        // as released out of order so that it will be ignored by 
        // the cycle finding algorithm
        //

        if (ReleasedByAnotherThread) {
           ReleasedNode->ReleasedOutOfOrder = 1;
        }

#if DBG
        ViDeadlockCheckNodeConsistency (ReleasedNode, FALSE);
        ViDeadlockCheckResourceConsistency (ReleasedNode->Root, FALSE);
        ViDeadlockCheckThreadConsistency (ThreadEntry, FALSE);
#endif

        if (ThreadEntry && ThreadEntry->NodeCount == 0) {
            ViDeadlockDeleteThread (ThreadEntry, FALSE);
        }

        //
        // N.B. Since this is a root node with no children we can delete 
        // the node too. This would be important to keep memory low. A single node
        // can never be the cause of a deadlock. However there are thousands of 
        // resources used like this and constantly creating and deleting them
        // will create a bottleneck. So we prefer to keep them around.
        //
#if 0
        if (ReleasedNode->Parent == NULL && IsListEmpty(&(ReleasedNode->ChildrenList))) {
            ViDeadlockDeleteNode (ReleasedNode, FALSE);
            ViDeadlockGlobals->RootNodesDeleted += 1;
        }
#endif
    }

    //
    // Capture the trace for the last release in the resource object.
    //

    if (ResourceRoot) {
        
        RtlCaptureStackBackTrace (2,
                                  VI_MAX_STACK_DEPTH,
                                  ResourceRoot->LastReleaseTrace,
                                  &HashValue);    
    }

    KeQueryTickCount (&EndTime);

    if (EndTime.QuadPart - StartTime.QuadPart > ViDeadlockGlobals->TimeRelease) {
        ViDeadlockGlobals->TimeRelease = EndTime.QuadPart - StartTime.QuadPart;
    }

    ViDeadlockDetectionUnlock (OldIrql);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Thread management
/////////////////////////////////////////////////////////////////////

PVI_DEADLOCK_THREAD
ViDeadlockSearchThread (
    PKTHREAD Thread
    )
/*++

Routine Description:

    This routine searches for a thread in the thread database.

    The function assumes the deadlock database lock is held.

Arguments:

    Thread - thread address

Return Value:

    Address of VI_DEADLOCK_THREAD structure if thread was found.
    Null otherwise.

--*/
{
    PLIST_ENTRY Current;
    PLIST_ENTRY ListHead;
    PVI_DEADLOCK_THREAD ThreadInfo;

    ThreadInfo = NULL;
        
    ListHead = ViDeadlockDatabaseHash (ViDeadlockGlobals->ThreadDatabase, Thread);

    if (IsListEmpty(ListHead)) {
        return NULL;
    }
    
    Current = ListHead->Flink;
    
    while (Current != ListHead) {

        ThreadInfo = CONTAINING_RECORD (Current,
                                        VI_DEADLOCK_THREAD,
                                        ListEntry);

        if (ThreadInfo->Thread == Thread) {            
            return ThreadInfo;
        }

        Current = Current->Flink;
    }

    return NULL;
}


PVI_DEADLOCK_THREAD
ViDeadlockAddThread (
    PKTHREAD Thread,
    PVOID ReservedThread
    )
/*++

Routine Description:

    This routine adds a new thread to the thread database.

    The function assumes the deadlock database lock is held. 

Arguments:

    Thread - thread address

Return Value:

    Address of the VI_DEADLOCK_THREAD structure just added.
    Null if allocation failed.
--*/
{
    PVI_DEADLOCK_THREAD ThreadInfo;    
    PLIST_ENTRY HashBin;

    ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread());
    
    //
    // Use reserved block for the new thread. Set ReservedThread
    // to null to signal that block was used. 
    //

    ThreadInfo = ReservedThread;
    ReservedThread = NULL;

    if (ThreadInfo == NULL) {
        return NULL;
    }

    RtlZeroMemory (ThreadInfo, sizeof *ThreadInfo);

    ThreadInfo->Thread = Thread;   
            
    HashBin = ViDeadlockDatabaseHash (ViDeadlockGlobals->ThreadDatabase, Thread);
    
    InsertHeadList(HashBin, &ThreadInfo->ListEntry);

    return ThreadInfo;
}


VOID
ViDeadlockDeleteThread (
    PVI_DEADLOCK_THREAD Thread,
    BOOLEAN Cleanup
    )
/*++

Routine Description:

    This routine deletes a thread.

Arguments:

    Thread - thread address

    Cleanup - true if this is a call generated from DeadlockDetectionCleanup().

Return Value:

    None.
--*/
{
    if (Cleanup == FALSE) {
        
        ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread());

        if (Thread->NodeCount != 0 
            || Thread->CurrentSpinNode != NULL
            || Thread->CurrentOtherNode != NULL) {
            
            //
            // A thread should not be deleted while it has resources acquired.
            //

            ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES,
                                   (ULONG_PTR)(Thread->Thread),
                                   (ULONG_PTR)(Thread),
                                   (ULONG_PTR)0);    
        } else {
            
            ASSERT (Thread->NodeCount == 0);
        }
        
    }

    RemoveEntryList (&(Thread->ListEntry));

    ViDeadlockFree (Thread, ViDeadlockThread);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Allocate/Free
/////////////////////////////////////////////////////////////////////


PVOID
ViDeadlockAllocateFromPoolCache (
    PULONG Count,
    ULONG MaximumCount,
    PLIST_ENTRY List,
    SIZE_T Offset
    )
{
    PVOID Address = NULL;
    PLIST_ENTRY Entry;

    UNREFERENCED_PARAMETER (MaximumCount);
    
    if (*Count > 0) {
        
        *Count -= 1;
        Entry = RemoveHeadList (List);
        Address = (PVOID)((SIZE_T)Entry - Offset);
    }

    return Address;
}


VOID
ViDeadlockFreeIntoPoolCache (
    PVOID Object,
    PULONG Count,
    PLIST_ENTRY List,
    SIZE_T Offset
    )
{
    PLIST_ENTRY Entry;

    Entry = (PLIST_ENTRY)((SIZE_T)Object + Offset);
    
    *Count += 1;
    InsertHeadList(List, Entry);
}


PVOID
ViDeadlockAllocate (
    VI_DEADLOCK_ALLOC_TYPE Type
    )
/*++

Routine Description:

    This routine is used to allocate deadlock verifier structures, 
    that is nodes, resources and threads.

Arguments:

    Type - what structure do we need to allocate (node, resource or thread).

Return Value:

    Address of the newly allocate structure or null if allocation failed.

Side effects:

    If allocation fails the routine will bump the AllocationFailures field
    from ViDeadlockGlobals.
    
--*/
{
    PVOID Address = NULL;
    KIRQL OldIrql;
    SIZE_T Offset;
    SIZE_T Size = 0;

    //
    // If it is a resource, thread, or node alocation, see
    // if we have a pre-allocated one on the free list.
    //

    ViDeadlockDetectionLock (&OldIrql);

    switch (Type) {

        case ViDeadlockThread:

            Offset = (SIZE_T)(&(((PVI_DEADLOCK_THREAD)0)->FreeListEntry));
            Size = sizeof (VI_DEADLOCK_THREAD);

            Address = ViDeadlockAllocateFromPoolCache (&(ViDeadlockGlobals->FreeThreadCount),
                                                       VI_DEADLOCK_MAX_FREE_THREAD,
                                                       &(ViDeadlockGlobals->FreeThreadList),
                                                       Offset);

            break;

        case ViDeadlockResource:

            Offset = (SIZE_T)(&(((PVI_DEADLOCK_RESOURCE)0)->FreeListEntry));
            Size = sizeof (VI_DEADLOCK_RESOURCE);

            Address = ViDeadlockAllocateFromPoolCache (&(ViDeadlockGlobals->FreeResourceCount),
                                                       VI_DEADLOCK_MAX_FREE_RESOURCE,
                                                       &(ViDeadlockGlobals->FreeResourceList),
                                                       Offset);

            break;

        case ViDeadlockNode:

            Offset = (SIZE_T)(&(((PVI_DEADLOCK_NODE)0)->FreeListEntry));
            Size = sizeof (VI_DEADLOCK_NODE);

            Address = ViDeadlockAllocateFromPoolCache (&(ViDeadlockGlobals->FreeNodeCount),
                                                       VI_DEADLOCK_MAX_FREE_NODE,
                                                       &(ViDeadlockGlobals->FreeNodeList),
                                                       Offset);

            break;

        default:

            ASSERT (0);
            break;
    }        

    //
    // If we did not find anything and kernel verifier is not active 
    // then go to the kernel pool for a direct allocation. If kernel
    // verifier is enabled everything is preallocated and we never
    // call into the kernel pool.
    //

    if (Address == NULL && ViDeadlockState.KernelVerifierEnabled == 0) {

        ViDeadlockDetectionUnlock (OldIrql);
        Address = ExAllocatePoolWithTag(NonPagedPool, Size, VI_DEADLOCK_TAG);  
        ViDeadlockDetectionLock (&OldIrql);
    }

    if (Address) {

        switch (Type) {

            case ViDeadlockThread:
                ViDeadlockGlobals->Threads[0] += 1;

                if (ViDeadlockGlobals->Threads[0] > ViDeadlockGlobals->Threads[1]) {
                    ViDeadlockGlobals->Threads[1] = ViDeadlockGlobals->Threads[0];
                }
                break;

            case ViDeadlockResource:
                ViDeadlockGlobals->Resources[0] += 1;
                
                if (ViDeadlockGlobals->Resources[0] > ViDeadlockGlobals->Resources[1]) {
                    ViDeadlockGlobals->Resources[1] = ViDeadlockGlobals->Resources[0];
                }
                break;
        
            case ViDeadlockNode:
                ViDeadlockGlobals->Nodes[0] += 1;

                if (ViDeadlockGlobals->Nodes[0] > ViDeadlockGlobals->Nodes[1]) {
                    ViDeadlockGlobals->Nodes[1] = ViDeadlockGlobals->Nodes[0];
                }
                break;
        
            default:
                ASSERT (0);
                break;
        }
    }
    else {

        ViDeadlockState.AllocationFailures = 1;
        ViDeadlockGlobals->AllocationFailures += 1;

        //
        // Note that making the AllocationFailures counter bigger than zero
        // essentially disables deadlock verification because the CanProceed()
        // routine will start returning false.
        //
    }

    //
    // Update statistics. No need to zero the block since every
    // call site takes care of this.
    //

    if (Address) {

#if DBG
        RtlFillMemory (Address, Size, 0xFF);
#endif
        ViDeadlockGlobals->BytesAllocated += Size;
    }

    ViDeadlockDetectionUnlock (OldIrql);
    
    return Address;
}


VOID
ViDeadlockFree (
    PVOID Object,
    VI_DEADLOCK_ALLOC_TYPE Type
    )
/*++

Routine Description:

    This routine deallocates a deadlock verifier structure (node, resource
    or thread). The function will place the block in the corrsponding cache
    based on the type of the structure. The routine never calls ExFreePool.

    The reason for not calling ExFreePool is that we get notifications from 
    ExFreePool every time it gets called. Sometimes the notification comes
    with pool locks held and therefore we cannot call again.

Arguments:

    Object - block to deallocate
    
    Type - type of object (node, resource, thread).

Return Value:

    None.

--*/
//
// Note ... if a thread, node, or resource is being freed, we must not
// call ExFreePool. Since the pool lock may be already held, calling ExFreePool
// would cause a recursive spinlock acquisition (which is bad).
// Instead, we move everything to a 'free' list and try to reuse.
// Non-thread-node-resource frees get ExFreePooled
//
{
    SIZE_T Offset;
    SIZE_T Size = 0;

    switch (Type) {

        case ViDeadlockThread:

            ViDeadlockGlobals->Threads[0] -= 1;
            Size = sizeof (VI_DEADLOCK_THREAD);
            
            Offset = (SIZE_T)(&(((PVI_DEADLOCK_THREAD)0)->FreeListEntry));

            ViDeadlockFreeIntoPoolCache (Object,
                                         &(ViDeadlockGlobals->FreeThreadCount),
                                         &(ViDeadlockGlobals->FreeThreadList),
                                         Offset);
            break;

        case ViDeadlockResource:

            ViDeadlockGlobals->Resources[0] -= 1;
            Size = sizeof (VI_DEADLOCK_RESOURCE);
            
            Offset = (SIZE_T)(&(((PVI_DEADLOCK_RESOURCE)0)->FreeListEntry));

            ViDeadlockFreeIntoPoolCache (Object,
                                         &(ViDeadlockGlobals->FreeResourceCount),
                                         &(ViDeadlockGlobals->FreeResourceList),
                                         Offset);
            break;

        case ViDeadlockNode:

            ViDeadlockGlobals->Nodes[0] -= 1;
            Size = sizeof (VI_DEADLOCK_NODE);
            
            Offset = (SIZE_T)(&(((PVI_DEADLOCK_NODE)0)->FreeListEntry));

            ViDeadlockFreeIntoPoolCache (Object,
                                         &(ViDeadlockGlobals->FreeNodeCount),
                                         &(ViDeadlockGlobals->FreeNodeList),
                                         Offset);
            break;

        default:

            ASSERT (0);
            break;
    }        
    
    ViDeadlockGlobals->BytesAllocated -= Size;
}


VOID
ViDeadlockTrimPoolCache (
    VOID
    )
/*++

Routine Description:

    This function trims the pool caches to decent levels. It is carefully
    written to queue a work item to do the actual processing (freeing of pool)
    because the caller may hold various pool mutexes above us.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    if (ViDeadlockState.KernelVerifierEnabled == 1) {
        return;
    }

    ViDeadlockDetectionLock (&OldIrql);

    if (ViDeadlockGlobals->CacheReductionInProgress == TRUE) {
        ViDeadlockDetectionUnlock (OldIrql);
        return;
    }

    if ((ViDeadlockGlobals->FreeThreadCount > VI_DEADLOCK_MAX_FREE_THREAD) ||
        (ViDeadlockGlobals->FreeNodeCount > VI_DEADLOCK_MAX_FREE_NODE) ||
        (ViDeadlockGlobals->FreeResourceCount > VI_DEADLOCK_MAX_FREE_RESOURCE)){

        ExQueueWorkItem (&ViTrimDeadlockPoolWorkItem, DelayedWorkQueue);
        ViDeadlockGlobals->CacheReductionInProgress = TRUE;
        ViDeadlockGlobals->PoolTrimCounter += 1;
    }

    ViDeadlockDetectionUnlock (OldIrql);
    return;
}

VOID
ViDeadlockTrimPoolCacheWorker (
    PVOID Parameter
    )
/*++

Routine Description:

    This function trims the pool caches to decent levels. It is carefully
    written so that ExFreePool is called without holding any deadlock
    verifier locks.

Arguments:

    None.
    
Return Value:

    None.

Environment:

    Worker thread, PASSIVE_LEVEL, no locks held.

--*/
{
    LIST_ENTRY ListOfThreads;
    LIST_ENTRY ListOfNodes;
    LIST_ENTRY ListOfResources;
    KIRQL OldIrql;
    PLIST_ENTRY Entry;
    LOGICAL CacheReductionNeeded;

    UNREFERENCED_PARAMETER (Parameter);

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);

    CacheReductionNeeded = FALSE;

    InitializeListHead (&ListOfThreads);
    InitializeListHead (&ListOfNodes);
    InitializeListHead (&ListOfResources);

    ViDeadlockDetectionLock (&OldIrql);

    while (ViDeadlockGlobals->FreeThreadCount > VI_DEADLOCK_TRIM_TARGET_THREAD) {

        Entry = RemoveHeadList (&(ViDeadlockGlobals->FreeThreadList));
        InsertTailList (&ListOfThreads, Entry);
        ViDeadlockGlobals->FreeThreadCount -= 1;
        CacheReductionNeeded = TRUE;
    }

    while (ViDeadlockGlobals->FreeNodeCount > VI_DEADLOCK_TRIM_TARGET_NODE) {

        Entry = RemoveHeadList (&(ViDeadlockGlobals->FreeNodeList));
        InsertTailList (&ListOfNodes, Entry);
        ViDeadlockGlobals->FreeNodeCount -= 1;
        CacheReductionNeeded = TRUE;
    }

    while (ViDeadlockGlobals->FreeResourceCount > VI_DEADLOCK_TRIM_TARGET_RESOURCE) {

        Entry = RemoveHeadList (&(ViDeadlockGlobals->FreeResourceList));
        InsertTailList (&ListOfResources, Entry);
        ViDeadlockGlobals->FreeResourceCount -= 1;
        CacheReductionNeeded = TRUE;
    }

    //
    // Don't clear CacheReductionInProgress until the pool allocations are
    // freed to prevent needless recursion.
    //

    if (CacheReductionNeeded == FALSE) {
        ViDeadlockGlobals->CacheReductionInProgress = FALSE;
        ViDeadlockDetectionUnlock (OldIrql);
        return;
    }

    ViDeadlockDetectionUnlock (OldIrql);

    //
    // Now, out of the deadlock verifier lock we can deallocate the 
    // blocks trimmed.
    //

    Entry = ListOfThreads.Flink;

    while (Entry != &ListOfThreads) {

        PVI_DEADLOCK_THREAD Block;

        Block = CONTAINING_RECORD (Entry,
                                   VI_DEADLOCK_THREAD,
                                   FreeListEntry);

        Entry = Entry->Flink;
        ExFreePool (Block);
    }

    Entry = ListOfNodes.Flink;

    while (Entry != &ListOfNodes) {

        PVI_DEADLOCK_NODE Block;

        Block = CONTAINING_RECORD (Entry,
                                   VI_DEADLOCK_NODE,
                                   FreeListEntry);

        Entry = Entry->Flink;
        ExFreePool (Block);
    }

    Entry = ListOfResources.Flink;

    while (Entry != &ListOfResources) {

        PVI_DEADLOCK_RESOURCE Block;

        Block = CONTAINING_RECORD (Entry,
                                   VI_DEADLOCK_RESOURCE,
                                   FreeListEntry);

        Entry = Entry->Flink;
        ExFreePool (Block);
    }

    //
    // It's safe to clear CacheReductionInProgress now that the pool
    // allocations are freed.
    //

    ViDeadlockDetectionLock (&OldIrql);
    ViDeadlockGlobals->CacheReductionInProgress = FALSE;
    ViDeadlockDetectionUnlock (OldIrql);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Error reporting and debugging
/////////////////////////////////////////////////////////////////////

//
// Variable accessed by the !deadlock debug extension to investigate
// failures.
//

ULONG_PTR ViDeadlockIssue[4];

VOID
ViDeadlockReportIssue (
    ULONG_PTR Param1,
    ULONG_PTR Param2,
    ULONG_PTR Param3,
    ULONG_PTR Param4
    )
/*++

Routine Description:

    This routine is called to report a deadlock verifier issue.
    If we are in debug mode we will just break in debugger.
    Otherwise we will bugcheck,

Arguments:

    Param1..Param4 - relevant information for the point of failure.

Return Value:

    None.

--*/
{
    ViDeadlockIssue[0] = Param1;
    ViDeadlockIssue[1] = Param2;
    ViDeadlockIssue[2] = Param3;
    ViDeadlockIssue[3] = Param4;


    if (ViDeadlockDebug) {

        DbgPrint ("Verifier: deadlock: stop: %p %p %p %p %p \n",
                  DRIVER_VERIFIER_DETECTED_VIOLATION,
                  Param1,
                  Param2,
                  Param3,
                  Param4);

        DbgBreakPoint ();
    }
    else {

        KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                      Param1,
                      Param2,
                      Param3,
                      Param4);
    }

}


VOID
ViDeadlockAddParticipant(
    PVI_DEADLOCK_NODE Node
    )
/*++

Routine Description:

    Adds a new node to the set of nodes involved in a deadlock.
    The function is called only from ViDeadlockAnalyze().

Arguments:

    Node - node to be added to the deadlock participants collection.

Return Value:

    None.

--*/
{
    ULONG Index;

    Index = ViDeadlockGlobals->NumberOfParticipants;

    if (Index >= NO_OF_DEADLOCK_PARTICIPANTS) {

        ViDeadlockState.DeadlockParticipantsOverflow = 1;
        return;
    }

    ViDeadlockGlobals->Participant[Index] = Node;
    ViDeadlockGlobals->NumberOfParticipants += 1;
}


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// Resource cleanup
/////////////////////////////////////////////////////////////////////

VOID
VfDeadlockDeleteMemoryRange(
    IN PVOID Address,
    IN SIZE_T Size
    )
/*++

Routine Description:

    This routine is called whenever some region of kernel virtual space
    is no longer valid. We need this hook because most kernel resources
    do not have a "delete resource" function and we need to figure out
    what resources are not valid. Otherwise our dependency graph will
    become populated by many zombie resources.

    The important moments when the function gets called are ExFreePool
    (and friends) and driver unloading. Dynamic and static memory are the
    main regions where a resource gets allocated. There can be the possibility
    of a resource allocated on the stack but this is a very weird scenario.
    We might need to detect this and flag it as a potential issue.

    If a resource or thread lives within the range specified then all graph
    paths with nodes reachable from the resource or thread will be wiped out.

    NOTE ON OPTIMIZATION -- rather than having to search through all of the
    resources we've collected, we can make a simple optimization -- if we
    put the resources into hash bins based on PFN or the page address (i.e.
    page number for address 1A020 is 1A), we only have to look into a single
    hash bin for each page that the range spans. Worst case scenario is when
    we have an extremely long allocation, but even in this case we only look
    through each hash bin once.

Arguments:

    Address - start address of the range to be deleted.

    Size - size in bytes of the range to be deleted.

Return Value:

    None.

--*/
{
    ULONG SpanningPages;
    ULONG Index;
    ULONG_PTR Start;
    ULONG_PTR End;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY CurrentEntry;
    PVI_DEADLOCK_RESOURCE Resource;
    PVI_DEADLOCK_THREAD Thread;
    KIRQL OldIrql;

    //
    // If we are not initialized or package is not enabled
    // we return immediately.
    //

    if (! ViDeadlockCanProceed(NULL, NULL, VfDeadlockUnknown)) {
        return;
    }

    SpanningPages = (ULONG) ADDRESS_AND_SIZE_TO_SPAN_PAGES (Address, Size);

   
    if (SpanningPages > VI_DEADLOCK_HASH_BINS ) {
        SpanningPages = VI_DEADLOCK_HASH_BINS;        

    }

    Start = (ULONG_PTR) Address;    
    End = Start + (ULONG_PTR) Size;

    ViDeadlockDetectionLock(&OldIrql);

    //
    // Iterate all resources and delete the ones contained in the
    // memory range.
    //
    
    for (Index = 0; Index < SpanningPages; Index += 1) {
        
        //
        // See optimization note above for description of why we only look
        // in a single hash bin.
        //
        
        ListHead = ViDeadlockDatabaseHash (ViDeadlockGlobals->ResourceDatabase,
                                           (PVOID) (Start + Index * PAGE_SIZE));
        
        CurrentEntry = ListHead->Flink;

        while (CurrentEntry != ListHead) {

            Resource = CONTAINING_RECORD (CurrentEntry,
                                          VI_DEADLOCK_RESOURCE,
                                          HashChainList);

            CurrentEntry = CurrentEntry->Flink;

            if ((ULONG_PTR)(Resource->ResourceAddress) >= Start &&
                (ULONG_PTR)(Resource->ResourceAddress) < End) {

                ViDeadlockDeleteResource (Resource, FALSE);
            }
        }
    }    

    //
    // Iterate all threads and delete the ones contained in the
    // memory range.
    //
    
    for (Index = 0; Index < SpanningPages; Index += 1) {
        
        ListHead = ViDeadlockDatabaseHash (ViDeadlockGlobals->ThreadDatabase,
                                           (PVOID) (Start + Index * PAGE_SIZE));
        
        CurrentEntry = ListHead->Flink;

        while (CurrentEntry != ListHead) {

            Thread = CONTAINING_RECORD (CurrentEntry,
                                        VI_DEADLOCK_THREAD,
                                        ListEntry);

            CurrentEntry = CurrentEntry->Flink;

            if ((ULONG_PTR)(Thread->Thread) >= Start &&
                (ULONG_PTR)(Thread->Thread) < End) {

#if DBG
                if (Thread->NodeCount > 0) {
                    DbgPrint ("Deadlock verifier: deleting thread %p while holding resources %p \n");
                    DbgBreakPoint ();
                }
#endif

                ViDeadlockDeleteThread (Thread, FALSE);
            }
        }
    }    

    ViDeadlockDetectionUnlock(OldIrql);
}


VOID
ViDeadlockDeleteResource (
    PVI_DEADLOCK_RESOURCE Resource,
    BOOLEAN Cleanup
    )
/*++

Routine Description:

    This routine deletes a routine and all nodes representing
    acquisitions of that resource.

Arguments:

    Resource - resource to be deleted
    
    Cleanup - true if are called from ViDeadlockDetectionCleanup

Return Value:

    None.

--*/
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_NODE Node;

    ASSERT (Resource != NULL);
    ASSERT (Cleanup || ViDeadlockDatabaseOwner == KeGetCurrentThread());
    

    //
    // Check if the resource being deleted is still acquired. 
    // Note that this might fire if we loose release() operations
    // performed by an unverified driver.
    //

    if (Cleanup == FALSE && Resource->ThreadOwner != NULL) {
        
        ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES, 
                              (ULONG_PTR) (Resource->ResourceAddress),
                              (ULONG_PTR) (Resource->ThreadOwner->Thread),
                              (ULONG_PTR) (Resource));
    }

    //
    // If this is a normal delete (not a cleanup) we will collapse all trees
    // containing nodes for this resource. If it is a cleanup we will just
    // wipe out the node.
    //

    Current = Resource->ResourceList.Flink;

    while (Current != &(Resource->ResourceList)) {

        Node = CONTAINING_RECORD (Current,
                                  VI_DEADLOCK_NODE,
                                  ResourceList);


        Current = Current->Flink;

        ASSERT (Node->Root == Resource);

        ViDeadlockDeleteNode (Node, Cleanup);
    }

    //
    // There should not be any NODEs for the resource at this moment.
    //

    ASSERT (&(Resource->ResourceList) == Resource->ResourceList.Flink);
    ASSERT (&(Resource->ResourceList) == Resource->ResourceList.Blink);

    //
    // Remote the resource from the hash table and
    // delete the resource structure.
    //

    RemoveEntryList (&(Resource->HashChainList));   
    ViDeadlockFree (Resource, ViDeadlockResource);
}


VOID
ViDeadlockTrimResources (
    PLIST_ENTRY HashList
    )
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_RESOURCE Resource;
    ULONG Counter;

    ViDeadlockGlobals->ForgetHistoryCounter += 1;
    Counter = ViDeadlockGlobals->ForgetHistoryCounter;
    Counter %= VI_DEADLOCK_FORGET_HISTORY_FREQUENCY;

    if (Counter == 0) {

        Current = HashList->Flink;

        while (Current != HashList) {

            Resource = CONTAINING_RECORD (Current,
                                          VI_DEADLOCK_RESOURCE,
                                          HashChainList);
            Current = Current->Flink;

            ViDeadlockForgetResourceHistory (Resource, 
                                             ViDeadlockTrimThreshold, 
                                             ViDeadlockAgeWindow);
        }
    }
}

VOID
ViDeadlockForgetResourceHistory (
    PVI_DEADLOCK_RESOURCE Resource,
    ULONG TrimThreshold,
    ULONG AgeThreshold
    )
/*++

Routine Description:

    This routine deletes sone of the nodes representing
    acquisitions of that resource. In essence we forget
    part of the history of that resource.

Arguments:

    Resource - resource for which we wipe out nodes.
    
    TrimThreshold - how many nodes should remain
    
    AgeThreshold - nodes older than this will go away

Return Value:

    None.

--*/
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_NODE Node;
    ULONG NodesTrimmed = 0;
    ULONG SequenceNumber;

    ASSERT (Resource != NULL);
    ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread());

    //
    // If resource is owned we cannot do anything,
    //

    if (Resource->ThreadOwner) {
        return;
    }

    //
    // If resource has less than TrimThreshold nodes it is still fine.
    //

    if (Resource->NodeCount < TrimThreshold) {
        return;
    }

    //
    // Delete some nodes of the resource based on ageing.
    //

    SequenceNumber = ViDeadlockGlobals->SequenceNumber;

    Current = Resource->ResourceList.Flink;

    while (Current != &(Resource->ResourceList)) {

        Node = CONTAINING_RECORD (Current,
                                  VI_DEADLOCK_NODE,
                                  ResourceList);


        Current = Current->Flink;

        ASSERT (Node->Root == Resource);

        //
        // Special care here because the sequence numbers are 32bits
        // and they can overflow. In an ideal world the global sequence
        // is always greater or equal to the node sequence but if it
        // overwrapped it can be the other way around.
        //

        if (SequenceNumber > Node->SequenceNumber) {
            
            if (SequenceNumber - Node->SequenceNumber > AgeThreshold) {

                ViDeadlockDeleteNode (Node, FALSE);
                NodesTrimmed += 1;
            }
        }
        else {

            if (Node->SequenceNumber - SequenceNumber < AgeThreshold) {

                ViDeadlockDeleteNode (Node, FALSE);
                NodesTrimmed += 1;
            }
        }
    }

    ViDeadlockGlobals->NodesTrimmedBasedOnAge += NodesTrimmed;
    
    //
    // If resource has less than TrimThreshold nodes it is fine.
    //

    if (Resource->NodeCount < TrimThreshold) {
        return;
    }

    //
    // If we did not manage to trim the nodes by the age algorithm then
    // we  trim everything that we encounter.
    //

    NodesTrimmed = 0;

    Current = Resource->ResourceList.Flink;

    while (Current != &(Resource->ResourceList)) {

        if (Resource->NodeCount < TrimThreshold) {
            break;
        }

        Node = CONTAINING_RECORD (Current,
                                  VI_DEADLOCK_NODE,
                                  ResourceList);


        Current = Current->Flink;

        ASSERT (Node->Root == Resource);

        ViDeadlockDeleteNode (Node, FALSE);
        NodesTrimmed += 1;
    }

    ViDeadlockGlobals->NodesTrimmedBasedOnCount += NodesTrimmed;
}


VOID 
ViDeadlockDeleteNode (
    PVI_DEADLOCK_NODE Node,
    BOOLEAN Cleanup
    )
/*++

Routine Description:

    This routine deletes a node from a graph and collapses the tree, 
    that is connects its childrend with its parent.
    
    If we are during a cleanup we will just delete the node without
    collapsing the tree.

Arguments:

    Node - node to be deleted.
    
    Cleanup - true if we are during a total cleanup
    
Return Value:

    None.

--*/
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_NODE Child;
    ULONG Children;

    ASSERT (Node);

    //
    // If are during a cleanup just delete the node and return.
    //

    if (Cleanup) {
        
        RemoveEntryList (&(Node->ResourceList));
        ViDeadlockFree (Node, ViDeadlockNode);
        return;
    }
    
    //
    // If we are here we need to collapse the tree
    //

    ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread());

    if (Node->Parent) {

        //
        // All Node's children must become Parent's children
        //
        
        Current = Node->ChildrenList.Flink;

        while (Current != &(Node->ChildrenList)) {
            
            Child = CONTAINING_RECORD (Current,
                                      VI_DEADLOCK_NODE,
                                      SiblingsList);

            Current = Current->Flink;

            RemoveEntryList (&(Child->SiblingsList));

            Child->Parent = Node->Parent;

            InsertTailList (&(Node->Parent->ChildrenList), 
                            &(Child->SiblingsList));
        }

        RemoveEntryList (&(Node->SiblingsList));
    }
    else {

        //
        // All Node's children must become roots of the graph
        //

        Current = Node->ChildrenList.Flink;
        Children = 0;
        Child = NULL;

        while (Current != &(Node->ChildrenList)) {
            
            Children += 1;

            Child = CONTAINING_RECORD (Current,
                                      VI_DEADLOCK_NODE,
                                      SiblingsList);

            Current = Current->Flink;

            RemoveEntryList (&(Child->SiblingsList));

            Child->Parent = NULL;
            Child->SiblingsList.Flink = NULL;
            Child->SiblingsList.Blink = NULL;
        }
    }

    ASSERT (Node->Root);
    ASSERT (Node->Root->NodeCount > 0);

    Node->Root->NodeCount -= 1;
    
    RemoveEntryList (&(Node->ResourceList));
    ViDeadlockFree (Node, ViDeadlockNode);
}


ULONG
ViDeadlockNodeLevel (
    PVI_DEADLOCK_NODE Node
    )
/*++

Routine Description:

    This routine computes the level of a graph node.

Arguments:

    Node - graph node

Return Value:

    Level of the node. A root node has level zero.
--*/    
{
    PVI_DEADLOCK_NODE Current;
    ULONG Level = 0;

    Current = Node->Parent;

    while (Current) {
        
        Level += 1;
        Current = Current->Parent;
    }

    return Level;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Incremental graph compression
/////////////////////////////////////////////////////////////////////

//
// SilviuC: should write a comment about graph compression
// This is a very smart and tricky algorithm :-)
//

VOID 
ViDeadlockCheckDuplicatesAmongChildren (
    PVI_DEADLOCK_NODE Parent,
    PVI_DEADLOCK_NODE Child
    )
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_NODE Node;
    LOGICAL FoundOne;

    FoundOne = FALSE;
    Current = Parent->ChildrenList.Flink;

    while (Current != &(Parent->ChildrenList)) {

        Node = CONTAINING_RECORD (Current,
                                  VI_DEADLOCK_NODE,
                                  SiblingsList);

        ASSERT (Current->Flink);
        Current = Current->Flink;

        if (ViDeadlockSimilarNodes (Node, Child)) {
            
            if (FoundOne == FALSE) {
                ASSERT (Node == Child);
                FoundOne = TRUE;
            }
            else {
                
                ViDeadlockMergeNodes (Child, Node);
            }
        }
    }
}


VOID 
ViDeadlockCheckDuplicatesAmongRoots (
    PVI_DEADLOCK_NODE Root
    )
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_NODE Node;
    PVI_DEADLOCK_RESOURCE Resource;
    LOGICAL FoundOne;

    FoundOne = FALSE;
    Resource = Root->Root;
    Current = Resource->ResourceList.Flink;

    while (Current != &(Resource->ResourceList)) {

        Node = CONTAINING_RECORD (Current,
                                  VI_DEADLOCK_NODE,
                                  ResourceList);

        ASSERT (Current->Flink);
        Current = Current->Flink;

        if (Node->Parent == NULL && ViDeadlockSimilarNodes (Node, Root)) {
            
            if (FoundOne == FALSE) {
                ASSERT (Node == Root);
                FoundOne = TRUE;
            }
            else {
                
                ViDeadlockMergeNodes (Root, Node);
            }
        }
    }
}


LOGICAL
ViDeadlockSimilarNodes (
    PVI_DEADLOCK_NODE NodeA,
    PVI_DEADLOCK_NODE NodeB
    )
{
    if (NodeA->Root == NodeB->Root
        && NodeA->OnlyTryAcquireUsed == NodeB->OnlyTryAcquireUsed) {
        
        return TRUE;
    }
    else {

        return FALSE;
    }
}


VOID
ViDeadlockMergeNodes (
    PVI_DEADLOCK_NODE NodeTo,
    PVI_DEADLOCK_NODE NodeFrom
    )
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_NODE Node;

    //
    // If NodeFrom is currently acquired then copy the same 
    // characteristics to NodeTo. Since the locks are exclusive
    // it is impossible to have NodeTo also acquired.
    //

    if (NodeFrom->ThreadEntry) {
        ASSERT (NodeTo->ThreadEntry == NULL);
        NodeTo->ThreadEntry = NodeFrom->ThreadEntry;        

        RtlCopyMemory (NodeTo->StackTrace,
                       NodeFrom->StackTrace,
                       sizeof (NodeTo->StackTrace));

        RtlCopyMemory (NodeTo->ParentStackTrace,
                       NodeFrom->ParentStackTrace,
                       sizeof (NodeTo->ParentStackTrace));
    }
    
    if (NodeFrom->Active) {
        ASSERT (NodeTo->Active == 0);
        NodeTo->Active = NodeFrom->Active;        
    }

    //
    // Move each child of NodeFrom as a child of NodeTo.
    //

    Current = NodeFrom->ChildrenList.Flink;

    while (Current != &(NodeFrom->ChildrenList)) {

        Node = CONTAINING_RECORD (Current,
                                  VI_DEADLOCK_NODE,
                                  SiblingsList);

        ASSERT (Current->Flink);
        Current = Current->Flink;

        RemoveEntryList (&(Node->SiblingsList));

        ASSERT (Node->Parent == NodeFrom);
        Node->Parent = NodeTo;

        InsertTailList (&(NodeTo->ChildrenList),
                        &(Node->SiblingsList));
    }

    //
    // NodeFrom is empty. Delete it.
    //

    ASSERT (IsListEmpty(&(NodeFrom->ChildrenList)));

    if (NodeFrom->Parent) {
        RemoveEntryList (&(NodeFrom->SiblingsList));
    }
    
    NodeFrom->Root->NodeCount -= 1;
    RemoveEntryList (&(NodeFrom->ResourceList));
    ViDeadlockFree (NodeFrom, ViDeadlockNode);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// ExFreePool() hook
/////////////////////////////////////////////////////////////////////

VOID
VerifierDeadlockFreePool(
    IN PVOID Address,
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This routine receives notification of all pool manager memory frees.

Arguments:

    Address - Supplies the virtual address being freed.

    NumberOfBytes - Supplies the number of bytes spanned by the allocation.

Return Value:

    None.
    
Environment:

    This is called at various points either just before or just after the
    allocation has been freed, depending on which is convenient for the pool
    manager (this varies based on type of allocation).

    No pool resources are held on entry and the memory still exists and
    is referencable.
    
--*/

{
    VfDeadlockDeleteMemoryRange (Address, NumberOfBytes);
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////// Consistency checks
/////////////////////////////////////////////////////////////////////

//
//  Node             Resource            Thread
//
//  Root             ThreadOwner         CurrentNode
//  ThreadEntry      RecursionCount      NodeCount
//  Active           ResourceAddress     Thread
//
//
// 
//

VOID
ViDeadlockCheckThreadConsistency (
    PVI_DEADLOCK_THREAD Thread,
    BOOLEAN Recursion
    )
{
    if (Thread->CurrentSpinNode == NULL && Thread->CurrentOtherNode == NULL) {
        ASSERT (Thread->NodeCount == 0);
        return;
    }

    if (Thread->CurrentSpinNode) {
        
        ASSERT (Thread->NodeCount > 0);
        ASSERT (Thread->CurrentSpinNode->Active);    

        if (Recursion == FALSE) {
            ViDeadlockCheckNodeConsistency (Thread->CurrentSpinNode, TRUE);
            ViDeadlockCheckResourceConsistency (Thread->CurrentSpinNode->Root, TRUE);
        }
    }
    
    if (Thread->CurrentOtherNode) {
        
        ASSERT (Thread->NodeCount > 0);
        ASSERT (Thread->CurrentOtherNode->Active);    

        if (Recursion == FALSE) {
            ViDeadlockCheckNodeConsistency (Thread->CurrentOtherNode, TRUE);
            ViDeadlockCheckResourceConsistency (Thread->CurrentOtherNode->Root, TRUE);
        }
    }
}

VOID
ViDeadlockCheckNodeConsistency (
    PVI_DEADLOCK_NODE Node,
    BOOLEAN Recursion
    )
{
    if (Node->ThreadEntry) {
        
        ASSERT (Node->Active == 1);

        if (Recursion == FALSE) {
            ViDeadlockCheckThreadConsistency (Node->ThreadEntry, TRUE);
            ViDeadlockCheckResourceConsistency (Node->Root, TRUE);
        }
    }
    else {

        ASSERT (Node->Active == 0);
        
        if (Recursion == FALSE) {
            ViDeadlockCheckResourceConsistency (Node->Root, TRUE);
        }
    }
}

VOID
ViDeadlockCheckResourceConsistency (
    PVI_DEADLOCK_RESOURCE Resource,
    BOOLEAN Recursion
    )
{
    if (Resource->ThreadOwner) {
        
        ASSERT (Resource->RecursionCount > 0);

        if (Recursion == FALSE) {
            ViDeadlockCheckThreadConsistency (Resource->ThreadOwner, TRUE);

            if (Resource->Type == VfDeadlockSpinLock) {
                ViDeadlockCheckNodeConsistency (Resource->ThreadOwner->CurrentSpinNode, TRUE);
            }
            else {
                ViDeadlockCheckNodeConsistency (Resource->ThreadOwner->CurrentOtherNode, TRUE);
            }
        }
    }
    else {

        ASSERT (Resource->RecursionCount == 0);
    }
}

PVI_DEADLOCK_THREAD
ViDeadlockCheckThreadReferences (
    PVI_DEADLOCK_NODE Node
    )
/*++

Routine Description:

    This routine iterates all threads in order to check if `Node' is
    referred in the `CurrentNode' field in any of them.

Arguments:

    Node - node to search

Return Value:

    If everything goes ok we should not find the node and the return
    value is null. Otherwise we return the thread referring to the node.        

--*/
{
    ULONG Index;
    PLIST_ENTRY Current;
    PVI_DEADLOCK_THREAD Thread;

    for (Index = 0; Index < VI_DEADLOCK_HASH_BINS; Index += 1) {
        Current = ViDeadlockGlobals->ThreadDatabase[Index].Flink;

        while (Current != &(ViDeadlockGlobals->ThreadDatabase[Index])) {

            Thread = CONTAINING_RECORD (Current,
                                        VI_DEADLOCK_THREAD,
                                        ListEntry);

            if (Thread->CurrentSpinNode == Node) {
                return Thread;                    
            }

            if (Thread->CurrentOtherNode == Node) {
                return Thread;                    
            }

            Current = Current->Flink;
        }
    }

    return NULL;
}


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// Detect paging code paths
/////////////////////////////////////////////////////////////////////

BOOLEAN
VfDeadlockBeforeCallDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine checks if the IRP is a paging I/O IRP. If it is it will
    disable deadlock verification in this thread until the after() function
    is called.
    
    The function also ignores mounting IRPs. There are drivers that have
    locks inversed in mounting code paths but mounting can never happen
    in parallel with normal access. 

Arguments:

    DeviceObject - same parameter used in IoCallDriver call.
    
    Irp - IRP passed to the driver as used in IoCallDriver call.

Return Value:

    True if the Irp parameter is a paging IRP.

--*/
{
    KIRQL OldIrql;
    PKTHREAD SystemThread;
    PVI_DEADLOCK_THREAD VerifierThread;
    BOOLEAN PagingIrp = FALSE;
    PVOID ReservedThread = NULL;

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    // Skip if package not initialized
    //

    if (ViDeadlockGlobals == NULL) {
        return FALSE;
    }

    //
    // Skip if package is disabled
    //

    if (! ViDeadlockDetectionEnabled) {
        return FALSE;
    }
        
    //
    // Skip for machines with more than 4 processors because 
    // it is too slow and all code is protected
    // by one single lock and this becomes a bottleneck.
    //

    if (KeNumberProcessors > 4) {
        return FALSE;
    }

    //
    // If it is not a paging I/O IRP or a mounting IRP we do not care.
    //

    if ((Irp->Flags & (IRP_PAGING_IO | IRP_MOUNT_COMPLETION)) == 0) {
        return FALSE;
    }
    
    //
    // Find the deadlock verifier structure maintained for the current
    // thread. If we do not find one then we will create one. On top of
    // this mount/page IRP there might be locks acquired and we want to 
    // skip them too. The only situations where we observed that lock
    // hierarchies are not respected is when at least one lock was acquired
    // before the IoCallDriver() with a paging IRP or no lock acquired before
    // a mount IRP (udfs.sys). For this last case we need to create a thread
    // in which to increase the PageCount counter.
    //

    SystemThread = KeGetCurrentThread ();

    ReservedThread = ViDeadlockAllocate (ViDeadlockThread);

    if (ReservedThread == NULL) {
        return FALSE;
    }

    ViDeadlockDetectionLock (&OldIrql);

    VerifierThread = ViDeadlockSearchThread (SystemThread);

    if (VerifierThread == NULL) {

        VerifierThread = ViDeadlockAddThread (SystemThread, 
                                              ReservedThread);

        ReservedThread = NULL;

        ASSERT (VerifierThread);
    }

    //
    // At this point VerifierThread points to a deadlock verifier
    // thread structure. We need to bump the paging recursion count 
    // to mark that one more level of paging I/O is active.
    //
        
    VerifierThread->PagingCount += 1;

    PagingIrp = TRUE;

    //
    // Unlock the deadlock verifier lock and exit.
    //

    if (ReservedThread) {
        ViDeadlockFree (ReservedThread, ViDeadlockThread);
    }

    ViDeadlockDetectionUnlock (OldIrql);

    return PagingIrp;
}


VOID
VfDeadlockAfterCallDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN BOOLEAN PagingIrp
    )
/*++

Routine Description:

    This routine is called after an IoCallDriver() call returns. It is used
    to undo any state created by the before() function.

Arguments:

    DeviceObject - same parameter used in IoCallDriver call.
    
    Irp - IRP passed to the driver as used in IoCallDriver call.
    
    PagingIrp - true if a previous call to the before() routine returned
        true signalling a paging IRP.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PKTHREAD SystemThread;
    PVI_DEADLOCK_THREAD VerifierThread;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Irp);

    //
    // Skip if package not initialized
    //

    if (ViDeadlockGlobals == NULL) {
        return;
    }

    //
    // Skip if package is disabled
    //

    if (! ViDeadlockDetectionEnabled) {
        return;
    }
        
    //
    // Skip for machines with more than 4 processors because 
    // it is too slow and all code is protected
    // by one single lock and this becomes a bottleneck.
    //

    if (KeNumberProcessors > 4) {
        return;
    }

    //
    // If it is not a paging I/O IRP we do not care.
    //

    if (! PagingIrp) {
        return;
    }

    //
    // Find the deadlock verifier structure maintained for the current
    // thread. If we do not find one then we will let deadlock verifier
    // do its job. The only situations where we observed that lock
    // hierarchies are not respected is when at least one lock was acquired
    // before the IoCallDriver() with a paging IRP.
    //

    SystemThread = KeGetCurrentThread ();

    ViDeadlockDetectionLock (&OldIrql);

    VerifierThread = ViDeadlockSearchThread (SystemThread);

    if (VerifierThread == NULL) {
        goto Exit;
    }

    //
    // At this point VerifierThread points to a deadlock verifier
    // thread structure. We need to bump the paging recursion count 
    // to mark that one more level of paging I/O is active.
    //
        
    ASSERT (VerifierThread->PagingCount > 0);

    VerifierThread->PagingCount -= 1;

    //
    // Unlock the deadlock verifier lock and exit.
    //

    Exit:

    ViDeadlockDetectionUnlock (OldIrql);
}


BOOLEAN
ViIsThreadInsidePagingCodePaths (
    VOID
    )
/*++

Routine Description:

    This routine checks if current thread is inside paging code paths.         

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PKTHREAD SystemThread;
    PVI_DEADLOCK_THREAD VerifierThread;
    BOOLEAN Paging = FALSE;

    SystemThread = KeGetCurrentThread ();

    ViDeadlockDetectionLock (&OldIrql);

    VerifierThread = ViDeadlockSearchThread (SystemThread);

    if (VerifierThread && VerifierThread->PagingCount > 0) {
        Paging = TRUE;
    }

    ViDeadlockDetectionUnlock (OldIrql);

    return Paging;
}


VOID
ViDeadlockCheckStackLimits (
    VOID
    )
/*++

Routine Description:

    This function checks that the current stack is a thread stack
    or a DPC stack. This will catch drivers that switch their stacks.

--*/
{
#if defined(_X86_)

    ULONG_PTR StartStack;
    ULONG_PTR EndStack;
    ULONG_PTR HintAddress;

    _asm mov HintAddress, EBP;

    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
        return;
    }
    
    StartStack = (ULONG_PTR)(KeGetCurrentThread()->StackLimit);
    EndStack = (ULONG_PTR)(KeGetCurrentThread()->StackBase);

    if (StartStack <= HintAddress && HintAddress <= EndStack) {
        return;
    }

    EndStack = (ULONG_PTR)(KeGetPcr()->Prcb->DpcStack);
    StartStack = EndStack - KERNEL_STACK_SIZE;
    
    if (EndStack && StartStack <= HintAddress && HintAddress <= EndStack) {
        return;
    }

    KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                  0x90, 
                  (ULONG_PTR)(KeGetPcr()->Prcb), 
                  0, 
                  0);

#else
    return;
#endif

}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfddi.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    vfddi.c

Abstract:

    This module contains the list of device driver interfaces exported by the
    driver verifier and the kernel. Note that thunked exports are *not* placed
    here.

    All the exports are concentrated in one file because

        1) There are relatively few driver verifier exports

        2) The function naming convention differs from that used elsewhere in
           the driver verifier.

Author:

    Adrian J. Oney (adriao) 26-Apr-2001

Environment:

    Kernel mode

Revision History:

--*/

#include "vfdef.h"
#include "viddi.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, VfDdiInit)
#pragma alloc_text(PAGEVRFY, VfDdiExposeWmiObjects)
//#pragma alloc_text(NONPAGED, VfFailDeviceNode)
//#pragma alloc_text(NONPAGED, VfFailSystemBIOS)
//#pragma alloc_text(NONPAGED, VfFailDriver)
//#pragma alloc_text(NONPAGED, VfIsVerificationEnabled)
#pragma alloc_text(PAGEVRFY, ViDdiThrowException)
#pragma alloc_text(PAGEVRFY, ViDdiDriverEntry)
#pragma alloc_text(PAGEVRFY, ViDdiDispatchWmi)
#pragma alloc_text(PAGEVRFY, ViDdiDispatchWmiRegInfoEx)
#pragma alloc_text(PAGEVRFY, ViDdiBuildWmiRegInfoData)
#pragma alloc_text(PAGEVRFY, ViDdiDispatchWmiQueryAllData)

#endif // ALLOC_PRAGMA

LOGICAL ViDdiInitialized = FALSE;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEVRFD")
#endif

UNICODE_STRING ViDdiWmiMofKey;
UNICODE_STRING ViDdiWmiMofResourceName;
PDEVICE_OBJECT *ViDdiDeviceObjectArray = NULL;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGEVRFC")
#endif

//
// These are the general "classifications" of device errors, along with the
// default flags that will be applied the first time this is hit.
//
const VFMESSAGE_CLASS ViDdiClassFailDeviceInField = {
    VFM_FLAG_BEEP | VFM_LOGO_FAILURE | VFM_DEPLOYMENT_FAILURE,
    "DEVICE FAILURE"
    };

// VFM_DEPLOYMENT_FAILURE is set here because we don't yet have a "logo" mode
const VFMESSAGE_CLASS ViDdiClassFailDeviceLogo = {
    VFM_FLAG_BEEP | VFM_LOGO_FAILURE | VFM_DEPLOYMENT_FAILURE,
    "DEVICE FAILURE"
    };

const VFMESSAGE_CLASS ViDdiClassFailDeviceUnderDebugger = {
    VFM_FLAG_BEEP,
    "DEVICE FAILURE"
    };

WCHAR VerifierDdiDriverName[] = L"\\DRIVER\\VERIFIER_DDI";

#include <initguid.h>

// Define the verifier WMI GUID (1E2C2980-F7DB-46AA-820E-8734FCC21F4C)
DEFINE_GUID( GUID_VERIFIER_WMI_INTERFACE, 0x1E2C2980L, 0xF7DB, 0x46AA,
    0x82, 0x0E, 0x87, 0x34, 0xFC, 0xC2, 0x1F, 0x4C);

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

#define POOLTAG_DDI_WMIDO_ARRAY     'aDfV'


VOID
VfDdiInit(
    VOID
    )
/*++

Routine Description:

    This routine initializes the Device Driver Interface support.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ViDdiInitialized = TRUE;
}


VOID
VfDdiExposeWmiObjects(
    VOID
    )
/*++

Routine Description:

    This routine exposes verifier WMI objects.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UNICODE_STRING driverString;

    // L"\\Machine\\Registry\\System\\CurrentControlSet\\Services\\Verifier");
    RtlInitUnicodeString(&ViDdiWmiMofKey, L"");

    // L"VerifierMof"
    RtlInitUnicodeString(&ViDdiWmiMofResourceName, L"");
    RtlInitUnicodeString(&driverString, VerifierDdiDriverName);

    IoCreateDriver(&driverString, ViDdiDriverEntry);
}


VOID
VfFailDeviceNode(
    IN      PDEVICE_OBJECT      PhysicalDeviceObject,
    IN      ULONG               BugCheckMajorCode,
    IN      ULONG               BugCheckMinorCode,
    IN      VF_FAILURE_CLASS    FailureClass,
    IN OUT  PULONG              AssertionControl,
    IN      PSTR                DebuggerMessageText,
    IN      PSTR                ParameterFormatString,
    ...
    )
/*++

Routine Description:

    This routine fails a Pnp enumerated hardware or virtual device if
    verification is enabled against it.

Arguments:

    PhysicalDeviceObject    - Bottom of the stack that identifies the PnP
                              device.

    BugCheckMajorCode       - BugCheck Major Code

    BugCheckMinorCode       - BugCheck Minor Code
                              Note - Zero is reserved!!!

    FailureClass            - Either VFFAILURE_FAIL_IN_FIELD,
                                     VFFAILURE_FAIL_LOGO, or
                                     VFFAILURE_FAIL_UNDER_DEBUGGER

    AssertionControl        - Points to a ULONG associated with the failure,
                              used to store information across multiple calls.
                              Must be statically preinitialized to zero.

    DebuggerMessageText     - Text to be displayed in the debugger. Note that
                              the text may reference parameters such as:
                              %Routine  - passed in Routine
                              %Irp      - passed in Irp
                              %DevObj   - passed in DevObj
                              %Status   - passed in Status
                              %Ulong    - passed in ULONG
                              %Ulong1   - first passed in ULONG
                              %Ulong3   - third passed in ULONG (max 3, any param)
                              %Pvoid2   - second passed in PVOID
                              etc
                              (note, capitalization matters)

    ParameterFormatString   - Contains ordered list of parameters referenced by
                              above debugger text. For instance,
                        (..., "%Status1%Status2%Ulong1%Ulong2", Status1, Status2, Ulong1, Ulong2);

                        Note - If %Routine/%Routine1 is supplied as a param,
                        the driver at %Routine must also be under verification.

    ...                     - Actual parameters

Return Value:

    None.

    Note - this function may return if the device is not currently being
           verified.

--*/
{
    va_list arglist;

    if (!VfIsVerificationEnabled(VFOBJTYPE_DEVICE, (PVOID) PhysicalDeviceObject)) {

        return;
    }

    va_start(arglist, ParameterFormatString);

    ViDdiThrowException(
        BugCheckMajorCode,
        BugCheckMinorCode,
        FailureClass,
        AssertionControl,
        DebuggerMessageText,
        ParameterFormatString,
        &arglist
        );

    va_end(arglist);
}


VOID
VfFailSystemBIOS(
    IN      ULONG               BugCheckMajorCode,
    IN      ULONG               BugCheckMinorCode,
    IN      VF_FAILURE_CLASS    FailureClass,
    IN OUT  PULONG              AssertionControl,
    IN      PSTR                DebuggerMessageText,
    IN      PSTR                ParameterFormatString,
    ...
    )
/*++

Routine Description:

    This routine fails the system BIOS if verification is enabled against it.

Arguments:

    BugCheckMajorCode       - BugCheck Major Code

    BugCheckMinorCode       - BugCheck Minor Code
                              Note - Zero is reserved!!!

    FailureClass            - Either VFFAILURE_FAIL_IN_FIELD,
                                     VFFAILURE_FAIL_LOGO, or
                                     VFFAILURE_FAIL_UNDER_DEBUGGER

    AssertionControl        - Points to a ULONG associated with the failure,
                              used to store information across multiple calls.
                              Must be statically preinitialized to zero.

    DebuggerMessageText     - Text to be displayed in the debugger. Note that
                              the text may reference parameters such as:
                              %Routine  - passed in Routine
                              %Irp      - passed in Irp
                              %DevObj   - passed in DevObj
                              %Status   - passed in Status
                              %Ulong    - passed in ULONG
                              %Ulong1   - first passed in ULONG
                              %Ulong3   - third passed in ULONG (max 3, any param)
                              %Pvoid2   - second passed in PVOID
                              etc
                              (note, capitalization matters)

    ParameterFormatString   - Contains ordered list of parameters referenced by
                              above debugger text. For instance,
                        (..., "%Status1%Status2%Ulong1%Ulong2", Status1, Status2, Ulong1, Ulong2);

                        Note - If %Routine/%Routine1 is supplied as a param,
                        the driver at %Routine must also be under verification.

    ...                     - Actual parameters

Return Value:

    None.

    Note - this function may return if the device is not currently being
           verified.

--*/
{
    va_list arglist;

    if (!VfIsVerificationEnabled(VFOBJTYPE_SYSTEM_BIOS, NULL)) {

        return;
    }

    va_start(arglist, ParameterFormatString);

    ViDdiThrowException(
        BugCheckMajorCode,
        BugCheckMinorCode,
        FailureClass,
        AssertionControl,
        DebuggerMessageText,
        ParameterFormatString,
        &arglist
        );

    va_end(arglist);
}


VOID
VfFailDriver(
    IN      ULONG               BugCheckMajorCode,
    IN      ULONG               BugCheckMinorCode,
    IN      VF_FAILURE_CLASS    FailureClass,
    IN OUT  PULONG              AssertionControl,
    IN      PSTR                DebuggerMessageText,
    IN      PSTR                ParameterFormatString,
    ...
    )
/*++

Routine Description:

    This routine fails a driver if verification is enabled against it.

Arguments:

    BugCheckMajorCode       - BugCheck Major Code

    BugCheckMinorCode       - BugCheck Minor Code
                              Note - Zero is reserved!!!

    FailureClass            - Either VFFAILURE_FAIL_IN_FIELD,
                                     VFFAILURE_FAIL_LOGO, or
                                     VFFAILURE_FAIL_UNDER_DEBUGGER

    AssertionControl        - Points to a ULONG associated with the failure.
                              Must be preinitialized to zero!!!

    DebuggerMessageText     - Text to be displayed in the debugger. Note that
                              the text may reference parameters such as:
                              %Routine  - passed in Routine
                              %Irp      - passed in Irp
                              %DevObj   - passed in DevObj
                              %Status   - passed in Status
                              %Ulong    - passed in ULONG
                              %Ulong1   - first passed in ULONG
                              %Ulong3   - third passed in ULONG (max 3, any param)
                              %Pvoid2   - second passed in PVOID
                              etc
                              (note, capitalization matters)

    ParameterFormatString   - Contains ordered list of parameters referenced by
                              above debugger text. For instance,
                        (..., "%Status1%Status2%Ulong1%Ulong2", Status1, Status2, Ulong1, Ulong2);

                        One of these parameters should be %Routine. This will
                        be what the OS uses to identify the driver.

        static minorFlags = 0;

        VfFailDriver(
            major,
            minor,
            VFFAILURE_FAIL_LOGO,
            &minorFlags,
            "Driver at %Routine returned %Ulong",
            "%Ulong%Routine",
            value,
            routine
            );

Return Value:

    None.

    Note - this function may return if the driver is not currently being
           verified.

--*/
{
    va_list arglist;

    if (!ViDdiInitialized) {

        return;
    }

    va_start(arglist, ParameterFormatString);

    ViDdiThrowException(
        BugCheckMajorCode,
        BugCheckMinorCode,
        FailureClass,
        AssertionControl,
        DebuggerMessageText,
        ParameterFormatString,
        &arglist
        );

    va_end(arglist);
}


VOID
ViDdiThrowException(
    IN      ULONG               BugCheckMajorCode,
    IN      ULONG               BugCheckMinorCode,
    IN      VF_FAILURE_CLASS    FailureClass,
    IN OUT  PULONG              AssertionControl,
    IN      PSTR                DebuggerMessageText,
    IN      PSTR                ParameterFormatString,
    IN      va_list *           MessageParameters
    )
/*++

Routine Description:

    This routine fails either a devnode or a driver.

Arguments:

    BugCheckMajorCode       - BugCheck Major Code

    BugCheckMinorCode       - BugCheck Minor Code
                              Note - Zero is reserved!!!

    FailureClass            - Either VFFAILURE_FAIL_IN_FIELD,
                                     VFFAILURE_FAIL_LOGO, or
                                     VFFAILURE_FAIL_UNDER_DEBUGGER

    AssertionControl        - Points to a ULONG associated with the failure.
                              Must be preinitialized to zero.

    DebuggerMessageText     - Text to be displayed in the debugger. Note that
                              the text may reference parameters such as:
                              %Routine  - passed in Routine
                              %Irp      - passed in Irp
                              %DevObj   - passed in DevObj
                              %Status   - passed in Status
                              %Ulong    - passed in ULONG
                              %Ulong1   - first passed in ULONG
                              %Ulong3   - third passed in ULONG (max 3, any param)
                              %Pvoid2   - second passed in PVOID
                              etc
                              (note, capitalization matters)

    ParameterFormatString   - Contains ordered list of parameters referenced by
                              above debugger text. For instance,
                        (..., "%Status1%Status2%Ulong1%Ulong2", Status1, Status2, Ulong1, Ulong2);

    MessageParameters       - arg list of parameters matching
                              ParameterFormatString

Return Value:

    None.

    Note - this function may return if the device is not currently being
           verified.

--*/
{
    PCVFMESSAGE_CLASS messageClass;
    VFMESSAGE_TEMPLATE messageTemplates[2];
    VFMESSAGE_TEMPLATE_TABLE messageTable;
    NTSTATUS status;

    ASSERT(BugCheckMinorCode != 0);

    switch(FailureClass) {
        case VFFAILURE_FAIL_IN_FIELD:
            messageClass = &ViDdiClassFailDeviceInField;
            break;

        case VFFAILURE_FAIL_LOGO:
            messageClass = &ViDdiClassFailDeviceLogo;
            break;

        case VFFAILURE_FAIL_UNDER_DEBUGGER:
            messageClass = &ViDdiClassFailDeviceUnderDebugger;
            break;

        default:
            ASSERT(0);
            messageClass = NULL;
            break;
    }

    //
    // Program the template.
    //
    RtlZeroMemory(messageTemplates, sizeof(messageTemplates));
    messageTemplates[0].MessageID = BugCheckMinorCode-1;
    messageTemplates[1].MessageID = BugCheckMinorCode;
    messageTemplates[1].MessageClass = messageClass;
    messageTemplates[1].Flags = *AssertionControl;
    messageTemplates[1].ParamString = ParameterFormatString;
    messageTemplates[1].MessageText = DebuggerMessageText;

    //
    // Fill out the message table.
    //
    messageTable.TableID = 0;
    messageTable.BugCheckMajor = BugCheckMajorCode;
    messageTable.TemplateArray = messageTemplates;
    messageTable.TemplateCount = ARRAY_COUNT(messageTemplates);
    messageTable.OverrideArray = NULL;
    messageTable.OverrideCount = 0;

    status = VfBugcheckThrowException(
        &messageTable,
        BugCheckMinorCode,
        ParameterFormatString,
        MessageParameters
        );

    //
    // Write back the assertion control.
    //
    *AssertionControl = messageTemplates[1].Flags;
}


BOOLEAN
VfIsVerificationEnabled(
    IN  VF_OBJECT_TYPE  VfObjectType,
    IN  PVOID           Object
    )
{
    if (!ViDdiInitialized) {

        return FALSE;
    }

    switch(VfObjectType) {

        case VFOBJTYPE_DRIVER:
            return (BOOLEAN) MmIsDriverVerifying((PDRIVER_OBJECT) Object);

        case VFOBJTYPE_DEVICE:

            if (!VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_HARDWARE_VERIFICATION)) {

                return FALSE;
            }

            return PpvUtilIsHardwareBeingVerified((PDEVICE_OBJECT) Object);

        case VFOBJTYPE_SYSTEM_BIOS:
            return VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_SYSTEM_BIOS_VERIFICATION);
    }

    return FALSE;
}


NTSTATUS
ViDdiDriverEntry(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     RegistryPath
    )
/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    Verifier Ddi Object.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - is NULL.

Return Value:

   STATUS_SUCCESS

--*/
{
    PDEVICE_OBJECT deviceObject;
    ULONG siloCount;
    NTSTATUS status;
    ULONG i;

    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // This driver exposes a WMI interface, and that's it.
    //
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = ViDdiDispatchWmi;

    siloCount = VfIrpLogGetIrpDatabaseSiloCount();

    ViDdiDeviceObjectArray = (PDEVICE_OBJECT *) ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(PDEVICE_OBJECT) * siloCount,
        POOLTAG_DDI_WMIDO_ARRAY
        );

    if (ViDdiDeviceObjectArray == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Create device objects that will expose IRP history via WMI. We expose
    // multiple as WMI has a maximum of 64K data per transfer.
    //
    for(i=0; i < siloCount; i++) {

        status = IoCreateDevice(
            DriverObject,
            sizeof(VFWMI_DEVICE_EXTENSION),
            NULL, // The name will be autogenerated
            FILE_DEVICE_UNKNOWN,
            FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
            FALSE,
            &deviceObject
            );

        if (!NT_SUCCESS(status)) {

            while(i) {

                IoDeleteDevice(ViDdiDeviceObjectArray[--i]);
            }

            return status;
        }

        ViDdiDeviceObjectArray[i] = deviceObject;
        ((PVFWMI_DEVICE_EXTENSION) deviceObject->DeviceExtension)->SiloNumber = i;
    }

    for(i=0; i < siloCount; i++) {

        deviceObject = ViDdiDeviceObjectArray[i];

        //
        // Let the operating system know this device object is now online (we
        // can now receive IRPs, such as WMI).
        //
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        //
        // Tell WMI to query our device object for WMI information.
        //
        status = IoWMIRegistrationControl(deviceObject, WMIREG_ACTION_REGISTER);

        if (!NT_SUCCESS(status)) {

            IoDeleteDevice(deviceObject);
            while(i) {

                IoDeleteDevice(ViDdiDeviceObjectArray[--i]);
            }

            return status;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ViDdiDispatchWmi(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the Verifier Ddi dispatch handler for WMI IRPs.

Arguments:

    DeviceObject - Pointer to the verifier device object.

    Irp - Pointer to the incoming IRP.

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch(irpSp->MinorFunction) {

        case IRP_MN_REGINFO_EX:

            status = ViDdiDispatchWmiRegInfoEx(DeviceObject, Irp);
            break;

        case IRP_MN_QUERY_ALL_DATA:

            status = ViDdiDispatchWmiQueryAllData(DeviceObject, Irp);
            break;

        default:
            status = STATUS_NOT_SUPPORTED;
            break;
    }

    if (status == STATUS_NOT_SUPPORTED) {

        status = Irp->IoStatus.Status;

    } else {

        Irp->IoStatus.Status = status;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


NTSTATUS
ViDdiDispatchWmiRegInfoEx(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the Verifier Ddi dispatch handler for the WMI IRP_MN_REGINFO_EX IRP.

Arguments:

    DeviceObject - Pointer to the verifier device object.

    Irp - Pointer to the incoming IRP.

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpSp;
    PWMIREGINFO wmiRegInfo;
    ULONG sizeSupplied;
    ULONG sizeRequired;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if ((PDEVICE_OBJECT) irpSp->Parameters.WMI.ProviderId != DeviceObject) {

        //
        // Huh? This is a single device object legacy stack!
        //
        ASSERT(0);
        return STATUS_NOT_SUPPORTED;
    }

    wmiRegInfo = (PWMIREGINFO) irpSp->Parameters.WMI.Buffer;

    sizeSupplied = irpSp->Parameters.WMI.BufferSize;

    sizeRequired = ViDdiBuildWmiRegInfoData((ULONG) (ULONG_PTR) irpSp->Parameters.WMI.DataPath, NULL);

    if (sizeRequired > sizeSupplied) {

        //
        // Not large enough, indicate the required size and fail the IRP.
        //
        if (sizeSupplied < sizeof(ULONG)) {

            //
            // WMI must give us at least a ULONG!
            //
            ASSERT(0);
            return STATUS_NOT_SUPPORTED;
        }

        //
        // Per spec, write to only the first ULONG in the supplied buffer.
        //
        wmiRegInfo->BufferSize = sizeRequired;
        Irp->IoStatus.Information = sizeof(ULONG);
        return STATUS_BUFFER_TOO_SMALL;
    }

    ViDdiBuildWmiRegInfoData((ULONG) (ULONG_PTR) irpSp->Parameters.WMI.DataPath, wmiRegInfo);

    Irp->IoStatus.Information = sizeRequired;
    return STATUS_SUCCESS;
}


ULONG
ViDdiBuildWmiRegInfoData(
    IN  ULONG        Datapath,
    OUT PWMIREGINFOW WmiRegInfo OPTIONAL
    )
/*++

Routine Description:

    This function calculates and optionally builds the data block to return
    back to WMI in response to IRP_MN_REGINFO_EX.

Arguments:

    Datapath - Either WMIREGISTER or WMIUPDATE.

    WmiRegInfo - Buffer supplied by OS to optionally fill in.

Return Value:

    Size in bytes of buffer (required or written)

--*/
{
    PUNICODE_STRING unicodeDestString;
    PUNICODE_STRING unicodeSrcString;
    PWMIREGGUIDW wmiRegGuid;
    ULONG bufferSize;
    ULONG guidCount;

    //
    // Start with the basic WMI structure size.
    //
    bufferSize = sizeof(WMIREGINFO);

    //
    // Add our one interface GUID structure. We are using dynamic instance
    // names for this interface, so we'll provide them in response to a query.
    // Consequently, we don't have any trailing static instance info.
    //
    guidCount = 1;

    if (ARGUMENT_PRESENT(WmiRegInfo)) {

        WmiRegInfo->GuidCount = guidCount;

        wmiRegGuid = &WmiRegInfo->WmiRegGuid[0];
        wmiRegGuid->Guid = GUID_VERIFIER_WMI_INTERFACE;
        wmiRegGuid->Flags = 0;

        //
        // These fields don't need to be zeroed, but we make them consistant
        // just in case a bug exists somewhere downstream.
        //
        wmiRegGuid->InstanceCount = 0;
        wmiRegGuid->InstanceInfo = 0;
    }

    bufferSize += guidCount * sizeof(WMIREGGUIDW);

    if (Datapath == WMIREGISTER) {

        //
        // The registry path begins here. Adjust bufferSize to point to the
        // next field.
        //
        bufferSize = ALIGN_UP_ULONG(bufferSize, 2);

        unicodeSrcString = &ViDdiWmiMofKey;

        if (ARGUMENT_PRESENT(WmiRegInfo)) {

            WmiRegInfo->RegistryPath = bufferSize;

            unicodeDestString = (PUNICODE_STRING) (((PUCHAR) WmiRegInfo) + bufferSize);

            unicodeDestString->Length        = unicodeSrcString->Length;
            unicodeDestString->MaximumLength = unicodeSrcString->Length;

            unicodeDestString->Buffer = (PWCHAR) (unicodeDestString+1);
            RtlCopyMemory(unicodeDestString->Buffer,
                          unicodeSrcString->Buffer,
                          unicodeSrcString->Length);
        }

        bufferSize += sizeof(UNICODE_STRING) + unicodeSrcString->Length;

        //
        // The Mof resource name begins here. Adjust buffersize to point to the
        // next field.
        //
        bufferSize = ALIGN_UP_ULONG(bufferSize, 2);

        unicodeSrcString = &ViDdiWmiMofResourceName;

        if (ARGUMENT_PRESENT(WmiRegInfo)) {

            WmiRegInfo->MofResourceName = bufferSize;

            unicodeDestString = (PUNICODE_STRING) (((PUCHAR) WmiRegInfo) + bufferSize);

            unicodeDestString->Length        = unicodeSrcString->Length;
            unicodeDestString->MaximumLength = unicodeSrcString->Length;

            unicodeDestString->Buffer = (PWCHAR) (unicodeDestString+1);
            RtlCopyMemory(unicodeDestString->Buffer,
                          unicodeSrcString->Buffer,
                          unicodeSrcString->Length);
        }

        bufferSize += sizeof(UNICODE_STRING) + unicodeSrcString->Length;
    }

    //
    // That's it, close up the structures.
    //
    if (ARGUMENT_PRESENT(WmiRegInfo)) {

        WmiRegInfo->NextWmiRegInfo = 0;
        WmiRegInfo->BufferSize = bufferSize;
    }

    return bufferSize;
}


NTSTATUS
ViDdiDispatchWmiQueryAllData(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the Verifier Ddi dispatch handler for the WMI IRP_MN_QUERY_ALL_DATA
    IRP.

Arguments:

    DeviceObject - Pointer to the verifier device object.

    Irp - Pointer to the incoming IRP.

Return Value:

    NTSTATUS

--*/
{
    PVFWMI_DEVICE_EXTENSION wmiDeviceExtension;
    PIO_STACK_LOCATION irpSp;
    PWNODE_HEADER wnodeHeader;
    PWNODE_ALL_DATA wmiAllData;
    PWNODE_TOO_SMALL tooSmall;
    ULONG sizeSupplied;
    ULONG offsetInstanceNameOffsets;
    ULONG instanceCount;
    ULONG dataBlockOffset;
    ULONG totalRequiredSize;
    NTSTATUS status;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if ((PDEVICE_OBJECT) irpSp->Parameters.WMI.ProviderId != DeviceObject) {

        //
        // Huh? This is a single device object legacy stack!
        //
        ASSERT(0);
        return STATUS_NOT_SUPPORTED;
    }

    if (!IS_EQUAL_GUID(irpSp->Parameters.WMI.DataPath, &GUID_VERIFIER_WMI_INTERFACE)) {

        //
        // We only support one Guid. WMI shouldn't be able to come up with
        // another...
        //
        ASSERT(0);
        return STATUS_WMI_GUID_NOT_FOUND;
    }

    wmiDeviceExtension = (PVFWMI_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    sizeSupplied = irpSp->Parameters.WMI.BufferSize;

    //
    // Not large enough, indicate the required size and fail the IRP.
    //
    if (sizeSupplied < sizeof(WNODE_TOO_SMALL)) {

        //
        // WMI must give us at least a WNODE_TOO_SMALL structure!
        //
        ASSERT(0);
        return STATUS_BUFFER_TOO_SMALL;
    }

    wmiAllData = (PWNODE_ALL_DATA) irpSp->Parameters.WMI.Buffer;
    wnodeHeader = &wmiAllData->WnodeHeader;

    //
    // These fields should already be populated by WMI...
    //
    ASSERT(wnodeHeader->Flags & WNODE_FLAG_ALL_DATA);
    ASSERT(IS_EQUAL_GUID(&wnodeHeader->Guid, &GUID_VERIFIER_WMI_INTERFACE));

    //
    // Fill in the time stamp before we lock the Irp log database.
    //
    KeQuerySystemTime(&wnodeHeader->TimeStamp);

    //
    // Lock the Irp Log Database so that we can query entries from it.
    //
    status = VfIrpLogLockDatabase(wmiDeviceExtension->SiloNumber);
    if (!NT_SUCCESS(status)) {

        return status;
    }

    status = VfIrpLogRetrieveWmiData(
        wmiDeviceExtension->SiloNumber,
        NULL,
        &offsetInstanceNameOffsets,
        &instanceCount,
        &dataBlockOffset,
        &totalRequiredSize
        );

    if (!NT_SUCCESS(status)) {

        VfIrpLogUnlockDatabase(wmiDeviceExtension->SiloNumber);
        return status;
    }

    totalRequiredSize += sizeof(WNODE_ALL_DATA);

    if (totalRequiredSize > sizeSupplied) {

        VfIrpLogUnlockDatabase(wmiDeviceExtension->SiloNumber);

        //
        // Per spec, write to a WNODE_TOO_SMALL structure into the buffer.
        // Note that the structure does *not* follow wmiAllData! Rather,
        // the same structure is interpretted two
        //
        //
        wnodeHeader->Flags |= WNODE_FLAG_TOO_SMALL;
        tooSmall = (PWNODE_TOO_SMALL) wmiAllData;
        tooSmall->SizeNeeded = totalRequiredSize;
        Irp->IoStatus.Information = sizeof(WNODE_TOO_SMALL);

        //
        // Yes, STATUS_SUCCESS is returned here. This is very asymetric when
        // compared to IRP_MN_QUERY_REGINFO_EX.
        //
        return STATUS_SUCCESS;

    } else if (instanceCount) {

        status = VfIrpLogRetrieveWmiData(
            wmiDeviceExtension->SiloNumber,
            (PUCHAR) wmiAllData,
            &offsetInstanceNameOffsets,
            &instanceCount,
            &dataBlockOffset,
            &totalRequiredSize
            );
    }

    VfIrpLogUnlockDatabase(wmiDeviceExtension->SiloNumber);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    if (instanceCount) {

        wnodeHeader->Flags |= WNODE_FLAG_ALL_DATA;
        wnodeHeader->Flags &= ~WNODE_FLAG_FIXED_INSTANCE_SIZE;
        wnodeHeader->BufferSize = totalRequiredSize;
        wmiAllData->InstanceCount = instanceCount;
        wmiAllData->DataBlockOffset = dataBlockOffset;
        wmiAllData->OffsetInstanceNameOffsets = offsetInstanceNameOffsets;

    } else {

        totalRequiredSize = sizeof(WNODE_ALL_DATA);
        wnodeHeader->BufferSize = totalRequiredSize;
        wmiAllData->InstanceCount = 0;
        wmiAllData->FixedInstanceSize = 0;
        wmiAllData->DataBlockOffset = 0;
        wmiAllData->OffsetInstanceNameOffsets = 0;
    }

    Irp->IoStatus.Information = totalRequiredSize;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfdebug.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    vfdebug.h

Abstract:

    This header contains debugging macros used by the driver verifier code.

Author:

    Adrian J. Oney (AdriaO) May 5, 2000.

Revision History:


--*/

extern ULONG VfSpewLevel;

#if DBG
#define VERIFIER_DBGPRINT(txt,level) \
{ \
    if (VfSpewLevel>(level)) { \
        DbgPrint##txt; \
    }\
}
#else
#define VERIFIER_DBGPRINT(txt,level)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfdef.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    vfdef.h

Abstract:

    This header collects together the various files neccessary to create a basic
    set of definitions for the verifier.

Author:

    Adrian J. Oney (AdriaO) Feb. 10, 2000.

Revision History:


--*/

//
// Disable W4 level warnings generated by public headers.
//

#include "vfpragma.h"

#include "ntos.h"
#include <ntverp.h>
#include "vfdebug.h"
#include "vfmacro.h"
#include "vfinit.h"
#include "vfsettings.h"
#include "vfmessage.h"
#include "vfbugcheck.h"
#include "vfprint.h"
#include "vfutil.h"
#include "vfstack.h"
#include "vfirp.h"
#include "vfirpdb.h"
#include "vfirplog.h"
#include "vfdevobj.h"
#include "vfpacket.h"
#include "halverifier.h"
#include "vfdeadlock.h"

#include "..\io\trackirp.h"
#include "..\io\sessnirp.h"

#include "..\ob\obvutil.h"
#include "..\io\iovutil.h"
#include "..\io\pnpmgr\ppvutil.h"

#include "vffilter.h"
#include "vfmajor.h"
#include "vfpnp.h"
#include "vfpower.h"
#include "vfwmi.h"
#include "vfgeneric.h"
#include "vfrandom.h"
#include "vfddi.h"

//
// For the sake of good coding practice, no macros or defines should be
// declared in this file, but rather they should be defined in seperate headers.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfdevobj.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfdevobj.c

Abstract:

    This module verifies drivers properly manage device objects.

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      05/02/2000 - Seperated out from ntos\io\trackirp.c

--*/

//
// Disable W4 level warnings generated by public headers.
//
#include "vfpragma.h"

#include "..\io\iop.h" // Includes vfdef.h

#if (( defined(_X86_) ) && ( FPO ))
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, VerifierIoAttachDeviceToDeviceStack)
#pragma alloc_text(PAGEVRFY, VerifierIoDetachDevice)
#pragma alloc_text(PAGEVRFY, VerifierIoDeleteDevice)
#pragma alloc_text(PAGEVRFY, VfDevObjPreAddDevice)
#pragma alloc_text(PAGEVRFY, VfDevObjPostAddDevice)
#pragma alloc_text(PAGEVRFY, VfDevObjAdjustFdoForVerifierFilters)
#endif


VOID
VerifierIoAttachDeviceToDeviceStack(
    IN PDEVICE_OBJECT NewDevice,
    IN PDEVICE_OBJECT ExistingDevice
    )
{
    UNREFERENCED_PARAMETER (NewDevice);

    IovUtilFlushStackCache(ExistingDevice, DATABASELOCKSTATE_HELD);
}


VOID
VerifierIoDetachDevice(
    IN PDEVICE_OBJECT LowerDevice
    )
{
    PVOID callerAddress;
    ULONG stackHash;

    if (LowerDevice->AttachedDevice == NULL) {

        if (RtlCaptureStackBackTrace(2, 1, &callerAddress, &stackHash) != 1) {

            callerAddress = NULL;
        }

        WDM_FAIL_ROUTINE((
            DCERROR_DETACH_NOT_ATTACHED,
            DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
            callerAddress,
            LowerDevice
            ));
    }

    IovUtilFlushStackCache(LowerDevice, DATABASELOCKSTATE_HELD);
}


VOID
VerifierIoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_OBJECT deviceBelow;
    PVOID callerAddress;
    ULONG stackHash;

    if (RtlCaptureStackBackTrace(2, 1, &callerAddress, &stackHash) != 1) {

        callerAddress = NULL;
    }

    //
    // ADRIAO N.B. 06/16/2000 - A good thing to do here would be to send a
    //     second remove IRP to every deleted device object that was a member
    // of a WDM device stack. Just to check.
    //
    if (IovUtilIsDeviceObjectMarked(DeviceObject, MARKTYPE_DELETED)) {

        WDM_FAIL_ROUTINE((
            DCERROR_DOUBLE_DELETION,
            DCPARAM_ROUTINE,
            callerAddress
            ));
    }

    IovUtilMarkDeviceObject(DeviceObject, MARKTYPE_DELETED);

    IovUtilGetLowerDeviceObject(DeviceObject, &deviceBelow);
    if (deviceBelow) {

        WDM_FAIL_ROUTINE((
            DCERROR_DELETE_WHILE_ATTACHED,
            DCPARAM_ROUTINE,
            callerAddress
            ));

        ObDereferenceObject(deviceBelow);
    }

    VfIrpLogDeleteDeviceLogs(DeviceObject);
}


VOID
VfDevObjPreAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType
    )
/*++

  Description:

    This routine is called before the specified driver's AddDevice has been
    invoked.

  Arguments:

     PhysicalDeviceObject - Device object at the bottom of the PnP stack.

     DriverObject - Driver object of the driver who's AddDevice has been
                    invoked.

     AddDeviceFunction - Address of the AddDevice routine.

     DevObjType - Type of device object (lower device filter, FDO, etc.)

  Return Value:

     None.

--*/
{
    VF_DEVOBJ_TYPE objType;

    UNREFERENCED_PARAMETER(AddDeviceFunction);

    if (!MmIsDriverVerifying(DriverObject)) {

        return;
    }

    if (VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_INSERT_WDM_FILTERS)) {

        if (DevObjType == VF_DEVOBJ_FDO) {

            //
            // If we are calling AddDevice for the FDO, first attempt to attach
            // a lower class filter.
            //
            objType = VF_DEVOBJ_LOWER_CLASS_FILTER;


        } else {

            objType = DevObjType;
        }

        //
        // Attach a filter, cause pain.
        //
        VfFilterAttach(PhysicalDeviceObject, objType);
    }
}


VOID
VfDevObjPostAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType,
    IN  NTSTATUS            Result
    )
/*++

  Description:

    This routine is called after the specified driver's AddDevice has been
    invoked.

  Arguments:

     PhysicalDeviceObject - Device object at the bottom of the PnP stack.

     DriverObject - Driver object of the driver who's AddDevice has been
                    invoked.

     AddDeviceFunction - Address of the AddDevice routine.

     DevObjType - Type of device object (lower device filter, FDO, etc.)

     Result - Result returned by the AddDevice Routine

  Return Value:

     None.

--*/
{
    PDEVICE_OBJECT deviceAbove, deviceBelow;
    BOOLEAN powerFailure;
    VF_DEVOBJ_TYPE objType;

    UNREFERENCED_PARAMETER(DriverObject);

    if (NT_SUCCESS(Result) &&
        VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_INSERT_WDM_FILTERS) &&
        MmIsDriverVerifying(DriverObject)) {

        if (DevObjType == VF_DEVOBJ_FDO) {

            //
            // If we've just attached an FDO, try to add a upper device filter
            // on top of it.
            //
            objType = VF_DEVOBJ_UPPER_DEVICE_FILTER;

        } else {

            objType = DevObjType;
        }

        //
        // Attach filter, cause pain.
        //
        VfFilterAttach(PhysicalDeviceObject, objType);
    }

    if (!VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_VERIFY_DO_FLAGS)) {

        return;
    }

    //
    // Take this opportunity to check the PDO.
    //
    if (!IovUtilIsDeviceObjectMarked(PhysicalDeviceObject, MARKTYPE_DEVICE_CHECKED)) {

        if ((PhysicalDeviceObject->Flags & (DO_BUFFERED_IO | DO_DIRECT_IO)) ==
            (DO_BUFFERED_IO | DO_DIRECT_IO)) {

            //
            // Both direct I/O and buffered I/O are set. These are mutually
            // exclusive.
            //
            WDM_FAIL_ROUTINE((
                DCERROR_INCONSISTANT_DO_FLAGS,
                DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                PhysicalDeviceObject->DriverObject->DriverExtension->AddDevice,
                PhysicalDeviceObject
                ));
        }

        //
        // No need to check DO_DEVICE_INITIALIZING as PDO's get them cleared
        // automagically.
        //

        IovUtilMarkDeviceObject(PhysicalDeviceObject, MARKTYPE_DEVICE_CHECKED);
    }

    powerFailure = FALSE;
    deviceBelow = PhysicalDeviceObject;
    ObReferenceObject(deviceBelow);
    while(1) {
        IovUtilGetUpperDeviceObject(deviceBelow, &deviceAbove);

        if (deviceAbove == NULL) {

            ObDereferenceObject(deviceBelow);
            break;
        }

        if (!IovUtilIsDeviceObjectMarked(deviceAbove, MARKTYPE_DEVICE_CHECKED)) {

            if ((deviceAbove->Flags & (DO_BUFFERED_IO | DO_DIRECT_IO)) ==
                (DO_BUFFERED_IO | DO_DIRECT_IO)) {

                //
                // Both direct I/O and buffered I/O are set. These are mutually
                // exclusive.
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_INCONSISTANT_DO_FLAGS,
                    DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                    AddDeviceFunction,
                    deviceAbove
                    ));
            }

            if (deviceAbove->Flags & DO_DEVICE_INITIALIZING) {

                //
                // A device didn't clear the DO_DEVICE_INITIALIZING flag during
                // AddDevice. Fail it now.
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_DO_INITIALIZING_NOT_CLEARED,
                    DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                    AddDeviceFunction,
                    deviceAbove
                    ));

                //
                // Clean up the mess.
                //
                deviceAbove->Flags &= ~DO_DEVICE_INITIALIZING;
            }

            if ((deviceBelow->Flags & DO_POWER_PAGABLE) &&
                (!(deviceAbove->Flags & DO_POWER_PAGABLE))) {

                if (!powerFailure) {

                    //
                    // We have caught a driver bug. deviceAbove didn't inherit the
                    // DO_POWER_PAGABLE flag.
                    //
                    WDM_FAIL_ROUTINE((
                        DCERROR_POWER_PAGABLE_NOT_INHERITED,
                        DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                        AddDeviceFunction,
                        deviceAbove
                        ));

                    //
                    // Don't blame anyone else.
                    //
                    powerFailure = TRUE;
                }

                deviceAbove->Flags |= DO_POWER_PAGABLE;
            }

            if ((deviceBelow->Flags & DO_BUFFERED_IO) &&
                (!(deviceAbove->Flags & DO_BUFFERED_IO))) {

                //
                // Buffered I/O flag not copied. Broken filter!
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_DO_FLAG_NOT_COPIED,
                    DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                    AddDeviceFunction,
                    deviceAbove
                    ));
            }

            if ((deviceBelow->Flags & DO_DIRECT_IO) &&
                (!(deviceAbove->Flags & DO_DIRECT_IO))) {

                //
                // Direct I/O flag not copied. Broken filter!
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_DO_FLAG_NOT_COPIED,
                    DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                    AddDeviceFunction,
                    deviceAbove
                    ));
            }

            if ((deviceBelow->DeviceType != FILE_DEVICE_UNKNOWN) &&
                (deviceAbove->DeviceType == FILE_DEVICE_UNKNOWN)) {

                //
                // The device type wasn't copied by a filter!
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_DEVICE_TYPE_NOT_COPIED,
                    DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                    AddDeviceFunction,
                    deviceAbove
                    ));
            }

            //
            // Characteristics don't have to be checked because PnP takes care
            // of propogating them appropriately.
            //
        }

        IovUtilMarkDeviceObject(deviceAbove, MARKTYPE_DEVICE_CHECKED);

        ObDereferenceObject(deviceBelow);
        deviceBelow = deviceAbove;
    }
}


VOID
VfDevObjAdjustFdoForVerifierFilters(
    IN OUT  PDEVICE_OBJECT *FunctionalDeviceObject
    )
/*++

  Description:

    This routine adjusts the designated FDO to take into account any verifier
    filter DO's added by this file.

  Arguments:

     FunctionalDeviceObject - On input, contains FDO. Adjusted to point to the
                              correct FDO if verifier added a filter.

  Return Value:

     None.

--*/
{
    PDEVICE_OBJECT fdo;

    fdo = *FunctionalDeviceObject;

    if (VfFilterIsVerifierFilterObject(fdo)) {

        fdo = fdo->AttachedDevice;
        ASSERT(fdo);

        *FunctionalDeviceObject = fdo;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vffilter.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vffilter.h

Abstract:

    This header contains prototypes for using the verifier driver filter.

Author:

    Adrian J. Oney (adriao) 12-June-2000

Environment:

    Kernel mode

Revision History:

    AdriaO      06/12/2000 - Authored

--*/

VOID
VfFilterInit(
    VOID
    );

VOID
VfFilterAttach(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject,
    IN  VF_DEVOBJ_TYPE  DeviceObjectType
    );

BOOLEAN
VfFilterIsVerifierFilterObject(
    IN  PDEVICE_OBJECT  DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfdevobj.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfdevobj.h

Abstract:

    This header exposes function hooks that verify drivers properly manage
    device objects.

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      05/02/2000 - Seperated out from ntos\io\trackirp.h

--*/

typedef enum {

    VF_DEVOBJ_PDO = 0,
    VF_DEVOBJ_BUS_FILTER,
    VF_DEVOBJ_LOWER_DEVICE_FILTER,
    VF_DEVOBJ_LOWER_CLASS_FILTER,
    VF_DEVOBJ_FDO,
    VF_DEVOBJ_UPPER_DEVICE_FILTER,
    VF_DEVOBJ_UPPER_CLASS_FILTER

} VF_DEVOBJ_TYPE, *PVF_DEVOBJ_TYPE;

VOID
VfDevObjPreAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType
    );

VOID
VfDevObjPostAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType,
    IN  NTSTATUS            Result
    );

VOID
VfDevObjAdjustFdoForVerifierFilters(
    IN OUT  PDEVICE_OBJECT *FunctionalDeviceObject
    );

VOID
VerifierIoAttachDeviceToDeviceStack(
    IN PDEVICE_OBJECT NewDevice,
    IN PDEVICE_OBJECT ExistingDevice
    );

VOID
VerifierIoDetachDevice(
    IN PDEVICE_OBJECT LowerDevice
    );

VOID
VerifierIoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vffileio.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vffileio.c

Abstract:

    This module contains code that monitors file I/O functions for misuse.

Author:

    Adrian J. Oney (adriao) 19-Dec-2000

Environment:

    Kernel mode

Revision History:

--*/

#include "vfdef.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY,VerifierNtCreateFile)
#pragma alloc_text(PAGEVRFY,VerifierNtWriteFile)
#pragma alloc_text(PAGEVRFY,VerifierNtReadFile)
#endif // ALLOC_PRAGMA


NTSTATUS
VerifierNtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    )
{
    //
    // We use VERIFIER_OPTION_TRACK_IRPS until we add a generic IOVerifier
    // setting.
    //
    if (VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_TRACK_IRPS)) {

        if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

            //
            // The driver has made a mistake. Fail it now.
            //
            WDM_FAIL_ROUTINE((
                DCERROR_FILE_IO_AT_BAD_IRQL,
                DCPARAM_ROUTINE,
                _ReturnAddress()
                ));
        }
    }

    return NtCreateFile(
        FileHandle,
        DesiredAccess,
        ObjectAttributes,
        IoStatusBlock,
        AllocationSize,
        FileAttributes,
        ShareAccess,
        CreateDisposition,
        CreateOptions,
        EaBuffer,
        EaLength
        );
}


NTSTATUS
VerifierNtWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )
{
    //
    // We use VERIFIER_OPTION_TRACK_IRPS until we add a generic IOVerifier
    // setting.
    //
    if (VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_TRACK_IRPS)) {

        if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

            //
            // The driver has made a mistake. Fail it now.
            //
            WDM_FAIL_ROUTINE((
                DCERROR_FILE_IO_AT_BAD_IRQL,
                DCPARAM_ROUTINE,
                _ReturnAddress()
                ));
        }
    }

    return NtWriteFile(
        FileHandle,
        Event,
        ApcRoutine,
        ApcContext,
        IoStatusBlock,
        Buffer,
        Length,
        ByteOffset,
        Key
        );
}


NTSTATUS
VerifierNtReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )
{
    //
    // We use VERIFIER_OPTION_TRACK_IRPS until we add a generic IOVerifier
    // setting.
    //
    if (VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_TRACK_IRPS)) {

        if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

            //
            // The driver has made a mistake. Fail it now.
            //
            WDM_FAIL_ROUTINE((
                DCERROR_FILE_IO_AT_BAD_IRQL,
                DCPARAM_ROUTINE,
                _ReturnAddress()
                ));
        }
    }

    return NtReadFile(
        FileHandle,
        Event,
        ApcRoutine,
        ApcContext,
        IoStatusBlock,
        Buffer,
        Length,
        ByteOffset,
        Key
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vffilter.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vffilter.c

Abstract:

    This module contains the verifier driver filter.

Author:

    Adrian J. Oney (adriao) 12-June-2000

Environment:

    Kernel mode

Revision History:

    AdriaO      06/12/2000 - Authored

--*/

#include "vfdef.h" // Includes vfdef.h
#include "vifilter.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, VfFilterInit)
#pragma alloc_text(PAGEVRFY, VfFilterAttach)
#pragma alloc_text(PAGEVRFY, ViFilterDriverEntry)
#pragma alloc_text(PAGEVRFY, ViFilterAddDevice)
#pragma alloc_text(PAGEVRFY, ViFilterDispatchPnp)
#pragma alloc_text(PAGEVRFY, ViFilterStartCompletionRoutine)
#pragma alloc_text(PAGEVRFY, ViFilterDeviceUsageNotificationCompletionRoutine)
#pragma alloc_text(PAGEVRFY, ViFilterDispatchPower)
#pragma alloc_text(PAGEVRFY, ViFilterDispatchGeneric)
#pragma alloc_text(PAGEVRFY, VfFilterIsVerifierFilterObject)
#endif

PDRIVER_OBJECT VfFilterDriverObject = NULL;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGEVRFC")
#endif

WCHAR VerifierFilterDriverName[] = L"\\DRIVER\\VERIFIER_FILTER";
BOOLEAN VfFilterCreated = FALSE;

VOID
VfFilterInit(
    VOID
    )
/*++

Routine Description:

    This routine initializes the driver verifier filter code.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
VfFilterAttach(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject,
    IN  VF_DEVOBJ_TYPE  DeviceObjectType
    )
/*++

Routine Description:

    This is the Verifier filter dispatch handler for PnP IRPs.

Arguments:

    PhysicalDeviceObject - Bottom of stack to attach to.

    DeviceObjectType - Type of filter the device object must simulate.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT newDeviceObject, lowerDeviceObject;
    PVERIFIER_EXTENSION verifierExtension;
    UNICODE_STRING driverString;

    if (!VfFilterCreated) {

        RtlInitUnicodeString(&driverString, VerifierFilterDriverName);

        IoCreateDriver(&driverString, ViFilterDriverEntry);

        VfFilterCreated = TRUE;
    }

    if (VfFilterDriverObject == NULL) {

        return;
    }

    switch(DeviceObjectType) {

        case VF_DEVOBJ_PDO:
            //
            // This makes no sense. We can't impersonate a PDO.
            //
            return;

        case VF_DEVOBJ_BUS_FILTER:
            //
            // We don't have the code to impersonate a bus filter yet.
            //
            return;

        case VF_DEVOBJ_LOWER_DEVICE_FILTER:
        case VF_DEVOBJ_LOWER_CLASS_FILTER:
            break;

        case VF_DEVOBJ_FDO:
            //
            // This makes no sense. We can't impersonate an FDO.
            //
            return;

        case VF_DEVOBJ_UPPER_DEVICE_FILTER:
        case VF_DEVOBJ_UPPER_CLASS_FILTER:
            break;

        default:
            //
            // We don't even know what this is!
            //
            ASSERT(0);
            return;
    }

    lowerDeviceObject = IoGetAttachedDevice(PhysicalDeviceObject);
    if (lowerDeviceObject->DriverObject == VfFilterDriverObject) {

        //
        // No need to add another filter. We are immediately below.
        //
        return;
    }

    //
    // Create a filter device object.
    //
    // (Note that FILE_DEVICE_SECURE_OPEN is not really needed here, as the
    //  FDO is the driver that should be determining how the namespace is
    //  validated. That said, this will be fixed up by the below code that
    //  copies the lower driver's characteristics to this device object. We
    //  pass in FILE_DEVICE_SECURE_OPEN just in case someone lifts this code
    //  for use elsewhere.)
    //
    status = IoCreateDevice(
        VfFilterDriverObject,
        sizeof(VERIFIER_EXTENSION),
        NULL,  // No Name
        FILE_DEVICE_UNKNOWN,
        FILE_DEVICE_SECURE_OPEN,
        FALSE,
        &newDeviceObject
        );

    if (!NT_SUCCESS(status)) {

        return;
    }

    verifierExtension = (PVERIFIER_EXTENSION) newDeviceObject->DeviceExtension;

    verifierExtension->LowerDeviceObject = IoAttachDeviceToDeviceStack(
        newDeviceObject,
        PhysicalDeviceObject
        );

    //
    // Failure for attachment is an indication of a broken plug & play system.
    //
    if (verifierExtension->LowerDeviceObject == NULL) {

        IoDeleteDevice(newDeviceObject);
        return;
    }

    newDeviceObject->Flags |= verifierExtension->LowerDeviceObject->Flags &
        (DO_BUFFERED_IO | DO_DIRECT_IO | DO_POWER_PAGABLE  | DO_POWER_INRUSH);

    newDeviceObject->DeviceType = verifierExtension->LowerDeviceObject->DeviceType;

    newDeviceObject->Characteristics =
        verifierExtension->LowerDeviceObject->Characteristics;

    verifierExtension->Self = newDeviceObject;
    verifierExtension->PhysicalDeviceObject = PhysicalDeviceObject;

    newDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
}


NTSTATUS
ViFilterDriverEntry(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     RegistryPath
    )
/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    Verifier filter Object.  In this function, we need to remember the
    DriverObject.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - is NULL.

Return Value:

   STATUS_SUCCESS

--*/
{
    ULONG i;

    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // File the pointer to our driver object away
    //
    VfFilterDriverObject = DriverObject;

    //
    // Fill in the driver object
    //
    DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE) ViFilterAddDevice;

    //
    // Most IRPs are simply pass though
    //
    for(i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = ViFilterDispatchGeneric;
    }

    //
    // PnP and Power IRPs are of course trickier.
    //
    DriverObject->MajorFunction[IRP_MJ_PNP]   = ViFilterDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = ViFilterDispatchPower;

    return STATUS_SUCCESS;
}


NTSTATUS
ViFilterAddDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )
/*++

Routine Description:

    This is the AddDevice callback function exposed by the verifier filter
    object. It should never be invoked by the operating system.

Arguments:

    DriverObject - Pointer to the verifier filter driver object.

    PhysicalDeviceObject - Stack PnP wishes to attach this driver too.

Return Value:

   NTSTATUS

--*/
{
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(PhysicalDeviceObject);

    //
    // We should never get here!
    //
    ASSERT(0);
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
ViFilterDispatchPnp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the Verifier filter dispatch handler for PnP IRPs.

Arguments:

    DeviceObject - Pointer to the verifier device object.

    Irp - Pointer to the incoming IRP.

Return Value:

    NTSTATUS

--*/
{
    PVERIFIER_EXTENSION verifierExtension;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT lowerDeviceObject;
    NTSTATUS status;

    verifierExtension = (PVERIFIER_EXTENSION) DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    lowerDeviceObject = verifierExtension->LowerDeviceObject;

    switch(irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            IoCopyCurrentIrpStackLocationToNext(Irp);

            IoSetCompletionRoutine(
                Irp,
                ViFilterStartCompletionRoutine,
                NULL,
                TRUE,
                TRUE,
                TRUE
                );

            return IoCallDriver(lowerDeviceObject, Irp);

        case IRP_MN_REMOVE_DEVICE:

            IoCopyCurrentIrpStackLocationToNext(Irp);
            status = IoCallDriver(lowerDeviceObject, Irp);

            IoDetachDevice(lowerDeviceObject);
            IoDeleteDevice(DeviceObject);
            return status;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:

            //
            // On the way down, pagable might become set. Mimic the driver
            // above us. If no one is above us, just set pagable.
            //
            if ((DeviceObject->AttachedDevice == NULL) ||
                (DeviceObject->AttachedDevice->Flags & DO_POWER_PAGABLE)) {

                DeviceObject->Flags |= DO_POWER_PAGABLE;
            }

            IoCopyCurrentIrpStackLocationToNext(Irp);

            IoSetCompletionRoutine(
                Irp,
                ViFilterDeviceUsageNotificationCompletionRoutine,
                NULL,
                TRUE,
                TRUE,
                TRUE
                );

            return IoCallDriver(lowerDeviceObject, Irp);
    }

    IoCopyCurrentIrpStackLocationToNext(Irp);
    return IoCallDriver(lowerDeviceObject, Irp);
}


NTSTATUS
ViFilterStartCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PVERIFIER_EXTENSION verifierExtension;

    UNREFERENCED_PARAMETER(Context);

    if (Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    verifierExtension = (PVERIFIER_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Inherit FILE_REMOVABLE_MEDIA during Start. This characteristic didn't
    // make a clean transition from NT4 to NT5 because it wasn't available
    // until the driver stack is started! Even worse, drivers *examine* this
    // characteristic during start as well.
    //
    if (verifierExtension->LowerDeviceObject->Characteristics & FILE_REMOVABLE_MEDIA) {

        DeviceObject->Characteristics |= FILE_REMOVABLE_MEDIA;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ViFilterDeviceUsageNotificationCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PVERIFIER_EXTENSION verifierExtension;

    UNREFERENCED_PARAMETER(Context);

    if (Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    verifierExtension = (PVERIFIER_EXTENSION) DeviceObject->DeviceExtension;

    //
    // On the way up, pagable might become clear. Mimic the driver below us.
    //
    if (!(verifierExtension->LowerDeviceObject->Flags & DO_POWER_PAGABLE)) {

        DeviceObject->Flags &= ~DO_POWER_PAGABLE;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ViFilterDispatchPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the Verifier filter dispatch handler for Power IRPs.

Arguments:

    DeviceObject - Pointer to the verifier device object.

    Irp - Pointer to the incoming IRP.

Return Value:

   NTSTATUS

--*/
{
    PVERIFIER_EXTENSION verifierExtension;

    verifierExtension = (PVERIFIER_EXTENSION) DeviceObject->DeviceExtension;

    PoStartNextPowerIrp(Irp);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    return PoCallDriver(verifierExtension->LowerDeviceObject, Irp);
}


NTSTATUS
ViFilterDispatchGeneric(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This is the Verifier filter dispatch handler for generic IRPs.

Arguments:

    DeviceObject - Pointer to the verifier device object.

    Irp - Pointer to the incoming IRP.

Return Value:

    NTSTATUS

--*/
{
    PVERIFIER_EXTENSION verifierExtension;

    verifierExtension = (PVERIFIER_EXTENSION) DeviceObject->DeviceExtension;

    IoCopyCurrentIrpStackLocationToNext(Irp);
    return IoCallDriver(verifierExtension->LowerDeviceObject, Irp);
}


BOOLEAN
VfFilterIsVerifierFilterObject(
    IN  PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    This determines whether the passed in device object is a verifier DO.

Arguments:

    DeviceObject - Pointer to the device object to check.

Return Value:

    TRUE/FALSE

--*/
{
    return (BOOLEAN) (DeviceObject->DriverObject->MajorFunction[IRP_MJ_PNP] == ViFilterDispatchPnp);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfgeneric.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfgeneric.h

Abstract:

    This header contains prototypes for verifying generic IRPs are handled
    correctly.

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      06/15/2000 - Seperated out from ntos\io\flunkirp.h

--*/

VOID
VfGenericInit(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfgeneric.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfgeneric.c

Abstract:

    This module handles generic Irp verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

     AdriaO      06/15/2000 - Seperated out from ntos\io\flunkirp.c

--*/

#include "vfdef.h"
#include "vigeneric.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,     VfGenericInit)
#pragma alloc_text(PAGEVRFY, ViGenericDumpIrpStack)
#pragma alloc_text(PAGEVRFY, ViGenericVerifyNewRequest)
#pragma alloc_text(PAGEVRFY, ViGenericVerifyIrpStackDownward)
#pragma alloc_text(PAGEVRFY, ViGenericVerifyIrpStackUpward)
#pragma alloc_text(PAGEVRFY, ViGenericIsValidIrpStatus)
#pragma alloc_text(PAGEVRFY, ViGenericIsNewRequest)
#pragma alloc_text(PAGEVRFY, ViGenericVerifyNewIrp)
#pragma alloc_text(PAGEVRFY, ViGenericVerifyFinalIrpStack)
#pragma alloc_text(PAGEVRFY, ViGenericBuildIrpLogEntry)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGEVRFC")
#endif

const PCHAR IrpMajorNames[] = {
    "IRP_MJ_CREATE",                          // 0x00
    "IRP_MJ_CREATE_NAMED_PIPE",               // 0x01
    "IRP_MJ_CLOSE",                           // 0x02
    "IRP_MJ_READ",                            // 0x03
    "IRP_MJ_WRITE",                           // 0x04
    "IRP_MJ_QUERY_INFORMATION",               // 0x05
    "IRP_MJ_SET_INFORMATION",                 // 0x06
    "IRP_MJ_QUERY_EA",                        // 0x07
    "IRP_MJ_SET_EA",                          // 0x08
    "IRP_MJ_FLUSH_BUFFERS",                   // 0x09
    "IRP_MJ_QUERY_VOLUME_INFORMATION",        // 0x0a
    "IRP_MJ_SET_VOLUME_INFORMATION",          // 0x0b
    "IRP_MJ_DIRECTORY_CONTROL",               // 0x0c
    "IRP_MJ_FILE_SYSTEM_CONTROL",             // 0x0d
    "IRP_MJ_DEVICE_CONTROL",                  // 0x0e
    "IRP_MJ_INTERNAL_DEVICE_CONTROL",         // 0x0f
    "IRP_MJ_SHUTDOWN",                        // 0x10
    "IRP_MJ_LOCK_CONTROL",                    // 0x11
    "IRP_MJ_CLEANUP",                         // 0x12
    "IRP_MJ_CREATE_MAILSLOT",                 // 0x13
    "IRP_MJ_QUERY_SECURITY",                  // 0x14
    "IRP_MJ_SET_SECURITY",                    // 0x15
    "IRP_MJ_POWER",                           // 0x16
    "IRP_MJ_SYSTEM_CONTROL",                  // 0x17
    "IRP_MJ_DEVICE_CHANGE",                   // 0x18
    "IRP_MJ_QUERY_QUOTA",                     // 0x19
    "IRP_MJ_SET_QUOTA",                       // 0x1a
    "IRP_MJ_PNP",                             // 0x1b
    NULL
    };

#define MAX_NAMED_MAJOR_IRPS   0x1b

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


VOID
VfGenericInit(
    VOID
    )
{
    VfMajorRegisterHandlers(
        IRP_MJ_ALL_MAJORS,
        ViGenericDumpIrpStack,
        ViGenericVerifyNewRequest,
        ViGenericVerifyIrpStackDownward,
        ViGenericVerifyIrpStackUpward,
        NULL,
        NULL,
        ViGenericIsValidIrpStatus,
        ViGenericIsNewRequest,
        ViGenericVerifyNewIrp,
        ViGenericVerifyFinalIrpStack,
        NULL,
        ViGenericBuildIrpLogEntry
        );
}


VOID
FASTCALL
ViGenericDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    )
{
    if ((IrpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL)&&(IrpSp->MinorFunction == IRP_MN_SCSI_CLASS)) {

         DbgPrint("IRP_MJ_SCSI");

    } else if (IrpSp->MajorFunction<=MAX_NAMED_MAJOR_IRPS) {

         DbgPrint(IrpMajorNames[IrpSp->MajorFunction]);

    } else if (IrpSp->MajorFunction==0xFF) {

         DbgPrint("IRP_MJ_BOGUS");

    } else {

         DbgPrint("IRP_MJ_??");
    }
}


VOID
FASTCALL
ViGenericVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    )
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (IrpLastSp);
    UNREFERENCED_PARAMETER (StackLocationData);

    if (!VfSettingsIsOptionEnabled(IovPacket->VerifierSettings, VERIFIER_OPTION_PROTECT_RESERVED_IRPS)) {

        return;
    }

    if ((IovPacket->Flags&TRACKFLAG_IO_ALLOCATED)&&
        (!(IovPacket->Flags&TRACKFLAG_WATERMARKED))) {

        if (VfMajorIsSystemRestrictedIrp(IrpSp)) {

            //
            // We've caught somebody initiating an IRP they shouldn't be sending!
            //
            WDM_FAIL_ROUTINE((
                DCERROR_RESTRICTED_IRP,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                CallerAddress,
                IovPacket->TrackedIrp
                ));
        }
    }
}


VOID
FASTCALL
ViGenericVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    )
{
    PIRP irp = IovPacket->TrackedIrp;
    NTSTATUS currentStatus, lastStatus;
    BOOLEAN newRequest, statusChanged, infoChanged, firstRequest;
    PIOV_SESSION_DATA iovSessionData;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (StackLocationData);


    currentStatus = irp->IoStatus.Status;
    lastStatus = RequestHeadLocationData->LastStatusBlock.Status;
    statusChanged = (BOOLEAN)(currentStatus != lastStatus);
    infoChanged = (BOOLEAN)(irp->IoStatus.Information != RequestHeadLocationData->LastStatusBlock.Information);
    firstRequest = (BOOLEAN)((RequestHeadLocationData->Flags&STACKFLAG_FIRST_REQUEST) != 0);
    iovSessionData = VfPacketGetCurrentSessionData(IovPacket);

    //
    // Do we have a "new" function to process?
    //
    newRequest = VfMajorIsNewRequest(IrpLastSp, IrpSp);

    //
    // Verify IRQL's are legal
    //
    switch(IrpSp->MajorFunction) {

        case IRP_MJ_POWER:
        case IRP_MJ_READ:
        case IRP_MJ_WRITE:
        case IRP_MJ_DEVICE_CONTROL:
        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            break;
        default:
            if (iovSessionData->ForwardMethod != FORWARDED_TO_NEXT_DO) {
                break;
            }

            if ((IovPacket->DepartureIrql >= DISPATCH_LEVEL) &&
                (!(IovPacket->Flags & TRACKFLAG_PASSED_AT_BAD_IRQL))) {

                WDM_FAIL_ROUTINE((
                    DCERROR_DISPATCH_CALLED_AT_BAD_IRQL,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    CallerAddress,
                    irp
                    ));

                IovPacket->Flags |= TRACKFLAG_PASSED_AT_BAD_IRQL;
            }
    }

    //
    // The following is only executed if we are not a new IRP...
    //
    if (IrpLastSp == NULL) {
        return;
    }

    //
    // Let's verify bogus IRPs haven't been touched...
    //
    if ((IovPacket->Flags&TRACKFLAG_BOGUS) &&
        (!(RequestHeadLocationData->Flags&STACKFLAG_BOGUS_IRP_TOUCHED))) {

        if (newRequest && (!firstRequest)) {

            RequestHeadLocationData->Flags |= STACKFLAG_BOGUS_IRP_TOUCHED;

            WDM_FAIL_ROUTINE((
                DCERROR_BOGUS_FUNC_TRASHED,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                CallerAddress,
                irp
                ));
        }

        if (statusChanged) {

            RequestHeadLocationData->Flags |= STACKFLAG_BOGUS_IRP_TOUCHED;

            if (IrpSp->MinorFunction == 0xFF) {

                WDM_FAIL_ROUTINE((
                    DCERROR_BOGUS_MINOR_STATUS_TRASHED,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    CallerAddress,
                    irp
                    ));

            } else {

                WDM_FAIL_ROUTINE((
                    DCERROR_BOGUS_STATUS_TRASHED,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    CallerAddress,
                    irp
                    ));
            }
        }

        if (infoChanged) {

            RequestHeadLocationData->Flags |= STACKFLAG_BOGUS_IRP_TOUCHED;

            WDM_FAIL_ROUTINE((
                DCERROR_BOGUS_INFO_TRASHED,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                CallerAddress,
                irp
                ));
        }
    }

    if (!VfMajorIsValidIrpStatus(IrpSp, currentStatus)) {

        WDM_FAIL_ROUTINE((
            DCERROR_INVALID_STATUS,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            CallerAddress,
            irp
            ));
    }
}


VOID
FASTCALL
ViGenericVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    )
{
    PIRP irp;
    NTSTATUS currentStatus;
    BOOLEAN statusChanged, infoChanged;
    PVOID routine;

    UNREFERENCED_PARAMETER (IsNewlyCompleted);
    UNREFERENCED_PARAMETER (RequestFinalized);

    irp = IovPacket->TrackedIrp;
    currentStatus = irp->IoStatus.Status;

    //
    // Who'd we call for this one?
    //
    routine = StackLocationData->LastDispatch;
    ASSERT(routine) ;

    //
    // Did they touch something stupid?
    //
    if ((IovPacket->Flags&TRACKFLAG_BOGUS) &&
        (!(RequestHeadLocationData->Flags&STACKFLAG_BOGUS_IRP_TOUCHED))) {

        statusChanged = (BOOLEAN)(currentStatus != RequestHeadLocationData->LastStatusBlock.Status);

        if (statusChanged) {

            RequestHeadLocationData->Flags |= STACKFLAG_BOGUS_IRP_TOUCHED;

            if (IrpSp->MinorFunction == 0xFF) {

                WDM_FAIL_ROUTINE((
                    DCERROR_BOGUS_MINOR_STATUS_TRASHED,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    routine,
                    irp
                    ));

            } else {

                WDM_FAIL_ROUTINE((
                    DCERROR_BOGUS_STATUS_TRASHED,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    routine,
                    irp
                    ));
            }
        }

        infoChanged = (BOOLEAN)(irp->IoStatus.Information != RequestHeadLocationData->LastStatusBlock.Information);
        if (infoChanged) {

            RequestHeadLocationData->Flags |= STACKFLAG_BOGUS_IRP_TOUCHED;

            WDM_FAIL_ROUTINE((
                DCERROR_BOGUS_INFO_TRASHED,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                routine,
                irp
                ));
        }
    }

    if (!VfMajorIsValidIrpStatus(IrpSp, currentStatus)) {

        WDM_FAIL_ROUTINE(
            (DCERROR_INVALID_STATUS, DCPARAM_IRP + DCPARAM_ROUTINE, routine, irp)
            );
    }

    //
    // Check for leaked Cancel routines.
    //
    if (irp->CancelRoutine) {

        if (VfSettingsIsOptionEnabled(IovPacket->VerifierSettings, VERIFIER_OPTION_VERIFY_CANCEL_LOGIC)) {

            WDM_FAIL_ROUTINE((
                DCERROR_CANCELROUTINE_AFTER_COMPLETION,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                routine,
                irp
                ));
        }
    }
}


BOOLEAN
FASTCALL
ViGenericIsValidIrpStatus(
    IN PIO_STACK_LOCATION   IrpSp,
    IN NTSTATUS             Status
    )
/*++

    Description:
        As per the title, this function determines whether an IRP status is
        valid or probably random trash. See NTStatus.h for info on how status
        codes break down...

    Returns:

        TRUE iff IRP status looks to be valid. FALSE otherwise.
--*/
{
    ULONG severity;
    ULONG customer;
    ULONG reserved;
    ULONG facility;
    ULONG code;
    ULONG lanManClass;

    UNREFERENCED_PARAMETER (IrpSp);

    severity = (((ULONG)Status) >> 30)&3;
    customer = (((ULONG)Status) >> 29)&1;
    reserved = (((ULONG)Status) >> 28)&1;
    facility = (((ULONG)Status) >> 16)&0xFFF;
    code =     (((ULONG)Status) & 0xFFFF);

    //
    // If reserved set, definitely bogus...
    //
    if (reserved) {

        return FALSE;
    }

    //
    // Is this a microsoft defined return code? If not, do no checking.
    //
    if (customer) {

        return TRUE;
    }

    //
    // ADRIAO N.B. 10/04/1999 -
    //     The current methodology for doling out error codes appears to be
    // fairly chaotic. The primary kernel mode status codes are defined in
    // ntstatus.h. However, rtl\generr.c should also be consulted to see which
    // error codes can bubble up to user mode. Many OLE error codes from
    // winerror.h are now being used within the kernel itself.
    //
    if (facility < 0x20) {

        //
        // Facilities under 20 are currently legal.
        //
        switch(severity) {

            case STATUS_SEVERITY_SUCCESS:
                return (BOOLEAN)(code < 0x200);

            case STATUS_SEVERITY_INFORMATIONAL:

                //
                // ADRIAO N.B. 06/27/2000
                //     This test could be tighter (a little over 0x50)
                //
                return (BOOLEAN)(code < 0x400);

            case STATUS_SEVERITY_WARNING:

                //
                // FACILITY_WIN32 is 7. All Win32 codes are valid.
                //
                return (BOOLEAN) ((facility == 7) || (code < 0x400));

            case STATUS_SEVERITY_ERROR:
                break;
        }

        //
        // Why the heck does WOW use such an odd error code?
        //
        return (BOOLEAN)((code < 0x500)||(code == 0x9898));

    } else if (facility == 0x98) {

        //
        // This is the lan manager service. In the case on Lan Man, the code
        // field is further subdivided into a class field.
        //
        lanManClass = code >> 12;
        code &= 0xFFF;

        //
        // Do no testing here.
        //
        return TRUE;

    } else {

        //
        // Not known, probably bogus.
        //
        return FALSE;
    }
}


BOOLEAN
FASTCALL
ViGenericIsNewRequest(
    IN PIO_STACK_LOCATION   IrpLastSp OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp
    )
/*++

  Description:

     Determines whether the two Irp stacks refer to the same "request",
     ie starting the same device, etc. This is used to detect whether an IRP
     has been simply forwarded or rather the IRP has been reused to initiate
     a new request.

  Arguments:

     The two IRP stacks to compare.

     N.B. - the device object is not currently part of those IRP stacks.

  Return Value:

     TRUE if the stacks represent the same request, FALSE otherwise.

--*/
{
    return (BOOLEAN)((IrpLastSp==NULL)||
        (IrpSp->MajorFunction != IrpLastSp->MajorFunction) ||
        (IrpSp->MinorFunction != IrpLastSp->MinorFunction));
}


VOID
FASTCALL
ViGenericVerifyNewIrp(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    )
{
    LONG                index;
    PIO_STACK_LOCATION  irpSp;
    BOOLEAN             queuesApc;

    UNREFERENCED_PARAMETER (IrpSp);
    UNREFERENCED_PARAMETER (StackLocationData);

    if (Irp->UserIosb || Irp->UserEvent) {

        //
        // We have an IRP with user buffer data. This kind of IRP must be
        // initiated at PASSIVE_LEVEL lest the APC that signals the event gets
        // held up by fast mutex.
        //
        queuesApc = (BOOLEAN)
            (!((Irp->Flags & (IRP_PAGING_IO | IRP_CLOSE_OPERATION)) &&
            (Irp->Flags & (IRP_SYNCHRONOUS_PAGING_IO | IRP_CLOSE_OPERATION))));

        if (queuesApc) {

            //
            // The caller may be using the UserIosb for storage, and may really
            // free the IRP in a completion routine. Look for one now.
            //
            irpSp = IoGetNextIrpStackLocation(Irp);
            for(index = Irp->CurrentLocation-1;
                index <= Irp->StackCount;
                index++) {

                if (irpSp->CompletionRoutine != NULL) {

                    queuesApc = FALSE;
                    break;
                }
                irpSp++;
            }
        }

        if (queuesApc && (IovPacket->DepartureIrql > PASSIVE_LEVEL)) {

            WDM_FAIL_ROUTINE((
                DCERROR_DISPATCH_CALLED_AT_BAD_IRQL,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                CallerAddress,
                Irp
                ));
        }
    }
}


VOID
FASTCALL
ViGenericVerifyFinalIrpStack(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp
    )
{
    UNREFERENCED_PARAMETER(IovPacket);
    UNREFERENCED_PARAMETER(IrpSp);

    ASSERT(!IovPacket->RefTrackingCount);
}


LOGICAL
FASTCALL
ViGenericBuildIrpLogEntry(
    IN  PIRP                Irp,
    IN  ULONG               CurrentCount,
    IN  PIRPLOG_SNAPSHOT    CurrentEntryArray,
    OUT PIRPLOG_SNAPSHOT    IrpSnapshot
    )
{
    PIO_STACK_LOCATION irpSp;

    UNREFERENCED_PARAMETER(CurrentCount);
    UNREFERENCED_PARAMETER(CurrentEntryArray);

    irpSp = IoGetNextIrpStackLocation(Irp);

    switch(irpSp->MajorFunction) {

        case IRP_MJ_DEVICE_CONTROL:
            IrpSnapshot->Count = 1;
            IrpSnapshot->MajorFunction = irpSp->MajorFunction;
            IrpSnapshot->MinorFunction = irpSp->MinorFunction;
            IrpSnapshot->Flags = irpSp->Flags;
            IrpSnapshot->Control = irpSp->Control;
            IrpSnapshot->ArgArray[0] = (ULONGLONG) irpSp->Parameters.Others.Argument1;
            IrpSnapshot->ArgArray[1] = (ULONGLONG) irpSp->Parameters.Others.Argument2;
            IrpSnapshot->ArgArray[2] = (ULONGLONG) irpSp->Parameters.Others.Argument3;
            IrpSnapshot->ArgArray[3] = (ULONGLONG) irpSp->Parameters.Others.Argument4;
            return TRUE;

        default:
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfinit.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfinit.h

Abstract:

    This header exposes the routines neccessary to initialize the driver verifier.

Author:

    Adrian J. Oney (adriao) 1-Mar-2000

Environment:

    Kernel mode

Revision History:

--*/

VOID
FASTCALL
VfInitVerifier(
    IN  ULONG   MmFlags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfinit.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfinit.c

Abstract:

    This module handles initialization of the driver verifier.

Author:

    Adrian J. Oney (adriao) 1-Mar-2000

Environment:

    Kernel mode

Revision History:

--*/

#include "vfdef.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, VfInitVerifier)
#endif // ALLOC_PRAGMA

VOID
FASTCALL
VfInitVerifier(
    IN  ULONG   MmFlags
    )
/*++

Routine Description:

    This routine is called to initialize the driver verifier.

Parameters:

    None.

Return Value:

    None.

--*/
{
    //
    // Initialize the verifier code
    //
    VfSettingsInit(MmFlags);
    VfRandomInit();
    VfBugcheckInit();
    VfIrpDatabaseInit();
    VfIrpInit();
    VfMajorInit();
    VfPnpInit();
    VfPowerInit();
    VfWmiInit();
    VfGenericInit();
    VfHalVerifierInitialize();
    VfFilterInit();
    VfIrpLogInit();
    VfDdiInit();

    //
    // Connect up with the remainder of the kernel
    //
    IovUtilInit();
    PpvUtilInit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfipacket.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfipacket.h

Abstract:

    This header contains private prototypes used in managing the verifier
    packet data that tracks IRPs. It should be included by vfpacket.c only.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      05/02/2000 - Seperated out from ntos\io\hashirp.h

--*/

VOID
FASTCALL
VfpPacketFree(
    IN  PIOV_REQUEST_PACKET     IovPacket
    );

VOID
VfpPacketNotificationCallback(
    IN  PIOV_DATABASE_HEADER    IovHeader,
    IN  PIRP                    TrackedIrp  OPTIONAL,
    IN  IRP_DATABASE_EVENT      Event
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfirp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfirp.c

Abstract:

    This module contains functions used to manage IRPs used in the verification
    process.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      05/02/2000 - Seperated out from ntos\io\hashirp.c

--*/

#include "vfdef.h"
#include "viirp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,     VfIrpInit)
#pragma alloc_text(PAGEVRFY, VfIrpReserveCallStackData)
#pragma alloc_text(PAGEVRFY, VfIrpPrepareAllocaCallStackData)
#pragma alloc_text(PAGEVRFY, VfIrpReleaseCallStackData)
#pragma alloc_text(PAGEVRFY, VfIrpAllocate)
#pragma alloc_text(PAGEVRFY, ViIrpAllocateLockedPacket)
#pragma alloc_text(PAGEVRFY, VfIrpMakeTouchable)
#pragma alloc_text(PAGEVRFY, VfIrpMakeUntouchable)
#pragma alloc_text(PAGEVRFY, VfIrpFree)
#pragma alloc_text(PAGEVRFY, VerifierIoAllocateIrp1)
#pragma alloc_text(PAGEVRFY, VerifierIoAllocateIrp2)
#pragma alloc_text(PAGEVRFY, VerifierIoFreeIrp)
#pragma alloc_text(PAGEVRFY, VerifierIoInitializeIrp)
#pragma alloc_text(PAGEVRFY, VfIrpSendSynchronousIrp)
#pragma alloc_text(PAGEVRFY, ViIrpSynchronousCompletionRoutine)
#pragma alloc_text(PAGEVRFY, VfIrpWatermark)
#endif

#define POOL_TAG_PROTECTED_IRP      '+prI'
#define POOL_TAG_CALL_STACK_DATA    'CprI'

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEVRFD")
#endif

NPAGED_LOOKASIDE_LIST ViIrpCallStackDataList;

VOID
FASTCALL
VfIrpInit(
    VOID
    )
/*++

Description:

    This routine initializes IRP tracking support for the verifier.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ExInitializeNPagedLookasideList(
        &ViIrpCallStackDataList,
        NULL,
        NULL,
        0,
        sizeof(IOFCALLDRIVER_STACKDATA),
        POOL_TAG_CALL_STACK_DATA,
        0
        );
}


BOOLEAN
FASTCALL
VfIrpReserveCallStackData(
    IN  PIRP                            Irp,
    OUT PIOFCALLDRIVER_STACKDATA       *IofCallDriverStackData
    )
/*++

Description:

    This routine reserves call stack data for IovCallDriver.

Arguments:

    Irp - Contains IRP the call stack data is being reserved for.

    IofCallDriverStackData - Receives allocated call stack data, NULL if
                             insufficient memory.

Return Value:

    TRUE if either the allocation was successful, or it failed but is
         noncritical. If FALSE, memory should be allocated on the stack to
         support the request.

--*/
{
    PIOFCALLDRIVER_STACKDATA newCallStackData;

    newCallStackData = ExAllocateFromNPagedLookasideList(&ViIrpCallStackDataList);

    *IofCallDriverStackData = newCallStackData;

    if (newCallStackData == NULL) {

        //
        // We're low on memory, test the IRP to see if it's critical. If not,
        // the IRP will be tainted so we ignore it forever after.
        //
        return (!IovpCheckIrpForCriticalTracking(Irp));
    };

    //
    // Use the alloca initialization function here and then adjust the flags
    // accordingly.
    //
    VfIrpPrepareAllocaCallStackData(newCallStackData);
    newCallStackData->Flags |= CALLFLAG_STACK_DATA_ALLOCATED;
    return TRUE;
}


VOID
FASTCALL
VfIrpPrepareAllocaCallStackData(
    OUT PIOFCALLDRIVER_STACKDATA        IofCallDriverStackData
    )
/*++

Description:

    This routine initializes call stack data allocated on the stack.

Arguments:

    IofCallDriverStackData - Call stack data to initialize (from stack).

Return Value:

    None.

  Note: This initializer is also called by VfIrpReserveCallStackData in case
        of a successful pool allocation. In this case flags are later adjusted.

--*/
{
    //
    // Preinitialize the CallStackData.
    //
    RtlZeroMemory(IofCallDriverStackData, sizeof(IOFCALLDRIVER_STACKDATA));
}


VOID
FASTCALL
VfIrpReleaseCallStackData(
    IN  PIOFCALLDRIVER_STACKDATA        IofCallDriverStackData  OPTIONAL
    )
/*++

Description:

    This routine releases call stack data if it was allocated from pool. If the
    memory was allocated from the stack, this function does nothing.

Arguments:

    IofCallDriverStackData - Call stack data to free.

Return Value:

    None.

--*/
{
    if (IofCallDriverStackData &&
        (IofCallDriverStackData->Flags & CALLFLAG_STACK_DATA_ALLOCATED)) {

        ExFreeToNPagedLookasideList(
            &ViIrpCallStackDataList,
            IofCallDriverStackData
            );
    }
}


/*
 * The 4 routines listed below -
 *   VfIrpAllocate
 *   VfIrpMakeTouchable
 *   VfIrpMakeUntouchable
 *   VfIrpFree
 *
 * - handle management of the replacement IRP. Specifically, we want to be
 * able to allocate a set of non-paged bytes we can remove the backing
 * physical memory from, and release the virtual addresses for later (we
 * are essentially breaking free into it's two components). We do this with
 * help from the special pool.
 *
 */

PIRP
FASTCALL
VfIrpAllocate(
    IN  CCHAR       StackSize
    )
/*++

  Description:

    This routine allocates an IRP from the special pool using the
    "replacement IRP" tag.

  Arguments:

     StackSize - Number of stack locations to give the new IRP

  Return Value:

     Pointer to the memory allocated.

--*/
{
    PIRP pIrp;
    ULONG_PTR irpPtr;
    SIZE_T sizeOfAllocation;

    //
    // We are allocating an IRP from the special pool. Since IRPs may come from
    // lookaside lists they may be ULONG aligned. The memory manager on the
    // other hand gaurentees quad-aligned allocations. So to catch all special
    // pool overrun bugs we "skew" the IRP right up to the edge.
    //
    sizeOfAllocation = IoSizeOfIrp(StackSize);

    ASSERT((sizeOfAllocation % (sizeof(ULONG))) == 0);

    irpPtr = (ULONG_PTR) ExAllocatePoolWithTagPriority(
        NonPagedPool,
        sizeOfAllocation,
        POOL_TAG_PROTECTED_IRP,
        HighPoolPrioritySpecialPoolOverrun
        );

    pIrp = (PIRP) (irpPtr);

    return pIrp;
}


VOID
FASTCALL
ViIrpAllocateLockedPacket(
    IN      CCHAR               StackSize,
    IN      BOOLEAN             ChargeQuota,
    OUT     PIOV_REQUEST_PACKET *IovPacket
    )
/*++

  Description:

    This routine allocates an IRP tracked by the verifier. The IRP is allocated
    from the special pool and is initialized appropriately. Caller must call
    VfPacketReleaseLock to release the lock.

  Arguments:

    StackSize              - Count of stack locations to allocate for this IRP.

    ChargeQuote            - TRUE if quote should be charged against the current
                             thread.

    IovPacket              - Receives verifier request packet (the IRP is
                             then IovPacket->TrackedIrp), or NULL on error.

  Return Value:

    None.

--*/
{
    PIOV_REQUEST_PACKET iovNewPacket;
    PIRP irp;
    NTSTATUS status;
    ULONG quotaCharge;
    PEPROCESS quotaProcess;

    *IovPacket = NULL;

    irp = VfIrpAllocate(StackSize);

    if (irp == NULL) {

        return;
    }

    //
    // Make compiler happy and void warning for variable used without being
    // initialized even if it is not true.
    //

    quotaCharge = 0;
    quotaProcess = NULL;

    if (ChargeQuota) {

        quotaCharge = PAGE_SIZE;
        quotaProcess = PsGetCurrentProcess();

        status = PsChargeProcessNonPagedPoolQuota(
            quotaProcess,
            quotaCharge
            );

        if (!NT_SUCCESS(status)) {

            VfIrpFree(irp);
            return;
        }
    }

    //
    // Call this before the IRP has a packet associated with it!
    //
    IoInitializeIrp(irp, IoSizeOfIrp(StackSize), StackSize);

    iovNewPacket = VfPacketCreateAndLock(irp);

    if (iovNewPacket == NULL) {

        VfIrpFree(irp);

        if (ChargeQuota) {

            PsReturnProcessNonPagedPoolQuota(
                quotaProcess,
                quotaCharge
                );
        }

        return;
    }

    iovNewPacket->Flags |= TRACKFLAG_PROTECTEDIRP | TRACKFLAG_IO_ALLOCATED;
    VfPacketReference(iovNewPacket, IOVREFTYPE_POINTER);

    irp->Flags |= IRPFLAG_EXAMINE_TRACKED;
    irp->AllocationFlags |= IRP_ALLOCATION_MONITORED;
    if (ChargeQuota) {

        irp->AllocationFlags |= IRP_QUOTA_CHARGED;

        iovNewPacket->QuotaCharge = quotaCharge;
        iovNewPacket->QuotaProcess = quotaProcess;
        ObReferenceObject(quotaProcess);
    }

    *IovPacket = iovNewPacket;
}


VOID
FASTCALL
VfIrpMakeUntouchable(
    IN  PIRP    Irp     OPTIONAL
    )
/*++

  Description:

    This routine makes the surrogate IRP untouchable.

  Arguments:

    Irp        - Pointer to the Irp to make untouchable

  Return Value:

     None.

--*/
{
    if (!Irp) {

        return;
    }

    MmProtectSpecialPool(Irp, PAGE_NOACCESS);
}


VOID
FASTCALL
VfIrpMakeTouchable(
    IN  PIRP    Irp
    )
/*++

  Description:

    This routine makes the an IRP touchable if previously untouchable.

  Arguments:

    Irp           - Pointer to the Irp to make untouchable

  Return Value:

     None.
--*/
{
    MmProtectSpecialPool(Irp, PAGE_READWRITE);
}


VOID
FASTCALL
VfIrpFree(
    IN  PIRP  Irp OPTIONAL
    )
/*++

  Description:

    This routine is called when the call stack has entirely unwound
    and the IRP has completed. At this point it is no longer really
    useful to hold the surrogate IRP around.

  Arguments:

    Irp           - Pointer to the Irp to free

  Return Value:

     None.
--*/
{
    if (!Irp) {

        return;
    }

    ExFreePool(Irp);
}


VOID
FASTCALL
VerifierIoAllocateIrp1(
    IN      CCHAR               StackSize,
    IN      BOOLEAN             ChargeQuota,
    IN OUT  PIRP                *IrpPointer
    )
/*++

  Description:

    This routine is called by IoAllocateIrp and returns an IRP iff
    we are handled the allocations ourselves.

    We may need to do this internally so we can turn off IRP lookaside lists
    and use the special pool to catch people reusing free'd IRPs.

  Arguments:

    StackSize              - Count of stack locations to allocate for this IRP.

    ChargeQuote            - TRUE if quote should be charged against the current
                             thread.

    IrpPointer             - Pointer to IRP if one was allocated. This will
                             point to NULL after the call iff IoAllocateIrp
                             should use it's normal lookaside list code.

  Return Value:

    None.

--*/
{
    PIOV_REQUEST_PACKET iovPacket;
    ULONG stackHash;

    *IrpPointer = NULL;
    if (!VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_MONITOR_IRP_ALLOCS)) {

        return;
    }

    if (!VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_POLICE_IRPS)) {

        return;
    }

    //
    // Allocate a new IRP and the associated verification data.
    //
    ViIrpAllocateLockedPacket(StackSize, ChargeQuota, &iovPacket);

    if (iovPacket == NULL) {

        return;
    }

    //
    // Update the pointer.
    //
    *IrpPointer = iovPacket->TrackedIrp;

    //
    // Record he who allocated this IRP (if we can get it)
    //
    RtlCaptureStackBackTrace(1, IRP_ALLOC_COUNT, iovPacket->AllocatorStack, &stackHash);

    VfPacketLogEntry(
        iovPacket,
        IOV_EVENT_IO_ALLOCATE_IRP,
        iovPacket->AllocatorStack[0],
        (ULONG_PTR) iovPacket->AllocatorStack[2]
        );

    VfPacketReleaseLock(iovPacket);
}


VOID
FASTCALL
VerifierIoAllocateIrp2(
    IN     PIRP               Irp
    )
/*++

  Description:

    This routine is called by IoAllocateIrp and captures information if
    the IRP was allocated by the OS.

  Arguments:

    Irp                    - Pointer to IRP

  Return Value:

    None.

--*/
{
    PIOV_REQUEST_PACKET iovPacket;
    ULONG stackHash;

    if (!VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_MONITOR_IRP_ALLOCS)) {

        return;
    }

    iovPacket = VfPacketCreateAndLock(Irp);
    if (iovPacket == NULL) {

        return;
    }

    VfPacketReference(iovPacket, IOVREFTYPE_POINTER);
    iovPacket->Flags |= TRACKFLAG_IO_ALLOCATED;
    Irp->AllocationFlags |= IRP_ALLOCATION_MONITORED;
    Irp->Flags |= IRPFLAG_EXAMINE_TRACKED;

    //
    // Record he who allocated this IRP (if we can get it)
    //
    RtlCaptureStackBackTrace(1, IRP_ALLOC_COUNT, iovPacket->AllocatorStack, &stackHash);

    VfPacketLogEntry(
        iovPacket,
        IOV_EVENT_IO_ALLOCATE_IRP,
        iovPacket->AllocatorStack[0],
        (ULONG_PTR) iovPacket->AllocatorStack[2]
        );

    VfPacketReleaseLock(iovPacket);
}


VOID
FASTCALL
VerifierIoFreeIrp(
    IN      PIRP                Irp,
    IN OUT  PBOOLEAN            FreeHandled
    )
/*++

  Description:

    This routine is called by IoFreeIrp and returns TRUE iff
    the free was handled internally here (in which case IoFreeIrp
    should do nothing).

    We need to handle the call internally because we may turn off lookaside
    list cacheing to catch people reusing IRPs after they are freed.

  Arguments:

    Irp                    - A pointer to the IRP passed into
                             IoCancelIrp.

    FreeHandled            - Indicates whether the free operation was
                             handled entirely by this routine.

  Return Value:

     None.

--*/
{
    PIOV_REQUEST_PACKET iovPacket;
    PVOID callerAddress;
    ULONG stackHash;

    iovPacket = VfPacketFindAndLock(Irp);

    if (iovPacket == NULL) {

        //
        // The below assertion might fire if an IRP allocated then freed twice.
        // Normally we won't even survive the assert as the IRP would have been
        // allocated from special pool.
        //
        ASSERT(!(Irp->AllocationFlags&IRP_ALLOCATION_MONITORED));
        *FreeHandled = FALSE;
        return;
    }

    VfPacketLogEntry(
        iovPacket,
        IOV_EVENT_IO_FREE_IRP,
        NULL,
        0
        );

    if (RtlCaptureStackBackTrace(2, 1, &callerAddress, &stackHash) != 1) {

        callerAddress = NULL;
    }

    if (!IsListEmpty(&Irp->ThreadListEntry)) {

        if (VfSettingsIsOptionEnabled(iovPacket->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS)) {

            WDM_FAIL_ROUTINE((
                DCERROR_FREE_OF_THREADED_IRP,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                callerAddress,
                Irp
                ));
        }

        //
        // <Grumble> keep us alive by not actually freeing the IRP if someone did
        // this to us. We leak for life...
        //
        *FreeHandled = TRUE;
        return;
    }

    if (VfPacketGetCurrentSessionData(iovPacket)) {

        //
        // If there's a current session, that means someone is freeing an IRP
        // that they don't own. Of course, if the stack unwound badly because
        // someone forgot to return PENDING or complete the IRP, then we don't
        // assert here (we'd probably end up blaiming kernel).
        //
        if (VfSettingsIsOptionEnabled(iovPacket->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS) &&
            (!(iovPacket->Flags&TRACKFLAG_UNWOUND_BADLY))) {

            WDM_FAIL_ROUTINE((
                DCERROR_FREE_OF_INUSE_IRP,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                callerAddress,
                Irp
                ));
        }

        //
        // <Grumble> keep us alive by not actually freeing the IRP if someone did
        // this to us. We leak for life...
        //
        VfPacketReleaseLock(iovPacket);
        *FreeHandled = TRUE;
        return;
    }

    if (!(iovPacket->Flags&TRACKFLAG_IO_ALLOCATED)) {

        //
        // We weren't tracking this at allocation time. We shouldn't got our
        // packet unless the IRP had a pointer count still, meaning it's has
        // a session. And that should've been caught above.
        //
        ASSERT(0);
        VfPacketReleaseLock(iovPacket);
        *FreeHandled = FALSE;
        return;
    }

    //
    // The IRP may have been reinitialized, possibly losing it's allocation
    // flags. We catch this bug in the IoInitializeIrp hook.
    //
    //ASSERT(Irp->AllocationFlags&IRP_ALLOCATION_MONITORED);
    //

    if (!(iovPacket->Flags&TRACKFLAG_PROTECTEDIRP)) {

        //
        // We're just tagging along this IRP. Drop our pointer count but bail.
        //
        VfPacketDereference(iovPacket, IOVREFTYPE_POINTER);
        VfPacketReleaseLock(iovPacket);
        *FreeHandled = FALSE;
        return;
    }

    //
    // Set up a nice bugcheck for those who free their IRPs twice. This is done
    // because the special pool may have been exhausted, in which case the IRP
    // can be touched after it has been freed.
    //
    Irp->Type = 0;

    ASSERT(iovPacket);
    ASSERT(VfSettingsIsOptionEnabled(iovPacket->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS));

    //
    // Release any quota we charged.
    //
    if (Irp->AllocationFlags & IRP_QUOTA_CHARGED) {

        PsReturnProcessNonPagedPoolQuota(
                    iovPacket->QuotaProcess,
                    iovPacket->QuotaCharge
                    );

        ObDereferenceObject(iovPacket->QuotaProcess);
    }

    VfPacketDereference(iovPacket, IOVREFTYPE_POINTER);
    ASSERT(iovPacket->PointerCount == 0);
    VfPacketReleaseLock(iovPacket);

    VfIrpFree(Irp);

    //
    // We handled allocation and initialization. There is nothing much more to
    // do.
    //
    *FreeHandled = TRUE;
}


VOID
FASTCALL
VerifierIoInitializeIrp(
    IN OUT PIRP               Irp,
    IN     USHORT             PacketSize,
    IN     CCHAR              StackSize,
    IN OUT PBOOLEAN           InitializeHandled
    )
/*++

  Description:

    This routine is called by IoInitializeIrp and sets InitializeHandled to
    TRUE if the entire initialization was handled internally.

    While here we verify the caller is not Initializing an IRP allocated
    through IoAllocateIrp, as doing so means we may leak quota/etc.

  Arguments:

    Irp                    - Irp to initialize

    PacketSize             - Size of the IRP in bytes.

    StackSize              - Count of stack locations for this IRP.

    InitializeHandled      - Pointer to a BOOLEAN that will be set to true iff
                             the initialization of the IRP was handled entirely
                             within this routine. If FALSE, IoInitializeIrp
                             should initialize the IRP as normal.

    ADRIAO N.B. 06/16/2000 - As currently coded in iomgr\ioverifier.c, this
                             function is expected to set InitializeHandled to
                             FALSE!

  Return Value:

     None.

--*/
{
    PIOV_REQUEST_PACKET iovPacket;
    PVOID callerAddress;
    ULONG stackHash;

    UNREFERENCED_PARAMETER (PacketSize);
    UNREFERENCED_PARAMETER (StackSize);

    iovPacket = VfPacketFindAndLock(Irp);
    if (iovPacket == NULL) {

        *InitializeHandled = FALSE;
        return;
    }

    if (RtlCaptureStackBackTrace(2, 1, &callerAddress, &stackHash) != 1) {

        callerAddress = NULL;
    }

    if (VfSettingsIsOptionEnabled(iovPacket->VerifierSettings, VERIFIER_OPTION_POLICE_IRPS) &&

       (iovPacket->Flags&TRACKFLAG_IO_ALLOCATED)) {

        if (Irp->AllocationFlags&IRP_QUOTA_CHARGED) {

            //
            // Don't let us leak quota now!
            //
            WDM_FAIL_ROUTINE((
                DCERROR_REINIT_OF_ALLOCATED_IRP_WITH_QUOTA,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                callerAddress,
                Irp
                ));

        } else {

            //
            // In this case we are draining our lookaside lists erroneously.
            //
            // WDM_CHASTISE_CALLER2(
            //    (DCERROR_REINIT_OF_ALLOCATED_IRP_WITHOUT_QUOTA, DCPARAM_IRP, Irp)
            //    );
        }
    }

    *InitializeHandled = FALSE;
    VfPacketReleaseLock(iovPacket);
}
BOOLEAN
VfIrpSendSynchronousIrp(
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIO_STACK_LOCATION  TopStackLocation,
    IN      BOOLEAN             Untouchable,
    IN      NTSTATUS            InitialStatus,
    IN      ULONG_PTR           InitialInformation  OPTIONAL,
    OUT     ULONG_PTR           *FinalInformation   OPTIONAL,
    OUT     NTSTATUS            *FinalStatus        OPTIONAL
    )
/*++

Routine Description:

    This function sends a synchronous irp to the top level device
    object which roots on DeviceObject.

Parameters:

    DeviceObject - Supplies the device object of the device being removed.

    TopStackLocation - Supplies a pointer to the parameter block for the irp.

    Untouchable - TRUE iff IRP should be marked untouchable (ie status and
                  information should be left alone by target.)

    InitialStatus - Initial value for the IRPs status field.

    InitialInformation - Initial value for the IRPs information field.

    FinalInformation - Receives final result of information field, or NULL if
                       IRP could not be allocated.

    FinalStatus - Receives final status for sent IRP, or STATUS_SUCCESS if IRP
                       could not be allocated.

Return Value:

    TRUE iff IRP was sent, FALSE if IRP could not be sent due to low resources.

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    NTSTATUS status;
    PDEVICE_OBJECT topDeviceObject;

    PAGED_CODE();

    //
    // Preinit for failure
    //
    if (ARGUMENT_PRESENT(FinalInformation)) {

        *FinalInformation = 0;
    }

    if (ARGUMENT_PRESENT(FinalStatus)) {

        *FinalStatus = STATUS_SUCCESS;
    }

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //
    topDeviceObject = IoGetAttachedDeviceReference(DeviceObject);

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //
    irp = IoAllocateIrp(topDeviceObject->StackSize, FALSE);
    if (irp == NULL){

        ObDereferenceObject(topDeviceObject);
        return FALSE;
    }

    if (Untouchable) {

        SPECIALIRP_WATERMARK_IRP(irp, IRP_BOGUS);
    }

    //
    // Initialize the IRP
    //
    irp->IoStatus.Status = InitialStatus;
    irp->IoStatus.Information = InitialInformation;

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and parameters are set.
    //
    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Copy in the caller-supplied stack location contents
    //
    *irpSp = *TopStackLocation;

    //
    // Set a top level completion routine.
    //
    IoSetCompletionRoutine(
        irp,
        ViIrpSynchronousCompletionRoutine,
        (PVOID) &event,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Call the driver
    //
    status = IoCallDriver(topDeviceObject, irp);
    ObDereferenceObject(topDeviceObject);

    //
    // If a driver returns STATUS_PENDING, we will wait for it to complete
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            (PLARGE_INTEGER) NULL
            );

        status = irp->IoStatus.Status;
    }

    if (ARGUMENT_PRESENT(FinalStatus)) {

        *FinalStatus = status;
    }

    if (ARGUMENT_PRESENT(FinalInformation)) {

        *FinalInformation = irp->IoStatus.Information;
    }

    IoFreeIrp(irp);
    return TRUE;
}


NTSTATUS
ViIrpSynchronousCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    KeSetEvent((PKEVENT) Context, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
FASTCALL
VfIrpWatermark(
    IN PIRP  Irp,
    IN ULONG Flags
    )
{
    PIOV_REQUEST_PACKET iovPacket;

    iovPacket = VfPacketFindAndLock(Irp);

    if (iovPacket == NULL) {

        return;
    }

    if (Flags & IRP_SYSTEM_RESTRICTED) {

        //
        // Note that calling this function is not in itself enough to get the
        // system to prevent drivers from sending restricted IRPs. Those IRPs to
        // be protected must also be added to the system restricted callbacks
        // registered by VfMajorRegisterHandlers.
        //
        iovPacket->Flags |= TRACKFLAG_WATERMARKED;
    }

    if (Flags & IRP_BOGUS) {

        iovPacket->Flags |= TRACKFLAG_BOGUS;
    }

    VfPacketReleaseLock(iovPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfhal.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   vfhal.c

Abstract:

    This module contains the routines to verify hal usage & apis.

Author:

    Jordan Tigani (jtigani) 12-Nov-1999

Revision History:

--*/

// needed for data pointer to function pointer conversions
#pragma warning(disable:4054)   // type cast from function pointer to PVOID (data pointer)
#pragma warning(disable:4055)   // type cast from PVOID (data pointer) to function pointer

#include "vfdef.h"
#include "vihal.h"

#define THUNKED_API


//
// We are keying on the IO verifier level.
//
extern BOOLEAN IopVerifierOn;
extern ULONG IovpVerifierLevel;

//
// Use this to not generate false errors when we enter the debugger
//
extern LARGE_INTEGER KdTimerStart;


// ===================================
// Flags that can be set on the fly...
// ===================================
//
//
// Hal verifier has two parts (at this point) -- the timer verifier and the
// dma verifier. The timer verifier only runs when the hal is being verified.
//
// DMA verifier runs when ioverifier is >= level 3 *or*
// when HKLM\System\CCS\Control\Session Manager\I/O System\VerifyDma is
// nonzero.
//

ULONG   ViVerifyDma = FALSE;

//
// All data other than ViVerifyDma can be PAGEVRF.
// Note that there is no `data_seg()' counterpart
//
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEVRFD")
#endif

LOGICAL ViVerifyPerformanceCounter = FALSE;
//
// Specify whether we want to double buffer all dma transfers for hooked
// drivers. This is an easy way to tell whether the driver will work on a
// PAE system without having to do extensive testing on a pae system.
// It also adds a physical guard page to each side of each double buffered
// page. Benefits of this is that it can catch hardware that over (or under)
// writes its allocation.
//
LOGICAL ViDoubleBufferDma    = TRUE;

//
// Specifies whether we want to use a physical guard page on either side
// of common buffer allocations.
//
LOGICAL ViProtectBuffers     = TRUE;

//
// Whether or not we can inject failures into DMA api calls.
//
LOGICAL ViInjectDmaFailures = FALSE;

//
// Internal debug flag ... useful to turn on certain debug features
// at runtime.
//
LOGICAL ViSuperDebug = FALSE;


// ======================================
// Internal globals are set automatically
// ======================================

LOGICAL ViSufficientlyBootedForPcControl =  FALSE;
LOGICAL ViSufficientlyBootedForDmaFailure = FALSE;

ULONG ViMaxMapRegistersPerAdapter = 0x20;
ULONG ViMaxCommonBuffersPerAdapter = 0x20;

ULONG ViAllocationsFailedDeliberately = 0;
//
// Wait 30 seconds after boot before we start imposing
// consistency on the performance counter.
// Once the performance counter bugs are fixed, this can be
// lowered.
// This one number is used for both Performance counter control
// and dma failure injection.
//
LARGE_INTEGER ViRequiredTimeSinceBoot = {(LONG) 30 * 1000 * 1000, 0};

//
// When doing double buffering, we write this guy at the beginning and end
// of every buffer to make sure that nobody overwrites their allocation
//
CHAR ViDmaVerifierTag[] = {'D','m','a','V','r','f','y','0'};


BOOLEAN ViPenalties[] =
{
    HVC_ASSERT,             // HV_MISCELLANEOUS_ERROR
    HVC_ASSERT,             // HV_PERFORMANCE_COUNTER_DECREASED
    HVC_WARN,               // HV_PERFORMANCE_COUNTER_SKIPPED
    HVC_BUGCHECK,           // HV_FREED_TOO_MANY_COMMON_BUFFERS
    HVC_BUGCHECK,           // HV_FREED_TOO_MANY_ADAPTER_CHANNELS
    HVC_BUGCHECK,           // HV_FREED_TOO_MANY_MAP_REGISTERS
    HVC_BUGCHECK,           // HV_FREED_TOO_MANY_SCATTER_GATHER_LISTS
    HVC_ASSERT,             // HV_LEFTOVER_COMMON_BUFFERS
    HVC_ASSERT,             // HV_LEFTOVER_ADAPTER_CHANNELS
    HVC_ASSERT,             // HV_LEFTOVER_MAP_REGISTERS
    HVC_ASSERT,             // HV_LEFTOVER_SCATTER_GATHER_LISTS
    HVC_ASSERT,             // HV_TOO_MANY_ADAPTER_CHANNELS
    HVC_ASSERT,             // HV_TOO_MANY_MAP_REGISTERS
    HVC_ASSERT,             // HV_DID_NOT_FLUSH_ADAPTER_BUFFERS
    HVC_BUGCHECK,           // HV_DMA_BUFFER_NOT_LOCKED
    HVC_BUGCHECK,           // HV_BOUNDARY_OVERRUN
    HVC_ASSERT,             // HV_CANNOT_FREE_MAP_REGISTERS
    HVC_ASSERT,             // HV_DID_NOT_PUT_ADAPTER
    HVC_WARN | HVC_ONCE,    // HV_MDL_FLAGS_NOT_SET
    HVC_ASSERT,             // HV_BAD_IRQL
    //
    // This is a hack that is in because almost nobody calls
    // PutDmaAdapter at the right Irql... so until it gets fixed, just
    // print out a warning so we don't have to assert on known situations.
    //
    HVC_ASSERT,             // HV_BAD_IRQL_JUST_WARN
    HVC_WARN | HVC_ONCE,    // HV_OUT_OF_MAP_REGISTERS
    HVC_ASSERT | HVC_ONCE,  // HV_FLUSH_EMPTY_BUFFERS
    HVC_ASSERT,             // HV_MISMATCHED_MAP_FLUSH
    HVC_BUGCHECK,           // HV_ADAPTER_ALREADY_RELEASED
    HVC_BUGCHECK,           // HV_NULL_DMA_ADAPTER
    HVC_IGNORE,             // HV_MAP_FLUSH_NO_TRANSFER
    HVC_BUGCHECK,           // HV_ADDRESS_NOT_IN_MDL
    HVC_BUGCHECK,           // HV_DATA_LOSS
    HVC_BUGCHECK,           // HV_DOUBLE_MAP_REGISTER
    HVC_ASSERT,             // HV_OBSOLETE_API
    HVC_ASSERT,             // HV_BAD_MDL
    HVC_ASSERT,             // HV_FLUSH_NOT_MAPPED
    HVC_ASSERT | HVC_ONCE   // HV_MAP_ZERO_LENGTH_BUFFER

};


HAL_VERIFIER_LOCKED_LIST ViAdapterList = {NULL,NULL,0};
PVF_TIMER_INFORMATION    ViTimerInformation;


DMA_OPERATIONS ViDmaOperations =
{
    sizeof(DMA_OPERATIONS),
    (PPUT_DMA_ADAPTER)          VfPutDmaAdapter,
    (PALLOCATE_COMMON_BUFFER)   VfAllocateCommonBuffer,
    (PFREE_COMMON_BUFFER)       VfFreeCommonBuffer,
    (PALLOCATE_ADAPTER_CHANNEL) VfAllocateAdapterChannel,
    (PFLUSH_ADAPTER_BUFFERS)    VfFlushAdapterBuffers,
    (PFREE_ADAPTER_CHANNEL)     VfFreeAdapterChannel,
    (PFREE_MAP_REGISTERS)       VfFreeMapRegisters,
    (PMAP_TRANSFER)             VfMapTransfer,
    (PGET_DMA_ALIGNMENT)        VfGetDmaAlignment,
    (PREAD_DMA_COUNTER)         VfReadDmaCounter,
    (PGET_SCATTER_GATHER_LIST)  VfGetScatterGatherList,
    (PPUT_SCATTER_GATHER_LIST)  VfPutScatterGatherList,

    //
    // New DMA APIs
    //
    (PCALCULATE_SCATTER_GATHER_LIST_SIZE)   VfCalculateScatterGatherListSize,
    (PBUILD_SCATTER_GATHER_LIST)            VfBuildScatterGatherList,
    (PBUILD_MDL_FROM_SCATTER_GATHER_LIST)   VfBuildMdlFromScatterGatherList
};

#if !defined (NO_LEGACY_DRIVERS)
DMA_OPERATIONS ViLegacyDmaOperations =
{
    sizeof(DMA_OPERATIONS),
    //
    // PutDmaAdapter cannot be called by name
    //
    (PPUT_DMA_ADAPTER)          NULL,
    (PALLOCATE_COMMON_BUFFER)   HalAllocateCommonBuffer,
    (PFREE_COMMON_BUFFER)       HalFreeCommonBuffer,
    (PALLOCATE_ADAPTER_CHANNEL) IoAllocateAdapterChannel,
    (PFLUSH_ADAPTER_BUFFERS)    IoFlushAdapterBuffers,
    (PFREE_ADAPTER_CHANNEL)     IoFreeAdapterChannel,
    (PFREE_MAP_REGISTERS)       IoFreeMapRegisters,
    (PMAP_TRANSFER)             IoMapTransfer,
    //
    // HalGetDmaAlignmentRequirement isn't exported by legacy hals
    //
    (PGET_DMA_ALIGNMENT)        NULL,
    (PREAD_DMA_COUNTER)         HalReadDmaCounter,
    //
    // Scatter gather functions can never get called by name
    //
                                NULL,
                                NULL
};
#endif

//
// Saves the real HalAllocateMapRegisters
//
pHalAllocateMapRegisters       VfRealHalAllocateMapRegisters = NULL;


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, VfHalVerifierInitialize)

#pragma alloc_text(PAGEVRFY, VfGetDmaAdapter)

#if !defined (NO_LEGACY_DRIVERS)
#pragma alloc_text(PAGEVRFY, VfLegacyGetAdapter)
#endif

#pragma alloc_text(PAGEVRFY, VfPutDmaAdapter)
#pragma alloc_text(PAGEVRFY, VfHalDeleteDevice)

#pragma alloc_text(PAGEVRFY, VfAllocateCommonBuffer)
#pragma alloc_text(PAGEVRFY, VfFreeCommonBuffer)

#pragma alloc_text(PAGEVRFY, VfAllocateAdapterChannel)
#pragma alloc_text(PAGEVRFY, VfAdapterCallback)
#pragma alloc_text(PAGEVRFY, VfFreeAdapterChannel)
#pragma alloc_text(PAGEVRFY, VfFreeMapRegisters)

#pragma alloc_text(PAGEVRFY, VfMapTransfer)
#pragma alloc_text(PAGEVRFY, VfFlushAdapterBuffers)

#pragma alloc_text(PAGEVRFY, VfGetDmaAlignment)
#pragma alloc_text(PAGEVRFY, VfReadDmaCounter)

#pragma alloc_text(PAGEVRFY, VfGetScatterGatherList)
#pragma alloc_text(PAGEVRFY, VfPutScatterGatherList)

#pragma alloc_text(PAGEVRFY, VfQueryPerformanceCounter)
#pragma alloc_text(PAGEVRFY, VfInitializeTimerInformation)

#pragma alloc_text(PAGEVRFY, ViRefreshCallback)

#pragma alloc_text(PAGEVRFY, VfInjectDmaFailure)

#pragma alloc_text(PAGEVRFY, ViHookDmaAdapter)

#pragma alloc_text(PAGEVRFY, ViGetAdapterInformation)
#pragma alloc_text(PAGEVRFY, ViGetRealDmaOperation)

#pragma alloc_text(PAGEVRFY, ViSpecialAllocateCommonBuffer)
#pragma alloc_text(PAGEVRFY, ViSpecialFreeCommonBuffer)

#pragma alloc_text(PAGEVRFY, ViAllocateMapRegisterFile)
#pragma alloc_text(PAGEVRFY, ViFreeMapRegisterFile)

#pragma alloc_text(PAGEVRFY, ViMapDoubleBuffer)
#pragma alloc_text(PAGEVRFY, ViFlushDoubleBuffer)

#pragma alloc_text(PAGEVRFY, ViFreeMapRegistersToFile)
#pragma alloc_text(PAGEVRFY, ViFindMappedRegisterInFile)

#pragma alloc_text(PAGEVRFY, ViCheckAdapterBuffers)
#pragma alloc_text(PAGEVRFY, ViTagBuffer)
#pragma alloc_text(PAGEVRFY, ViCheckTag)
#pragma alloc_text(PAGEVRFY, ViInitializePadding)
#pragma alloc_text(PAGEVRFY, ViCheckPadding)
#pragma alloc_text(PAGEVRFY, ViHasBufferBeenTouched)

#pragma alloc_text(PAGEVRFY, VfAssert)
#pragma alloc_text(PAGEVRFY, VfBuildScatterGatherList)
#pragma alloc_text(PAGEVRFY, VfAllocateCrashDumpRegisters)
#pragma alloc_text(PAGEVRFY, VfScatterGatherCallback)
#pragma alloc_text(PAGEVRFY, ViAllocateContiguousMemory)
#pragma alloc_text(PAGEVRFY, VfHalAllocateMapRegisters)


#pragma alloc_text(PAGEVRFY, ViAllocateMapRegistersFromFile)
#pragma alloc_text(PAGEVRFY, ViReleaseDmaAdapter)
#pragma alloc_text(PAGEVRFY, ViSwap)
#pragma alloc_text(PAGEVRFY, ViCopyBackModifiedBuffer)
#pragma alloc_text(PAGEVRFY, ViFreeToContiguousMemory)
#pragma alloc_text(PAGEVRFY, ViAllocateFromContiguousMemory)
#pragma alloc_text(PAGEVRFY, ViCommonBufferCalculatePadding)


#if defined  (_X86_)
#pragma alloc_text(PAGEVRFY, ViRdtscX86)
#elif defined(_IA64_)
#pragma alloc_text(PAGEVRFY, ViRdtscIA64)
#else
#pragma alloc_text(PAGEVRFY, ViRdtscNull)
#endif

#endif




typedef
LARGE_INTEGER
(*PKE_QUERY_PERFORMANCE_COUNTER) (
   IN PLARGE_INTEGER PerformanceFrequency OPTIONAL
    );

VOID
ViRefreshCallback(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    VfQueryPerformanceCounter(NULL);

} // ViRefreshCallback //


VOID
VfInitializeTimerInformation()
/*++

Routine Description:

    Sets up all the performance counter refresh timer.

Arguments:

    Not used.

Return Value:

    None.

--*/

{
    ULONG timerPeriod;
    LARGE_INTEGER performanceCounter;

    PAGED_CODE();

    ViTimerInformation = ExAllocatePoolWithTag(NonPagedPool, sizeof(VF_TIMER_INFORMATION), HAL_VERIFIER_POOL_TAG);
    if (! ViTimerInformation )
        return;

    RtlZeroMemory(ViTimerInformation, sizeof(VF_TIMER_INFORMATION));

    KeInitializeTimer(&ViTimerInformation->RefreshTimer);

    KeInitializeDpc(&ViTimerInformation->RefreshDpc,
        ViRefreshCallback,
        NULL
        );

    //
    // Find out the performance counter frequency
    //
    performanceCounter = KeQueryPerformanceCounter(
        (PLARGE_INTEGER) &ViTimerInformation->PerformanceFrequency);

    SAFE_WRITE_TIMER64(ViTimerInformation->UpperBound,
        RtlConvertLongToLargeInteger(-1));

    SAFE_WRITE_TIMER64(ViTimerInformation->LastKdStartTime, KdTimerStart);
    //
    // We are going to be setting a timer to go off every millisecond, so
    // we need the timer tick interval to be as low as possible.
    //
    // N.B The system can't change this value after we have set it to a
    // minimum so  we don't have to worry about the TimeIncrement value
    // changing.
    //
    ExSetTimerResolution(0, TRUE);

    //
    // Calculate how far the performance counter goes in one clock tick
    //
    //     Counts      Counts      Seconds
    //     ------ =    ------  *   -------
    //      Tick       Second       Tick
    //

    //                      Second             Counts     100 nanoSeconds
    //            =  --------------------  *   ------  *  ---------------
    //                10^7 100 nanoSeconds     Second           Tick

    ViTimerInformation->CountsPerTick = (ULONG)
        (ViTimerInformation->PerformanceFrequency.QuadPart *
        KeQueryTimeIncrement() / ( 10 * 1000 * 1000));


    //
    // Set our refresh timer to wake up every timer tick to keep the
    // upper bound calculation in the right ballpark.
    // Round the system increment time to nearest millisecond * convert
    // 100 nanosecond units to milliseconds
    //
    timerPeriod = (KeQueryTimeIncrement() + 400 * 10) / (1000 * 10);
    KeSetTimerEx(
        &ViTimerInformation->RefreshTimer,
        RtlConvertLongToLargeInteger(-1 * 1000 * 1000), // start in a second
        timerPeriod,
        &ViTimerInformation->RefreshDpc
        );

} // ViInitializeTimerInformation //


VOID
VfHalVerifierInitialize(
    VOID
    )
/*++

Routine Description:

    Sets up all data structures etc. needed to run hal verifier.

Arguments:


Return Value:

    None.

--*/
{
    VF_INITIALIZE_LOCKED_LIST(&ViAdapterList);

   if ( VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_VERIFY_DMA)) {
        ViVerifyDma = TRUE;
        //
        // We need to replace a private routine (HalAllocateMapRegisters)
        // with the hooked-up version
        //
        if (HalPrivateDispatchTable.Version >= HAL_PRIVATE_DISPATCH_VERSION) {
           VfRealHalAllocateMapRegisters = HalAllocateMapRegisters;
           HalAllocateMapRegisters = VfHalAllocateMapRegisters;
        }

    }

   if ( VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_DOUBLE_BUFFER_DMA)) {
        ViDoubleBufferDma = TRUE;
    }

   if ( VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_VERIFY_PERFORMANCE_COUNTER)) {
       ViVerifyPerformanceCounter = TRUE;
    }

} // VfHalVerifierInitialize //




THUNKED_API
LARGE_INTEGER
VfQueryPerformanceCounter (
   IN PLARGE_INTEGER PerformanceFrequency OPTIONAL
    )
/*++

Routine Description:

    Make sure that the performance counter is correct. For now, just ensure
    that the pc is strictly increasing, but eventually we are going to keep
    track of processor cycle  counts (on X86 of course). This is complicated
    by the fact that we want to run on any arbitrary hal -- and the time
    stamp counter will get reset when we hibernate or otherwise restart a
    processor (as in a failover restart on a Fault tolerant system).

    N.B. This function can be called from any IRQL and on any processor --
        we should try to protect ourselves accordingly

Arguments:

    PerformanceFrequency -- lets us query the performance frequency.

Return Value:

    Current 64-bit performance counter value.

--*/
{

    LARGE_INTEGER performanceCounter;
    LARGE_INTEGER lastPerformanceCounter;
    PTIMER_TICK currentTickInformation;
    LARGE_INTEGER upperBound;
    LARGE_INTEGER tickCount;
    LARGE_INTEGER lastTickCount;
    LARGE_INTEGER nextUpperBound;
    ULONG currentCounter;

    if (! ViVerifyPerformanceCounter)
    {
        return  KeQueryPerformanceCounter(PerformanceFrequency);
    }

    if (! ViSufficientlyBootedForPcControl)
    //
    // If we're not worrying about performance counters yet
    // call the real function
    //
    {
        LARGE_INTEGER currentTime;
        KIRQL currentIrql;

        performanceCounter = KeQueryPerformanceCounter(PerformanceFrequency);

        currentIrql = KeGetCurrentIrql();

        KeQuerySystemTime(&currentTime);

        //
        // We can't call VfInitializeTimerInformation unless we're at
        // less than dispatch level
        //
        if (currentIrql < DISPATCH_LEVEL &&
            currentTime.QuadPart > KeBootTime.QuadPart +
            ViRequiredTimeSinceBoot.QuadPart )
        {

            ViSufficientlyBootedForPcControl = TRUE;

            VfInitializeTimerInformation();

            if (! ViTimerInformation )
            {
                //
                // If we failed initialization, we're out of luck.
                //
                ViVerifyPerformanceCounter = FALSE;
                return performanceCounter;
            }
        }
        else
        //
        // If we haven't booted enough yet, just return the current
        // performance counter
        //
        {
            return performanceCounter;
        }

    } // ! ViSufficientlyBooted //


    ASSERT(ViTimerInformation);

    //
    // Find out what the last performance counter value was
    // (bottom 32 bits may rollover while we are in the middle of reading so
    // we have to do a bit of extra work).
    //
    SAFE_READ_TIMER64( lastPerformanceCounter,
        ViTimerInformation->LastPerformanceCounter );

    performanceCounter = KeQueryPerformanceCounter(PerformanceFrequency);


    //
    // Make sure that PC hasn't gone backwards
    //
    VF_ASSERT(
        performanceCounter.QuadPart >= lastPerformanceCounter.QuadPart,

        HV_PERFORMANCE_COUNTER_DECREASED,

        ( "Performance counter has decreased-- PC1: %I64x, PC0: %I64x",
            performanceCounter.QuadPart,
            lastPerformanceCounter.QuadPart )
        );


    //
    // We're not only checking that the performance counter increased,
    // we're making sure that it didn't increase too much
    //
    SAFE_READ_TIMER64( lastTickCount,
        ViTimerInformation->LastTickCount );

    //
    // The hal takes care of synchronization for this.
    // N.B.If an interrupt comes in between the performance counter &
    //      tick count the tick count could increase in the meantime --
    //      this isn't a problem because it will just make our upper
    //      bound a bit higher.
    //
    KeQueryTickCount(&tickCount);

    //
    // Save this Perf count & tick count values so we can dump the most
    // recent ones from the debugger (find the index into our saved
    // counter list)
    //
    currentCounter = InterlockedIncrement(
        (PLONG)(&ViTimerInformation->CurrentCounter) ) % MAX_COUNTERS;

    currentTickInformation =
        &ViTimerInformation->SavedTicks[currentCounter];

    currentTickInformation->PerformanceCounter = performanceCounter;
    currentTickInformation->TimerTick = tickCount;

    currentTickInformation->TimeStampCounter = ViRdtsc();
    currentTickInformation->Processor = KeGetCurrentProcessorNumber();


    //
    // Tentatively set the next upper bound too... set a whole second
    // ahead.
    //
    nextUpperBound.QuadPart = performanceCounter.QuadPart +
        ViTimerInformation->PerformanceFrequency.QuadPart;

    //
    // If it has been too long since we last called
    // KeQueryPerformanceCounter, don't check the upper bound.
    //
    if (tickCount.QuadPart - lastTickCount.QuadPart < 4)
    {

        //
        // Figure out the upper bound on the performance counter
        //
        SAFE_READ_TIMER64(upperBound, ViTimerInformation->UpperBound);



        //
        // Make sure the PC hasn't gone too far forwards.
        //
        if ((ULONGLONG) performanceCounter.QuadPart >
            (ULONGLONG) upperBound.QuadPart )
        {
            LARGE_INTEGER lastKdStartTime;
            //
            // Microseconds = 10^6  * ticks / ticks per second
            //
            ULONG miliseconds = (ULONG) ( 1000 *
                ( performanceCounter.QuadPart -
                lastPerformanceCounter.QuadPart ) /
                ViTimerInformation->PerformanceFrequency.QuadPart );

            //
            // Check if the skip was caused by entering the debugger
            //
            SAFE_READ_TIMER64(lastKdStartTime, ViTimerInformation->LastKdStartTime);

            if (KdTimerStart.QuadPart <= lastKdStartTime.QuadPart)
            {
                //
                // skip was not caused by entering the debugger
                //

                VF_ASSERT(
                    (ULONGLONG) performanceCounter.QuadPart <=
                    (ULONGLONG) upperBound.QuadPart,

                    HV_PERFORMANCE_COUNTER_SKIPPED,

                    ( "Performance counter skipped too far -- %I64x (%d milliseconds)",
                    performanceCounter.QuadPart,
                    miliseconds )
                    );
            }
            else
            {
                //
                // Entering debugger caused us to skip too far
                //
                SAFE_WRITE_TIMER64(ViTimerInformation->LastKdStartTime, KdTimerStart);
                //
                // N.B. when we assert, we sit and wait while the
                //     performance counter goes up. We may not get
                //     a clock tick interrupt in this time, so set
                //     the next maximum to the highest possible large
                //     integer.
                //
                nextUpperBound = RtlConvertLongToLargeInteger(-1);
            }

        } // if we skipped too far  //


    } // If it hasn't been too many clock ticks since the last //
    // performance counter call //


    //
    // Save the upper bound calculation and the current tick count
    //
    SAFE_WRITE_TIMER64(ViTimerInformation->LastTickCount, tickCount);
    SAFE_WRITE_TIMER64(ViTimerInformation->UpperBound, nextUpperBound);

    //
    // Save this performance counter to serve as a minimum for the next guy.
    // (must do so in a safe way).
    //

    SAFE_WRITE_TIMER64( ViTimerInformation->LastPerformanceCounter,
        performanceCounter );

    return performanceCounter;

} // VfQueryPerformanceCounter //


#if defined (_X86_)

//
// For some annoying reason, a naked function call will cause
// a warning since we don't have a "return" statement
//
#pragma warning(disable: 4035)
//
// RDTSC is a non-standard instruction -- so build it from
// the opcode (0x0F31)
//
#ifndef RDTSC
#define RDTSC __asm _emit 0x0F __asm _emit 0x31
#endif


_declspec(naked)
LARGE_INTEGER
ViRdtscX86()
{
    __asm{
        RDTSC
        ret
    }
} // ViRdtscX86 //

#elif defined(_IA64_)

LARGE_INTEGER
ViRdtscIA64()
{
    LARGE_INTEGER itc;
    itc.QuadPart = __getReg(CV_IA64_ApITC);
    return itc;
} // ViRdtscIA64 //

#else // !X86 && !_IA64_ //


LARGE_INTEGER
ViRdtscNull()
{
    //
    // Return 0
    //
    return RtlConvertLongToLargeInteger(0);
} // ViRdtscNull //

#endif


PADAPTER_INFORMATION
ViHookDmaAdapter(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_DESCRIPTION DeviceDescription,
    IN ULONG NumberOfMapRegisters
    )

/*++

Routine Description:

    DMA functions can't be hooked in the normal way -- they are called via
    a pointer in the DmaAdapter structure -- so we are going to replace
    those pointers with our pointers after saving the real ones.

    N.B. ANY DEVICE THAT SUCCEEDS THIS FUNCTION WILL HAVE AN ELEVATED REF
    COUNT.
        So there will be a leak if ViReleaseDmaAdapter isn't called.
        ViReleaseDmaAdapter is, in the usual case, called from
        IoDeleteDevice. However, in order to do this, we have to be able
        to associate a device object with the adapter. Since there is an
        unsupported feature of the HAL that lets you pass NULL for the PDO
        when calling IoGetDmaAdapter, we have to try to find the device
        object when AllocateAdapterChannel etc is called. Some devices may
        decide to call ObDereferenceObject instead of calling PutDmaAdapter.
        While not very cool, I think that this is allowed for now. Anyway
        to make a long story short, if a driver passes a null PDO into
        PutDmaAdapter, doesn't call any dma functions, and doesn't call
        PutDmaAdapter, we will leak a reference. I think that this is a
        necessary evil since it will let us catch drivers that are being
        bad.


Arguments:

    DmaAdapter -- adapter that has been returned from IoGetDmaAdapter.
    DeviceDescription -- Describes the device.
    NumberOfMapRegisters -- how many map registers the device got.

Return Value:

    Returns either a pointer to the new adapter information structure or
    NULL if we fail.

--*/

{

    PADAPTER_INFORMATION newAdapterInformation;
    PDMA_OPERATIONS dmaOperations;

    PAGED_CODE();

    if ( VfInjectDmaFailure() == TRUE)
    {
        return NULL;
    }

    newAdapterInformation = ViGetAdapterInformation(DmaAdapter);
    if (newAdapterInformation)
    //
    // This is a bit of a tricky part -- since devices will ask the bus for
    // help creating an adapter, we can get called twice on the same stack--
    // i.e pci device calls IoGetDmaAdapter which calls PciGetDmaAdapter
    // which then calls IoGetDmaAdapter again. If we hook it all, than we'll
    // get called twice, add the same adapter twice, and destroy the real dma
    // operations.
    //
    // So in order to prevent bad things from happening, if we've seen
    // the adapter before, ignore it.
    //
    {
        return newAdapterInformation;
    }

    //
    // Allocate space to store the real dma operations for this new adapter
    //
    newAdapterInformation = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(ADAPTER_INFORMATION),
        HAL_VERIFIER_POOL_TAG );

    if (! newAdapterInformation )
    {
        //
        // If we can't allocate space for the new adapter, we're not going to
        // hook the  dma operations... thats ok though, but we won't be
        // verifying dma for this device
        //
        return NULL;
    }

    RtlZeroMemory(newAdapterInformation, sizeof(ADAPTER_INFORMATION) );

    newAdapterInformation->DmaAdapter = DmaAdapter;

    VF_ADD_TO_LOCKED_LIST(&ViAdapterList, newAdapterInformation);

    ASSERT(DmaAdapter->DmaOperations != &ViDmaOperations);

    //
    // Make sure that the dma adapter doesn't go away until we say it is ok
    // (we will deref the object in IoDeleteDevice)
    //
    ObReferenceObject(DmaAdapter);


    VF_INITIALIZE_LOCKED_LIST(&newAdapterInformation->ScatterGatherLists);
    VF_INITIALIZE_LOCKED_LIST(&newAdapterInformation->CommonBuffers);
    VF_INITIALIZE_LOCKED_LIST(&newAdapterInformation->MapRegisterFiles);

    //
    // Save the device description in case we want to look at it later.
    //
    RtlCopyMemory(&newAdapterInformation->DeviceDescription,
        DeviceDescription, sizeof(DEVICE_DESCRIPTION) );

    newAdapterInformation->MaximumMapRegisters = NumberOfMapRegisters;

    //
    // Do some calculations on the device description so that we can tell
    // at a glance what the device is doing.
    //
    if (VF_DOES_DEVICE_USE_DMA_CHANNEL(DeviceDescription))
        newAdapterInformation->UseDmaChannel = TRUE;


    KeInitializeSpinLock(&newAdapterInformation->AllocationLock);
    //
    // When we double buffer, we must remember that devices that don't do
    // scatter gather or aren't bus masters won't be able to play our double
    // buffering game, unless we come up with a better way to do double
    // buffering.
    //
    if (VF_DOES_DEVICE_REQUIRE_CONTIGUOUS_BUFFERS(DeviceDescription)) {
       newAdapterInformation->UseContiguousBuffers = TRUE;
    } else if (ViDoubleBufferDma) {
       //
       // Pre-allocate contiguous memory
       //
       ViAllocateContiguousMemory(newAdapterInformation);
    }
    //
    // Ok we've added the real dma operations structure to our adapter list--
    // so we're going to kill this one and replace it with ours
    //
    dmaOperations = DmaAdapter->DmaOperations;
    newAdapterInformation->RealDmaOperations = dmaOperations;

    DmaAdapter->DmaOperations = &ViDmaOperations;

    return newAdapterInformation;
} // ViHookDmaAdapter //


VOID
ViReleaseDmaAdapter(
    IN PADAPTER_INFORMATION AdapterInformation
    )
/*++

Routine Description:

    Release all memory associated with a particular adapter -- this is the
    antithesis of ViHookDmaAdapter.

    N.B. -- we don't actually do this until VfHalDeleteDevice is called so
        that we can do reference counting until then.
    N.B. -- That is, unless we haven't been able to associate a device object
        with he adapter, in which case we call this function from
        VfPutDmaAdapter.

Arguments:

    AdapterInformation -- structure containing the adapter to unhook.

Return Value:

    None.

--*/

{
    PDMA_ADAPTER dmaAdapter;
    ULONG_PTR referenceCount;
    PVOID *contiguousBuffers;
    ULONG i;
    KIRQL oldIrql;

    ASSERT(AdapterInformation);

    dmaAdapter = AdapterInformation->DmaAdapter;

    //
    // Just in case this comes back to haunt us (which I think is happening
    // when we disable/enable a device)
    //
    dmaAdapter->DmaOperations = AdapterInformation->RealDmaOperations;

    //
    // Free the contiguous memory if any
    //
    KeAcquireSpinLock(&AdapterInformation->AllocationLock, &oldIrql);
    contiguousBuffers = AdapterInformation->ContiguousBuffers;
    AdapterInformation->ContiguousBuffers = NULL;
    KeReleaseSpinLock(&AdapterInformation->AllocationLock, oldIrql);

    if (contiguousBuffers) {
       for (i = 0; i < MAX_CONTIGUOUS_MAP_REGISTERS; i++) {
          if (contiguousBuffers[i]) {
             MmFreeContiguousMemory(contiguousBuffers[i]);
          }
       }
       ExFreePool(contiguousBuffers);
    }

    //
    // HalPutAdapter (the real hal function) will dereference the object
    // iff it has been called. Some people try dereffing the adapter
    // themselves, and according to JakeO, that's ok. Since we
    // artificially increased the pointer count when we hooked the
    // adapter, it should be 1 now (otherwise it would be 0).
    // If its not 1, then the driver hasn't dereferenced it (either
    // by calling ObDeref... or PutDmaAdapter).
    //
    referenceCount = ObDereferenceObject(dmaAdapter);

    VF_ASSERT(
        referenceCount == 0 ||
        (referenceCount == 1 &&
            AdapterInformation->UseDmaChannel ),

        HV_DID_NOT_PUT_ADAPTER,

        ( "Too many outstanding reference counts (%x) for adapter %p",
            referenceCount,
            dmaAdapter )
        );


    VF_REMOVE_FROM_LOCKED_LIST(&ViAdapterList, AdapterInformation);

    ExFreePool(AdapterInformation);


} // ViReleaseDmaAdapter //



PADAPTER_INFORMATION
ViGetAdapterInformation(
    IN PDMA_ADAPTER DmaAdapter
    )
/*++

Routine Description:

    We store relevant information about each adapter in a linked list.
    This function goes through that list and tries to find the adapter
    and returns a pointer to the structure referencing the adapter.

Arguments:

    DmaAdapter -- adapter that has been returned from IoGetDmaAdapter.

Return Value:

    Pointer to the adapter information structure for adapter DmaAdapeer or
    NULL if we fail.

--*/

{
    PADAPTER_INFORMATION adapterInformation;
    KIRQL OldIrql;


    if (!DmaAdapter)
        return NULL;

    //
    // If the irql is greater than dispatch level we can't use our spinlock.
    // or we'll bugcheck
    //
    if (KeGetCurrentIrql() > DISPATCH_LEVEL)
    {
        //
        // Only assert when we're verifying dma. Note that during a crashdump.
        // dma verification is turned off.
        //
        if (ViVerifyDma)
        {
            VF_ASSERT_MAX_IRQL(DISPATCH_LEVEL);
        }

        return NULL;
    }



    VF_LOCK_LIST(&ViAdapterList, OldIrql);
    FOR_ALL_IN_LIST(ADAPTER_INFORMATION, &ViAdapterList.ListEntry, adapterInformation)
    {
        if (DmaAdapter == adapterInformation->DmaAdapter)
        {
            VF_UNLOCK_LIST(&ViAdapterList, OldIrql);

            VF_ASSERT( ! adapterInformation->Inactive,
                HV_ADAPTER_ALREADY_RELEASED,
                ("Driver has attempted to access an adapter (%p) that has already been released",
                DmaAdapter)
                );

            return adapterInformation;
        }
    }
    VF_UNLOCK_LIST(&ViAdapterList, OldIrql);

    //
    // Dma adapter not in the list //
    //
    return NULL;
} // ViGetAdapterInformation //


PVOID
ViGetRealDmaOperation(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG AdapterInformationOffset
    )
/*++

Routine Description:

    We've hooked the adapter operation and now the driver has called it so we
    want to find the real function that it was supposed to call. Since under
    the nt5 dma paradigm there can be multiple instances of dma functions
    (although to the best of my knowledge we don't do this yet), we can't
    just call a fixed function but we have to find the one that corresponds
    to this adapter.

Arguments:

    DmaAdapter -- adapter that has been returned from IoGetDmaAdapter.
    AdapterInformationOffset -- the byte offset of the DMA_OPERATIONS
        structure that contains the function we are looking for. For
        example, offset 0x4 would be PutDmaAdapter and 0x8 is
        AllocateCommonBuffer.

Return Value:

    TRUE  -- hooked the adapter.
    FALSE -- we were unable to hook the functions in the adapter.

--*/

{

    PADAPTER_INFORMATION adapterInformation;
    PVOID dmaOperation;

    adapterInformation = ViGetAdapterInformation(DmaAdapter);


    VF_ASSERT(
        ! (ViVerifyDma && DmaAdapter == NULL)   ,
        HV_NULL_DMA_ADAPTER,
        ("DMA adapters aren't supposed to be NULL anymore")
        );

#if !defined (NO_LEGACY_DRIVERS)
    //
    // Prevent against recursion when Hal.dll is being verified
    //
    //
    // This is a hack that will break when
    // dma is done in a filter driver -- but
    // this should only happen when NO_LEGACY_DRIVERs is set.
    //
    dmaOperation = DMA_INDEX(&ViLegacyDmaOperations, AdapterInformationOffset);
    if (NULL != dmaOperation)
    {
        return dmaOperation;
    }
    //
    // If we fall though here we must have hooked the adapter
    //

#endif

    if (! adapterInformation) {
         //
         // If we can't find the adapter information, we must not have
         // hooked it.
         //

        dmaOperation = DMA_INDEX( DmaAdapter->DmaOperations, AdapterInformationOffset );
    }
    else {
        //
        // Dma adapter is hooked. Whether we are still verifying it or not,
        // we have to call the real dma operations structure.
        //

        dmaOperation = DMA_INDEX(adapterInformation->RealDmaOperations, AdapterInformationOffset);

    }

    return dmaOperation;

} // ViGetRealDmaOperation //


THUNKED_API
PDMA_ADAPTER
VfGetDmaAdapter(
    IN PDEVICE_OBJECT  PhysicalDeviceObject,
    IN PDEVICE_DESCRIPTION DeviceDescription,
    IN OUT PULONG  NumberOfMapRegisters
    )
/*++

Routine Description:

    This is the hooked version of IoGetDmaAdapter -- the only hook we need
    from the driver verifier for dma -- since all other hooks will come out
    of the DmaAdapter->DmaOperations structure. We don't actually do any
    verification here -- we just use this as an excuse to save off a bunch
    of stuff and set up the hooks to the rest of the dma operations.

Arguments:

    PhysicalDeviceObject -- the PDO for the driver trying to get an adapter.
    DeviceDescription -- A structure describing the device we are trying to
        get an adapter for. At some point, I'm going to monkey around with
        this guy so we can convince the HAL that we are something that we're
        not, but for now just gets passed straight into IoGetDmaAdapter.

Return Value:

    Returns a pointer to the dma adapter or
    NULL if we couldn't allocate one.


--*/
{
    PVOID callingAddress;
    PADAPTER_INFORMATION newAdapterInformation;
    PADAPTER_INFORMATION inactiveAdapter;
    PDMA_ADAPTER dmaAdapter;

    PAGED_CODE();

    GET_CALLING_ADDRESS(callingAddress);

    //
    // Give the option of not hooking dma adapters at all.
    // Also, if we're a PCI bus driver, we will be called on
    // behalf of a PCI device. We don't want to hook up this call
    // because we may end up hooking up the function table for the PCI device
    // (not the PCI bus) and they may not want this...
    //
    if (! ViVerifyDma ||
          VfIsPCIBus(PhysicalDeviceObject)) {
        return IoGetDmaAdapter(
            PhysicalDeviceObject,
            DeviceDescription,
            NumberOfMapRegisters );
    }

    if (VfInjectDmaFailure() == TRUE) {
        return NULL;
    }

    VF_ASSERT_IRQL(PASSIVE_LEVEL);

    //
    // Use the PDO, cause it's the only way to uniquely identify a stack...
    //
    if (PhysicalDeviceObject)
    {
        //
        // Clean up inactive adapters with the same device object
        //
        inactiveAdapter = VF_FIND_INACTIVE_ADAPTER(PhysicalDeviceObject);

        ///
        // A device may have more than one adapter. Release each of them.
        ///
        while (inactiveAdapter) {

            ViReleaseDmaAdapter(inactiveAdapter);
            inactiveAdapter = VF_FIND_INACTIVE_ADAPTER(PhysicalDeviceObject);
        }

    }


    if ( ViDoubleBufferDma &&
        *NumberOfMapRegisters > ViMaxMapRegistersPerAdapter )  {
        //
        //  Harumph -- don't let drivers try to get too many adapters
        //  Otherwise NDIS tries to allocate thousands. Since we allocate
        //  three pages of non-paged memory for each map register, it
        //  gets expensive unless we put our foot down here
        //
        *NumberOfMapRegisters = ViMaxMapRegistersPerAdapter;

    }

    dmaAdapter = IoGetDmaAdapter(
        PhysicalDeviceObject,
        DeviceDescription,
        NumberOfMapRegisters
        );

    if (! dmaAdapter ) {
        //
        // early opt-out here -- the hal couldn't allocate the adapter
        //
        return NULL;
    }

    //
    // Replace all of the dma operations that live in the adapter with our
    // dma operations..  If we can't do it, fail.
    //
    newAdapterInformation = ViHookDmaAdapter(
        dmaAdapter,
        DeviceDescription,
        *NumberOfMapRegisters
        );
    if (! newAdapterInformation) {
        dmaAdapter->DmaOperations->PutDmaAdapter(dmaAdapter);
        return NULL;
    }

    newAdapterInformation->DeviceObject = PhysicalDeviceObject;
    newAdapterInformation->CallingAddress = callingAddress;

    return dmaAdapter ;
} // VfGetDmaAdapter //


THUNKED_API
VOID
VfPutDmaAdapter(
    PDMA_ADAPTER DmaAdapter
    )
/*++

Routine Description:

    Releases dma adapter -- we are going to make sure that the driver was
    nice and put away all of its toys before calling us .. i.e. free its
    common buffers, put its scatter gather lists, etc.

Arguments:

    DmaAdapter -- which adapter to put away.

Return Value:

    None.


--*/
{
    PPUT_DMA_ADAPTER putDmaAdapter;
    PADAPTER_INFORMATION adapterInformation;

    VF_ASSERT_MAX_IRQL(DISPATCH_LEVEL);

    putDmaAdapter = (PPUT_DMA_ADAPTER)
        ViGetRealDmaOperation(DmaAdapter, DMA_OFFSET(PutDmaAdapter));


    if (! putDmaAdapter) {
        //
        // This is bad but no other choice.
        // -- note there is not default put adapter function
        //
        return;
    }

    //
    // Make sure that the driver has freed all of its buffers etc
    //
    adapterInformation = ViGetAdapterInformation(DmaAdapter);

    if ( adapterInformation ) {

        adapterInformation->Inactive = TRUE;

        VF_ASSERT(
            adapterInformation->AllocatedAdapterChannels ==
            adapterInformation->FreedAdapterChannels,

            HV_LEFTOVER_ADAPTER_CHANNELS,

            ( "Cannot put adapter %p until all adapter channels are freed (%x left)",
            DmaAdapter,
            adapterInformation->AllocatedAdapterChannels -
            adapterInformation->FreedAdapterChannels )
            );

        VF_ASSERT(
            adapterInformation->AllocatedCommonBuffers ==
            adapterInformation->FreedCommonBuffers,

            HV_LEFTOVER_ADAPTER_CHANNELS,

            ( "Cannot put adapter %p until all common buffers are freed (%x left)",
            DmaAdapter,
            adapterInformation->AllocatedCommonBuffers -
            adapterInformation->FreedCommonBuffers )
            );

        VF_ASSERT(
            adapterInformation->ActiveMapRegisters == 0,

            HV_LEFTOVER_MAP_REGISTERS,

            ( "Cannot put adapter %p until all map registers are freed (%x left)",
            DmaAdapter,
            adapterInformation->ActiveMapRegisters )
            );

        VF_ASSERT(
            adapterInformation->ActiveScatterGatherLists == 0,

            HV_LEFTOVER_ADAPTER_CHANNELS,

            ( "Cannot put adapter %p until all scatter gather lists are freed (%x left)",
            DmaAdapter,
            adapterInformation->ActiveScatterGatherLists)
            );

        //
        // These are just to assure the verifier has done everything right.
        //
#if DBG
        ASSERT( VF_IS_LOCKED_LIST_EMPTY(
            &adapterInformation->ScatterGatherLists ));
        ASSERT( VF_IS_LOCKED_LIST_EMPTY(
            &adapterInformation->CommonBuffers ));
#endif
        //
        // Ideally, we wouldn't do this here. It's a bit of a hack. However,
        // if we don't want to leak adapter information structures etc, we
        // have to. Since when we really want to do this, in IoDeleteDevice,
        // we only have a device object, if we don't have a device
        // object in our adapter information struct, we won't be able to do it.
        //
        if (! adapterInformation->DeviceObject)
            ViReleaseDmaAdapter(adapterInformation);

        //
        // This is not a hack. The system dma adapters are persistent, so
        // we don't want to get upset when they show up again.
        //
        if (adapterInformation->UseDmaChannel)
            ViReleaseDmaAdapter(adapterInformation);
    }

    (putDmaAdapter)(DmaAdapter);

} // VfPutDmaAdapter //


THUNKED_API
PVOID
VfAllocateCommonBuffer(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    Hooked version of allocate common buffer. We are going to allocate some
    space on either side of the buffer so that we can tell if a driver
    overruns (or underruns) its allocation.


Arguments:

    DmaAdapter -- Which adapter we're looking at.
    Length  -- Size of the common buffer (note we are going to increase)
    LogicalAddress -- Gets the *PHYSICAL* address of the common buffer.
    CacheEnabled -- whether or not the memory should be cached.

Return Value:

    Returns the *VIRTUAL* address of the common buffer or
    NULL if it could not be allocated.


--*/
{
    PVOID callingAddress;
    PALLOCATE_COMMON_BUFFER allocateCommonBuffer;
    PVOID commonBuffer;
    PADAPTER_INFORMATION adapterInformation;


    allocateCommonBuffer = (PALLOCATE_COMMON_BUFFER)
        ViGetRealDmaOperation( DmaAdapter,
            DMA_OFFSET(AllocateCommonBuffer) );

    adapterInformation = ViGetAdapterInformation(DmaAdapter);

    if (adapterInformation) {

        GET_CALLING_ADDRESS(callingAddress);

        VF_ASSERT_IRQL(PASSIVE_LEVEL);

        if (VfInjectDmaFailure() == TRUE ) {
            return NULL;
        }

        if (ViProtectBuffers) {
            //
            // Try to allocate an extra big common buffer so we can check for
            // buffer overrun
            //
            commonBuffer = ViSpecialAllocateCommonBuffer(
                allocateCommonBuffer,
                adapterInformation,
                callingAddress,
                Length,
                LogicalAddress,
                CacheEnabled
                );

            if (commonBuffer)
                return commonBuffer;
        }

    }
    commonBuffer = (allocateCommonBuffer)(
        DmaAdapter,
        Length,
        LogicalAddress,
        CacheEnabled );


    if(commonBuffer && adapterInformation) {
        //
        // Increment the number of known common buffers for this adapter
        // (the dma adapter  better be in our list because otherwise we
        // couldn't have gotten the pointer to the allocateCommonBuffer
        // struct
        //
        INCREMENT_COMMON_BUFFERS(adapterInformation);
    }


    return commonBuffer;
} // VfAllocateCommonBuffer //


THUNKED_API
VOID
VfFreeCommonBuffer(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    Hooked version of FreeCommonBuffer.


Arguments:

    DmaAdapter -- Which adapter we're looking at.
    Length  -- Size of the common buffer (note we are going to increase)
    LogicalAddress -- The *PHYSICAL* address of the common buffer.
    VirtualAddress -- The *VIRTUAL* address of common buffer.
    CacheEnabled -- whether or not the memory is cached.

Return Value:

    None.

--*/

{
    PFREE_COMMON_BUFFER freeCommonBuffer;
    PADAPTER_INFORMATION adapterInformation;

    freeCommonBuffer = (PFREE_COMMON_BUFFER)
        ViGetRealDmaOperation(DmaAdapter, DMA_OFFSET(FreeCommonBuffer));


    adapterInformation = ViGetAdapterInformation(DmaAdapter);


    if (adapterInformation) {
        VF_ASSERT_IRQL(PASSIVE_LEVEL);
        //
        // We want to call this even if we're not doing common buffer
        // protection. Why? because we may have switched it off manually
        // (on the fly) and we don't want to try to free the wrong kind of
        // buffer.
        //
        if (ViSpecialFreeCommonBuffer(
            freeCommonBuffer,
            adapterInformation,
            VirtualAddress,
            CacheEnabled
            )) {
            return;
        }

    }

    //
    // Call the real free common buffer routine.
    //
    (freeCommonBuffer)(
        DmaAdapter,
        Length,
        LogicalAddress,
        VirtualAddress,
        CacheEnabled );

    //
    // Decrement the number of known common buffers for this adapter
    //
    if (adapterInformation) {
        DECREMENT_COMMON_BUFFERS(adapterInformation);
    }

} // VfFreeCommonBuffer //




THUNKED_API
NTSTATUS
VfAllocateAdapterChannel(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT  DeviceObject,
    IN ULONG  NumberOfMapRegisters,
    IN PDRIVER_CONTROL  ExecutionRoutine,
    IN PVOID  Context
    )
/*++

Routine Description:

    Hooked version of AllocateAdapterChannel ..

Arguments:

    DmaAdapter -- adapter referenced.
    DeviceObject -- we don't care about this.
    NumberOfMapRegisters -- make sure that the driver isn't trying to be too
        greedy and trying to allocate more map registers than it said that it
        wanted when it allocated the adapter.
    ExecutionRoutine -- call this routine when done (actually let the hal do
        this). We are going to hook this routine so that we know when this
        happens.
    Context -- context parameter to pass into the execution routine.

Return Value:

    NTSTATUS code ... up to the hal to decide this one.

--*/
{
    PALLOCATE_ADAPTER_CHANNEL allocateAdapterChannel;
    PADAPTER_INFORMATION adapterInformation;
    PVF_WAIT_CONTEXT_BLOCK waitBlock;
    NTSTATUS status;

    allocateAdapterChannel = (PALLOCATE_ADAPTER_CHANNEL)
        ViGetRealDmaOperation(DmaAdapter, DMA_OFFSET(AllocateAdapterChannel));

    adapterInformation = ViGetAdapterInformation(DmaAdapter);

    if (adapterInformation) {
        VF_ASSERT_IRQL(DISPATCH_LEVEL);
        //
        // Fill in the wait context block so that the execution routine will
        // know what is going on.
        //

        waitBlock = &adapterInformation->AdapterChannelContextBlock;
            RtlZeroMemory(waitBlock, sizeof(VF_WAIT_CONTEXT_BLOCK));

        waitBlock->RealContext = Context;
        waitBlock->RealCallback = (PVOID)ExecutionRoutine;
        waitBlock->AdapterInformation = adapterInformation;
        waitBlock->NumberOfMapRegisters = NumberOfMapRegisters;


        if (ViDoubleBufferDma && ! adapterInformation->UseContiguousBuffers) {
            //
            // Note if this fails, we simply won't have double buffer
            //
            waitBlock->MapRegisterFile = ViAllocateMapRegisterFile(
                adapterInformation,
                NumberOfMapRegisters
                );
        }

        //
        // We are going to save the device object if the adapter was created without
        // a real PDO (there is an option to pass in NULL).
        //
        if (! adapterInformation->DeviceObject) {
            adapterInformation->DeviceObject = DeviceObject;
        }

        //
        // Use OUR execution routine and callback (we've already saved theirs)
        //
        ExecutionRoutine = VfAdapterCallback;
        Context = waitBlock;

        INCREMENT_ADAPTER_CHANNELS(adapterInformation);
        ADD_MAP_REGISTERS(adapterInformation, NumberOfMapRegisters, FALSE);

    } // if (adapterInformation)

    status = (allocateAdapterChannel)(
        DmaAdapter,
        DeviceObject,
        NumberOfMapRegisters,
        ExecutionRoutine,
        Context
        );

    if ( status != STATUS_SUCCESS && adapterInformation) {
        DECREMENT_ADAPTER_CHANNELS(adapterInformation);
        SUBTRACT_MAP_REGISTERS(adapterInformation, NumberOfMapRegisters);
    }


    return status;
} // VfAllocateAdapterChannel //


THUNKED_API
BOOLEAN
VfFlushAdapterBuffers(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    Hooked version of FlushAdapterBuffers .. drivers that don't call this
    after a map transfer must be punished.

Arguments:

    DmaAdapter -- dma adapter for the device whose buffers we are flushing.
    Mdl -- Mdl for transfer.
    MapRegisterBase -- only the HAL really knows what this is.
    CurrentVa -- virtual address indexing the Mdl to show where we want to
        start flushing.
    Length -- length of transfer (i.e how much to flush).
    WriteToDevice -- direction of transfer. We should make sure that the
        device has this set correctly (but not exactly sure how to do so).

Return Value:

    TRUE -- flushed buffers.
    FALSE -- couldn't flush buffers. I'm not sure what the driver is
        actually supposed to do in the occasion that the flushing fails.
        Re-flush ? Re-try the transfer?

--*/
{
    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers;
    PADAPTER_INFORMATION adapterInformation;
    BOOLEAN buffersFlushed;

    flushAdapterBuffers = (PFLUSH_ADAPTER_BUFFERS)
        ViGetRealDmaOperation( DmaAdapter,
        DMA_OFFSET(FlushAdapterBuffers) );

    adapterInformation = ViGetAdapterInformation(DmaAdapter);

    if (adapterInformation) {
        VF_ASSERT_MAX_IRQL(DISPATCH_LEVEL);

        //
        // It doesn't make any sense to flush adapter buffers with a length
        // of zero.
        //
        if (MapRegisterBase == MRF_NULL_PLACEHOLDER) {

            //
            // Some drivers (scsiport for one) don't call
            // HalFlushAdapterBuffers unless MapRegisterBase is non-null.
            // In order to fool the drivers into thinking that they need
            // to flush, we exchange the NULL MapRegisterBase (if in fact
            // the hal uses a null map register base) for our
            /// MRF_NULL_PLACEHOLDER in the adapter allocation callback.
            // So now, if we find that placeholder, we must exchange it
            // for NULL in order not to confuse the hal.
            //

            MapRegisterBase = NULL;
        }
        else if (  VALIDATE_MAP_REGISTER_FILE_SIGNATURE(
            (PMAP_REGISTER_FILE) MapRegisterBase )  ) {
            PMDL  alternateMdl;
            PVOID alternateVa;
            PVOID alternateMapRegisterBase;

            alternateMdl = Mdl;
            alternateVa  = CurrentVa;
            alternateMapRegisterBase = MapRegisterBase;

            //
            // Find the mdl * va we used to map the transfer
            // (i.e. the location of the double buffer)
            //
            if (!ViSwap(&alternateMapRegisterBase, &alternateMdl, &alternateVa)) {
                //
                // Assert only when the length is not zero, if they
                // map and flush a zero length buffer
                //
                VF_ASSERT(Length == 0,
                          HV_FLUSH_NOT_MAPPED,
                          ("Cannot flush map register that isn't mapped!"
                           " (Map register base %p, flushing address %p, MDL %p)",
                           MapRegisterBase, CurrentVa, Mdl));
                //
                // Don't continue -- we don't know what should actually be flushed and
                // the hal will get our map register base and corrupt it instead
                // of using its own  map register base.
                //
                return FALSE;

            }


            buffersFlushed = (flushAdapterBuffers)(
                DmaAdapter,
                alternateMdl,
                alternateMapRegisterBase,
                alternateVa,
                Length,
                WriteToDevice
                );

            ///
            // Double buffer away!!!
            // (remember we must use the original mdl and va).
            ///
            ViFlushDoubleBuffer(
                (PMAP_REGISTER_FILE) MapRegisterBase,
                Mdl,
                CurrentVa,
                Length,
                WriteToDevice
                );

             if (buffersFlushed) {
                DECREASE_MAPPED_TRANSFER_BYTE_COUNT( adapterInformation, Length);
             }
             return buffersFlushed;

        } /// End double buffering //

    } /// end we have adapter information //

    buffersFlushed = (flushAdapterBuffers)(
        DmaAdapter,
        Mdl,
        MapRegisterBase,
        CurrentVa,
        Length,
        WriteToDevice
        );



    if (adapterInformation && buffersFlushed) {
        DECREASE_MAPPED_TRANSFER_BYTE_COUNT( adapterInformation, Length);
    }

    return buffersFlushed;

} // VfFlushAdapterBuffers //


VOID
VfFreeAdapterChannel(
    IN PDMA_ADAPTER DmaAdapter
    )
/*++

Routine Description:

    Hooked version of FreeAdapterChannel. Either this or FreeMapRegisters
    must be called, depending on the return value of AllocateAdapterChannel
    callback -- but not both.

Arguments:

    DmaAdapter -- dma adapter that allocated the adapter channel.

Return Value:

    None.

--*/
{
    PFREE_ADAPTER_CHANNEL freeAdapterChannel;
    PADAPTER_INFORMATION  adapterInformation;

    VF_ASSERT_IRQL(DISPATCH_LEVEL);

    freeAdapterChannel = (PFREE_ADAPTER_CHANNEL)
        ViGetRealDmaOperation(DmaAdapter, DMA_OFFSET(FreeAdapterChannel));

    (freeAdapterChannel)(DmaAdapter);

    adapterInformation = ViGetAdapterInformation(DmaAdapter);

    if (! adapterInformation) {
        return;
    }


    DECREASE_MAPPED_TRANSFER_BYTE_COUNT( adapterInformation, 0);
    //
    // Keep track of the adapter channel being freed
    //
    DECREMENT_ADAPTER_CHANNELS(adapterInformation);
    //
    // This also frees the map registers allocated this time.
    //
    SUBTRACT_MAP_REGISTERS( adapterInformation,
        adapterInformation->AdapterChannelMapRegisters );

    adapterInformation->AdapterChannelMapRegisters = 0;

    //
    // In this case, we can tell when we have double mapped the buffer
    //
    if(adapterInformation->AdapterChannelContextBlock.MapRegisterFile) {

        ViFreeMapRegisterFile(
            adapterInformation,
            adapterInformation->AdapterChannelContextBlock.MapRegisterFile
            );
    }

} // VfFreeAdapterChannel //


THUNKED_API
VOID
VfFreeMapRegisters(
    IN PDMA_ADAPTER DmaAdapter,
    PVOID MapRegisterBase,
    ULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    Hooked version of FreeMapRegisters -- must be called if the adapter
    allocation callback routine returned DeallocateObejcetKeepRegisters.

Arguments:

    DmaAdapter -- adapter for the device that allocated the registers in
        the first place.
    MapRegisterBase -- secret hal pointer.
    NumberOfMapRegisters -- how many map registers you're freeing. Must
        be same as how many registers were allocated.

Return Value:

    None.


--*/
{
    PFREE_MAP_REGISTERS freeMapRegisters;
    PMAP_REGISTER_FILE mapRegisterFile = NULL;
    PADAPTER_INFORMATION adapterInformation;

    freeMapRegisters = (PFREE_MAP_REGISTERS)
        ViGetRealDmaOperation(DmaAdapter, DMA_OFFSET(FreeMapRegisters));

    adapterInformation = ViGetAdapterInformation(DmaAdapter);

    if (adapterInformation) {

        VF_ASSERT_IRQL(DISPATCH_LEVEL);

        mapRegisterFile = MapRegisterBase;

        if (MapRegisterBase == MRF_NULL_PLACEHOLDER) {
            //
            // Some drivers (scsiport for one) don't call
            // HalFlushAdapterBuffers unless MapRegisterBase is non-null.
            // In order to fool the drivers into thinking that they need
            // to flush, we exchange the NULL MapRegisterBase (if in fact
            // the hal uses a null map register base) for our
            /// MRF_NULL_PLACEHOLDER in the adapter allocation callback.
            // So now, if we find that placeholder, we must exchange it
            // for NULL in order not to confuse the hal.
            //

            MapRegisterBase = NULL;
            mapRegisterFile = NULL;
        }
        else if (VALIDATE_MAP_REGISTER_FILE_SIGNATURE(mapRegisterFile)) {
            MapRegisterBase = mapRegisterFile->MapRegisterBaseFromHal;
        }
    }

    (freeMapRegisters)(DmaAdapter, MapRegisterBase, NumberOfMapRegisters);



    if (! adapterInformation) {
        return;
    }

    //
    // Keep track of the map registers that are being freed.
    //
    SUBTRACT_MAP_REGISTERS(adapterInformation, NumberOfMapRegisters);

    //
    // Always do this -- if we're not actually doing double buffering, it
    // will just return. Otherwise if we clear the double-buffering flag
    // on the fly, we won't ever free our allocation.
    //
    ViFreeMapRegisterFile(
        adapterInformation,
        mapRegisterFile
        );

} // VfFreeMapregisters //


THUNKED_API
PHYSICAL_ADDRESS
VfMapTransfer(
    IN PDMA_ADAPTER  DmaAdapter,
    IN PMDL  Mdl,
    IN PVOID  MapRegisterBase,
    IN PVOID  CurrentVa,
    IN OUT PULONG  Length,
    IN BOOLEAN  WriteToDevice
    )
/*++

Routine Description:

    Hooked version of MapTransfer.

Arguments:

    DmaAdapter -- adapter we're using to map the transfer.
    Mdl -- describes memory to map.
    MapRegisterBase -- Lets the hal monkey around with the data. I hook
        this if I am doing double buffering.
    CurrentVa -- where in the transfer we are.
    Length -- how many bytes to transfer (and how many bytes hal is going
        to let you  transfer).
    WriteToDevice -- direction of transfer.

Return Value:

    PHYSICAL_ADDRESS that is the memory to be transferred as seen by the
        device.


--*/
{
    PMAP_TRANSFER mapTransfer;
    PHYSICAL_ADDRESS mappedAddress;
    PADAPTER_INFORMATION adapterInformation;


    mapTransfer = (PMAP_TRANSFER)
        ViGetRealDmaOperation(DmaAdapter, DMA_OFFSET(MapTransfer));


    adapterInformation = ViGetAdapterInformation(DmaAdapter);

    if (adapterInformation) {

        VF_ASSERT_MAX_IRQL(DISPATCH_LEVEL);
        //
        // NOTE -- this may cause a page-fault while at dispatch level if
        //  the buffer is not locked down. Thats ok because we would bugcheck
        //  anyway if the buffer's not locked down.
        //
        VERIFY_BUFFER_LOCKED(Mdl);


        if (MapRegisterBase == MRF_NULL_PLACEHOLDER) {
            //
            // Some drivers (scsiport for one) don't call
            // HalFlushAdapterBuffers unless MapRegisterBase is non-null.
            // In order to fool the drivers into thinking that they need
            // to flush, we exchange the NULL MapRegisterBase (if in fact
            // the hal uses a null map register base) for our
            /// MRF_NULL_PLACEHOLDER in the adapter callback routine.
            // So now, if we find that placeholder, we must exchange it
            // for NULL in order not to confuse the hal.
            //

            MapRegisterBase = NULL;
        }
        else if (VALIDATE_MAP_REGISTER_FILE_SIGNATURE(
                 (PMAP_REGISTER_FILE) MapRegisterBase)) {

            ULONG bytesMapped;

            ///
            // Double buffer away!!!
            ///

            //
            // Note -- we only have to double buffer as much as we want....
            //
            bytesMapped = ViMapDoubleBuffer(
                (PMAP_REGISTER_FILE) MapRegisterBase,
                Mdl,
                CurrentVa,
                *Length,
                WriteToDevice);
             //
             // If we fail to map,  bytesMapped will be 0 and we will
             // still use the real mdl & Va -- so we don't need any
             // kind of special cases.
             //
            if (bytesMapped) {

                *Length = bytesMapped;


                //
                // Get the values that IoMapTransfer is going to use
                // i.e. the real map register base, but the
                //     mdl and virtual address for double buffering.
                //
                if (FALSE == ViSwap(&MapRegisterBase, &Mdl, &CurrentVa)) {
                   //
                   // Something terrible happened. Make sure we use the
                   // HAL's MapRegisterBase instead of our 'cooked' MapRegisterBase.
                   // If ViSwap fails Mdl and CurrentVa will not be swapped.
                   //
                   MapRegisterBase = ((PMAP_REGISTER_FILE) MapRegisterBase)->MapRegisterBaseFromHal;
                }

            }
            else {
                MapRegisterBase = ((PMAP_REGISTER_FILE) MapRegisterBase)->MapRegisterBaseFromHal;
            }
        } // IF double buffering //

        //
        // Make sure that this adapter's common buffers are ok
        //
        ViCheckAdapterBuffers(adapterInformation);

    } // if we are verifying this adapter //

    mappedAddress = (mapTransfer)(
        DmaAdapter,
        Mdl,
        MapRegisterBase,
        CurrentVa,
        Length,
        WriteToDevice
        );

    if (adapterInformation) {
        INCREASE_MAPPED_TRANSFER_BYTE_COUNT( adapterInformation, *Length );
    }

    return mappedAddress;
} // VfMapTransfer //


THUNKED_API
ULONG
VfGetDmaAlignment(
    IN PDMA_ADAPTER DmaAdapter
    )
/*++

Routine Description:

    Hooked GetDmaAlignment. It would be interesting to change this to a big
    number and see how many drivers blow up. On a PC, this is alway 1 so
    it's not particularly interesting (and why drivers may take it for
    granted). Actually drivers can specify that they want this bumped up.

Arguments:

    DmaAdapter -- get the dma alignment for this device.

Return Value:

    Align on n byte boundaries where n is the return value.

--*/
{

    PGET_DMA_ALIGNMENT getDmaAlignment;
    ULONG dmaAlignment;

    VF_ASSERT_IRQL(PASSIVE_LEVEL);

    getDmaAlignment = (PGET_DMA_ALIGNMENT)
        ViGetRealDmaOperation(DmaAdapter, DMA_OFFSET(GetDmaAlignment));

    if (! getDmaAlignment) {
        //
        // This should never happen but ..
        //
        return 1;
    }

    dmaAlignment = (getDmaAlignment)(DmaAdapter);

    return dmaAlignment;

} // GetDmaAlignment //


ULONG
VfReadDmaCounter(
    IN PDMA_ADAPTER  DmaAdapter
    )
/*++

Routine Description:

    Hooked ReadDmaCounter. How much dma is left.

Arguments:

    DmaAdapter -- read this device's dma counter.

Return Value:

    Returns how much dma is left.


--*/
{
    PREAD_DMA_COUNTER readDmaCounter;
    ULONG dmaCounter;

    VF_ASSERT_MAX_IRQL(DISPATCH_LEVEL);

    readDmaCounter = (PREAD_DMA_COUNTER)
        ViGetRealDmaOperation(DmaAdapter, DMA_OFFSET(ReadDmaCounter));


    dmaCounter = (readDmaCounter)(DmaAdapter);

    return dmaCounter;
} // VfReadDmaCounter //


THUNKED_API
NTSTATUS
VfGetScatterGatherList (
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    Hooked version of get scatter gather list.

Arguments:

    DmaAdapter -- Adapter getting the scatter gather list.
    DeviceObject -- device object of device getting scatter gather list.
    Mdl -- get a scatter gather list describing memory in this mdl.
    CurrentVa -- where we are in the transfer.
    Length -- how much to put into the scatter gather list.
    ExecutionRoutine -- callback. We are going to hook this.
    Context -- what to pass into the execution routine.
    WriteToDevice -- direction of transfer.

Return Value:

    NTSTATUS code.


--*/
{
    PGET_SCATTER_GATHER_LIST getScatterGatherList;
    PADAPTER_INFORMATION adapterInformation;
    ULONG numberOfMapRegisters;
    ULONG transferLength;
    ULONG pageOffset;
    ULONG mdlLength;
    PUCHAR mdlVa;
    PMDL tempMdl;
    NTSTATUS status;
    PVF_WAIT_CONTEXT_BLOCK_EX waitBlock = NULL;
    PMAP_REGISTER_FILE mapRegisterFileCopy = NULL;


    getScatterGatherList =  (PGET_SCATTER_GATHER_LIST)
        ViGetRealDmaOperation(
            DmaAdapter,
            DMA_OFFSET(GetScatterGatherList) );


    adapterInformation = ViGetAdapterInformation(DmaAdapter);

    if (adapterInformation) {
        VF_ASSERT_IRQL(DISPATCH_LEVEL);

        if (VfInjectDmaFailure() == TRUE) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        INCREMENT_SCATTER_GATHER_LISTS(adapterInformation);

        //
        // NOTE -- this may cause a page-fault while at dispatch level if
        //  the buffer is not locked down. Thats ok because we would bugcheck
        //  anyway if the buffer's not locked down.
        //
        VERIFY_BUFFER_LOCKED(Mdl);

        if (ViDoubleBufferDma) {

            PMAP_REGISTER_FILE mapRegisterFile;
            ULONG bytesMapped;

            //
            // We will allocate space for the MDL after the wait block.
            // This is because we cannot be sure that the storage for the MDL
            // will not freed by the driver at PutScatterGatherList time.
            // Also pay attention to alignment issues.
            //
            waitBlock = ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(VF_WAIT_CONTEXT_BLOCK_EX),
                HAL_VERIFIER_POOL_TAG);


            //
            // If exalloc... failed we can't to double buffering
            //
            if (! waitBlock) {
                goto __NoDoubleBuffer;
            }

            if(ViSuperDebug) {
                DbgPrint("    %p Allocated Wait Block\n",waitBlock );
            }

            RtlZeroMemory(waitBlock, sizeof(VF_WAIT_CONTEXT_BLOCK));
            waitBlock->RealContext  = Context;
            waitBlock->RealCallback = (PVOID)ExecutionRoutine;
            InitializeListHead(&waitBlock->ListEntry);

            mdlVa = MmGetMdlVirtualAddress(Mdl);

            //
            // Calculate the number of required map registers.
            //

            tempMdl = Mdl;
            transferLength = (ULONG) ((ULONG_PTR) tempMdl->ByteCount - (ULONG_PTR) ((PUCHAR) CurrentVa - mdlVa));
            mdlLength = transferLength;

            pageOffset = BYTE_OFFSET(CurrentVa);
            numberOfMapRegisters = 0;

            //
            // The virtual address should fit in the first MDL.
            //

            ASSERT((ULONG)((PUCHAR)CurrentVa - mdlVa) <= tempMdl->ByteCount);

            //
            // Loop through the any chained MDLs accumulating the required
            // number of map registers.
            //

            while (transferLength < Length && tempMdl->Next != NULL) {

                numberOfMapRegisters += (pageOffset + mdlLength + PAGE_SIZE - 1) >>
                    PAGE_SHIFT;

                tempMdl = tempMdl->Next;
                pageOffset = tempMdl->ByteOffset;
                mdlLength = tempMdl->ByteCount;
                transferLength += mdlLength;
            }

            if ((transferLength + PAGE_SIZE) < (Length + pageOffset )) {

                ASSERT(transferLength >= Length);
                DECREMENT_SCATTER_GATHER_LISTS(adapterInformation);
                ExFreePool(waitBlock);
                return(STATUS_BUFFER_TOO_SMALL);
            }

            //
            // Calculate the last number of map registers based on the requested
            // length not the length of the last MDL.
            //

            ASSERT( transferLength <= mdlLength + Length );

            numberOfMapRegisters += (pageOffset + Length + mdlLength - transferLength +
                PAGE_SIZE - 1) >> PAGE_SHIFT;


            waitBlock->NumberOfMapRegisters = numberOfMapRegisters;
            waitBlock->AdapterInformation = adapterInformation;

            mapRegisterFile = ViAllocateMapRegisterFile(
                adapterInformation,
                waitBlock->NumberOfMapRegisters
                );

            if (! mapRegisterFile ) {

                if(ViSuperDebug) {

                    DbgPrint("%p Freeing Wait Block\n",waitBlock);

                }

                ExFreePool(waitBlock);
                waitBlock = NULL;
                goto __NoDoubleBuffer;
            }

            //
            // Signal that the map register file is for scatter gather
            // this will make sure that the whole buffer gets mapped
            //
            mapRegisterFile->ScatterGather = TRUE;
            waitBlock->MapRegisterFile = mapRegisterFile;

            //
            // The storage for our MDL is at the end of the structure
            //
            waitBlock->RealMdl         = &waitBlock->Mdl;
            waitBlock->RealStartVa     = CurrentVa;
            waitBlock->RealLength      = Length;


            bytesMapped = ViMapDoubleBuffer(
                mapRegisterFile,
                Mdl,
                CurrentVa,
                Length,
                WriteToDevice );

            if (bytesMapped) {
                //
                // Since we mapped the buffer, we can hook the callback
                // routine & send out wait block as the parameter
                //


                Context = waitBlock;
                ExecutionRoutine = VfScatterGatherCallback;
                //
                // Copy the original MDL. We just need the fixed part
                // to identify the buffer in our structures so we should be
                // OK here.
                //
                RtlCopyMemory(waitBlock->RealMdl,
                              Mdl,
                              sizeof(MDL));

                //
                // mapRegisterFile gets destroyed here. We may need it if
                // Get fails so save it now
                //
                mapRegisterFileCopy = mapRegisterFile;
                ViSwap(&mapRegisterFile, &Mdl, &CurrentVa);

            }
            else {
                //
                // If for some strange reason we couldn't map the whole buffer
                // (that is bad because we just created the double- buffer to be exactly
                // the size we wanted)
                //

                ViFreeMapRegisterFile(adapterInformation, mapRegisterFile);
                ExFreePool(waitBlock);
                waitBlock = NULL;
            }
        } // IF double buffering //

    } // If verifying adapter //

__NoDoubleBuffer:

    status = (getScatterGatherList)(
        DmaAdapter,
        DeviceObject,
        Mdl,
        CurrentVa,
        Length,
        ExecutionRoutine,
        Context,
        WriteToDevice
        );

    if (adapterInformation && ! NT_SUCCESS(status)) {
        DECREMENT_SCATTER_GATHER_LISTS(adapterInformation);
        //
        // The driver will not call Put because Get failed so we will not do
        // cleanup. If needed, undo any allocations we've made.
        //
        if (mapRegisterFileCopy) {
            ViFreeMapRegisterFile(adapterInformation, mapRegisterFileCopy);
        }
        if (waitBlock) {
           //
           // Make sure we remove it from the scatter gather list
           // If it is not added, nothing will happen
           //
           VF_REMOVE_FROM_LOCKED_LIST(&adapterInformation->ScatterGatherLists, waitBlock);
           ExFreePool(waitBlock);
        }
    }

    return status;

} // VfGetScatterGatherList //


THUNKED_API
VOID
VfPutScatterGatherList(
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    Hooked version of PutScatterGatherList.

Arguments:

    DmaAdapter -- adapter of dma.
    ScatterGather -- scatter gather list we are putting away.
    WriteToDevice -- which direction we are transferring.

Return Value:

    NONE.

--*/
{
    PPUT_SCATTER_GATHER_LIST putScatterGatherList;
    PADAPTER_INFORMATION adapterInformation;



    putScatterGatherList = (PPUT_SCATTER_GATHER_LIST)
        ViGetRealDmaOperation(
            DmaAdapter,
            DMA_OFFSET(PutScatterGatherList) );

    adapterInformation = ViGetAdapterInformation(DmaAdapter);

    if (adapterInformation) {
        VF_ASSERT_IRQL(DISPATCH_LEVEL);

        if ( ! VF_IS_LOCKED_LIST_EMPTY(&adapterInformation->ScatterGatherLists) ) {
            //
            // We've got some double bufferin candidates.
            // Note we don't just check for whether doublebuffering is
            // enabled since a. it can be turned off on the fly and b.
            // we may have failed to allocate the overhead structures and
            // not double buffered this particular list
            //

            PVF_WAIT_CONTEXT_BLOCK waitBlock;
            KIRQL Irql;

            VF_LOCK_LIST(&adapterInformation->ScatterGatherLists, Irql);

            FOR_ALL_IN_LIST(VF_WAIT_CONTEXT_BLOCK, &adapterInformation->ScatterGatherLists.ListEntry, waitBlock) {

                if (waitBlock->ScatterGatherList == ScatterGather) {
                //
                // We found what we're looking for.
                //

                    ULONG elements = ScatterGather->NumberOfElements;

                    VF_REMOVE_FROM_LOCKED_LIST_DONT_LOCK(&adapterInformation->ScatterGatherLists, waitBlock);
                    VF_UNLOCK_LIST(&adapterInformation->ScatterGatherLists, Irql);

                    //
                    // Call the real scatter gather function
                    //
                    (putScatterGatherList)(
                        DmaAdapter,
                        ScatterGather,
                        WriteToDevice
                        );

                    SUBTRACT_MAP_REGISTERS(adapterInformation, elements);
                    DECREMENT_SCATTER_GATHER_LISTS(adapterInformation);

                    //
                    // Un double buffer us
                    // (copy out the double buffer)
                    //
                    if (! ViFlushDoubleBuffer(
                        waitBlock->MapRegisterFile,
                        waitBlock->RealMdl,
                        waitBlock->RealStartVa,
                        waitBlock->RealLength,
                        WriteToDevice )) {

                        ASSERT(0 && "HAL Verifier error -- could not flush scatter gather double buffer");

                    }
                    //
                    // free the map register file
                    //
                    if (!ViFreeMapRegisterFile(
                        adapterInformation,
                        waitBlock->MapRegisterFile)) {

                        ASSERT(0 && "HAL Verifier error -- could not free map register file for scatter gather");

                    }


                    if(ViSuperDebug) {
                        DbgPrint("%p Freeing Wait Block\n",waitBlock);
                    }

                    ExFreePool(waitBlock);
                    return;
                }

            } // For each scatter gather list allocated for this adapter //

            VF_UNLOCK_LIST(&adapterInformation->ScatterGatherLists, Irql);

        }

    }

    (putScatterGatherList)(
        DmaAdapter,
        ScatterGather,
        WriteToDevice
        );

    if (adapterInformation) {
        DECREMENT_SCATTER_GATHER_LISTS(adapterInformation);
    }

} // VfPutScatterGatherList //

NTSTATUS
VfCalculateScatterGatherListSize(
     IN PDMA_ADAPTER DmaAdapter,
     IN OPTIONAL PMDL Mdl,
     IN PVOID CurrentVa,
     IN ULONG Length,
     OUT PULONG  ScatterGatherListSize,
     OUT OPTIONAL PULONG pNumberOfMapRegisters
     )
/*++

Routine Description:

    Hooked version of CalculateScatterGatherListSize.
    We don't do anything here

Arguments:

    Same as CalculateScatterGatherListSize

Return Value:

    NTSTATUS code

--*/

{
    PCALCULATE_SCATTER_GATHER_LIST_SIZE calculateSgListSize;

    calculateSgListSize = (PCALCULATE_SCATTER_GATHER_LIST_SIZE )
        ViGetRealDmaOperation(
            DmaAdapter,
            DMA_OFFSET(CalculateScatterGatherList)
            );

    return (calculateSgListSize) (
        DmaAdapter,
        Mdl,
        CurrentVa,
        Length,
        ScatterGatherListSize,
        pNumberOfMapRegisters
        );

} // VfCalculateScatterGatherListSize //

NTSTATUS
VfBuildScatterGatherList(
     IN PDMA_ADAPTER DmaAdapter,
     IN PDEVICE_OBJECT DeviceObject,
     IN PMDL Mdl,
     IN PVOID CurrentVa,
     IN ULONG Length,
     IN PDRIVER_LIST_CONTROL ExecutionRoutine,
     IN PVOID Context,
     IN BOOLEAN WriteToDevice,
     IN PVOID   ScatterGatherBuffer,
     IN ULONG   ScatterGatherLength
     )
/*++

Routine Description:

    Hooked version of BuildScatterGatherList

Arguments:

    Same as BuildScatterGatherList

Return Value:

    NTSTATUS code

--*/
{

    PBUILD_SCATTER_GATHER_LIST buildScatterGatherList;
    PADAPTER_INFORMATION adapterInformation;
    NTSTATUS status;
    PVF_WAIT_CONTEXT_BLOCK_EX waitBlock = NULL;
    PMAP_REGISTER_FILE mapRegisterFileCopy = NULL;

    buildScatterGatherList =  (PBUILD_SCATTER_GATHER_LIST)
        ViGetRealDmaOperation(
            DmaAdapter,
            DMA_OFFSET(BuildScatterGatherList) );


    adapterInformation = ViGetAdapterInformation(DmaAdapter);

    if (adapterInformation) {
        VF_ASSERT_IRQL(DISPATCH_LEVEL);

        if (VfInjectDmaFailure() == TRUE) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        INCREMENT_SCATTER_GATHER_LISTS(adapterInformation);

        //
        // NOTE -- this may cause a page-fault while at dispatch level if
        //  the buffer is not locked down. Thats ok because we would bugcheck
        //  anyway if the buffer's not locked down.
        //
        VERIFY_BUFFER_LOCKED(Mdl);

        if (ViDoubleBufferDma) {

            PMAP_REGISTER_FILE mapRegisterFile;
            ULONG bytesMapped;
            //
            // We will allocate space for the MDL after the wait block.
            // This is because we cannot be sure that the storage for the MDL
            // will not freed by the driver at PutScatterGatherList time.
            // Also pay attention to alignment issues.
            //
            waitBlock = ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(VF_WAIT_CONTEXT_BLOCK_EX),
                HAL_VERIFIER_POOL_TAG);


            //
            // If exalloc... failed we can't to double buffering
            //
            if (! waitBlock) {

                goto __NoDoubleBuffer;

            }

            if(ViSuperDebug) {
                DbgPrint("    %p Allocated Wait Block\n",waitBlock );
            }

            RtlZeroMemory(waitBlock, sizeof(VF_WAIT_CONTEXT_BLOCK));
            waitBlock->RealContext  = Context;
            waitBlock->RealCallback = (PVOID)ExecutionRoutine;
            waitBlock->NumberOfMapRegisters = ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, Length);
            waitBlock->AdapterInformation = adapterInformation;
            InitializeListHead(&waitBlock->ListEntry);

            mapRegisterFile = ViAllocateMapRegisterFile(
                adapterInformation,
                waitBlock->NumberOfMapRegisters
                );

            if (! mapRegisterFile ) {

                if(ViSuperDebug) {

                    DbgPrint("%p Freeing Wait Block\n",waitBlock);

                }

                ExFreePool(waitBlock);
                waitBlock = NULL;
                goto __NoDoubleBuffer;

            }

            //
            // Signal that the map register file is for scatter gather
            // this will make sure that the whole buffer gets mapped
            //
            mapRegisterFile->ScatterGather = TRUE;
            waitBlock->MapRegisterFile = mapRegisterFile;
            //
            // Save the pointer to our previously allocated storage
            //
            waitBlock->RealMdl         = &waitBlock->Mdl;
            waitBlock->RealStartVa     = CurrentVa;
            waitBlock->RealLength      = Length;


            bytesMapped = ViMapDoubleBuffer(
                mapRegisterFile,
                Mdl,
                CurrentVa,
                Length,
                WriteToDevice );

            if (bytesMapped) {
            //
            // Since we mapped the buffer, we can hook the callback
            // routine & send out wait block as the parameter
            //

                Context = waitBlock;
                ExecutionRoutine = VfScatterGatherCallback;
                //
                // Copy the original MDL
                //
                RtlCopyMemory(waitBlock->RealMdl,
                              Mdl,
                              sizeof(MDL));


                //
                // mapRegisterFile gets destroyed here. We may need it if
                // the real HAL routine fails, so save it here
                //
                mapRegisterFileCopy = mapRegisterFile;
                ViSwap(&mapRegisterFile, &Mdl, &CurrentVa);

            }
            else {
                //
                // If for some strange reason we couldn't map the whole buffer
                // (that is bad because we just created the double- buffer to be exactly
                // the size we wanted)
                //
                ViFreeMapRegisterFile(adapterInformation, mapRegisterFile);
                ExFreePool(waitBlock);
                waitBlock = NULL;
            }
        } // IF double buffering //

    } // If verifying adapter //

__NoDoubleBuffer:



    status = (buildScatterGatherList)(
        DmaAdapter,
        DeviceObject,
        Mdl,
        CurrentVa,
        Length,
        ExecutionRoutine,
        Context,
        WriteToDevice,
        ScatterGatherBuffer,
        ScatterGatherLength
        );

    if (adapterInformation && ! NT_SUCCESS(status)) {

        DECREMENT_SCATTER_GATHER_LISTS(adapterInformation);
        //
        // If needed, undo any allocations we've made
        //
        if (mapRegisterFileCopy) {
            ViFreeMapRegisterFile(adapterInformation, mapRegisterFileCopy);
        }
        if (waitBlock) {
           //
           // Make sure we remove it from the scatter gather list
           // If it is not added, nothing will happen
           //
           VF_REMOVE_FROM_LOCKED_LIST(&adapterInformation->ScatterGatherLists, waitBlock);
           ExFreePool(waitBlock);
        }

    }

    return status;


} // VfBuildScatterGatherList //


NTSTATUS
VfBuildMdlFromScatterGatherList(
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    )
/*++

Routine Description:

    Hooked version of BuildMdlFromScatterGatherList.
    Don't really do anything here

Arguments:

    Same as BuildMdlFromScatterGatherList

Return Value:

    NTSTATUS code

--*/
{
    PBUILD_MDL_FROM_SCATTER_GATHER_LIST buildMdlFromScatterGatherList;

    buildMdlFromScatterGatherList = (PBUILD_MDL_FROM_SCATTER_GATHER_LIST)
        ViGetRealDmaOperation(
            DmaAdapter,
            DMA_OFFSET(BuildMdlFromScatterGatherList) );

    return (buildMdlFromScatterGatherList) (
            DmaAdapter,
            ScatterGather,
            OriginalMdl,
            TargetMdl
            );

} // VfBuildMdlFromScatterGatherList //



IO_ALLOCATION_ACTION
VfAdapterCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )
/*++

Routine Description:

    We hook the callback from AllocateAdapterChannel so we that we can make
    sure that the driver only tries to do this one at a time.

Arguments:

    DeviceObject -- device object.
    Irp -- current irp.
    MapRegisterBase -- magic number provided by HAL
    Context -- A special context block with relevant information inside.

Return Value:

    NONE.

--*/
{
    PVF_WAIT_CONTEXT_BLOCK contextBlock =
        (PVF_WAIT_CONTEXT_BLOCK) Context;
    IO_ALLOCATION_ACTION allocationAction;
    PADAPTER_INFORMATION adapterInformation;


    if (VALIDATE_MAP_REGISTER_FILE_SIGNATURE(contextBlock->MapRegisterFile)) {

        //
        // Do the old switcheroo -- we are now substituting *our* map
        // register base for *theirs* (and hide a pointer to *theirs*
        // in *ours*)
        //

        contextBlock->MapRegisterFile->MapRegisterBaseFromHal =
            MapRegisterBase;
        MapRegisterBase = contextBlock->MapRegisterFile;

    }
    else {
        //
        // Some drivers (scsiport for one) don't call
        // HalFlushAdapterBuffers unless MapRegisterBase is non-null.
        // In order to fool the drivers into thinking that they need
        // to flush, we exchange the NULL MapRegisterBase (if in fact
        // the hal uses a null map register base) for our
        /// MRF_NULL_PLACEHOLDER.
        //

        //
        // 12/15/2000 - Use the non-NULL placeholder
        // only if the original MapRegisterBase is NULL,
        // otherwise leave it alone...
        //
        if (NULL == MapRegisterBase) {
          MapRegisterBase = MRF_NULL_PLACEHOLDER;
        }
    }

    adapterInformation = contextBlock->AdapterInformation;

    //
    // Fix a weird race condition:
    // - if we expect the callback to return something other than KeepObject
    //   we're going to decrement the adapter channel count in advance
    //   to prevent ndis from calling another AllocateAdapterChannel before
    //   we can make it to the DECREMENT_ADAPTER_CHANNEL call
    //
    if (adapterInformation &&
        adapterInformation->DeviceDescription.Master) {
        //
        // Master devices are the ones that return
        // DeallocateObjectKeepRegisters.
        //
        DECREMENT_ADAPTER_CHANNELS(adapterInformation);

    }

    //
    // Call the *real* callback routine
    //
    allocationAction =  ((PDRIVER_CONTROL) contextBlock->RealCallback)(
        DeviceObject,
        Irp,
        MapRegisterBase,
        contextBlock->RealContext
        );

    if (! adapterInformation) {

        return allocationAction;

    }

    //
    // Ok if we keep everything, just return
    //
    if (allocationAction == KeepObject) {
        //
        // Only slave devices should get here
        //
        if (adapterInformation->DeviceDescription.Master) {
            //
            // We should not get here. But if we do, compensate for the
            // DECREMENT_ADAPTER_CHANNELS we did before just in case.
            // We do a InterlockedDecrement instead of a
            // INCREMENT_ADAPTER_CHANNELS so our allocated and freed
            // count reflect the number of real alloc/free operations performed.
            //
            InterlockedDecrement((PLONG)(&adapterInformation->FreedAdapterChannels));
            DbgPrint("Driver at address %p has a problem\n", adapterInformation->CallingAddress );
            DbgPrint("Master devices should return DeallocateObjectKeepRegisters\n");
            ASSERT(0);
        }

        adapterInformation->AdapterChannelMapRegisters =
            contextBlock->NumberOfMapRegisters;
        return allocationAction;
    }


    //
    // Otherwise we are definitely freeing the adapter channel.
    // Keep in mind that we have done this for Master devices,
    // do it just for Slave devices.
    //
    if (!adapterInformation->DeviceDescription.Master) {
        DECREMENT_ADAPTER_CHANNELS(adapterInformation);
    }


    if (allocationAction == DeallocateObjectKeepRegisters) {

        return allocationAction;

    }

    //
    // Ok now we know we're getting rid of map registers too...
    //
    SUBTRACT_MAP_REGISTERS( adapterInformation,
        contextBlock->NumberOfMapRegisters );

    //
    // False alarm ... we went through all the trouble of allocating the
    // double map buffer registers and they don't even want them. We should
    // bugcheck out of spite.
    //
    if (VALIDATE_MAP_REGISTER_FILE_SIGNATURE(contextBlock->MapRegisterFile)) {

        ViFreeMapRegisterFile(
            adapterInformation,
            contextBlock->MapRegisterFile);

    }


    return allocationAction;

} // VfAdapterCallback //


#if !defined (NO_LEGACY_DRIVERS)
PADAPTER_OBJECT
VfLegacyGetAdapter(
    IN PDEVICE_DESCRIPTION  DeviceDescription,
    IN OUT PULONG  NumberOfMapRegisters
    )
/*++

Routine Description:

    This function is a bit of a hack made necessary by the drivers that use
    a different hack -- they use nt4 apis instead of the new ones. We
    allocate an adapter and mark it as legacy -- we will have to hook the dma
    functions the old fashioned way instead of from the dma operations.

    We don't have to worry that the new-fangled dma apis call the old'ns
    as long as the hal-kernel interface isn't hooked -- since the new apis
    will call the old from the kernel, the thunks will still point to the
    hal and not to us.

Arguments:

    DeviceDescription -- A structure describing the device we are trying to
        get an adapter for. At some point, I'm going to monkey around with
        this guy so we can convince the HAL that we are something that we're
        not, but for now just gets passed straight into IoGetDmaAdapter.
    NumberOfMapRegisters -- maximum number of map registers that the driver
        is going to try to allocate.

Return Value:

    Returns a pointer to the dma adapter or
    NULL if we couldn't allocate one.


--*/

{
    PVOID callingAddress;
    PADAPTER_INFORMATION newAdapterInformation;
    PDMA_ADAPTER dmaAdapter;

    //
    // Give the option of not verifying at all
    //
    if (! ViVerifyDma ) {

        return HalGetAdapter(DeviceDescription, NumberOfMapRegisters);

    }
    if (VfInjectDmaFailure()) {
        return NULL;

    }

    VF_ASSERT_IRQL(PASSIVE_LEVEL);

    GET_CALLING_ADDRESS(callingAddress);

    VF_ASSERT(
        0,
        HV_OBSOLETE_API,
        ("HalGetAdapter API obsolete -- use IoGetDmaAdapter instead")
        );


    if ( ViDoubleBufferDma &&
        *NumberOfMapRegisters > ViMaxMapRegistersPerAdapter ) {

        //
        //  Harumph -- don't let drivers try to get too many map registers
        //
        *NumberOfMapRegisters = ViMaxMapRegistersPerAdapter;

    }

    dmaAdapter = (PDMA_ADAPTER) HalGetAdapter(
        DeviceDescription,
        NumberOfMapRegisters
        );

    if (! dmaAdapter ) {

        //
        // early opt-out here -- the hal couldn't allocate the adapter
        //
        return NULL;

    }

    //
    // Replace all of the dma operations that live in the adapter with our
    // dma operations.. If we can't do it, fail.
    //
    newAdapterInformation = ViHookDmaAdapter(
        dmaAdapter,
        DeviceDescription,
        *NumberOfMapRegisters
        );
    if (! newAdapterInformation) {
        //
        // remember to put away our toys -- even though we've been called
        // with legacy apis, we can still do the right thing here.
        //
        dmaAdapter->DmaOperations->PutDmaAdapter(dmaAdapter);
        return NULL;
    }

    newAdapterInformation->DeviceObject = NULL;
    newAdapterInformation->CallingAddress      = callingAddress;

    return (PADAPTER_OBJECT) dmaAdapter;


} // VfLegacyGetAdapter //
#endif

PVOID
ViSpecialAllocateCommonBuffer(
    IN PALLOCATE_COMMON_BUFFER AllocateCommonBuffer,
    IN PADAPTER_INFORMATION AdapterInformation,
    IN PVOID CallingAddress,
    IN ULONG Length,
    IN OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN LOGICAL CacheEnabled
    )

/*++

Routine Description:

    Special version of allocate common buffer that keeps close track of
    allocations.

Arguments:

    AllocateCommonBuffer -- pointer to the hal buffer allocation routine.
    AdapterInformation -- contains information about the adapter we're using.
    CallingAddress -- who called us -- (who called VfAllocateCommonBuffer).

    Length  -- Size of the common buffer (note we are going to increase).
    LogicalAddress -- Gets the *PHYSICAL* address of the common buffer.
    CacheEnabled -- whether or not the memory should be cached.

Return Value:

    Returns the *VIRTUAL* address of the common buffer or
        NULL if it could not be allocated.


--*/
{
    ULONG desiredLength;
    ULONG paddingLength;
    ULONG prePadding;
    ULONG postPadding;
    PHAL_VERIFIER_BUFFER verifierBuffer;
    PUCHAR commonBuffer;
    PHYSICAL_ADDRESS realLogicalAddress;

    //
    // First check if we are under the limit for common buffer verification
    // for this adapter.
    //
    if ((AdapterInformation->AllocatedCommonBuffers - AdapterInformation->FreedCommonBuffers)
          >= ViMaxCommonBuffersPerAdapter) {
        return NULL;
    }


    verifierBuffer = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(HAL_VERIFIER_BUFFER),
        HAL_VERIFIER_POOL_TAG
        );
    if (!verifierBuffer) {
        DbgPrint("Couldn't track common buffer allocation\n");
        return NULL;
    }

    ViCommonBufferCalculatePadding(Length, &prePadding, &postPadding);

    paddingLength = prePadding + postPadding;
    desiredLength = paddingLength + Length;

    if (ViSuperDebug) {

        DbgPrint("Common buffer req len:%x alloc len %x, padding %x / %x\n",
            Length, desiredLength, prePadding, postPadding);
    }

    if (ViProtectBuffers) {

        ASSERT( !BYTE_OFFSET(desiredLength) );
        // ASSERT( paddingLength >= 2 * sizeof(ViDmaVerifierTag));
    }

    //
    // Call into the hal to try to get us a common buffer
    //
    commonBuffer = (AllocateCommonBuffer)(
        AdapterInformation->DmaAdapter,
        desiredLength,
        &realLogicalAddress,
        (BOOLEAN) CacheEnabled
        );

    if (! commonBuffer) {

#if DBG
        DbgPrint("Could not allocate 'special' common buffer size %x\n",
            desiredLength);
#endif
        ExFreePool(verifierBuffer);
        return NULL;

    }


    //
    // This is our overhead structure we're zeroing out here
    //
    RtlZeroMemory(verifierBuffer, sizeof(HAL_VERIFIER_BUFFER));

    //
    // Save off all of the data we have
    //
    verifierBuffer->PrePadBytes      = (USHORT) prePadding;
    verifierBuffer->PostPadBytes     = (USHORT) postPadding;

    verifierBuffer->AdvertisedLength = Length;
    verifierBuffer->RealLength       = desiredLength;

    verifierBuffer->RealStartAddress        = commonBuffer;
    verifierBuffer->AdvertisedStartAddress  = commonBuffer + prePadding;
    verifierBuffer->RealLogicalStartAddress = realLogicalAddress;

    verifierBuffer->AllocatorAddress        = CallingAddress;


    //
    // Fill the common buffer with junk to a. mark it and b. so no one uses
    // it without initializing it.
    //
    ViInitializePadding(
        verifierBuffer->RealStartAddress,
        verifierBuffer->RealLength,
        verifierBuffer->AdvertisedStartAddress,
        verifierBuffer->AdvertisedLength
        );


    //
    // Tell the driver that the allocation is in the middle of our guarded
    // section
    //
    LogicalAddress->QuadPart = realLogicalAddress.QuadPart + prePadding;

    VF_ADD_TO_LOCKED_LIST( &AdapterInformation->CommonBuffers,
        verifierBuffer );

    INCREMENT_COMMON_BUFFERS(AdapterInformation);

    return (commonBuffer+prePadding);
} // ViSpecialAllocateCommonBuffer //


LOGICAL
ViSpecialFreeCommonBuffer(
    IN PFREE_COMMON_BUFFER FreeCommonBuffer,
    IN PADAPTER_INFORMATION AdapterInformation,
    IN PVOID CommonBuffer,
    LOGICAL CacheEnabled
    )

/*++

Routine Description:

    Tries to undo the damage done by the special common buffer allocator.

Arguments:

    FreeCommonBuffer -- pointer to the hal buffer free routine.
    AdapterInformation -- contains information about the adapter we're using.
    CommonBuffer -- we use this to look up which allocation to free.
    CacheEnabled -- whether or not the buffer was cached.

Return Value:

    NONE


--*/
{
    PHAL_VERIFIER_BUFFER verifierBuffer;

    verifierBuffer = VF_FIND_BUFFER(&AdapterInformation->CommonBuffers,
        CommonBuffer);

    if (! verifierBuffer) {

        //
        // We couldn't find this buffer in the list
        //

        if (ViProtectBuffers) {

            DbgPrint("HV: Couldn't find buffer %p\n",CommonBuffer);
        }

        return FALSE;
    }

    if (ViProtectBuffers) {
        //
        // When we created the buffer we built in a bit of padding at the
        // beginning and end of the  allocation -- make sure that nobody has
        // touched it.
        //

        ViCheckPadding(
            verifierBuffer->RealStartAddress,
            verifierBuffer->RealLength,
            verifierBuffer->AdvertisedStartAddress,
            verifierBuffer->AdvertisedLength
            );
    }

    //
    // Take this buffer out of circulation.
    //
    VF_REMOVE_FROM_LOCKED_LIST( &AdapterInformation->CommonBuffers,
        verifierBuffer);



    //
    // Zero out the common buffer memory so that nobody tries to access
    // it after it gets freed
    //
    RtlZeroMemory(CommonBuffer, verifierBuffer->AdvertisedLength);


    (FreeCommonBuffer)(
        AdapterInformation->DmaAdapter,
        verifierBuffer->RealLength,
        verifierBuffer->RealLogicalStartAddress,
        verifierBuffer->RealStartAddress,
        (BOOLEAN) CacheEnabled
        );


    DECREMENT_COMMON_BUFFERS(AdapterInformation);

    ExFreePool(verifierBuffer);
    return TRUE;
} // ViSpecialFreeCommonBuffer //



PMAP_REGISTER_FILE
ViAllocateMapRegisterFile(
    IN PADAPTER_INFORMATION AdapterInformation,
    IN ULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    In order to isolate a mapped buffer, we're going to do double buffering
    ourselves. We allocate buffers that we will use when the driver calls
    MapTransfer.

    N.B. This function is almost as messy as my dorm room in college.

    When we are doing dma, we have a buffer that will look like this:

    Virtual               Physical
     Buffer               memory
     to do
     dma with
                        +------+
    +------+            |   3  |
    |   1  |            +------+
    +------+                            +------+
    |   2  |    <-->                    |   4  |
    +------+                +------+    +------+
    |   3  |                |   1  |              +------+
    +------+                +------+              |   2  |
    |   4  |                                      +------+
    +------+

    The problem is that since the pages are scattered around physical memory,
    If the hardware overruns the buffer, we'll never know or it will cause
    a random failure down the line. What I want to do is allocate the pages
    physically on either side of each page of the transfer  like this:
    (where the 'X' pages are filed with a known pattern that we can test to
    make sure they haven't changed).


     Virtual              Physical
     Buffer               memory
     to do              +------+
     dma with           |XXXXXX|
                        +------+
    +------+            |   3  |            +------+
    |   1  |            +------+            |XXXXXX|
    +------+            |XXXXXX|+------+    +------+
    |   2  |    <-->    +------+|XXXXXX|    |   4  |  +------+
    +------+                    +------+    +------+  |XXXXXX|
    |   3  |                    |   1  |    |XXXXXX|  +------+
    +------+                    +------+    +------+  |   2  |
    |   4  |                    |XXXXXX|              +------+
    +------+                    +------+              |XXXXXX|
                                                      +------+

    In order to do this, for each map register needed by the device, I create
    one of the 3-contiguous page entities shown above. Then I create an mdl
    and map the center pages into a single virtual buffer. After this is set
    up, during each map transfer, I have to copy the contents of the driver's
    virtual buffer into my newly created buffer and pass this to the HAL.
    (IoMapTransfer is really in the HAL despite the prefix). The contents are
    copied back when a FlushAdapterBuffers is done.

    N.B. For slave devices, the pages have to be contiguous in memory. So
        the above won't work.

Arguments:

    AdapterInformation -- contains information about the adapter we're using
    NumberOfMapRegisters -- how many map registers to allocate.

Return Value:

    New map register file pointer (of course we also add it to the
        adapterinformation list) or NULL on failure.

--*/

{
    ULONG mapRegisterBufferSize;
    PMAP_REGISTER_FILE mapRegisterFile;
    PMDL mapRegisterMdl;

    PPFN_NUMBER registerFilePfnArray;
    PFN_NUMBER  registerPfn;

    PMAP_REGISTER tempMapRegister;

    ULONG mapRegistersLeft;

    //
    // Make sure we haven't tried to allocate too many map registers to
    // this device
    //
    mapRegistersLeft = AdapterInformation->ActiveMapRegisters;

    if ( mapRegistersLeft + NumberOfMapRegisters > ViMaxMapRegistersPerAdapter ) {
        //
        // Don't have enough room in this adpter's quota to allocate the
        // map registers. Why do we need a quota at all? Because annoying
        // drivers like NDIS etc. try to get around their maximum map
        // register allocation by cheating. Ok so they don't cheat but
        // they demand like thousands of map registers two at a time.
        // Actually returning null here doesn't affect whether the driver
        // gets the map registers or not .. we're just not going to double
        // buffer them.
        //
        return NULL;
    }

    if (0 == NumberOfMapRegisters) {
       //
       // This is weird but still legal, just don't double
       // buffer in this case.
       //
       return NULL;
    }
    //
    // Allocate space for the register file
    //
    mapRegisterBufferSize =
        sizeof(MAP_REGISTER_FILE) +
        sizeof(MAP_REGISTER) * (NumberOfMapRegisters-1);

    mapRegisterFile = ExAllocatePoolWithTag(
        NonPagedPool,
        mapRegisterBufferSize,
        HAL_VERIFIER_POOL_TAG
        );

    if (! mapRegisterFile)
        return NULL;

    if (ViSuperDebug) {
        DbgPrint("%p Allocated Map register file\n",mapRegisterFile);
    }



    RtlZeroMemory(mapRegisterFile, mapRegisterBufferSize);

    //
    // This is all we can set right now. We set the MapRegisterBaseFromHal
    // in AllocateAdapterChannel and the MappedBuffer in MapTransfer
    //
    mapRegisterFile->NumberOfMapRegisters = NumberOfMapRegisters;

    mapRegisterMdl = IoAllocateMdl(
        NULL,
        NumberOfMapRegisters << PAGE_SHIFT,
        FALSE,
        FALSE,
        NULL
        );

    if (! mapRegisterMdl) {

        goto CleanupFailure;
    }


    if (ViSuperDebug) {

        DbgPrint("    %p Allocated MDL\n",mapRegisterMdl);
    }

    //
    // Allocate the original buffer as well
    //
    mapRegisterFile->OriginalBuffer = ExAllocatePoolWithTag(
        NonPagedPool,
        NumberOfMapRegisters << PAGE_SHIFT,
        HAL_VERIFIER_POOL_TAG
        );

    if (!mapRegisterFile->OriginalBuffer) {

       goto CleanupFailure;
    }

    if (ViSuperDebug) {
       DbgPrint("    %p Allocated OriginalBuffer\n", mapRegisterFile->OriginalBuffer);
    }

    registerFilePfnArray = MmGetMdlPfnArray(mapRegisterMdl);

    tempMapRegister = &mapRegisterFile->MapRegisters[0];

    for(NOP;
        NumberOfMapRegisters;
        NumberOfMapRegisters--, tempMapRegister++, registerFilePfnArray++ ) {

        PHYSICAL_ADDRESS registerPhysical;


        //
        // I really want to use MmAllocatePagesForMdl, which would make my
        // life much easier, but it can only be called at IRQL <= APC_LEVEL.
        // So I have to double-map these pages -- i.e. allocate them from the
        // Cache aligned non paged pool which will most likely give me
        // consecutive pages in physical memory. Then I take those pages and
        // build a custom Mdl with them. Then I map them with
        // MmMapLockedPagesSpecifyCache
        //


        //
        // Allocate the map register, its index will be the hint
        //
        tempMapRegister->MapRegisterStart = ViAllocateFromContiguousMemory(
            AdapterInformation,
            mapRegisterFile->NumberOfMapRegisters - NumberOfMapRegisters
            );
        if (tempMapRegister->MapRegisterStart) {
           InterlockedIncrement((PLONG)&AdapterInformation->ContiguousMapRegisters);
        }  else {
           tempMapRegister->MapRegisterStart = ExAllocatePoolWithTag(
              NonPagedPoolCacheAligned,
              3 * PAGE_SIZE,
              HAL_VERIFIER_POOL_TAG
              );
           if (tempMapRegister->MapRegisterStart) {
              InterlockedIncrement((PLONG)&AdapterInformation->NonContiguousMapRegisters);
           } else {

              goto CleanupFailure;
           }
        }
        //
        // Fill the map register padding area
        // We don't want to tag it because we
        // don't know where the buffer is going
        // to get mapped.
        // This essentially just zeroes
        // out the whole buffer.
        //
        ViInitializePadding(
            tempMapRegister->MapRegisterStart,
            3 * PAGE_SIZE,
            NULL,
            0
            );


        if (ViSuperDebug) {
            DbgPrint("    %p Allocated Map Register (%x)\n",
                tempMapRegister->MapRegisterStart,
                mapRegisterFile->NumberOfMapRegisters - NumberOfMapRegisters);
        }


        //
        // Add the middle page of the allocation to our register
        // file mdl
        //
        registerPhysical = MmGetPhysicalAddress(
            (PUCHAR) tempMapRegister->MapRegisterStart + PAGE_SIZE );

        registerPfn = (PFN_NUMBER) (registerPhysical.QuadPart >> PAGE_SHIFT);

        RtlCopyMemory(
            (PVOID) registerFilePfnArray,
            (PVOID) &registerPfn,
            sizeof(PFN_NUMBER) ) ;

    }    // For each map register //

    //
    // Now we have a mdl with all of our map registers physical pages entered
    // in, we have to map this into virtual address space.
    //
    mapRegisterMdl->MdlFlags |= MDL_PAGES_LOCKED;

    mapRegisterFile->MapRegisterBuffer = MmMapLockedPagesSpecifyCache (
        mapRegisterMdl,
        KernelMode,
        MmCached,
        NULL,
        FALSE,
        NormalPagePriority
        );

    if (! mapRegisterFile->MapRegisterBuffer) {

        goto CleanupFailure;
    }


    mapRegisterFile->MapRegisterMdl = mapRegisterMdl;

    //
    // Since we are going to be mixing our map register files with system
    // MapRegisterBase's we want to be able to make sure that it's really
    // ours.
    //
    SIGN_MAP_REGISTER_FILE(mapRegisterFile);

    KeInitializeSpinLock(&mapRegisterFile->AllocationLock);

    VF_ADD_TO_LOCKED_LIST(
        &AdapterInformation->MapRegisterFiles,
        mapRegisterFile );

    return mapRegisterFile;

CleanupFailure:
    //
    // Its all or nothing ... if we can't allocate the map register buffer,
    // kill all of the memory that we've allocated and get out
    //
#if DBG
    DbgPrint("Halverifier: Failed to allocate double buffered dma registers\n");
#endif

    tempMapRegister = &mapRegisterFile->MapRegisters[0];

    for (NumberOfMapRegisters = mapRegisterFile->NumberOfMapRegisters;
        NumberOfMapRegisters && tempMapRegister->MapRegisterStart;
        NumberOfMapRegisters--, tempMapRegister++) {

        if (!ViFreeToContiguousMemory(AdapterInformation,
                tempMapRegister->MapRegisterStart,
                mapRegisterFile->NumberOfMapRegisters - NumberOfMapRegisters)) {

                //
                // Could not find the address in the contiguous buffers pool
                // it must be from non-paged pool.
                //
                ExFreePool(tempMapRegister->MapRegisterStart);
        }

    }

    if (mapRegisterMdl) {
        IoFreeMdl(mapRegisterMdl);
    }
    if (mapRegisterFile->OriginalBuffer) {
       ExFreePool(mapRegisterFile->OriginalBuffer);
    }

    ExFreePool(mapRegisterFile);
    return NULL;
} // ViAllocateMapRegisterFile//

LOGICAL
ViFreeMapRegisterFile(
    IN PADAPTER_INFORMATION AdapterInformation,
    IN PMAP_REGISTER_FILE MapRegisterFile
    )
/*++

Routine Description:

    Get rid of the map registers.

Arguments:

    AdapterInformation -- contains information about the adapter we're using
    MapRegisterFile -- what to free.
    NumberOfMapRegisters -- We don't need this except to check that its the
        same as the map registers were allocated. Only check this when doing
        packet dma not scatter gather.

Return Value:

    TRUE -- MapRegisterFile is really a MapRegisterFile.
    FALSE -- MapRegisterFile wasn't really a MapRegisterFile.


--*/

{
    PMAP_REGISTER tempMapRegister;
    ULONG mapRegisterNumber;

    if (! VALIDATE_MAP_REGISTER_FILE_SIGNATURE(MapRegisterFile)) {
        //
        // This could be a real MapRegisterBase that the hal returned
        // But it's not one of ours.
        //
        return FALSE;
    }

    VF_REMOVE_FROM_LOCKED_LIST(&AdapterInformation->MapRegisterFiles,
        MapRegisterFile );
    //
    // Clear the signature from memory so we don't find it after it's freed
    // and think that it's real.
    //
    MapRegisterFile->Signature = 0;

    MmUnmapLockedPages(
        MapRegisterFile->MapRegisterBuffer,
        MapRegisterFile->MapRegisterMdl );

    tempMapRegister = &MapRegisterFile->MapRegisters[0];

    for ( mapRegisterNumber = 0  ;
        mapRegisterNumber < MapRegisterFile->NumberOfMapRegisters;
        mapRegisterNumber++, tempMapRegister++ ) {

        ASSERT(tempMapRegister->MapRegisterStart);

        if(ViSuperDebug) {

            DbgPrint("    %p Freeing Map Register (%x)\n",
                tempMapRegister->MapRegisterStart,
                mapRegisterNumber);
        }

        //
        // Make sure that the driver or hw hasn't done anything funny in
        // and around the area of the map register
        //
        if (tempMapRegister->MappedToSa) {
        //
        /// Map register is still mapped ...there better
        //  not be any data in the buffer
        //
            PUCHAR mappedSa =
                (PUCHAR) tempMapRegister->MapRegisterStart +
                    PAGE_SIZE + BYTE_OFFSET(tempMapRegister->MappedToSa);

            //
            // Make sure that the outside looks good
            //
            ViCheckPadding(
                tempMapRegister->MapRegisterStart,
                3* PAGE_SIZE,
                mappedSa,
                tempMapRegister->BytesMapped
                );
        }
        else
        {
            ViCheckPadding(tempMapRegister->MapRegisterStart, 3 * PAGE_SIZE, NULL, 0);
        }
        tempMapRegister->Flags = 0;
        //
        // Bye bye map register ...
        //
        if (!ViFreeToContiguousMemory(AdapterInformation,
                                   tempMapRegister->MapRegisterStart,
                                   mapRegisterNumber)) {
           //
           // Could not find the address in the contiguous buffers pool
           // it must be from non-paged pool.
           //
           ExFreePool(tempMapRegister->MapRegisterStart);
        }

    }

    if(ViSuperDebug)
    {
        DbgPrint("    %p Freeing MDL\n",MapRegisterFile->MapRegisterMdl);
   }



    IoFreeMdl(MapRegisterFile->MapRegisterMdl);

    if (MapRegisterFile->OriginalBuffer) {
       ExFreePool(MapRegisterFile->OriginalBuffer);
    }

    //
    // N.B.  -- we don't free the MapRegisterBuffer --- because all of its
    //     memory was just another way of looking at the MapRegisters
    //
    RtlZeroMemory(MapRegisterFile, sizeof(MapRegisterFile));


    if(ViSuperDebug) {
        DbgPrint("%p Freeing Map Register File\n",MapRegisterFile);
    }
    ExFreePool(MapRegisterFile);
    return TRUE;
} // ViFreeMapRegisterFile //


ULONG
ViMapDoubleBuffer(
    IN PMAP_REGISTER_FILE MapRegisterFile,
    IN PMDL  Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN  WriteToDevice
    )
/*++

Routine Description:

    This and ViFlushDoubleBuffer take care of double buffering to and from
    our map register files. Why do we do this? So that we can catch drivers
    that a. don't flush adapter buffers, or b. make the hardware overrun
    its allocation.

Arguments:


    MapRegisterFile-- this is our map register file containing allocated
        space for our double buffering.
    Mdl -- the mdl to map.
    CurrentVa -- in: index into the mdl to map.
    Length -- how much to map. Note we don't have to map it all unless
        ContiguousMap has been specified in the map register file.
    WriteToDevice -- TRUE we have to double buffer since we are setting up a
        write. if its false, we don't have to do much because it doesn't
        matter whats in the buffer before it gets read.


Return Value:

    Number of bytes mapped. If 0, we don't touch the mdl or current va.

--*/

{
    PUCHAR mapRegisterCurrentSa;
    PUCHAR driverCurrentSa;
    PUCHAR originalBufferCurrentSa = NULL;
    PUCHAR systemAddress = NULL;
    ULONG mapRegisterNumber;
    PMDL currentMdl;
    ULONG bytesLeft;
    ULONG currentTransferLength;

    //
    // Assert that the length cannot be 0
    //
    if (Length == 0) {
        VF_ASSERT(Length != 0,
                  HV_MAP_ZERO_LENGTH_BUFFER,
                  ("Driver is attempting to map a 0-length transfer"));
        return Length;
    }

    //
    // Right off the bat -- if we are being called by getscattergather, we
    // are going to need to map the whole thing. Otherwise just map as much
    // as is contiguous. The hal had already done these calculations, so I
    // just copied the code to determine the contiguous length of transfer.
    //
    if ( ! MapRegisterFile->ScatterGather) {
        Length = MIN(Length, PAGE_SIZE- BYTE_OFFSET(CurrentVa));
    }

    //
    // Now we know how many bytes we are going to transfer.
    //



    if ((PUCHAR) CurrentVa < (PUCHAR) MmGetMdlVirtualAddress(Mdl)) {
    //
    // System address before the beginning of the first MDL. This is bad.
    //

        VF_ASSERT((PUCHAR) CurrentVa >= (PUCHAR) MmGetMdlVirtualAddress(Mdl),
            HV_BAD_MDL,
            ("Virtual address %p is before the first MDL %p",CurrentVa, Mdl));
        return FALSE;

    }

    if ((ULONG)((PUCHAR) CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl)) >= MmGetMdlByteCount(Mdl)) {
    //
    // System address is after the end of the first MDL. This is also bad.
    //

        VF_ASSERT((ULONG)((PUCHAR) CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl)) < MmGetMdlByteCount(Mdl),
            HV_BAD_MDL,
            ("Virtual address %p is after the first MDL %p",CurrentVa, Mdl));
        return FALSE;

    }


    //
    // Get a pointer into the Mdl that we can actually use
    // N.B. this may bugcheck if the mdl isn't mapped but that's a bug
    // in the first place.
    //
    systemAddress = (PUCHAR)MmGetSystemAddressForMdlSafe(Mdl, NormalPagePriority);
    if (NULL == systemAddress) {
       return FALSE;
    }
    driverCurrentSa = systemAddress +
        ((PUCHAR) CurrentVa -
        (PUCHAR) MmGetMdlVirtualAddress(Mdl) ) ;


    //
    // Allocate contiguous map registers from our map register file
    //
    if ( ! ViAllocateMapRegistersFromFile(
        MapRegisterFile,
        driverCurrentSa,
        Length,
        WriteToDevice,
        &mapRegisterNumber
        ) ) {

        return FALSE;
    }

    //
    // Get a pointer to the base of the map registers for
    // double buffering.
    //
    mapRegisterCurrentSa =
        MAP_REGISTER_SYSTEM_ADDRESS(
           MapRegisterFile,
           driverCurrentSa,
           mapRegisterNumber );

    if (!WriteToDevice) {

        ASSERT(MapRegisterFile->OriginalBuffer);
        if (!MapRegisterFile->OriginalBuffer) {
           //
           // This is bad and should not happen, but do not try to access
           // funny addresses if it happens...
           //
           return FALSE;
        }
        originalBufferCurrentSa =
           ORIGINAL_BUFFER_SYSTEM_ADDRESS(
              MapRegisterFile,
              driverCurrentSa,
              mapRegisterNumber );

    }

   //
   // We have to copy for read and for write (for read to be able to correctly
   // perform a 3-way merge between the driver's current buffer, our buffer and
   // the driver's oroginal buffer, which we also copy)
   //

   //
   // Copy chained mdls to a single buffer at mapRegisterCurrentSa
   //
   currentMdl = Mdl;
   bytesLeft = Length;


   while (bytesLeft) {

      if (NULL == currentMdl) {

         //
         // 12/21/2000 - This should never happen
         //
         ASSERT(NULL != currentMdl);
         return FALSE;

      }

      if (currentMdl->Next == NULL && bytesLeft > MmGetMdlByteCount(currentMdl)) {
         //
         // 12/21/2000 - There are some rare cases where the buffer described
         // in the MDL is less than the transfer Length. This happens for instance
         // when the file system rounds up the file size to a multiple of sector
         // size but MM uses the exact file size in the MDL. The HAL compensates for
         // this.
         // If this is the case, use the size based on Length (bytesLeft)
         // instead of the size in the MDL (ByteCount). Also check that
         // this extra does not cross a page boundary.
         //
         if ((Length - 1) >> PAGE_SHIFT != (Length - (bytesLeft - MmGetMdlByteCount(currentMdl))) >> PAGE_SHIFT) {

            VF_ASSERT((Length - 1) >> PAGE_SHIFT == (Length - (bytesLeft - MmGetMdlByteCount(currentMdl))) >> PAGE_SHIFT,
                      HV_BAD_MDL,
                      ("Extra transfer length crosses a page boundary: Mdl %p, Length %x", Mdl, Length));
            return FALSE;


         }
         currentTransferLength = bytesLeft;

      } else {
         currentTransferLength = MIN(bytesLeft, MmGetMdlByteCount(currentMdl));
      }


      if (ViSuperDebug) {

         DbgPrint("Dbl buffer: %x bytes, %p src, %p dest\n",
                  currentTransferLength,
                  driverCurrentSa,
                  mapRegisterCurrentSa);
      }

      //
      // Since we are writing to the device, we must copy from the driver's
      // buffer to  our buffer.
      //

      RtlCopyMemory(
                   mapRegisterCurrentSa ,
                   driverCurrentSa,
                   currentTransferLength);

      mapRegisterCurrentSa+= currentTransferLength;


      if (!WriteToDevice) {
         //
         // Copy the driver's buffer into OriginalBuffer to help
         // us do the 3-way merge
         //
         RtlCopyMemory(
                      originalBufferCurrentSa,
                      driverCurrentSa,
                      currentTransferLength);

         originalBufferCurrentSa += currentTransferLength;
      }

      currentMdl = currentMdl->Next;

      //
      // The system address for other mdls must start at the
      // beginning of the MDL.
      //
      if (currentMdl) {

         driverCurrentSa = (PUCHAR)MmGetSystemAddressForMdlSafe(currentMdl, NormalPagePriority);
         if (NULL == driverCurrentSa) {
            //
            // Not much that we can do if we cannot map
            // We will just not do double-buffering.
            //
            return FALSE;
         }

      }

      bytesLeft -= currentTransferLength;


   } // for each chained mdl //


   //
   // The buffer should have been filled in with a known
   // pattern when we tagged it
   //

    //
    // Flush the buffers for our MDL
    //
    if (MapRegisterFile->MapRegisterMdl) {
        KeFlushIoBuffers(MapRegisterFile->MapRegisterMdl, !WriteToDevice, TRUE);
    }
    return Length;
} // ViMapDoubleBuffer //


LOGICAL
ViFlushDoubleBuffer(
    IN PMAP_REGISTER_FILE MapRegisterFile,
    IN PMDL   Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN  WriteToDevice
    )
/*++

Routine Description:

    This and ViMapDoubleBuffer take care of double buffering to and from
    our map register files. Why do we do this? So that we can catch drivers
    that a. don't flush adapter buffers, or b. make the hardware overrun
    its allocation.

Arguments:

    MapRegisterFile-- this is our map register file containing allocated
        space for our double buffering.
    Mdl -- the mdl to flush
    CurrentVa -- index into the mdl to map
    Length -- how much to flush.
    WriteToDevice -- FALSE we have to double buffer since we are setting up a
        read. if its TRUE, we don't have to do much because it doesn't matter
        whats in the buffer after it gets written.


Return Value:

    TRUE -- we succeeded in the mapping
    FALSE -- we couldn't do it.

--*/
{
    PUCHAR mapRegisterCurrentSa;
    PUCHAR driverCurrentSa;
    PUCHAR originalBufferCurrentSa = NULL;

    ULONG mapRegisterNumber;
    ULONG bytesLeftInMdl;

    //
    // Get a pointer into the Mdl that we can actually use
    // N.B. this may bugcheck if the mdl isn't mapped but that's a bug
    // in the first place.
    //
    driverCurrentSa = (PUCHAR)MmGetSystemAddressForMdl(Mdl) +
        ((PUCHAR) CurrentVa -
        (PUCHAR) MmGetMdlVirtualAddress(Mdl)) ;

    //
    // Find the map register number of the start of the flush
    // so that we can find out where to double buffer from
    //

    if (! ViFindMappedRegisterInFile(
        MapRegisterFile,
        driverCurrentSa,
        &mapRegisterNumber) ) {
        VF_ASSERT(
            0,
            HV_FLUSH_EMPTY_BUFFERS,
            ("Cannot flush buffers that aren't mapped (Addr %p)",
                driverCurrentSa )
        );
        return FALSE;
    }

    mapRegisterCurrentSa =
        MAP_REGISTER_SYSTEM_ADDRESS(
            MapRegisterFile,
            driverCurrentSa,
            mapRegisterNumber );


    //
    // Check to make sure that the flush is being done with a reasonable
    // length.(mdl byte count - mdl offset)
    //
    bytesLeftInMdl = MmGetMdlByteCount(MapRegisterFile->MapRegisterMdl) -
        (ULONG) ( (PUCHAR) mapRegisterCurrentSa -
        (PUCHAR) MmGetSystemAddressForMdl(MapRegisterFile->MapRegisterMdl) ) ;

    VF_ASSERT(
        Length <= bytesLeftInMdl,

        HV_MISCELLANEOUS_ERROR,

        ("FLUSH: Can only flush %x bytes to end of map register file (%x attempted)",
            bytesLeftInMdl, Length)
        );

    if (Length > bytesLeftInMdl) {
        //
        // Salvage the situation by truncating the flush
        //
        Length = bytesLeftInMdl;
    }



    //
    // Note on a write, we don't have to double buffer at this end
    //
    if (!WriteToDevice) {
        //
        // Since certain scsi miniports write to the mapped buffer and expect
        // that data to be there when we flush, we have to check for this
        // case ... and if it happens DON'T double buffer.
        //

        //
        // The correct way to do this is a merge between the
        // original buffer, our buffer and the driver's current buffer.
        // The most complex scenario is where the scsi miniport writes
        // the start and the end of the buffer and program the hardware
        // to transfer to region in between. This is why we need a copy
        // of the original buffer and the buffer that's been handed to the
        // hardware and copy back only what's changed between the two...
        //
        ASSERT(MapRegisterFile->OriginalBuffer);

        if (MapRegisterFile->OriginalBuffer) {

           originalBufferCurrentSa =
              ORIGINAL_BUFFER_SYSTEM_ADDRESS(
                 MapRegisterFile,
                 driverCurrentSa,
                 mapRegisterNumber);

            //
            // Perform the merge
            //
            ViCopyBackModifiedBuffer(
                 driverCurrentSa,
                 mapRegisterCurrentSa,
                 originalBufferCurrentSa,
                 Length);


        }


    } // if (!WriteToDevice) //

    //
    // Free map registers to our map register file
    //
    if (! ViFreeMapRegistersToFile(
        MapRegisterFile,
        driverCurrentSa,
        Length) ) {

        DbgPrint("Flushing too many map registers\n");
    }


    return TRUE;
} // ViFlushDoubleBuffer //




LOGICAL
ViAllocateMapRegistersFromFile(
    IN PMAP_REGISTER_FILE MapRegisterFile,
    IN PVOID CurrentSa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice,
    OUT PULONG MapRegisterNumber
    )
/*++

Routine Description:

    We specify that certain map registers are in use and decide how long the
    transfer should be based on the available map registers. For packet dma,
    we are only going to map one page maximum. For scatter gather, on the
    other hand, we have to map the whole thing.

Arguments:

    MapRegisterFile -- the structure containing the map registers to allocate
    CurrentSa -- page aligned address of the buffer to map
    Length -- how many bytes the transfer is going to be. We only use
        this to turn it into a number of pages.
    WriteToDevice - the direction of the transfer
    MapRegisterNumber -- returns the index into the map register file of the
        start of the allocation.
Return Value:


    TRUE -- succeeded
    FALSE -- not.
--*/

{
    KIRQL OldIrql;

    ULONG mapRegistersNeeded;
    ULONG mapRegisterNumber;

    PMAP_REGISTER mapRegister;

    ULONG numberOfContiguousMapRegisters;

    mapRegistersNeeded   = ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentSa, Length);

    //
    // find n available contiguous map registers
    //
    mapRegister       = &MapRegisterFile->MapRegisters[0];
    mapRegisterNumber = 0;
    numberOfContiguousMapRegisters = 0;

    //
    // Must lock the list so that other processors don't access it while
    // we're trying to.
    //
    KeAcquireSpinLock(&MapRegisterFile->AllocationLock, &OldIrql);

    //
    // Make sure that this address isn't already mapped
    //
    if (MapRegisterFile->NumberOfRegistersMapped) {
        PUCHAR windowStart = CurrentSa;
        PUCHAR windowEnd   = windowStart + Length;
        PMAP_REGISTER currentReg;
        PMAP_REGISTER lastReg;

        currentReg = &MapRegisterFile->MapRegisters[0];
        lastReg    = currentReg + MapRegisterFile->NumberOfMapRegisters;

        while(currentReg < lastReg) {

            if (currentReg->MappedToSa &&
                (PUCHAR) currentReg->MappedToSa >= windowStart &&
                (PUCHAR) currentReg->MappedToSa <  windowEnd ) {

                //
                // This is bad. We're trying to map an address
                // that is already mapped
                //

                VF_ASSERT(
                    FALSE,
                    HV_DOUBLE_MAP_REGISTER,
                    ("Driver is trying to map an address range(%p-%p) that is already mapped"
                    "    at %p",
                    windowStart,
                    windowEnd,
                    currentReg->MappedToSa
                    ));
            }

            currentReg++;

        } // for each map register //

    } // Check to see if address is already mapped //
    //
    // Find contiguous free map registers
    //
    while(numberOfContiguousMapRegisters < mapRegistersNeeded) {
        if (mapRegisterNumber == MapRegisterFile->NumberOfMapRegisters) {

            //
            // We've gotten to the end without finding enough map registers.
            // thats bad. However I can picture getting false positives here
            // if the map register file is large and gets fragmented.
            // This is a pretty pathological case and I doubt it would ever
            // happen.
            //
            VF_ASSERT(
                FALSE,

                HV_MISCELLANEOUS_ERROR,

                ("Map registers needed: %x available: %x",
                mapRegistersNeeded,
                numberOfContiguousMapRegisters)
                );
            KeReleaseSpinLock(&MapRegisterFile->AllocationLock, OldIrql);
            return FALSE;
        }

        if (mapRegister->MappedToSa) {
        //
        // This one's being used...must reset our contiguous count...
        //
            numberOfContiguousMapRegisters=0;
        }
        else {
        //
        // A free map register
        //

            numberOfContiguousMapRegisters++;
        }

        mapRegister++;
        mapRegisterNumber++;
    } // Find n contiguous map registers //

    //
    // got 'em ... we're now at the end of our area to be allocated
    // go back to the beginning.
    //
    mapRegister       -= mapRegistersNeeded;
    mapRegisterNumber -= mapRegistersNeeded;

    //
    // Save the map register index number to return
    //
    *MapRegisterNumber = mapRegisterNumber;
    //
    // Go through and mark the map registers as used...
    //
    while(mapRegistersNeeded--) {

        mapRegister->MappedToSa = CurrentSa;
        mapRegister->BytesMapped = MIN( PAGE_SIZE - BYTE_OFFSET(CurrentSa), Length );
        mapRegister->Flags = WriteToDevice ? MAP_REGISTER_WRITE : MAP_REGISTER_READ;

        InterlockedIncrement((PLONG)(&MapRegisterFile->NumberOfRegistersMapped));

        //
        // Write some known quantities into the buffer so that we know
        // if the device overwrites
        //
        ViTagBuffer(
            (PUCHAR) mapRegister->MapRegisterStart + PAGE_SIZE + BYTE_OFFSET(CurrentSa),
            mapRegister->BytesMapped,
            TAG_BUFFER_START | TAG_BUFFER_END
            );

        CurrentSa = PAGE_ALIGN( (PUCHAR) CurrentSa + PAGE_SIZE);
        Length -= mapRegister->BytesMapped;
        mapRegister++;
    }

    KeReleaseSpinLock(&MapRegisterFile->AllocationLock, OldIrql);


    return TRUE;

} // ViAllocateMapRegistersFromFile //


PMAP_REGISTER
ViFindMappedRegisterInFile(
    IN PMAP_REGISTER_FILE MapRegisterFile,
    IN PVOID CurrentSa,
    OUT PULONG MapRegisterNumber OPTIONAL
    )
/*++

Routine Description:

    From a system address, find out which map register in a map register file
    is mapped to that address.


Arguments:

    MapRegisterFile -- the structure containing the map registers.
    CurrentSa -- system address of where we are looking for the mapped map
        register.
    MapRegisterNumber -- gets the offset into the map register file.


Return Value:

    Returns a pointer to the map register if we found it or NULL if we didn't

--*/

{
    ULONG tempMapRegisterNumber;
    PMAP_REGISTER mapRegister;

    tempMapRegisterNumber   = 0;
    mapRegister             = &MapRegisterFile->MapRegisters[0];

    while(tempMapRegisterNumber < MapRegisterFile->NumberOfMapRegisters) {

        if (CurrentSa == mapRegister->MappedToSa) {
            if (MapRegisterNumber) {
            //
            // return the optional map register index
            //
                *MapRegisterNumber = tempMapRegisterNumber;
            }

            return mapRegister;
        }
        mapRegister++;
        tempMapRegisterNumber++;
    }

    return NULL;
} // ViFindMappedRegisterInFile //


LOGICAL
ViFreeMapRegistersToFile(
    IN PMAP_REGISTER_FILE MapRegisterFile,
    IN PVOID CurrentSa,
    IN ULONG Length
    )
/*++

Routine Description:


    Set the map registers in our map register file back to not being mapped.

Arguments:

    MapRegisterFile -- the structure containing the map registers to
        allocate.
    CurrentSa -- system address of where to start the transfer.  We use this
        to help set the transfer length.
    Length -- how much to free -- this is non-negotiable.
    NOTE -- while we're freeing map registers, we don't have to use the spinlock.
        Why? Because we're just clearing flags. In the allocation case we need
        it so that someone doesn't take our map registers before we get a
        chance to claim them. But if someone frees out map registers before we
        get a chance to, it won't make a difference. (that would be a bug in
        the first place and we'd hit an assert).

Return Value:


    TRUE -- succeeded in unmapping at least some of the map registers.
    FALSE -- not.
--*/
{
    PMAP_REGISTER mapRegister;
    ULONG numberOfRegistersToUnmap;

    if (Length) {
       numberOfRegistersToUnmap = MIN (
           ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentSa, Length),
           MapRegisterFile->NumberOfRegistersMapped
           );
    } else {
       //
       // Zero length usually signals an error condition, it may
       // be possible that the hardware still transferred something, so
       // let's (arbitrarily) unmap one register
       // (otherwise we may find some partly transferred
       // data and assert that it was lost)
       //
       numberOfRegistersToUnmap = MIN(1, MapRegisterFile->NumberOfRegistersMapped);
    }

    //
    // Find the first map register
    //
    mapRegister = ViFindMappedRegisterInFile(
        MapRegisterFile,
        CurrentSa,
        NULL);

    if (! mapRegister ) {
        return FALSE;
    }

    //
    // Because a driver can just say "flush" and doesn't necessarily have to
    // have anything mapped -- and also wants to flush the whole thing at one
    // time, we are going to try unmap each map register and not get
    // bent out of shape if we can't do it.
    //
    // Remember all map register allocations have to be contiguous
    // (i.e a if a 2 page buffer gets mapped starting at map register 3
    // the second page will be mapped to map register 4)
    //
    //
    // NOTE -- the order of these does matter!!!
    //
    while(numberOfRegistersToUnmap && mapRegister->MappedToSa ) {

        //
        // Check the bits that we scribbled right before and after the map register
        // make sure nobody's scribbled over them.
        //
        // This also removes the tag and zeroes out the whole map register buffer.
        // Why ? Because next time this map register gets mapped, it may get mapped
        // at a different offset so the tag will have to go in a different place.
        // We've got to clear out the buffer.
        //
        // This way we can tell if someone is using this buffer after the flush
        //
        ViCheckTag(
            (PUCHAR) mapRegister->MapRegisterStart +
            PAGE_SIZE + BYTE_OFFSET(mapRegister->MappedToSa),
            mapRegister->BytesMapped,
            TRUE,
            TAG_BUFFER_START | TAG_BUFFER_END
            );

        //
        // Clear the RW flags
        //
        mapRegister->Flags &= ~MAP_REGISTER_RW_MASK;

        //
        //  (Dirty debug trick) : save the MappedToSa field so we
        // can tell who has flushed it before, if needed.
        //
        mapRegister->Flags = PtrToUlong(mapRegister->MappedToSa);

        //
        // Unmap the register
        //
        mapRegister->MappedToSa = NULL;
        mapRegister->BytesMapped = 0;
        //
        // Clear the RW flags
        //
        InterlockedDecrement((PLONG)(&MapRegisterFile->NumberOfRegistersMapped));

        //
        // Go on to the next map register
        //
        mapRegister++;
        numberOfRegistersToUnmap--;
    }

    return TRUE;
} // ViFreeMapRegistersToFile //


THUNKED_API
VOID
VfHalDeleteDevice(
    IN PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:


    Hooks the IoDeleteDevice routine -- we want to make sure that all
    adapters are put away before calling this routine -- otherwise we
    issue a big fat bugcheck to teach naughty drivers a lesson.

    We have a list of all of the devices that we've hooked, and so here we
    just make sure that we can't find this device object on the hooked list.

    We are not calling IoDeleteDevice, since we're being called
    from an I/O Verifier path and I/O Verifier will call IoDeleteDevice
    subsequently.

Arguments:

    DeviceObject -- Device object that is being deleted.

Return Value:

    NTSTATUS code.
--*/

{
    PADAPTER_INFORMATION adapterInformation;
    PDEVICE_OBJECT pdo;

    pdo = VfGetPDO(DeviceObject);

    ASSERT(pdo);

    if (pdo == DeviceObject) {
       //
       // The PDO goes away, do the clean up.
       // Find adapter info for this device.
       //
       adapterInformation = VF_FIND_DEVICE_INFORMATION(DeviceObject);

       ///
       // A device may have more than one adapter. Release each of them.
       ///
       while (adapterInformation) {

           ViReleaseDmaAdapter(adapterInformation);
           adapterInformation = VF_FIND_DEVICE_INFORMATION(DeviceObject);
       }
    } else {
       //
       // A device in the stack is removed. Since we cannot be sure that the
       // device object that is verified is DeviceObject (it may be a filter on
       // top of it), we need to just mark the adapter for removal
       //
       VF_MARK_FOR_DEFERRED_REMOVE(pdo);
    }

    return;

} // VfHalDeletedevice //


LOGICAL
VfInjectDmaFailure (
    VOID
    )

/*++

Routine Description:

    This function determines whether a dma operation should be
    deliberately failed.

Arguments:

    None.

Return Value:

    TRUE if the operation should be failed.  FALSE otherwise.

Environment:

    Kernel mode.  DISPATCH_LEVEL or below.

--*/

{
    LARGE_INTEGER currentTime;

    if ( ViInjectDmaFailures == FALSE) {
        return FALSE;
    }


   //
   // Don't fail during the beginning of boot.
    //
   if (ViSufficientlyBootedForDmaFailure == FALSE) {
        KeQuerySystemTime (&currentTime);

        if ( currentTime.QuadPart > KeBootTime.QuadPart +
            ViRequiredTimeSinceBoot.QuadPart ) {
            ViSufficientlyBootedForDmaFailure = TRUE;
        }
    }

    if (ViSufficientlyBootedForDmaFailure == TRUE) {

        KeQueryTickCount(&currentTime);

        if ((currentTime.LowPart & 0x1F) == 0) {

            ViAllocationsFailedDeliberately += 1;

            //
            // Deliberately fail this request.
            //

            return TRUE;
        }
    }

    return FALSE;
} // VfInjectDmaFailure //


VOID
VfScatterGatherCallback(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    )
/*++

Routine Description:

    This function is the hooked callback for GetScatterGatherList.

Arguments:

    DeviceObject -- passed through (not used).
    Irp -- passed through (not used).
    ScatterGather -- scatter gather list built by system.
    Context -- This is really our wait block.

Return Value:

    NONE.

Environment:

    Kernel mode.  DISPATCH_LEVEL.

--*/
{
    PVF_WAIT_CONTEXT_BLOCK waitBlock = (PVF_WAIT_CONTEXT_BLOCK) Context;
    PADAPTER_INFORMATION adapterInformation = waitBlock->AdapterInformation;


    ADD_MAP_REGISTERS(adapterInformation, ScatterGather->NumberOfElements, TRUE);


    //
    // Save the scatter gather list so we can look it up when we put it away
    //
    waitBlock->ScatterGatherList = ScatterGather;

    VF_ADD_TO_LOCKED_LIST(&adapterInformation->ScatterGatherLists, waitBlock);

    ((PDRIVER_LIST_CONTROL) waitBlock->RealCallback)(DeviceObject,Irp, ScatterGather, waitBlock->RealContext);

} // VfScatterGatherCallback //

LOGICAL
ViSwap(IN OUT PVOID * MapRegisterBase,
        IN OUT PMDL  * Mdl,
        IN OUT PVOID * CurrentVa
        )
/*++

Routine Description:

    Swaps things that we hook in doing dma -- I.e. we replace the
    map register base with our map register file, we replace the mdl with
    our own, and the current va with the virtual address that indexes our
    mdl.

Arguments:

    MapRegisterBase:
        IN  -- our map register file
        OUT -- the map register base returned by the HAL.
    Mdl:
        IN  -- the mdl the driver is using for dma
        OUT -- the mdl that we are using for double buffered dma.
    CurrentVa:
        IN  -- the address indexing the mdl that the driver is doing dma to/from
        OUT -- the address indexing our mdl for double buffered dma.

Return Value:

    TRUE -- we could find all of the stuff we wanted.
    FALSE -- not.


--*/
{
    PMAP_REGISTER_FILE mapRegisterFile  = (PMAP_REGISTER_FILE) *MapRegisterBase;
    ULONG mapRegisterNumber;
    PUCHAR currentSa;
    PUCHAR driverCurrentSa;

    driverCurrentSa = (PUCHAR) MmGetSystemAddressForMdl(*Mdl) +
        ((PUCHAR) *CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(*Mdl));

    //
    // Make sure that the VA is actually in the mdl they gave us
    //
    if (MmGetMdlByteCount(*Mdl)) {

       VF_ASSERT(
           MmGetMdlByteCount(*Mdl) > (ULONG_PTR) ((PUCHAR) *CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(*Mdl)),
           HV_ADDRESS_NOT_IN_MDL,
           ("Virtual address %p out of bounds of MDL %p", *CurrentVa, *Mdl)
           );
    }
    if (!ViFindMappedRegisterInFile(mapRegisterFile, driverCurrentSa, &mapRegisterNumber)) {

        return FALSE;
    }


    currentSa = MAP_REGISTER_SYSTEM_ADDRESS(mapRegisterFile, driverCurrentSa, mapRegisterNumber);

    *Mdl = mapRegisterFile->MapRegisterMdl;

    *CurrentVa = MAP_REGISTER_VIRTUAL_ADDRESS(mapRegisterFile, driverCurrentSa, mapRegisterNumber);

    *MapRegisterBase = mapRegisterFile->MapRegisterBaseFromHal;

    return TRUE;
} // ViSwap //

VOID
ViCheckAdapterBuffers(
    IN PADAPTER_INFORMATION AdapterInformation
    )
/*++

Routine Description:

    Since common buffer dma isn't transactional, we have to have a way of
    checking to make sure that the common buffer's guard pages don't get
    scribbled on. This function will each common buffer owned by the adapter

Arguments:



Return Value:

    NONE.

--*/
{
    KIRQL oldIrql;
    PHAL_VERIFIER_BUFFER verifierBuffer;
    const SIZE_T tagSize = sizeof(ViDmaVerifierTag);
    USHORT  whereToCheck = 0;

    //
    // This is expensive so if either:
    // we're not adding padding to common buffers,
    // we're not checking the padding except when stuff is being destroyed,
    // or this adapter doesn't have any common buffers, quit right here.
    //
    if (! ViProtectBuffers ||
        VF_IS_LOCKED_LIST_EMPTY(&AdapterInformation->CommonBuffers) ) {

        return;
    }

    VF_LOCK_LIST(&AdapterInformation->CommonBuffers, oldIrql);

    //
    // Make sure each darn common buffer's paddin' looks good
    //
    FOR_ALL_IN_LIST(
        HAL_VERIFIER_BUFFER,
        &AdapterInformation->CommonBuffers.ListEntry,
        verifierBuffer ) {

        SIZE_T startPadSize = (PUCHAR)verifierBuffer->AdvertisedStartAddress - (PUCHAR)verifierBuffer->RealStartAddress;

        if (startPadSize>= tagSize) {
           whereToCheck |= TAG_BUFFER_START;
        }

        if (startPadSize + verifierBuffer->AdvertisedLength + tagSize <= verifierBuffer->RealLength) {
           whereToCheck |= TAG_BUFFER_END;
        }

        ViCheckTag(
            verifierBuffer->AdvertisedStartAddress,
            verifierBuffer->AdvertisedLength,
            FALSE, // DO NOT REMOVE TAG //
            whereToCheck
            );

    } // FOR each buffer in list //

    VF_UNLOCK_LIST(&AdapterInformation->CommonBuffers, oldIrql);

} // ViCheckAdapterBuffers //


VOID
ViTagBuffer(
    IN PVOID  AdvertisedBuffer,
    IN ULONG  AdvertisedLength,
    IN USHORT WhereToTag
    )
/*++

Routine Description:

    Write a known string to the area right before of a buffer
    and right after one -- so if there is an overrun, we'll
    catch it.

    Also write a known pattern to initialize the innards of the buffer.

Arguments:

    AdvertisedBuffer -- The beginning of the buffer that the driver can see.
    AdvertisedLength -- How long the driver thinks that the buffer is.
    WhereToTag       -- Indicates whether to tag the beginning of the buffer,
                        the end or both.

Return Value:

    NONE.

--*/
{
    const SIZE_T tagSize = sizeof(ViDmaVerifierTag);

    if (WhereToTag & TAG_BUFFER_START) {
       RtlCopyMemory( (PUCHAR) AdvertisedBuffer - tagSize ,         ViDmaVerifierTag, tagSize);
    }
    if (WhereToTag & TAG_BUFFER_END) {
       RtlCopyMemory( (PUCHAR) AdvertisedBuffer + AdvertisedLength, ViDmaVerifierTag, tagSize);
    }
    //
    // We're not using the fill character any more
    //
    // RtlFillMemory( AdvertisedBuffer, (SIZE_T) AdvertisedLength, MAP_REGISTER_FILL_CHAR);

} // ViTagBuffer //

VOID
ViCheckTag(
    IN PVOID AdvertisedBuffer,
    IN ULONG AdvertisedLength,
    IN BOOLEAN RemoveTag,
    IN USHORT  WhereToCheck
    )
/*++

Routine Description:

    Make sure our tag -- the bits we scribbled right before and right after
    an allocation -- is still there. And perhaps kill it if we've
    been so advised.

Arguments:

    AdvertisedBuffer -- The beginning of the buffer that the driver can see.
    AdvertisedLength -- how long the driver thinks that the buffer is.
    RemoveTag -- do we want to clear the tag & the buffer? Why would we
        want to do this? for map registers, who may get mapped to a
        different place, we need to keep the environment pristine.

Return Value:

    NONE.

--*/
{
    const SIZE_T tagSize = sizeof(ViDmaVerifierTag);
    PVOID endOfBuffer = (PUCHAR) AdvertisedBuffer + AdvertisedLength;

    PUCHAR startOfRemoval  = (PUCHAR)AdvertisedBuffer;
    SIZE_T lengthOfRemoval = AdvertisedLength;

    if (WhereToCheck & TAG_BUFFER_START) {
      VF_ASSERT(
          RtlCompareMemory((PUCHAR) AdvertisedBuffer - tagSize , ViDmaVerifierTag, tagSize) == tagSize,

          HV_BOUNDARY_OVERRUN,

          ( "Area before %x byte allocation at %p has been modified",
              AdvertisedLength,
              AdvertisedBuffer )
          );
      startOfRemoval  -= tagSize;
      lengthOfRemoval += tagSize;
    }
    if (WhereToCheck & TAG_BUFFER_END) {
      VF_ASSERT(
          RtlCompareMemory(endOfBuffer, ViDmaVerifierTag, tagSize) == tagSize,

          HV_BOUNDARY_OVERRUN,

          ( "Area after %x byte allocation at %p has been modified",
              AdvertisedLength,
              AdvertisedBuffer
              ));
      lengthOfRemoval += tagSize;
    }
    if (RemoveTag) {
    //
    // If we're getting rid of the tags, get rid of the data in the buffer too.
    //
        RtlFillMemory(
            startOfRemoval,
            lengthOfRemoval,
            PADDING_FILL_CHAR
            );
    }
} // ViCheckTag //


VOID
ViInitializePadding(
    IN PVOID RealBufferStart,
    IN ULONG RealBufferLength,
    IN PVOID AdvertisedBufferStart, OPTIONAL
    IN ULONG AdvertisedBufferLength OPTIONAL
    )
/*++

Routine Description:

    Set up padding with whatever we want to put into it.

    N.B. The padding should be PADDING_FILL_CHAR except for the tags.

Arguments:

    RealBufferStart  -- the beginning of the padding.
    RealBufferLength -- total length of allocation.

    AdvertisedBufferStart -- The beginning of the buffer that the driver can see.
    AdvertisedBufferLength -- how long the driver thinks that the buffer is.
        If AdvertisedBuffer/AdvertisedLength aren't present (they must
        both be yea or nay) we won't tag the buffer. We need this option
        because when we allocate map registers we don't know
        where the tags need to go.

Return Value:

    NONE.

--*/

{
    PUCHAR postPadStart;
    USHORT whereToTag = 0;
    const SIZE_T tagSize = sizeof(ViDmaVerifierTag);

    if (!AdvertisedBufferLength) {

        RtlFillMemory(RealBufferStart, RealBufferLength, PADDING_FILL_CHAR);
        return;
    }

    //
    // Fill out the pre-padding
    //
    RtlFillMemory(
        RealBufferStart,
        (PUCHAR) AdvertisedBufferStart - (PUCHAR) RealBufferStart,
        PADDING_FILL_CHAR
        );

    //
    // Fill out the post padding
    //
    postPadStart = (PUCHAR) AdvertisedBufferStart + AdvertisedBufferLength;

    RtlFillMemory(
        postPadStart,
        RealBufferLength - (postPadStart - (PUCHAR) RealBufferStart),
        PADDING_FILL_CHAR
        );

    if ((PUCHAR)RealBufferStart + tagSize <= (PUCHAR)AdvertisedBufferStart) {
       whereToTag |= TAG_BUFFER_START;
    }
    if ((postPadStart - (PUCHAR) RealBufferStart) + tagSize <= RealBufferLength) {
       whereToTag |= TAG_BUFFER_END;
    }
    //
    // And write our little tag ...
    //
    ViTagBuffer(AdvertisedBufferStart, AdvertisedBufferLength, whereToTag);

} // ViInitializePadding //

VOID
ViCheckPadding(
    IN PVOID RealBufferStart,
    IN ULONG RealBufferLength,
    IN PVOID AdvertisedBufferStart, OPTIONAL
    IN ULONG AdvertisedBufferLength OPTIONAL
    )
/*++

Routine Description:

    Make sure that the guard pages etc haven't been touched -- more exhaustive than
    just checking the tag -- checks each byte.

    N.B. The padding should be Zeros except for the tags.

Arguments:

    RealBufferStart  -- the beginning of the padding.
    RealBufferLength -- total length of allocation.

    AdvertisedBufferStart -- The beginning of the buffer that the driver can see.
    AdvertisedLength -- how long the driver thinks that the buffer is.
        If AdvertisedBuffer/AdvertisedLength aren't present (they must
        both be yea or nay) we won't check for a valid tag.

Return Value:

    NONE.

--*/
{
    const ULONG tagSize = sizeof(ViDmaVerifierTag);
    PULONG_PTR corruptedAddress;

    if (AdvertisedBufferLength == RealBufferLength) {
        //
        // No padding to check.
        //

        return;
    }

    if (! AdvertisedBufferLength) {
        //
        // There is no intervening buffer to worry about --
        // so the *whole* thing has to be the padding fill char
        //

        corruptedAddress = ViHasBufferBeenTouched(
            RealBufferStart,
            RealBufferLength,
            PADDING_FILL_CHAR
            );

        VF_ASSERT(
            NULL == corruptedAddress,

            HV_BOUNDARY_OVERRUN,

            ( "Verified driver or hardware has corrupted memory at %p",
               corruptedAddress )
            );


    } // ! AdvertisedBufferLength //

    else {
        PUCHAR prePadStart;
        PUCHAR postPadStart;
        ULONG_PTR prePadBytes;
        ULONG_PTR postPadBytes;
        USHORT    whereToCheck = 0;

        prePadStart  = (PUCHAR) RealBufferStart;
        prePadBytes  = (PUCHAR) AdvertisedBufferStart - prePadStart;

        postPadStart = (PUCHAR) AdvertisedBufferStart + AdvertisedBufferLength;
        postPadBytes = RealBufferLength - (postPadStart - (PUCHAR) RealBufferStart);

        //
        // Now factor in the tag... it's the only thing in the padding that is allowed to be
        // non-zero.
        //
        if (prePadBytes >= tagSize) {
           prePadBytes  -= tagSize;
           whereToCheck |= TAG_BUFFER_START;
        }
        if (postPadBytes >= tagSize) {
           postPadBytes -= tagSize;
           postPadStart += tagSize;
           whereToCheck |= TAG_BUFFER_END;


        }
        //
        // Make sure the tag is in place.
        //
        ViCheckTag(AdvertisedBufferStart, AdvertisedBufferLength , FALSE, whereToCheck);


        corruptedAddress = ViHasBufferBeenTouched(
            prePadStart,
            prePadBytes,
            PADDING_FILL_CHAR
            );

        VF_ASSERT(
            NULL == corruptedAddress,

            HV_BOUNDARY_OVERRUN,

            ( "Padding before allocation at %p has been illegally modified at %p",
                AdvertisedBufferStart,
                corruptedAddress
                )
            );

         corruptedAddress = ViHasBufferBeenTouched(
            postPadStart,
            postPadBytes,
            PADDING_FILL_CHAR
            );

        VF_ASSERT(
            NULL == corruptedAddress,

            HV_BOUNDARY_OVERRUN,

            ( "Padding after allocation at %p has been illegally modified at %p",
                AdvertisedBufferStart,
                corruptedAddress
                )
            );
    } // if AdvertisedLength //

} // ViCheckPadding //

PULONG_PTR
ViHasBufferBeenTouched(
    IN PVOID Address,
    IN ULONG_PTR Length,
    IN UCHAR ExpectedFillChar
    )
/*++

Routine Description:

    Check if a buffer contains a repetition of a certain character.

Arguments:

    Address -- address of buffer to check.
    Length -- length of buffer.
    ExpectedFillChar -- the character that should be repeated.

Return Value:

    The address at which it has been touched.
    or NULL if it hasn't been touched

--*/
{
    PULONG_PTR currentChunk;
    PUCHAR     currentByte;
    ULONG_PTR expectedFillChunk;

    ULONG counter;

    expectedFillChunk = (ULONG_PTR) ExpectedFillChar;
    counter = 1;

    //
    // How is this for non-obvious code!
    // What it does is fills in a ULONG_PTR with
    // the character
    //
    while( counter < sizeof(ULONG_PTR) ) {
        expectedFillChunk |= expectedFillChunk << (counter << 3);
        counter <<=1;
    }

    //
    // Get aligned natively
    //
    currentByte =  Address;
    while((ULONG_PTR) currentByte % sizeof(ULONG_PTR) && Length) {

        if(*currentByte != ExpectedFillChar) {

            return (PULONG_PTR) currentByte;
        }

        currentByte++;
        Length--;
    }

    currentChunk = (PULONG_PTR) currentByte;

    //
    // Check 4 (or 8 depending on architecture) bytes at a time
    //
    while(Length >= sizeof(ULONG_PTR)) {

        if (*currentChunk != expectedFillChunk) {

            return currentChunk;
        }

        currentChunk++;
        Length-=sizeof(ULONG_PTR);
    }

    currentByte = (PUCHAR) currentChunk;

    //
    // Check the remaining few bytes
    //
    while(Length) {

        if(*currentByte != ExpectedFillChar) {
            return (PULONG_PTR) currentByte;
        }

        currentByte++;
        Length--;
    }

    return NULL;

} // ViHasMapRegisterBeenTouched //



VOID
VfAssert(
    IN LOGICAL     Condition,
    IN ULONG Code,
    IN OUT PULONG  Enable
    )
/*++

Routine Description:

    Verifier Assert.

Arguments:

    Condition -- is this true?
    Code -- code to pass to KeBugcheck if need be.
    Enable -- lets us Zap the assert

Return Value:

    None

--*/

{
    ULONG enableCode = *Enable;
    if (Condition) {
        return;
    }

    if (enableCode & HVC_ONCE) {
        //
        // HVC_ONCE does a self-zap
        //

        *Enable = HVC_IGNORE;
    }

    if (enableCode & HVC_WARN) {
    //
    // Already warned
    //

        return;
    }

    if(enableCode  & HVC_BUGCHECK || ! KdDebuggerEnabled ) {
        KeBugCheckEx (
            HAL_VERIFIER_DETECTED_VIOLATION,
            Code,
            0,
            0,
            0
            );
        return;
    }

    if (enableCode & HVC_ASSERT) {
        char response[2];

        while (TRUE) {
            DbgPrint( "\n*** Verifier assertion failed ***\n");

            DbgPrompt( "(B)reak, (I)gnore, (W)arn only, (R)emove assert? ",
                response,
                sizeof( response )
                );
            switch (response[0]) {
            case 'B':
            case 'b':
                DbgBreakPoint();
                break;

            case 'I':
            case 'i':
                return;

            case 'W':
            case 'w':
                //
                // Next time we hit this, we aren't going to assert, just
                // print out a warning
                //
                *Enable = HVC_WARN;
                return;
            case 'R':
            case 'r':
                //
                // Next time we hit this we are going to ignore it
                //
                *Enable = HVC_IGNORE;
                return;
            } // end of switch //
        }  // while true //
    } // if we want to assert //
} // VfAssert //



PVOID
VfAllocateCrashDumpRegisters(
    IN PADAPTER_OBJECT AdapterObject,
    IN PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    Hook HalAllocateCrashDumpRegisters so that we can bump up the number
    of map registers the device is allowed to have.

Arguments:

    Same as HalAllocateCrashDumpRegisters

Return Value:

    PVOID -- pointer to the map registers

--*/
{
    PVOID mapRegisterBase;
    PADAPTER_INFORMATION adapterInformation;

    //
    // Note -- turn off dma verification when we're doing a crash dump (but leave it
    // on for a hibernate). Crash dumps are done at IRQL == HIGH_LEVEL, and we'd
    // crash the machine a second time if we tried to use spin locks, allocate
    // memory, and all of the other stuff that we do.
    //

    if (KeGetCurrentIrql() > DISPATCH_LEVEL &&
        ViVerifyDma) {
        ViVerifyDma = FALSE;
        //
        // Reset the DMA operations table to the real one for all adapters
        // we have. Otherwise, because ViVerifyDma is not set, we'll believe
        // he have never hooked the operations and we'll recursively call
        // the verifier routines. Do not worry about synchronization now.
        //

        FOR_ALL_IN_LIST(ADAPTER_INFORMATION, &ViAdapterList.ListEntry, adapterInformation)
        {
            if (adapterInformation->DmaAdapter) {
               adapterInformation->DmaAdapter->DmaOperations = adapterInformation->RealDmaOperations;
            }
        }

    }

    adapterInformation = ViGetAdapterInformation((DMA_ADAPTER *)AdapterObject);

    mapRegisterBase = HalAllocateCrashDumpRegisters(
        AdapterObject,
        NumberOfMapRegisters
        );

    if (adapterInformation) {
        //
        // Note we only get here if this is a hibernate, not a crash dump
        //

        VF_ASSERT_IRQL(DISPATCH_LEVEL);
        //
        // Do not double buffer crash dump registers. They are special.
        //

        //
        // Add these map registers -- but also add to the maximum number that can
        // be mapped
        //
        InterlockedExchangeAdd((PLONG)(&adapterInformation->MaximumMapRegisters), *NumberOfMapRegisters);
        ADD_MAP_REGISTERS(adapterInformation, *NumberOfMapRegisters, FALSE);
    } // if (adapterInformation)

    //
    // Some drivers (hiber_scsiport for one) don't call FlushAdapterBuffers
    // unless the MapRegisterBase is non-NULL. This breaks our
    // calculations in the hibernation path.
    // So, in order to fool the drivers into thinking that they need
    // to flush, we exchange the NULL MapRegisterBase (if in fact
    // the hal uses a null map register base) for our
    // MRF_NULL_PLACEHOLDER and take care to replace back with NULL
    // in our wrappers before passing it to the HAL.
    // Also, make sure not to mess with the crash dump case.
    //

    if (ViVerifyDma &&
        NULL == mapRegisterBase) {
        mapRegisterBase = MRF_NULL_PLACEHOLDER;
    }
    return mapRegisterBase;
} // VfAllocateCrashDumpRegisters //




VOID
ViCommonBufferCalculatePadding(
                              IN  ULONG  Length,
                              OUT PULONG PrePadding,
                              OUT PULONG PostPadding
                              )
/*++

Routine Description:

    Calculates how many bytes to reserve for padding before and
    after a common buffer. The reason to make this a function is
    to be able to have more granular per-buffer padding policies.
    The prePadding will be page aligned.

Arguments:

    Length -- the allocation real length
    PrePadding -- how many bytes to reserve for padding before the start
                  of the common buffer
    PostPadding -- how many bytes to reserve for padding before the
                   end of the common buffer


Return Value:

    None.

--*/
{

    if (!ViProtectBuffers) {
       //
       // Don't add any padding if we're not padding buffers
       //
       *PrePadding = *PostPadding = 0;
       return;
    }
    //
    // Use one full guard page, so the buffer returned to the caller
    // will be page-aligned
    //
    *PrePadding = PAGE_SIZE;

    if (Length + sizeof(ViDmaVerifierTag) <= PAGE_SIZE) {
       //
       // For small buffers, just allocate a page
       //
       *PostPadding = PAGE_SIZE - Length;
    }
    else if ( BYTE_OFFSET(Length)) {
      //
      // For longer buffers that aren't an even number of pages,
      // just round up the number of pages necessary
      // (we need space at least for our tag)
      //
      *PostPadding =  (BYTES_TO_PAGES( Length + sizeof(ViDmaVerifierTag) )
                       << PAGE_SHIFT ) - Length;
    }
    else { // PAGE ALIGNED LENGTH //

      //
      // Since if the length is an even number of pages the driver might expect
      // a page aligned buffer, we allocate the page before and after the allocation
      //
      *PostPadding  = PAGE_SIZE;

    }
    return;
} //ViCommonBufferCalculatePadding


VOID
ViAllocateContiguousMemory (
    IN OUT PADAPTER_INFORMATION AdapterInformation
    )

/*++

Routine Description:

    Attempts to allocate 3 * MAX_CONTIGUOUS_MAP_REGISTERS contiguous
    physical pages to form a pool from where we can give 3-page buffers for
    double buffering map registers. Note that if we fail, or if we use more
    than MAX_CONTIGUOUS_MAP_REGISTERS at a time, we'll just default to
    non-contiguous non paged pool, so we can still test a number of assertions
    that come with double buffering.

Arguments:

    AdapterInformation - information about our adapter.

Return Value:

    None.

--*/

{
   PHYSICAL_ADDRESS highestAddress;
   ULONG            i;

   PAGED_CODE();

   //
   // Default to a less than 1 MB visible
   //
   highestAddress.HighPart = 0;
   highestAddress.LowPart =  0x000FFFF;
   //
   // Determine the highest acceptable physical address to be used
   // in calls to MmAllocateContiguousMemory
   //
   if (AdapterInformation->DeviceDescription.Dma64BitAddresses) {
      //
      // Can use any address in the 64 bit address space
      //
      highestAddress.QuadPart = (ULONGLONG)-1;
   }  else if (AdapterInformation->DeviceDescription.Dma32BitAddresses) {
      //
      // Can use any address in the 32 bit (<4GB) address space
      //
      highestAddress.LowPart = 0xFFFFFFFF;
   }  else if (AdapterInformation->DeviceDescription.InterfaceType == Isa) {
      //
      // Can see 16MB (24-bit addresses)
      //
      highestAddress.LowPart = 0x00FFFFFF;
   }
   //
   // Initialize the allocator bitmap
   //
   RtlInitializeBitMap(&AdapterInformation->AllocationMap,
                       (PULONG)&AdapterInformation->AllocationStorage,
                       MAX_CONTIGUOUS_MAP_REGISTERS);
   //
   // Initially no blocks are allocated
   //
   RtlClearAllBits(&AdapterInformation->AllocationMap);


   AdapterInformation->ContiguousBuffers = ExAllocatePoolWithTag(NonPagedPool,
       MAX_CONTIGUOUS_MAP_REGISTERS * sizeof(PVOID),
       HAL_VERIFIER_POOL_TAG);

   if (AdapterInformation->ContiguousBuffers) {
       //
       // Allocate contiguous buffers
       //
       for (i = 0; i < MAX_CONTIGUOUS_MAP_REGISTERS; i++) {
          AdapterInformation->ContiguousBuffers[i] = MmAllocateContiguousMemory(3 * PAGE_SIZE,
             highestAddress);
          if (NULL == AdapterInformation->ContiguousBuffers[i]) {
             //
             // Mark as in use, so we don't hand it over
             //
             RtlSetBits(&AdapterInformation->AllocationMap, i, 1);
             InterlockedIncrement((PLONG)&AdapterInformation->FailedContiguousAllocations);
          } else {
             InterlockedIncrement((PLONG)&AdapterInformation->SuccessfulContiguousAllocations);
          }
       }
   }

   return;

} // ViAllocateContiguousMemory

PVOID
ViAllocateFromContiguousMemory (
    IN OUT PADAPTER_INFORMATION AdapterInformation,
    IN     ULONG                HintIndex
    )
/*++

Routine Description:

    Attempts to 'allocate' a 3 page buffer from our pre-allocated
    contiguous memory.

Arguments:

    AdapterInformation - adapter data
    HintIndex - gives a hint where to look for the next free block

Return Value:

    A virtual address from our contiguous memory pool or NULL if none
    is available.

--*/

{
    PVOID  address = NULL;
    ULONG  index;
    KIRQL  oldIrql;


    if (NULL == AdapterInformation ||
        NULL == AdapterInformation->ContiguousBuffers) {
        return NULL;
    }

    //
    // Find the first available location
    //
    KeAcquireSpinLock(&AdapterInformation->AllocationLock, &oldIrql);
    index = RtlFindClearBitsAndSet(&AdapterInformation->AllocationMap, 1, HintIndex);
    if (index != 0xFFFFFFFF) {
       address = AdapterInformation->ContiguousBuffers[index];
    }
    KeReleaseSpinLock(&AdapterInformation->AllocationLock, oldIrql);

    return address;
} // ViAllocateFromContiguousMemory

LOGICAL
ViFreeToContiguousMemory (
    IN OUT PADAPTER_INFORMATION AdapterInformation,
    IN     PVOID Address,
    IN     ULONG HintIndex
    )
/*++
Routine Description:

    Frees a 3-page contiguous buffer into our pool of contiguous buffers
    contiguous memory.

Arguments:

    AdapterInformation - adapter data.
    Address - the memory to be freed.
    HintIndex - gives a hint where to look for the address to free. Usually
                the address at this index is what we need to free. If not, we
                search the whole buffer.

Return Value:

    TRUE is the address is from the contiguous buffer pool, FALSE if not.

--*/
{
    ULONG  index = 0xFFFFFFFF;
    KIRQL  oldIrql;
    ULONG  i;



    if (NULL == AdapterInformation->ContiguousBuffers) {
       return FALSE;
    }

    ASSERT(BYTE_OFFSET(Address) == 0);


    if (HintIndex < MAX_CONTIGUOUS_MAP_REGISTERS &&
       AdapterInformation->ContiguousBuffers[HintIndex] == Address) {
       index = HintIndex;
    }  else  {
       for (i = 0; i < MAX_CONTIGUOUS_MAP_REGISTERS; i++) {
          if (AdapterInformation->ContiguousBuffers[i] == Address) {
             index = i;
             break;
          }
       }
    }
    if (index < MAX_CONTIGUOUS_MAP_REGISTERS) {
       KeAcquireSpinLock(&AdapterInformation->AllocationLock, &oldIrql);
       ASSERT(RtlAreBitsSet(&AdapterInformation->AllocationMap, index, 1));
       RtlClearBits(&AdapterInformation->AllocationMap, index, 1);
       KeReleaseSpinLock(&AdapterInformation->AllocationLock, oldIrql);

       return TRUE;

    } else {
      return FALSE;
    }
} // ViFreeToContiguousMemory


LOGICAL
VfIsPCIBus (
     IN PDEVICE_OBJECT  PhysicalDeviceObject
     )

/*++
Routine Description:

    Checks if a PDO is for a PCI bus, in which case we do not hook up
    the adapter (because we may do this when called for a PCI device on that
    bus and they may not want it).

Arguments:

    PhysicalDeviceObject  - the PDO to be checked

Return Value:

    TRUE is the PDO is for a PCI bus, FALSE if not.

--*/
{
   LOGICAL      result = FALSE;
   NTSTATUS     status;
   WCHAR        deviceDesc[40];
   ULONG        length = 0;

   if (NULL == PhysicalDeviceObject) {
      //
      // If the PDO is NULL, assume it is not
      // a PCI bus...
      //
      return FALSE;
   }

   status = IoGetDeviceProperty(PhysicalDeviceObject,
                                DevicePropertyDeviceDescription,
                                sizeof(WCHAR) * 40,
                                deviceDesc,
                                &length);
   if (status == STATUS_SUCCESS &&
       0 == _wcsicmp(deviceDesc, L"PCI bus")) {
      result = TRUE;
   }

   return result;
} // VfIsPCIBus


PDEVICE_OBJECT
VfGetPDO (
          IN PDEVICE_OBJECT  DeviceObject
     )

/*++
Routine Description:

    Gets the device object at the bottom of a device stack (PDO)

Arguments:

    DeviceObject  - device object in the device stack

Return Value:

    A pointer to a physical device object.
--*/
{
   PDEVICE_OBJECT   pdo;


   pdo = DeviceObject;
   while (pdo->DeviceObjectExtension &&
          pdo->DeviceObjectExtension->AttachedTo) {
      pdo = pdo->DeviceObjectExtension->AttachedTo;
   }

   return pdo;

} // VfGetPDO


VOID
VfDisableHalVerifier (
                      VOID
                     )

/*++
Routine Description:

    Disables HAL Verifier when we do a crash dump.

Arguments:

    None.

Return Value:

    None.
--*/
{

   PADAPTER_INFORMATION adapterInformation;


   if (ViVerifyDma) {

      ViVerifyDma = FALSE;
      //
      // Reset the DMA operations table to the real one for all adapters
      // we have. Otherwise, because ViVerifyDma is not set, we'll believe
      // he have never hooked the operations and we'll recursively call
      // the verifier routines. Do not worry about synchronization now.
      //

      FOR_ALL_IN_LIST(ADAPTER_INFORMATION, &ViAdapterList.ListEntry, adapterInformation)
      {
         if (adapterInformation->DmaAdapter) {
            adapterInformation->DmaAdapter->DmaOperations = adapterInformation->RealDmaOperations;
         }
      }
   }

   return;

} // VfDisableHalVerifier



VOID
ViCopyBackModifiedBuffer (
     OUT PUCHAR  Dest,
     IN  PUCHAR  Source,
     IN  PUCHAR  Original,
     IN  SIZE_T  Length
     )

/*++
Routine Description:

    Copies back in the destination only those bytes from the source buffer
    that are different than the ones in original. The scenario is where a SCSI
    miniport fills in the start and end of a buffer and programs the hardware
    to fill in the rest. In this case we have to copy back only the middle
    portion and we use the original buffer to tell us what this portion is.


Arguments:

    Dest - the destination buffer
    Source - the buffer from where we transfer modifies parts only
    Original - how the original buffer looked like
    Length - the length of the transfer


Return Value:

    None.
--*/
{
   SIZE_T   startOffset;
   PUCHAR   start;

   if (0 == Length) {
      return;
   }
   //
   // As mentioned above, the Source and Oroginal buffers can have
   // common parts at the beginning and end. The first step is to find
   // these common parts. Note that is more likely to have a common
   // header than a common end.
   //
   startOffset = RtlCompareMemory(Source, Original, Length);
   if (Length == startOffset) {
      //
      // Buffer unchanged, do not copy anything
      //
      return;
   }
   start = Source + startOffset;
   //
   // Start from the end and determine what is common part
   //
   Source   += Length - 1;
   Original += Length - 1;

   //
   // The following loop will break when we get at startOffset at least
   //
   while (*Source == *Original ) {
      Source   -= 1;
      Original -= 1;
   }
   //
   // Source points to the last byte to copy, increment it
   //
   Source += 1;

   if (ViSuperDebug) {
        DbgPrint("Flush: %x bytes, %p src, %p dest\n",
                  Source - start,
                  start,
                  Dest + startOffset);

   }

   RtlCopyMemory(Dest + startOffset,
                 start,
                 Source - start);


   return;

} // VfCopyBackModifiedBuffer



NTSTATUS
VfHalAllocateMapRegisters(
    IN PADAPTER_OBJECT DmaAdapter,
    IN ULONG NumberOfMapRegisters,
    IN ULONG BaseAddressCount,
    OUT PMAP_REGISTER_ENTRY MapRegisterArray
    )


/*++
Routine Description:

    Hooked-up version for HalpAllocateMapRegisters.
    It is a combination VfAllocateAdapterChannel and
    VfAdapterCallback


Arguments:

    DmaAdapter - the adapter this is operationg on.
    NumberOfMapRegisters - the number of map registers per allocation
    BaseAddressCount - how many map register sets to allocate (each of
                       length NumberOfMapRegisters)
    MapRegisterArray - receive the map registers


Return Value:

    NT Status code.

--*/
{

   PADAPTER_INFORMATION adapterInformation;
   NTSTATUS status;
   ULONG    index;
   PMAP_REGISTER_FILE  mapRegisterFile;
   //
   // See what the HAL gets us first
   //
   if (VfRealHalAllocateMapRegisters) {
      status = (VfRealHalAllocateMapRegisters)(DmaAdapter,
                                               NumberOfMapRegisters,
                                               BaseAddressCount,
                                               MapRegisterArray);
   } else {
      //
      // This should never happen (if we are hooked,
      // VfRealHalAllocateMapRegisters should be hooked
      // as well)
      //
      ASSERT(VfRealHalAllocateMapRegisters);
      return STATUS_UNSUCCESSFUL;
   }

   if (NT_SUCCESS(status)) {

      adapterInformation = ViGetAdapterInformation((PDMA_ADAPTER)DmaAdapter);

      if (adapterInformation) {

         for (index = 0; index < BaseAddressCount; index++) {

            mapRegisterFile = NULL;

            if (ViDoubleBufferDma && ! adapterInformation->UseContiguousBuffers) {
               //
               // Note if this fails, we simply won't have double buffer
               //
               mapRegisterFile = ViAllocateMapRegisterFile(adapterInformation,
                                                           NumberOfMapRegisters);
            }
            if (mapRegisterFile) {
               //
               // Switch what the HAL gave us with our stuff
               //
               mapRegisterFile->MapRegisterBaseFromHal = MapRegisterArray[index].MapRegister;
               MapRegisterArray[index].MapRegister = mapRegisterFile;
            } else {
               //
               // Some drivers (scsiport for one) don't call
               // HalFlushAdapterBuffers unless MapRegisterBase is non-null.
               // In order to fool the drivers into thinking that they need
               // to flush, we exchange the NULL MapRegisterBase (if in fact
               // the hal uses a null map register base) for our
               //  MRF_NULL_PLACEHOLDER. We also make sure we replace it back
               // if needed
               //

               if (NULL == MapRegisterArray[index].MapRegister) {
                  MapRegisterArray[index].MapRegister = MRF_NULL_PLACEHOLDER;
               }
            }
            //
            // Account for this allocation. We need to add NumberOfMapRegisters
            // at a time so we will not trigger another assert
            //
            ADD_MAP_REGISTERS(adapterInformation, NumberOfMapRegisters, TRUE);
         } // for all map registers

      } // if (adapterInformation)

   } // if succesfully called the real API

   return status;

} // VfHalAllocateMapRegisters
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfirp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfirp.h

Abstract:

    This module contains prototypes for functions used to manage IRPs used in
    the verification process.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      05/02/2000 - Seperated out from ntos\io\hashirp.h

--*/

struct _IOV_STACK_LOCATION;
struct _IOV_REQUEST_PACKET;
struct _IOFCALLDRIVER_STACKDATA;

typedef struct _IOV_STACK_LOCATION         *PIOV_STACK_LOCATION;
typedef struct _IOV_REQUEST_PACKET         *PIOV_REQUEST_PACKET;
typedef struct _IOV_SESSION_DATA           *PIOV_SESSION_DATA;
typedef struct _IOFCALLDRIVER_STACKDATA    *PIOFCALLDRIVER_STACKDATA;

//
// Mini-snapshots of the IRP are stored on the stack for cases when the
// verifier needs to inform the developer as to the mistake, but no longer
// has the original IRP in memory. Because these may be stored on the stack,
// they need to be small and light.
//
typedef struct _IRP_MINI_SNAPSHOT {

    PIRP                Irp;
    IO_STACK_LOCATION   IoStackLocation;

} IRP_MINI_SNAPSHOT, *PIRP_MINI_SNAPSHOT;

typedef struct _IOV_STACK_LOCATION {

    BOOLEAN                 InUse;
    ULONG                   Flags;
    PIOV_STACK_LOCATION     RequestsFirstStackLocation;
    LIST_ENTRY              CallStackData;
    PIO_STACK_LOCATION      IrpSp;
    PVOID                   LastDispatch;
    LARGE_INTEGER           PerfDispatchStart;
    LARGE_INTEGER           PerfStackLocationStart;
    PDEVICE_OBJECT          ReferencingObject;
    LONG                    ReferencingCount;
    IO_STATUS_BLOCK         InitialStatusBlock;
    IO_STATUS_BLOCK         LastStatusBlock;
    PETHREAD                ThreadDispatchedTo;

} IOV_STACK_LOCATION;

typedef struct _IOV_SESSION_DATA {

   PIOV_REQUEST_PACKET          IovRequestPacket;
   LONG                         SessionRefCount;
   LIST_ENTRY                   SessionLink;
   ULONG                        SessionFlags;

   PETHREAD                     OriginatorThread;
   PDEVICE_OBJECT               DeviceLastCalled; // Last device called
   ULONG                        ForwardMethod;
   PIRP                         BestVisibleIrp;
   PVERIFIER_SETTINGS_SNAPSHOT  VerifierSettings;
   IOV_STACK_LOCATION           StackData[ANYSIZE_ARRAY];

} IOV_SESSION_DATA;

typedef struct _IOFCALLDRIVER_STACKDATA {

    PIOV_SESSION_DATA   IovSessionData;
    PIOV_STACK_LOCATION IovStackLocation;
    PIOV_REQUEST_PACKET IovPacket;
    ULONG               Flags;
    LIST_ENTRY          SharedLocationList;
    PDRIVER_DISPATCH    DispatchRoutine;
    NTSTATUS            ExpectedStatus;
    NTSTATUS            NewStatus;
    PDEVICE_OBJECT      RemovePdo;
    IRP_MINI_SNAPSHOT   IrpSnapshot;

} IOFCALLDRIVER_STACKDATA;

typedef struct _IOFCOMPLETEREQUEST_STACKDATA {

    PIOV_SESSION_DATA       IovSessionData;
    PIOV_REQUEST_PACKET     IovRequestPacket;
    BOOLEAN                 IsRemoveIrp;
    LONG                    LocationsAdvanced;
    ULONG                   RaisedCount;
    KIRQL                   PreviousIrql;
    PVOID                   CompletionRoutine;

} IOFCOMPLETEREQUEST_STACKDATA, *PIOFCOMPLETEREQUEST_STACKDATA;

VOID
FASTCALL
VfIrpInit(
    VOID
    );

PIRP
FASTCALL
VfIrpAllocate(
    IN CCHAR    StackSize
    );

VOID
FASTCALL
VfIrpMakeTouchable(
    IN  PIRP  Irp
    );

VOID
FASTCALL
VfIrpMakeUntouchable(
    IN  PIRP    Irp OPTIONAL
    );

VOID
FASTCALL
VfIrpFree(
    IN  PIRP   Irp OPTIONAL
    );

VOID
FASTCALL
VerifierIoAllocateIrp1(
    IN     CCHAR              StackSize,
    IN     BOOLEAN            ChargeQuota,
    IN OUT PIRP               *IrpPointer
    );

VOID
FASTCALL
VerifierIoAllocateIrp2(
    IN     PIRP               Irp
    );

VOID
FASTCALL
VerifierIoFreeIrp(
    IN     PIRP               Irp,
    IN OUT PBOOLEAN           FreeHandled
    );

VOID
FASTCALL
VerifierIoInitializeIrp(
    IN OUT PIRP               Irp,
    IN     USHORT             PacketSize,
    IN     CCHAR              StackSize,
    IN OUT PBOOLEAN           InitializeHandled
    );

BOOLEAN
FASTCALL
VfIrpReserveCallStackData(
    IN  PIRP                            Irp,
    OUT PIOFCALLDRIVER_STACKDATA       *IofCallDriverStackData
    );

VOID
FASTCALL
VfIrpPrepareAllocaCallStackData(
    OUT PIOFCALLDRIVER_STACKDATA        IofCallDriverStackData
    );

VOID
FASTCALL
VfIrpReleaseCallStackData(
    IN  PIOFCALLDRIVER_STACKDATA        IofCallDriverStackData  OPTIONAL
    );

//
// VfIrpCallDriverPreprocess is a macro function that may do an alloca as
// part of it's operation. As such callers must be careful not to use
// variable lengthed arrays in a scope that encompasses
// VfIrpCallDriverPreProcess but not VfIrpCallDriverPostProcess.
//
#define VfIrpCallDriverPreProcess(DeviceObject, IrpPointer, CallStackData, CallerAddress)  \
    if (!VfIrpReserveCallStackData(*(IrpPointer), (CallStackData))) {       \
        *(CallStackData) = alloca(sizeof(IOFCALLDRIVER_STACKDATA));         \
        VfIrpPrepareAllocaCallStackData(*(CallStackData));                  \
    }                                                                       \
    IovpCallDriver1((DeviceObject), (IrpPointer), *(CallStackData), (CallerAddress))

#define VfIrpCallDriverPostProcess(DeviceObject, FinalStatus, CallStackData) \
    IovpCallDriver2(DeviceObject, FinalStatus, CallStackData);               \
    VfIrpReleaseCallStackData(CallStackData)

BOOLEAN
VfIrpSendSynchronousIrp(
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIO_STACK_LOCATION  TopStackLocation,
    IN      BOOLEAN             Untouchable,
    IN      NTSTATUS            InitialStatus,
    IN      ULONG_PTR           InitialInformation  OPTIONAL,
    OUT     ULONG_PTR           *FinalInformation   OPTIONAL,
    OUT     NTSTATUS            *FinalStatus        OPTIONAL
    );

VOID
FASTCALL
VfIrpWatermark(
    IN PIRP  Irp,
    IN ULONG Flags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfirpdb.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfirpdb.h

Abstract:

    This header exposes prototypes for functions used to manage the database of
    IRP tracking data.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      05/02/2000 - Seperated out from ntos\io\hashirp.h

--*/

struct _IOV_DATABASE_HEADER;
typedef struct _IOV_DATABASE_HEADER IOV_DATABASE_HEADER;
typedef struct _IOV_DATABASE_HEADER *PIOV_DATABASE_HEADER;

typedef enum _IOV_REFERENCE_TYPE {

    IOVREFTYPE_PACKET = 0,
    IOVREFTYPE_POINTER

} IOV_REFERENCE_TYPE;

typedef enum {

    IRPDBEVENT_POINTER_COUNT_ZERO = 1,
    IRPDBEVENT_REFERENCE_COUNT_ZERO

} IRP_DATABASE_EVENT;

typedef VOID (*PFN_IRPDBEVENT_CALLBACK)(
    IN  PIOV_DATABASE_HEADER    IovHeader,
    IN  PIRP                    TrackedIrp  OPTIONAL,
    IN  IRP_DATABASE_EVENT      Event
    );

typedef struct _IOV_DATABASE_HEADER {

    PIRP                    TrackedIrp;     // Tracked IRP
    KSPIN_LOCK              HeaderLock;     // Spinlock on data structure
    KIRQL                   LockIrql;       // IRQL taken at.
    LONG                    ReferenceCount; // # of reasons to keep this packet
    LONG                    PointerCount;   // # of reasons to track by irp addr
    ULONG                   HeaderFlags;
    LIST_ENTRY              HashLink;       // Link in hash table.
    LIST_ENTRY              ChainLink;      // Head is HeadPacket
    PIOV_DATABASE_HEADER    ChainHead;      // First packet in a chain.
    PFN_IRPDBEVENT_CALLBACK NotificationCallback;
};

VOID
FASTCALL
VfIrpDatabaseInit(
    VOID
    );

BOOLEAN
FASTCALL
VfIrpDatabaseEntryInsertAndLock(
    IN      PIRP                    Irp,
    IN      PFN_IRPDBEVENT_CALLBACK NotificationCallback,
    IN OUT  PIOV_DATABASE_HEADER    IovHeader
    );

PIOV_DATABASE_HEADER
FASTCALL
VfIrpDatabaseEntryFindAndLock(
    IN PIRP     Irp
    );

VOID
FASTCALL
VfIrpDatabaseEntryAcquireLock(
    IN  PIOV_DATABASE_HEADER    IovHeader   OPTIONAL
    );

VOID
FASTCALL
VfIrpDatabaseEntryReleaseLock(
    IN  PIOV_DATABASE_HEADER    IovHeader
    );

VOID
FASTCALL
VfIrpDatabaseEntryReference(
    IN PIOV_DATABASE_HEADER IovHeader,
    IN IOV_REFERENCE_TYPE   IovRefType
    );

VOID
FASTCALL
VfIrpDatabaseEntryDereference(
    IN PIOV_DATABASE_HEADER IovHeader,
    IN IOV_REFERENCE_TYPE   IovRefType
    );

VOID
FASTCALL
VfIrpDatabaseEntryAppendToChain(
    IN OUT  PIOV_DATABASE_HEADER    IovExistingHeader,
    IN OUT  PIOV_DATABASE_HEADER    IovNewHeader
    );

VOID
FASTCALL
VfIrpDatabaseEntryRemoveFromChain(
    IN OUT  PIOV_DATABASE_HEADER    IovHeader
    );

PIOV_DATABASE_HEADER
FASTCALL
VfIrpDatabaseEntryGetChainPrevious(
    IN  PIOV_DATABASE_HEADER    IovHeader
    );

PIOV_DATABASE_HEADER
FASTCALL
VfIrpDatabaseEntryGetChainNext(
    IN  PIOV_DATABASE_HEADER    IovHeader
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfmacro.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    vfmacro.h

Abstract:

    This header contains a collection of macros used by the verifier.

Author:

    Adrian J. Oney (AdriaO) June 7, 2000.

Revision History:


--*/


//
// This macro takes an array and returns the number of elements in it.
//
#define ARRAY_COUNT(array) (sizeof(array)/sizeof(array[0]))

//
// This macro takes a value and an alignment and rounds the entry up
// appropriately. The alignment MUST be a power of two!
//
#define ALIGN_UP_ULONG(value, alignment) (((value)+(alignment)-1)&(~(alignment-1)))

//
// This macro compares two guids in their binary form for equivalence.
//
#define IS_EQUAL_GUID(a,b) (RtlCompareMemory(a, b, sizeof(GUID)) == sizeof(GUID))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfirplog.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfirplog.c

Abstract:

    This module manages IRP logs for the verifier.

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode

Revision History:

--*/

//
// Disable W4 level warnings generated by public headers.
//
#include "vfpragma.h"

#include "..\io\iop.h" // Includes vfdef.h
#include "viirplog.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, VfIrpLogInit)
#pragma alloc_text(PAGEVRFY, ViIrpLogDatabaseFindPointer)
#pragma alloc_text(PAGEVRFY, ViIrpLogExposeWmiCallback)
#pragma alloc_text(PAGEVRFY, VfIrpLogRecordEvent)
#pragma alloc_text(PAGEVRFY, VfIrpLogGetIrpDatabaseSiloCount)
#pragma alloc_text(PAGEVRFY, VfIrpLogLockDatabase)
#pragma alloc_text(PAGEVRFY, VfIrpLogRetrieveWmiData)
#pragma alloc_text(PAGEVRFY, VfIrpLogUnlockDatabase)
#pragma alloc_text(PAGEVRFY, VfIrpLogDeleteDeviceLogs)
#endif

PIRPLOG_HEAD ViIrpLogDatabase;
KSPIN_LOCK  ViIrpLogDatabaseLock;
LONG ViIrpLogDdiLock = DDILOCK_UNREGISTERED;

#define POOLTAG_IRPLOG_DATABASE     'dIfV'
#define POOLTAG_IRPLOG_DATA         'eIfV'
#define POOLTAG_IRPLOG_TEMP         'tIfV'
#define POOLTAG_IRPLOG_WORKITEM     'wIfV'

#define INSTANCE_NAME_PROLOG        L"VERIFIER"

VOID
VfIrpLogInit(
    VOID
    )
/*++

  Description:

    This routine initializes all the important structures we use to log IRPs.

  Arguments:

    None

  Return Value:

    None

--*/
{
    ULONG i;

    PAGED_CODE();

    KeInitializeSpinLock(&ViIrpLogDatabaseLock);

    //
    // As this is system startup code, it is one of the very few places
    // where it's ok to use MustSucceed.
    //
    ViIrpLogDatabase = (PIRPLOG_HEAD) ExAllocatePoolWithTag(
        NonPagedPoolMustSucceed,
        VI_IRPLOG_DATABASE_HASH_SIZE * sizeof(IRPLOG_HEAD),
        POOLTAG_IRPLOG_DATABASE
        );

    for(i=0; i < VI_IRPLOG_DATABASE_HASH_SIZE; i++) {

        ViIrpLogDatabase[i].Locked = FALSE;
        InitializeListHead(&ViIrpLogDatabase[i].ListHead);
    }
}


PIRPLOG_DATA
FASTCALL
ViIrpLogDatabaseFindPointer(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PIRPLOG_HEAD   *HashHead
    )
/*++

  Description:

    This routine returns a pointer to a pointer to the per-device object.
    data. This function is meant to be called by other routines in this file.

    N.B. The verifier devobj database lock is assumed to be held by the caller.

  Arguments:

    DeviceObject - Device object to locate in the tracking table.

    HashHead     - If return is non-null, points to the hash head that should
                   be used to insert the tracking data.

  Return Value:

     IrpLogData iff found, NULL otherwise.

--*/
{
    PIRPLOG_DATA irpLogData;
    PLIST_ENTRY listEntry, listHead;
    UINT_PTR hashIndex;

    hashIndex = VI_IRPLOG_CALCULATE_DATABASE_HASH(DeviceObject);

    ASSERT_SPINLOCK_HELD(&ViIrpLogDatabaseLock);

    *HashHead = &ViIrpLogDatabase[hashIndex];

    listHead = &ViIrpLogDatabase[hashIndex].ListHead;

    for(listEntry = listHead;
        listEntry->Flink != listHead;
        listEntry = listEntry->Flink) {

        irpLogData = CONTAINING_RECORD(listEntry->Flink, IRPLOG_DATA, HashLink);

        if (irpLogData->DeviceObject == DeviceObject) {

            return irpLogData;
        }
    }

    return NULL;
}


VOID
ViIrpLogExposeWmiCallback(
    IN  PVOID   Context
    )
{
    PWORK_QUEUE_ITEM workQueueItem;

    PAGED_CODE();

    workQueueItem = (PWORK_QUEUE_ITEM) Context;

    VfDdiExposeWmiObjects();

    ViIrpLogDdiLock = DDILOCK_REGISTERED;
    ExFreePool(workQueueItem);
}


VOID
VfIrpLogRecordEvent(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot,
    IN  PDEVICE_OBJECT              DeviceObject,
    IN  PIRP                        Irp
    )
{
    PIRPLOG_HEAD hashHead;
    PIRPLOG_DATA irpLogData;
    IRPLOG_SNAPSHOT irpLogSnapshot;
    PWORK_QUEUE_ITEM workQueueItem;
    KIRQL oldIrql;
    LONG oldVal;
    ULONG maxElementCount;
    ULONG elementCount;
    LOGICAL logEntry;

    if (!VfSettingsIsOptionEnabled(VerifierSettingsSnapshot,
                                   VERIFIER_OPTION_EXPOSE_IRP_HISTORY)) {

        return;
    }

    if (ViIrpLogDdiLock != DDILOCK_REGISTERED) {

        oldVal = InterlockedCompareExchange( &ViIrpLogDdiLock,
                                             DDILOCK_REGISTERING,
                                             DDILOCK_UNREGISTERED );

        if (oldVal == DDILOCK_UNREGISTERED) {

            workQueueItem = (PWORK_QUEUE_ITEM) ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(WORK_QUEUE_ITEM),
                POOLTAG_IRPLOG_WORKITEM
                );

            if (workQueueItem) {

                ExInitializeWorkItem(
                    workQueueItem,
                    ViIrpLogExposeWmiCallback,
                    workQueueItem
                    );

                ExQueueWorkItem(
                    workQueueItem,
                    DelayedWorkQueue
                    );

            } else {

                ViIrpLogDdiLock = DDILOCK_UNREGISTERED;
            }
        }
    }

    ExAcquireSpinLock(&ViIrpLogDatabaseLock, &oldIrql);

    irpLogData = ViIrpLogDatabaseFindPointer(DeviceObject, &hashHead);

    if (hashHead->Locked) {

        //
        // The current logs are being drained. Since logs are lossy anyway,
        // dump this one on the floor.
        //
        ExReleaseSpinLock(&ViIrpLogDatabaseLock, oldIrql);
        return;
    }

    if (irpLogData == NULL) {

        VfSettingsGetValue(
            VerifierSettingsSnapshot,
            VERIFIER_VALUE_IRPLOG_COUNT,
            &maxElementCount
            );

        irpLogData = ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(IRPLOG_DATA)+(maxElementCount-1)*sizeof(IRPLOG_SNAPSHOT),
            POOLTAG_IRPLOG_DATA
            );

        if (irpLogData != NULL) {

            ObReferenceObject(DeviceObject);
            irpLogData->DeviceObject = DeviceObject;
            irpLogData->Flags = 0;
            irpLogData->DeviceType = DeviceObject->DeviceType;
            irpLogData->Head = 0;
            irpLogData->MaximumElementCount = maxElementCount;
            InsertHeadList(&hashHead->ListHead, &irpLogData->HashLink);
        }
    }

    if (irpLogData != NULL) {

        if (!(irpLogData->Flags & (IRPLOG_FLAG_DELETED | IRPLOG_FLAG_NAMELESS))) {

            if (irpLogData->Flags == IRPLOG_FLAG_FULL) {

                elementCount = irpLogData->MaximumElementCount;

            } else {

                elementCount = irpLogData->Head;
            }

            logEntry = VfMajorBuildIrpLogEntry(
                Irp,
                elementCount,
                &irpLogData->SnapshotArray[irpLogData->Head],
                &irpLogSnapshot
                );

            if (logEntry) {

                irpLogData->SnapshotArray[irpLogData->Head] = irpLogSnapshot;

                irpLogData->Head++;

                if (irpLogData->Head == irpLogData->MaximumElementCount) {

                    irpLogData->Flags |= IRPLOG_FLAG_FULL;
                    irpLogData->Head = 0;
                }
            }
        }
    }

    ExReleaseSpinLock(&ViIrpLogDatabaseLock, oldIrql);
}


ULONG
VfIrpLogGetIrpDatabaseSiloCount(
    VOID
    )
{
    return VI_IRPLOG_DATABASE_HASH_SIZE;
}


NTSTATUS
VfIrpLogLockDatabase(
    IN  ULONG   SiloNumber
    )
{
    NTSTATUS status;
    KIRQL oldIrql;

    ASSERT(SiloNumber < VI_IRPLOG_DATABASE_HASH_SIZE);

    //
    // Take the database offline. From this point on, changes can still be made
    // but new entries cannot be added, nor can old ones be removed from the
    // tree. We do this under a lock to ensure all current inserts/removals
    // have drained with respect to the state change.
    //
    ExAcquireSpinLock(&ViIrpLogDatabaseLock, &oldIrql);

    if (ViIrpLogDatabase[SiloNumber].Locked) {

        //
        // Reentrancy attempt - we don't try to do anything clever.
        //
        status = STATUS_RETRY;

    } else {

        ViIrpLogDatabase[SiloNumber].Locked = TRUE;
        status = STATUS_SUCCESS;
    }

    ExReleaseSpinLock(&ViIrpLogDatabaseLock, oldIrql);

    return status;
}


NTSTATUS
VfIrpLogRetrieveWmiData(
    IN  ULONG   SiloNumber,
    OUT PUCHAR  OutputBuffer                OPTIONAL,
    OUT ULONG  *OffsetInstanceNameOffsets,
    OUT ULONG  *InstanceCount,
    OUT ULONG  *DataBlockOffset,
    OUT ULONG  *TotalRequiredSize
    )
{
    PIRPLOG_DATA irpLogData;
    PLIST_ENTRY listEntry, listHead;
    ULONG instances;
    POBJECT_NAME_INFORMATION objectName;
    ULONG currentNameSize, neededNameSize;
    ULONG totalDataSize;
    ULONG nameOffsetArrayOffset;
    ULONG instanceLengthArrayOffset;
    ULONG nameStringBufferOffset;
    ULONG instanceDataOffset;
    ULONG individualStringLengthInBytes;
    ULONG individualStringLengthInChars;
    ULONG elementCount;
    PULONG nameOffsetBuffer;
    POFFSETINSTANCEDATAANDLENGTH instanceLengthBuffer;
    PUSHORT nameStringBuffer;
    PUCHAR instanceDataBuffer;
    NTSTATUS status;

    //
    // The irp log database must be locked for this query.
    //
    ASSERT(SiloNumber < VI_IRPLOG_DATABASE_HASH_SIZE);
    ASSERT(ViIrpLogDatabase[SiloNumber].Locked);

    //
    // Preinit for error.
    //
    *OffsetInstanceNameOffsets = 0;
    *InstanceCount = 0;
    *DataBlockOffset = 0;
    *TotalRequiredSize = 0;

    //
    // Allocate an initial buffer.
    //
    currentNameSize = sizeof(OBJECT_NAME_INFORMATION);

    objectName = ExAllocatePoolWithTag(
        PagedPool,
        currentNameSize,
        POOLTAG_IRPLOG_TEMP
        );

    if (objectName == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Walk through the database and start retrieving information. First count
    // the instances.
    //
    instances = 0;
    listHead = &ViIrpLogDatabase[SiloNumber].ListHead;

    for(listEntry = listHead;
        listEntry->Flink != listHead;
        listEntry = listEntry->Flink) {

        irpLogData = CONTAINING_RECORD(listEntry->Flink, IRPLOG_DATA, HashLink);

#ifdef MAX_INSTANCE_COUNT
        if (instances == MAX_INSTANCE_COUNT) {

            break;
        }
#endif

        instances++;
    }

    //
    // First, since we have dynamic named, we need to allocate space for the
    // ULONG-sized array of offset pointers to each string.
    //

    //
    // The buffer will look like this:
    //
    // [WNODE_ALL_DATA]
    // [Array of per-instance DataOffset+DataLength entries)
    // [Array of per-instance NameOffset entries]
    // [names]
    // [data]
    //
    instanceLengthArrayOffset = FIELD_OFFSET(WNODE_ALL_DATA, OffsetInstanceDataAndLength);
    nameOffsetArrayOffset =  instanceLengthArrayOffset + instances*sizeof(OFFSETINSTANCEDATAANDLENGTH);
    nameStringBufferOffset = nameOffsetArrayOffset + instances*sizeof(ULONG);

    nameOffsetBuffer = (PULONG) (OutputBuffer + nameOffsetArrayOffset);
    instanceLengthBuffer = (POFFSETINSTANCEDATAANDLENGTH) (OutputBuffer + instanceLengthArrayOffset);
    nameStringBuffer = (PUSHORT) (OutputBuffer + nameStringBufferOffset);

    //
    // So far the required size only accounts for the array of offsets to names
    //
    totalDataSize = nameStringBufferOffset;

    //
    // Now start collecting the names.
    //
    status = STATUS_SUCCESS;
    instances = 0;
    listHead = &ViIrpLogDatabase[SiloNumber].ListHead;

    for(listEntry = listHead;
        listEntry->Flink != listHead;
        listEntry = listEntry->Flink) {

        irpLogData = CONTAINING_RECORD(listEntry->Flink, IRPLOG_DATA, HashLink);

        //
        // Retrieve the name
        //
        status = ObQueryNameString(
            irpLogData->DeviceObject,
            objectName,
            currentNameSize,
            &neededNameSize
            );

        if (status == STATUS_INFO_LENGTH_MISMATCH) {

            ExFreePool(objectName);

            objectName = ExAllocatePoolWithTag(
                    PagedPool,
                    neededNameSize,
                    POOLTAG_IRPLOG_TEMP
                    );

            if (objectName == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                currentNameSize = neededNameSize;

                status = ObQueryNameString(
                    irpLogData->DeviceObject,
                    objectName,
                    currentNameSize,
                    &neededNameSize
                    );
            }
        }

        if (!NT_SUCCESS(status)) {

            break;
        }

        if (objectName->Name.Length == 0) {

            irpLogData->Flags |= IRPLOG_FLAG_NAMELESS;
            continue;
        }

#ifdef MAX_INSTANCE_COUNT
        if (instances == MAX_INSTANCE_COUNT) {

            break;
        }
#endif

        instances++;

        //
        // Write the appropriate offset into the name offset array
        //
        if (ARGUMENT_PRESENT(OutputBuffer)) {

            *nameOffsetBuffer = totalDataSize;
        }

        nameOffsetBuffer++;

        //
        // Add in memory for each "counted" string. WMI counted strings are
        // of the form [USHORT LenInBytesIncludingTerminator]
        //             [WCHAR Array w/NULL terminator]
        //
        // The string is of the form VERIFIER\Device\Foo (The terminating NULL
        // is accounted for by sizeof().
        //
        individualStringLengthInBytes = objectName->Name.Length + sizeof(INSTANCE_NAME_PROLOG);
        individualStringLengthInChars = individualStringLengthInBytes/sizeof(WCHAR);

        //
        // Write out the counted string, starting with the length
        //
        ASSERT(OutputBuffer + totalDataSize == (PUCHAR) nameStringBuffer);

        if (ARGUMENT_PRESENT(OutputBuffer)) {

            *nameStringBuffer = (USHORT) individualStringLengthInBytes;
        }

        nameStringBuffer++;
        totalDataSize += sizeof(USHORT);

        if (ARGUMENT_PRESENT(OutputBuffer)) {

            RtlCopyMemory(
                nameStringBuffer,
                INSTANCE_NAME_PROLOG,
                sizeof(INSTANCE_NAME_PROLOG)-sizeof(UNICODE_NULL)
                );

            RtlCopyMemory(
                nameStringBuffer + ((sizeof(INSTANCE_NAME_PROLOG) - sizeof(UNICODE_NULL))/sizeof(WCHAR)),
                objectName->Name.Buffer,
                objectName->Name.Length
                );

            nameStringBuffer[individualStringLengthInChars-1] = UNICODE_NULL;
        }

        nameStringBuffer += individualStringLengthInChars;
        totalDataSize += individualStringLengthInBytes;
    }

    if (objectName) {

        ExFreePool(objectName);
    }

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Now collect the instance data
    //
    totalDataSize = ALIGN_UP_ULONG(totalDataSize, 8);
    instanceDataOffset = totalDataSize;
    instanceDataBuffer = (OutputBuffer + instanceDataOffset);

    instances = 0;
    listHead = &ViIrpLogDatabase[SiloNumber].ListHead;

    for(listEntry = listHead;
        listEntry->Flink != listHead;
        listEntry = listEntry->Flink) {

        irpLogData = CONTAINING_RECORD(listEntry->Flink, IRPLOG_DATA, HashLink);

        if (irpLogData->Flags & IRPLOG_FLAG_NAMELESS) {

            continue;
        }

#ifdef MAX_INSTANCE_COUNT
        if (instances == MAX_INSTANCE_COUNT) {

            break;
        }
#endif

        instances++;

        if (irpLogData->Flags & IRPLOG_FLAG_FULL) {

            elementCount = irpLogData->MaximumElementCount;

        } else {

            elementCount = irpLogData->Head;
        }

        if (ARGUMENT_PRESENT(OutputBuffer)) {

            //
            // Update the array of per-instance Offset/Length information
            //
            instanceLengthBuffer->OffsetInstanceData = totalDataSize;

            instanceLengthBuffer->LengthInstanceData =
                sizeof(ULONG)*2 + (elementCount * sizeof(IRPLOG_SNAPSHOT));

            instanceLengthBuffer++;

            //
            // Write out the device type.
            //
            *((PULONG) instanceDataBuffer) = irpLogData->DeviceType;
            instanceDataBuffer += sizeof(ULONG);

            //
            // Write out the instance data count
            //
            *((PULONG) instanceDataBuffer) = elementCount;
            instanceDataBuffer += sizeof(ULONG);

            //
            // Don't bother with reordering the data appropriately. Also note
            // that we have 8 byte alignment here - very important!!!
            //
            RtlCopyMemory(
                instanceDataBuffer,
                irpLogData->SnapshotArray,
                elementCount * sizeof(IRPLOG_SNAPSHOT)
                );

            instanceDataBuffer += elementCount * sizeof(IRPLOG_SNAPSHOT);
        }

        totalDataSize += sizeof(ULONG)*2;
        totalDataSize += elementCount * sizeof(IRPLOG_SNAPSHOT);
    }

    *OffsetInstanceNameOffsets = nameOffsetArrayOffset;
    *InstanceCount = instances;
    *DataBlockOffset = instanceDataOffset;
    *TotalRequiredSize = totalDataSize;
    return STATUS_SUCCESS;
}


VOID
VfIrpLogUnlockDatabase(
    IN  ULONG   SiloNumber
    )
{
    KIRQL oldIrql;
    PIRPLOG_DATA irpLogData;
    PLIST_ENTRY listEntry, listHead;

    ASSERT(SiloNumber < VI_IRPLOG_DATABASE_HASH_SIZE);

    //
    // Reenable logging to present devices
    //
    ViIrpLogDatabase[SiloNumber].Locked = FALSE;

    //
    // Clean up any lingering deleted device data
    //
    ExAcquireSpinLock(&ViIrpLogDatabaseLock, &oldIrql);

    listHead = &ViIrpLogDatabase[SiloNumber].ListHead;

    for(listEntry = listHead;
        listEntry->Flink != listHead;
        listEntry = listEntry->Flink) {

        irpLogData = CONTAINING_RECORD(listEntry->Flink, IRPLOG_DATA, HashLink);

        if (irpLogData->Flags & IRPLOG_FLAG_DELETED) {

            ObDereferenceObject(irpLogData->DeviceObject);
            RemoveEntryList(&irpLogData->HashLink);
            ExFreePool(irpLogData);
        }
    }

    ExReleaseSpinLock(&ViIrpLogDatabaseLock, oldIrql);
}


VOID
VfIrpLogDeleteDeviceLogs(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PIRPLOG_DATA irpLogData;
    PIRPLOG_HEAD hashHead;
    KIRQL oldIrql;

    ExAcquireSpinLock(&ViIrpLogDatabaseLock, &oldIrql);

    irpLogData = ViIrpLogDatabaseFindPointer(DeviceObject, &hashHead);

    if (irpLogData != NULL) {

        if (!hashHead->Locked) {

            ObDereferenceObject(irpLogData->DeviceObject);
            RemoveEntryList(&irpLogData->HashLink);

            ExFreePool(irpLogData);

        } else {

            irpLogData->Flags |= IRPLOG_FLAG_DELETED;
        }
    }

    ExReleaseSpinLock(&ViIrpLogDatabaseLock, oldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfirpdb.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfirpdb.c

Abstract:

    This module contains functions used to manage the database of IRP tracking
    data.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      05/02/2000 - Seperated out from ntos\io\hashirp.c

--*/

#include "vfdef.h"
#include "viirpdb.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,     VfIrpDatabaseInit)
#pragma alloc_text(PAGEVRFY, ViIrpDatabaseFindPointer)
#pragma alloc_text(PAGEVRFY, VfIrpDatabaseEntryInsertAndLock)
#pragma alloc_text(PAGEVRFY, VfIrpDatabaseEntryFindAndLock)
#pragma alloc_text(PAGEVRFY, VfIrpDatabaseEntryAcquireLock)
#pragma alloc_text(PAGEVRFY, VfIrpDatabaseEntryReleaseLock)
#pragma alloc_text(PAGEVRFY, VfIrpDatabaseEntryReference)
#pragma alloc_text(PAGEVRFY, VfIrpDatabaseEntryDereference)
#pragma alloc_text(PAGEVRFY, VfIrpDatabaseEntryAppendToChain)
#pragma alloc_text(PAGEVRFY, VfIrpDatabaseEntryRemoveFromChain)
#pragma alloc_text(PAGEVRFY, VfIrpDatabaseEntryGetChainPrevious)
#pragma alloc_text(PAGEVRFY, VfIrpDatabaseEntryGetChainNext)
#pragma alloc_text(PAGEVRFY, ViIrpDatabaseEntryDestroy)
#endif

#define POOL_TAG_IRP_DATABASE   'tToI'

//
// This is our IRP tracking table, a hash table that points to a block of
// data associated with each IRP.
//
PLIST_ENTRY ViIrpDatabase;
KSPIN_LOCK  ViIrpDatabaseLock;

/*
 * The routines listed below -
 *   VfIrpDatabaseInit
 *   VfIrpDatabaseEntryInsertAndLock
 *   VfIrpDatabaseEntryFindAndLock
 *   VfIrpDatabaseAcquireLock
 *   VfIrpDatabaseReleaseLock
 *   VfIrpDatabaseReference
 *   VfIrpDatabaseDereference
 *   VfIrpDatabaseEntryAppendToChain
 *   VfIrpDatabaseEntryRemoveFromChain
 *   VfIrpDatabaseEntryGetChainPrevious
 *   VfIrpDatabaseEntryGetChainNext
 *   ViIrpDatabaseFindPointer              - (internal)
 *   ViIrpDatabaseEntryDestroy             - (internal)
 *
 * - store and retrieve IRP tracking information from the IRP database. Users
 * of the database pass around IOV_DATABASE_HEADER's which are usually part of
 * a larger structure. We use a hash table setup to quickly find the IRPs in
 * our table.
 *
 *     Each entry in the table has a pointer count and a reference count. The
 * pointer count expresses the number of reasons the IRP should be located by
 * address. For instance, when an IRP is freed or recycled the pointer count
 * would go to zero. The reference count is greater or equal to the pointer
 * count, and expresses the number of reasons to keep the data structure around.
 * It is fairly common for a database entry to lose it's "pointer" but have a
 * non-zero reference count during which time thread stacks may be unwinding.
 *
 *     Another aspect of the IRP database is it supports the "chaining" of
 * entries together. Locking an entry automatically locks all entries back to
 * the head of the chain. Entries can only be added or removed from the end of
 * the chain. This feature is used to support "surrogate" IRPs, where a new
 * IRP is sent in place of the IRP originally delivered to a new stack.
 *
 * Locking semantics:
 *     There are two locks involved when dealing with IRP database entries, the
 * global database lock and the per-entry header lock. No IRP may be removed
 * from or inserted into the table without the DatabaseLock being taken. The
 * database lock must also be held when the IRP pointer is zeroed due to a newly
 * zeroed pointer count. The reference count must be manipulated using
 * interlocked operators, as it is may be modified when either lock is held.
 * The pointer count on the other hand is only modified with the header lock
 * held, and as such does not require interlocked ops.
 *
 * Perf - The database lock should be replaced with an array of
 *        VI_DATABASE_HASH_SIZE database locks with little cost.
 */

VOID
FASTCALL
VfIrpDatabaseInit(
    VOID
    )
/*++

  Description:

    This routine initializes all the important structures we use to track
    IRPs through the hash tables.

  Arguments:

    None

  Return Value:

    None

--*/
{
    ULONG i;

    PAGED_CODE();

    KeInitializeSpinLock(&ViIrpDatabaseLock);

    //
    // As this is system startup code, it is one of the very few places where
    // it's ok to use MustSucceed.
    //
    ViIrpDatabase = (PLIST_ENTRY) ExAllocatePoolWithTag(
        NonPagedPoolMustSucceed,
        VI_DATABASE_HASH_SIZE * sizeof(LIST_ENTRY),
        POOL_TAG_IRP_DATABASE
        );

    for(i=0; i < VI_DATABASE_HASH_SIZE; i++) {

        InitializeListHead(ViIrpDatabase+i);
    }
}


PIOV_DATABASE_HEADER
FASTCALL
ViIrpDatabaseFindPointer(
    IN  PIRP            Irp,
    OUT PLIST_ENTRY     *HashHead
    )
/*++

  Description:

    This routine returns a pointer to a pointer to the Irp tracking data.
    This function is meant to be called by other routines in this file.

    N.B. The tracking lock is assumed to be held by the caller.

  Arguments:

    Irp                        - Irp to locate in the tracking table.

    HashHead                   - If return is non-null, points to the
                                 list head that should be used to insert
                                 the IRP.

  Return Value:

     IovHeader iff found, NULL otherwise.

--*/
{
    PIOV_DATABASE_HEADER iovHeader;
    PLIST_ENTRY listEntry, listHead;
    UINT_PTR hashIndex;

    hashIndex = VI_DATABASE_CALCULATE_HASH(Irp);

    ASSERT_SPINLOCK_HELD(&ViIrpDatabaseLock);

    *HashHead = listHead = ViIrpDatabase + hashIndex;

    for(listEntry = listHead;
        listEntry->Flink != listHead;
        listEntry = listEntry->Flink) {

        iovHeader = CONTAINING_RECORD(listEntry->Flink, IOV_DATABASE_HEADER, HashLink);

        if (iovHeader->TrackedIrp == Irp) {

            return iovHeader;
        }
    }

    return NULL;
}


BOOLEAN
FASTCALL
VfIrpDatabaseEntryInsertAndLock(
    IN      PIRP                    Irp,
    IN      PFN_IRPDBEVENT_CALLBACK NotificationCallback,
    IN OUT  PIOV_DATABASE_HEADER    IovHeader
    )
/*++

  Description:

    This routine inserts an IovHeader that is associated with the Irp into the
    IRP database table. The IRP does not get an initial reference count however.
    VfIrpDatabaseEntryReleaseLock must be called to drop the lock taken out.

  Arguments:

    Irp                  - Irp to begin tracking.

    NotificationCallback - Callback function to invoke for various database
                           events.

    IovHeader            - Points to an IovHeader to insert. The IovHeader
                           fields will be properly initialized by this function.

  Return Value:

    TRUE if successful, FALSE if driver error detected. On error the passed in
    header will have been freed.

--*/
{
    KIRQL oldIrql;
    PIOV_DATABASE_HEADER iovHeaderPointer;
    PLIST_ENTRY hashHead;

    ExAcquireSpinLock(&ViIrpDatabaseLock, &oldIrql);

    iovHeaderPointer = ViIrpDatabaseFindPointer(Irp, &hashHead);

    ASSERT(iovHeaderPointer == NULL);

    if (iovHeaderPointer) {

        ExReleaseSpinLock(&ViIrpDatabaseLock, oldIrql);
        return FALSE;
    }

    //
    // From top to bottom, initialize the fields. Note that there is not a
    // "surrogateHead". If any code needs to find out the first entry in the
    // circularly linked list of IRPs (the first is the only non-surrogate IRP),
    // then HeadPacket should be used. Note that the link to the session is
    // stored by the headPacket, more on this later.
    //
    IovHeader->TrackedIrp = Irp;
    KeInitializeSpinLock(&IovHeader->HeaderLock);
    IovHeader->ReferenceCount = 1;
    IovHeader->PointerCount = 1;
    IovHeader->HeaderFlags = 0;
    InitializeListHead(&IovHeader->HashLink);
    InitializeListHead(&IovHeader->ChainLink);
    IovHeader->ChainHead = IovHeader;
    IovHeader->NotificationCallback = NotificationCallback;

    //
    // Place into hash table under lock (with the initial reference count)
    //
    InsertHeadList(hashHead, &IovHeader->HashLink);

    VERIFIER_DBGPRINT((
        "  VRP CREATE(%x)->%x\n",
        Irp,
        IovHeader
        ), 3);

    ExReleaseSpinLock(&ViIrpDatabaseLock, oldIrql);

    iovHeaderPointer = VfIrpDatabaseEntryFindAndLock(Irp);

    ASSERT(iovHeaderPointer == IovHeader);

    if (iovHeaderPointer == NULL) {

        return FALSE;

    } else if (iovHeaderPointer != IovHeader) {

        VfIrpDatabaseEntryReleaseLock(iovHeaderPointer);
        return FALSE;
    }

    InterlockedDecrement(&IovHeader->ReferenceCount);
    IovHeader->PointerCount--;

    ASSERT(IovHeader->PointerCount == 0);
    return TRUE;
}


PIOV_DATABASE_HEADER
FASTCALL
VfIrpDatabaseEntryFindAndLock(
    IN PIRP     Irp
    )
/*++

  Description:

    This routine will return the tracking data for an IRP that is
    being tracked without a surrogate or the tracking data for with
    a surrogate if the surrogate IRP is what was passed in.

  Arguments:

    Irp                    - Irp to find.

  Return Value:

    IovHeader block, iff above conditions are satified.

--*/
{
    KIRQL oldIrql;
    PIOV_DATABASE_HEADER iovHeader;
    PLIST_ENTRY listHead;

    ASSERT(Irp);
    ExAcquireSpinLock(&ViIrpDatabaseLock, &oldIrql);

    iovHeader = ViIrpDatabaseFindPointer(Irp, &listHead);

    if (!iovHeader) {

        ExReleaseSpinLock(&ViIrpDatabaseLock, oldIrql);
        return NULL;
    }

    InterlockedIncrement(&iovHeader->ReferenceCount);

    ExReleaseSpinLock(&ViIrpDatabaseLock, oldIrql);

    VfIrpDatabaseEntryAcquireLock(iovHeader);
    iovHeader->LockIrql = oldIrql;

    InterlockedDecrement(&iovHeader->ReferenceCount);

    //
    // Here we check the PointerCount field under the header lock. This might
    // be zero if the another thread just unlocked the entry after decrementing
    // the pointer count all the way to zero.
    //
    if (iovHeader->PointerCount == 0) {

        //
        // This might happen in the following manner:
        // 1) IoInitializeIrp is called on an allocated block of pool
        // 2) The IRP is first seen by the verifier in IoCallDriver
        // 3) The IRP completes, disappearing from the verifier's view
        // 4) At that exact moment, the driver calls IoCancelIrp
        // The above sequence can occur in a safetly coded driver if the memory
        // backing the IRP isn't freed until some event fired. Ie...
        //    ExAllocatePool
        //    IoInitializeIrp
        //    IoCallDriver
        //      IoCompleteRequest
        //    IoCancelIrp*
        //    KeWaitForSingleObject
        //    ExFreePool
        //
        //ASSERT(0);
        VfIrpDatabaseEntryReleaseLock(iovHeader);
        return NULL;
    }

    VERIFIER_DBGPRINT((
        "  VRP FIND(%x)->%x\n",
        Irp,
        iovHeader
        ), 3);

    return iovHeader;
}


VOID
FASTCALL
VfIrpDatabaseEntryAcquireLock(
    IN  PIOV_DATABASE_HEADER    IovHeader   OPTIONAL
    )
/*++

  Description:

    This routine is called by to acquire the IRPs tracking data lock.

    This function returns at DISPATCH_LEVEL. Callers *must* follow up with
    VfIrpDatabaseEntryReleaseLock.

  Arguments:

    IovHeader        - Pointer to the IRP tracking data (or NULL, in which
                       case this routine does nothing).

  Return Value:

     None.
--*/
{
    KIRQL oldIrql;
    PIOV_DATABASE_HEADER iovCurHeader;

    if (!IovHeader) {

        return;
    }

    iovCurHeader = IovHeader;
    ASSERT(iovCurHeader->ReferenceCount != 0);

    while(1) {

        ExAcquireSpinLock(&iovCurHeader->HeaderLock, &oldIrql);
        iovCurHeader->LockIrql = oldIrql;

        if (iovCurHeader == iovCurHeader->ChainHead) {

            break;
        }

        iovCurHeader = CONTAINING_RECORD(
            iovCurHeader->ChainLink.Blink,
            IOV_DATABASE_HEADER,
            ChainLink
            );
    }
}


VOID
FASTCALL
VfIrpDatabaseEntryReleaseLock(
    IN  PIOV_DATABASE_HEADER    IovHeader
    )
/*++

  Description:

    This routine releases the IRPs tracking data lock and adjusts the ref count
    as appropriate. If the reference count drops to zero, the tracking data is
    freed.

  Arguments:

    IovHeader              - Pointer to the IRP tracking data.

  Return Value:

     Nothing.

--*/
{
    BOOLEAN freeTrackingData;
    PIOV_DATABASE_HEADER iovCurHeader, iovChainHead, iovNextHeader;
    KIRQL oldIrql;

    //
    // Pass one, delink anyone from the tree who's leaving, and assert that
    // no surrogates are left after a freed one.
    //
    iovCurHeader = iovChainHead = IovHeader->ChainHead;
    while(1) {

        ASSERT_SPINLOCK_HELD(&iovCurHeader->HeaderLock);

        iovNextHeader = CONTAINING_RECORD(
            iovCurHeader->ChainLink.Flink,
            IOV_DATABASE_HEADER,
            ChainLink
            );

        //
        // PointerCount is always referenced under the header lock.
        //
        if (iovCurHeader->PointerCount == 0) {

            ExAcquireSpinLock(&ViIrpDatabaseLock, &oldIrql);

            //
            // This field may be examined only under the database lock.
            //
            if (iovCurHeader->TrackedIrp) {

                iovCurHeader->NotificationCallback(
                    iovCurHeader,
                    iovCurHeader->TrackedIrp,
                    IRPDBEVENT_POINTER_COUNT_ZERO
                    );

                iovCurHeader->TrackedIrp = NULL;
            }

            ExReleaseSpinLock(&ViIrpDatabaseLock, oldIrql);
        }

        //
        // We now remove any entries that will be leaving from the hash table.
        // Note that the ReferenceCount may be incremented outside the header
        // lock (but under the database lock) but ReferenceCount can never be
        // dropped outside of the IRP lock. Therefore for performance we check
        // once and then take the lock to prevent anyone finding it and
        // incrementing it.
        //
        if (iovCurHeader->ReferenceCount == 0) {

            ExAcquireSpinLock(&ViIrpDatabaseLock, &oldIrql);

            if (iovCurHeader->ReferenceCount == 0) {

                ASSERT(iovCurHeader->PointerCount == 0);
/*
                ASSERT((iovCurHeader->pIovSessionData == NULL) ||
                       (iovCurHeader != iovChainHead));
*/
                ASSERT((iovNextHeader->ReferenceCount == 0) ||
                       (iovNextHeader == iovChainHead));

                RemoveEntryList(&iovCurHeader->HashLink);

                InitializeListHead(&iovCurHeader->HashLink);
            }

            ExReleaseSpinLock(&ViIrpDatabaseLock, oldIrql);
        }

        if (iovCurHeader == IovHeader) {

            break;
        }

        iovCurHeader = iovNextHeader;
    }

    //
    // Pass two, drop locks and free neccessary data.
    //
    iovCurHeader = iovChainHead;
    while(1) {

        freeTrackingData = (BOOLEAN)IsListEmpty(&iovCurHeader->HashLink);

        iovNextHeader = CONTAINING_RECORD(
            iovCurHeader->ChainLink.Flink,
            IOV_DATABASE_HEADER,
            ChainLink
            );

        ExReleaseSpinLock(&iovCurHeader->HeaderLock, iovCurHeader->LockIrql);

        if (freeTrackingData) {

            ASSERT(IsListEmpty(&iovCurHeader->ChainLink));

            ViIrpDatabaseEntryDestroy(iovCurHeader);

            iovCurHeader->NotificationCallback(
                iovCurHeader,
                iovCurHeader->TrackedIrp,
                IRPDBEVENT_REFERENCE_COUNT_ZERO
                );
        }

        if (iovCurHeader == IovHeader) {

            break;
        }

        iovCurHeader = iovNextHeader;
    }
}


VOID
FASTCALL
VfIrpDatabaseEntryReference(
    IN PIOV_DATABASE_HEADER IovHeader,
    IN IOV_REFERENCE_TYPE   IovRefType
    )
{
    ASSERT_SPINLOCK_HELD(&IovHeader->HeaderLock);

    VERIFIER_DBGPRINT((
        "  VRP REF(%x) %x++\n",
        IovHeader,
        IovHeader->ReferenceCount
        ), 3);

    InterlockedIncrement(&IovHeader->ReferenceCount);
    if (IovRefType == IOVREFTYPE_POINTER) {

        VERIFIER_DBGPRINT((
            "  VRP REF2(%x) %x++\n",
            IovHeader,
            IovHeader->PointerCount
            ), 3);

        IovHeader->PointerCount++;
    }
}


VOID
FASTCALL
VfIrpDatabaseEntryDereference(
    IN PIOV_DATABASE_HEADER IovHeader,
    IN IOV_REFERENCE_TYPE   IovRefType
    )
{
    KIRQL oldIrql;

    ASSERT_SPINLOCK_HELD(&IovHeader->HeaderLock);
    ASSERT(IovHeader->ReferenceCount > 0);

    VERIFIER_DBGPRINT((
        "  VRP DEREF(%x) %x--\n",
        IovHeader,
        IovHeader->ReferenceCount
        ), 3);

    if (IovRefType == IOVREFTYPE_POINTER) {

        ASSERT(IovHeader->PointerCount > 0);

        VERIFIER_DBGPRINT((
            "  VRP DEREF2(%x) %x--\n",
            IovHeader,
            IovHeader->PointerCount
            ), 3);

        IovHeader->PointerCount--;

        if (IovHeader->PointerCount == 0) {

            ExAcquireSpinLock(&ViIrpDatabaseLock, &oldIrql);

            IovHeader->NotificationCallback(
                IovHeader,
                IovHeader->TrackedIrp,
                IRPDBEVENT_POINTER_COUNT_ZERO
                );

            IovHeader->TrackedIrp = NULL;

            ExReleaseSpinLock(&ViIrpDatabaseLock, oldIrql);
        }
    }

    InterlockedDecrement(&IovHeader->ReferenceCount);

    ASSERT(IovHeader->ReferenceCount >= IovHeader->PointerCount);
}


VOID
FASTCALL
VfIrpDatabaseEntryAppendToChain(
    IN OUT  PIOV_DATABASE_HEADER    IovExistingHeader,
    IN OUT  PIOV_DATABASE_HEADER    IovNewHeader
    )
{
    ASSERT_SPINLOCK_HELD(&IovExistingHeader->HeaderLock);
    ASSERT_SPINLOCK_HELD(&IovNewHeader->HeaderLock);

    IovNewHeader->ChainHead = IovExistingHeader->ChainHead;

    //
    // Fix up IRQL's so spinlocks are released in the right order. Link'm.
    //
    IovNewHeader->LockIrql = IovExistingHeader->LockIrql;
    IovExistingHeader->LockIrql = DISPATCH_LEVEL;

    //
    // Insert this entry into the chain list
    //
    InsertTailList(
        &IovExistingHeader->ChainHead->ChainLink,
        &IovNewHeader->ChainLink
        );
}


VOID
FASTCALL
VfIrpDatabaseEntryRemoveFromChain(
    IN OUT  PIOV_DATABASE_HEADER    IovHeader
    )
{
    PIOV_DATABASE_HEADER iovNextHeader;

    ASSERT_SPINLOCK_HELD(&IovHeader->HeaderLock);

    //
    // It is not legal to remove an entry unless it is at the end of the chain.
    // This is illegal because the following entries might not be locked down,
    // and the ChainLink must be protected.
    //
    iovNextHeader = CONTAINING_RECORD(
        IovHeader->ChainLink.Flink,
        IOV_DATABASE_HEADER,
        ChainLink
        );

    ASSERT(iovNextHeader == IovHeader->ChainHead);

    RemoveEntryList(&IovHeader->ChainLink);
    InitializeListHead(&IovHeader->ChainLink);
    IovHeader->ChainHead = IovHeader;
}


PIOV_DATABASE_HEADER
FASTCALL
VfIrpDatabaseEntryGetChainPrevious(
    IN  PIOV_DATABASE_HEADER    IovHeader
    )
{
    PIOV_DATABASE_HEADER iovPrevHeader;

    ASSERT_SPINLOCK_HELD(&IovHeader->HeaderLock);

    if (IovHeader == IovHeader->ChainHead) {

        return NULL;
    }

    iovPrevHeader = CONTAINING_RECORD(
        IovHeader->ChainLink.Blink,
        IOV_DATABASE_HEADER,
        ChainLink
        );

    return iovPrevHeader;
}


PIOV_DATABASE_HEADER
FASTCALL
VfIrpDatabaseEntryGetChainNext(
    IN  PIOV_DATABASE_HEADER    IovHeader
    )
{
    PIOV_DATABASE_HEADER iovNextHeader;

    ASSERT_SPINLOCK_HELD(&IovHeader->HeaderLock);

    iovNextHeader = CONTAINING_RECORD(
        IovHeader->ChainLink.Flink,
        IOV_DATABASE_HEADER,
        ChainLink
        );

    return (iovNextHeader == IovHeader->ChainHead) ? NULL : iovNextHeader;
}


VOID
FASTCALL
ViIrpDatabaseEntryDestroy(
    IN OUT  PIOV_DATABASE_HEADER    IovHeader
    )
/*++

  Description:

    This routine marks an IovHeader as dead. The header should already have been
    removed from the table by a call to VfIrpDatabaseEntryReleaseLock with the
    ReferenceCount at 0. This routine is solely here for debugging purposes.

  Arguments:

    IovHeader - Header to mark dead.

  Return Value:

    Nope.

--*/
{
    //
    // The list entry is inited to point back to itself when removed. The
    // pointer count should of course still be zero.
    //
    IovHeader->HeaderFlags |= IOVHEADERFLAG_REMOVED_FROM_TABLE;
    ASSERT(IsListEmpty(&IovHeader->HashLink));

    //
    // with no reference counts...
    //
    ASSERT(!IovHeader->ReferenceCount);
    ASSERT(!IovHeader->PointerCount);

    VERIFIER_DBGPRINT((
        "  VRP FREE(%x)x\n",
        IovHeader
        ), 3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfirplog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfirplog.h

Abstract:

    This header exposes functions for logging IRP events.

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode

Revision History:

--*/

//
// Log-snapshots are retrievable by user mode for profiling and targetted
// probing of stacks. Content-wise they are heavier.
//
typedef struct _IRPLOG_SNAPSHOT {

    ULONG       Count;
    UCHAR       MajorFunction;
    UCHAR       MinorFunction;
    UCHAR       Flags;
    UCHAR       Control;
    ULONGLONG   ArgArray[4];

} IRPLOG_SNAPSHOT, *PIRPLOG_SNAPSHOT;

VOID
VfIrpLogInit(
    VOID
    );

VOID
VfIrpLogRecordEvent(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot,
    IN  PDEVICE_OBJECT              DeviceObject,
    IN  PIRP                        Irp
    );

ULONG
VfIrpLogGetIrpDatabaseSiloCount(
    VOID
    );

NTSTATUS
VfIrpLogLockDatabase(
    IN  ULONG   SiloNumber
    );

NTSTATUS
VfIrpLogRetrieveWmiData(
    IN  ULONG   SiloNumber,
    OUT PUCHAR  OutputBuffer                OPTIONAL,
    OUT ULONG  *OffsetInstanceNameOffsets,
    OUT ULONG  *InstanceCount,
    OUT ULONG  *DataBlockOffset,
    OUT ULONG  *TotalRequiredSize
    );

VOID
VfIrpLogUnlockDatabase(
    IN  ULONG   SiloNumber
    );

VOID
VfIrpLogDeleteDeviceLogs(
    IN PDEVICE_OBJECT DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfmajor.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfmajor.h

Abstract:

    This header contains prototypes for per-major IRP code verification.

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      06/15/2000 - Seperated out from ntos\io\flunkirp.h

--*/

//
// Use this major code to register a handler for default or all IRPs (context
// specific to function)
//
#define IRP_MJ_ALL_MAJORS   0xFF

typedef VOID (FASTCALL *PFN_DUMP_IRP_STACK)(
    IN PIO_STACK_LOCATION IrpSp
    );

typedef VOID (FASTCALL *PFN_VERIFY_NEW_REQUEST)(
    IN PIOV_REQUEST_PACKET  IrpTrackingData,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

typedef VOID (FASTCALL *PFN_VERIFY_IRP_STACK_DOWNWARD)(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    );

typedef VOID (FASTCALL *PFN_VERIFY_IRP_STACK_UPWARD)(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    );

typedef BOOLEAN (FASTCALL *PFN_IS_SYSTEM_RESTRICTED_IRP)(
    IN PIO_STACK_LOCATION IrpSp
    );

typedef BOOLEAN (FASTCALL *PFN_ADVANCE_IRP_STATUS)(
    IN     PIO_STACK_LOCATION   IrpSp,
    IN     NTSTATUS             OriginalStatus,
    IN OUT NTSTATUS             *StatusToAdvance
    );

typedef BOOLEAN (FASTCALL *PFN_IS_VALID_IRP_STATUS)(
    IN PIO_STACK_LOCATION   IrpSp,
    IN NTSTATUS             Status
    );

typedef BOOLEAN (FASTCALL *PFN_IS_NEW_REQUEST)(
    IN PIO_STACK_LOCATION   IrpLastSp OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp
    );

typedef VOID (FASTCALL *PFN_VERIFY_NEW_IRP)(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

typedef VOID (FASTCALL *PFN_VERIFY_FINAL_IRP_STACK)(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp
    );

typedef VOID (FASTCALL *PFN_TEST_STARTED_PDO_STACK)(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );

typedef LOGICAL (FASTCALL *PFN_BUILD_LOG_ENTRY)(
    IN  PIRP                Irp,
    IN  ULONG               CurrentCount,
    IN  PIRPLOG_SNAPSHOT    CurrentEntryArray,
    OUT PIRPLOG_SNAPSHOT    IrpSnapshot
    );

VOID
VfMajorInit(
    VOID
    );

VOID
FASTCALL
VfMajorRegisterHandlers(
    IN  UCHAR                           IrpMajorCode,
    IN  PFN_DUMP_IRP_STACK              DumpIrpStack            OPTIONAL,
    IN  PFN_VERIFY_NEW_REQUEST          VerifyNewRequest        OPTIONAL,
    IN  PFN_VERIFY_IRP_STACK_DOWNWARD   VerifyStackDownward     OPTIONAL,
    IN  PFN_VERIFY_IRP_STACK_UPWARD     VerifyStackUpward       OPTIONAL,
    IN  PFN_IS_SYSTEM_RESTRICTED_IRP    IsSystemRestrictedIrp   OPTIONAL,
    IN  PFN_ADVANCE_IRP_STATUS          AdvanceIrpStatus        OPTIONAL,
    IN  PFN_IS_VALID_IRP_STATUS         IsValidIrpStatus        OPTIONAL,
    IN  PFN_IS_NEW_REQUEST              IsNewRequest            OPTIONAL,
    IN  PFN_VERIFY_NEW_IRP              VerifyNewIrp            OPTIONAL,
    IN  PFN_VERIFY_FINAL_IRP_STACK      VerifyFinalIrpStack     OPTIONAL,
    IN  PFN_TEST_STARTED_PDO_STACK      TestStartedPdoStack     OPTIONAL,
    IN  PFN_BUILD_LOG_ENTRY             BuildIrpLogEntry        OPTIONAL
    );

VOID
FASTCALL
VfMajorDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
FASTCALL
VfMajorVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
VfMajorVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
VfMajorVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    );

BOOLEAN
FASTCALL
VfMajorIsSystemRestrictedIrp(
    IN PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
FASTCALL
VfMajorAdvanceIrpStatus(
    IN     PIO_STACK_LOCATION   IrpSp,
    IN     NTSTATUS             OriginalStatus,
    IN OUT NTSTATUS             *StatusToAdvance
    );

BOOLEAN
FASTCALL
VfMajorIsValidIrpStatus(
    IN PIO_STACK_LOCATION   IrpSp,
    IN NTSTATUS             Status
    );

BOOLEAN
FASTCALL
VfMajorIsNewRequest(
    IN PIO_STACK_LOCATION   IrpLastSp OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp
    );

VOID
FASTCALL
VfMajorVerifyNewIrp(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
VfMajorVerifyFinalIrpStack(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp
    );

VOID
FASTCALL
VfMajorTestStartedPdoStack(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );

LOGICAL
FASTCALL
VfMajorBuildIrpLogEntry(
    IN  PIRP                Irp,
    IN  ULONG               CurrentCount,
    IN  PIRPLOG_SNAPSHOT    CurrentEntryArray,
    OUT PIRPLOG_SNAPSHOT    IrpSnapshot
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfmajor.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfmajor.c

Abstract:

    This module routes calls for per-major and generic Irp verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

     AdriaO      06/15/2000 - Seperated out from ntos\io\flunkirp.c

--*/

#include "vfdef.h"
#include "vimajor.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,     VfMajorInit)
#pragma alloc_text(PAGEVRFY, VfMajorRegisterHandlers)
#pragma alloc_text(PAGEVRFY, VfMajorDumpIrpStack)
#pragma alloc_text(PAGEVRFY, VfMajorVerifyNewRequest)
#pragma alloc_text(PAGEVRFY, VfMajorVerifyIrpStackDownward)
#pragma alloc_text(PAGEVRFY, VfMajorVerifyIrpStackUpward)
#pragma alloc_text(PAGEVRFY, VfMajorIsSystemRestrictedIrp)
#pragma alloc_text(PAGEVRFY, VfMajorAdvanceIrpStatus)
#pragma alloc_text(PAGEVRFY, VfMajorIsValidIrpStatus)
#pragma alloc_text(PAGEVRFY, VfMajorIsNewRequest)
#pragma alloc_text(PAGEVRFY, VfMajorVerifyNewIrp)
#pragma alloc_text(PAGEVRFY, VfMajorVerifyFinalIrpStack)
#pragma alloc_text(PAGEVRFY, VfMajorTestStartedPdoStack)
#pragma alloc_text(PAGEVRFY, VfMajorBuildIrpLogEntry)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEVRFD")
#endif

//
// We have two extra slots, one for "all majors" and one permanently full of
// zeroes.
//
IRP_MAJOR_VERIFIER_ROUTINES ViMajorVerifierRoutines[IRP_MJ_MAXIMUM_FUNCTION + 3];

#define GET_MAJOR_ROUTINES(Major) \
    (ViMajorVerifierRoutines + \
    ((Major <= IRP_MJ_MAXIMUM_FUNCTION) ? Major : \
    ((Major == IRP_MJ_ALL_MAJORS) ? (IRP_MJ_MAXIMUM_FUNCTION + 1) : \
                                    (IRP_MJ_MAXIMUM_FUNCTION + 2))))

VOID
VfMajorInit(
    VOID
    )
{
    //
    // Set every pointer to NULL.
    //
    RtlZeroMemory(ViMajorVerifierRoutines, sizeof(ViMajorVerifierRoutines));
}


VOID
FASTCALL
VfMajorRegisterHandlers(
    IN  UCHAR                           IrpMajorCode,
    IN  PFN_DUMP_IRP_STACK              DumpIrpStack            OPTIONAL,
    IN  PFN_VERIFY_NEW_REQUEST          VerifyNewRequest        OPTIONAL,
    IN  PFN_VERIFY_IRP_STACK_DOWNWARD   VerifyStackDownward     OPTIONAL,
    IN  PFN_VERIFY_IRP_STACK_UPWARD     VerifyStackUpward       OPTIONAL,
    IN  PFN_IS_SYSTEM_RESTRICTED_IRP    IsSystemRestrictedIrp   OPTIONAL,
    IN  PFN_ADVANCE_IRP_STATUS          AdvanceIrpStatus        OPTIONAL,
    IN  PFN_IS_VALID_IRP_STATUS         IsValidIrpStatus        OPTIONAL,
    IN  PFN_IS_NEW_REQUEST              IsNewRequest            OPTIONAL,
    IN  PFN_VERIFY_NEW_IRP              VerifyNewIrp            OPTIONAL,
    IN  PFN_VERIFY_FINAL_IRP_STACK      VerifyFinalIrpStack     OPTIONAL,
    IN  PFN_TEST_STARTED_PDO_STACK      TestStartedPdoStack     OPTIONAL,
    IN  PFN_BUILD_LOG_ENTRY             BuildIrpLogEntry        OPTIONAL
    )
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;

    //
    // Ensure only legal major codes are passed in.
    //
    if ((IrpMajorCode != IRP_MJ_ALL_MAJORS) &&
        (IrpMajorCode > IRP_MJ_MAXIMUM_FUNCTION)) {

        return;
    }

    verifierRoutines = GET_MAJOR_ROUTINES(IrpMajorCode);

    verifierRoutines->VerifyNewRequest = VerifyNewRequest;
    verifierRoutines->VerifyStackDownward = VerifyStackDownward;
    verifierRoutines->VerifyStackUpward = VerifyStackUpward;
    verifierRoutines->DumpIrpStack = DumpIrpStack;
    verifierRoutines->IsSystemRestrictedIrp = IsSystemRestrictedIrp;
    verifierRoutines->AdvanceIrpStatus = AdvanceIrpStatus;
    verifierRoutines->IsValidIrpStatus = IsValidIrpStatus;
    verifierRoutines->IsNewRequest = IsNewRequest;
    verifierRoutines->VerifyNewIrp = VerifyNewIrp;
    verifierRoutines->VerifyFinalIrpStack = VerifyFinalIrpStack;
    verifierRoutines->TestStartedPdoStack = TestStartedPdoStack;
    verifierRoutines->BuildIrpLogEntry = BuildIrpLogEntry;
}


VOID
FASTCALL
VfMajorDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    )
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;

    verifierRoutines = GET_MAJOR_ROUTINES(IrpSp->MajorFunction);

    //
    // First try to get a specific routine, else try a generic one. We never
    // call both for the purposes of printing.
    //
    if (verifierRoutines->DumpIrpStack == NULL) {

        verifierRoutines = GET_MAJOR_ROUTINES(IRP_MJ_ALL_MAJORS);

        if (verifierRoutines->DumpIrpStack == NULL) {

            return;
        }
    }

    verifierRoutines->DumpIrpStack(IrpSp);
}


VOID
FASTCALL
VfMajorVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    )
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;

    //
    // Perform major specific checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IrpSp->MajorFunction);

    if (verifierRoutines->VerifyNewRequest) {

        verifierRoutines->VerifyNewRequest(
            IovPacket,
            DeviceObject,
            IrpLastSp,
            IrpSp,
            StackLocationData,
            CallerAddress
            );
    }

    //
    // Perform generic checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IRP_MJ_ALL_MAJORS);

    if (verifierRoutines->VerifyNewRequest) {

        verifierRoutines->VerifyNewRequest(
            IovPacket,
            DeviceObject,
            IrpLastSp,
            IrpSp,
            StackLocationData,
            CallerAddress
            );
    }
}


VOID
FASTCALL
VfMajorVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    )
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;

    //
    // Perform major specific checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IrpSp->MajorFunction);

    if (verifierRoutines->VerifyStackDownward) {

        verifierRoutines->VerifyStackDownward(
            IovPacket,
            DeviceObject,
            IrpLastSp,
            IrpSp,
            StackLocationData->RequestsFirstStackLocation,
            StackLocationData,
            CallerAddress
            );
    }

    //
    // Perform generic checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IRP_MJ_ALL_MAJORS);

    if (verifierRoutines->VerifyStackDownward) {

        verifierRoutines->VerifyStackDownward(
            IovPacket,
            DeviceObject,
            IrpLastSp,
            IrpSp,
            StackLocationData->RequestsFirstStackLocation,
            StackLocationData,
            CallerAddress
            );
    }
}


VOID
FASTCALL
VfMajorVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    )
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;

    //
    // Perform major specific checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IrpSp->MajorFunction);

    if (verifierRoutines->VerifyStackUpward) {

        verifierRoutines->VerifyStackUpward(
            IovPacket,
            IrpSp,
            StackLocationData->RequestsFirstStackLocation,
            StackLocationData,
            IsNewlyCompleted,
            RequestFinalized
            );
    }

    //
    // Perform generic checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IRP_MJ_ALL_MAJORS);

    if (verifierRoutines->VerifyStackUpward) {

        verifierRoutines->VerifyStackUpward(
            IovPacket,
            IrpSp,
            StackLocationData->RequestsFirstStackLocation,
            StackLocationData,
            IsNewlyCompleted,
            RequestFinalized
            );
    }
}


BOOLEAN
FASTCALL
VfMajorIsSystemRestrictedIrp(
    IN PIO_STACK_LOCATION IrpSp
    )
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;

    //
    // Perform major specific checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IrpSp->MajorFunction);

    if (verifierRoutines->IsSystemRestrictedIrp) {

        if (verifierRoutines->IsSystemRestrictedIrp(IrpSp)) {

            return TRUE;
        }
    }

    //
    // Perform generic checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IRP_MJ_ALL_MAJORS);

    if (verifierRoutines->IsSystemRestrictedIrp) {

        return verifierRoutines->IsSystemRestrictedIrp(IrpSp);
    }

    return FALSE;
}


BOOLEAN
FASTCALL
VfMajorAdvanceIrpStatus(
    IN     PIO_STACK_LOCATION   IrpSp,
    IN     NTSTATUS             OriginalStatus,
    IN OUT NTSTATUS             *StatusToAdvance
    )
/*++

  Description:

     Given an IRP stack pointer, is it legal to change the status for
     debug-ability? If so, this function determines what the new status
     should be. Note that for each stack location, this function is iterated
     over n times where n is equal to the number of drivers who IoSkip'd this
     location.

  Arguments:

     IrpSp           - Current stack right after complete for the given stack
                       location, but before the completion routine for the
                       stack location above has been called.

     OriginalStatus  - The status of the IRP at the time listed above. Does
                       not change over iteration per skipping driver.

     StatusToAdvance - Pointer to the current status that should be updated.

  Return Value:

     TRUE if the status has been adjusted, FALSE otherwise (in this case
         StatusToAdvance is untouched).

--*/
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;

    //
    // Perform major specific checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IrpSp->MajorFunction);

    if (verifierRoutines->AdvanceIrpStatus) {

        if (verifierRoutines->AdvanceIrpStatus(
            IrpSp,
            OriginalStatus,
            StatusToAdvance
            )) {

            return TRUE;
        }
    }

    //
    // Perform generic checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IRP_MJ_ALL_MAJORS);

    if (verifierRoutines->AdvanceIrpStatus) {

        return verifierRoutines->AdvanceIrpStatus(
            IrpSp,
            OriginalStatus,
            StatusToAdvance
            );
    }

    return FALSE;
}


BOOLEAN
FASTCALL
VfMajorIsValidIrpStatus(
    IN PIO_STACK_LOCATION   IrpSp,
    IN NTSTATUS             Status
    )
/*++

  Description:

     As per the title, this function determines whether an IRP status is
     valid or probably random trash. See NTStatus.h for info on how status
     codes break down...

  Arguments:

     IrpSp           - Current stack location.

     Status          - Status code.

  Returns:

     TRUE iff IRP status looks to be valid. FALSE otherwise.

--*/
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;

    //
    // Perform major specific checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IrpSp->MajorFunction);

    if (verifierRoutines->IsValidIrpStatus) {

        if (!verifierRoutines->IsValidIrpStatus(IrpSp, Status)) {

            return FALSE;
        }
    }

    //
    // Perform generic checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IRP_MJ_ALL_MAJORS);

    if (verifierRoutines->IsValidIrpStatus) {

        return verifierRoutines->IsValidIrpStatus(IrpSp, Status);
    }

    return FALSE;
}


BOOLEAN
FASTCALL
VfMajorIsNewRequest(
    IN PIO_STACK_LOCATION   IrpLastSp OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp
    )
/*++

  Description:

     Determines whether the two Irp stacks refer to the same "request",
     ie starting the same device, etc. This is used to detect whether an IRP
     has been simply forwarded or rather the IRP has been reused to initiate
     a new request.

  Arguments:

     The two IRP stacks to compare.

     N.B. - the device object is not currently part of those IRP stacks.

  Return Value:

     TRUE if the stacks represent the same request, FALSE otherwise.

--*/
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;

    //
    // Perform major specific checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IrpSp->MajorFunction);

    if (verifierRoutines->IsNewRequest) {

        if (verifierRoutines->IsNewRequest(IrpLastSp, IrpSp)) {

            return TRUE;
        }
    }

    //
    // Perform generic checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IRP_MJ_ALL_MAJORS);

    if (verifierRoutines->IsNewRequest) {

        return verifierRoutines->IsNewRequest(IrpLastSp, IrpSp);
    }

    return FALSE;
}


VOID
FASTCALL
VfMajorVerifyNewIrp(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    )
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;

    //
    // Perform major specific checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IrpSp->MajorFunction);

    if (verifierRoutines->VerifyNewIrp) {

        verifierRoutines->VerifyNewIrp(
            IovPacket,
            Irp,
            IrpSp,
            StackLocationData,
            CallerAddress
            );
    }

    //
    // Perform generic checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IRP_MJ_ALL_MAJORS);

    if (verifierRoutines->VerifyNewIrp) {

        verifierRoutines->VerifyNewIrp(
            IovPacket,
            Irp,
            IrpSp,
            StackLocationData,
            CallerAddress
            );
    }
}


VOID
FASTCALL
VfMajorVerifyFinalIrpStack(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp
    )
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;

    //
    // Perform major specific checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IrpSp->MajorFunction);

    if (verifierRoutines->VerifyFinalIrpStack) {

        verifierRoutines->VerifyFinalIrpStack(IovPacket, IrpSp);
    }

    //
    // Perform generic checks
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IRP_MJ_ALL_MAJORS);

    if (verifierRoutines->VerifyFinalIrpStack) {

        verifierRoutines->VerifyFinalIrpStack(IovPacket, IrpSp);
    }
}


VOID
FASTCALL
VfMajorTestStartedPdoStack(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

    Description:
        As per the title, we are going to throw some IRPs at the stack to
        see if they are handled correctly.

    Returns:

        Nothing
--*/
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;
    ULONG index;

    if (!IovUtilIsVerifiedDeviceStack(PhysicalDeviceObject)) {

        return;
    }

    for(index=0; index <= IRP_MJ_MAXIMUM_FUNCTION; index++) {

        verifierRoutines = GET_MAJOR_ROUTINES(index);

        if (verifierRoutines->TestStartedPdoStack) {

            verifierRoutines->TestStartedPdoStack(PhysicalDeviceObject);
        }
    }

    verifierRoutines = GET_MAJOR_ROUTINES(IRP_MJ_ALL_MAJORS);

    if (verifierRoutines->TestStartedPdoStack) {

        verifierRoutines->TestStartedPdoStack(PhysicalDeviceObject);
    }
}


LOGICAL
FASTCALL
VfMajorBuildIrpLogEntry(
    IN  PIRP                Irp,
    IN  ULONG               CurrentCount,
    IN  PIRPLOG_SNAPSHOT    CurrentEntryArray,
    OUT PIRPLOG_SNAPSHOT    IrpSnapshot
    )
{
    PIRP_MAJOR_VERIFIER_ROUTINES verifierRoutines;
    LOGICAL logEntry;
    ULONG index;

    logEntry = FALSE;

    //
    // Let the generic routines try to log the entry
    //
    verifierRoutines = GET_MAJOR_ROUTINES(IRP_MJ_ALL_MAJORS);

    if (verifierRoutines->BuildIrpLogEntry) {

        logEntry |= verifierRoutines->BuildIrpLogEntry( Irp,
                                                        CurrentCount,
                                                        CurrentEntryArray,
                                                        IrpSnapshot );
    }

    //
    // The major-specific routines can override the answer of the
    // major-specific routines.
    //
    index = IoGetNextIrpStackLocation(Irp)->MajorFunction;
    verifierRoutines = GET_MAJOR_ROUTINES(index);

    if (verifierRoutines->BuildIrpLogEntry) {

        logEntry = verifierRoutines->BuildIrpLogEntry( Irp,
                                                       CurrentCount,
                                                       CurrentEntryArray,
                                                       IrpSnapshot );
    }

    return logEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfpacket.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfpacket.h

Abstract:

    This header exposes functions used to manage the verifier packet data that
    tracks IRPs.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      05/02/2000 - Seperated out from ntos\io\hashirp.h

--*/


//
// Currently, ntddk.h uses up to 0x2000 for Irp->Flags
//
#define IRPFLAG_EXAMINE_MASK           0xC0000000
#define IRPFLAG_EXAMINE_NOT_TRACKED    0x80000000
#define IRPFLAG_EXAMINE_TRACKED        0x40000000
#define IRPFLAG_EXAMINE_UNMARKED       0x00000000

#define TRACKFLAG_ACTIVE            0x00000001
#define IRP_ALLOC_COUNT             8

#define IRP_LOG_ENTRIES             16

typedef enum {

    IOV_EVENT_NONE = 0,
    IOV_EVENT_IO_ALLOCATE_IRP,
    IOV_EVENT_IO_CALL_DRIVER,
    IOV_EVENT_IO_CALL_DRIVER_UNWIND,
    IOV_EVENT_IO_COMPLETE_REQUEST,
    IOV_EVENT_IO_COMPLETION_ROUTINE,
    IOV_EVENT_IO_COMPLETION_ROUTINE_UNWIND,
    IOV_EVENT_IO_CANCEL_IRP,
    IOV_EVENT_IO_FREE_IRP

} IOV_LOG_EVENT;

typedef struct {

    IOV_LOG_EVENT   Event;
    PETHREAD        Thread;
    PVOID           Address;
    ULONG_PTR       Data;
    LARGE_INTEGER   TimeStamp;

} IOV_LOG_ENTRY, *PIOV_LOG_ENTRY;

struct _IOV_SESSION_DATA;
struct _IOV_REQUEST_PACKET;

typedef struct _IOV_SESSION_DATA    *PIOV_SESSION_DATA;
typedef struct _IOV_REQUEST_PACKET  *PIOV_REQUEST_PACKET;

typedef struct _IOV_REQUEST_PACKET {

    IOV_DATABASE_HEADER;
    ULONG                       Flags;
    KIRQL                       DepartureIrql;  // Irql IRP will be dispatched at.
    KIRQL                       ArrivalIrql;    // Irql IRP was sent in at.
    LIST_ENTRY                  SessionHead;    // List of all sessions.
    CCHAR                       StackCount;     // StackCount of tracked IRP.
    ULONG                       QuotaCharge;    // Quota charged against IRP.
    PEPROCESS                   QuotaProcess;   // Process quota was charged to.

    PIO_COMPLETION_ROUTINE      RealIrpCompletionRoutine;
    UCHAR                       RealIrpControl;
    PVOID                       RealIrpContext;
    PVOID                       AllocatorStack[IRP_ALLOC_COUNT];

    //
    // The following information is for the assertion routines to read.
    //
    UCHAR                       TopStackLocation;

    CCHAR                       PriorityBoost;  // Boost from IofCompleteRequest
    UCHAR                       LastLocation;   // Last location from IofCallDriver
    ULONG                       RefTrackingCount;

    //
    // This field is only set on surrogate IRPs, and contains the locked system
    // VA for the destination of a direct I/O IRP that's being buffered.
    //
    PUCHAR                      SystemDestVA;

#if DBG
    IOV_LOG_ENTRY               LogEntries[IRP_LOG_ENTRIES];
    ULONG                       LogEntryHead;
    ULONG                       LogEntryTail;
#endif

    PVERIFIER_SETTINGS_SNAPSHOT VerifierSettings;
    PIOV_SESSION_DATA           pIovSessionData;

} IOV_REQUEST_PACKET;

PIOV_REQUEST_PACKET
FASTCALL
VfPacketCreateAndLock(
    IN  PIRP    Irp
    );

PIOV_REQUEST_PACKET
FASTCALL
VfPacketFindAndLock(
    IN  PIRP    Irp
    );

VOID
FASTCALL
VfPacketAcquireLock(
    IN  PIOV_REQUEST_PACKET   IrpTrackingData
    );

VOID
FASTCALL
VfPacketReleaseLock(
    IN  PIOV_REQUEST_PACKET   IrpTrackingData
    );

VOID
FASTCALL
VfPacketReference(
    IN  PIOV_REQUEST_PACKET IovPacket,
    IN  IOV_REFERENCE_TYPE  IovRefType
    );

VOID
FASTCALL
VfPacketDereference(
    IN  PIOV_REQUEST_PACKET IovPacket,
    IN  IOV_REFERENCE_TYPE  IovRefType
    );

PIOV_SESSION_DATA
FASTCALL
VfPacketGetCurrentSessionData(
    IN PIOV_REQUEST_PACKET IovPacket
    );

VOID
FASTCALL
VfPacketLogEntry(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN IOV_LOG_EVENT        IovLogEvent,
    IN PVOID                Address,
    IN ULONG_PTR            Data
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfmessage.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfmessage.c

Abstract:

    This module contains the verifier error lists, along with the text and flags
    associated with each error.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\ioassert.c

--*/

#include "vfdef.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, VfMessageRetrieveInternalTable)
#pragma alloc_text(PAGEVRFY, VfMessageRetrieveErrorData)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGEVRFC")
#endif

//
// These are the general "classifications" of driver errors, along with the
// default flags that will be applied the first time this is hit.
//
// ViMessageClassFailDriverInField -
//     Bugs in this class are severe enough that the driver should be
//     immediately removed from a running production machine.
//
// ViMessageClassFailDriverLogo -
//     Bugs of this class are severe enough for WHQL to deny a logo for the
//     failing whateverware.
//
// ViMessageClassFailDriverUnderDebugger -
//     Bugs of this class stop the machine only if it is running under a
//     kernel debugger.
//
// ViMessageClassDriverWarning -
//     Anything in this class will beep but continue without breaking in.
//
// ViMessageClassPostponedDriverIssue -
//     Anything in this class will merely print and continue.
//
// ViMessageClassCoreError -
//     Issue in a core component (kernel or hal)
//
const VFMESSAGE_CLASS ViMessageClassFailDriverInField = {
    VFM_FLAG_BEEP | VFM_LOGO_FAILURE | VFM_DEPLOYMENT_FAILURE,
    "WDM DRIVER ERROR"
    };

// VFM_DEPLOYMENT_FAILURE is set here because we don't yet have a "logo" mode
const VFMESSAGE_CLASS ViMessageClassFailDriverLogo = {
    VFM_FLAG_BEEP | VFM_LOGO_FAILURE | VFM_DEPLOYMENT_FAILURE,
    "WDM DRIVER ERROR"
    };

const VFMESSAGE_CLASS ViMessageClassFailDriverUnderDebugger = {
    VFM_FLAG_BEEP,
    "WDM DRIVER ERROR"
    };

const VFMESSAGE_CLASS ViMessageClassDriverWarning = {
    VFM_FLAG_BEEP | VFM_FLAG_ZAPPED,
    "WDM DRIVER WARNING"
    };

const VFMESSAGE_CLASS ViMessageClassPostponedDriverIssue = {
    VFM_FLAG_ZAPPED,
    "POSTPONED WDM DRIVER BUG"
    };

const VFMESSAGE_CLASS ViMessageClassCoreError = {
    VFM_FLAG_BEEP,
    "CORE DRIVER ERROR"
    };

//
// This table contains things we've postponed.
//
const VFMESSAGE_OVERRIDE ViMessageIoVerifierOverrides[] = {

    //
    // These exist because verifier.exe cannot specify kernels or hals. We still
    // want a mechanism to allow complaints.
    //
    { VIMESSAGE_ALL_IDS, "HAL.DLL",      &ViMessageClassCoreError },
    { VIMESSAGE_ALL_IDS, "NTOSKRNL.EXE", &ViMessageClassCoreError },
    { VIMESSAGE_ALL_IDS, "NTKRNLMP.EXE", &ViMessageClassCoreError },
    { VIMESSAGE_ALL_IDS, "NTKRNLPA.EXE", &ViMessageClassCoreError },
    { VIMESSAGE_ALL_IDS, "NTKRPAMP.EXE", &ViMessageClassCoreError },

    //
    // ADRIAO BUGBUG 10/04/2001 -
    //     Both the driver bugs have been fixed for quite some time, but these
    // entries were accidentally left in for XP. Both entries will be removed
    // on the first non-service pack build following XP.
    //
    { DCERROR_SUCCESSFUL_POWER_IRP_NOT_FORWARDED, "NDIS.SYS",
      &ViMessageClassPostponedDriverIssue },

    //
    // ADRIAO BUGBUG 08/10/1999 -
    //     ACPI and PCI have to work together to handle wait-wake. In the
    // current design, ACPI.SYS gets an interface and does all the work itself.
    // The proper design should move the queueing to PCI, or tell PCI to leave
    // wait-wake IRPs alone for the given device. Cutting off any other bus
    // filters is a bad design.
    //
    { DCERROR_SUCCESSFUL_POWER_IRP_NOT_FORWARDED, "ACPI.SYS",
      &ViMessageClassPostponedDriverIssue },

    //
    // JAMESCA BUGBUG 09/16/2001 -
    //     SWENUM incorrectly detaches its FDO from the stack prior to sending
    // the remove IRP down the stack.  Because of the interesting and complex
    // relationship between SWENUM.SYS and the KS.SYS service routines that it
    // calls, the fix requires rearchitecture of these two drivers, and has
    // been postponed.
    //
    { DCERROR_BUS_FILTER_ERRONEOUSLY_DETACHED, "SWENUM.SYS",
      &ViMessageClassPostponedDriverIssue },
    { DCERROR_SHOULDVE_DELETED,                "SWENUM.SYS",
      &ViMessageClassPostponedDriverIssue }
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEVRFD")
#endif

//
// This message is used if someone provides bad data for a verifier assert. The
// message Id is VIMESSAGE_ALL_IDS - a nice reserved Id that'll match with
// nothing except possibly a generic class override.
//
VFMESSAGE_TEMPLATE ViMessageBogusTemplate = { VIMESSAGE_ALL_IDS, NULL, 0, NULL, NULL };

//
// Here begins internal verifier error tables. The current algorithm for
// identifying errors expects all messages in a table to be numbered
// consecutively. If a check is later removed the algorithm may need to be
// replaced with something akin to a binary search.
//

//
// This is the table of IO verifier error messages.
//
VFMESSAGE_TEMPLATE ViMessageIoVerifierTemplates[DCERROR_MAXIMUM - DCERROR_UNSPECIFIED] = {

   { DCERROR_UNSPECIFIED, NULL, 0, NULL, NULL },
   { DCERROR_DELETE_WHILE_ATTACHED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A device is deleting itself while there is another device beneath it in "
     "the driver stack. This may be because the caller has forgotten to call "
     "IoDetachDevice first, or the lower driver may have incorrectly deleted "
     "itself." },
   { DCERROR_DETACH_NOT_ATTACHED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "Driver has attempted to detach from device object %DevObj, which is not "
     "attached to anything. This may occur if detach was called twice on the "
     "same device object." },
   { DCERROR_CANCELROUTINE_FORWARDED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has called IoCallDriver without setting the CancelRoutine in "
     "the Irp to NULL (Irp = %Irp )." },
   { DCERROR_NULL_DEVOBJ_FORWARDED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "Caller has passed in NULL as a DeviceObject. This is fatal (Irp = %Irp )."
     },
   { DCERROR_QUEUED_IRP_FORWARDED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "Caller is forwarding an IRP that is currently queued beneath it! The "
     "code handling IRPs returning STATUS_PENDING in this driver appears to "
     "be broken (Irp = %Irp )." },
   { DCERROR_NEXTIRPSP_DIRTY, &ViMessageClassFailDriverInField, 0,
     NULL,
     "Caller has incorrectly forwarded an IRP (control field not zerod). The "
     "driver should use IoCopyCurrentIrpStackLocationToNext or "
     "IoSkipCurrentIrpStackLocation. (Irp = %Irp )" },
   { DCERROR_IRPSP_COPIED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "Caller has manually copied the stack and has inadvertantly copied the "
     "upper layer's completion routine. Please use "
     "IoCopyCurrentIrpStackLocationToNext. (Irp = %Irp )." },
   { DCERROR_INSUFFICIENT_STACK_LOCATIONS, &ViMessageClassFailDriverInField, 0,
     NULL,
     "This IRP is about to run out of stack locations. Someone may have "
     "forwarded this IRP from another stack (Irp = %Irp )." },
   { DCERROR_QUEUED_IRP_COMPLETED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "Caller is completing an IRP that is currently queued beneath it! The "
     "code handling IRPs returning STATUS_PENDING in this driver appears to be "
     "broken. (Irp = %Irp )" },
   { DCERROR_FREE_OF_INUSE_TRACKED_IRP, &ViMessageClassFailDriverInField, 0,
     NULL,
     "Caller of IoFreeIrp is freeing an IRP that is still in use! (Original "
     "Irp = %Irp1, Irp in usage is %Irp2 )" },
   { DCERROR_FREE_OF_INUSE_IRP, &ViMessageClassFailDriverInField, 0,
     NULL,
     "Caller of IoFreeIrp is freeing an IRP that is still in use! (Irp = %Irp )"
     },
   { DCERROR_FREE_OF_THREADED_IRP, &ViMessageClassFailDriverInField, 0,
     NULL,
     "Caller of IoFreeIrp is freeing an IRP that is still enqueued against a "
     "thread! (Irp = %Irp )" },
   { DCERROR_REINIT_OF_ALLOCATED_IRP_WITH_QUOTA, &ViMessageClassFailDriverInField, 0,
     NULL,
     "Caller of IoInitializeIrp has passed an IRP that was allocated with "
     "IoAllocateIrp. This is illegal and unneccessary, and has caused a quota "
     "leak. Check the documentation for IoReuseIrp if this IRP is being "
     "recycled." },
   { DCERROR_PNP_IRP_BAD_INITIAL_STATUS, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Any PNP IRP must have status initialized to STATUS_NOT_SUPPORTED "
     "(Irp = %Irp )." },
   { DCERROR_POWER_IRP_BAD_INITIAL_STATUS, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Any Power IRP must have status initialized to STATUS_NOT_SUPPORTED "
     "(Irp = %Irp )." },
   { DCERROR_WMI_IRP_BAD_INITIAL_STATUS, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Any WMI IRP must have status initialized to STATUS_NOT_SUPPORTED "
     "(Irp = %Irp )." },
   { DCERROR_SKIPPED_DEVICE_OBJECT, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Caller has forwarded an Irp while skipping a device object in the stack. "
     "The caller is probably sending IRPs to the PDO instead of to the device "
     "returned by IoAttachDeviceToDeviceStack (Irp = %Irp )." },
   { DCERROR_BOGUS_FUNC_TRASHED, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Caller has trashed or has not properly copied IRP's stack (Irp = %Irp )."
     },
   { DCERROR_BOGUS_STATUS_TRASHED, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Caller has changed the status field of an IRP it does not understand "
     "(Irp = %Irp )." },
   { DCERROR_BOGUS_INFO_TRASHED, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Caller has changed the information field of an IRP it does not "
     "understand (Irp = %Irp )." },
   { DCERROR_PNP_FAILURE_FORWARDED, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Non-successful non-STATUS_NOT_SUPPORTED IRP status for IRP_MJ_PNP is "
     "being passed down stack (Irp = %Irp ). Failed PNP IRPs must be completed."
     },
   { DCERROR_PNP_IRP_STATUS_RESET, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Previously set IRP_MJ_PNP status has been converted to "
     "STATUS_NOT_SUPPORTED. This failure status is reserved for use of the OS "
     "- drivers cannot fail a PnP IRP with this value. (Irp = %Irp )." },
   { DCERROR_PNP_IRP_NEEDS_HANDLING, &ViMessageClassFailDriverUnderDebugger, 0,
     NULL,
     "The driver has not handled a required IRP. The driver must update the "
     "status of the IRP to indicate whether it's been handled or not. "
     "(Irp = %Irp )." },
   { DCERROR_PNP_IRP_HANDS_OFF, &ViMessageClassFailDriverUnderDebugger, 0,
     NULL,
     "The driver has responded to an IRP that is that is reserved for other "
     "device objects elsewhere in the stack. (Irp = %Irp )" },
   { DCERROR_POWER_FAILURE_FORWARDED, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Non-successful non-STATUS_NOT_SUPPORTED IRP status for IRP_MJ_POWER is "
     "being passed down stack (Irp = %Irp ). Failed POWER IRPs must be "
     "completed." },
   { DCERROR_POWER_IRP_STATUS_RESET, &ViMessageClassFailDriverUnderDebugger, 0,
     NULL,
     "Previously set IRP_MJ_POWER status has been converted to "
     "STATUS_NOT_SUPPORTED. This failure status is reserved for use of the OS "
     "- drivers cannot fail a Power IRP with this value (Irp = %Irp )." },
   { DCERROR_INVALID_STATUS, &ViMessageClassFailDriverUnderDebugger, 0,
     NULL,
     "Driver has returned a suspicious status. This is probably due to an "
     "uninitiaized variable bug in the driver. (Irp = %Irp )" },
   { DCERROR_UNNECCESSARY_COPY, &ViMessageClassDriverWarning, 0,
     NULL,
     "Caller has copied the Irp stack but not set a completion routine. "
     "This is inefficient, use IoSkipCurrentIrpStackLocation instead "
     "(Irp = %Irp )." },
   { DCERROR_SHOULDVE_DETACHED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "An IRP dispatch handler has not properly detached from the stack below "
     "it upon receiving a remove IRP. DeviceObject = %DevObj - Dispatch = "
     "%Routine - Irp = %Snapshot" },
   { DCERROR_SHOULDVE_DELETED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "An IRP dispatch handler has not properly deleted it's device object upon "
     "receiving a remove IRP. DeviceObject = %DevObj - Dispatch = %Routine - "
     "Irp = %Snapshot" },
   { DCERROR_MISSING_DISPATCH_FUNCTION, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "This driver has not filled out a dispatch routine for a required IRP "
     "major function (Irp = %Irp )." },
   { DCERROR_WMI_IRP_NOT_FORWARDED, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "IRP_MJ_SYSTEM_CONTROL has been completed by someone other than the "
     "ProviderId. This IRP should either have been completed earlier or "
     "should have been passed down (Irp = %Irp ). The IRP was targetted at "
     "DeviceObject %DevObj" },
   { DCERROR_DELETED_PRESENT_PDO, &ViMessageClassFailDriverInField, 0,
     NULL,
     "An IRP dispatch handler for a PDO has deleted it's device object, but "
     "the hardware has not been reported as missing in a bus relations query. "
     "DeviceObject = %DevObj - Dispatch = %Routine - Irp = %Snapshot " },
   { DCERROR_BUS_FILTER_ERRONEOUSLY_DETACHED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A Bus Filter's IRP dispatch handler has detached upon receiving a remove "
     "IRP when the PDO is still alive. Bus Filters must clean up in "
     "FastIoDetach callbacks. DeviceObject = %DevObj - Dispatch = %Routine - "
     "Irp = %Snapshot" },
   { DCERROR_BUS_FILTER_ERRONEOUSLY_DELETED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "An IRP dispatch handler for a bus filter has deleted it's device object, "
     "but the PDO is still present! Bus filters must clean up in FastIoDetach "
     "callbacks. DeviceObject = %DevObj - Dispatch = %Routine - Irp = %Snapshot" },
   { DCERROR_INCONSISTANT_STATUS, &ViMessageClassFailDriverInField, 0,
     NULL,
     "An IRP dispatch handler ( %Routine ) has returned a status that is "
     "inconsistent with the Irp's IoStatus.Status field. ( Irp = %Snapshot - "
     "Irp->IoStatus.Status = %Status1 - returned = %Status2 )" },
   { DCERROR_UNINITIALIZED_STATUS, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "An IRP dispatch handler has returned a status that is illegal "
     "(0xFFFFFFFF). This is probably due to an uninitialized stack variable. "
     "Please do an ln on address %lx and file a bug. (Irp = %Snapshot )" },
   { DCERROR_IRP_RETURNED_WITHOUT_COMPLETION, &ViMessageClassFailDriverInField, 0,
     NULL,
     "An IRP dispatch handler has returned without passing down or completing "
     "this Irp or someone forgot to return STATUS_PENDING. (Irp = %Snapshot )." },
   { DCERROR_COMPLETION_ROUTINE_PAGABLE, &ViMessageClassFailDriverInField, 0,
     NULL,
     "IRP completion routines must be in nonpagable code, and this one is not: "
     "%Routine. (Irp = %Irp )" },
   { DCERROR_PENDING_BIT_NOT_MIGRATED, &ViMessageClassFailDriverUnderDebugger, 0,
     NULL,
     "A driver's completion routine ( %Routine ) has not marked the IRP "
     "pending if the PendingReturned field was set in the IRP passed to it. "
     "This may cause the OS to hang, especially if an error is returned by the "
     " stack. (Irp = %Irp )" },
   { DCERROR_CANCELROUTINE_ON_FORWARDED_IRP, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A cancel routine has been set for an IRP that is currently being "
     "processed by drivers lower in the stack, possibly stomping their cancel "
     "routine (Irp = %Irp, Routine=%Routine )." },
   { DCERROR_PNP_IRP_NEEDS_PDO_HANDLING, &ViMessageClassFailDriverUnderDebugger, 0,
     NULL,
     "PDO has not responded to a required IRP (Irp = %Irp )" },
   { DCERROR_TARGET_RELATION_LIST_EMPTY, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "PDO has forgotten to fill out the device relation list with the PDO for "
     "the TargetDeviceRelation query (Irp = %Irp )" },
   { DCERROR_TARGET_RELATION_NEEDS_REF, &ViMessageClassFailDriverInField, 0,
     NULL,
     "The code implementing the TargetDeviceRelation query has not called "
     "ObReferenceObject on the PDO (Irp = %Irp )." },
   { DCERROR_BOGUS_PNP_IRP_COMPLETED, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Caller has completed a IRP_MJ_PNP it didn't understand instead of "
     "passing it down (Irp = %Irp )." },
   { DCERROR_SUCCESSFUL_PNP_IRP_NOT_FORWARDED, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Caller has completed successful IRP_MJ_PNP instead of passing it down "
     "(Irp = %Irp )." },
   { DCERROR_UNTOUCHED_PNP_IRP_NOT_FORWARDED, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Caller has completed untouched IRP_MJ_PNP (instead of passing the irp "
     "down) or non-PDO has failed the irp using illegal value of "
     "STATUS_NOT_SUPPORTED. (Irp = %Irp )." },
   { DCERROR_BOGUS_POWER_IRP_COMPLETED, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Caller has completed a IRP_MJ_POWER it didn't understand instead of "
     "passing it down (Irp = %Irp )." },
   { DCERROR_SUCCESSFUL_POWER_IRP_NOT_FORWARDED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "Caller has completed successful IRP_MJ_POWER instead of passing it down "
     "(Irp = %Irp )." },
   { DCERROR_UNTOUCHED_POWER_IRP_NOT_FORWARDED, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Caller has completed untouched IRP_MJ_POWER (instead of passing the irp "
     "down) or non-PDO has failed the irp using illegal value of "
     "STATUS_NOT_SUPPORTED. (Irp = %Irp )." },
   { DCERROR_PNP_QUERY_CAP_BAD_VERSION, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "The version field of the query capabilities structure in a query "
     "capabilities IRP was not properly initialized. (Irp = %Irp )." },
   { DCERROR_PNP_QUERY_CAP_BAD_SIZE, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "The size field of the query capabilities structure in a query "
     "capabilities IRP was not properly initialized. (Irp = %Irp )." },
   { DCERROR_PNP_QUERY_CAP_BAD_ADDRESS, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "The address field of the query capabilities structure in a query "
     "capabilities IRP was not properly initialized to -1. (Irp = %Irp )." },
   { DCERROR_PNP_QUERY_CAP_BAD_UI_NUM, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "The UI Number field of the query capabilities structure in a query "
     "capabilities IRP was not properly initialized to -1. (Irp = %Irp )." },
   { DCERROR_RESTRICTED_IRP, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has sent an IRP that is restricted for system use only. "
     "(Irp = %Irp )." },
   { DCERROR_REINIT_OF_ALLOCATED_IRP_WITHOUT_QUOTA, &ViMessageClassDriverWarning, 0,
     NULL,
     "Caller of IoInitializeIrp has passed an IRP that was allocated with "
     "IoAllocateIrp. This is illegal, unneccessary, and negatively impacts "
     "performace in normal use. Check the documentation for IoReuseIrp if "
     "this IRP is being recycled." },
   { DCERROR_UNFORWARDED_IRP_COMPLETED, &ViMessageClassDriverWarning, 0,
     NULL,
     "The caller of IoCompleteRequest is completing an IRP that has never "
     "been forwarded via a call to IoCallDriver or PoCallDriver. This may "
     "be a bug. (Irp = %Irp )." },
   { DCERROR_DISPATCH_CALLED_AT_BAD_IRQL, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has forwarded an IRP at an IRQL that is illegal for this major"
     " code. "
     "(Irp = %Irp )." },
   { DCERROR_BOGUS_MINOR_STATUS_TRASHED, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "Caller has changed the status field of an IRP it does not understand "
     "(Irp = %Irp )." },
   { DCERROR_CANCELROUTINE_AFTER_COMPLETION, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has completed an IRP without setting the CancelRoutine in "
     "the Irp to NULL (Irp = %Irp )." },
   { DCERROR_PENDING_RETURNED_NOT_MARKED, &ViMessageClassFailDriverUnderDebugger, 0,
     NULL,
     "A driver has returned STATUS_PENDING but did not mark the IRP pending "
     "via a call to IoMarkIrpPending (Irp = %Irp)." },
   { DCERROR_PENDING_MARKED_NOT_RETURNED, &ViMessageClassFailDriverUnderDebugger, 0,
     NULL,
     "A driver has marked an IRP pending but didn't return STATUS_PENDING. "
     "(Irp = %Snapshot)." },
   { DCERROR_POWER_PAGABLE_NOT_INHERITED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has not inherited the DO_POWER_PAGABLE bit from the stack it "
     "has attached to (DevObj = %DevObj)." },
   { DCERROR_DOUBLE_DELETION, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver is attempting to delete a device object that has already been "
     "deleted via a prior call to IoDeleteDevice." },
   { DCERROR_DETACHED_IN_SURPRISE_REMOVAL, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has detached it's device object during a surprise remove IRP "
     "(Irp = %Irp  DevObj = %DevObj)." },
   { DCERROR_DELETED_IN_SURPRISE_REMOVAL, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has deleted it's device object during a surprise remove IRP "
     "(Irp = %Irp  DevObj = %DevObj)." },
   { DCERROR_DO_INITIALIZING_NOT_CLEARED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has failed to clear the DO_DEVICE_INITIALIZING flag at the "
     "end of AddDevice (DevObj = %DevObj)." },
   { DCERROR_DO_FLAG_NOT_COPIED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has not copied either the DO_BUFFERED_IO or the DO_DIRECT_IO "
     "flag from the device object it is attaching to (DevObj = %DevObj)." },
   { DCERROR_INCONSISTANT_DO_FLAGS, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has set both the DO_BUFFERED_IO and the DO_DIRECT_IO flags. "
     "These flags are mutually exclusive (DevObj = %DevObj)." },
   { DCERROR_DEVICE_TYPE_NOT_COPIED, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has failed to copy the DeviceType field from the device object "
     "it is attaching to (DevObj = %DevObj)." },
   { DCERROR_NON_FAILABLE_IRP, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has failed an IRP that cannot legally be failed IRP "
     "(Irp = %Irp)." },
   { DCERROR_NON_PDO_RETURNED_IN_RELATION, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has added a device object that is not a PDO to a device "
     "relations query (Irp = %Irp, DevObj = %DevObj)." },
   { DCERROR_DUPLICATE_ENUMERATION, &ViMessageClassFailDriverLogo, 0,
     NULL,
     "A driver has enumerated two child PDO's that returned identical Device "
     "ID's (DevObj1 = %DevObj1 , DevObj2 = %DevObj2 )." },
   { DCERROR_FILE_IO_AT_BAD_IRQL, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has mistakenly called a file I/O function at an IRQL other "
     "than PASSIVE_LEVEL." },
   { DCERROR_MISHANDLED_TARGET_DEVICE_RELATIONS, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has succeeded IRP_MJ_PNP.IRP_MN_QUERY_DEVICE_RELATIONS(TargetRelations) "
     "but didn't properly fill out the request or forward the IRP to the "
     "underlying hardware stack (DevObj = %DevObj)." },
   { DCERROR_PENDING_RETURNED_NOT_MARKED_2, &ViMessageClassFailDriverUnderDebugger, 0,
     NULL,
     "A driver has returned STATUS_PENDING but did not mark the IRP pending "
     "via a call to IoMarkIrpPending (Irp = %Snapshot)." },
   { DCERROR_DDI_REQUIRES_PDO, &ViMessageClassFailDriverInField, 0,
     NULL,
     "A driver has passed an invalid device object to a function that requires "
     "a PDO (DevObj = %DevObj)." }
};

//
// Here is the table collecting together all internal tables.
//
VFMESSAGE_TEMPLATE_TABLE ViMessageBuiltInTables[] = {

    { VFMESSAGE_TABLE_IOVERIFIER,
      DRIVER_VERIFIER_IOMANAGER_VIOLATION,
      ViMessageIoVerifierTemplates,
      ARRAY_COUNT(ViMessageIoVerifierTemplates),
      ViMessageIoVerifierOverrides,
      ARRAY_COUNT(ViMessageIoVerifierOverrides) }
};

VOID
VfMessageRetrieveInternalTable(
    IN  VFMESSAGE_TABLEID           TableID,
    OUT PVFMESSAGE_TEMPLATE_TABLE  *MessageTable
    )
/*++

Routine Description:

    This routine retrieves the appropriate error table using the passed in
    TableID.

Arguments:

    TableID             - Name of error table to use.

    MessageTable        - Receives Table, NULL if no match is found.

Return Value:

    None.

--*/
{
    PVFMESSAGE_TEMPLATE_TABLE   errorTable;
    ULONG                       i;

    //
    // Assert we have valid Table IDs (0 is reserved)
    //
    ASSERT(TableID);

    //
    // Preinit for error.
    //
    errorTable = NULL;

    //
    // Find the appropriate template by searching the built-in tables
    //
    for (i=0; i<ARRAY_COUNT(ViMessageBuiltInTables); i++) {

        if (ViMessageBuiltInTables[i].TableID == TableID) {

            //
            // We found the appropriate table. Get out now.
            //
            errorTable = &ViMessageBuiltInTables[i];
            break;
        }
    }

    *MessageTable = errorTable;
}


VOID
VfMessageRetrieveErrorData(
    IN  PVFMESSAGE_TEMPLATE_TABLE   MessageTable    OPTIONAL,
    IN  VFMESSAGE_ERRORID           MessageID,
    IN  PSTR                        AnsiDriverName,
    OUT ULONG                      *BugCheckMajor,
    OUT PCVFMESSAGE_CLASS          *MessageClass,
    OUT PCSTR                      *MessageTextTemplate,
    OUT PULONG                     *TemplateFlags
    )
/*++

Routine Description:

    This routine takes a failure ID and retrieves the text template and the
    error class associated with it.

Arguments:

    MessageTable        - Message table to use.

    MessageID           - Failure code (doubles as bugcheck minor).

    AnsiDriverName      - Name of the driver that failed verification.

    BugCheckMajor       - Receives bugcheck major code if applicable.

    MessageClass        - Receives a pointer to a VFMESSAGE_CLASS structure
                          that contains information on how to handle the error.

    MessageTextTemplate - Receives a pointer to the text associated with the
                          failure code.

    TemplateFlags       - Receives address of the assertion's control field,
                          which can be used to suppress the assertion.

Return Value:

    None.

--*/
{
    PVFMESSAGE_TEMPLATE         errorTemplate;
    ULONG                       tableIndex, i;

    //
    // Assert we have a valid Message ID (0 is reserved)
    //
    ASSERT(MessageID);

    //
    // Preinit for error.
    //
    errorTemplate = NULL;

    //
    // If we have an error table, look for the specific error message.
    //
    if (ARGUMENT_PRESENT(MessageTable)) {

        //
        // Convert the ID to a table index.
        //
        tableIndex = MessageID - MessageTable->TemplateArray[0].MessageID;

        //
        // Retrieve the appropriate entry if it exists.
        //
        if (tableIndex < MessageTable->TemplateCount) {

            errorTemplate = &MessageTable->TemplateArray[tableIndex];

            //
            // Our "algorithm" currently expects table numbers to be sequential.
            //
            ASSERT(errorTemplate->MessageID == MessageID);
        }
    }

    if (!errorTemplate) {

        //
        // Bogus message or table index!
        //
        ASSERT(0);

        //
        // Give the engine something to chew on.
        //
        errorTemplate = &ViMessageBogusTemplate;
    }

    //
    // Return the appropriate data.
    //
    *MessageTextTemplate = errorTemplate->MessageText;
    *MessageClass = errorTemplate->MessageClass;
    *TemplateFlags = &errorTemplate->Flags;

    if (ARGUMENT_PRESENT(MessageTable)) {

        *BugCheckMajor = MessageTable->BugCheckMajor;

        //
        // Let the override table make any modifications to the error.
        //
        for(i=0; i<MessageTable->OverrideCount; i++) {

            if ((MessageTable->OverrideArray[i].MessageID == MessageID) ||
                (MessageTable->OverrideArray[i].MessageID == VIMESSAGE_ALL_IDS)) {

                if (!_stricmp(AnsiDriverName,
                              MessageTable->OverrideArray[i].DriverName)) {

                    *MessageClass = MessageTable->OverrideArray[i].ReplacementClass;
                }
            }
        }

    } else {

        //
        // Bleagh.
        //
        *BugCheckMajor = 0;
    }
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfpnp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfpnp.h

Abstract:

    This header contains prototypes for verifying Pnp IRPs are handled
    correctly.

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      06/15/2000 - Seperated out from ntos\io\flunkirp.h

--*/

VOID
VfPnpInit(
    VOID
    );

VOID
FASTCALL
VfPnpVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
VfPnpVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    );

VOID
FASTCALL
VfPnpVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    );

VOID
FASTCALL
VfPnpDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
FASTCALL
VfPnpIsSystemRestrictedIrp(
    IN PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
FASTCALL
VfPnpAdvanceIrpStatus(
    IN     PIO_STACK_LOCATION   IrpSp,
    IN     NTSTATUS             OriginalStatus,
    IN OUT NTSTATUS             *StatusToAdvance
    );

VOID
FASTCALL
VfPnpTestStartedPdoStack(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfpacket.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfpacket.c

Abstract:

    This module contains functions used to manage the verifier packet data
    that tracks IRPs.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      05/02/2000 - Seperated out from ntos\io\hashirp.c

--*/

#include "vfdef.h"
#include "vfipacket.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, VfPacketCreateAndLock)
#pragma alloc_text(PAGEVRFY, VfPacketFindAndLock)
#pragma alloc_text(PAGEVRFY, VfPacketAcquireLock)
#pragma alloc_text(PAGEVRFY, VfPacketReleaseLock)
#pragma alloc_text(PAGEVRFY, VfPacketReference)
#pragma alloc_text(PAGEVRFY, VfPacketDereference)
#pragma alloc_text(PAGEVRFY, VfpPacketFree)
#pragma alloc_text(PAGEVRFY, VfpPacketNotificationCallback)
#pragma alloc_text(PAGEVRFY, VfPacketGetCurrentSessionData)
#pragma alloc_text(PAGEVRFY, VfPacketLogEntry)
#endif

#define POOL_TAG_TRACKING_DATA      'tprI'

PIOV_REQUEST_PACKET
FASTCALL
VfPacketCreateAndLock(
    IN  PIRP    Irp
    )
/*++

  Description:

    This routine creates a tracking packet for a new IRP. The IRP does not get
    an initial reference count however. VfPacketReleaseLock must be called to
    drop the lock.

  Arguments:

    Irp             - Irp to begin tracking.

  Return Value:

    iovPacket block, NULL if no memory.

--*/
{
    PIOV_REQUEST_PACKET iovPacket;
    ULONG allocSize;
    BOOLEAN successfullyInserted;

    allocSize = sizeof(IOV_REQUEST_PACKET) + VfSettingsGetSnapshotSize();

    iovPacket = ExAllocatePoolWithTag(
        NonPagedPool,
        allocSize,
        POOL_TAG_TRACKING_DATA
        );

    if (!iovPacket) {

        return NULL;
    }

    //
    // From top to bottom, initialize the fields. Note that there is not a
    // "surrogateHead". If any code needs to find out the first entry in the
    // circularly linked list of IRPs (the first is the only non-surrogate IRP),
    // then HeadPacket should be used. Note that the link to the session is
    // stored by the headPacket, more on this later.
    //
    iovPacket->Flags = 0;
    InitializeListHead(&iovPacket->SessionHead);
    iovPacket->StackCount = Irp->StackCount;
    iovPacket->RealIrpCompletionRoutine = NULL;
    iovPacket->RealIrpControl = 0;
    iovPacket->RealIrpContext = NULL;
    iovPacket->TopStackLocation = 0;
    iovPacket->PriorityBoost = 0;
    iovPacket->LastLocation = 0;
    iovPacket->RefTrackingCount = 0;
    iovPacket->VerifierSettings = (PVERIFIER_SETTINGS_SNAPSHOT) (iovPacket+1);
    iovPacket->pIovSessionData = NULL;
    iovPacket->QuotaCharge = 0;
    iovPacket->QuotaProcess = NULL;
    iovPacket->SystemDestVA = NULL;
#if DBG
    iovPacket->LogEntryHead = 0;
    iovPacket->LogEntryTail = 0;
    RtlZeroMemory(iovPacket->LogEntries, sizeof(IOV_LOG_ENTRY)*IRP_LOG_ENTRIES);
#endif

    VfSettingsCreateSnapshot(iovPacket->VerifierSettings);

    successfullyInserted = VfIrpDatabaseEntryInsertAndLock(
        Irp,
        VfpPacketNotificationCallback,
        (PIOV_DATABASE_HEADER) iovPacket
        );

    return successfullyInserted ? iovPacket : NULL;
}


PIOV_REQUEST_PACKET
FASTCALL
VfPacketFindAndLock(
    IN  PIRP    Irp
    )
/*++

  Description:

    This routine will return the tracking data for an IRP that is
    being tracked without a surrogate or the tracking data for with
    a surrogate if the surrogate IRP is what was passed in.

  Arguments:

    Irp                    - Irp to find.

  Return Value:

    IovPacket block, iff above conditions are satified.

--*/
{
    return (PIOV_REQUEST_PACKET) VfIrpDatabaseEntryFindAndLock(Irp);
}


VOID
FASTCALL
VfPacketAcquireLock(
    IN  PIOV_REQUEST_PACKET IovPacket   OPTIONAL
    )
/*++

  Description:

    This routine is called by to acquire the IRPs tracking data lock.

    Incoming IRQL must be the same as the callers (IoCallDriver, IoCompleteRequest)
    We may be at DPC level when we return. Callers *must* follow up with
    VfPacketReleaseLock.

  Arguments:

    IovPacket        - Pointer to the IRP tracking data (or NULL, in which
                       case this routine does nothing).

  Return Value:

     None.
--*/
{
    VfIrpDatabaseEntryAcquireLock((PIOV_DATABASE_HEADER) IovPacket);
}


VOID
FASTCALL
VfPacketReleaseLock(
    IN  PIOV_REQUEST_PACKET IovPacket
    )
/*++

  Description:

    This routine releases the IRPs tracking data lock and adjusts the ref count
    as appropriate. If the reference count drops to zero, the tracking data is
    freed.

  Arguments:

    IovPacket              - Pointer to the IRP tracking data.

  Return Value:

     None.

--*/
{
    VfIrpDatabaseEntryReleaseLock((PIOV_DATABASE_HEADER) IovPacket);
}


VOID
FASTCALL
VfPacketReference(
    IN PIOV_REQUEST_PACKET IovPacket,
    IN IOV_REFERENCE_TYPE  IovRefType
    )
{
    VfIrpDatabaseEntryReference((PIOV_DATABASE_HEADER) IovPacket, IovRefType);
}


VOID
FASTCALL
VfPacketDereference(
    IN PIOV_REQUEST_PACKET IovPacket,
    IN IOV_REFERENCE_TYPE  IovRefType
    )
{
    VfIrpDatabaseEntryDereference((PIOV_DATABASE_HEADER) IovPacket, IovRefType);
}


VOID
FASTCALL
VfpPacketFree(
    IN  PIOV_REQUEST_PACKET IovPacket
    )
/*++

  Description:

    This routine free's the tracking data. The tracking data should already
    have been removed from the table by a call to VfPacketReleaseLock with the
    ReferenceCount at 0.

  Arguments:

    IovPacket        - Tracking data to free.

  Return Value:

    Nope.

--*/
{
    ExFreePool(IovPacket);
}


VOID
VfpPacketNotificationCallback(
    IN  PIOV_DATABASE_HEADER    IovHeader,
    IN  PIRP                    TrackedIrp  OPTIONAL,
    IN  IRP_DATABASE_EVENT      Event
    )
{
    switch(Event) {

        case IRPDBEVENT_POINTER_COUNT_ZERO:

            TrackedIrp->Flags &= ~IRPFLAG_EXAMINE_MASK;
            break;

        case IRPDBEVENT_REFERENCE_COUNT_ZERO:

            ASSERT((((PIOV_REQUEST_PACKET) IovHeader)->pIovSessionData == NULL) ||
                   (IovHeader != IovHeader->ChainHead));

            VfpPacketFree((PIOV_REQUEST_PACKET) IovHeader);
            break;

        default:
            break;
    }
}


PIOV_SESSION_DATA
FASTCALL
VfPacketGetCurrentSessionData(
    IN PIOV_REQUEST_PACKET IovPacket
    )
{
    PIOV_REQUEST_PACKET headPacket;

    headPacket = (PIOV_REQUEST_PACKET) IovPacket->ChainHead;

    ASSERT_SPINLOCK_HELD(&IovPacket->IrpLock);
    ASSERT_SPINLOCK_HELD(&IovPacket->HeadPacket->IrpLock);
    ASSERT((headPacket->pIovSessionData == NULL)||
           (IovPacket->Flags&TRACKFLAG_ACTIVE)) ;

    return headPacket->pIovSessionData;
}


VOID
FASTCALL
VfPacketLogEntry(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN IOV_LOG_EVENT        IovLogEvent,
    IN PVOID                Address,
    IN ULONG_PTR            Data
    )
/*++

  Description:

    This routine logs an event in the IRP request packet data.

  Arguments:

    IovPacket        - Tracking data to write log entry into.
    IovLogEvent      - Log Event
    Address          - Address to associate log with
    Data             - A chunk of data to go with the address

  Return Value:

    Nope.

--*/
{
#if DBG
    PIOV_LOG_ENTRY logEntry;

    ASSERT_SPINLOCK_HELD(&IovPacket->IrpLock);

    logEntry = IovPacket->LogEntries + IovPacket->LogEntryHead;

    KeQueryTickCount(&logEntry->TimeStamp);
    logEntry->Thread = PsGetCurrentThread();
    logEntry->Event = IovLogEvent;
    logEntry->Address = Address;
    logEntry->Data = Data;

    IovPacket->LogEntryHead = ((IovPacket->LogEntryHead + 1) % IRP_LOG_ENTRIES);

    if (IovPacket->LogEntryHead == IovPacket->LogEntryTail) {

        IovPacket->LogEntryTail = ((IovPacket->LogEntryTail + 1) % IRP_LOG_ENTRIES);
    }

#else

    UNREFERENCED_PARAMETER(IovPacket);
    UNREFERENCED_PARAMETER(IovLogEvent);
    UNREFERENCED_PARAMETER(Address);
    UNREFERENCED_PARAMETER(Data);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfmessage.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfmessage.h

Abstract:

    This module contains prototypes for functions used to retrieve text and
    flags associated with each error.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\ioassert.c

--*/

//
// The verifier uses tables of messages and with indexes into the tables.
//
typedef ULONG   VFMESSAGE_TABLEID;
typedef ULONG   VFMESSAGE_ERRORID;

//
// VFM_ flags control how a verifier message is handled.
//
// VFM_FLAG_INITIALIZED     - Set when the error template has been updated with
//                            error-class information
//
// VFM_FLAG_BEEP            - Set if error should beep in debugger
//
// VFM_FLAG_ZAPPED          - Set if error was "zapped" (ie prints instead of
//                            stops) via debugger
//
// VFM_FLAG_CLEARED         - Set if error was cleared (disabled) in debugger
//
// VFM_DEPLOYMENT_FAILURE   - Set if the error is severe enough to warrant
//                            removal of the driver from a production system
//
// VFM_LOGO_FAILURE         - Set if the error should disallow certification
//                            for the hardware or the driver
//
// VFM_IGNORE_DRIVER_LIST   - Set if error should fire regardless of whether
//                            the offending driver is being verified or not.
//

#define VFM_FLAG_INITIALIZED        0x00000001
#define VFM_FLAG_BEEP               0x00000002
#define VFM_FLAG_ZAPPED             0x00000004
#define VFM_FLAG_CLEARED            0x00000008
#define VFM_DEPLOYMENT_FAILURE      0x00000010
#define VFM_LOGO_FAILURE            0x00000020
#define VFM_IGNORE_DRIVER_LIST      0x00000040

//
// A message class contains VFM_ flags and some generic text describing the
// problem class.
//
typedef struct _VFMESSAGE_CLASS {

    ULONG   ClassFlags;
    PCSTR   MessageClassText;

} VFMESSAGE_CLASS, *PVFMESSAGE_CLASS;

typedef VFMESSAGE_CLASS const *PCVFMESSAGE_CLASS;

//
// Individual error template. Identifies the index, the message class it's
// associated with, the parameters it takes along with the formatted text it
// displays. Note the ulong flags field - this should always be preinited to
// zero!
//
typedef struct _VFMESSAGE_TEMPLATE {

    VFMESSAGE_ERRORID   MessageID;
    PCVFMESSAGE_CLASS   MessageClass;
    ULONG               Flags;
    PCSTR               ParamString;
    PCSTR               MessageText;

} VFMESSAGE_TEMPLATE, *PVFMESSAGE_TEMPLATE;

//
// Message index 0 is reserved for use in the override tables
//
#define VIMESSAGE_ALL_IDS   0

//
// An override entry allows the verifier to special case generic assertions
// that occur against specific drivers. This is done by overriding the error
// class on the fly.
//
typedef struct _VFMESSAGE_OVERRIDE {

    VFMESSAGE_ERRORID   MessageID;
    PCSTR               DriverName;
    PCVFMESSAGE_CLASS   ReplacementClass;

} VFMESSAGE_OVERRIDE, *PVFMESSAGE_OVERRIDE;

typedef VFMESSAGE_OVERRIDE const *PCVFMESSAGE_OVERRIDE;

//
// The table of errors. Contains the TableID (used for internal lookup),
// bugcheck major ID, array of messages and array of overrides
//
typedef struct _VFMESSAGE_TEMPLATE_TABLE {

    VFMESSAGE_TABLEID       TableID;
    ULONG                   BugCheckMajor;
    PVFMESSAGE_TEMPLATE     TemplateArray;
    ULONG                   TemplateCount;
    PCVFMESSAGE_OVERRIDE    OverrideArray;
    ULONG                   OverrideCount;

} VFMESSAGE_TEMPLATE_TABLE, *PVFMESSAGE_TEMPLATE_TABLE;

//
// Retrieves an internal error table based on ID.
//
VOID
VfMessageRetrieveInternalTable(
    IN  VFMESSAGE_TABLEID           TableID,
    OUT PVFMESSAGE_TEMPLATE_TABLE  *MessageTable
    );

//
// Retrieves and formats the appropriate error message.
//
VOID
VfMessageRetrieveErrorData(
    IN  PVFMESSAGE_TEMPLATE_TABLE   MessageTable        OPTIONAL,
    IN  VFMESSAGE_ERRORID           MessageID,
    IN  PSTR                        AnsiDriverName,
    OUT ULONG                      *BugCheckMajor,
    OUT PCVFMESSAGE_CLASS          *MessageClass,
    OUT PCSTR                      *MessageTextTemplate,
    OUT PULONG                     *TemplateFlags
    );

//
// This file contains a set of internal message tables.
//
// The IO Verifier Table Index is...
//
#define VFMESSAGE_TABLE_IOVERIFIER  1

//
// IO Verifier Messages
//
typedef enum _DCERROR_ID {

    DCERROR_UNSPECIFIED = 0x200,
    DCERROR_DELETE_WHILE_ATTACHED,
    DCERROR_DETACH_NOT_ATTACHED,
    DCERROR_CANCELROUTINE_FORWARDED,
    DCERROR_NULL_DEVOBJ_FORWARDED,
    DCERROR_QUEUED_IRP_FORWARDED,
    DCERROR_NEXTIRPSP_DIRTY,
    DCERROR_IRPSP_COPIED,
    DCERROR_INSUFFICIENT_STACK_LOCATIONS,
    DCERROR_QUEUED_IRP_COMPLETED,
    DCERROR_FREE_OF_INUSE_TRACKED_IRP,
    DCERROR_FREE_OF_INUSE_IRP,
    DCERROR_FREE_OF_THREADED_IRP,
    DCERROR_REINIT_OF_ALLOCATED_IRP_WITH_QUOTA,
    DCERROR_PNP_IRP_BAD_INITIAL_STATUS,
    DCERROR_POWER_IRP_BAD_INITIAL_STATUS,
    DCERROR_WMI_IRP_BAD_INITIAL_STATUS,
    DCERROR_SKIPPED_DEVICE_OBJECT,
    DCERROR_BOGUS_FUNC_TRASHED,
    DCERROR_BOGUS_STATUS_TRASHED,
    DCERROR_BOGUS_INFO_TRASHED,
    DCERROR_PNP_FAILURE_FORWARDED,
    DCERROR_PNP_IRP_STATUS_RESET,
    DCERROR_PNP_IRP_NEEDS_HANDLING,
    DCERROR_PNP_IRP_HANDS_OFF,
    DCERROR_POWER_FAILURE_FORWARDED,
    DCERROR_POWER_IRP_STATUS_RESET,
    DCERROR_INVALID_STATUS,
    DCERROR_UNNECCESSARY_COPY,
    DCERROR_SHOULDVE_DETACHED,
    DCERROR_SHOULDVE_DELETED,
    DCERROR_MISSING_DISPATCH_FUNCTION,
    DCERROR_WMI_IRP_NOT_FORWARDED,
    DCERROR_DELETED_PRESENT_PDO,
    DCERROR_BUS_FILTER_ERRONEOUSLY_DETACHED,
    DCERROR_BUS_FILTER_ERRONEOUSLY_DELETED,
    DCERROR_INCONSISTANT_STATUS,
    DCERROR_UNINITIALIZED_STATUS,
    DCERROR_IRP_RETURNED_WITHOUT_COMPLETION,
    DCERROR_COMPLETION_ROUTINE_PAGABLE,
    DCERROR_PENDING_BIT_NOT_MIGRATED,
    DCERROR_CANCELROUTINE_ON_FORWARDED_IRP,
    DCERROR_PNP_IRP_NEEDS_PDO_HANDLING,
    DCERROR_TARGET_RELATION_LIST_EMPTY,
    DCERROR_TARGET_RELATION_NEEDS_REF,
    DCERROR_BOGUS_PNP_IRP_COMPLETED,
    DCERROR_SUCCESSFUL_PNP_IRP_NOT_FORWARDED,
    DCERROR_UNTOUCHED_PNP_IRP_NOT_FORWARDED,
    DCERROR_BOGUS_POWER_IRP_COMPLETED,
    DCERROR_SUCCESSFUL_POWER_IRP_NOT_FORWARDED,
    DCERROR_UNTOUCHED_POWER_IRP_NOT_FORWARDED,
    DCERROR_PNP_QUERY_CAP_BAD_VERSION,
    DCERROR_PNP_QUERY_CAP_BAD_SIZE,
    DCERROR_PNP_QUERY_CAP_BAD_ADDRESS,
    DCERROR_PNP_QUERY_CAP_BAD_UI_NUM,
    DCERROR_RESTRICTED_IRP,
    DCERROR_REINIT_OF_ALLOCATED_IRP_WITHOUT_QUOTA,
    DCERROR_UNFORWARDED_IRP_COMPLETED,
    DCERROR_DISPATCH_CALLED_AT_BAD_IRQL,
    DCERROR_BOGUS_MINOR_STATUS_TRASHED,
    DCERROR_CANCELROUTINE_AFTER_COMPLETION,
    DCERROR_PENDING_RETURNED_NOT_MARKED,
    DCERROR_PENDING_MARKED_NOT_RETURNED,
    DCERROR_POWER_PAGABLE_NOT_INHERITED,
    DCERROR_DOUBLE_DELETION,
    DCERROR_DETACHED_IN_SURPRISE_REMOVAL,
    DCERROR_DELETED_IN_SURPRISE_REMOVAL,
    DCERROR_DO_INITIALIZING_NOT_CLEARED,
    DCERROR_DO_FLAG_NOT_COPIED,
    DCERROR_INCONSISTANT_DO_FLAGS,
    DCERROR_DEVICE_TYPE_NOT_COPIED,
    DCERROR_NON_FAILABLE_IRP,
    DCERROR_NON_PDO_RETURNED_IN_RELATION,
    DCERROR_DUPLICATE_ENUMERATION,
    DCERROR_FILE_IO_AT_BAD_IRQL,
    DCERROR_MISHANDLED_TARGET_DEVICE_RELATIONS,
    DCERROR_PENDING_RETURNED_NOT_MARKED_2,
    DCERROR_DDI_REQUIRES_PDO,
    DCERROR_MAXIMUM

} DCERROR_ID;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfpower.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfpower.c

Abstract:

    This module handles Power Irp verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

     AdriaO      06/15/2000 - Seperated out from ntos\io\flunkirp.c

--*/

#include "vfdef.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,     VfPowerInit)
#pragma alloc_text(PAGEVRFY, VfPowerDumpIrpStack)
#pragma alloc_text(PAGEVRFY, VfPowerVerifyNewRequest)
#pragma alloc_text(PAGEVRFY, VfPowerVerifyIrpStackDownward)
#pragma alloc_text(PAGEVRFY, VfPowerVerifyIrpStackUpward)
#pragma alloc_text(PAGEVRFY, VfPowerIsSystemRestrictedIrp)
#pragma alloc_text(PAGEVRFY, VfPowerAdvanceIrpStatus)
#pragma alloc_text(PAGEVRFY, VfPowerTestStartedPdoStack)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGEVRFC")
#endif

const PCHAR PowerIrpNames[] = {
    "IRP_MN_WAIT_WAKE",                       // 0x00
    "IRP_MN_POWER_SEQUENCE",                  // 0x01
    "IRP_MN_SET_POWER",                       // 0x02
    "IRP_MN_QUERY_POWER",                     // 0x03
    NULL
    };

#define MAX_NAMED_POWER_IRP 0x3

const PCHAR SystemStateNames[] = {
    "PowerSystemUnspecified",           // 0x00
    "PowerSystemWorking.S0",            // 0x01
    "PowerSystemSleeping1.S1",          // 0x02
    "PowerSystemSleeping2.S2",          // 0x03
    "PowerSystemSleeping3.S3",          // 0x04
    "PowerSystemHibernate.S4",          // 0x05
    "PowerSystemShutdown.S5",           // 0x06
    NULL
    };

#define MAX_NAMED_SYSTEM_STATES 0x6

const PCHAR DeviceStateNames[] = {
    "PowerDeviceUnspecified",           // 0x00
    "PowerDeviceD0",                    // 0x01
    "PowerDeviceD1",                    // 0x02
    "PowerDeviceD2",                    // 0x03
    "PowerDeviceD3",                    // 0x04
    NULL
    };

#define MAX_NAMED_DEVICE_STATES 0x4

const PCHAR ActionNames[] = {
    "PowerActionNone",                  // 0x00
    "PowerActionReserved",              // 0x01
    "PowerActionSleep",                 // 0x02
    "PowerActionHibernate",             // 0x03
    "PowerActionShutdown",              // 0x04
    "PowerActionShutdownReset",         // 0x05
    "PowerActionShutdownOff",           // 0x06
    "PowerActionWarmEject",             // 0x07
    NULL
    };

#define MAX_ACTION_NAMES 0x7

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


VOID
VfPowerInit(
    VOID
    )
{
    VfMajorRegisterHandlers(
        IRP_MJ_POWER,
        VfPowerDumpIrpStack,
        VfPowerVerifyNewRequest,
        VfPowerVerifyIrpStackDownward,
        VfPowerVerifyIrpStackUpward,
        VfPowerIsSystemRestrictedIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        VfPowerTestStartedPdoStack,
        NULL
        );
}


VOID
FASTCALL
VfPowerVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    )
{
    PIRP irp;
    NTSTATUS currentStatus;

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (IrpSp);
    UNREFERENCED_PARAMETER (IrpLastSp);

    irp = IovPacket->TrackedIrp;
    currentStatus = irp->IoStatus.Status;

    //
    // Verify new IRPs start out life accordingly
    //
    if (currentStatus!=STATUS_NOT_SUPPORTED) {

        WDM_FAIL_ROUTINE((
            DCERROR_POWER_IRP_BAD_INITIAL_STATUS,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            CallerAddress,
            irp
            ));

        //
        // Don't blame anyone else for this driver's mistake.
        //
        if (!NT_SUCCESS(currentStatus)) {

            StackLocationData->Flags |= STACKFLAG_FAILURE_FORWARDED;
        }
    }
}


VOID
FASTCALL
VfPowerVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    )
{
    PIRP irp = IovPacket->TrackedIrp;
    NTSTATUS currentStatus, lastStatus;
    BOOLEAN statusChanged;
    PDRIVER_OBJECT driverObject;
    PIOV_SESSION_DATA iovSessionData;

    UNREFERENCED_PARAMETER (IrpSp);

    currentStatus = irp->IoStatus.Status;
    lastStatus = RequestHeadLocationData->LastStatusBlock.Status;
    statusChanged = (BOOLEAN)(currentStatus != lastStatus);
    iovSessionData = VfPacketGetCurrentSessionData(IovPacket);

    //
    // Verify the IRP was forwarded properly
    //
    if (iovSessionData->ForwardMethod == SKIPPED_A_DO) {

        WDM_FAIL_ROUTINE((
            DCERROR_SKIPPED_DEVICE_OBJECT,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            CallerAddress,
            irp
            ));
    }

    //
    // For some IRP major's going down a stack, there *must* be a handler
    //
    driverObject = DeviceObject->DriverObject;

    if (!IovUtilHasDispatchHandler(driverObject, IRP_MJ_POWER)) {

        RequestHeadLocationData->Flags |= STACKFLAG_BOGUS_IRP_TOUCHED;

        WDM_FAIL_ROUTINE((
            DCERROR_MISSING_DISPATCH_FUNCTION,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            driverObject->DriverInit,
            irp
            ));

        StackLocationData->Flags |= STACKFLAG_NO_HANDLER;
    }

    //
    // The following is only executed if we are not a new IRP...
    //
    if (IrpLastSp == NULL) {
        return;
    }

    //
    // The only legit failure code to pass down is STATUS_NOT_SUPPORTED
    //
    if ((!NT_SUCCESS(currentStatus)) && (currentStatus != STATUS_NOT_SUPPORTED) &&
        (!(RequestHeadLocationData->Flags & STACKFLAG_FAILURE_FORWARDED))) {

        WDM_FAIL_ROUTINE((
            DCERROR_POWER_FAILURE_FORWARDED,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            CallerAddress,
            irp
            ));

        //
        // Don't blame anyone else for this drivers's mistakes.
        //
        RequestHeadLocationData->Flags |= STACKFLAG_FAILURE_FORWARDED;
    }

    //
    // Status of a Power IRP may not be converted to STATUS_NOT_SUPPORTED on
    // the way down.
    //
    if ((currentStatus == STATUS_NOT_SUPPORTED)&&statusChanged) {

        WDM_FAIL_ROUTINE((
            DCERROR_POWER_IRP_STATUS_RESET,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            CallerAddress,
            irp
            ));
    }
}


VOID
FASTCALL
VfPowerVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    )
{
    PIRP irp;
    NTSTATUS currentStatus;
    BOOLEAN mustPassDown, isBogusIrp, isPdo;
    PVOID routine;

    UNREFERENCED_PARAMETER (IrpSp);
    UNREFERENCED_PARAMETER (RequestFinalized);

    irp = IovPacket->TrackedIrp;
    currentStatus = irp->IoStatus.Status;

    //
    // Who'd we call for this one?
    //
    routine = StackLocationData->LastDispatch;
    ASSERT(routine) ;

    //
    // If this "Request" has been "Completed", perform some checks
    //
    if (IsNewlyCompleted) {

        //
        // Remember bogosity...
        //
        isBogusIrp = (BOOLEAN)((IovPacket->Flags&TRACKFLAG_BOGUS)!=0);

        //
        // Is this a PDO?
        //
        isPdo = (BOOLEAN)((StackLocationData->Flags&STACKFLAG_REACHED_PDO)!=0);

        //
        // Was anything completed too early?
        // A driver may outright fail almost anything but a bogus IRP
        //
        mustPassDown = (BOOLEAN)(!(StackLocationData->Flags&STACKFLAG_NO_HANDLER));
        mustPassDown &= (!isPdo);

        mustPassDown &= (isBogusIrp || NT_SUCCESS(currentStatus) || (currentStatus == STATUS_NOT_SUPPORTED));
        if (mustPassDown) {

            //
            // Print appropriate error message
            //
            if (IovPacket->Flags&TRACKFLAG_BOGUS) {

                WDM_FAIL_ROUTINE((
                    DCERROR_BOGUS_POWER_IRP_COMPLETED,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    routine,
                    irp
                    ));

            } else if (NT_SUCCESS(currentStatus)) {

                WDM_FAIL_ROUTINE((
                    DCERROR_SUCCESSFUL_POWER_IRP_NOT_FORWARDED,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    routine,
                    irp
                    ));

            } else if (currentStatus == STATUS_NOT_SUPPORTED) {

                WDM_FAIL_ROUTINE((
                    DCERROR_UNTOUCHED_POWER_IRP_NOT_FORWARDED,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    routine,
                    irp
                    ));
            }
        }
    }

    //
    // Did anyone stomp the status erroneously?
    //
    if ((currentStatus == STATUS_NOT_SUPPORTED) &&
        (currentStatus != RequestHeadLocationData->LastStatusBlock.Status)) {

        //
        // Status of a PnP or Power IRP may not be converted from success to
        // STATUS_NOT_SUPPORTED on the way down.
        //
        WDM_FAIL_ROUTINE((
            DCERROR_POWER_IRP_STATUS_RESET,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            routine,
            irp
            ));
    }
}


VOID
FASTCALL
VfPowerDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    )
{
    DbgPrint("IRP_MJ_POWER.");

    if (IrpSp->MinorFunction <= MAX_NAMED_POWER_IRP) {

        DbgPrint(PowerIrpNames[IrpSp->MinorFunction]);

        if ((IrpSp->MinorFunction == IRP_MN_QUERY_POWER) ||
            (IrpSp->MinorFunction == IRP_MN_SET_POWER)) {

            DbgPrint("(");

            if (IrpSp->Parameters.Power.Type == SystemPowerState) {

                if (IrpSp->Parameters.Power.State.SystemState <= MAX_NAMED_SYSTEM_STATES) {

                    DbgPrint(SystemStateNames[IrpSp->Parameters.Power.State.SystemState]);
                }

            } else {

                if (IrpSp->Parameters.Power.State.DeviceState <= MAX_NAMED_DEVICE_STATES) {

                    DbgPrint(DeviceStateNames[IrpSp->Parameters.Power.State.DeviceState]);
                }
            }

            if (IrpSp->Parameters.Power.ShutdownType <= MAX_ACTION_NAMES) {

                DbgPrint(".%s", ActionNames[IrpSp->Parameters.Power.ShutdownType]);
            }

            DbgPrint(")");
        }

    } else if (IrpSp->MinorFunction == 0xFF) {

        DbgPrint("IRP_MN_BOGUS");

    } else {

        DbgPrint("(Bogus)");
    }
}


BOOLEAN
FASTCALL
VfPowerIsSystemRestrictedIrp(
    IN PIO_STACK_LOCATION IrpSp
    )
{
    switch(IrpSp->MinorFunction) {
        case IRP_MN_POWER_SEQUENCE:
            return FALSE;
        case IRP_MN_QUERY_POWER:
        case IRP_MN_SET_POWER:
        case IRP_MN_WAIT_WAKE:
            return TRUE;
        default:
            break;
    }

    return TRUE;
}


BOOLEAN
FASTCALL
VfPowerAdvanceIrpStatus(
    IN     PIO_STACK_LOCATION   IrpSp,
    IN     NTSTATUS             OriginalStatus,
    IN OUT NTSTATUS             *StatusToAdvance
    )
/*++

  Description:

     Given an IRP stack pointer, is it legal to change the status for
     debug-ability? If so, this function determines what the new status
     should be. Note that for each stack location, this function is iterated
     over n times where n is equal to the number of drivers who IoSkip'd this
     location.

  Arguments:

     IrpSp           - Current stack right after complete for the given stack
                       location, but before the completion routine for the
                       stack location above has been called.

     OriginalStatus  - The status of the IRP at the time listed above. Does
                       not change over iteration per skipping driver.

     StatusToAdvance - Pointer to the current status that should be updated.

  Return Value:

     TRUE if the status has been adjusted, FALSE otherwise (in this case
         StatusToAdvance is untouched).

--*/
{
    UNREFERENCED_PARAMETER (IrpSp);

    if (((ULONG) OriginalStatus) >= 256) {

        return FALSE;
    }

    (*StatusToAdvance)++;
    if ((*StatusToAdvance) == STATUS_PENDING) {
        (*StatusToAdvance)++;
    }

    return TRUE;
}


VOID
FASTCALL
VfPowerTestStartedPdoStack(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

    Description:
        As per the title, we are going to throw some IRPs at the stack to
        see if they are handled correctly.

    Returns:

        Nothing
--*/
{
    IO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //
    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    if (VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_SEND_BOGUS_POWER_IRPS)) {

        //
        // And a bogus Power IRP
        //
        irpSp.MajorFunction = IRP_MJ_POWER;
        irpSp.MinorFunction = 0xff;
        VfIrpSendSynchronousIrp(
            PhysicalDeviceObject,
            &irpSp,
            TRUE,
            STATUS_NOT_SUPPORTED,
            0,
            NULL,
            NULL
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfpower.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfpower.h

Abstract:

    This header contains prototypes for verifying Power IRPs are handled
    correctly.

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      06/15/2000 - Seperated out from ntos\io\flunkirp.h

--*/

VOID
VfPowerInit(
    VOID
    );

VOID
FASTCALL
VfPowerVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
VfPowerVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    );

VOID
FASTCALL
VfPowerVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    );

VOID
FASTCALL
VfPowerDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
FASTCALL
VfPowerIsSystemRestrictedIrp(
    IN PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
FASTCALL
VfPowerAdvanceIrpStatus(
    IN     PIO_STACK_LOCATION   IrpSp,
    IN     NTSTATUS             OriginalStatus,
    IN OUT NTSTATUS             *StatusToAdvance
    );

VOID
FASTCALL
VfPowerTestStartedPdoStack(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfpnp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfpnp.c

Abstract:

    This module handles Pnp Irp verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

     AdriaO      06/15/2000 - Seperated out from ntos\io\flunkirp.c

--*/

#include "vfdef.h"
#include "vipnp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,     VfPnpInit)
#pragma alloc_text(PAGEVRFY, VfPnpDumpIrpStack)
#pragma alloc_text(PAGEVRFY, VfPnpVerifyNewRequest)
#pragma alloc_text(PAGEVRFY, VfPnpVerifyIrpStackDownward)
#pragma alloc_text(PAGEVRFY, VfPnpVerifyIrpStackUpward)
#pragma alloc_text(PAGEVRFY, VfPnpIsSystemRestrictedIrp)
#pragma alloc_text(PAGEVRFY, VfPnpAdvanceIrpStatus)
#pragma alloc_text(PAGEVRFY, VfPnpTestStartedPdoStack)
#pragma alloc_text(PAGEVRFY, ViPnpVerifyMinorWasProcessedProperly)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGEVRFC")
#endif

const PCHAR PnPIrpNames[] = {
    "IRP_MN_START_DEVICE",                    // 0x00
    "IRP_MN_QUERY_REMOVE_DEVICE",             // 0x01
    "IRP_MN_REMOVE_DEVICE - ",                // 0x02
    "IRP_MN_CANCEL_REMOVE_DEVICE",            // 0x03
    "IRP_MN_STOP_DEVICE",                     // 0x04
    "IRP_MN_QUERY_STOP_DEVICE",               // 0x05
    "IRP_MN_CANCEL_STOP_DEVICE",              // 0x06
    "IRP_MN_QUERY_DEVICE_RELATIONS",          // 0x07
    "IRP_MN_QUERY_INTERFACE",                 // 0x08
    "IRP_MN_QUERY_CAPABILITIES",              // 0x09
    "IRP_MN_QUERY_RESOURCES",                 // 0x0A
    "IRP_MN_QUERY_RESOURCE_REQUIREMENTS",     // 0x0B
    "IRP_MN_QUERY_DEVICE_TEXT",               // 0x0C
    "IRP_MN_FILTER_RESOURCE_REQUIREMENTS",    // 0x0D
    "INVALID_IRP_CODE",                       //
    "IRP_MN_READ_CONFIG",                     // 0x0F
    "IRP_MN_WRITE_CONFIG",                    // 0x10
    "IRP_MN_EJECT",                           // 0x11
    "IRP_MN_SET_LOCK",                        // 0x12
    "IRP_MN_QUERY_ID",                        // 0x13
    "IRP_MN_QUERY_PNP_DEVICE_STATE",          // 0x14
    "IRP_MN_QUERY_BUS_INFORMATION",           // 0x15
    "IRP_MN_DEVICE_USAGE_NOTIFICATION",       // 0x16
    "IRP_MN_SURPRISE_REMOVAL",                // 0x17
    "IRP_MN_QUERY_LEGACY_BUS_INFORMATION",    // 0x18
    NULL
    };

#define MAX_NAMED_PNP_IRP   0x18

#include <initguid.h>
DEFINE_GUID( GUID_BOGUS_INTERFACE, 0x00000000L, 0x0000, 0x0000,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


VOID
VfPnpInit(
    VOID
    )
{
    VfMajorRegisterHandlers(
        IRP_MJ_PNP,
        VfPnpDumpIrpStack,
        VfPnpVerifyNewRequest,
        VfPnpVerifyIrpStackDownward,
        VfPnpVerifyIrpStackUpward,
        VfPnpIsSystemRestrictedIrp,
        VfPnpAdvanceIrpStatus,
        NULL,
        NULL,
        NULL,
        NULL,
        VfPnpTestStartedPdoStack,
        NULL
        );
}


VOID
FASTCALL
VfPnpVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    )
{
    PIRP irp;
    NTSTATUS currentStatus;
    PDEVICE_OBJECT possiblePdo;
    PDEVICE_CAPABILITIES deviceCapabilities;

    UNREFERENCED_PARAMETER (IrpLastSp);

    irp = IovPacket->TrackedIrp;
    currentStatus = irp->IoStatus.Status;

    //
    // Verify new IRPs start out life accordingly
    //
    if (currentStatus!=STATUS_NOT_SUPPORTED) {

        //
        // This is a special WDM (9x) compatibility hack.
        //
        if ((IrpSp->MinorFunction != IRP_MN_FILTER_RESOURCE_REQUIREMENTS) &&
            (!(IovPacket->Flags & TRACKFLAG_BOGUS))) {

            WDM_FAIL_ROUTINE((
                DCERROR_PNP_IRP_BAD_INITIAL_STATUS,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                CallerAddress,
                irp
                ));
        }

        //
        // Don't blame anyone else for this guy's mistake.
        //
        if (!NT_SUCCESS(currentStatus)) {

            StackLocationData->Flags |= STACKFLAG_FAILURE_FORWARDED;
        }
    }

    if (IrpSp->MinorFunction == IRP_MN_QUERY_CAPABILITIES) {

        deviceCapabilities = IrpSp->Parameters.DeviceCapabilities.Capabilities;

        if (VfUtilIsMemoryRangeReadable(deviceCapabilities, sizeof(DEVICE_CAPABILITIES), VFMP_INSTANT_NONPAGED)) {

            //
            // Verify fields are initialized correctly
            //
            if (deviceCapabilities->Version < 1) {

                //
                // Whoops, it didn't initialize the version correctly!
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_PNP_QUERY_CAP_BAD_VERSION,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    CallerAddress,
                    irp
                    ));
            }

            if (deviceCapabilities->Size < sizeof(DEVICE_CAPABILITIES)) {

                //
                // Whoops, it didn't initialize the size field correctly!
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_PNP_QUERY_CAP_BAD_SIZE,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    CallerAddress,
                    irp
                    ));
            }

            if (deviceCapabilities->Address != (ULONG) -1) {

                //
                // Whoops, it didn't initialize the address field correctly!
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_PNP_QUERY_CAP_BAD_ADDRESS,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    CallerAddress,
                    irp
                    ));
            }

            if (deviceCapabilities->UINumber != (ULONG) -1) {

                //
                // Whoops, it didn't initialize the UI number field correctly!
                //
                WDM_FAIL_ROUTINE((
                    DCERROR_PNP_QUERY_CAP_BAD_UI_NUM,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    CallerAddress,
                    irp
                    ));
            }
        }
    }

    //
    // If this is a target device relation IRP, verify the appropriate
    // object will be referenced.
    //
    if (!VfSettingsIsOptionEnabled(IovPacket->VerifierSettings, VERIFIER_OPTION_TEST_TARGET_REFCOUNT)) {

        return;
    }

    if ((IrpSp->MinorFunction == IRP_MN_QUERY_DEVICE_RELATIONS)&&
        (IrpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation)) {

        IovUtilGetBottomDeviceObject(DeviceObject, &possiblePdo);

        if (IovUtilIsPdo(possiblePdo)) {

            if (StackLocationData->ReferencingObject == NULL) {

                //
                // Got'm!
                //
                StackLocationData->Flags |= STACKFLAG_CHECK_FOR_REFERENCE;
                StackLocationData->ReferencingObject = possiblePdo;
                StackLocationData->ReferencingCount = (LONG)ObvUtilStartObRefMonitoring(possiblePdo);
                IovPacket->RefTrackingCount++;
            }
        }

        //
        // Free our reference (we will have one if we are snapshotting anyway)
        //
        ObDereferenceObject(possiblePdo);
    }
}


VOID
FASTCALL
VfPnpVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    )
{
    PIRP irp;
    NTSTATUS currentStatus, lastStatus;
    BOOLEAN statusChanged;
    PDRIVER_OBJECT driverObject;
    PIOV_SESSION_DATA iovSessionData;
    HOW_PROCESSED howProcessed;
    VF_DEVOBJ_TYPE devObjType;

    UNREFERENCED_PARAMETER (StackLocationData);

    if (!IovUtilIsWdmStack(DeviceObject)) {

        return;
    }

    irp = IovPacket->TrackedIrp;
    currentStatus = irp->IoStatus.Status;
    lastStatus = RequestHeadLocationData->LastStatusBlock.Status;
    statusChanged = (BOOLEAN)(currentStatus != lastStatus);
    iovSessionData = VfPacketGetCurrentSessionData(IovPacket);

    //
    // Verify the IRP was forwarded properly
    //
    switch(iovSessionData->ForwardMethod) {

        case SKIPPED_A_DO:

            WDM_FAIL_ROUTINE((
                DCERROR_SKIPPED_DEVICE_OBJECT,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                CallerAddress,
                irp
                ));

            break;

        case STARTED_TOP_OF_STACK:
        case FORWARDED_TO_NEXT_DO:

            //
            // Perfectly normal
            //
            break;

        case STARTED_INSIDE_STACK:
            //
            // Probably an Internal irp (query cap's, etc)
            //
            break;

        case CHANGED_STACKS_MID_STACK:
        case CHANGED_STACKS_AT_BOTTOM:

            //
            // ADRIAO N.B. - Ensure drivers aren't rerouting certain IRPs off
            // PnP stacks.
            //
#if 0
            ASSERT(0);
#endif
            break ;
    }

    //
    // For some IRP major's going down a stack, there *must* be a handler
    //
    driverObject = DeviceObject->DriverObject;

    if (!IovUtilHasDispatchHandler(driverObject, IRP_MJ_PNP)) {

        RequestHeadLocationData->Flags |= STACKFLAG_BOGUS_IRP_TOUCHED;

        WDM_FAIL_ROUTINE((
            DCERROR_MISSING_DISPATCH_FUNCTION,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            driverObject->DriverInit,
            irp
            ));

        StackLocationData->Flags |= STACKFLAG_NO_HANDLER;
    }

    //
    // The following is only executed if we are not a new IRP...
    //
    if (IrpLastSp == NULL) {
        return;
    }

    //
    // The only legit failure code to pass down is STATUS_NOT_SUPPORTED
    //
    if ((!NT_SUCCESS(currentStatus)) && (currentStatus != STATUS_NOT_SUPPORTED) &&
        (!(RequestHeadLocationData->Flags & STACKFLAG_FAILURE_FORWARDED))) {

        WDM_FAIL_ROUTINE((
            DCERROR_PNP_FAILURE_FORWARDED,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            CallerAddress,
            irp
            ));

        //
        // Don't blame anyone else for this driver's mistakes...
        //
        RequestHeadLocationData->Flags |= STACKFLAG_FAILURE_FORWARDED;
    }

    //
    // Status of a PnP IRP may not be converted to
    // STATUS_NOT_SUPPORTED on the way down
    //
    if ((currentStatus == STATUS_NOT_SUPPORTED)&&statusChanged&&
        (!(RequestHeadLocationData->Flags & STACKFLAG_FAILURE_FORWARDED))) {

        WDM_FAIL_ROUTINE((
            DCERROR_PNP_IRP_STATUS_RESET,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            CallerAddress,
            irp
            ));

        //
        // Don't blame anyone else for this driver's mistakes...
        //
        RequestHeadLocationData->Flags |= STACKFLAG_FAILURE_FORWARDED;
    }

    //
    // Some IRPs FDO's are required to handle before passing down. And some
    // IRPs should not be touched by the FDO. Assert it is so...
    //
    if ((!iovSessionData->DeviceLastCalled) ||
        (!IovUtilIsDesignatedFdo(iovSessionData->DeviceLastCalled))) {

        return;
    }

    if (currentStatus != STATUS_NOT_SUPPORTED) {

        howProcessed = DEFINITELY_PROCESSED;

    } else if (IrpSp->CompletionRoutine == NULL) {

        howProcessed = NOT_PROCESSED;

    } else {

        howProcessed = POSSIBLY_PROCESSED;
    }

    //
    // How could a Raw FDO (aka a PDO) get here? Well, a PDO could forward
    // to another stack if he's purposely reserved enough stack locations
    // for that eventuality.
    //
    devObjType = IovUtilIsRawPdo(iovSessionData->DeviceLastCalled) ?
        VF_DEVOBJ_PDO : VF_DEVOBJ_FDO;

    ViPnpVerifyMinorWasProcessedProperly(
        irp,
        IrpSp,
        devObjType,
        iovSessionData->VerifierSettings,
        howProcessed,
        CallerAddress
        );
}


VOID
FASTCALL
VfPnpVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    )
{
    PIRP irp;
    NTSTATUS currentStatus;
    BOOLEAN mustPassDown, isBogusIrp, isPdo, touchable;
    PVOID routine;
    LONG referencesTaken;
    PDEVICE_RELATIONS deviceRelations;
    PIOV_SESSION_DATA iovSessionData;
    ULONG index, swapIndex;
    PDEVICE_OBJECT swapObject, lowerDevObj;
    HOW_PROCESSED howProcessed;

    UNREFERENCED_PARAMETER (RequestFinalized);

    if (!IovUtilIsWdmStack(IrpSp->DeviceObject)) {

        return;
    }

    isPdo = FALSE;

    irp = IovPacket->TrackedIrp;
    currentStatus = irp->IoStatus.Status;
    iovSessionData = VfPacketGetCurrentSessionData(IovPacket);

    //
    // Who'd we call for this one?
    //
    routine = StackLocationData->LastDispatch;
    ASSERT(routine) ;

    //
    // If this "Request" has been "Completed", perform some checks
    //
    if (IsNewlyCompleted) {

        //
        // Remember bogosity...
        //
        isBogusIrp = (BOOLEAN)((IovPacket->Flags&TRACKFLAG_BOGUS)!=0);

        //
        // Is this a PDO?
        //
        isPdo = (BOOLEAN)((StackLocationData->Flags&STACKFLAG_REACHED_PDO)!=0);

        //
        // Was anything completed too early?
        // A driver may outright fail almost anything but a bogus IRP
        //
        mustPassDown = (BOOLEAN)(!(StackLocationData->Flags&STACKFLAG_NO_HANDLER));
        mustPassDown &= (!isPdo);

        mustPassDown &= (isBogusIrp || NT_SUCCESS(currentStatus) || (currentStatus == STATUS_NOT_SUPPORTED));
        if (mustPassDown) {

            //
            // Print appropriate error message
            //
            if (IovPacket->Flags&TRACKFLAG_BOGUS) {

                WDM_FAIL_ROUTINE((
                    DCERROR_BOGUS_PNP_IRP_COMPLETED,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    routine,
                    irp
                    ));

            } else if (NT_SUCCESS(currentStatus)) {

                WDM_FAIL_ROUTINE((
                    DCERROR_SUCCESSFUL_PNP_IRP_NOT_FORWARDED,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    routine,
                    irp
                    ));

            } else if (currentStatus == STATUS_NOT_SUPPORTED) {

                WDM_FAIL_ROUTINE((
                    DCERROR_UNTOUCHED_PNP_IRP_NOT_FORWARDED,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    routine,
                    irp
                    ));
            }
        }
    }

    //
    // Did the PDO respond to it's required set of IRPs?
    //
    if (IsNewlyCompleted && isPdo) {

        if (currentStatus != STATUS_NOT_SUPPORTED) {

            howProcessed = DEFINITELY_PROCESSED;

        } else {

            howProcessed = POSSIBLY_PROCESSED;
        }

        ViPnpVerifyMinorWasProcessedProperly(
            irp,
            IrpSp,
            VF_DEVOBJ_PDO,
            iovSessionData->VerifierSettings,
            howProcessed,
            routine
            );
    }

    //
    // Was TargetDeviceRelation implemented correctly?
    //
    if (IsNewlyCompleted &&
        (RequestHeadLocationData->Flags&STACKFLAG_CHECK_FOR_REFERENCE)) {

        ASSERT ((IrpSp->MajorFunction == IRP_MJ_PNP)&&
            (IrpSp->MinorFunction == IRP_MN_QUERY_DEVICE_RELATIONS)&&
            (IrpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation));

        ASSERT(RequestHeadLocationData->ReferencingObject);
        ASSERT(IovPacket->RefTrackingCount);

        referencesTaken = (LONG)ObvUtilStopObRefMonitoring(
            RequestHeadLocationData->ReferencingObject,
            RequestHeadLocationData->ReferencingCount
            );

        IovPacket->RefTrackingCount--;
        RequestHeadLocationData->ReferencingObject = NULL;

        RequestHeadLocationData->Flags &= ~STACKFLAG_CHECK_FOR_REFERENCE;

        if (NT_SUCCESS(currentStatus)&&(!referencesTaken)) {

            WDM_FAIL_ROUTINE((
                DCERROR_TARGET_RELATION_NEEDS_REF,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                routine,
                irp
                ));
        }
    }

    //
    // Did anyone stomp the status erroneously?
    //
    if ((currentStatus == STATUS_NOT_SUPPORTED) &&
        (!(RequestHeadLocationData->Flags & STACKFLAG_FAILURE_FORWARDED)) &&
        (currentStatus != RequestHeadLocationData->LastStatusBlock.Status)) {

        //
        // Status of a PnP or Power IRP may not be converted from success to
        // STATUS_NOT_SUPPORTED on the way down.
        //
        WDM_FAIL_ROUTINE((
            DCERROR_PNP_IRP_STATUS_RESET,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            routine,
            irp
            ));

        //
        // Don't blame anyone else for this driver's mistakes...
        //
        RequestHeadLocationData->Flags |= STACKFLAG_FAILURE_FORWARDED;
    }

    switch(IrpSp->MinorFunction) {

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            //
            // Rotate device relations if so ordered.
            //
            if ((RequestHeadLocationData == StackLocationData) &&
                ((IrpSp->Parameters.QueryDeviceRelations.Type == BusRelations) ||
                 (IrpSp->Parameters.QueryDeviceRelations.Type == RemovalRelations) ||
                 (IrpSp->Parameters.QueryDeviceRelations.Type == EjectionRelations)) &&
                VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings,
                VERIFIER_OPTION_SCRAMBLE_RELATIONS)) {

                if (NT_SUCCESS(currentStatus) && irp->IoStatus.Information) {

                    deviceRelations = (PDEVICE_RELATIONS) irp->IoStatus.Information;

                    touchable = VfUtilIsMemoryRangeReadable(
                        deviceRelations,
                        (sizeof(DEVICE_RELATIONS)-sizeof(PVOID)),
                        VFMP_INSTANT_NONPAGED
                        );

                    if (!touchable) {

                        break;
                    }

                    touchable = VfUtilIsMemoryRangeReadable(
                        deviceRelations,
                        (sizeof(DEVICE_RELATIONS)+((LONG) (deviceRelations->Count-1))*sizeof(PVOID)),
                        VFMP_INSTANT_NONPAGED
                        );

                    if (!touchable) {

                        break;
                    }

                    if (deviceRelations->Count > 1) {

                        //
                        // Scramble the relation list by random swapping.
                        //
                        for(index = 0; index < (deviceRelations->Count+1)/2; index++) {

                            swapIndex = VfRandomGetNumber(1, deviceRelations->Count-1);

                            swapObject = deviceRelations->Objects[0];
                            deviceRelations->Objects[0] = deviceRelations->Objects[swapIndex];
                            deviceRelations->Objects[swapIndex] = swapObject;
                        }
                    }
                }
            }

            break;

        case IRP_MN_SURPRISE_REMOVAL:
            if (VfSettingsIsOptionEnabled(iovSessionData->VerifierSettings,
                VERIFIER_OPTION_MONITOR_REMOVES)) {

                //
                // Verify driver didn't do an IoDetachDevice upon recieving the
                // SURPRISE_REMOVAL IRP.
                //
                IovUtilGetLowerDeviceObject(IrpSp->DeviceObject, &lowerDevObj);

                if (lowerDevObj) {

                    ObDereferenceObject(lowerDevObj);

                } else if (!IovUtilIsPdo(IrpSp->DeviceObject)) {

                    WDM_FAIL_ROUTINE((
                        DCERROR_DETACHED_IN_SURPRISE_REMOVAL,
                        DCPARAM_IRP + DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                        routine,
                        iovSessionData->BestVisibleIrp,
                        IrpSp->DeviceObject
                        ));
                }

                //
                // Verify driver didn't do an IoDeleteDevice upon recieving the
                // SURPRISE_REMOVAL IRP.
                //
                if (IovUtilIsDeviceObjectMarked(IrpSp->DeviceObject, MARKTYPE_DELETED)) {

                    WDM_FAIL_ROUTINE((
                        DCERROR_DELETED_IN_SURPRISE_REMOVAL,
                        DCPARAM_IRP + DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                        routine,
                        iovSessionData->BestVisibleIrp,
                        IrpSp->DeviceObject
                        ));
                }
            }

            break;

        default:
            break;
    }
}


VOID
FASTCALL
VfPnpDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    )
{
    DbgPrint("IRP_MJ_PNP.");

    if (IrpSp->MinorFunction<=MAX_NAMED_PNP_IRP) {

        DbgPrint(PnPIrpNames[IrpSp->MinorFunction]);
    } else if (IrpSp->MinorFunction==0xFF) {

        DbgPrint("IRP_MN_BOGUS");
    } else {

        DbgPrint("(Bogus)");
    }

    switch(IrpSp->MinorFunction) {
        case IRP_MN_QUERY_DEVICE_RELATIONS:

            switch(IrpSp->Parameters.QueryDeviceRelations.Type) {
                case BusRelations:
                    DbgPrint("(BusRelations)");
                    break;
                case EjectionRelations:
                    DbgPrint("(EjectionRelations)");
                    break;
                case PowerRelations:
                    DbgPrint("(PowerRelations)");
                    break;
                case RemovalRelations:
                    DbgPrint("(RemovalRelations)");
                    break;
                case TargetDeviceRelation:
                    DbgPrint("(TargetDeviceRelation)");
                    break;
                default:
                    DbgPrint("(Bogus)");
                    break;
            }
            break;
        case IRP_MN_QUERY_INTERFACE:
            break;
        case IRP_MN_QUERY_DEVICE_TEXT:
            switch(IrpSp->Parameters.QueryId.IdType) {
                case DeviceTextDescription:
                    DbgPrint("(DeviceTextDescription)");
                    break;
                case DeviceTextLocationInformation:
                    DbgPrint("(DeviceTextLocationInformation)");
                    break;
                default:
                    DbgPrint("(Bogus)");
                    break;
            }
            break;
        case IRP_MN_WRITE_CONFIG:
        case IRP_MN_READ_CONFIG:
            DbgPrint("(WhichSpace=%x, Buffer=%x, Offset=%x, Length=%x)",
                IrpSp->Parameters.ReadWriteConfig.WhichSpace,
                IrpSp->Parameters.ReadWriteConfig.Buffer,
                IrpSp->Parameters.ReadWriteConfig.Offset,
                IrpSp->Parameters.ReadWriteConfig.Length
                );
            break;
        case IRP_MN_SET_LOCK:
            if (IrpSp->Parameters.SetLock.Lock) DbgPrint("(True)");
            else DbgPrint("(False)");
            break;
        case IRP_MN_QUERY_ID:
            switch(IrpSp->Parameters.QueryId.IdType) {
                case BusQueryDeviceID:
                    DbgPrint("(BusQueryDeviceID)");
                    break;
                case BusQueryHardwareIDs:
                    DbgPrint("(BusQueryHardwareIDs)");
                    break;
                case BusQueryCompatibleIDs:
                    DbgPrint("(BusQueryCompatibleIDs)");
                    break;
                case BusQueryInstanceID:
                    DbgPrint("(BusQueryInstanceID)");
                    break;
                default:
                    DbgPrint("(Bogus)");
                    break;
            }
            break;
        case IRP_MN_QUERY_BUS_INFORMATION:
            break;
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            switch(IrpSp->Parameters.UsageNotification.Type) {
                case DeviceUsageTypeUndefined:
                    DbgPrint("(DeviceUsageTypeUndefined");
                    break;
                case DeviceUsageTypePaging:
                    DbgPrint("(DeviceUsageTypePaging");
                    break;
                case DeviceUsageTypeHibernation:
                    DbgPrint("(DeviceUsageTypeHibernation");
                    break;
                case DeviceUsageTypeDumpFile:
                    DbgPrint("(DeviceUsageTypeDumpFile");
                    break;
                default:
                    DbgPrint("(Bogus)");
                    break;
            }
            if (IrpSp->Parameters.UsageNotification.InPath) {
                DbgPrint(", InPath=TRUE)");
            } else {
                DbgPrint(", InPath=FALSE)");
            }
            break;
        case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
            break;
        default:
            break;
    }
}


BOOLEAN
FASTCALL
VfPnpIsSystemRestrictedIrp(
    IN PIO_STACK_LOCATION IrpSp
    )
{
    switch(IrpSp->MinorFunction) {
        case IRP_MN_START_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_REMOVE_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
        case IRP_MN_STOP_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_SURPRISE_REMOVAL:
            return TRUE;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            switch(IrpSp->Parameters.QueryDeviceRelations.Type) {
                case BusRelations:
                case PowerRelations:
                    return TRUE;
                case RemovalRelations:
                case EjectionRelations:
                case TargetDeviceRelation:
                    return FALSE;
                default:
                    break;
            }
            break;
        case IRP_MN_QUERY_INTERFACE:
        case IRP_MN_QUERY_CAPABILITIES:
            return FALSE;
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        case IRP_MN_QUERY_DEVICE_TEXT:
            return TRUE;
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:
            return FALSE;
        case IRP_MN_EJECT:
        case IRP_MN_SET_LOCK:
        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
            return TRUE;
        case IRP_MN_QUERY_ID:
            switch(IrpSp->Parameters.QueryId.IdType) {

                case BusQueryHardwareIDs:
                case BusQueryCompatibleIDs:
                    return TRUE;
                case BusQueryDeviceID:
                case BusQueryInstanceID:
                    return FALSE;
                default:
                    break;
            }
            break;
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
        case IRP_MN_QUERY_BUS_INFORMATION:
            return TRUE;
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return FALSE;
        default:
            break;
    }

    return TRUE;
}


BOOLEAN
FASTCALL
VfPnpAdvanceIrpStatus(
    IN     PIO_STACK_LOCATION   IrpSp,
    IN     NTSTATUS             OriginalStatus,
    IN OUT NTSTATUS             *StatusToAdvance
    )
/*++

  Description:

     Given an IRP stack pointer, is it legal to change the status for
     debug-ability? If so, this function determines what the new status
     should be. Note that for each stack location, this function is iterated
     over n times where n is equal to the number of drivers who IoSkip'd this
     location.

  Arguments:

     IrpSp           - Current stack right after complete for the given stack
                       location, but before the completion routine for the
                       stack location above has been called.

     OriginalStatus  - The status of the IRP at the time listed above. Does
                       not change over iteration per skipping driver.

     StatusToAdvance - Pointer to the current status that should be updated.

  Return Value:

     TRUE if the status has been adjusted, FALSE otherwise (in this case
         StatusToAdvance is untouched).

--*/
{
    UNREFERENCED_PARAMETER (IrpSp);

    if (((ULONG) OriginalStatus) >= 256) {

        return FALSE;
    }

    (*StatusToAdvance)++;
    if ((*StatusToAdvance) == STATUS_PENDING) {
        (*StatusToAdvance)++;
    }

    return TRUE;
}


VOID
FASTCALL
VfPnpTestStartedPdoStack(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

    Description:
        As per the title, we are going to throw some IRPs at the stack to
        see if they are handled correctly.

    Returns:

        Nothing
--*/
{
    IO_STACK_LOCATION irpSp;
    PDEVICE_RELATIONS targetDeviceRelationList;
    INTERFACE interface;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //
    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // send lots of bogus PNP IRPs
    //
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = 0xff;
    VfIrpSendSynchronousIrp(
        PhysicalDeviceObject,
        &irpSp,
        TRUE,
        STATUS_NOT_SUPPORTED,
        0,
        NULL,
        NULL
        );

    irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
    irpSp.Parameters.QueryDeviceRelations.Type = (DEVICE_RELATION_TYPE) -1;
    VfIrpSendSynchronousIrp(
        PhysicalDeviceObject,
        &irpSp,
        TRUE,
        STATUS_NOT_SUPPORTED,
        0,
        NULL,
        NULL
        );

    if (VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_RELATION_IGNORANCE_TEST)) {

        irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
        irpSp.Parameters.QueryDeviceRelations.Type = (DEVICE_RELATION_TYPE) -1;
        VfIrpSendSynchronousIrp(
            PhysicalDeviceObject,
            &irpSp,
            TRUE,
            STATUS_NOT_SUPPORTED,
            (ULONG_PTR) -1,
            NULL,
            NULL
            );
    }

    irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_TEXT;
    irpSp.Parameters.QueryDeviceText.DeviceTextType = (DEVICE_TEXT_TYPE) -1;
    VfIrpSendSynchronousIrp(
        PhysicalDeviceObject,
        &irpSp,
        TRUE,
        STATUS_NOT_SUPPORTED,
        0,
        NULL,
        NULL
        );

    irpSp.MinorFunction = IRP_MN_QUERY_ID;
    irpSp.Parameters.QueryId.IdType = (BUS_QUERY_ID_TYPE) -1;
    VfIrpSendSynchronousIrp(
        PhysicalDeviceObject,
        &irpSp,
        TRUE,
        STATUS_NOT_SUPPORTED,
        0,
        NULL,
        NULL
        );
/*
    irpSp.MinorFunction = IRP_MN_QUERY_ID;
    irpSp.Parameters.QueryId.IdType = (BUS_QUERY_ID_TYPE) -1;
    VfIrpSendSynchronousIrp(
        PhysicalDeviceObject,
        &irpSp,
        TRUE,
        STATUS_SUCCESS,
        (ULONG_PTR) -1,
        NULL,
        NULL
        );
*/
    //
    // Target device relation test...
    //
    irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
    irpSp.Parameters.QueryDeviceRelations.Type = TargetDeviceRelation;
    targetDeviceRelationList = NULL;
    if (VfIrpSendSynchronousIrp(
        PhysicalDeviceObject,
        &irpSp,
        FALSE,
        STATUS_NOT_SUPPORTED,
        0,
        (ULONG_PTR *) &targetDeviceRelationList,
        &status
        )) {

        if (NT_SUCCESS(status)) {

            ASSERT(targetDeviceRelationList);
            ASSERT(targetDeviceRelationList->Count == 1);
            ASSERT(targetDeviceRelationList->Objects[0]);
            ObDereferenceObject(targetDeviceRelationList->Objects[0]);
            ExFreePool(targetDeviceRelationList);

        } else {

            //
            // IRP was asserted in other code. We need to do nothing here...
            //
        }
    }

    RtlZeroMemory(&interface, sizeof(INTERFACE));
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpSp.Parameters.QueryInterface.Size = (USHORT)-1;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.InterfaceType = &GUID_BOGUS_INTERFACE;
    irpSp.Parameters.QueryInterface.Interface = &interface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = (PVOID) -1;
    VfIrpSendSynchronousIrp(
        PhysicalDeviceObject,
        &irpSp,
        TRUE,
        STATUS_NOT_SUPPORTED,
        0,
        NULL,
        NULL
        );

    RtlZeroMemory(&interface, sizeof(INTERFACE));
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpSp.Parameters.QueryInterface.Size = (USHORT)-1;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.InterfaceType = &GUID_BOGUS_INTERFACE;
    irpSp.Parameters.QueryInterface.Interface = &interface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = (PVOID) -1;
    VfIrpSendSynchronousIrp(
        PhysicalDeviceObject,
        &irpSp,
        TRUE,
        STATUS_SUCCESS,
        0,
        NULL,
        NULL
        );

    //
    // We could do more chaff here. For example, bogus device usage
    // notifications, etc...
    //
}


VOID
ViPnpVerifyMinorWasProcessedProperly(
    IN  PIRP                        Irp,
    IN  PIO_STACK_LOCATION          IrpSp,
    IN  VF_DEVOBJ_TYPE              DevObjType,
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSnapshot,
    IN  HOW_PROCESSED               HowProcessed,
    IN  PVOID                       CallerAddress
    )
{
    PDEVICE_OBJECT relationObject, relationPdo;
    PDEVICE_RELATIONS deviceRelations;
    BOOLEAN touchable;
    ULONG index;

    switch(IrpSp->MinorFunction) {

        case IRP_MN_SURPRISE_REMOVAL:

            if ((HowProcessed != NOT_PROCESSED) ||
                (!VfSettingsIsOptionEnabled(VerifierSnapshot,
                VERIFIER_OPTION_EXTENDED_REQUIRED_IRPS))) {

                break;
            }

            WDM_FAIL_ROUTINE((
                DCERROR_PNP_IRP_NEEDS_HANDLING,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                CallerAddress,
                Irp
                ));

            break;

        case IRP_MN_START_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_REMOVE_DEVICE:
        case IRP_MN_STOP_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:

            //
            // The driver must set the status as appropriate.
            //
            if (HowProcessed != NOT_PROCESSED) {

                break;
            }

            WDM_FAIL_ROUTINE((
                DCERROR_PNP_IRP_NEEDS_HANDLING,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                CallerAddress,
                Irp
                ));

            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE:

            //
            // The driver must set the status of these IRPs to something
            // successful!
            //
            if (HowProcessed == NOT_PROCESSED) {

                WDM_FAIL_ROUTINE((
                    DCERROR_PNP_IRP_NEEDS_HANDLING,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    CallerAddress,
                    Irp
                    ));

            } else if ((HowProcessed == DEFINITELY_PROCESSED) &&
                       (!NT_SUCCESS(Irp->IoStatus.Status)) &&
                       (VfSettingsIsOptionEnabled(VerifierSnapshot,
                        VERIFIER_OPTION_EXTENDED_REQUIRED_IRPS))) {

                WDM_FAIL_ROUTINE((
                    DCERROR_NON_FAILABLE_IRP,
                    DCPARAM_IRP + DCPARAM_ROUTINE,
                    CallerAddress,
                    Irp
                    ));
            }

            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            switch(IrpSp->Parameters.QueryDeviceRelations.Type) {
                case TargetDeviceRelation:

                    if (DevObjType != VF_DEVOBJ_PDO) {

                        if (HowProcessed != DEFINITELY_PROCESSED) {

                            break;
                        }

                        WDM_FAIL_ROUTINE((
                            DCERROR_PNP_IRP_HANDS_OFF,
                            DCPARAM_IRP + DCPARAM_ROUTINE,
                            CallerAddress,
                            Irp
                            ));

                    } else {

                        if (HowProcessed == NOT_PROCESSED) {

                            WDM_FAIL_ROUTINE((
                                DCERROR_PNP_IRP_NEEDS_PDO_HANDLING,
                                DCPARAM_IRP + DCPARAM_ROUTINE,
                                CallerAddress,
                                Irp
                                ));

                        } else if (NT_SUCCESS(Irp->IoStatus.Status)) {

                            if (Irp->IoStatus.Information == (ULONG_PTR) NULL) {

                                WDM_FAIL_ROUTINE((
                                    DCERROR_TARGET_RELATION_LIST_EMPTY,
                                    DCPARAM_IRP + DCPARAM_ROUTINE,
                                    CallerAddress,
                                    Irp
                                    ));
                            }

                            //
                            // ADRIAO N.B. - I could also assert the Information
                            // matches DeviceObject.
                            //
                        }
                    }

                    break;

               case BusRelations:
               case PowerRelations:
               case RemovalRelations:

               case EjectionRelations:

                   //
                   // Ejection relations are usually a bad idea for
                   // FDO's - As stopping a device implies powerdown,
                   // RemovalRelations are usually the proper response
                   // for an FDO. One exception is ISAPNP, as PCI-to-ISA
                   // bridges can never be powered down.
                   //

               default:
                   break;
            }

            //
            // Verify we got back PDO's.
            //
            if (!VfSettingsIsOptionEnabled(
                VerifierSnapshot,
                VERIFIER_OPTION_EXAMINE_RELATION_PDOS)) {

                break;
            }

            if ((!NT_SUCCESS(Irp->IoStatus.Status)) ||
                (((PVOID) Irp->IoStatus.Information) == NULL)) {

                break;
            }

            switch(IrpSp->Parameters.QueryDeviceRelations.Type) {
                case TargetDeviceRelation:
                case BusRelations:
                case PowerRelations:
                case RemovalRelations:
                case EjectionRelations:

                    deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;

                    touchable = VfUtilIsMemoryRangeReadable(
                        deviceRelations,
                        (sizeof(DEVICE_RELATIONS)-sizeof(PVOID)),
                        VFMP_INSTANT_NONPAGED
                        );

                    if (!touchable) {

                        break;
                    }

                    touchable = VfUtilIsMemoryRangeReadable(
                        deviceRelations,
                        (sizeof(DEVICE_RELATIONS)+((LONG) (deviceRelations->Count-1))*sizeof(PVOID)),
                        VFMP_INSTANT_NONPAGED
                        );

                    if (!touchable) {

                        break;
                    }

                    for(index = 0; index < deviceRelations->Count; index++) {

                        relationObject = deviceRelations->Objects[index];

                        if (IovUtilIsDeviceObjectMarked(relationObject, MARKTYPE_RELATION_PDO_EXAMINED)) {

                            continue;
                        }

                        IovUtilGetBottomDeviceObject(relationObject, &relationPdo);

                        if (relationPdo != relationObject) {

                            //
                            // Fail the appropriate driver.
                            //
                            WDM_FAIL_ROUTINE((
                                DCERROR_NON_PDO_RETURNED_IN_RELATION,
                                DCPARAM_IRP + DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                                CallerAddress,
                                Irp,
                                relationObject
                                ));
                        }

                        //
                        // Don't blame the next driver that handles the IRP.
                        //
                        IovUtilMarkDeviceObject(
                            relationObject,
                            MARKTYPE_RELATION_PDO_EXAMINED
                            );

                        //
                        // Drop ref
                        //
                        ObDereferenceObject(relationPdo);
                    }

                    break;
            }

            break;
        case IRP_MN_QUERY_INTERFACE:
        case IRP_MN_QUERY_CAPABILITIES:
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            break;
        case IRP_MN_QUERY_DEVICE_TEXT:
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:
        case IRP_MN_EJECT:
        case IRP_MN_SET_LOCK:
        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        case IRP_MN_QUERY_BUS_INFORMATION:

            if ((DevObjType == VF_DEVOBJ_PDO) ||
                (HowProcessed != DEFINITELY_PROCESSED)) {

                break;
            }

            WDM_FAIL_ROUTINE((
                DCERROR_PNP_IRP_HANDS_OFF,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                CallerAddress,
                Irp
                ));

            break;

        case IRP_MN_QUERY_ID:
            switch(IrpSp->Parameters.QueryId.IdType) {

                case BusQueryDeviceID:
                case BusQueryHardwareIDs:
                case BusQueryCompatibleIDs:
                case BusQueryInstanceID:

                    if ((DevObjType == VF_DEVOBJ_PDO) ||
                        (HowProcessed != DEFINITELY_PROCESSED)) {

                        break;
                    }

                    WDM_FAIL_ROUTINE((
                        DCERROR_PNP_IRP_HANDS_OFF,
                        DCPARAM_IRP + DCPARAM_ROUTINE,
                        CallerAddress,
                        Irp
                        ));

                    break;
                default:
                    break;
            }
            break;
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
        case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
            break;
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:

            if ((HowProcessed != NOT_PROCESSED) ||
                (!VfSettingsIsOptionEnabled(VerifierSnapshot,
                VERIFIER_OPTION_EXTENDED_REQUIRED_IRPS))) {

                break;
            }

            WDM_FAIL_ROUTINE((
                DCERROR_PNP_IRP_NEEDS_HANDLING,
                DCPARAM_IRP + DCPARAM_ROUTINE,
                CallerAddress,
                Irp
                ));

            break;

        default:
            break;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfprint.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfprint.h

Abstract:

    This header exposes prototypes required when outputting various data types
    to the debugger.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\ioassert.c

--*/

VOID
VfPrintDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
VfPrintDumpIrp(
    IN PIRP IrpToFlag
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfprint.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vfprint.c

Abstract:

    This module implements support for output of various data types to the
    debugger.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\ioassert.c

--*/

#include "vfdef.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, VfPrintDumpIrpStack)
#pragma alloc_text(PAGEVRFY, VfPrintDumpIrp)
#endif // ALLOC_PRAGMA

VOID
VfPrintDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    )
{
    VfMajorDumpIrpStack(IrpSp);
    DbgPrint("\n");

    DbgPrint(
        "[ DevObj=%p, FileObject=%p, Parameters=%p %p %p %p ]\n",
        IrpSp->DeviceObject,
        IrpSp->FileObject,
        IrpSp->Parameters.Others.Argument1,
        IrpSp->Parameters.Others.Argument2,
        IrpSp->Parameters.Others.Argument3,
        IrpSp->Parameters.Others.Argument4
        );

}


VOID
VfPrintDumpIrp(
    IN PIRP IrpToFlag
    )
{
    PIO_STACK_LOCATION irpSpCur;
    PIO_STACK_LOCATION irpSpNxt;

    //
    // First see if we can touch the IRP header
    //
    if(!VfUtilIsMemoryRangeReadable(IrpToFlag, sizeof(IRP), VFMP_INSTANT)) {
        return;
    }

    //
    // OK, get the next two stack locations...
    //
    irpSpNxt = IoGetNextIrpStackLocation( IrpToFlag );
    irpSpCur = IoGetCurrentIrpStackLocation( IrpToFlag );

    if (VfUtilIsMemoryRangeReadable(irpSpNxt, 2*sizeof(IO_STACK_LOCATION), VFMP_INSTANT)) {

        //
        // Both are present, print the best one!
        //
        if (irpSpNxt->MinorFunction == irpSpCur->MinorFunction) {

            //
            // Looks forwarded
            //
            VfPrintDumpIrpStack(irpSpNxt);

        } else if (irpSpNxt->MinorFunction == 0) {

            //
            // Next location is probably currently zero'd
            //
            VfPrintDumpIrpStack(irpSpCur);

        } else {

            DbgPrint("Next:    >");
            VfPrintDumpIrpStack(irpSpNxt);
            DbgPrint("Current:  ");
            VfPrintDumpIrpStack(irpSpCur);
        }

    } else if (VfUtilIsMemoryRangeReadable(irpSpCur, sizeof(IO_STACK_LOCATION), VFMP_INSTANT)) {

        VfPrintDumpIrpStack(irpSpCur);

    } else if (VfUtilIsMemoryRangeReadable(irpSpNxt, sizeof(IO_STACK_LOCATION), VFMP_INSTANT)) {

        VfPrintDumpIrpStack(irpSpNxt);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfpragma.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    vfpragma.h

Abstract:

    This header contains disable instructions for W4 warnings generated
    by public headers. This way we can still compile modules at W4.

Author:

    Silviu Calinoiu - Nov 14, 2000

Revision History:


--*/

//
// Disable W4 level warnings generated by public headers.
//

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4232)   // dllimport not static
#pragma warning(disable:4206)   // translation unit empty
#pragma warning(disable:4054)   // function pointer to data pointer cast
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfrandom.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfrandom.h

Abstract:

    This header exposes support for random number generation as needed by the
    verifier.

Author:

    Adrian J. Oney (adriao) 28-Jun-2000

Environment:

    Kernel mode

Revision History:

--*/

VOID
VfRandomInit(
    VOID
    );

ULONG
FASTCALL
VfRandomGetNumber(
    IN  ULONG   Minimum,
    IN  ULONG   Maximum
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfrandom.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfrandom.c

Abstract:

    This module implements support for random number generation needed by the
    verifier.

Author:

    Adrian J. Oney (adriao) 28-Jun-2000

Environment:

    Kernel mode

Revision History:

--*/

#include "vfdef.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,     VfRandomInit)
#pragma alloc_text(PAGEVRFY, VfRandomGetNumber)
#endif // ALLOC_PRAGMA


VOID
VfRandomInit(
    VOID
    )
/*++

Routine Description:

    This routine initializes the random number generator, seeing it based on
    the startup time of the machine.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


ULONG
FASTCALL
VfRandomGetNumber(
    IN  ULONG   Minimum,
    IN  ULONG   Maximum
    )
/*++

Routine Description:

    This routine returns a random number in the range [Minimum, Maximum].

Arguments:

    Minimum - Minimum value returnable

    Maximum - Maximum value returnable

Return Value:

    A random number between Minimum and Maximum

--*/
{
    LARGE_INTEGER performanceCounter;

    //
    // This should be replaced with the algorithm from rtl\random.c
    //
    KeQueryPerformanceCounter(&performanceCounter);

    if (Maximum + 1 == Minimum) {

        return performanceCounter.LowPart;

    } else {

        return (performanceCounter.LowPart % (Maximum - Minimum + 1)) + Minimum;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfutil.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfutil.h

Abstract:

    This header contains prototypes for various functions required to do driver
    verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\ioassert.c

--*/

typedef enum {

    VFMP_INSTANT = 0,
    VFMP_INSTANT_NONPAGED

} MEMORY_PERSISTANCE;

BOOLEAN
VfUtilIsMemoryRangeReadable(
    IN PVOID                Location,
    IN size_t               Length,
    IN MEMORY_PERSISTANCE   Persistance
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfstack.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfstack.c

Abstract:

    This module contains code required to verify drivers don't improperly use
    thread stacks.

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode.

--*/

#include "vfdef.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, VfStackSeedStack)
#endif

VOID
FASTCALL
VfStackSeedStack(
    IN  ULONG   Seed
    )
/*++

  Description:

    This routine "seeds" the stack so that uninitialized variables are
    more easily ferreted out.

    Note if the thread subsequently does a usermode wait, the memory
    manager throws out the filled pages on stack swapout and on swapin
    replaces them with randomly filled ones.

  Arguments:

      Seed - Value to seed stack with.

  Return Value:
  
      None.

--*/
{
#if !defined(_WIN64)
    KIRQL oldIrql;
    PKTHREAD Thread;
    PULONG StartingAddress;
    PULONG StackPointer;

    if (!VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_SEEDSTACK)) {
        return;
    }

    Thread = KeGetCurrentThread ();
    StartingAddress = (PULONG) Thread->StackLimit;

    //
    // We are going below the stack pointer.  Make sure no interrupt can occur.
    //

    KeRaiseIrql (HIGH_LEVEL, &oldIrql);

    _asm {
        mov StackPointer, esp
    }

    // 
    // Check the stack bounds and don't fill if some caller is whacking the
    // stack pointer.
    //

    if ((StackPointer <= StartingAddress) || (StackPointer >= (PULONG)Thread->StackBase)) {
        KeLowerIrql (oldIrql);
        return;
    }

    // 
    // We use the return value 0xFFFFFFFF, as it is an illegal return value. We
    // are trying to catch people who don't initialize NTSTATUS, and it's also
    // a good pointer trap too.
    //
    // Note RtlFillMemoryUlong is not used because calling it would use
    // additional stack which we don't want to have to account for in our
    // calculations.
    //

    while (StartingAddress < StackPointer) {
        *StartingAddress = Seed;
        StartingAddress += 1;
    }

    KeLowerIrql (oldIrql);
#else
    UNREFERENCED_PARAMETER (Seed);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfutil.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfutil.c

Abstract:

    This module implements various utilities required to do driver verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\ioassert.c

--*/

#include "vfdef.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, VfUtilIsMemoryRangeReadable)
#endif // ALLOC_PRAGMA

// allow constructions like `((PCHAR)Address)++'
#pragma warning(disable:4213)   // type cast on l-value


BOOLEAN
VfUtilIsMemoryRangeReadable(
    IN PVOID                Location,
    IN size_t               Length,
    IN MEMORY_PERSISTANCE   Persistance
    )
{
    while (((ULONG_PTR)Location & (sizeof(ULONG_PTR)-1)) && (Length > 0)) {

        //
        // Check to determine if the move will succeed before actually performing
        // the operation.
        //
        if (MmIsAddressValid(Location)==FALSE) {
            return FALSE;
        }

        if (Persistance == VFMP_INSTANT_NONPAGED) {

            if (!MmIsNonPagedSystemAddressValid(Location)) {

                return FALSE;
            }
        }

        ((PCHAR) Location)++;
        Length--;
    }

    while (Length > (sizeof(ULONG_PTR)-1)) {

        //
        // Check to determine if the move will succeed before actually performing
        // the operation.
        //
        if (MmIsAddressValid(Location)==FALSE) {
            return FALSE;
        }

        if (Persistance == VFMP_INSTANT_NONPAGED) {

            if (!MmIsNonPagedSystemAddressValid(Location)) {

                return FALSE;
            }
        }

        ((PCHAR) Location) += sizeof(ULONG_PTR);
        Length -= sizeof(ULONG_PTR);
    }

    while (Length > 0) {

        //
        // Check to determine if the move will succeed before actually performing
        // the operation.
        //
        if (MmIsAddressValid(Location)==FALSE) {
            return FALSE;
        }

        if (Persistance == VFMP_INSTANT_NONPAGED) {

            if (!MmIsNonPagedSystemAddressValid(Location)) {

                return FALSE;
            }
        }

        ((PCHAR) Location)++;
        Length--;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfsettings.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfsettings.c

Abstract:

    This module contains code that tracks whether various verifier tests are
    enabled. It also keeps track of various values.

Author:

    Adrian J. Oney (adriao) 31-May-2000

Environment:

    Kernel mode

Revision History:

--*/

#include "vfdef.h"
#include "visettings.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, VfSettingsInit)
#pragma alloc_text(PAGEVRFY, VfSettingsCreateSnapshot)
#pragma alloc_text(PAGEVRFY, VfSettingsGetSnapshotSize)
#pragma alloc_text(PAGEVRFY, VfSettingsIsOptionEnabled)
#pragma alloc_text(PAGEVRFY, VfSettingsSetOption)
#pragma alloc_text(PAGEVRFY, VfSettingsGetValue)
#pragma alloc_text(PAGEVRFY, VfSettingsSetValue)
#endif

#define POOL_TAG_VERIFIER_SETTINGS  'oGfV'

//
// This points to the global list of verifier settings.
//
PVERIFIER_SETTINGS_SNAPSHOT VfSettingsGlobal = NULL;

VOID
FASTCALL
VfSettingsInit(
    IN  ULONG   MmFlags
    )
/*++

  Description:

     This routine is called to initialize the current set of verifier settings.

  Arguments:

     MmFlags - A mask of flags (DRIVER_VERIFIER_xxx) indicating which verifier
               settings should be enabled.

  Return Value:

     None.

--*/
{

    //
    // As this is system startup code, it is one of the very few places where
    // it's ok to use MustSucceed.
    //
    VfSettingsGlobal = (PVERIFIER_SETTINGS_SNAPSHOT) ExAllocatePoolWithTag(
        NonPagedPoolMustSucceed,
        VfSettingsGetSnapshotSize(),
        POOL_TAG_VERIFIER_SETTINGS
        );

    RtlZeroMemory(VfSettingsGlobal, VfSettingsGetSnapshotSize());

    //
    // Set IRP deferral time to 300 us.
    //
    VfSettingsSetValue(NULL, VERIFIER_VALUE_IRP_DEFERRAL_TIME,  10 * 300);

    //
    // Set the IRPs-to-log-per-devobj to 20
    //
    VfSettingsSetValue(NULL, VERIFIER_VALUE_IRPLOG_COUNT, 20);

    if (MmFlags & DRIVER_VERIFIER_IO_CHECKING) {

        VfSettingsSetOption(NULL, VERIFIER_OPTION_EXAMINE_RELATION_PDOS, TRUE);
        VfSettingsSetOption(NULL, VERIFIER_OPTION_TRACK_IRPS, TRUE);
        VfSettingsSetOption(NULL, VERIFIER_OPTION_MONITOR_IRP_ALLOCS, TRUE);
        VfSettingsSetOption(NULL, VERIFIER_OPTION_POLICE_IRPS, TRUE);
        VfSettingsSetOption(NULL, VERIFIER_OPTION_MONITOR_MAJORS, TRUE);

        if (MmFlags & DRIVER_VERIFIER_ENHANCED_IO_CHECKING) {

#if 0
            //
            // These are untested options:
            //
            VfSettingsSetOption(NULL, VERIFIER_OPTION_BUFFER_DIRECT_IO, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_DEFER_COMPLETION, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_COMPLETE_AT_PASSIVE, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_FORCE_PENDING, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_COMPLETE_AT_DISPATCH, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_DETECT_DEADLOCKS, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_VERIFY_DO_FLAGS, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_SMASH_SRBS, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_SURROGATE_IRPS, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_SCRAMBLE_RELATIONS, TRUE);
#endif

            VfSettingsSetOption(NULL, VERIFIER_OPTION_INSERT_WDM_FILTERS, TRUE);

            VfSettingsSetOption(NULL, VERIFIER_OPTION_MONITOR_PENDING_IO, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_SEEDSTACK, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_ROTATE_STATUS, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_CONSUME_ALWAYS, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_MONITOR_REMOVES, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_SEND_BOGUS_WMI_IRPS, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_SEND_BOGUS_POWER_IRPS, TRUE);
            VfSettingsSetOption(NULL, VERIFIER_OPTION_RELATION_IGNORANCE_TEST, TRUE);
        }
    }

    if (MmFlags & DRIVER_VERIFIER_EXPOSE_IRP_HISTORY) {

        VfSettingsSetOption(NULL, VERIFIER_OPTION_TRACK_IRPS, TRUE);
        VfSettingsSetOption(NULL, VERIFIER_OPTION_EXPOSE_IRP_HISTORY, TRUE);
    }

    if (MmFlags & DRIVER_VERIFIER_DMA_VERIFIER) {

        VfSettingsSetOption(NULL, VERIFIER_OPTION_VERIFY_DMA, TRUE);
        VfSettingsSetOption(NULL, VERIFIER_OPTION_DOUBLE_BUFFER_DMA, TRUE);
    }

    if (MmFlags & DRIVER_VERIFIER_HARDWARE_VERIFICATION) {

        VfSettingsSetOption(NULL, VERIFIER_OPTION_HARDWARE_VERIFICATION, TRUE);
    }

    if (MmFlags & DRIVER_VERIFIER_SYSTEM_BIOS_VERIFICATION) {

        VfSettingsSetOption(NULL, VERIFIER_OPTION_SYSTEM_BIOS_VERIFICATION, TRUE);
    }
}


VOID
FASTCALL
VfSettingsCreateSnapshot(
    IN OUT  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot
    )
/*++

  Description:

     This routine creates a snapshot of the current global verifier settings.

  Arguments:

     VerifierSettingsSnapshot - Pointer to an uninitialized block of memory,
                                the size of which is determined by calling
                                VfSettingsGetSnapshotSize.

  Return Value:

     Size of snapshot data in bytes.

--*/
{
    RtlCopyMemory(
        VerifierSettingsSnapshot,
        VfSettingsGlobal,
        VfSettingsGetSnapshotSize()
        );
}


ULONG
FASTCALL
VfSettingsGetSnapshotSize(
    VOID
    )
/*++

  Description:

     This routine returns the size of a snapshot. It allows callers to create
     an appropriate sized buffer for storing verifier settings.

  Arguments:

     None.

  Return Value:

     Size of snapshot data in bytes.

--*/
{
    return (OPTION_SIZE + sizeof(ULONG) * VERIFIER_VALUE_MAX);
}


BOOLEAN
FASTCALL
VfSettingsIsOptionEnabled(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot  OPTIONAL,
    IN  VERIFIER_OPTION             VerifierOption
    )
/*++

  Description:

     This routine determines whether a given verifier option is enabled.

  Arguments:

     VerifierSettingsSnapshot - A snapshot of verifier settings. If NULL the
                                current system-wide verifier setting are used.

     VerifierOption - Option to examine

  Return Value:

     TRUE if option is currently enabled, FALSE otherwise.

--*/
{
    ULONG verifierIndex, verifierMask;
    PULONG verifierData;

    //
    // Bounds check.
    //
    if ((VerifierOption >= VERIFIER_OPTION_MAX) || (VerifierOption == 0)) {

        ASSERT(0);
        return FALSE;
    }

    //
    // Extract appropriate bit.
    //
    verifierIndex = (ULONG) VerifierOption;
    verifierMask = 1 << (verifierIndex % 32);
    verifierIndex /= 32;

    if (VerifierSettingsSnapshot) {

        verifierData = (PULONG) VerifierSettingsSnapshot;

    } else {

        verifierData = (PULONG) VfSettingsGlobal;
    }

    //
    // And now the test.
    //
    return (BOOLEAN)((verifierData[verifierIndex]&verifierMask) != 0);
}


VOID
FASTCALL
VfSettingsSetOption(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot  OPTIONAL,
    IN  VERIFIER_OPTION             VerifierOption,
    IN  BOOLEAN                     Setting
    )
/*++

  Description:

     This routine sets the state of a given verifier option.

  Arguments:

     VerifierSettingsSnapshot - A snapshot of verifier settings. If NULL the
                                current system-wide verifier setting are used.

     VerifierOption - Option to set

     Setting - TRUE if option should be enabled, FALSE otherwise.

  Return Value:

     None.

--*/
{
    ULONG verifierIndex, verifierMask, oldValue, newValue, lastValue;
    PULONG verifierData;

    //
    // Bounds check.
    //
    if ((VerifierOption >= VERIFIER_OPTION_MAX) || (VerifierOption == 0)) {

        ASSERT(0);
        return;
    }

    //
    // Extract appropriate bit.
    //
    verifierIndex = (ULONG) VerifierOption;
    verifierMask = 1 << (verifierIndex % 32);
    verifierIndex /= 32;

    if (VerifierSettingsSnapshot) {

        verifierData = (PULONG) VerifierSettingsSnapshot;

    } else {

        verifierData = (PULONG) VfSettingsGlobal;
    }

    //
    // And now to set the value as atomically as possible.
    //
    do {

        oldValue = verifierData[verifierIndex];
        if (Setting) {

            newValue = oldValue | verifierMask;

        } else {

            newValue = oldValue &= ~verifierMask;
        }

        lastValue = InterlockedExchange((PLONG)(verifierData + verifierIndex), newValue);

    } while ( lastValue != newValue );
}


VOID
FASTCALL
VfSettingsGetValue(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot  OPTIONAL,
    IN  VERIFIER_VALUE              VerifierValue,
    OUT ULONG                       *Value
    )
/*++

  Description:

     This routine retrieves a given verifier value.

  Arguments:

     VerifierSettingsSnapshot - A snapshot of verifier settings. If NULL the
                                current system-wide verifier setting are used.

     VerifierValue - Value to retrieve.

     Value - Receives verifier value (0 if bad VerifierValue was specified.)

  Return Value:

     None.

--*/
{
    PULONG valueArray;

    //
    // Sanity check values
    //
    if ((VerifierValue == 0) || (VerifierValue >= VERIFIER_VALUE_MAX)) {

        *Value = 0;
        return;
    }

    //
    // Get appropriate array
    //
    if (VerifierSettingsSnapshot) {

        valueArray = (PULONG) (((PUCHAR) VerifierSettingsSnapshot) + OPTION_SIZE);

    } else {

        valueArray = (PULONG) (((PUCHAR) VfSettingsGlobal) + OPTION_SIZE);
    }

    //
    // Read out the value.
    //
    *Value = valueArray[VerifierValue];
}


VOID
FASTCALL
VfSettingsSetValue(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot  OPTIONAL,
    IN  VERIFIER_VALUE              VerifierValue,
    IN  ULONG                       Value
    )
/*++

  Description:

     This routine sets the state of a given verifier value.

  Arguments:

     VerifierSettingsSnapshot - A snapshot of verifier settings. If NULL the
                                current system-wide verifier setting are used.

     VerifierValue - Value to set.

     Value - ULONG to store.

  Return Value:

     None.

--*/
{
    PULONG valueArray;

    //
    // Sanity check values
    //
    if ((VerifierValue == 0) || (VerifierValue >= VERIFIER_VALUE_MAX)) {

        return;
    }

    //
    // Get appropriate array
    //
    if (VerifierSettingsSnapshot) {

        valueArray = (PULONG) (((PUCHAR) VerifierSettingsSnapshot) + OPTION_SIZE);

    } else {

        valueArray = (PULONG) (((PUCHAR) VfSettingsGlobal) + OPTION_SIZE);
    }

    //
    // Set the value.
    //
    valueArray[VerifierValue] = Value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfsettings.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfsettings.h

Abstract:

    This header contains prototypes for manipulating verifier options and
    values.

Author:

    Adrian J. Oney (adriao) 31-May-2000

Environment:

    Kernel mode

Revision History:

--*/

typedef PVOID PVERIFIER_SETTINGS_SNAPSHOT;

typedef enum {

    //
    // This option lets the verifer begin tracking all IRPs. It must be enabled
    // for most of the other IRP verification options to work.
    //
    VERIFIER_OPTION_TRACK_IRPS = 1,

    //
    // This option forces all IRPs to be allocated from the special pool.
    // VERIFIER_OPTION_TRACK_IRPS need not be enabled.
    //
    VERIFIER_OPTION_MONITOR_IRP_ALLOCS,

    //
    // This option enables various checks for basic/common IRP handling mistakes.
    //
    VERIFIER_OPTION_POLICE_IRPS,

    //
    // This option enables checks specific to major/minor codes.
    //
    VERIFIER_OPTION_MONITOR_MAJORS,

    //
    // This option causes the call stacks of IRP dispatch and completion
    // routines to be seeded with 0xFFFFFFFF. This value is illegal for a
    // status code, and such seeding flushes out uninitialized variable bugs.
    //
    VERIFIER_OPTION_SEEDSTACK,

    //
    // This option sends a bogus QueryDeviceRelations IRP to newly built stacks.
    // The particular IRP sent is of type -1, and has a -1 passed in for the
    // device list.
    //
    VERIFIER_OPTION_RELATION_IGNORANCE_TEST,

    //
    // This option causes the verifier to stop on unneccessary IRP stack copies.
    // It is useful for optimizing drivers.
    //
    VERIFIER_OPTION_FLAG_UNNECCESSARY_COPIES,

    VERIFIER_OPTION_SEND_BOGUS_WMI_IRPS,
    VERIFIER_OPTION_SEND_BOGUS_POWER_IRPS,

    //
    // If this option is enabled, the verifier makes sure drivers mark the IRP
    // pending if and only if STATUS_PENDING is returned, and visa versa.
    //
    VERIFIER_OPTION_MONITOR_PENDING_IO,

    //
    // If this option is enabled, the verifier makes all IRPs return in an
    // asynchronous manner. Specifically, all IRPs are marked pending, and
    // STATUS_PENDING is returned from every IoCallDriver.
    //
    VERIFIER_OPTION_FORCE_PENDING,

    //
    // If this option is enabled, the verifier will change the status code of
    // successful IRPs to alternate success status's. This catches many IRP
    // forwarding bugs.
    //
    VERIFIER_OPTION_ROTATE_STATUS,

    //
    // If this option is enabled, the verifier will undo the effects of
    // IoSkipCurrentIrpStackLocation so that all stacks appear to be copied.
    // (Exempting the case where an IRP was forwarded to another stack)
    //
    VERIFIER_OPTION_CONSUME_ALWAYS,

    //
    // If this option is enabled, the verifier will update SRB's to handle
    // surrogate IRPs. Some SCSI IRPs can't be surrogated unless the
    // SRB->OriginalRequest pointer is updated. This is due to a busted SRB
    // architecture. Note that the technique used to identify an SRB IRP is
    // "fuzzy", and could in theory touch an IRP it shouldn't have!
    //
    VERIFIER_OPTION_SMASH_SRBS,

    //
    // If this option is enabled, the verifier will replace original IRPs with
    // surrogates when travelling down the stack. The surrogates are allocated
    // from special pool, and get freed immediately upon completion. This lets
    // the verifier catch drivers that touch IRPs after they're completed.
    //
    VERIFIER_OPTION_SURROGATE_IRPS,

    //
    // If this option is enabled, the verifier buffers all direct I/O. It does
    // this by allocating an alternate MDL and copying the MDL contents back
    // to user mode only after IRP completion. This allows overruns, underruns,
    // and late accesses to be detected.
    //
    VERIFIER_OPTION_BUFFER_DIRECT_IO,

    //
    // If this option is enabled, the verifier delays completion of all IRPs
    // via timer. VERIFIER_OPTION_FORCE_PENDING is set by inference.
    //
    VERIFIER_OPTION_DEFER_COMPLETION,

    //
    // If this option is enabled, the verifier completes every IRP at
    // PASSIVE_LEVEL, regardless of major function.
    // VERIFIER_OPTION_FORCE_PENDING is set by inference.
    //
    VERIFIER_OPTION_COMPLETE_AT_PASSIVE,

    //
    // If this option is enabled, the verifier completes every IRP at
    // DISPATCH_LEVEL, regardless of major function.
    //
    VERIFIER_OPTION_COMPLETE_AT_DISPATCH,

    //
    // If this option is enabled, the verifier monitors cancel routines to make
    // sure they are cleared appropriately.
    //
    VERIFIER_OPTION_VERIFY_CANCEL_LOGIC,

    VERIFIER_OPTION_RANDOMLY_CANCEL_IRPS,

    //
    // If this option is enabled, the verifier inserts filter device objects
    // into WDM stacks to ensure IRPs are properly forwarded.
    //
    VERIFIER_OPTION_INSERT_WDM_FILTERS,

    //
    // If this option is enabled, the verifier monitors drivers to ensure they
    // don't send system reserved IRPs to WDM stacks.
    //
    VERIFIER_OPTION_PROTECT_RESERVED_IRPS,

    //
    // If this option is enabled, the verifier walks the entire stack to ensure
    // the DO bits are properly built during AddDevice. This includes the
    // DO_POWER_PAGABLE flag.
    //
    VERIFIER_OPTION_VERIFY_DO_FLAGS,

    //
    // If this option is enabled, the verifier watches Target device relation
    // IRPs to make sure the device object is properly reference counted.
    //
    VERIFIER_OPTION_TEST_TARGET_REFCOUNT,

    //
    // Lets you detect when deadlocks can occur
    //
    VERIFIER_OPTION_DETECT_DEADLOCKS,

    //
    // If this option is enabled, all dma operations will be hooked and
    // validated.
    //
    VERIFIER_OPTION_VERIFY_DMA,

    //
    // This option double buffers all dma and erects guard pages on each side
    // of all common buffers and mapped buffers. Is memory-intensive but can
    // catch hardware buffer overruns and drivers that don't flush adapter
    // buffers.
    //
    VERIFIER_OPTION_DOUBLE_BUFFER_DMA,

    //
    // If this option is enabled, you get notified when the performance counter
    // is being naughty
    //
    VERIFIER_OPTION_VERIFY_PERFORMANCE_COUNTER,

    //
    // If this option is enabled, the verifier checks for implementations of
    // IRP_MN_DEVICE_USAGE_NOTIFICATION and IRP_MN_SURPRISE_REMOVAL. The
    // verifier will also make sure PnP Cancel IRPs are not explicitely failed.
    //
    VERIFIER_OPTION_EXTENDED_REQUIRED_IRPS,

    //
    // If this option is enabled, the verifier mixes up device relations
    // to ensure drivers aren't depending on ordering.
    //
    VERIFIER_OPTION_SCRAMBLE_RELATIONS,

    //
    // If this option is enabled, the verifier ensures proper detaching and
    // deletion occurs on removes and surprise removes.
    //
    VERIFIER_OPTION_MONITOR_REMOVES,

    //
    // If this option is enabled, the verifier ensures device relations only
    // consist of PDO's.
    //
    VERIFIER_OPTION_EXAMINE_RELATION_PDOS,

    //
    // If this option is enabled, the verifier enabled hardware verification
    // (bus specific behavior)
    //
    VERIFIER_OPTION_HARDWARE_VERIFICATION,

    //
    // If this option is enabled, the verifier ensures system BIOS verification
    //
    VERIFIER_OPTION_SYSTEM_BIOS_VERIFICATION,

    //
    // If this option is enabled, the verifier exposes IRP history data that
    // can be used to test for security holes.
    //
    VERIFIER_OPTION_EXPOSE_IRP_HISTORY,

    VERIFIER_OPTION_MAX

} VERIFIER_OPTION;

typedef enum {

    //
    // If VERIFIER_OPTION_DEFER_COMPLETION is set, this value contains the time
    // an IRP will be deferred, in 100us units.
    //
    VERIFIER_VALUE_IRP_DEFERRAL_TIME = 1,

    //
    // This shall be the percentage of allocates to fail during low resource
    // simulation.
    //
    VERIFIER_VALUE_LOW_RESOURCE_PERCENTAGE,

    //
    // If VERIFIER_OPTION_EXPOSE_IRP_HISTORY is set, this value contains the
    // amount of IRPs per device object to log.
    //
    VERIFIER_VALUE_IRPLOG_COUNT,

    VERIFIER_VALUE_MAX

} VERIFIER_VALUE;

VOID
FASTCALL
VfSettingsInit(
    IN  ULONG   MmFlags
    );

BOOLEAN
FASTCALL
VfSettingsIsOptionEnabled(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot  OPTIONAL,
    IN  VERIFIER_OPTION             VerifierOption
    );

VOID
FASTCALL
VfSettingsCreateSnapshot(
    IN OUT  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot
    );

ULONG
FASTCALL
VfSettingsGetSnapshotSize(
    VOID
    );

VOID
FASTCALL
VfSettingsSetOption(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot  OPTIONAL,
    IN  VERIFIER_OPTION             VerifierOption,
    IN  BOOLEAN                     Setting
    );

VOID
FASTCALL
VfSettingsGetValue(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot  OPTIONAL,
    IN  VERIFIER_VALUE              VerifierValue,
    OUT ULONG                       *Value
    );

VOID
FASTCALL
VfSettingsSetValue(
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSettingsSnapshot  OPTIONAL,
    IN  VERIFIER_VALUE              VerifierValue,
    IN  ULONG                       Value
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfstack.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfstack.h

Abstract:

    This header contains prototypes for verifying drivers don't improperly use
    thread stacks.

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\trackirp.h

--*/

VOID
FASTCALL
VfStackSeedStack(
    IN  ULONG   Seed
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfwmi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfwmi.h

Abstract:

    This header contains prototypes for verifying System Control IRPs are
    handled correctly.

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      06/15/2000 - Seperated out from ntos\io\flunkirp.h

--*/

VOID
VfWmiInit(
    VOID
    );

VOID
FASTCALL
VfWmiVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
VfWmiVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    );

VOID
FASTCALL
VfWmiVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    );

VOID
FASTCALL
VfWmiDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
FASTCALL
VfWmiTestStartedPdoStack(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfwmi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vfwmi.c

Abstract:

    This module handles System Control Irp verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

     AdriaO      06/15/2000 - Seperated out from ntos\io\flunkirp.c

--*/

#include "vfdef.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,     VfWmiInit)
#pragma alloc_text(PAGEVRFY, VfWmiDumpIrpStack)
#pragma alloc_text(PAGEVRFY, VfWmiVerifyNewRequest)
#pragma alloc_text(PAGEVRFY, VfWmiVerifyIrpStackDownward)
#pragma alloc_text(PAGEVRFY, VfWmiVerifyIrpStackUpward)
#pragma alloc_text(PAGEVRFY, VfWmiTestStartedPdoStack)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGEVRFC")
#endif

const PCHAR WmiIrpNames[] = {
    "IRP_MN_QUERY_ALL_DATA",                  // 0x00
    "IRP_MN_QUERY_SINGLE_INSTANCE",           // 0x01
    "IRP_MN_CHANGE_SINGLE_INSTANCE",          // 0x02
    "IRP_MN_CHANGE_SINGLE_ITEM",              // 0x03
    "IRP_MN_ENABLE_EVENTS",                   // 0x04
    "IRP_MN_DISABLE_EVENTS",                  // 0x05
    "IRP_MN_ENABLE_COLLECTION",               // 0x06
    "IRP_MN_DISABLE_COLLECTION",              // 0x07
    "IRP_MN_REGINFO",                         // 0x08
    "IRP_MN_EXECUTE_METHOD",                  // 0x09
    NULL
    };

#define MAX_NAMED_WMI_IRP   0x9

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


VOID
VfWmiInit(
    VOID
    )
{
    VfMajorRegisterHandlers(
        IRP_MJ_SYSTEM_CONTROL,
        VfWmiDumpIrpStack,
        VfWmiVerifyNewRequest,
        VfWmiVerifyIrpStackDownward,
        VfWmiVerifyIrpStackUpward,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        VfWmiTestStartedPdoStack,
        NULL
        );
}


VOID
FASTCALL
VfWmiVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    )
{
    PIRP irp = IovPacket->TrackedIrp;
    NTSTATUS currentStatus;

    UNREFERENCED_PARAMETER (IrpSp);
    UNREFERENCED_PARAMETER (IrpLastSp);
    UNREFERENCED_PARAMETER (DeviceObject);

    currentStatus = irp->IoStatus.Status;

    //
    // Verify new IRPs start out life accordingly
    //
    if (currentStatus!=STATUS_NOT_SUPPORTED) {

        WDM_FAIL_ROUTINE((
            DCERROR_WMI_IRP_BAD_INITIAL_STATUS,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            CallerAddress,
            irp
            ));

        //
        // Don't blame anyone else for this guy's mistake.
        //
        if (!NT_SUCCESS(currentStatus)) {

            StackLocationData->Flags |= STACKFLAG_FAILURE_FORWARDED;
        }
    }
}


VOID
FASTCALL
VfWmiVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    )
{
    PIRP irp = IovPacket->TrackedIrp;
    PDRIVER_OBJECT driverObject;
    PIOV_SESSION_DATA iovSessionData;

    UNREFERENCED_PARAMETER (IrpSp);
    UNREFERENCED_PARAMETER (IrpLastSp);

    iovSessionData = VfPacketGetCurrentSessionData(IovPacket);

    //
    // Verify the IRP was forwarded properly
    //
    if (iovSessionData->ForwardMethod == SKIPPED_A_DO) {

        WDM_FAIL_ROUTINE((
            DCERROR_SKIPPED_DEVICE_OBJECT,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            CallerAddress,
            irp
            ));
    }

    //
    // For some IRP major's going down a stack, there *must* be a handler
    //
    driverObject = DeviceObject->DriverObject;

    if (!IovUtilHasDispatchHandler(driverObject, IRP_MJ_SYSTEM_CONTROL)) {

        RequestHeadLocationData->Flags |= STACKFLAG_BOGUS_IRP_TOUCHED;

        WDM_FAIL_ROUTINE((
            DCERROR_MISSING_DISPATCH_FUNCTION,
            DCPARAM_IRP + DCPARAM_ROUTINE,
            driverObject->DriverInit,
            irp
            ));

        StackLocationData->Flags |= STACKFLAG_NO_HANDLER;
    }
}


VOID
FASTCALL
VfWmiVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    )
{
    PIRP irp;
    BOOLEAN mustPassDown, isBogusIrp, isPdo;
    PVOID routine;

    UNREFERENCED_PARAMETER (RequestHeadLocationData);
    UNREFERENCED_PARAMETER (RequestFinalized);

    //
    // Who'd we call for this one?
    //
    irp = IovPacket->TrackedIrp;
    routine = StackLocationData->LastDispatch;
    ASSERT(routine) ;

    //
    // If this "Request" has been "Completed", perform some checks
    //
    if (IsNewlyCompleted) {

        //
        // Remember bogosity...
        //
        isBogusIrp = (BOOLEAN)((IovPacket->Flags&TRACKFLAG_BOGUS)!=0);

        //
        // Is this a PDO?
        //
        isPdo = (BOOLEAN)((StackLocationData->Flags&STACKFLAG_REACHED_PDO)!=0);

        //
        // Was anything completed too early?
        // A driver may outright fail almost anything but a bogus IRP
        //
        mustPassDown = (BOOLEAN)(!(StackLocationData->Flags&STACKFLAG_NO_HANDLER));
        mustPassDown &= (!isPdo);
        mustPassDown &= ((PDEVICE_OBJECT) IrpSp->Parameters.WMI.ProviderId != IrpSp->DeviceObject);
        if (mustPassDown) {

             WDM_FAIL_ROUTINE((
                 DCERROR_WMI_IRP_NOT_FORWARDED,
                 DCPARAM_IRP + DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                 routine,
                 irp,
                 IrpSp->Parameters.WMI.ProviderId
                 ));
        }
    }
}


VOID
FASTCALL
VfWmiDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    )
{
    DbgPrint("IRP_MJ_SYSTEM_CONTROL.");

    if (IrpSp->MinorFunction <= MAX_NAMED_WMI_IRP) {

        DbgPrint(WmiIrpNames[IrpSp->MinorFunction]);

    } else if (IrpSp->MinorFunction == 0xFF) {

        DbgPrint("IRP_MN_BOGUS");

    } else {

        DbgPrint("(Bogus)");
    }
}


VOID
FASTCALL
VfWmiTestStartedPdoStack(
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

    Description:
        As per the title, we are going to throw some IRPs at the stack to
        see if they are handled correctly.

    Returns:

        Nothing
--*/

{
    IO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //
    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    if (VfSettingsIsOptionEnabled(NULL, VERIFIER_OPTION_SEND_BOGUS_WMI_IRPS)) {

        //
        // Send a bogus WMI IRP
        //
        // Note that we shouldn't be sending this IRP to any stack that doesn't
        // terminate with a devnode. The WmiSystemControl export from WmiLib
        // says "NotWmiIrp if it sees these. The callers should still pass down
        // the IRP.
        //
        ASSERT(IovUtilIsPdo(PhysicalDeviceObject));

        irpSp.MajorFunction = IRP_MJ_SYSTEM_CONTROL;
        irpSp.MinorFunction = 0xff;
        irpSp.Parameters.WMI.ProviderId = (ULONG_PTR) PhysicalDeviceObject;
        VfIrpSendSynchronousIrp(
            PhysicalDeviceObject,
            &irpSp,
            TRUE,
            STATUS_NOT_SUPPORTED,
            0,
            NULL,
            NULL
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\viddi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    viddi.h

Abstract:

    This header contains private information used for supplying Verifier Device
    Driver Interfaces. This header should be included only by vfddi.c.

Author:

    Adrian J. Oney (adriao) 1-May-2001

Environment:

    Kernel mode

Revision History:

--*/

typedef struct {

    ULONG   SiloNumber;

} VFWMI_DEVICE_EXTENSION, *PVFWMI_DEVICE_EXTENSION;

VOID
ViDdiThrowException(
    IN      ULONG               BugCheckMajorCode,
    IN      ULONG               BugCheckMinorCode,
    IN      VF_FAILURE_CLASS    FailureClass,
    IN OUT  PULONG              AssertionControl,
    IN      PSTR                DebuggerMessageText,
    IN      PSTR                ParameterFormatString,
    IN      va_list *           MessageParameters
    );

NTSTATUS
ViDdiDriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
ViDdiDispatchWmi(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ViDdiDispatchWmiRegInfoEx(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

ULONG
ViDdiBuildWmiRegInfoData(
    IN  ULONG        Datapath,
    OUT PWMIREGINFOW WmiRegInfo OPTIONAL
    );

NTSTATUS
ViDdiDispatchWmiQueryAllData(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

ULONG
ViDdiBuildWmiInstanceData(
    IN  ULONG           Datapath,
    OUT PWNODE_ALL_DATA WmiData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vigeneric.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vigeneric.h

Abstract:

    This header contains private prototypes for verifying Generic IRPs are
    handled correctly. This file is meant to be included only by vfgeneric.c

Author:

    Adrian J. Oney (adriao) 30-Jun-2000

Environment:

    Kernel mode

Revision History:

--*/

typedef enum {

    NOT_PROCESSED = 0,
    POSSIBLY_PROCESSED,
    DEFINITELY_PROCESSED

} HOW_PROCESSED;

VOID
ViPnpVerifyMinorWasProcessedProperly(
    IN  PIRP                        Irp,
    IN  PIO_STACK_LOCATION          IrpSp,
    IN  VF_DEVOBJ_TYPE              DevObjType,
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSnapshot,
    IN  HOW_PROCESSED               HowProcessed,
    IN  PVOID                       CallerAddress
    );

VOID
FASTCALL
ViGenericDumpIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
FASTCALL
ViGenericVerifyNewRequest(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp           OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
ViGenericVerifyIrpStackDownward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIO_STACK_LOCATION   IrpLastSp                   OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress               OPTIONAL
    );

VOID
FASTCALL
ViGenericVerifyIrpStackUpward(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  RequestHeadLocationData,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN BOOLEAN              IsNewlyCompleted,
    IN BOOLEAN              RequestFinalized
    );

BOOLEAN
FASTCALL
ViGenericIsValidIrpStatus(
    IN PIO_STACK_LOCATION   IrpSp,
    IN NTSTATUS             Status
    );

BOOLEAN
FASTCALL
ViGenericIsNewRequest(
    IN PIO_STACK_LOCATION   IrpLastSp OPTIONAL,
    IN PIO_STACK_LOCATION   IrpSp
    );

VOID
FASTCALL
ViGenericVerifyNewIrp(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp,
    IN PIOV_STACK_LOCATION  StackLocationData,
    IN PVOID                CallerAddress       OPTIONAL
    );

VOID
FASTCALL
ViGenericVerifyFinalIrpStack(
    IN PIOV_REQUEST_PACKET  IovPacket,
    IN PIO_STACK_LOCATION   IrpSp
    );

LOGICAL
FASTCALL
ViGenericBuildIrpLogEntry(
    IN  PIRP                Irp,
    IN  ULONG               CurrentCount,
    IN  PIRPLOG_SNAPSHOT    CurrentEntryArray,
    OUT PIRPLOG_SNAPSHOT    IrpSnapshot
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfzwapi.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

   vfzwapi.c

Abstract:

    Zw interfaces verifier.

Author:

    Silviu Calinoiu (silviuc) 23-Jul-2002


Revision History:

--*/

#include "vfdef.h"
#include "zwapi.h"
#include "vfzwapi.h"

VOID
VfZwCheckAddress (
    PVOID Address,
    PVOID Caller
    );

VOID
VfZwCheckHandle (
    PVOID Handle,
    PVOID Caller
    );

VOID
VfZwCheckObjectAttributes (
    POBJECT_ATTRIBUTES ObjectAttributes,
    PVOID Caller
    );

VOID
VfZwCheckUnicodeString (
    PUNICODE_STRING String,
    PVOID Caller
    );

LOGICAL
VfZwShouldCheck (
    PVOID Caller
    );

VOID
VfZwReportIssue (
    ULONG IssueType,
    PVOID Information,
    PVOID Caller
    );

LOGICAL
VfZwShouldReportIssue (
    PVOID Caller
    );

LOGICAL 
VfZwShouldSimulateDecommitAttack (
    VOID
    );

ULONG
VfZwExceptionFilter (
    PVOID ExceptionInfo
    );

VOID
VfZwReportUserModeVirtualSpaceOperation (
    PVOID Caller
    );

#define VF_ZW_CHECK_ADDRESS(Address) try {VfZwCheckAddress(Address, Caller);}except(VfZwExceptionFilter(_exception_info())){}
#define VF_ZW_CHECK_HANDLE(Handle) try {VfZwCheckHandle(Handle, Caller);}except(VfZwExceptionFilter(_exception_info())){}
#define VF_ZW_CHECK_OBJECT_ATTRIBUTES(A) try {VfZwCheckObjectAttributes(A, Caller);}except(VfZwExceptionFilter(_exception_info())){}
#define VF_ZW_CHECK_UNICODE_STRING(S) try {VfZwCheckUnicodeString(S, Caller);}except(VfZwExceptionFilter(_exception_info())){}

//
// Put all verifier globals into the verifier data section so
// that it can be paged out whenever verifier is not enabled.
// Note that this declaration affects all global declarations
// within the module since there is no `data_seg()' counterpart.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEVRFD")
#endif

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGEVRFY, VfZwShouldCheck)
#pragma alloc_text(PAGEVRFY, VfZwReportIssue)
#pragma alloc_text(PAGEVRFY, VfZwShouldReportIssue)
#pragma alloc_text(PAGEVRFY, VfZwExceptionFilter)
#pragma alloc_text(PAGEVRFY, VfZwReportUserModeVirtualSpaceOperation)
#pragma alloc_text(PAGEVRFY, VfZwShouldSimulateDecommitAttack)
#pragma alloc_text(PAGEVRFY, VfZwCheckAddress)
#pragma alloc_text(PAGEVRFY, VfZwCheckHandle)
#pragma alloc_text(PAGEVRFY, VfZwCheckObjectAttributes)
#pragma alloc_text(PAGEVRFY, VfZwCheckUnicodeString)

#pragma alloc_text(PAGEVRFY, VfZwAccessCheckAndAuditAlarm)
#pragma alloc_text(PAGEVRFY, VfZwAddBootEntry)
#pragma alloc_text(PAGEVRFY, VfZwAddDriverEntry)
#pragma alloc_text(PAGEVRFY, VfZwAdjustPrivilegesToken)
#pragma alloc_text(PAGEVRFY, VfZwAlertThread)
#pragma alloc_text(PAGEVRFY, VfZwAllocateVirtualMemory)
#pragma alloc_text(PAGEVRFY, VfZwAssignProcessToJobObject)
#pragma alloc_text(PAGEVRFY, VfZwCancelIoFile)
#pragma alloc_text(PAGEVRFY, VfZwCancelTimer)
#pragma alloc_text(PAGEVRFY, VfZwClearEvent)
#pragma alloc_text(PAGEVRFY, VfZwClose)
#pragma alloc_text(PAGEVRFY, VfZwCloseObjectAuditAlarm)
#pragma alloc_text(PAGEVRFY, VfZwConnectPort)
#pragma alloc_text(PAGEVRFY, VfZwCreateDirectoryObject)
#pragma alloc_text(PAGEVRFY, VfZwCreateEvent)
#pragma alloc_text(PAGEVRFY, VfZwCreateFile)
#pragma alloc_text(PAGEVRFY, VfZwCreateJobObject)
#pragma alloc_text(PAGEVRFY, VfZwCreateKey)
#pragma alloc_text(PAGEVRFY, VfZwCreateSection)
#pragma alloc_text(PAGEVRFY, VfZwCreateSymbolicLinkObject)
#pragma alloc_text(PAGEVRFY, VfZwCreateTimer)
#pragma alloc_text(PAGEVRFY, VfZwDeleteBootEntry)
#pragma alloc_text(PAGEVRFY, VfZwDeleteDriverEntry)
#pragma alloc_text(PAGEVRFY, VfZwDeleteFile)
#pragma alloc_text(PAGEVRFY, VfZwDeleteKey)
#pragma alloc_text(PAGEVRFY, VfZwDeleteValueKey)
#pragma alloc_text(PAGEVRFY, VfZwDeviceIoControlFile)
#pragma alloc_text(PAGEVRFY, VfZwDisplayString)
#pragma alloc_text(PAGEVRFY, VfZwDuplicateObject)
#pragma alloc_text(PAGEVRFY, VfZwDuplicateToken)
#pragma alloc_text(PAGEVRFY, VfZwEnumerateBootEntries)
#pragma alloc_text(PAGEVRFY, VfZwEnumerateDriverEntries)
#pragma alloc_text(PAGEVRFY, VfZwEnumerateKey)
#pragma alloc_text(PAGEVRFY, VfZwEnumerateValueKey)
#pragma alloc_text(PAGEVRFY, VfZwFlushInstructionCache)
#pragma alloc_text(PAGEVRFY, VfZwFlushKey)
#pragma alloc_text(PAGEVRFY, VfZwFlushVirtualMemory)
#pragma alloc_text(PAGEVRFY, VfZwFreeVirtualMemory)
#pragma alloc_text(PAGEVRFY, VfZwFsControlFile)
#pragma alloc_text(PAGEVRFY, VfZwInitiatePowerAction)
#pragma alloc_text(PAGEVRFY, VfZwIsProcessInJob)
#pragma alloc_text(PAGEVRFY, VfZwLoadDriver)
#pragma alloc_text(PAGEVRFY, VfZwLoadKey)
#pragma alloc_text(PAGEVRFY, VfZwMakeTemporaryObject)
#pragma alloc_text(PAGEVRFY, VfZwMapViewOfSection)
#pragma alloc_text(PAGEVRFY, VfZwModifyBootEntry)
#pragma alloc_text(PAGEVRFY, VfZwModifyDriverEntry)
#pragma alloc_text(PAGEVRFY, VfZwNotifyChangeKey)
#pragma alloc_text(PAGEVRFY, VfZwOpenDirectoryObject)
#pragma alloc_text(PAGEVRFY, VfZwOpenEvent)
#pragma alloc_text(PAGEVRFY, VfZwOpenFile)
#pragma alloc_text(PAGEVRFY, VfZwOpenJobObject)
#pragma alloc_text(PAGEVRFY, VfZwOpenKey)
#pragma alloc_text(PAGEVRFY, VfZwOpenProcess)
#pragma alloc_text(PAGEVRFY, VfZwOpenProcessToken)
#pragma alloc_text(PAGEVRFY, VfZwOpenProcessTokenEx)
#pragma alloc_text(PAGEVRFY, VfZwOpenSection)
#pragma alloc_text(PAGEVRFY, VfZwOpenSymbolicLinkObject)
#pragma alloc_text(PAGEVRFY, VfZwOpenThread)
#pragma alloc_text(PAGEVRFY, VfZwOpenThreadToken)
#pragma alloc_text(PAGEVRFY, VfZwOpenThreadTokenEx)
#pragma alloc_text(PAGEVRFY, VfZwOpenTimer)
#pragma alloc_text(PAGEVRFY, VfZwPowerInformation)
#pragma alloc_text(PAGEVRFY, VfZwPulseEvent)
#pragma alloc_text(PAGEVRFY, VfZwQueryBootEntryOrder)
#pragma alloc_text(PAGEVRFY, VfZwQueryBootOptions)
#pragma alloc_text(PAGEVRFY, VfZwQueryDefaultLocale)
#pragma alloc_text(PAGEVRFY, VfZwQueryDefaultUILanguage)
#pragma alloc_text(PAGEVRFY, VfZwQueryDriverEntryOrder)
#pragma alloc_text(PAGEVRFY, VfZwQueryInstallUILanguage)
#pragma alloc_text(PAGEVRFY, VfZwQueryDirectoryFile)
#pragma alloc_text(PAGEVRFY, VfZwQueryDirectoryObject)
#pragma alloc_text(PAGEVRFY, VfZwQueryEaFile)
#pragma alloc_text(PAGEVRFY, VfZwQueryFullAttributesFile)
#pragma alloc_text(PAGEVRFY, VfZwQueryInformationFile)
#pragma alloc_text(PAGEVRFY, VfZwQueryInformationJobObject)
#pragma alloc_text(PAGEVRFY, VfZwQueryInformationProcess)
#pragma alloc_text(PAGEVRFY, VfZwQueryInformationThread)
#pragma alloc_text(PAGEVRFY, VfZwQueryInformationToken)
#pragma alloc_text(PAGEVRFY, VfZwQueryInformationToken)
#pragma alloc_text(PAGEVRFY, VfZwQueryKey)
#pragma alloc_text(PAGEVRFY, VfZwQueryObject)
#pragma alloc_text(PAGEVRFY, VfZwQuerySection)
#pragma alloc_text(PAGEVRFY, VfZwQuerySecurityObject)
#pragma alloc_text(PAGEVRFY, VfZwQuerySymbolicLinkObject)
#pragma alloc_text(PAGEVRFY, VfZwQuerySystemInformation)
#pragma alloc_text(PAGEVRFY, VfZwQueryValueKey)
#pragma alloc_text(PAGEVRFY, VfZwQueryVolumeInformationFile)
#pragma alloc_text(PAGEVRFY, VfZwReadFile)
#pragma alloc_text(PAGEVRFY, VfZwReplaceKey)
#pragma alloc_text(PAGEVRFY, VfZwRequestWaitReplyPort)
#pragma alloc_text(PAGEVRFY, VfZwResetEvent)
#pragma alloc_text(PAGEVRFY, VfZwRestoreKey)
#pragma alloc_text(PAGEVRFY, VfZwSaveKey)
#pragma alloc_text(PAGEVRFY, VfZwSaveKeyEx)
#pragma alloc_text(PAGEVRFY, VfZwSetBootEntryOrder)
#pragma alloc_text(PAGEVRFY, VfZwSetBootOptions)
#pragma alloc_text(PAGEVRFY, VfZwSetDefaultLocale)
#pragma alloc_text(PAGEVRFY, VfZwSetDefaultUILanguage)
#pragma alloc_text(PAGEVRFY, VfZwSetDriverEntryOrder)
#pragma alloc_text(PAGEVRFY, VfZwSetEaFile)
#pragma alloc_text(PAGEVRFY, VfZwSetEvent)
#pragma alloc_text(PAGEVRFY, VfZwSetInformationFile)
#pragma alloc_text(PAGEVRFY, VfZwSetInformationJobObject)
#pragma alloc_text(PAGEVRFY, VfZwSetInformationObject)
#pragma alloc_text(PAGEVRFY, VfZwSetInformationProcess)
#pragma alloc_text(PAGEVRFY, VfZwSetInformationThread)
#pragma alloc_text(PAGEVRFY, VfZwSetSecurityObject)
#pragma alloc_text(PAGEVRFY, VfZwSetSystemInformation)
#pragma alloc_text(PAGEVRFY, VfZwSetSystemTime)
#pragma alloc_text(PAGEVRFY, VfZwSetTimer)
#pragma alloc_text(PAGEVRFY, VfZwSetValueKey)
#pragma alloc_text(PAGEVRFY, VfZwSetVolumeInformationFile)
#pragma alloc_text(PAGEVRFY, VfZwTerminateJobObject)
#pragma alloc_text(PAGEVRFY, VfZwTerminateProcess)
#pragma alloc_text(PAGEVRFY, VfZwTranslateFilePath)
#pragma alloc_text(PAGEVRFY, VfZwUnloadDriver)
#pragma alloc_text(PAGEVRFY, VfZwUnloadKey)
#pragma alloc_text(PAGEVRFY, VfZwUnmapViewOfSection)
#pragma alloc_text(PAGEVRFY, VfZwWaitForMultipleObjects)
#pragma alloc_text(PAGEVRFY, VfZwWaitForSingleObject)
#pragma alloc_text(PAGEVRFY, VfZwWriteFile)
#pragma alloc_text(PAGEVRFY, VfZwYieldExecution)

#endif
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

//NTSYSAPI
NTSTATUS
NTAPI
VfZwAccessCheckAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {
        
        VF_ZW_CHECK_UNICODE_STRING (SubsystemName);
        VF_ZW_CHECK_UNICODE_STRING (ObjectTypeName);
        VF_ZW_CHECK_UNICODE_STRING (ObjectName);
        VF_ZW_CHECK_ADDRESS (SecurityDescriptor);
        VF_ZW_CHECK_ADDRESS (GenericMapping);
        VF_ZW_CHECK_ADDRESS (GrantedAccess);
        VF_ZW_CHECK_ADDRESS (GenerateOnClose);
    }

    Status = ZwAccessCheckAndAuditAlarm (SubsystemName,
                                         HandleId,
                                         ObjectTypeName,
                                         ObjectName,
                                         SecurityDescriptor,
                                         DesiredAccess,
                                         GenericMapping,
                                         ObjectCreation,
                                         GrantedAccess,
                                         AccessStatus,
                                         GenerateOnClose);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwAddBootEntry (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (BootEntry);
        VF_ZW_CHECK_ADDRESS (Id);
    }

    Status = ZwAddBootEntry (BootEntry,
                             Id);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwAddDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry,
    OUT PULONG Id OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (DriverEntry);
        VF_ZW_CHECK_ADDRESS (Id);
    }

    Status = ZwAddDriverEntry (DriverEntry,
                               Id);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwAdjustPrivilegesToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES NewState OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    OUT PTOKEN_PRIVILEGES PreviousState OPTIONAL,
    OUT PULONG ReturnLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (TokenHandle);
        VF_ZW_CHECK_ADDRESS (NewState);
        VF_ZW_CHECK_ADDRESS (PreviousState);
        VF_ZW_CHECK_ADDRESS (ReturnLength);
    }
    
    Status = ZwAdjustPrivilegesToken (TokenHandle,
                                      DisableAllPrivileges,
                                      NewState OPTIONAL,
                                      BufferLength OPTIONAL,
                                      PreviousState OPTIONAL,
                                      ReturnLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwAlertThread(
    IN HANDLE ThreadHandle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ThreadHandle);
    }
    
    Status = ZwAlertThread (ThreadHandle);
    
    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ProcessHandle);
        VF_ZW_CHECK_ADDRESS (BaseAddress);
        VF_ZW_CHECK_ADDRESS (RegionSize);

        VfZwReportUserModeVirtualSpaceOperation (Caller);
        
        if (VfZwShouldSimulateDecommitAttack() &&
            Protect == PAGE_READWRITE) {

            DbgPrint ("DVRF:ZW: simulating decommit attack for caller %p \n", Caller);
            Protect = PAGE_READONLY;
        }
    }

    Status = ZwAllocateVirtualMemory (ProcessHandle,
                                      BaseAddress,
                                      ZeroBits,
                                      RegionSize,
                                      AllocationType,
                                      Protect);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwAssignProcessToJobObject(
    IN HANDLE JobHandle,
    IN HANDLE ProcessHandle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (JobHandle);
        VF_ZW_CHECK_HANDLE (ProcessHandle);
    }

    Status = ZwAssignProcessToJobObject (JobHandle,
                                         ProcessHandle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwCancelIoFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (FileHandle);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
    }
    
    Status = ZwCancelIoFile (FileHandle,
                             IoStatusBlock);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwCancelTimer (
    IN HANDLE TimerHandle,
    OUT PBOOLEAN CurrentState OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (TimerHandle);
        VF_ZW_CHECK_ADDRESS (CurrentState);
    }
    
    Status = ZwCancelTimer (TimerHandle,
                            CurrentState);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwClearEvent (
    IN HANDLE EventHandle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (EventHandle);
    }
    
    Status = ZwClearEvent (EventHandle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwClose(
    IN HANDLE Handle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (Handle);
    }

    Status = ZwClose (Handle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwCloseObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_UNICODE_STRING (SubsystemName);
    }
    
    Status = ZwCloseObjectAuditAlarm (SubsystemName,
                                      HandleId,
                                      GenerateOnClose);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PPORT_VIEW ClientView OPTIONAL,
    IN OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (PortHandle);
        VF_ZW_CHECK_UNICODE_STRING (PortName);
        VF_ZW_CHECK_ADDRESS (SecurityQos);
        VF_ZW_CHECK_ADDRESS (ClientView);
        VF_ZW_CHECK_ADDRESS (ServerView);
        VF_ZW_CHECK_ADDRESS (MaxMessageLength);
        VF_ZW_CHECK_ADDRESS (ConnectionInformation);
        VF_ZW_CHECK_ADDRESS (ConnectionInformationLength);
    }
    
    Status = ZwConnectPort(PortHandle,
                           PortName,
                           SecurityQos,
                           ClientView OPTIONAL,
                           ServerView OPTIONAL,
                           MaxMessageLength OPTIONAL,
                           ConnectionInformation OPTIONAL,
                           ConnectionInformationLength OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (DirectoryHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
    }
    
    Status = ZwCreateDirectoryObject(DirectoryHandle,
                                     DesiredAccess,
                                     ObjectAttributes);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (EventHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
    }
    
    Status = ZwCreateEvent(EventHandle,
                           DesiredAccess,
                           ObjectAttributes,
                           EventType,
                           InitialState);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (FileHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (AllocationSize);
        VF_ZW_CHECK_ADDRESS (EaBuffer);
    }
    
    Status = ZwCreateFile(FileHandle,
                          DesiredAccess,
                          ObjectAttributes,
                          IoStatusBlock,
                          AllocationSize OPTIONAL,
                          FileAttributes,
                          ShareAccess,
                          CreateDisposition,
                          CreateOptions,
                          EaBuffer OPTIONAL,
                          EaLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (JobHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
    }
    
    Status = ZwCreateJobObject (JobHandle,
                                DesiredAccess,
                                ObjectAttributes);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (KeyHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
        VF_ZW_CHECK_UNICODE_STRING (Class);
        VF_ZW_CHECK_ADDRESS (Disposition);
    }
    
    Status = ZwCreateKey(KeyHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         TitleIndex,
                         Class OPTIONAL,
                         CreateOptions,
                         Disposition OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (SectionHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
        VF_ZW_CHECK_ADDRESS (MaximumSize);
        VF_ZW_CHECK_HANDLE (FileHandle);
    }
    
    Status = ZwCreateSection (SectionHandle,
                              DesiredAccess,
                              ObjectAttributes OPTIONAL,
                              MaximumSize OPTIONAL,
                              SectionPageProtection,
                              AllocationAttributes,
                              FileHandle OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (LinkHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
        VF_ZW_CHECK_UNICODE_STRING (LinkTarget);
    }
    
    Status = ZwCreateSymbolicLinkObject(LinkHandle,
                                        DesiredAccess,
                                        ObjectAttributes,
                                        LinkTarget);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TIMER_TYPE TimerType
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (TimerHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
    }
    
    Status = ZwCreateTimer(TimerHandle,
                           DesiredAccess,
                           ObjectAttributes,
                           TimerType);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteBootEntry (
    IN ULONG Id
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (NULL);
    }
    
    Status = ZwDeleteBootEntry(Id);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteDriverEntry (
    IN ULONG Id
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (NULL);
    }
    
    Status = ZwDeleteDriverEntry(Id);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
    }
    
    Status = ZwDeleteFile(ObjectAttributes);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteKey(
    IN HANDLE KeyHandle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (KeyHandle);
    }
    
    Status = ZwDeleteKey(KeyHandle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (KeyHandle);
        VF_ZW_CHECK_UNICODE_STRING (ValueName);
    }
    
    Status = ZwDeleteValueKey(KeyHandle,
                              ValueName);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (FileHandle);
        VF_ZW_CHECK_HANDLE (Event);
        VF_ZW_CHECK_ADDRESS ((PVOID)ApcRoutine);
        VF_ZW_CHECK_ADDRESS (ApcContext);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (InputBuffer);
        VF_ZW_CHECK_ADDRESS (OutputBuffer);
    }
    
    Status = ZwDeviceIoControlFile(FileHandle,
                                   Event OPTIONAL,
                                   ApcRoutine OPTIONAL,
                                   ApcContext OPTIONAL,
                                   IoStatusBlock,
                                   IoControlCode,
                                   InputBuffer OPTIONAL,
                                   InputBufferLength,
                                   OutputBuffer OPTIONAL,
                                   OutputBufferLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwDisplayString(
    IN PUNICODE_STRING String
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_UNICODE_STRING (String);
    }
    
    Status = ZwDisplayString(String);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwDuplicateObject(
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN HANDLE TargetProcessHandle OPTIONAL,
    OUT PHANDLE TargetHandle OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (SourceProcessHandle);
        VF_ZW_CHECK_HANDLE (SourceHandle);
        VF_ZW_CHECK_HANDLE (TargetProcessHandle);
        VF_ZW_CHECK_ADDRESS (TargetHandle);
    }
    
    Status = ZwDuplicateObject(SourceProcessHandle,
                               SourceHandle,
                               TargetProcessHandle OPTIONAL,
                               TargetHandle OPTIONAL,
                               DesiredAccess,
                               HandleAttributes,
                               Options);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ExistingTokenHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
        VF_ZW_CHECK_ADDRESS (NewTokenHandle);
    }
    
    Status = ZwDuplicateToken (ExistingTokenHandle,
                               DesiredAccess,
                               ObjectAttributes,
                               EffectiveOnly,
                               TokenType,
                               NewTokenHandle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwEnumerateBootEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (Buffer);
        VF_ZW_CHECK_ADDRESS (BufferLength);
    }
    
    Status = ZwEnumerateBootEntries (Buffer,
                                     BufferLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwEnumerateDriverEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (Buffer);
        VF_ZW_CHECK_ADDRESS (BufferLength);
    }
    
    Status = ZwEnumerateDriverEntries (Buffer,
                                       BufferLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (KeyHandle);
        VF_ZW_CHECK_ADDRESS (KeyInformation);
        VF_ZW_CHECK_ADDRESS (ResultLength);
    }
    
    Status = ZwEnumerateKey(KeyHandle,
                            Index,
                            KeyInformationClass,
                            KeyInformation,
                            Length,
                            ResultLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (KeyHandle);
        VF_ZW_CHECK_ADDRESS (KeyValueInformation);
        VF_ZW_CHECK_ADDRESS (ResultLength);
    }
    
    Status = ZwEnumerateValueKey(KeyHandle,
                                 Index,
                                 KeyValueInformationClass,
                                 KeyValueInformation,
                                 Length,
                                 ResultLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwFlushInstructionCache (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress OPTIONAL,
    IN SIZE_T Length
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ProcessHandle);
        VF_ZW_CHECK_ADDRESS (BaseAddress);
    }
    
    Status = ZwFlushInstructionCache (ProcessHandle,
                                      BaseAddress OPTIONAL,
                                      Length);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwFlushKey(
    IN HANDLE KeyHandle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (KeyHandle);
    }
    
    Status = ZwFlushKey (KeyHandle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwFlushVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    OUT PIO_STATUS_BLOCK IoStatus
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ProcessHandle);
        VF_ZW_CHECK_ADDRESS (BaseAddress);
        VF_ZW_CHECK_ADDRESS (RegionSize);
        VF_ZW_CHECK_ADDRESS (IoStatus);
    }
    
    Status = ZwFlushVirtualMemory(ProcessHandle,
                                  BaseAddress,
                                  RegionSize,
                                  IoStatus);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ProcessHandle);
        VF_ZW_CHECK_ADDRESS (BaseAddress);
        VF_ZW_CHECK_ADDRESS (RegionSize);
    }
    
    Status = ZwFreeVirtualMemory (ProcessHandle,
                                  BaseAddress,
                                  RegionSize,
                                  FreeType);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (FileHandle);
        VF_ZW_CHECK_HANDLE (Event);
        VF_ZW_CHECK_ADDRESS ((PVOID)ApcRoutine);
        VF_ZW_CHECK_ADDRESS (ApcContext);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (InputBuffer);
        VF_ZW_CHECK_ADDRESS (OutputBuffer);
    }
    
    Status = ZwFsControlFile(FileHandle,
                             Event OPTIONAL,
                             ApcRoutine OPTIONAL,
                             ApcContext OPTIONAL,
                             IoStatusBlock,
                             FsControlCode,
                             InputBuffer OPTIONAL,
                             InputBufferLength,
                             OutputBuffer OPTIONAL,
                             OutputBufferLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwInitiatePowerAction(
    IN POWER_ACTION SystemAction,
    IN SYSTEM_POWER_STATE MinSystemState,
    IN ULONG Flags,                 // POWER_ACTION_xxx flags
    IN BOOLEAN Asynchronous
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        // no-op call to avoid warnings for `Caller' local.
        VF_ZW_CHECK_ADDRESS (NULL);
    }
    
    Status = ZwInitiatePowerAction(SystemAction,
                                   MinSystemState,
                                   Flags,                 // POWER_ACTION_xxx flags
                                   Asynchronous);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwIsProcessInJob (
    IN HANDLE ProcessHandle,
    IN HANDLE JobHandle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ProcessHandle);
        VF_ZW_CHECK_HANDLE (JobHandle);
    }
    
    Status = ZwIsProcessInJob(ProcessHandle,
                              JobHandle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_UNICODE_STRING (DriverServiceName);
    }
    
    Status = ZwLoadDriver(DriverServiceName);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_OBJECT_ATTRIBUTES (TargetKey);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (SourceFile);
    }
    
    Status = ZwLoadKey(TargetKey,
                       SourceFile);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwMakeTemporaryObject(
    IN HANDLE Handle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (Handle);
    }
    
    Status = ZwMakeTemporaryObject(Handle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (SectionHandle);
        VF_ZW_CHECK_HANDLE (ProcessHandle);
        VF_ZW_CHECK_ADDRESS (BaseAddress);
        VF_ZW_CHECK_ADDRESS (SectionOffset);
        VF_ZW_CHECK_ADDRESS (ViewSize);
        
        VfZwReportUserModeVirtualSpaceOperation (Caller);
        
        if (VfZwShouldSimulateDecommitAttack() &&
            Protect == PAGE_READWRITE) {

            DbgPrint ("DVRF:ZW: simulating unmap attack for caller %p \n", Caller);
            Protect = PAGE_READONLY;
        }
    }
    
    Status = ZwMapViewOfSection(SectionHandle,
                                ProcessHandle,
                                BaseAddress,
                                ZeroBits,
                                CommitSize,
                                SectionOffset OPTIONAL,
                                ViewSize,
                                InheritDisposition,
                                AllocationType,
                                Protect);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwModifyBootEntry (
    IN PBOOT_ENTRY BootEntry
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (BootEntry);
    }
    
    Status = ZwModifyBootEntry (BootEntry);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwModifyDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (DriverEntry);
    }
    
    Status = ZwModifyDriverEntry (DriverEntry);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (KeyHandle);
        VF_ZW_CHECK_HANDLE (Event);
        VF_ZW_CHECK_ADDRESS ((PVOID)ApcRoutine);
        VF_ZW_CHECK_ADDRESS (ApcContext);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (Buffer);
    }
    
    Status = ZwNotifyChangeKey(KeyHandle,
                               Event OPTIONAL,
                               ApcRoutine OPTIONAL,
                               ApcContext OPTIONAL,
                               IoStatusBlock,
                               CompletionFilter,
                               WatchTree,
                               Buffer,
                               BufferSize,
                               Asynchronous);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (DirectoryHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
    }
    
    Status = ZwOpenDirectoryObject(DirectoryHandle,
                                   DesiredAccess,
                                   ObjectAttributes);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (EventHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
    }
    
    Status = ZwOpenEvent(EventHandle,
                         DesiredAccess,
                         ObjectAttributes);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (FileHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
    }
    
    Status = ZwOpenFile(FileHandle,
                        DesiredAccess,
                        ObjectAttributes,
                        IoStatusBlock,
                        ShareAccess,
                        OpenOptions);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenJobObject(
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (JobHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
    }
    
    Status = ZwOpenJobObject(JobHandle,
                             DesiredAccess,
                             ObjectAttributes);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (KeyHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
    }
    
    Status = ZwOpenKey(KeyHandle,
                       DesiredAccess,
                       ObjectAttributes);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (ProcessHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
        VF_ZW_CHECK_ADDRESS (ClientId);
    }
    
    Status = ZwOpenProcess (ProcessHandle,
                            DesiredAccess,
                            ObjectAttributes,
                            ClientId OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ProcessHandle);
        VF_ZW_CHECK_ADDRESS (TokenHandle);
    }
    
    Status = ZwOpenProcessToken(ProcessHandle,
                                DesiredAccess,
                                TokenHandle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenProcessTokenEx(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ProcessHandle);
        VF_ZW_CHECK_ADDRESS (TokenHandle);
    }
    
    Status = ZwOpenProcessTokenEx(ProcessHandle,
                                  DesiredAccess,
                                  HandleAttributes,
                                  TokenHandle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (SectionHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
    }
    
    Status = ZwOpenSection(SectionHandle,
                           DesiredAccess,
                           ObjectAttributes);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (LinkHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
    }
    
    Status = ZwOpenSymbolicLinkObject(LinkHandle,
                                      DesiredAccess,
                                      ObjectAttributes);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (ThreadHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
        VF_ZW_CHECK_ADDRESS (ClientId);
    }
    
    Status = ZwOpenThread (ThreadHandle,
                           DesiredAccess,
                           ObjectAttributes,
                           ClientId OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ThreadHandle);
        VF_ZW_CHECK_ADDRESS (TokenHandle);
    }
    
    Status = ZwOpenThreadToken(ThreadHandle,
                               DesiredAccess,
                               OpenAsSelf,
                               TokenHandle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenThreadTokenEx(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ThreadHandle);
        VF_ZW_CHECK_ADDRESS (TokenHandle);
    }
    
    Status = ZwOpenThreadTokenEx(ThreadHandle,
                                 DesiredAccess,
                                 OpenAsSelf,
                                 HandleAttributes,
                                 TokenHandle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (TimerHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
    }
    
    Status = ZwOpenTimer (TimerHandle,
                          DesiredAccess,
                          ObjectAttributes);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (InputBuffer);
        VF_ZW_CHECK_ADDRESS (OutputBuffer);
    }
    
    Status = ZwPowerInformation(InformationLevel,
                                InputBuffer OPTIONAL,
                                InputBufferLength,
                                OutputBuffer OPTIONAL,
                                OutputBufferLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwPulseEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (EventHandle);
        VF_ZW_CHECK_ADDRESS (PreviousState);
    }
    
    Status = ZwPulseEvent (EventHandle,
                           PreviousState OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryBootEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (Ids);
        VF_ZW_CHECK_ADDRESS (Count);
    }
    
    Status = ZwQueryBootEntryOrder(Ids,
                                   Count);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryBootOptions (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (BootOptions);
        VF_ZW_CHECK_ADDRESS (BootOptionsLength);
    }
    
    Status = ZwQueryBootOptions (BootOptions,
                                 BootOptionsLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDefaultLocale(
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (DefaultLocaleId);
    }
    
    Status = ZwQueryDefaultLocale(UserProfile,
                                  DefaultLocaleId);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDefaultUILanguage(
    OUT LANGID *DefaultUILanguageId
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (DefaultUILanguageId);
    }
    
    Status = ZwQueryDefaultUILanguage(DefaultUILanguageId);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (FileHandle);
        VF_ZW_CHECK_HANDLE (Event);
        VF_ZW_CHECK_ADDRESS ((PVOID)ApcRoutine);
        VF_ZW_CHECK_ADDRESS (ApcContext);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (FileInformation);
        VF_ZW_CHECK_UNICODE_STRING (FileName);
    }
    
    Status = ZwQueryDirectoryFile(FileHandle,
                                  Event OPTIONAL,
                                  ApcRoutine OPTIONAL,
                                  ApcContext OPTIONAL,
                                  IoStatusBlock,
                                  FileInformation,
                                  Length,
                                  FileInformationClass,
                                  ReturnSingleEntry,
                                  FileName OPTIONAL,
                                  RestartScan);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDirectoryObject(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (DirectoryHandle);
        VF_ZW_CHECK_ADDRESS (Buffer);
        VF_ZW_CHECK_ADDRESS (Context);
        VF_ZW_CHECK_ADDRESS (ReturnLength);
    }
    
    Status = ZwQueryDirectoryObject(DirectoryHandle,
                                    Buffer,
                                    Length,
                                    ReturnSingleEntry,
                                    RestartScan,
                                    Context,
                                    ReturnLength OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDriverEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (Ids);
        VF_ZW_CHECK_ADDRESS (Count);
    }
    
    Status = ZwQueryDriverEntryOrder (Ids,
                                      Count);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (FileHandle);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (Buffer);
        VF_ZW_CHECK_ADDRESS (EaList);
        VF_ZW_CHECK_ADDRESS (EaIndex);
    }
    
    Status = ZwQueryEaFile(FileHandle,
                           IoStatusBlock,
                           Buffer,
                           Length,
                           ReturnSingleEntry,
                           EaList OPTIONAL,
                           EaListLength,
                           EaIndex OPTIONAL,
                           RestartScan);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_OBJECT_ATTRIBUTES (ObjectAttributes);
        VF_ZW_CHECK_ADDRESS (FileInformation);
    }
    
    Status = ZwQueryFullAttributesFile(ObjectAttributes,
                                       FileInformation);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (FileHandle);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (FileInformation);
    }
    
    Status = ZwQueryInformationFile(FileHandle,
                                    IoStatusBlock,
                                    FileInformation,
                                    Length,
                                    FileInformationClass);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationJobObject(
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    OUT PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (JobHandle);
        VF_ZW_CHECK_ADDRESS (JobObjectInformation);
        VF_ZW_CHECK_ADDRESS (ReturnLength);
    }
    
    Status = ZwQueryInformationJobObject(JobHandle,
                                         JobObjectInformationClass,
                                         JobObjectInformation,
                                         JobObjectInformationLength,
                                         ReturnLength OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ProcessHandle);
        VF_ZW_CHECK_ADDRESS (ProcessInformation);
        VF_ZW_CHECK_ADDRESS (ReturnLength);
    }
    
    Status = ZwQueryInformationProcess(ProcessHandle,
                                       ProcessInformationClass,
                                       ProcessInformation,
                                       ProcessInformationLength,
                                       ReturnLength OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ThreadHandle);
        VF_ZW_CHECK_ADDRESS (ThreadInformation);
        VF_ZW_CHECK_ADDRESS (ReturnLength);
    }
    
    Status = ZwQueryInformationThread(ThreadHandle,
                                      ThreadInformationClass,
                                      ThreadInformation,
                                      ThreadInformationLength,
                                      ReturnLength OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (TokenHandle);
        VF_ZW_CHECK_ADDRESS (TokenInformation);
        VF_ZW_CHECK_ADDRESS (ReturnLength);
    }
    
    Status = ZwQueryInformationToken (TokenHandle,
                                      TokenInformationClass,
                                      TokenInformation,
                                      TokenInformationLength,
                                      ReturnLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInstallUILanguage(
    OUT LANGID *InstallUILanguageId
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (InstallUILanguageId);
    }
    
    Status = ZwQueryInstallUILanguage(InstallUILanguageId);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (KeyHandle);
        VF_ZW_CHECK_ADDRESS (KeyInformation);
        VF_ZW_CHECK_ADDRESS (ResultLength);
    }
    
    Status = ZwQueryKey(KeyHandle,
                        KeyInformationClass,
                        KeyInformation,
                        Length,
                        ResultLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryObject(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (Handle);
        VF_ZW_CHECK_ADDRESS (ObjectInformation);
        VF_ZW_CHECK_ADDRESS (ReturnLength);
    }
    
    Status = ZwQueryObject(Handle,
                           ObjectInformationClass,
                           ObjectInformation,
                           Length,
                           ReturnLength OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQuerySection(
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN SIZE_T SectionInformationLength,
    OUT PSIZE_T ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (SectionHandle);
        VF_ZW_CHECK_ADDRESS (SectionInformation);
        VF_ZW_CHECK_ADDRESS (ReturnLength);
    }
    
    Status = ZwQuerySection(SectionHandle,
                            SectionInformationClass,
                            SectionInformation,
                            SectionInformationLength,
                            ReturnLength OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQuerySecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (Handle);
        VF_ZW_CHECK_ADDRESS (SecurityDescriptor);
        VF_ZW_CHECK_ADDRESS (LengthNeeded);
    }
    
    Status = ZwQuerySecurityObject(Handle,
                                   SecurityInformation,
                                   SecurityDescriptor,
                                   Length,
                                   LengthNeeded);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQuerySymbolicLinkObject(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (LinkHandle);
        VF_ZW_CHECK_UNICODE_STRING (LinkTarget);
        VF_ZW_CHECK_ADDRESS (ReturnedLength);
    }
    
    Status = ZwQuerySymbolicLinkObject(LinkHandle,
                                       LinkTarget,
                                       ReturnedLength OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (SystemInformation);
        VF_ZW_CHECK_ADDRESS (ReturnLength);
    }
    
    Status = ZwQuerySystemInformation (SystemInformationClass,
                                       SystemInformation,
                                       SystemInformationLength,
                                       ReturnLength OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (KeyHandle);
        VF_ZW_CHECK_UNICODE_STRING (ValueName);
        VF_ZW_CHECK_ADDRESS (KeyValueInformation);
        VF_ZW_CHECK_ADDRESS (ResultLength);
    }
    
    Status = ZwQueryValueKey(KeyHandle,
                             ValueName,
                             KeyValueInformationClass,
                             KeyValueInformation,
                             Length,
                             ResultLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (FileHandle);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (FsInformation);
    }
    
    Status = ZwQueryVolumeInformationFile(FileHandle,
                                          IoStatusBlock,
                                          FsInformation,
                                          Length,
                                          FsInformationClass);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (FileHandle);
        VF_ZW_CHECK_HANDLE (Event);
        VF_ZW_CHECK_ADDRESS ((PVOID)ApcRoutine);
        VF_ZW_CHECK_ADDRESS (ApcContext);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (Buffer);
        VF_ZW_CHECK_ADDRESS (ByteOffset);
        VF_ZW_CHECK_ADDRESS (Key);
    }
    
    Status = ZwReadFile(FileHandle,
                        Event OPTIONAL,
                        ApcRoutine OPTIONAL,
                        ApcContext OPTIONAL,
                        IoStatusBlock,
                        Buffer,
                        Length,
                        ByteOffset OPTIONAL,
                        Key OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE             TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_OBJECT_ATTRIBUTES (NewFile);
        VF_ZW_CHECK_HANDLE (TargetHandle);
        VF_ZW_CHECK_OBJECT_ATTRIBUTES (OldFile);
    }
    
    Status = ZwReplaceKey(NewFile,
                          TargetHandle,
                          OldFile);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwRequestWaitReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (PortHandle);
        VF_ZW_CHECK_ADDRESS (RequestMessage);
        VF_ZW_CHECK_ADDRESS (ReplyMessage);
    }
    
    Status = ZwRequestWaitReplyPort(PortHandle,
                                    RequestMessage,
                                    ReplyMessage);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwResetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (EventHandle);
        VF_ZW_CHECK_ADDRESS (PreviousState);
    }
    
    Status = ZwResetEvent (EventHandle,
                           PreviousState OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Flags
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (KeyHandle);
        VF_ZW_CHECK_HANDLE (FileHandle);
    }
    
    Status = ZwRestoreKey(KeyHandle,
                          FileHandle,
                          Flags);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (KeyHandle);
        VF_ZW_CHECK_HANDLE (FileHandle);
    }
    
    Status = ZwSaveKey(KeyHandle,
                       FileHandle);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSaveKeyEx(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Format
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (KeyHandle);
        VF_ZW_CHECK_HANDLE (FileHandle);
    }
    
    Status = ZwSaveKeyEx(KeyHandle,
                         FileHandle,
                         Format);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetBootEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (Ids);
    }
    
    Status = ZwSetBootEntryOrder (Ids,
                                  Count);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetBootOptions (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (BootOptions);
    }
    
    Status = ZwSetBootOptions (BootOptions,
                               FieldsToChange);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetDefaultLocale(
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        // no-op check to avoid warning for `Caller'.
        VF_ZW_CHECK_ADDRESS (NULL);
    }
    
    Status = ZwSetDefaultLocale(UserProfile,
                                DefaultLocaleId);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetDefaultUILanguage(
    IN LANGID DefaultUILanguageId
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        // no-op check to avoid warning for `Caller'.
        VF_ZW_CHECK_ADDRESS (NULL);
    }
    
    Status = ZwSetDefaultUILanguage(DefaultUILanguageId);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetDriverEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (Ids);
    }
    
    Status = ZwSetDriverEntryOrder (Ids, 
                                    Count);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (FileHandle);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (Buffer);
    }
    
    Status = ZwSetEaFile(FileHandle,
                         IoStatusBlock,
                         Buffer,
                         Length);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (EventHandle);
        VF_ZW_CHECK_ADDRESS (PreviousState);
    }
    
    Status = ZwSetEvent (EventHandle,
                         PreviousState OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (FileHandle);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (FileInformation);
    }
    
    Status = ZwSetInformationFile(FileHandle,
                                  IoStatusBlock,
                                  FileInformation,
                                  Length,
                                  FileInformationClass);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationJobObject(
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    IN PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (JobHandle);
        VF_ZW_CHECK_ADDRESS (JobObjectInformation);
    }
    
    Status = ZwSetInformationJobObject(JobHandle,
                                       JobObjectInformationClass,
                                       JobObjectInformation,
                                       JobObjectInformationLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationObject(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    IN PVOID ObjectInformation,
    IN ULONG ObjectInformationLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (Handle);
        VF_ZW_CHECK_ADDRESS (ObjectInformation);
    }
    
    Status = ZwSetInformationObject(Handle,
                                    ObjectInformationClass,
                                    ObjectInformation,
                                    ObjectInformationLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ProcessHandle);
        VF_ZW_CHECK_ADDRESS (ProcessInformation);
    }
    
    Status = ZwSetInformationProcess(ProcessHandle,
                                     ProcessInformationClass,
                                     ProcessInformation,
                                     ProcessInformationLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ThreadHandle);
        VF_ZW_CHECK_ADDRESS (ThreadInformation);
    }
    
    Status = ZwSetInformationThread(ThreadHandle,
                                    ThreadInformationClass,
                                    ThreadInformation,
                                    ThreadInformationLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetSecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (Handle);
        VF_ZW_CHECK_ADDRESS (SecurityDescriptor);
    }
    
    Status = ZwSetSecurityObject(Handle,
                                 SecurityInformation,
                                 SecurityDescriptor);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (SystemInformation);
    }
    
    Status = ZwSetSystemInformation (SystemInformationClass,
                                     SystemInformation,
                                     SystemInformationLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetSystemTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER PreviousTime OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (SystemTime);
        VF_ZW_CHECK_ADDRESS (PreviousTime);
    }
    
    Status = ZwSetSystemTime (SystemTime,
                              PreviousTime OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
    IN PVOID TimerContext OPTIONAL,
    IN BOOLEAN ResumeTimer,
    IN LONG Period OPTIONAL,
    OUT PBOOLEAN PreviousState OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (TimerHandle);
        VF_ZW_CHECK_ADDRESS (DueTime);
        VF_ZW_CHECK_ADDRESS ((PVOID)TimerApcRoutine);
        VF_ZW_CHECK_ADDRESS (TimerContext);
        VF_ZW_CHECK_ADDRESS (PreviousState);
    }
    
    Status = ZwSetTimer (TimerHandle,
                         DueTime,
                         TimerApcRoutine OPTIONAL,
                         TimerContext OPTIONAL,
                         ResumeTimer,
                         Period OPTIONAL,
                         PreviousState OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (KeyHandle);
        VF_ZW_CHECK_UNICODE_STRING (ValueName);
        VF_ZW_CHECK_ADDRESS (Data);
    }
    
    Status = ZwSetValueKey(KeyHandle,
                           ValueName,
                           TitleIndex OPTIONAL,
                           Type,
                           Data,
                           DataSize);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (FileHandle);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (FsInformation);
    }
    
    Status = ZwSetVolumeInformationFile(FileHandle,
                                        IoStatusBlock,
                                        FsInformation,
                                        Length,
                                        FsInformationClass);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwTerminateJobObject(
    IN HANDLE JobHandle,
    IN NTSTATUS ExitStatus
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (JobHandle);
    }
    
    Status = ZwTerminateJobObject(JobHandle,
                                  ExitStatus);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwTerminateProcess(
    IN HANDLE ProcessHandle OPTIONAL,
    IN NTSTATUS ExitStatus
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ProcessHandle);
    }
    
    Status = ZwTerminateProcess(ProcessHandle OPTIONAL,
                                ExitStatus);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwTranslateFilePath (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputFilePath,
    IN OUT PULONG OutputFilePathLength
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (InputFilePath);
        VF_ZW_CHECK_ADDRESS (OutputFilePath);
        VF_ZW_CHECK_ADDRESS (OutputFilePathLength);
    }
    
    Status = ZwTranslateFilePath (InputFilePath,
                                  OutputType,
                                  OutputFilePath,
                                  OutputFilePathLength);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwUnloadDriver(
    IN PUNICODE_STRING DriverServiceName
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_UNICODE_STRING (DriverServiceName);
    }
    
    Status = ZwUnloadDriver(DriverServiceName);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_OBJECT_ATTRIBUTES (TargetKey);
    }
    
    Status = ZwUnloadKey(TargetKey);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (ProcessHandle);
        VF_ZW_CHECK_ADDRESS (BaseAddress);
    }
    
    Status = ZwUnmapViewOfSection(ProcessHandle,
                                  BaseAddress);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwWaitForMultipleObjects(
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();
    ULONG Index;

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_ADDRESS (Handles);
        VF_ZW_CHECK_ADDRESS (Timeout);

        for (Index = 0; Index < Count; Index += 1) {
            VF_ZW_CHECK_HANDLE (Handles[Index]);
        }
    }
    
    Status = ZwWaitForMultipleObjects(Count,
                                      Handles,
                                      WaitType,
                                      Alertable,
                                      Timeout OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (Handle);
        VF_ZW_CHECK_ADDRESS (Timeout);
    }
    
    Status = ZwWaitForSingleObject(Handle,
                                   Alertable,
                                   Timeout);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        VF_ZW_CHECK_HANDLE (FileHandle);
        VF_ZW_CHECK_HANDLE (Event);
        VF_ZW_CHECK_ADDRESS ((PVOID)ApcRoutine);
        VF_ZW_CHECK_ADDRESS (ApcContext);
        VF_ZW_CHECK_ADDRESS (IoStatusBlock);
        VF_ZW_CHECK_ADDRESS (Buffer);
        VF_ZW_CHECK_ADDRESS (ByteOffset);
        VF_ZW_CHECK_ADDRESS (Key);
    }
    
    Status = ZwWriteFile(FileHandle,
                         Event OPTIONAL,
                         ApcRoutine OPTIONAL,
                         ApcContext OPTIONAL,
                         IoStatusBlock,
                         Buffer,
                         Length,
                         ByteOffset OPTIONAL,
                         Key OPTIONAL);

    return Status;
}

//NTSYSAPI
NTSTATUS
NTAPI
VfZwYieldExecution (
    VOID
    )
{
    NTSTATUS Status;
    PVOID Caller = _ReturnAddress();

    if (VfZwShouldCheck (Caller)) {

        // no-op check to avoid warning for `Caller' local.
        VF_ZW_CHECK_ADDRESS (NULL);
    }
    
    Status = ZwYieldExecution();

    return Status;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

//
// Turns on and off the entire Zw verifier code.
//

LOGICAL VfZwVerifierEnabled = FALSE;

//
// If Zw verifier is on, controls if sessions space drivers are checked.
//

LOGICAL VfZwVerifierSessionEnabled = TRUE;

//
// Do we break for issues?
//

LOGICAL VfZwBreakForIssues = FALSE;

//
// Break for virtual space allocations (alloc/map)?
//

LOGICAL VfZwBreakForVspaceOps = FALSE;

//
// Enable decommitted memory attacks on ZwAlloc/ZwMap users.
//

LOGICAL VfZwEnableSimulatedAttacks = FALSE;

LOGICAL VfZwSystemSufficientlyBooted;

#define VF_ZW_TIME_ONE_SECOND  ((LONGLONG)(1000 * 1000 * 10))
LONGLONG VfZwRequiredTimeSinceBoot = 5 * 60 * VF_ZW_TIME_ONE_SECOND;

PVOID VfZwLastCall;

#define MAX_NO_OF_ISSUES 256
ULONG VfZwReportedIssuesIndex;
PVOID VfZwReportedIssues[MAX_NO_OF_ISSUES];

#define VF_ZW_USER_MODE_ADDRESS_USED 1
#define VF_ZW_USER_MODE_HANDLE_USED  2

LOGICAL
VfZwShouldCheck (
    PVOID Caller
    )
{
    PEPROCESS CurrentProcess;

    if (VfZwVerifierEnabled == FALSE) {
        return FALSE;
    }

    //
    // Skip system process.
    //

    CurrentProcess = PsGetCurrentProcess();

    if (CurrentProcess == PsInitialSystemProcess) {
        return FALSE;
    }

    //
    // Check if we want to skip session space drivers (e.g. win32k.sys). 
    //

    if (MmIsSessionAddress(Caller)) {
        if (VfZwVerifierSessionEnabled == FALSE) {
            return FALSE;
        }
    }

    //
    // Skip exempt (trusted) processes (e.g. lsass, csrss, etc.).
    //

    if (_stricmp ((PCHAR)CurrentProcess->ImageFileName, "lsass.exe") == 0) {
        return FALSE;
    }

    if (_stricmp ((PCHAR)CurrentProcess->ImageFileName, "csrss.exe") == 0) {
        return FALSE;
    }
    
    if (_stricmp ((PCHAR)CurrentProcess->ImageFileName, "smss.exe") == 0) {
        return FALSE;
    }
    
    return TRUE;
}

VOID
VfZwReportIssue (
    ULONG IssueType,
    PVOID Information,
    PVOID Caller
    )
{
    switch (IssueType) {
        
        case VF_ZW_USER_MODE_HANDLE_USED: 
            DbgPrint ("DVRF:ZW: Using user mode handle %p in Zw call from %p \n", 
                      Information, Caller);
            break;

        case VF_ZW_USER_MODE_ADDRESS_USED:
            DbgPrint ("DVRF:ZW: Using user mode address %p in Zw call from %p \n", 
                      Information, Caller);
            break;

        default: 
            return;
    }

    if (VfZwBreakForIssues) {
        DbgBreakPoint ();
    }
}

LOGICAL
VfZwShouldReportIssue (
    PVOID Caller
    )
{
    ULONG Index;

    for (Index = 0; Index < VfZwReportedIssuesIndex; Index += 1) {

        if (VfZwReportedIssues[Index] == Caller) {
            return FALSE;
        }
    }
    
    Index = (ULONG)InterlockedIncrement((PLONG)(&VfZwReportedIssuesIndex));

    if (Index >= MAX_NO_OF_ISSUES) {
        DbgPrint ("DVRF:ZW: reported issues buffer has been maxed out. \n");
        return FALSE;
    }

    VfZwReportedIssues[Index] = Caller;
    return TRUE;
}

VOID
VfZwReportUserModeVirtualSpaceOperation (
    PVOID Caller
    )
{
    if (VfZwBreakForVspaceOps) {
        
        DbgPrint ("DVRF:ZW: user-mode virtual space allocation made by %p \n", Caller);
        DbgBreakPoint();
    }
}

LOGICAL 
VfZwShouldSimulateDecommitAttack (
    VOID
    )
{
    LARGE_INTEGER CurrentTime;

    if (VfZwEnableSimulatedAttacks == FALSE) {
        return FALSE;
    }
    
    if (VfZwSystemSufficientlyBooted == FALSE) {

        KeQuerySystemTime (&CurrentTime);                         

        if (CurrentTime.QuadPart > KeBootTime.QuadPart + VfZwRequiredTimeSinceBoot) {
            VfZwSystemSufficientlyBooted = TRUE;
        }                                       
    }
    else {

        KeQueryTickCount(&CurrentTime);

        if ((CurrentTime.LowPart & 0xF) == 0) {
            return TRUE;
        }
    }
    
    return FALSE;
}

ULONG
VfZwExceptionFilter (
    PVOID ExceptionInfo
    )
{
    DbgPrint("DVRF:ZW: exception raised! (info: %X) \n", ExceptionInfo);
    DbgBreakPoint();
    return EXCEPTION_EXECUTE_HANDLER;

}

VOID
VfZwCheckAddress (
    PVOID Address,
    PVOID Caller
    )
{
    if (Address == NULL) {
        return;
    }
    
    VfZwLastCall = _ReturnAddress();

    if ((ULONG_PTR)Address < (ULONG_PTR)(MM_HIGHEST_USER_ADDRESS)) {

        if (VfZwShouldReportIssue (Caller)) {

            VfZwReportIssue (VF_ZW_USER_MODE_ADDRESS_USED,
                             Address,
                             Caller);
        }
    }
}

VOID
VfZwCheckHandle (
    PVOID Handle,
    PVOID Caller
    )
{
    if (Handle == NULL) {
        return;
    }

    VfZwLastCall = _ReturnAddress();

//
//  Macro inspired from ntos\ob\obp.h
//  A kernel handle is just a regular handle with its sign
//  bit set.  But must exclude -1 and -2 values which are the current
//  process and current thread constants.
//

#define KERNEL_HANDLE_MASK ((ULONG_PTR)((LONG)0x80000000))

    if ((KERNEL_HANDLE_MASK & (ULONG_PTR)(Handle)) != KERNEL_HANDLE_MASK) {

        if (Handle != NtCurrentThread() &&
            Handle != NtCurrentProcess()) {
            
            if (VfZwShouldReportIssue (Caller)) {

                VfZwReportIssue (VF_ZW_USER_MODE_HANDLE_USED,
                                 Handle,
                                 Caller);
            }
        }
    }
}

VOID
VfZwCheckObjectAttributes (
    POBJECT_ATTRIBUTES ObjectAttributes,
    PVOID Caller
    )
{
    if (ObjectAttributes == NULL) {
        return;
    }
    
    VfZwLastCall = _ReturnAddress();

    VfZwCheckAddress (ObjectAttributes, Caller);
    VfZwCheckHandle (ObjectAttributes->RootDirectory, Caller);
    VfZwCheckUnicodeString (ObjectAttributes->ObjectName, Caller);
    VfZwCheckAddress (ObjectAttributes->SecurityDescriptor, Caller);
    VfZwCheckAddress (ObjectAttributes->SecurityQualityOfService, Caller);
}

VOID
VfZwCheckUnicodeString (
    PUNICODE_STRING String,
    PVOID Caller
    )
{
    if (String == NULL) {
        return;
    }
    
    VfZwLastCall = _ReturnAddress();

    VfZwCheckAddress (String, Caller);
    VfZwCheckAddress (String->Buffer, Caller);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEVRFD")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vihal.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   vihal.h

Abstract:

    This module contains the private declarations to verify hal usage & apis.

Author:

    Jordan Tigani (jtigani) 12-Nov-1999

Revision History:

    6-23-00: (jtigani) Moved from halverifier.c

--*/


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////// Hal verifier defines
/////////////////////////////////////////////////////////////////////



// 
// Bugcheck codes -- the major code is HAL_VERIFIER_DETECTED_VIOLATION --
// the sub-code is the HV_* 
//
#define HAL_VERIFIER_DETECTED_VIOLATION	 0xE6

#define HV_MISCELLANEOUS_ERROR					0x00
#define HV_PERFORMANCE_COUNTER_DECREASED		0x01
#define HV_PERFORMANCE_COUNTER_SKIPPED			0x02
#define HV_FREED_TOO_MANY_COMMON_BUFFERS		0x03
#define HV_FREED_TOO_MANY_ADAPTER_CHANNELS		0x04
#define HV_FREED_TOO_MANY_MAP_REGISTERS			0x05
#define HV_FREED_TOO_MANY_SCATTER_GATHER_LISTS	0x06
#define HV_LEFTOVER_COMMON_BUFFERS				0x07
#define HV_LEFTOVER_ADAPTER_CHANNELS			0x08
#define HV_LEFTOVER_MAP_REGISTERS				0x09
#define HV_LEFTOVER_SCATTER_GATHER_LISTS		0x0A
#define HV_TOO_MANY_ADAPTER_CHANNELS			0x0B
#define HV_TOO_MANY_MAP_REGISTERS				0x0C
#define HV_DID_NOT_FLUSH_ADAPTER_BUFFERS		0x0D
#define HV_DMA_BUFFER_NOT_LOCKED				0x0E
#define HV_BOUNDARY_OVERRUN						0x0F
#define HV_CANNOT_FREE_MAP_REGISTERS			0x10
#define HV_DID_NOT_PUT_ADAPTER					0x11
#define HV_MDL_FLAGS_NOT_SET					0x12
#define HV_BAD_IRQL								0x13
#define HV_BAD_IRQL_JUST_WARN					0x14
#define HV_OUT_OF_MAP_REGISTERS					0x15
#define HV_FLUSH_EMPTY_BUFFERS					0x16
#define HV_MISMATCHED_MAP_FLUSH                 0x17
#define HV_ADAPTER_ALREADY_RELEASED             0x18
#define HV_NULL_DMA_ADAPTER                     0x19
#define HV_MAP_FLUSH_NO_TRANSFER                0x1A
#define HV_ADDRESS_NOT_IN_MDL                   0x1b
#define HV_DATA_LOSS                            0x1c
#define HV_DOUBLE_MAP_REGISTER                  0x1d
#define HV_OBSOLETE_API                         0x1e
#define HV_BAD_MDL                              0x1f
#define HV_FLUSH_NOT_MAPPED                     0x20
#define HV_MAP_ZERO_LENGTH_BUFFER               0x21

///
// Codes to decide what to do when we hit a driver problem.
///
#define HVC_IGNORE			0x00	// Do nothing.
#define HVC_WARN			0x02	// Print message # continue
#define HVC_ASSERT			0x04	// Print message # break
#define HVC_BUGCHECK		0x08	// Print message # bugcheck
#define HVC_ONCE			0x10	// combined with another code, 

#define HAL_VERIFIER_POOL_TAG 'VlaH' // HalV backwards //

//
// This is how we can recognize our double buffers
//
#define MAP_REGISTER_FILL_CHAR  0x0E
#define PADDING_FILL_CHAR       0x0F


//
// Since we hook the "MapRegisterBase" with a MapRegisterFile, we sign 
// the first four bytes so we can tell the difference between the HAL's
// map register base and our map register file.
//
#define MRF_SIGNATURE 0xACEFD00D

//
// This is what we use if the hal has returned a NULL map register base so
// that drivers don't assume that they don't have flush adapter buffers.
//
#define MRF_NULL_PLACEHOLDER (PVOID)(LONG_PTR)(LONG)0xDEADF00D

//
// This should devide evenly into 2^32
//
#define MAX_COUNTERS 0x20

//
// Flags to indicate where the buffer tagging shall happen
//
#define TAG_BUFFER_START  0x01
#define TAG_BUFFER_END    0x02

//
// How many map registers we can double-buffer at once
// using physical contiguous memory.
// This must be an integral multiple of the number of bits in a ULONG
//
#define MAX_CONTIGUOUS_MAP_REGISTERS     0x20

//
// Flags that describe a map register
//
#define MAP_REGISTER_WRITE    0x01  // the transfer is a write to device
#define MAP_REGISTER_READ     0x02  // the transfer is a read from device

#define MAP_REGISTER_RW_MASK (MAP_REGISTER_WRITE | MAP_REGISTER_READ)

/////////////////////////////////////////////////////////////////////
//////////////////////// Safe multi-processor 64 bit reads and writes
/////////////////////////////////////////////////////////////////////

#if defined (_X86_)

//
// Only save the time stamp counter on x86 machines
//
#define ViRdtsc ViRdtscX86

//
// Structure to do a locked 64 bit write /compare without
// a spinlock.
//
typedef struct _TIMER64  {
	ULONG TimeLow;
	ULONG TimeHigh1;
	ULONG TimeHigh2;
	ULONG Reserved; // for packing sake //
} TIMER64, *PTIMER64;

//
// Since we can't do a 64 bit atomic operation
// without a spinlock, we have to monkey around a bit
// This method comes from the acpi timer code. 
//
#define SAFE_READ_TIMER64(WriteLargeInteger, ReadTimer64) 					\
								 											\
    while (TRUE) {					 										\
        (WriteLargeInteger).HighPart = (ReadTimer64).TimeHigh2;				\
        (WriteLargeInteger).LowPart  = (ReadTimer64).TimeLow;				\
							 												\
        if ((ULONG)(WriteLargeInteger).HighPart == (ReadTimer64).TimeHigh1) \
		break; 							\
			  						    \
        _asm { rep nop }; 				\
    }

#define SAFE_WRITE_TIMER64(WriteTimer64, ReadLargeInteger)	\
	WriteTimer64.TimeHigh1 =  (ReadLargeInteger).HighPart;	\
	WriteTimer64.TimeLow   =  (ReadLargeInteger).LowPart;	\
	WriteTimer64.TimeHigh2 =  (ReadLargeInteger).HighPart;

// defined (_X86_) //
#else
// ! defined (_X86_) //

#if defined(_IA64_)
#define ViRdtsc ViRdtscIA64
#else  // !_IA64_
//
// Only save the time stamp counter on x86 and ia64 machines
//
#define ViRdtsc ViRdtscNull
#endif // !_IA64_

//
// Alpha or IA64 can do atomic 64 bit read/writes. 
//
typedef LARGE_INTEGER TIMER64;


#define SAFE_READ_TIMER64(WriteLargeInteger, ReadTimer64)		\
    InterlockedExchangePointer(                  \
    &((PVOID) (WriteLargeInteger).QuadPart ),   \
    (PVOID) (ReadTimer64).QuadPart              \
    );
#define SAFE_WRITE_TIMER64(WriteTimer64, ReadLargeInteger)		\
    InterlockedExchangePointer(                 \
    &((PVOID) (WriteTimer64).QuadPart ),        \
    (PVOID) (ReadLargeInteger).QuadPart         \
    );	

// ! defined (_X86_) //
#endif



/////////////////////////////////////////////////////////////////////
///////////////////////////////////////// Hal verifier global externs
/////////////////////////////////////////////////////////////////////

extern ULONG   VfVerifyDma;
extern LOGICAL VfVerifyPerformanceCounter;
extern LOGICAL ViDoubleBufferDma;
extern LOGICAL ViProtectBuffers;
extern LOGICAL ViInjectDmaFailures;
extern LOGICAL ViSuperDebug;
extern LOGICAL ViSufficientlyBootedForPcControl;
extern LOGICAL ViSufficientlyBootedForDmaFailure;
extern ULONG ViMaxMapRegistersPerAdapter;
extern ULONG ViAllocationsFailedDeliberately;
extern LARGE_INTEGER ViRequiredTimeSinceBoot;
extern CHAR ViDmaVerifierTag[];
extern BOOLEAN ViPenalties[];

extern struct _HAL_VERIFIER_LOCKED_LIST  ViAdapterList;
extern struct _VF_TIMER_INFORMATION    * ViTimerInformation;
extern struct _DMA_OPERATIONS ViDmaOperations;
extern struct _DMA_OPERATIONS ViLegacyDmaOperations;



/////////////////////////////////////////////////////////////////////
////////////////////////////////// Hal verifier structure definitions
/////////////////////////////////////////////////////////////////////

typedef struct _TIMER_TICK {
	ULONG Processor;
	ULONG Reserved;
	LARGE_INTEGER TimeStampCounter;
	LARGE_INTEGER PerformanceCounter;
	LARGE_INTEGER TimerTick;	
} TIMER_TICK, *PTIMER_TICK;

typedef struct _VF_TIMER_INFORMATION {
	KDPC RefreshDpc;    
	KTIMER RefreshTimer;    

	TIMER64 LastPerformanceCounter;
	TIMER64 UpperBound;
    TIMER64 LastTickCount;
    TIMER64 LastKdStartTime;
	
	LARGE_INTEGER PerformanceFrequency;

	ULONG CountsPerTick;
	
	ULONG CurrentCounter;
	TIMER_TICK SavedTicks[MAX_COUNTERS];	


} VF_TIMER_INFORMATION, *PVF_TIMER_INFORMATION;


typedef struct _HAL_VERIFIER_LOCKED_LIST {
	LIST_ENTRY ListEntry;
	KSPIN_LOCK SpinLock;
} HAL_VERIFIER_LOCKED_LIST, *PHAL_VERIFIER_LOCKED_LIST;


typedef struct _HAL_VERIFIER_BUFFER {
	USHORT PrePadBytes;
    USHORT PostPadBytes;

	ULONG RealLength;
	ULONG AdvertisedLength;

	PVOID RealStartAddress;	
    PVOID AdvertisedStartAddress;

	PHYSICAL_ADDRESS RealLogicalStartAddress;

	PVOID AllocatorAddress;

	LIST_ENTRY ListEntry;
} HAL_VERIFIER_BUFFER, *PHAL_VERIFIER_BUFFER;

typedef struct _MAP_REGISTER {    
	PVOID MappedToSa;
    ULONG BytesMapped;
    ULONG Flags;
	PVOID MapRegisterStart;

} MAP_REGISTER, *PMAP_REGISTER;

typedef struct _MAP_REGISTER_FILE {
	ULONG Signature;
	LIST_ENTRY ListEntry;	    
    BOOLEAN ContiguousMap;    
    BOOLEAN ScatterGather;
	ULONG NumberOfMapRegisters;    
	ULONG NumberOfRegistersMapped;

    PVOID MapRegisterBaseFromHal;
	PMDL  MapRegisterMdl;
	PVOID MapRegisterBuffer;
   PVOID OriginalBuffer;
	KSPIN_LOCK AllocationLock;
	MAP_REGISTER MapRegisters[1];
	
	// Rest of the map registers go here
	//
} MAP_REGISTER_FILE, *PMAP_REGISTER_FILE;


typedef struct _VF_WAIT_CONTEXT_BLOCK {
	PVOID RealContext;
	PVOID RealCallback;
    PMDL  RealMdl;
    PVOID RealStartVa;
    ULONG RealLength;

	ULONG NumberOfMapRegisters;

	struct _ADAPTER_INFORMATION * AdapterInformation;

    PSCATTER_GATHER_LIST ScatterGatherList;
    LIST_ENTRY ListEntry;

    PMAP_REGISTER_FILE MapRegisterFile;	


} VF_WAIT_CONTEXT_BLOCK, *PVF_WAIT_CONTEXT_BLOCK;

//
// Needed to allocate storage for the MDL is Get/BuildScatterGatherList
// We declare this structure so we will not worry about alignment issues...
//
typedef struct _VF_WAIT_CONTEXT_BLOCK_EX {
  VF_WAIT_CONTEXT_BLOCK;
  MDL            Mdl;
} VF_WAIT_CONTEXT_BLOCK_EX, *PVF_WAIT_CONTEXT_BLOCK_EX;

//
// Store a list of the real dma operations used by an adapter ...
// when the driver allocates the adapter, we're going to replace all of its 
// dma operations with ours
//
typedef struct _ADAPTER_INFORMATION {	
	LIST_ENTRY ListEntry;
	PDMA_ADAPTER DmaAdapter;
	PDEVICE_OBJECT DeviceObject;

	BOOLEAN DeferredRemove; 	    
	BOOLEAN UseContiguousBuffers;
	BOOLEAN UseDmaChannel;
	BOOLEAN Inactive; 

	PVOID CallingAddress;

	PDMA_OPERATIONS RealDmaOperations;
	
	HAL_VERIFIER_LOCKED_LIST ScatterGatherLists;
	HAL_VERIFIER_LOCKED_LIST CommonBuffers;
	HAL_VERIFIER_LOCKED_LIST MapRegisterFiles;

	ULONG MaximumMapRegisters;

	ULONG AllocatedMapRegisters;
	LONG  ActiveMapRegisters;

	ULONG AllocatedScatterGatherLists;
	LONG  ActiveScatterGatherLists;

	ULONG AllocatedCommonBuffers;
	ULONG FreedCommonBuffers;

	ULONG AllocatedAdapterChannels; // Must be 1 or less ! //
	ULONG FreedAdapterChannels;

	ULONG MappedTransferWithoutFlushing;
	DEVICE_DESCRIPTION DeviceDescription; 

	ULONG AdapterChannelMapRegisters;

	VF_WAIT_CONTEXT_BLOCK AdapterChannelContextBlock;

   PVOID  *ContiguousBuffers; // array of contiguous 3-page buffers to be used for double-buffering

   ULONG  SuccessfulContiguousAllocations; // how many times we allocated contiguous space
   ULONG  FailedContiguousAllocations; // how many times we failed to allocate contiguous space

   KSPIN_LOCK AllocationLock;  // lock for our allocator routines

   ULONG  AllocationStorage[MAX_CONTIGUOUS_MAP_REGISTERS / (sizeof(ULONG) * 8)];  // bitmask for allocator routines

   RTL_BITMAP AllocationMap;  

   ULONG  ContiguousMapRegisters; // allocated among ContiguousBufers
   ULONG  NonContiguousMapRegisters; // allocated from non-Paged Pool


} ADAPTER_INFORMATION, *PADAPTER_INFORMATION;



/////////////////////////////////////////////////////////////////////
////////////////////////////////// Hal verifier function declarations
/////////////////////////////////////////////////////////////////////


//==========================
// Declare our dma apis here
// if NO_LEGACY_DRIVERS *is*
// enabled
// =========================

#if defined(NO_LEGACY_DRIVERS)
VOID
VfPutDmaAdapter(
    struct _DMA_ADAPTER * DmaAdapter
    );


PVOID
VfAllocateCommonBuffer(
    IN struct _DMA_ADAPTER * DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

VOID
VfFreeCommonBuffer(
    IN struct _DMA_ADAPTER * DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

NTSTATUS
VfAllocateAdapterChannel(
    IN struct _DMA_ADAPTER * DmaAdapter,
    IN PDEVICE_OBJECT  DeviceObject,
    IN ULONG  NumberOfMapRegisters,
    IN PDRIVER_CONTROL  ExecutionRoutine,
    IN PVOID  Context
    );

PHYSICAL_ADDRESS
VfMapTransfer(
    IN struct _DMA_ADAPTER *  DmaAdapter,
    IN PMDL  Mdl,
    IN PVOID  MapRegisterBase,
    IN PVOID  CurrentVa,
    IN OUT PULONG  Length,
    IN BOOLEAN  WriteToDevice
    );

BOOLEAN
VfFlushAdapterBuffers(
    IN struct _DMA_ADAPTER * DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

VOID
VfFreeAdapterChannel(
    IN struct _DMA_ADAPTER * DmaAdapter
    );

VOID
VfFreeMapRegisters(
    IN struct _DMA_ADAPTER * DmaAdapter,
    PVOID MapRegisterBase,
    ULONG NumberOfMapRegisters
    );

ULONG
VfGetDmaAlignment(
    IN struct _DMA_ADAPTER * DmaAdapter
    );
    

ULONG
VfReadDmaCounter(
    IN struct _DMA_ADAPTER *  DmaAdapter
    );

NTSTATUS
VfGetScatterGatherList (
    IN struct _DMA_ADAPTER * DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PVOID ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    );

VOID
VfPutScatterGatherList(
    IN struct _DMA_ADAPTER * DmaAdapter,
    IN struct _SCATTER_GATHER_LIST * ScatterGather,
    IN BOOLEAN WriteToDevice
    );

#endif


// =====================
// New verified dma apis
// =====================


NTSTATUS
VfCalculateScatterGatherListSize(
     IN PDMA_ADAPTER DmaAdapter,
     IN OPTIONAL PMDL Mdl,
     IN PVOID CurrentVa,
     IN ULONG Length,
     OUT PULONG  ScatterGatherListSize,
     OUT OPTIONAL PULONG pNumberOfMapRegisters
     );

NTSTATUS
VfBuildScatterGatherList(
     IN PDMA_ADAPTER DmaAdapter,
     IN PDEVICE_OBJECT DeviceObject,
     IN PMDL Mdl,
     IN PVOID CurrentVa,
     IN ULONG Length,
     IN PDRIVER_LIST_CONTROL ExecutionRoutine,
     IN PVOID Context,
     IN BOOLEAN WriteToDevice,
     IN PVOID   ScatterGatherBuffer,
     IN ULONG   ScatterGatherLength
     );

NTSTATUS
VfBuildMdlFromScatterGatherList(
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    );

IO_ALLOCATION_ACTION
VfAdapterCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

VOID
VfScatterGatherCallback(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN struct _SCATTER_GATHER_LIST * ScatterGather,
    IN PVOID Context
    );

// =================================
// Hook for HalpAllocateMapRegisters
// =================================
NTSTATUS
VfHalAllocateMapRegisters(
    IN PADAPTER_OBJECT DmaAdapter,
    IN ULONG NumberOfMapRegisters,
    IN ULONG BaseAddressCount,
    OUT PMAP_REGISTER_ENTRY MapRegisterArray
    );




// ==============================
// Hal verifier internal routines 
// ==============================

PADAPTER_INFORMATION
ViHookDmaAdapter(
	IN PDMA_ADAPTER DmaAdapter,
	IN PDEVICE_DESCRIPTION DeviceDescription,
	IN ULONG NumberOfMapRegisters	
	);

VOID
ViReleaseDmaAdapter(
	IN PADAPTER_INFORMATION AdapterInformation
	);

PADAPTER_INFORMATION
ViGetAdapterInformation(
	IN PDMA_ADAPTER DmaAdapter
	);

PVOID 
ViGetRealDmaOperation(
	IN PDMA_ADAPTER DmaAdapter, 
	IN ULONG AdapterInformationOffset
	);

LARGE_INTEGER
ViRdtsc(
    VOID
    );

VOID
VfInitializeTimerInformation(
    VOID
    );

VOID
ViRefreshCallback(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

LOGICAL
VfInjectDmaFailure (
    VOID
    );


// =================================================
// Hal verfier special routines to track allocations
// =================================================

PVOID 
ViSpecialAllocateCommonBuffer(
	IN PALLOCATE_COMMON_BUFFER AllocateCommonBuffer,
	IN PADAPTER_INFORMATION AdapterInformation,
	IN PVOID CallingAddress,
	IN ULONG Length,
	IN OUT PPHYSICAL_ADDRESS LogicalAddress,	
	IN LOGICAL CacheEnabled
	);
LOGICAL 
ViSpecialFreeCommonBuffer(
	IN PFREE_COMMON_BUFFER FreeCommonBuffer,
	IN PADAPTER_INFORMATION AdapterInformation,
	IN PVOID CommonBuffer,
	LOGICAL CacheEnabled
	);

// ===================================================
// Hal verfier special routines to do double buffering
// ===================================================

PMAP_REGISTER_FILE
ViAllocateMapRegisterFile(
	IN PADAPTER_INFORMATION AdapterInformation,		
	IN ULONG NumberOfMapRegisters	
	);
LOGICAL
ViFreeMapRegisterFile(
	IN PADAPTER_INFORMATION AdapterInformation,	
	IN PMAP_REGISTER_FILE MapRegisterFile	
	);

ULONG
ViMapDoubleBuffer(
    IN PMAP_REGISTER_FILE MapRegisterFile,
	IN OUT PMDL   Mdl,	
	IN OUT PVOID CurrentVa,
	IN ULONG Length,
	IN BOOLEAN WriteToDevice
	);

LOGICAL 
ViFlushDoubleBuffer(
    IN PMAP_REGISTER_FILE MapRegisterFile,
	IN PMDL  Mdl,	
	IN PVOID CurrentVa,
	IN ULONG Length,
	IN BOOLEAN WriteToDevice
	);

LOGICAL
ViAllocateMapRegistersFromFile(
	IN PMAP_REGISTER_FILE MapRegisterFile,
    IN PVOID CurrentSa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice,
    OUT PULONG MapRegisterNumber
    );


LOGICAL
ViFreeMapRegistersToFile(
	IN PMAP_REGISTER_FILE MapRegisterFile, 	
	IN PVOID CurrentSa, 
	IN ULONG Length
	);

PMAP_REGISTER
ViFindMappedRegisterInFile(
	IN PMAP_REGISTER_FILE MapRegisterFile, 
	IN PVOID CurrentSa,
    OUT PULONG MapRegisterNumber OPTIONAL
	);

LOGICAL
ViSwap(IN OUT PVOID * MapRegisterBase, 
        IN OUT PMDL  * Mdl,
        IN OUT PVOID * CurrentVa
        );

VOID
ViCheckAdapterBuffers( 
    IN PADAPTER_INFORMATION AdapterInformation 
    );

VOID
ViTagBuffer(    
    IN PVOID  AdvertisedBuffer, 
    IN ULONG  AdvertisedLength,
    IN USHORT WhereToTag
    );

VOID
ViCheckTag(    
    IN PVOID   AdvertisedBuffer, 
    IN ULONG   AdvertisedLength,
    IN BOOLEAN RemoveTag,
    IN USHORT  WhereToCheck 
    );


VOID
ViInitializePadding(
    IN PVOID RealBufferStart,
    IN ULONG RealBufferLength,
    IN PVOID AdvertisedBufferStart, OPTIONAL 
    IN ULONG AdvertisedBufferLength OPTIONAL
    );

VOID
ViCheckPadding(
    IN PVOID RealBufferStart,
    IN ULONG RealBufferLength,
    IN PVOID AdvertisedBufferStart, OPTIONAL 
    IN ULONG AdvertisedBufferLength OPTIONAL
    );

PULONG_PTR
ViHasBufferBeenTouched(
    IN PVOID Address,
    IN ULONG_PTR Length,
    IN UCHAR ExpectedFillChar
    );

VOID
VfAssert(
    IN LOGICAL     Condition,    
    IN ULONG       Code,
    IN OUT PULONG  Enable
    );

VOID
ViMapTransferHelper(
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG TransferLength,
    IN PULONG PageFrame,
    IN OUT PULONG Length
    );

VOID
ViCommonBufferCalculatePadding(
    IN  ULONG  Length,
    OUT PULONG PrePadding,
    OUT PULONG PostPadding
    );

VOID
ViAllocateContiguousMemory (
    IN OUT PADAPTER_INFORMATION AdapterInformation
    );

PVOID
ViAllocateFromContiguousMemory (
    IN OUT PADAPTER_INFORMATION AdapterInformation,
    IN     ULONG HintIndex
    );

LOGICAL
ViFreeToContiguousMemory (
    IN OUT PADAPTER_INFORMATION AdapterInformation,
    IN     PVOID Address,
    IN     ULONG HintIndex
    ); 

LOGICAL
VfIsPCIBus (
     IN PDEVICE_OBJECT  PhysicalDeviceObject
     );

PDEVICE_OBJECT
VfGetPDO (
     IN PDEVICE_OBJECT  DeviceObject
     );


VOID
ViCopyBackModifiedBuffer (
     OUT PUCHAR  Dest,
     IN  PUCHAR  Source,
     IN  PUCHAR  Original,
     IN  SIZE_T  Length
     );


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////// Hal verifier macros
/////////////////////////////////////////////////////////////////////

//
// This is a kind of long macro but it lets us decide what to
// do on certain kinds of errors. For instance, if we know
// we are going to hit something once, we might set it to
// HVC_WARN. Or if we know we will hit it 1000 times, but don't
// want to take the code out completely (especially if we're doing
// it on the fly), we can set it to HVC_IGNORE
//
#define VF_ASSERT(condition, code, message)				\
{												        \
    static ULONG enable = (ULONG) -1;                   \
    if (enable == (ULONG) -1)                           \
        enable = ViPenalties[code];                    \
    if (!(condition) && enable)                            \
    {                                                   \
        DbgPrint("* * * * * * * * HAL Verifier Detected Violation * * * * * * * *\n");\
        DbgPrint("* *\n");                              \
        DbgPrint("* * VF: ");                           \
        DbgPrint message;						        \
        DbgPrint("\n");	                                \
        DbgPrint("* *\n");                              \
        DbgPrint("* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n");\
                                                        \
        VfAssert(condition, code,  &enable);            \
    }                                                   \
}

// 
// Old favorite:
//
// Control macro (used like a for loop) which iterates over all entries in
// a standard doubly linked list.  Head is the list head and the entries 
// are of type Type.  A member called ListEntry is assumed to be the 
// LIST_ENTRY structure linking the entries together. Current contains a 
// pointer to each entry in turn.
//
#define FOR_ALL_IN_LIST(Type, Head, Current)                            \
    for((Current) = CONTAINING_RECORD((Head)->Flink, Type, ListEntry);  \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = CONTAINING_RECORD((Current)->ListEntry.Flink,        \
                                     Type,                              \
                                     ListEntry)                         \
       )


#ifndef MIN	
    #define MIN(a,b) ( ( (ULONG) (a)<(ULONG) (b))?(a):(b) )
#endif

#define NOP


#define VF_INITIALIZE_LOCKED_LIST(LockedList)							\
	KeInitializeSpinLock(&(LockedList)->SpinLock);						\
	InitializeListHead(&(LockedList)->ListEntry);

#define VF_LOCK_LIST(ListToLock, OldIrql)								\
	KeAcquireSpinLock(&(ListToLock)->SpinLock, &OldIrql)

#define VF_UNLOCK_LIST(ListToUnlock, OldIrql)							\
	KeReleaseSpinLock(&(ListToUnlock)->SpinLock, OldIrql)


#define VF_IS_LOCKED_LIST_EMPTY(LockedList)							\
	IsListEmpty( &(LockedList)->ListEntry )

#define VF_ADD_TO_LOCKED_LIST(LockedList, AddMe)						\
	ExInterlockedInsertHeadList(										\
		&(LockedList)->ListEntry,										\
		&(AddMe)->ListEntry,											\
		&(LockedList)->SpinLock )

#define VF_REMOVE_FROM_LOCKED_LIST(LockedList, RemoveMe)				\
{																		\
	KIRQL OldIrql;														\
	VF_LOCK_LIST((LockedList), OldIrql);								\
	RemoveEntryList(&(RemoveMe)->ListEntry);							\
	VF_UNLOCK_LIST((LockedList), OldIrql);							\
}

#define VF_REMOVE_FROM_LOCKED_LIST_DONT_LOCK(LockedList, RemoveMe)		\
	RemoveEntryList(&(RemoveMe)->ListEntry);							
		

//
// This is a bit of a hack so that reference counting for adapters will work.
// If the device uses a dma channel, the HAL wants to keep it around.
// There is a bit of funky logic that goes on to determine whether
// a device uses an adapter channel so I've included it here, free of
// charge.
//
#define VF_DOES_DEVICE_USE_DMA_CHANNEL(deviceDescription)			\
	(																\
	 ( (deviceDescription)->InterfaceType == Isa  &&				\
		(deviceDescription)->DmaChannel < 8 ) ||					\
	 ! (deviceDescription)->Master )

#define VF_DOES_DEVICE_REQUIRE_CONTIGUOUS_BUFFERS(deviceDescription)	\
	( !(deviceDescription)->Master || ! (deviceDescription)->ScatterGather )



#define DMA_OFFSET(DmaOperationsField) \
	FIELD_OFFSET(DMA_OPERATIONS, DmaOperationsField)

#define DMA_INDEX(DmaOperations, Offset)            \
    (PVOID)                                         \
			*(  (PVOID *)                           \
				(  ( (PUCHAR) (DmaOperations) ) +   \
                (Offset)  ) )


#define SIGN_MAP_REGISTER_FILE(MapRegisterFile)								\
	(MapRegisterFile)->Signature = MRF_SIGNATURE;

#define VALIDATE_MAP_REGISTER_FILE_SIGNATURE(MapRegisterFile )				\
	((MapRegisterFile) && (MapRegisterFile)->Signature == MRF_SIGNATURE )



//
// System dependent way to get the caller's address
//
#if defined(_X86_)

#define GET_CALLING_ADDRESS(CallingAddress)						\
{																\
	PVOID callersCaller;										\
	RtlGetCallersAddress(&CallingAddress, &callersCaller);		\
}
#else // ! defined(_X86_) //

#define GET_CALLING_ADDRESS(CallingAddress)						\
    CallingAddress = (PVOID)_ReturnAddress();
#endif // ! defined(_X86_)


//
// From a map register file, map register number and the corresponding system address,
// return the corresponding mapped address in system space.
//
#define MAP_REGISTER_SYSTEM_ADDRESS(MapRegisterFile, DriverCurrentSa, MapRegisterNumber)    \
    (PUCHAR)  (MapRegisterFile)->MapRegisterBuffer +                                        \
	( (MapRegisterNumber) << PAGE_SHIFT ) +                                                 \
	BYTE_OFFSET(DriverCurrentSa)


//
// From a map register file's OriginalBuffer, map register number and system address
// returns the address in the original buffer. Used to do a 3-way merge between
// the driver's buffer, verifier's buffer (passed to the hardware) and the original
// buffer
//
#define ORIGINAL_BUFFER_SYSTEM_ADDRESS(MapRegisterFile, DriverCurrentSa, MapRegisterNumber)    \
    (PUCHAR)  (MapRegisterFile)->OriginalBuffer +                                        \
	( (MapRegisterNumber) << PAGE_SHIFT ) +                                                 \
	BYTE_OFFSET(DriverCurrentSa)

//
// From a map register file, map register number and the corresponding system address,
// return the corresponding mapped address as an index into the map register file's
// MDL (i.e virtual address).
//
	
#define MAP_REGISTER_VIRTUAL_ADDRESS(MapRegisterFile, DriverCurrentSa, MapRegisterNumber)   \
	(PUCHAR) MmGetMdlVirtualAddress((MapRegisterFile)->MapRegisterMdl) +                    \
    ( (MapRegisterNumber) << PAGE_SHIFT ) +                                                 \
	BYTE_OFFSET(DriverCurrentSa)



/////////////////////////////////////////////////////////////////////
//////////////////////////// Hal verifier inline function definitions
/////////////////////////////////////////////////////////////////////

//
// Since so many people don't raise the irql when they put the dma adapter,
// just warn them.
//

__inline 
VOID
VF_ASSERT_SPECIAL_IRQL(IN KIRQL Irql)
{

	KIRQL currentIrql = KeGetCurrentIrql();
	VF_ASSERT(
		currentIrql == Irql,
		HV_BAD_IRQL_JUST_WARN,
		("**** Bad IRQL -- needed %x, got %x ****", 
        (ULONG) Irql, (ULONG) currentIrql)
	);
	
} // VF_ASSERT_IRQL //


__inline 
VOID
VF_ASSERT_IRQL(IN KIRQL Irql)
{
	KIRQL currentIrql = KeGetCurrentIrql();
	VF_ASSERT(
		currentIrql == Irql,
		HV_BAD_IRQL,
		("**** Bad IRQL -- needed %x, got %x ****", 
        (ULONG) Irql, (ULONG) currentIrql)
	);
	
} // VF_ASSERT_IRQL //

__inline 
VOID 
VF_ASSERT_MAX_IRQL(IN KIRQL MaxIrql)
{
	KIRQL currentIrql = KeGetCurrentIrql();
	
	VF_ASSERT(
		currentIrql <= MaxIrql,
		HV_BAD_IRQL,
		("**** Bad IRQL -- needed %x or less, got %x ****", 
        (ULONG) MaxIrql, (ULONG) currentIrql)
	);	
}

// =========================================
// Inlined functions to help with accounting
// =========================================
__inline 
VOID 
ADD_MAP_REGISTERS(
	IN PADAPTER_INFORMATION AdapterInformation, 
	IN ULONG NumberOfMapRegisters,
    IN BOOLEAN ScatterGather
	)
{
	ULONG activeMapRegisters = 
	InterlockedExchangeAdd(
			&AdapterInformation->ActiveMapRegisters,
			NumberOfMapRegisters
			) + NumberOfMapRegisters;
		
   InterlockedExchangeAdd((PLONG)(&AdapterInformation->AllocatedMapRegisters), 
                          NumberOfMapRegisters);
	    
	VF_ASSERT(
		NumberOfMapRegisters <= AdapterInformation->MaximumMapRegisters,
		HV_TOO_MANY_MAP_REGISTERS,
		( "Allocating too many map registers at a time: %x (max %x)", 
			NumberOfMapRegisters,
			AdapterInformation->MaximumMapRegisters )	
		);
	
    if (! ScatterGather ) {
        VF_ASSERT(
            activeMapRegisters <= AdapterInformation->MaximumMapRegisters,
            HV_OUT_OF_MAP_REGISTERS,
            ( "Allocated too many map registers : %x (max %x)", 
               activeMapRegisters,
               AdapterInformation->MaximumMapRegisters	)
            );
    }

	
} // ADD_MAP_REGISTERS //

__inline 
VOID 
SUBTRACT_MAP_REGISTERS(
	IN PADAPTER_INFORMATION AdapterInformation, 
	IN ULONG NumberOfMapRegisters
	)
{
	LONG activeMapRegisters =
		InterlockedExchangeAdd(
			&AdapterInformation->ActiveMapRegisters,
			-((LONG) NumberOfMapRegisters)
			) - NumberOfMapRegisters;
	
	
	VF_ASSERT(
		activeMapRegisters >= 0,
		HV_FREED_TOO_MANY_MAP_REGISTERS,
		( "Freed too many map registers: %x", 
			activeMapRegisters )
		);
	
    InterlockedExchange((PLONG)(&AdapterInformation->MappedTransferWithoutFlushing), 
                        0);    

} // SUBTRACT_MAP_REGISTERS //


__inline 
VOID 
INCREMENT_COMMON_BUFFERS(
	IN PADAPTER_INFORMATION AdapterInformation
	)
{	
	InterlockedIncrement((PLONG)(&AdapterInformation->AllocatedCommonBuffers) );

} // INCREMENT_COMMON_BUFFERS //

__inline 
VOID 
DECREMENT_COMMON_BUFFERS(
	IN PADAPTER_INFORMATION AdapterInformation
	)
{
	ULONG commonBuffersFreed = 
		(ULONG) InterlockedIncrement( 
        (PLONG)(&AdapterInformation->FreedCommonBuffers) );
	
	
	VF_ASSERT(
		commonBuffersFreed <= AdapterInformation->AllocatedCommonBuffers,
		HV_FREED_TOO_MANY_COMMON_BUFFERS,
		("Freed too many common buffers")
		);			
	
} // DECREMENT_COMMON_BUFFERS //

__inline 
VOID 
INCREASE_MAPPED_TRANSFER_BYTE_COUNT(
	IN PADAPTER_INFORMATION AdapterInformation,	
	IN ULONG Length
	)
{	
	ULONG mappedTransferCount;
   ULONG maxMappedTransfer;

   maxMappedTransfer = AdapterInformation->ActiveMapRegisters << PAGE_SHIFT;

   mappedTransferCount =
		InterlockedExchangeAdd( 
            (PLONG)(&AdapterInformation->MappedTransferWithoutFlushing),
			(LONG) Length
			) + Length;

	

	VF_ASSERT(
		mappedTransferCount <= maxMappedTransfer,
		HV_DID_NOT_FLUSH_ADAPTER_BUFFERS,
		("Driver did not flush adapter buffers -- bytes mapped: %x (%x max)",
			mappedTransferCount,
			maxMappedTransfer 
		));
	
} // INCREASE_MAPPED_TRANSFER_BYTE_COUNT //

__inline 
VOID 
DECREASE_MAPPED_TRANSFER_BYTE_COUNT(
	IN PADAPTER_INFORMATION AdapterInformation,	
	IN ULONG Length
	)
{	
    UNREFERENCED_PARAMETER (Length);

	InterlockedExchange( 
		(PLONG)(&AdapterInformation->MappedTransferWithoutFlushing),
		0);

		
} // DECREASE_MAPPED_TRANSFER_BYTE_COUNT //



__inline 
VOID 
INCREMENT_ADAPTER_CHANNELS(
	IN PADAPTER_INFORMATION AdapterInformation
	)
{

	ULONG allocatedAdapterChannels = (ULONG)
			InterlockedIncrement( 
            (PLONG)(&AdapterInformation->AllocatedAdapterChannels) );

	VF_ASSERT(
		allocatedAdapterChannels == 
            AdapterInformation->FreedAdapterChannels + 1,
		HV_TOO_MANY_ADAPTER_CHANNELS,
		( "Driver has allocated too many simultaneous adapter channels"
		));
	
	
} // INCREMENT_ADAPTER_CHANNELS //


__inline 
VOID 
DECREMENT_ADAPTER_CHANNELS(
	IN PADAPTER_INFORMATION AdapterInformation
	)
{
	ULONG adapterChannelsFreed = (ULONG)
		InterlockedIncrement( (PLONG)(&AdapterInformation->FreedAdapterChannels) );
	
	VF_ASSERT(
		adapterChannelsFreed == AdapterInformation->AllocatedAdapterChannels,
		HV_FREED_TOO_MANY_ADAPTER_CHANNELS,
		( "Driver has freed too many simultaneous adapter channels"
		));
	
} // DECREMENT_ADAPTER_CHANNELS //


_inline 
VOID 
INCREMENT_SCATTER_GATHER_LISTS(
	IN PADAPTER_INFORMATION AdapterInformation
	)
{	
	InterlockedIncrement( (PLONG)(&AdapterInformation->AllocatedScatterGatherLists) );
   InterlockedIncrement( &AdapterInformation->ActiveScatterGatherLists);

} // INCREMENT_SCATTER_GATHER_LISTS //

__inline 
VOID 
DECREMENT_SCATTER_GATHER_LISTS (
	IN PADAPTER_INFORMATION AdapterInformation
	)
{
	LONG activeScatterGatherLists = InterlockedDecrement( 
              &AdapterInformation->ActiveScatterGatherLists );
	

	VF_ASSERT(
		activeScatterGatherLists >= 0,
		HV_FREED_TOO_MANY_SCATTER_GATHER_LISTS,
		( "Driver has freed too many scatter gather lists %x allocated, %x freed",
        AdapterInformation->AllocatedScatterGatherLists, 
        AdapterInformation->AllocatedScatterGatherLists - 
        activeScatterGatherLists)
		);

} // DECREMENT_SCATTER_GATHER_LISTS //

__inline 
VOID 
VERIFY_BUFFER_LOCKED(
	IN PMDL Mdl	
	)
{    	
	VF_ASSERT(
		MmAreMdlPagesLocked(Mdl),
		HV_DMA_BUFFER_NOT_LOCKED,
		( "DMA Pages Not Locked! MDL %p for DMA not locked",  Mdl)
		);			


} // VERIFY_BUFFER_LOCKED //



__inline
PHAL_VERIFIER_BUFFER
VF_FIND_BUFFER (
	IN PHAL_VERIFIER_LOCKED_LIST LockedList, 
	IN PVOID AdvertisedStartAddress
	)
{
	PHAL_VERIFIER_BUFFER verifierBuffer;
	KIRQL OldIrql;

	VF_LOCK_LIST(LockedList, OldIrql);
	FOR_ALL_IN_LIST(HAL_VERIFIER_BUFFER, 
        &LockedList->ListEntry, 
        verifierBuffer ) {

		if ((PUCHAR) verifierBuffer->RealStartAddress + 
               verifierBuffer->PrePadBytes == AdvertisedStartAddress) {
			VF_UNLOCK_LIST(LockedList, OldIrql);
			return verifierBuffer;
		}
	}
	VF_UNLOCK_LIST(LockedList, OldIrql);
	return NULL;
} // VF_FIND_BUFFER //


__inline
PADAPTER_INFORMATION
VF_FIND_DEVICE_INFORMATION(
	IN PDEVICE_OBJECT DeviceObject
	)
{
	PADAPTER_INFORMATION adapterInformation;
	KIRQL OldIrql;

	VF_LOCK_LIST(&ViAdapterList, OldIrql);
	FOR_ALL_IN_LIST(ADAPTER_INFORMATION, &ViAdapterList.ListEntry, adapterInformation) {

		if (adapterInformation->DeviceObject == DeviceObject) {
			VF_UNLOCK_LIST(&ViAdapterList, OldIrql);
			return adapterInformation;
		}
	}

	VF_UNLOCK_LIST(&ViAdapterList, OldIrql);
	return NULL;
} // VF_FIND_DEVICE_INFORMATION //

__inline
PADAPTER_INFORMATION
VF_FIND_INACTIVE_ADAPTER(
	IN PDEVICE_OBJECT DeviceObject
	)
{
	PADAPTER_INFORMATION adapterInformation;
	KIRQL OldIrql;

	VF_LOCK_LIST(&ViAdapterList, OldIrql);
	FOR_ALL_IN_LIST(ADAPTER_INFORMATION, &ViAdapterList.ListEntry, adapterInformation) {

		if (adapterInformation->DeviceObject == DeviceObject && 
          (adapterInformation->Inactive == TRUE ||
           adapterInformation->DeferredRemove == TRUE)) {
			VF_UNLOCK_LIST(&ViAdapterList, OldIrql);
			return adapterInformation;
		}
	}

	VF_UNLOCK_LIST(&ViAdapterList, OldIrql);
	return NULL;
} // VF_FIND_INACTIVE_ADAPTER //


__inline
VOID
VF_MARK_FOR_DEFERRED_REMOVE(
	IN PDEVICE_OBJECT DeviceObject
	)
{
	PADAPTER_INFORMATION adapterInformation;
	KIRQL OldIrql;

	VF_LOCK_LIST(&ViAdapterList, OldIrql);
	FOR_ALL_IN_LIST(ADAPTER_INFORMATION, &ViAdapterList.ListEntry, adapterInformation) {

		if (adapterInformation->DeviceObject == DeviceObject) {
         adapterInformation->DeferredRemove = TRUE;
      }
	}

	VF_UNLOCK_LIST(&ViAdapterList, OldIrql);
	return ;
} // VF_MARK_FOR_DEFERRED_REMOVE //


__inline 
VOID 
VF_ASSERT_MAP_REGISTERS_CAN_BE_FREED(
	IN PADAPTER_INFORMATION AdapterInformation,								  
	IN PMAP_REGISTER_FILE MapRegisterFile
	)
{
    UNREFERENCED_PARAMETER (AdapterInformation);


	VF_ASSERT(
		MapRegisterFile->NumberOfRegistersMapped,
		HV_CANNOT_FREE_MAP_REGISTERS,
		( "Cannot free map registers -- %x registers still mapped", 
            MapRegisterFile->NumberOfMapRegisters)
		);
} // VF_ASSERT_MAP_REGISTERS_CAN_BE_FREED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vfzwapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

   vfzwapi.h

Abstract:

    Zw interfaces verifier.

Author:

    Silviu Calinoiu (silviuc) 23-Jul-2002


Revision History:

--*/

#ifndef _VF_ZWAPI_
#define _VF_ZWAPI_


#define DECLARE_ZW_VERIFIER_THUNK(Name) #Name,(PDRIVER_VERIFIER_THUNK_ROUTINE)Vf##Name

//NTSYSAPI
NTSTATUS
NTAPI
VfZwAccessCheckAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwAddBootEntry (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwAddDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry,
    OUT PULONG Id OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwAdjustPrivilegesToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES NewState OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    OUT PTOKEN_PRIVILEGES PreviousState OPTIONAL,
    OUT PULONG ReturnLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwAlertThread(
    IN HANDLE ThreadHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwAssignProcessToJobObject(
    IN HANDLE JobHandle,
    IN HANDLE ProcessHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCancelIoFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCancelTimer (
    IN HANDLE TimerHandle,
    OUT PBOOLEAN CurrentState OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwClearEvent (
    IN HANDLE EventHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwClose(
    IN HANDLE Handle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCloseObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PPORT_VIEW ClientView OPTIONAL,
    IN OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TIMER_TYPE TimerType
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteBootEntry (
    IN ULONG Id
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteDriverEntry (
    IN ULONG Id
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteKey(
    IN HANDLE KeyHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDisplayString(
    IN PUNICODE_STRING String
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDuplicateObject(
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN HANDLE TargetProcessHandle OPTIONAL,
    OUT PHANDLE TargetHandle OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwEnumerateBootEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwEnumerateDriverEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwFlushInstructionCache (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress OPTIONAL,
    IN SIZE_T Length
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwFlushKey(
    IN HANDLE KeyHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwFlushVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    OUT PIO_STATUS_BLOCK IoStatus
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwInitiatePowerAction(
    IN POWER_ACTION SystemAction,
    IN SYSTEM_POWER_STATE MinSystemState,
    IN ULONG Flags,                 // POWER_ACTION_xxx flags
    IN BOOLEAN Asynchronous
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwIsProcessInJob (
    IN HANDLE ProcessHandle,
    IN HANDLE JobHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwMakeTemporaryObject(
    IN HANDLE Handle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwModifyBootEntry (
    IN PBOOT_ENTRY BootEntry
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwModifyDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenJobObject(
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenProcessTokenEx(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenThreadTokenEx(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwPulseEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryBootEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryBootOptions (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDefaultLocale(
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDefaultUILanguage(
    OUT LANGID *DefaultUILanguageId
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDirectoryObject(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryDriverEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationJobObject(
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    OUT PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryInstallUILanguage(
    OUT LANGID *InstallUILanguageId
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryObject(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQuerySection(
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN SIZE_T SectionInformationLength,
    OUT PSIZE_T ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQuerySecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQuerySymbolicLinkObject(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE             TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwRequestWaitReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwResetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Flags
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSaveKeyEx(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Format
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetBootEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetBootOptions (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetDefaultLocale(
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetDefaultUILanguage(
    IN LANGID DefaultUILanguageId
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetDriverEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationJobObject(
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    IN PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationObject(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    IN PVOID ObjectInformation,
    IN ULONG ObjectInformationLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetSecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetSystemTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER PreviousTime OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
    IN PVOID TimerContext OPTIONAL,
    IN BOOLEAN ResumeTimer,
    IN LONG Period OPTIONAL,
    OUT PBOOLEAN PreviousState OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwSetVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwTerminateJobObject(
    IN HANDLE JobHandle,
    IN NTSTATUS ExitStatus
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwTerminateProcess(
    IN HANDLE ProcessHandle OPTIONAL,
    IN NTSTATUS ExitStatus
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwTranslateFilePath (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputFilePath,
    IN OUT PULONG OutputFilePathLength
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwUnloadDriver(
    IN PUNICODE_STRING DriverServiceName
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwWaitForMultipleObjects(
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
//NTSYSAPI
NTSTATUS
NTAPI
VfZwYieldExecution (
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vibugcheck.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vibugcheck.h

Abstract:

    This header defines the internal prototypes and constants required for
    verifier bugchecks. The file is meant to be included by vfbugcheck.c only.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Revision History:

    AdriaO  02/21/2000  - Moved from ntos\io\ioassert.h

--*/

//
// This structure and the table using it define the types and ordering of
// IopDriverCorrectnessCheck (see this function for a more detailed explanation)
//
typedef struct _DCPARAM_TYPE_ENTRY {

    ULONG   DcParamMask;
    PSTR    DcParamName;

} DCPARAM_TYPE_ENTRY, *PDCPARAM_TYPE_ENTRY;

typedef struct _DC_CHECK_DATA {

    PULONG              Control;
    ULONG               AssertionControl;
    ULONG               BugCheckMajor;
    VFMESSAGE_ERRORID   MessageID;
    PVOID               CulpritAddress;
    ULONG_PTR           OffsetIntoImage;
    PUNICODE_STRING     DriverName;
    PCVFMESSAGE_CLASS   AssertionClass;
    PCSTR               MessageTextTemplate;
    PVOID              *DcParamArray;
    PCSTR               ClassText;
    PSTR                AssertionText;
    BOOLEAN             InVerifierList;

} DC_CHECK_DATA, *PDC_CHECK_DATA;

VOID
ViBucheckProcessParams(
    IN  PVFMESSAGE_TEMPLATE_TABLE   MessageTable        OPTIONAL,
    IN  VFMESSAGE_ERRORID           MessageID,
    IN  PCSTR                       MessageParamFormat,
    IN  va_list *                   MessageParameters,
    IN  PVOID *                     DcParamArray,
    OUT PDC_CHECK_DATA              DcCheckData
    );

NTSTATUS
FASTCALL
ViBugcheckProcessMessageText(
   IN ULONG               MaxOutputBufferSize,
   OUT PSTR               OutputBuffer,
   IN OUT PDC_CHECK_DATA  DcCheckData
   );

BOOLEAN
FASTCALL
ViBugcheckApplyControl(
    IN OUT PDC_CHECK_DATA  DcCheckData
    );

VOID
FASTCALL
ViBugcheckHalt(
    IN PDC_CHECK_DATA DcCheckData
    );

VOID
FASTCALL
ViBugcheckPrintBuffer(
    IN PDC_CHECK_DATA DcCheckData
    );

VOID
FASTCALL
ViBugcheckPrintParamData(
    IN PDC_CHECK_DATA DcCheckData
    );

VOID
FASTCALL
ViBugcheckPrintUrl(
    IN PDC_CHECK_DATA DcCheckData
    );

VOID
FASTCALL
ViBugcheckPrompt(
    IN  PDC_CHECK_DATA DcCheckData,
    OUT PBOOLEAN       ExitAssertion
    );

PCHAR
KeBugCheckUnicodeToAnsi(
    IN PUNICODE_STRING UnicodeString,
    OUT PCHAR AnsiBuffer,
    IN ULONG MaxAnsiLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vifilter.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vifilter.h

Abstract:

    This header contains private information used to manage the verifier filter
    driver. This header should be included only by vffilter.c.

Author:

    Adrian J. Oney (adriao) 12-June-2000

Environment:

    Kernel mode

Revision History:

    AdriaO      06/12/2000 - Authored

--*/

typedef struct {

    PDEVICE_OBJECT  PhysicalDeviceObject;
    PDEVICE_OBJECT  LowerDeviceObject;
    PDEVICE_OBJECT  Self;
    VF_DEVOBJ_TYPE  DevObjType;

} VERIFIER_EXTENSION, *PVERIFIER_EXTENSION;

NTSTATUS
ViFilterDriverEntry(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     RegistryPath
    );

NTSTATUS
ViFilterAddDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
ViFilterDispatchPnp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ViFilterDispatchPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ViFilterDispatchGeneric(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ViFilterStartCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
ViFilterDeviceUsageNotificationCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\viirp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    viirp.h

Abstract:

    This header contains private prototypes for managing IRPs used in the
    verification process. This file is meant to be included only by vfirp.c

Author:

    Adrian J. Oney (adriao) 16-June-2000

Environment:

    Kernel mode

Revision History:

    AdriaO      06/16/2000 - Created.

--*/

VOID
FASTCALL
ViIrpAllocateLockedPacket(
    IN      CCHAR               StackSize,
    IN      BOOLEAN             ChargeQuota,
    OUT     PIOV_REQUEST_PACKET *IovPacket
    );

NTSTATUS
ViIrpSynchronousCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\viirpdb.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    viirpdb.h

Abstract:

    This header contains private information used to manage the database of
    IRP tracking data. This header should be included only by vfirpdb.c.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      05/02/2000 - Seperated out from ntos\io\hashirp.h

--*/

#define VI_DATABASE_HASH_SIZE   256
#define VI_DATABASE_HASH_PRIME  131

#define VI_DATABASE_CALCULATE_HASH(Irp) \
    (((((UINT_PTR) Irp)/PAGE_SIZE)*VI_DATABASE_HASH_PRIME) % VI_DATABASE_HASH_SIZE)

#define IOVHEADERFLAG_REMOVED_FROM_TABLE    0x80000000

VOID
FASTCALL
ViIrpDatabaseEntryDestroy(
    IN OUT  PIOV_DATABASE_HEADER    IovHeader
    );

PIOV_DATABASE_HEADER
FASTCALL
ViIrpDatabaseFindPointer(
    IN  PIRP               Irp,
    OUT PLIST_ENTRY        *HashHead
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\viirplog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    viirplog.h

Abstract:

    This header defines the internal prototypes and constants required for
    managing irp logs. The file is meant to be included by vfirplog.c only.

Author:

    Adrian J. Oney (adriao) 20-Feb-2002

--*/

//#define MAX_INSTANCE_COUNT      10

#define IRPLOG_FLAG_FULL        0x00000001
#define IRPLOG_FLAG_NAMELESS    0x00000002
#define IRPLOG_FLAG_DELETED     0x00000004

enum {

    DDILOCK_UNREGISTERED,
    DDILOCK_REGISTERING,
    DDILOCK_REGISTERED
};

typedef struct {

    LOGICAL             Locked;
    LIST_ENTRY          ListHead;

} IRPLOG_HEAD, *PIRPLOG_HEAD;

typedef struct {

    PDEVICE_OBJECT      DeviceObject;
    LIST_ENTRY          HashLink;
    ULONG               Flags;
    DEVICE_TYPE         DeviceType;
    ULONG               MaximumElementCount;
    ULONG               Head;
    IRPLOG_SNAPSHOT     SnapshotArray[1];

} IRPLOG_DATA, *PIRPLOG_DATA;

#define VI_IRPLOG_DATABASE_HASH_SIZE    1
#define VI_IRPLOG_DATABASE_HASH_PRIME   0

#define VI_IRPLOG_CALCULATE_DATABASE_HASH(DeviceObject) \
    (((((UINT_PTR) DeviceObject)/(PAGE_SIZE*2))*VI_IRPLOG_DATABASE_HASH_PRIME) % VI_IRPLOG_DATABASE_HASH_SIZE)

PIRPLOG_DATA
FASTCALL
ViIrpLogDatabaseFindPointer(
    IN  PDEVICE_OBJECT      DeviceObject,
    OUT PIRPLOG_HEAD       *HashHead
    );

VOID
ViIrpLogExposeWmiCallback(
    IN  PVOID   Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vimajor.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vimajor.h

Abstract:

    This header contains private prototypes for per-major IRP code verification.
    This file is meant to be included only by vfmajor.c.

Author:

    Adrian J. Oney (adriao) 09-May-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      06/15/2000 - Seperated out from ntos\io\flunkirp.h

--*/

typedef struct {

    PFN_DUMP_IRP_STACK              DumpIrpStack;
    PFN_VERIFY_NEW_REQUEST          VerifyNewRequest;
    PFN_VERIFY_IRP_STACK_DOWNWARD   VerifyStackDownward;
    PFN_VERIFY_IRP_STACK_UPWARD     VerifyStackUpward;
    PFN_IS_SYSTEM_RESTRICTED_IRP    IsSystemRestrictedIrp;
    PFN_ADVANCE_IRP_STATUS          AdvanceIrpStatus;
    PFN_IS_VALID_IRP_STATUS         IsValidIrpStatus;
    PFN_IS_NEW_REQUEST              IsNewRequest;
    PFN_VERIFY_NEW_IRP              VerifyNewIrp;
    PFN_VERIFY_FINAL_IRP_STACK      VerifyFinalIrpStack;
    PFN_TEST_STARTED_PDO_STACK      TestStartedPdoStack;
    PFN_BUILD_LOG_ENTRY             BuildIrpLogEntry;

} IRP_MAJOR_VERIFIER_ROUTINES, *PIRP_MAJOR_VERIFIER_ROUTINES;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\vipnp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vipnp.h

Abstract:

    This header contains private prototypes for verifying Pnp IRPs are handled
    correctly. This file is meant to be included only by vfpnp.c

Author:

    Adrian J. Oney (adriao) 30-Jun-2000

Environment:

    Kernel mode

Revision History:

--*/

typedef enum {

    NOT_PROCESSED = 0,
    POSSIBLY_PROCESSED,
    DEFINITELY_PROCESSED

} HOW_PROCESSED;

VOID
ViPnpVerifyMinorWasProcessedProperly(
    IN  PIRP                        Irp,
    IN  PIO_STACK_LOCATION          IrpSp,
    IN  VF_DEVOBJ_TYPE              DevObjType,
    IN  PVERIFIER_SETTINGS_SNAPSHOT VerifierSnapshot,
    IN  HOW_PROCESSED               HowProcessed,
    IN  PVOID                       CallerAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\api.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    api.c

Abstract:

    Api entrypoints to WMI

Author:

    AlanWar

Environment:

    Kernel Mode

Revision History:


--*/

#include "wmikmp.h"
#ifndef MEMPHIS
#include "evntrace.h"
#include "tracep.h"
#endif

BOOLEAN WMIInitialize(
    ULONG Phase,
    PVOID LoaderBlock
);

NTSTATUS IoWMIRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Action
);

NTSTATUS IoWMISuggestInstanceName(
    IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
    IN PUNICODE_STRING SymbolicLinkName OPTIONAL,
    IN BOOLEAN CombineNames,
    OUT PUNICODE_STRING SuggestedInstanceName
    );

NTSTATUS IoWMIHandleToInstanceName(
    IN PVOID DataBlockObject,
    IN HANDLE FileHandle,
    OUT PUNICODE_STRING InstanceName
    );

NTSTATUS IoWMIDeviceObjectToInstanceName(
    IN PVOID DataBlockObject,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PUNICODE_STRING InstanceName
    );

#ifdef ALLOC_PRAGMA
#ifndef MEMPHIS
#pragma alloc_text(INIT,WMIInitialize)
#endif
#pragma alloc_text(PAGE,IoWMIRegistrationControl)
#pragma alloc_text(PAGE,IoWMIAllocateInstanceIds)
#pragma alloc_text(PAGE,IoWMISuggestInstanceName)

#pragma alloc_text(PAGE,IoWMIOpenBlock)
#pragma alloc_text(PAGE,IoWMIQueryAllData)
#pragma alloc_text(PAGE,IoWMIQueryAllDataMultiple)
#pragma alloc_text(PAGE,IoWMIQuerySingleInstance)
#pragma alloc_text(PAGE,IoWMIQuerySingleInstanceMultiple)
#pragma alloc_text(PAGE,IoWMISetSingleInstance)
#pragma alloc_text(PAGE,IoWMISetSingleItem)
#pragma alloc_text(PAGE,IoWMISetNotificationCallback)
#pragma alloc_text(PAGE,IoWMIExecuteMethod)
#pragma alloc_text(PAGE,IoWMIHandleToInstanceName)
#pragma alloc_text(PAGE,IoWMIDeviceObjectToInstanceName)
#endif

#ifdef MEMPHIS
BOOLEAN WmipInitialized;
#endif

    //
    // Mutex used to ensure single access to InstanceId chunks
PINSTIDCHUNK WmipInstIdChunkHead;

NTSTATUS
WmipDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

BOOLEAN WMIInitialize(
    ULONG Phase,
    PVOID LoaderBlockPtr
)
/*++

Routine Description:

    This routine is the initialization routine for WMI and is called by IO
    within IoInitSystem on NT. On memphis it is called the firest time
    that IoWMIRegistrationControl is called. This routine asssumes that the
    IO system is initialized enough to call IoCreateDriver. The rest of the
    initialization occurs in the DriverEntry routine.

Arguments:

    Pass specifies the pass of initalization needed

Return Value:

    TRUE if initialization was successful

--*/
{
#ifndef MEMPHIS
//
// We name the driver this so that any eventlogs fired will have the
// source name WMIxWDM and thus get the eventlog messages from
// ntiologc.mc
//
#define WMIDRIVERNAME L"\\Driver\\WMIxWDM"

    UNICODE_STRING DriverName;
#endif
    NTSTATUS Status;

#if !DBG
    UNREFERENCED_PARAMETER (LoaderBlockPtr);
#endif

    if (Phase == 0)
    {
        WmipAssert(WmipServiceDeviceObject == NULL);
        WmipAssert(LoaderBlockPtr != NULL);

#ifdef MEMPHIS
        Status = IoCreateDriver(NULL, WmipDriverEntry);
        WmipInitialized = TRUE;
#else
        RtlInitUnicodeString(&DriverName, WMIDRIVERNAME);
        Status = IoCreateDriver(&DriverName, WmipDriverEntry);
#endif

#if defined(_IA64_)    // EFI actually
        WmipGetSMBiosFromLoaderBlock(LoaderBlockPtr);
#endif
        
    } else {
        WmipAssert(LoaderBlockPtr == NULL);
        
        WmipInitializeRegistration(Phase);

        Status = STATUS_SUCCESS;
    }

#if defined(_IA64_) || defined(_X86_) || defined(_AMD64_)
    //
    // Give MCA a chance to init during phase 0 and 1
    //
    WmipRegisterMcaHandler(Phase);
#endif      
    
    return(NT_SUCCESS(Status) ? TRUE : FALSE);
}

NTSTATUS IoWMIRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Action
)
/*++

Routine Description:

    This routine informs WMI of the existence and disappearance of a device
    object that would support WMI.

Arguments:

    DeviceObject - Pointer to device object  or callback address

    Action - Registration action code

        WMIREG_ACTION_REGISTER - If set action is to inform WMI that the
            device object supports and is ready to receive WMI IRPS.

        WMIREG_ACTION_DEREGISTER - If set action is to inform WMI that the
            device object no longer supports and is not ready to receive WMI
            IRPS.

        WMIREG_ACTION_REREGISTER - If set action is to requery the device
            object for the guids that it supports. This has the effect of
            deregistering followed by registering.

        WMIREG_ACTION_UPDATE_GUIDS - If set action is to query for information
            that is used to update already registered guids.

        WMIREG_ACTION_BLOCK_IRPS - If set action is to block any further irps
            from being sent to the device. The irps are failed by WMI.

        If the  WMIREG_FLAG_CALLBACK is set then DeviceObject actually specifies a callback
            address and not a DeviceObject

Return Value:

    Returns status code

--*/
{
#ifdef MEMPHIS
//
// make sure this matches with the value in io.h
#define WMIREG_FLAG_CALLBACK 0x80000000
#endif

    NTSTATUS Status;
#ifdef MEMPHIS
    BOOLEAN IsCallback = ((Action & WMIREG_FLAG_CALLBACK) == WMIREG_FLAG_CALLBACK);
#endif
    ULONG RegistrationFlag = 0;
    ULONG IsTraceProvider = FALSE;
    ULONG TraceClass = 0;
    PREGENTRY RegEntry;

    PAGED_CODE();

#ifdef MEMPHIS
    if (! WmipInitialized)
    {
         WMIInitialize();
    }
    
    //
    // Callbacks are not supported on memphis
    if (IsCallback)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, 
                  "WMI: Callback registrations not supported %x\n",
                         DeviceObject));
        return(STATUS_NOT_IMPLEMENTED);
    }
#endif

    if (WmipIsWmiNotSetupProperly())
    {
        return(STATUS_UNSUCCESSFUL);
    }

    if (Action & WMIREG_FLAG_CALLBACK)
    {
        RegistrationFlag |= WMIREG_FLAG_CALLBACK;
        Action &= ~WMIREG_FLAG_CALLBACK;
    }

#ifndef MEMPHIS
    if (Action & WMIREG_FLAG_TRACE_PROVIDER)
    {
        TraceClass = Action & WMIREG_FLAG_TRACE_NOTIFY_MASK;

        Action &= ~WMIREG_FLAG_TRACE_PROVIDER & ~WMIREG_FLAG_TRACE_NOTIFY_MASK;
        IsTraceProvider = TRUE;
        RegistrationFlag |= WMIREG_FLAG_TRACE_PROVIDER | TraceClass;
    }
#endif

    switch(Action)
    {
        case WMIREG_ACTION_REGISTER:
        {
            Status = WmipRegisterDevice(
                        DeviceObject,
                        RegistrationFlag);

#ifndef MEMPHIS
            if (IsTraceProvider)
            {
                WmipSetTraceNotify(DeviceObject, TraceClass, TRUE);
            }
            break;
#endif

        }

        case WMIREG_ACTION_DEREGISTER:
        {
            Status = WmipDeregisterDevice(DeviceObject);
            break;
        }

        case WMIREG_ACTION_REREGISTER:
        {
            Status = WmipDeregisterDevice(DeviceObject);
            if (NT_SUCCESS(Status))
            {
                Status = WmipRegisterDevice(
                            DeviceObject,
                            RegistrationFlag);
            }
            break;
        }

        case WMIREG_ACTION_UPDATE_GUIDS:
        {
            Status = WmipUpdateRegistration(DeviceObject);
            break;
        }

#ifndef MEMPHIS
        case WMIREG_ACTION_BLOCK_IRPS:
        {
            RegEntry = WmipFindRegEntryByDevice(DeviceObject, FALSE);
            if (RegEntry != NULL)
            {
                //
                // Mark the regentry as invalid so that no more irps
                // are sent to the device and the event will set when
                // the last irp completes.
                WmipEnterSMCritSection();
                RegEntry->Flags |= REGENTRY_FLAG_NOT_ACCEPTING_IRPS;
                WmipLeaveSMCritSection();
                WmipUnreferenceRegEntry(RegEntry);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }

            break;
        }
#endif
        default:
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    }
    return(Status);
}


NTSTATUS IoWMIAllocateInstanceIds(
    IN GUID *Guid,
    IN ULONG InstanceCount,
    OUT ULONG *FirstInstanceId
    )
/*++

    Routine Description:

    This routine allocates a range of instance ids that are unique to the
    guid. This routine is to be called only at PASSIVE_LEVEL.

    Arguments:

        Guid - Pointer to guid for which instance ids are needed.
        InstanceCount - Count of instance ids to allocate.
        *FirstInstanceId - Returns first instance id in the range.

    Return Value:

        Returns a status code

--*/
{
    PINSTIDCHUNK InstIdChunk, LastInstIdChunk = NULL;
    PINSTID InstId;
    ULONG i;

    PAGED_CODE();

#ifdef MEMPHIS
    if (! WmipInitialized)
    {
         WMIInitialize();
    }
#endif

    if (WmipIsWmiNotSetupProperly())
    {
        return(STATUS_UNSUCCESSFUL);
    }

    WmipEnterSMCritSection();

    //
    // See if the guid is already in the list
    InstIdChunk = WmipInstIdChunkHead;

    while (InstIdChunk != NULL)
    {
        for (i = 0; i < INSTIDSPERCHUNK; i++)
        {
            InstId = &InstIdChunk->InstId[i];
            if (InstId->BaseId == ~0)
            {
                //
                // Since InstIds are always filled sequentially and are
                // never freed, if we hit a free one then we know that
                // our guid is not in the list and we need to fill in a
                // new entry.
                goto FillInstId;
            }

            if (IsEqualGUID(Guid, &InstId->Guid))
            {
                //
                // We found an entry for our guid so use its information
                *FirstInstanceId = InstId->BaseId;
                InstId->BaseId += InstanceCount;
                WmipLeaveSMCritSection();
                return(STATUS_SUCCESS);
            }
        }
        LastInstIdChunk = InstIdChunk;
        InstIdChunk = InstIdChunk->Next;
    }

    //
    // We need to allocate a brand new chunk to accomodate the entry
    InstIdChunk = ExAllocatePoolWithTag(PagedPool,
                                        sizeof(INSTIDCHUNK),
                                        WMIIIPOOLTAG);
    if (InstIdChunk != NULL)
    {
        RtlFillMemory(InstIdChunk, sizeof(INSTIDCHUNK), 0xff);
        InstIdChunk->Next = NULL;
        if (LastInstIdChunk == NULL)
        {
            WmipInstIdChunkHead = InstIdChunk;
        } else {
            LastInstIdChunk->Next = InstIdChunk;
        }

        InstId = &InstIdChunk->InstId[0];
    } else {
        WmipLeaveSMCritSection();
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

FillInstId:
    RtlCopyMemory(&InstId->Guid, Guid, sizeof(GUID));
    InstId->BaseId = InstanceCount;
    WmipLeaveSMCritSection();
    *FirstInstanceId = 0;

    return(STATUS_SUCCESS);
}

NTSTATUS IoWMISuggestInstanceName(
    IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
    IN PUNICODE_STRING SymbolicLinkName OPTIONAL,
    IN BOOLEAN CombineNames,
    OUT PUNICODE_STRING SuggestedInstanceName
    )
/*++

    Routine Description:

    This routine is used by a device driver to suggest a base name with which
    to build WMI instance names for the device. A driver is not bound to
    follow the instance name returned.

    Arguments:

    PhysicalDeviceObject - PDO of device for which a suggested instance name
        is being requested

    SymbolicLinkName - Symbolic link name returned from
        IoRegisterDeviceInterface.

    CombineNames - If TRUE then the suggested names arising from the
        PhysicalDeviceObject and the SymbolicLinkName are combined to create
        the resultant suggested name.

    SuggestedInstanceName - Supplies a pointer to an empty (i.e., Buffer
        field set to NULL) UNICODE_STRING structure which, upon success, will
        be set to a newly-allocated string buffer containing the suggested
        instance name.  The caller is responsible for freeing
        SuggestedInstanceName->Buffer when it is no longer needed.


    Note:  If CombineNames is TRUE then both PhysicalDeviceObject and
           SymbolicLinkName must be specified. Otherwise only one of them
           must be specified.

    Return Value:

        Returns a status code

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER_MIX;
    ULONG DeviceDescSizeRequired;
    ULONG DeviceDescSize;
    PWCHAR DeviceDescBuffer;
    HANDLE DeviceInstanceKey;
    PKEY_VALUE_FULL_INFORMATION InfoBuffer;
    PWCHAR SymLinkDescBuffer;
    ULONG InfoSizeRequired;
    ULONG ResultDescSize;
    PWCHAR ResultDescBuffer;
    UNICODE_STRING DefaultValue;

    PAGED_CODE();

#ifdef MEMPHIS
    if (! WmipInitialized)
    {
         WMIInitialize();
    }
#endif

    if (WmipIsWmiNotSetupProperly())
    {
        return(STATUS_UNSUCCESSFUL);
    }

    DeviceDescBuffer = NULL;
    DeviceDescSizeRequired = 0;
    DeviceDescSize = 0;
    
    if (PhysicalDeviceObject != NULL)
    {
        Status = IoGetDeviceProperty(PhysicalDeviceObject,
                                     DevicePropertyDeviceDescription,
                                     DeviceDescSize,
                                     DeviceDescBuffer,
                                     &DeviceDescSizeRequired);

        if (Status == STATUS_BUFFER_TOO_SMALL)
        {
            DeviceDescBuffer = ExAllocatePoolWithTag(PagedPool,
                                                     DeviceDescSizeRequired,
                                                     WMIPOOLTAG);
            if (DeviceDescBuffer == NULL)
            {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
 
            DeviceDescSize = DeviceDescSizeRequired;
            Status = IoGetDeviceProperty(PhysicalDeviceObject,
                                     DevicePropertyDeviceDescription,
                                     DeviceDescSize,
                                     DeviceDescBuffer,
                                     &DeviceDescSizeRequired);
            if (! NT_SUCCESS(Status))
            {
                ExFreePool(DeviceDescBuffer);
                return(Status);
            }
        } else if (! NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    if (SymbolicLinkName != NULL)
    {
        Status = IoOpenDeviceInterfaceRegistryKey(SymbolicLinkName,
                                                  KEY_ALL_ACCESS,
                                                  &DeviceInstanceKey);
        if (NT_SUCCESS(Status))
        {
            //
            // Figure out how big the data value is so that a buffer of the
            // appropriate size can be allocated.
            DefaultValue.Length = 0;
            DefaultValue.MaximumLength= 0;
            DefaultValue.Buffer = NULL;
            Status = ZwQueryValueKey( DeviceInstanceKey,
                              &DefaultValue,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &InfoSizeRequired );
            if (Status == STATUS_BUFFER_OVERFLOW ||
                Status == STATUS_BUFFER_TOO_SMALL)
            {
                InfoBuffer = ExAllocatePoolWithTag(PagedPool,
                                            InfoSizeRequired,
                                            WMIPOOLTAG);
                if (InfoBuffer != NULL)
                {
                    Status = ZwQueryValueKey(DeviceInstanceKey,
                                             &DefaultValue,
                                             KeyValueFullInformation,
                                             InfoBuffer,
                                             InfoSizeRequired,
                                             &InfoSizeRequired);
                    if (NT_SUCCESS(Status))
                    {
                        SymLinkDescBuffer = (PWCHAR)((PCHAR)InfoBuffer + InfoBuffer->DataOffset);
                        if (CombineNames)
                        {
                            ResultDescSize = InfoBuffer->DataLength +
                                                    DeviceDescSizeRequired +
                                                    sizeof(WCHAR);
                            ResultDescBuffer = ExAllocatePoolWithTag(PagedPool,
                                                              ResultDescSize,
                                                              WMIPOOLTAG);
                            if (ResultDescBuffer == NULL)
                            {
                                Status = STATUS_INSUFFICIENT_RESOURCES;
                            } else {
                                SuggestedInstanceName->Buffer = ResultDescBuffer;
                                SuggestedInstanceName->Length =  0;
                                SuggestedInstanceName->MaximumLength = (USHORT)ResultDescSize;
                                if (DeviceDescBuffer != NULL)
                                {
                                    RtlAppendUnicodeToString(SuggestedInstanceName,
                                                             DeviceDescBuffer);
                                }
                                RtlAppendUnicodeToString(SuggestedInstanceName,
                                                         L"_");
                                RtlAppendUnicodeToString(SuggestedInstanceName,
                                                         SymLinkDescBuffer);

                            }
                            if (DeviceDescBuffer != NULL)
                            {
                                ExFreePool(DeviceDescBuffer);
                                DeviceDescBuffer= NULL;
                            }
                        } else {
                            if (DeviceDescBuffer != NULL)
                            {
                                ExFreePool(DeviceDescBuffer);
                                DeviceDescBuffer = NULL;
                            }
                            ResultDescBuffer = ExAllocatePoolWithTag(PagedPool,
                                                    InfoBuffer->DataLength,
                                                    WMIPOOLTAG);
                            if (ResultDescBuffer == NULL)
                            {
                                Status = STATUS_INSUFFICIENT_RESOURCES;
                            } else {
                                SuggestedInstanceName->Buffer = ResultDescBuffer;
                                SuggestedInstanceName->Length =  0;
                                SuggestedInstanceName->MaximumLength = (USHORT)InfoBuffer->DataLength;
                                RtlAppendUnicodeToString(SuggestedInstanceName,
                                                         SymLinkDescBuffer);
                            }

                        }
                    }

                    ExFreePool(InfoBuffer);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            ZwClose(DeviceInstanceKey);
        }

        if ((DeviceDescBuffer != NULL) && (! NT_SUCCESS(Status)))
        {
            ExFreePool(DeviceDescBuffer);
        }
    } else {
        if (DeviceDescBuffer != NULL)
        {
            //
            // Only looking for device description from PDO
            SuggestedInstanceName->Buffer = DeviceDescBuffer;
            SuggestedInstanceName->Length =  (USHORT)DeviceDescSizeRequired - sizeof(WCHAR);
            SuggestedInstanceName->MaximumLength =  (USHORT)DeviceDescSize;
        } else {
            SuggestedInstanceName->Buffer = NULL;
            SuggestedInstanceName->Length =  (USHORT)0;
            SuggestedInstanceName->MaximumLength =  0;
        }
    }

    return(Status);
}

NTSTATUS IoWMIWriteEvent(
    IN PVOID WnodeEventItem
    )
/*++

Routine Description:

    This routine will queue the passed WNODE_EVENT_ITEM for delivery to the
    WMI user mode agent. Once the event is delivered the WNODE_EVENT_ITEM
    buffer will be returned to the pool.

    This routine may be called at DPC level

Arguments:

    WnodeEventItem - Pointer to WNODE_EVENT_ITEM that has event information.

Return Value:

    Returns STATUS_SUCCESS or an error code

--*/
{
    NTSTATUS Status;
    PWNODE_HEADER WnodeHeader = (PWNODE_HEADER)WnodeEventItem;
#ifndef MEMPHIS
    PULONG TraceMarker = (PULONG) WnodeHeader;
#endif
    KIRQL OldIrql;
    PREGENTRY RegEntry;
    PEVENTWORKCONTEXT EventContext;
	ULONG ProviderId;

    if (WmipIsWmiNotSetupProperly())
    {
        return(STATUS_UNSUCCESSFUL);
    }

#ifndef MEMPHIS
    //
    // Special mode with high order bit set
    //
    if ((*TraceMarker & 0xC0000000) == TRACE_HEADER_FLAG)
    {
        return WmiTraceFastEvent(WnodeHeader);
    }

    if ( (WnodeHeader->Flags & WNODE_FLAG_TRACED_GUID) ||
         (WnodeHeader->Flags & WNODE_FLAG_LOG_WNODE) )
    {
        ULONG LoggerId = WmiGetLoggerId(WnodeHeader->HistoricalContext);
        ULONG IsTrace = WnodeHeader->Flags & WNODE_FLAG_TRACED_GUID;
        ULONG SavedSize = WnodeHeader->BufferSize;
        PULONG TraceMarker = (PULONG) WnodeHeader;

        if (SavedSize < sizeof(WNODE_HEADER))
            return STATUS_BUFFER_TOO_SMALL;

        //
        // If trace header, turn higher bit on and support
        // only full header
        //
        if (IsTrace)
        {
            if (SavedSize > 0XFFFF)    // restrict to USHORT max size
                return STATUS_BUFFER_OVERFLOW;

            *TraceMarker |= TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE |
                            (TRACE_HEADER_TYPE_FULL_HEADER << 16);
        }
        else
        {
            if (SavedSize & TRACE_HEADER_FLAG)
                return STATUS_BUFFER_OVERFLOW;
        }

        Status = STATUS_INVALID_HANDLE;
        if (LoggerId > 0 && LoggerId < MAXLOGGERS)
        {
            if (WmipLoggerContext[LoggerId] != NULL)
            {
                //
                // NOTE: The rule here is that IoWMIWriteEvent is always
                // called in kernel mode, and the buffer needs not be probed!
                //
                Status = WmiTraceEvent(WnodeHeader, KernelMode);
            }
        }
        // NOTE: If it is a trace, we will not go any further
        // Otherwise, if it is a regular WMI event, it will still
        // be processed by WMI.

        if (IsTrace)
        {
            WnodeHeader->BufferSize = SavedSize;
            return Status;
        }
    }

#endif // MEMPHIS

    //
    // Memory for event buffers is limited so the size of any event is also
    // limited.
#if DBG
    if (WnodeHeader->BufferSize > LARGEKMWNODEEVENTSIZE)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                          "WMI: Large event %p fired by %x via WMI\n",
                 WnodeEventItem,
                 ((PWNODE_HEADER)WnodeEventItem)->ProviderId));
    }
#endif

    if (WnodeHeader->BufferSize <= WmipMaxKmWnodeEventSize)
    {

        EventContext = ExAllocatePoolWithTag(NonPagedPool,
                                             sizeof(EVENTWORKCONTEXT),
                                             WMINWPOOLTAG);
        if (EventContext != NULL)
        {       
            //
            // Try to take a refcount on the regentry associated with the
            // provider id in the event. If we are successful then we set a
            // flag in the wnode header saying so. When processing the
            // event in the work item we check the flag and if it is set
            // we'll go looking for the regentry on the active and zombie
            // lists and then use it. At that time it will give up the ref
            // count taken here so that if the regentry really is a zombie
            // then it will go away peacefully.
            //

			ProviderId = WnodeHeader->ProviderId;
            KeAcquireSpinLock(&WmipRegistrationSpinLock,
                              &OldIrql);

            RegEntry = WmipDoFindRegEntryByProviderId(ProviderId,
                                                      REGENTRY_FLAG_RUNDOWN);
            if (RegEntry != NULL)
            {
                WmipReferenceRegEntry(RegEntry);
            }

            KeReleaseSpinLock(&WmipRegistrationSpinLock,
                          OldIrql);                 

            WnodeHeader->ClientContext = WnodeHeader->Version;

            EventContext->RegEntry = RegEntry;
            EventContext->Wnode = WnodeHeader;
            
            ExInterlockedInsertTailList(
                &WmipNPEvent,
                &EventContext->ListEntry,
                &WmipNPNotificationSpinlock);
            //
            // If the queue was empty then there was no work item outstanding
            // to move from non paged to paged memory. So fire up a work item
            // to do so.
            if (InterlockedIncrement(&WmipEventWorkItems) == 1)
            {
                ExQueueWorkItem( &WmipEventWorkQueueItem, DelayedWorkQueue );
            }
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                          "WMI: IoWMIWriteEvent detected an event %p fired by %x that exceeds the maximum event size\n",
                             WnodeEventItem,
                             ((PWNODE_HEADER)WnodeEventItem)->ProviderId));
    }

    return(Status);
}

// IoWMIDeviceObjectToProviderId is in register.c

NTSTATUS IoWMIOpenBlock(
    IN GUID *Guid,
    IN ULONG DesiredAccess,
    OUT PVOID *DataBlockObject
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR ObjectName[WmiGuidObjectNameLength+1];
    UNICODE_STRING ObjectString;
    ULONG Ioctl;
    NTSTATUS Status;
    HANDLE DataBlockHandle;
    
    PAGED_CODE();
    
    //
    // Establish the OBJECT_ATTRIBUTES for the guid object
    //
    StringCchCopyW(ObjectName, WmiGuidObjectNameLength+1, WmiGuidObjectDirectory);
    StringCchPrintfW(&ObjectName[WmiGuidObjectDirectoryLength-1],
                         WmiGuidObjectNameLength-8,
                         L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                         Guid->Data1, Guid->Data2, 
                         Guid->Data3,
                         Guid->Data4[0], Guid->Data4[1],
                         Guid->Data4[2], Guid->Data4[3],
                         Guid->Data4[4], Guid->Data4[5],
                         Guid->Data4[6], Guid->Data4[7]);
                     
    RtlInitUnicodeString(&ObjectString, ObjectName);
    
    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.ObjectName = &ObjectString;
    ObjectAttributes.Attributes = OBJ_KERNEL_HANDLE;
    
    if (DesiredAccess & WMIGUID_NOTIFICATION)
    {
        Ioctl = IOCTL_WMI_OPEN_GUID_FOR_EVENTS;
    } else if (DesiredAccess & WRITE_DAC) {
        Ioctl = IOCTL_WMI_OPEN_GUID;
    } else {
        Ioctl = IOCTL_WMI_OPEN_GUID_FOR_QUERYSET;
    }
    
    Status = WmipOpenBlock(Ioctl,
                           KernelMode,
                           &ObjectAttributes,
                           DesiredAccess,
                           &DataBlockHandle);

    if (NT_SUCCESS(Status))
    {
        Status = ObReferenceObjectByHandle(DataBlockHandle,
                                           DesiredAccess,
                                           WmipGuidObjectType,
                                           KernelMode,
                                           DataBlockObject,
                                           NULL);
        ZwClose(DataBlockHandle);
    }
    
    return(Status);                           
}


//
// Useful macro to establish a WNODE_HEADER quickly
#define WmipBuildWnodeHeader(Wnode, WnodeSize, FlagsUlong, Handle) { \
    ((PWNODE_HEADER)(Wnode))->Flags = FlagsUlong;                    \
    ((PWNODE_HEADER)(Wnode))->KernelHandle = Handle;                 \
    ((PWNODE_HEADER)(Wnode))->BufferSize = WnodeSize;                \
    ((PWNODE_HEADER)(Wnode))->Linkage = 0;                           \
}

NTSTATUS IoWMIQueryAllData(
    IN PVOID DataBlockObject,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
)
{
    NTSTATUS Status;    
    WNODE_ALL_DATA WnodeAD;
    ULONG WnodeSize;
    ULONG RetSize;
    PWNODE_ALL_DATA Wnode;
    
    PAGED_CODE();
    
    //
    // See if the caller passed a buffer that is large enough
    //
    WnodeSize = *InOutBufferSize;   
    Wnode = (PWNODE_ALL_DATA)OutBuffer;
    if ((Wnode == NULL) || (WnodeSize < sizeof(WNODE_ALL_DATA)))
    {
        Wnode = &WnodeAD;
        WnodeSize = sizeof(WnodeAD);
    }
    
    //
    // Initialize buffer for query
    //
    WmipBuildWnodeHeader(Wnode,
                         sizeof(WNODE_HEADER),
                         WNODE_FLAG_ALL_DATA,
                         NULL);
        
    Status = WmipQueryAllData(DataBlockObject,
                              NULL,
                              KernelMode,
                              Wnode,
                              WnodeSize,
                              &RetSize);
                                  
    //
    // if this was a successful query then extract the results
    //
    if (NT_SUCCESS(Status))
    {
        if (Wnode->WnodeHeader.Flags & WNODE_FLAG_INTERNAL)
        {
            //
            // Internal guids are not supported in KM
            //
            Status = STATUS_NOT_SUPPORTED;
        } else if (Wnode->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL) {
            //
            // Buffer passed was too small for provier
            //
            *InOutBufferSize = ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded;
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            //
            // Buffer was large enough for provider
            //
            *InOutBufferSize = RetSize;
            
            if (Wnode == &WnodeAD)
            {
                //
                // Although there was enough room for the provider,
                // the caller didn't pass a large enough buffer
                // so we need to return a buffer too small error
                //
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    }   
    
    return(Status);
}


NTSTATUS
IoWMIQueryAllDataMultiple(
    IN PVOID *DataBlockObjectList,
    IN ULONG ObjectCount,
    IN OUT ULONG *InOutBufferSize,
    OUT PVOID OutBuffer
)
{
    NTSTATUS Status;
    WNODE_ALL_DATA WnodeAD;
    PWNODE_HEADER Wnode;
    ULONG WnodeSize;
    ULONG RetSize;

    PAGED_CODE();
                
    //
    // Make sure we have an output buffer
    //
    WnodeSize = *InOutBufferSize;   
    Wnode = (PWNODE_HEADER)OutBuffer;
    if ((Wnode == NULL) || (WnodeSize < sizeof(WNODE_ALL_DATA)))
    {
        Wnode = (PWNODE_HEADER)&WnodeAD;
        WnodeSize = sizeof(WnodeAD);
    }
    
    Status = WmipQueryAllDataMultiple(ObjectCount,
                                      (PWMIGUIDOBJECT *)DataBlockObjectList,
                                      NULL,
                                      KernelMode,
                                      (PUCHAR)Wnode,
                                      WnodeSize,
                                      NULL,
                                      &RetSize);
    //
    // if this was a successful query then extract the results
    //
    if (NT_SUCCESS(Status))
    {
        if (Wnode->Flags & WNODE_FLAG_TOO_SMALL)
        {
            //
            // Buffer passed to provider was too small
            //
            *InOutBufferSize = ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded;
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            //
            // Buffer was large enough for provider
            //
            *InOutBufferSize = RetSize;
            
            if (Wnode == (PWNODE_HEADER)&WnodeAD)
            {
                //
                // Although there was enough room for the provider,
                // the caller didn't pass a large enough buffer
                // so we need to return a buffer too small error
                //
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    }
    
    return(Status);
}


NTSTATUS
IoWMIQuerySingleInstance(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN OUT ULONG *InOutBufferSize,
    OUT PVOID OutBuffer
)
{
    NTSTATUS Status;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    ULONG WnodeSize;
    PWCHAR WPtr;
    ULONG SizeNeeded;
    ULONG RetSize;

    PAGED_CODE();
    
    //
    // Make sure we have an output buffer
    //
    SizeNeeded = (FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                 VariableData) +
                   InstanceName->Length +
                   sizeof(USHORT) + 7) & ~7;


    WnodeSize = *InOutBufferSize;   
    WnodeSI = (PWNODE_SINGLE_INSTANCE)OutBuffer;
    if ((WnodeSI == NULL) || (WnodeSize < SizeNeeded))
    {
        WnodeSI = (PWNODE_SINGLE_INSTANCE)WmipAllocNP(SizeNeeded);
        WnodeSize = SizeNeeded;
    }
            
    if (WnodeSI != NULL)
    {
        //
        // Build WNODE_SINGLE_INSTANCE appropriately and query
        //
        RtlZeroMemory(WnodeSI, FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                          VariableData));
                                      
        WmipBuildWnodeHeader(WnodeSI,
                             SizeNeeded,
                             WNODE_FLAG_SINGLE_INSTANCE,
                             NULL);

        WnodeSI->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                 VariableData);
        WnodeSI->DataBlockOffset = SizeNeeded;

        //
        // Copy InstanceName into the WnodeSingleInstance for the
        // query. Instance name takes a USHORT Length and then followed
        // by a string.
        //
        WPtr = (PWCHAR)OffsetToPtr(WnodeSI, WnodeSI->OffsetInstanceName);
        *WPtr++ = InstanceName->Length;
        RtlCopyMemory(WPtr, InstanceName->Buffer, InstanceName->Length);
                    
        
        Status = WmipQuerySetExecuteSI((PWMIGUIDOBJECT)DataBlockObject,
                                       NULL,
                                       KernelMode,
                                       IRP_MN_QUERY_SINGLE_INSTANCE,
                                       (PWNODE_HEADER)WnodeSI,
                                       WnodeSize,
                                       &RetSize);
    
        //
        // if this was a successful query then extract the results
        //
        if (NT_SUCCESS(Status))
        {
            if (WnodeSI->WnodeHeader.Flags & WNODE_FLAG_INTERNAL)
            {
                //
                // Internal guids are not supported in KM
                //
                Status = STATUS_NOT_SUPPORTED;
            } else if (WnodeSI->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL) {
                //
                // Our buffer was too small
                //
                *InOutBufferSize = ((PWNODE_TOO_SMALL)WnodeSI)->SizeNeeded;
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                //
                // Buffer not too small, remember output size
                //
                *InOutBufferSize = RetSize;
                
                if (WnodeSI != OutBuffer)
                {
                    //
                    // Although there was enough room for the provider,
                    // the caller didn't pass a large enough buffer
                    // so we need to return a buffer too small error
                    //
                    Status = STATUS_BUFFER_TOO_SMALL;
                }
            }
        }       
        
        if (WnodeSI != OutBuffer)
        {
            WmipFree(WnodeSI);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status);
}

NTSTATUS
IoWMIQuerySingleInstanceMultiple(
    IN PVOID *DataBlockObjectList,
    IN PUNICODE_STRING InstanceNames,
    IN ULONG ObjectCount,
    IN OUT ULONG *InOutBufferSize,
    OUT PVOID OutBuffer
)
{
    NTSTATUS Status;
    ULONG RetSize;
    PWNODE_HEADER Wnode;
    WNODE_TOO_SMALL WnodeTooSmall;
    ULONG WnodeSize;
    
    PAGED_CODE();
    
    WnodeSize = *InOutBufferSize;
    Wnode = (PWNODE_HEADER)OutBuffer;
    if ((Wnode == NULL) || (WnodeSize < sizeof(WNODE_TOO_SMALL)))
    {
        Wnode = (PWNODE_HEADER)&WnodeTooSmall;
        WnodeSize = sizeof(WNODE_TOO_SMALL);
    }

    Status = WmipQuerySingleMultiple(NULL,
                                     KernelMode,
                                     (PUCHAR)Wnode,
                                     WnodeSize,
                                     NULL,
                                     ObjectCount,
                                     (PWMIGUIDOBJECT *)DataBlockObjectList,
                                     InstanceNames,
                                     &RetSize);
                            
                                 
    //
    // if this was a successful query then extract the results
    //
    if (NT_SUCCESS(Status))
    {
        if (Wnode->Flags & WNODE_FLAG_TOO_SMALL)
        {
            //
            // Buffer passed to provider was too small
            //
            *InOutBufferSize = ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded;
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            //
            // Buffer was large enough for provider
            //
            *InOutBufferSize = RetSize;
            
                
            if (Wnode == (PWNODE_HEADER)&WnodeTooSmall)
            {
                //
                // Although there was enough room for the provider,
                // the caller didn't pass a large enough buffer
                // so we need to return a buffer too small error
                //
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    }       
    
    return(Status);
}

NTSTATUS
IoWMISetSingleInstance(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    )
{
    NTSTATUS Status;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    PWCHAR WPtr;
    ULONG SizeNeeded;
    ULONG RetSize;
    ULONG InstanceOffset;
    ULONG DataOffset;
    PUCHAR DPtr;

    PAGED_CODE();
    
    InstanceOffset = (FIELD_OFFSET(WNODE_SINGLE_INSTANCE, 
                                   VariableData) + 1) & ~1;
                               
    DataOffset = (InstanceOffset + 
                  InstanceName->Length + sizeof(USHORT) + 7) & ~7;
                            
    SizeNeeded = DataOffset + ValueBufferSize;

    WnodeSI = (PWNODE_SINGLE_INSTANCE)WmipAllocNP(SizeNeeded);
            
    if (WnodeSI != NULL)
    {
        //
        // Build WNODE_SINGLE_INSTANCE appropriately and query
        //
        RtlZeroMemory(WnodeSI, FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                            VariableData));
                                      
        WmipBuildWnodeHeader(WnodeSI,
                             SizeNeeded,
                             WNODE_FLAG_SINGLE_INSTANCE,
                             NULL);
                         
        WnodeSI->WnodeHeader.Version = Version;

        //
        // Copy InstanceName into the WnodeSingleInstance for the query.
        //
        WnodeSI->OffsetInstanceName = InstanceOffset;
        WPtr = (PWCHAR)OffsetToPtr(WnodeSI, WnodeSI->OffsetInstanceName);
        *WPtr++ = InstanceName->Length;
        RtlCopyMemory(WPtr, InstanceName->Buffer, InstanceName->Length);
                                             
        //
        // Copy the new data into the WNODE
        //
        WnodeSI->SizeDataBlock = ValueBufferSize;
        WnodeSI->DataBlockOffset = DataOffset;
        DPtr = OffsetToPtr(WnodeSI, WnodeSI->DataBlockOffset);
        RtlCopyMemory(DPtr, ValueBuffer, ValueBufferSize);
        
        Status = WmipQuerySetExecuteSI(DataBlockObject,
                                       NULL,
                                       KernelMode,
                                       IRP_MN_CHANGE_SINGLE_INSTANCE,
                                       (PWNODE_HEADER)WnodeSI,
                                       SizeNeeded,
                                       &RetSize);
    
        WmipFree(WnodeSI);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status); 
}

NTSTATUS
IoWMISetSingleItem(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN ULONG DataItemId,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    )
{
    NTSTATUS Status;
    PWNODE_SINGLE_ITEM WnodeSI;
    PWCHAR WPtr;
    ULONG SizeNeeded;
    ULONG RetSize;
    ULONG InstanceOffset;
    ULONG DataOffset;
    PUCHAR DPtr;

    PAGED_CODE();
    
    InstanceOffset = (FIELD_OFFSET(WNODE_SINGLE_ITEM, 
                                   VariableData) + 1) & ~1;
                               
    DataOffset = (InstanceOffset + 
                  InstanceName->Length + sizeof(USHORT) + 7) & ~7;
                            
    SizeNeeded = DataOffset + ValueBufferSize;

    WnodeSI = (PWNODE_SINGLE_ITEM)WmipAllocNP(SizeNeeded);
            
    if (WnodeSI != NULL)
    {
        //
        // Build WNODE_SINGLE_INSTANCE appropriately and query
        //
        RtlZeroMemory(WnodeSI, FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                            VariableData));
                                      
        WmipBuildWnodeHeader(WnodeSI,
                             SizeNeeded,
                             WNODE_FLAG_SINGLE_ITEM,
                             NULL);
                         
        WnodeSI->WnodeHeader.Version = Version;
        WnodeSI->ItemId = DataItemId;

        //
        // Copy InstanceName into the WnodeSingleInstance for the query.
        //
        WnodeSI->OffsetInstanceName = InstanceOffset;
        WPtr = (PWCHAR)OffsetToPtr(WnodeSI, WnodeSI->OffsetInstanceName);
        *WPtr++ = InstanceName->Length;
        RtlCopyMemory(WPtr, InstanceName->Buffer, InstanceName->Length);
                                             
        //
        // Copy the new data into the WNODE
        //
        WnodeSI->SizeDataItem = ValueBufferSize;
        WnodeSI->DataBlockOffset = DataOffset;
        DPtr = OffsetToPtr(WnodeSI, WnodeSI->DataBlockOffset);
        RtlCopyMemory(DPtr, ValueBuffer, ValueBufferSize);
        
        Status = WmipQuerySetExecuteSI(DataBlockObject,
                                       NULL,
                                       KernelMode,
                                       IRP_MN_CHANGE_SINGLE_ITEM,
                                       (PWNODE_HEADER)WnodeSI,
                                       SizeNeeded,
                                       &RetSize);
    
        WmipFree(WnodeSI);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status); 
}

NTSTATUS IoWMIExecuteMethod(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN OUT PULONG OutBufferSize,
    IN OUT PUCHAR InOutBuffer
    )
{
    NTSTATUS Status;
    PWNODE_METHOD_ITEM WnodeMI;
    PWCHAR WPtr;
    PUCHAR DPtr;
    ULONG SizeNeeded;
    ULONG RetSize;
    ULONG DataOffset;

    PAGED_CODE();
    
    //
    // Make sure we have an output buffer
    //
    DataOffset = (FIELD_OFFSET(WNODE_METHOD_ITEM,
                                 VariableData) +
                   InstanceName->Length +
                   sizeof(USHORT) +
                   7) & ~7;
    
    SizeNeeded =  DataOffset +
                   ((InBufferSize > *OutBufferSize) ? InBufferSize :
                                                      *OutBufferSize);
    
    WnodeMI = (PWNODE_METHOD_ITEM)WmipAllocNP(SizeNeeded);
            
    if (WnodeMI != NULL)
    {
        //
        // Build WNODE_SINGLE_INSTANCE appropriately and query
        //
        RtlZeroMemory(WnodeMI, FIELD_OFFSET(WNODE_METHOD_ITEM,
                                          VariableData));
                                      
        WmipBuildWnodeHeader(WnodeMI,
                             SizeNeeded,
                             WNODE_FLAG_METHOD_ITEM,
                             NULL);
        
        WnodeMI->MethodId = MethodId;

        WnodeMI->OffsetInstanceName = FIELD_OFFSET(WNODE_METHOD_ITEM,
                                                   VariableData);
        WnodeMI->DataBlockOffset = DataOffset;
        WnodeMI->SizeDataBlock = InBufferSize;

        //
        // Copy InstanceName into the WnodeMethodItem for the query.
        //
        WPtr = (PWCHAR)OffsetToPtr(WnodeMI, WnodeMI->OffsetInstanceName);
        *WPtr++ = InstanceName->Length;
        RtlCopyMemory(WPtr, InstanceName->Buffer, InstanceName->Length);

        //
        // Copy the input data into the WnodeMethodItem
        //
        DPtr = (PUCHAR)OffsetToPtr(WnodeMI, WnodeMI->DataBlockOffset);
        RtlCopyMemory(DPtr, InOutBuffer, InBufferSize);
        
        Status = WmipQuerySetExecuteSI(DataBlockObject,NULL,
                                       KernelMode,
                                       IRP_MN_EXECUTE_METHOD,
                                       (PWNODE_HEADER)WnodeMI,
                                       SizeNeeded,
                                       &RetSize);
    
        //
        // if this was a successful query then extract the results
        //
        if (NT_SUCCESS(Status))
        {
            if (WnodeMI->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL)
            {
                //
                // Our buffer was too small
                //
                *OutBufferSize = ( (((PWNODE_TOO_SMALL)WnodeMI)->SizeNeeded -
                                 DataOffset) + 7 ) & ~7;
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                //
                // Buffer not too small, remember output size
                //
                if (*OutBufferSize >= WnodeMI->SizeDataBlock)
                {
                    *OutBufferSize = WnodeMI->SizeDataBlock;
                    DPtr = (PUCHAR)OffsetToPtr(WnodeMI,
                                               WnodeMI->DataBlockOffset);
                    RtlCopyMemory(InOutBuffer, DPtr, WnodeMI->SizeDataBlock);
                } else {
                    *OutBufferSize = (WnodeMI->SizeDataBlock + 7) & ~7;
                    Status = STATUS_BUFFER_TOO_SMALL;
                }
            }
        }       
        
        WmipFree(WnodeMI);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status);
}

NTSTATUS
IoWMISetNotificationCallback(
    IN PVOID Object,
    IN WMI_NOTIFICATION_CALLBACK Callback,
    IN PVOID Context
    )
{
    PWMIGUIDOBJECT GuidObject;
    
    PAGED_CODE();

    GuidObject = (PWMIGUIDOBJECT)Object;
    
    WmipAssert(GuidObject->Flags & WMIGUID_FLAG_KERNEL_NOTIFICATION);
    
    WmipEnterSMCritSection();
    
    GuidObject->Callback = Callback;
    GuidObject->CallbackContext = Context;
    
    WmipLeaveSMCritSection();

    return(STATUS_SUCCESS);
}

NTSTATUS IoWMIHandleToInstanceName(
    IN PVOID DataBlockObject,
    IN HANDLE FileHandle,
    OUT PUNICODE_STRING InstanceName
    )
{
    NTSTATUS Status;
    
    PAGED_CODE();

    Status = WmipTranslateFileHandle(NULL,
                                     NULL,
                                     FileHandle,
                                     NULL,
                                     DataBlockObject,
                                     InstanceName);
    return(Status);
}

NTSTATUS IoWMIDeviceObjectToInstanceName(
    IN PVOID DataBlockObject,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PUNICODE_STRING InstanceName
    )
{
    NTSTATUS Status;
    
    PAGED_CODE();

    Status = WmipTranslateFileHandle(NULL,
                                     NULL,
                                     NULL,
                                     DeviceObject,
                                     DataBlockObject,
                                     InstanceName);
    return(Status);
}


#if 0
NTSTATUS
IoWMISetGuidSecurity(
    IN PVOID Object,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    NTSTATUS status;
    
    PAGED_CODE();




    DaclLength = (ULONG)sizeof(ACL) +
                   (1*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                   SeLengthSid( SeLocalSystemSid ) +
                   8; // The 8 is just for good measure

    ServiceDeviceSd = (PSECURITY_DESCRIPTOR)ExAllocatePoolWithTag(PagedPool,
                                               DaclLength +
                                                  sizeof(SECURITY_DESCRIPTOR),
                                               'ZZZZ');


    if (ServiceDeviceSd == NULL)
    {
        return(NULL);
    }

    ServiceDeviceDacl = (PACL)((PUCHAR)ServiceDeviceSd +
                                sizeof(SECURITY_DESCRIPTOR));
    Status = RtlCreateAcl( ServiceDeviceDacl,
                           DaclLength,
                           ACL_REVISION2);

    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlAddAccessAllowedAce (
                 ServiceDeviceDacl,
                 ACL_REVISION2,
                 FILE_ALL_ACCESS,
                 SeLocalSystemSid
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlCreateSecurityDescriptor(
                 ServiceDeviceSd,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlSetDaclSecurityDescriptor(
                 ServiceDeviceSd,
                 TRUE,                       // DaclPresent
                 ServiceDeviceDacl,
                 FALSE                       // DaclDefaulted
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
Cleanup:
    if (! NT_SUCCESS(Status))
    {
        ExFreePool(ServiceDeviceSd);
        ServiceDeviceSd = NULL;
    }
    


    

    status = ObSetSecurityObjectByPointer(Object,
                                          SecurityInformation,
                                          SecurityDescriptor);

    return(status);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\verifier\visettings.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    visettings.h

Abstract:

    This header contains private information used to manage the verifier
    settings. This header should be included only by vfsettings.c.

Author:

    Adrian J. Oney (adriao) 31-May-2000

Environment:

    Kernel mode

Revision History:

--*/

//
// Note the rounding up to the nearest ULONG.
//
#define OPTION_SIZE     ((VERIFIER_OPTION_MAX+sizeof(ULONG)*8-1)/8)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\callouts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    callouts.c

Abstract:

    This is the source file that contains all the callout routines
    from the kernel itself. The only exception is TraceIo for DiskPerf.

Author:

    Jee Fung Pang (jeepang) 03-Dec-1996

Revision History:

--*/

#pragma warning(disable:4214)
#pragma warning(disable:4115)
#pragma warning(disable:4201)
#pragma warning(disable:4127)
#pragma warning(disable:4127)
#include <stdio.h>
#include <ntos.h>
#include <zwapi.h>
#ifdef NTPERF
#include <ntdddisk.h>
#endif
#include <evntrace.h>
#include "wmikmp.h"
#include "tracep.h"
#pragma warning(default:4214)
#pragma warning(default:4115)
#pragma warning(default:4201)

#ifndef _WMIKM_
#define _WMIKM_
#endif

#define MAX_FILENAME_TO_LOG   4096
#define ETW_WORK_ITEM_LIMIT  64

typedef struct _TRACE_FILE_WORK_ITEM {
    WORK_QUEUE_ITEM         WorkItem;
    PFILE_OBJECT            FileObject;
    ULONG                   BufferSize;
} TRACE_FILE_WORK_ITEM, *PTRACE_FILE_WORK_ITEM;

VOID
FASTCALL
WmipTracePageFault(
    IN NTSTATUS Status,
    IN PVOID VirtualAddress,
    IN PVOID TrapFrame
    );

VOID
WmipTraceNetwork(
    IN ULONG GroupType,
    IN PVOID EventInfo,
    IN ULONG EventInfoLen,
    IN PVOID Reserved 
    );

VOID
WmipTraceIo(
    IN ULONG DiskNumber,
    IN PIRP Irp,
    IN PVOID Counters
    );

VOID WmipTraceFile(
    IN PVOID TraceFileContext
    );

VOID
WmipTraceLoadImage(
    IN PUNICODE_STRING ImageName,
    IN HANDLE ProcessId,
    IN PIMAGE_INFO ImageInfo
    );

VOID
WmipTraceRegistry(
    IN NTSTATUS         Status,
    IN PVOID            Kcb,
    IN LONGLONG         ElapsedTime,
    IN ULONG            Index,
    IN PUNICODE_STRING  KeyName,
    IN UCHAR            Type
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWMI, WmipIsLoggerOn)
#pragma alloc_text(PAGE,    WmipEnableKernelTrace)
#pragma alloc_text(PAGE,    WmipDisableKernelTrace)
#pragma alloc_text(PAGE,    WmipSetTraceNotify)
#pragma alloc_text(PAGE,    WmiTraceProcess)
#pragma alloc_text(PAGE,    WmiTraceThread)
#pragma alloc_text(PAGE,    WmipTraceFile)
#pragma alloc_text(PAGE,    WmipTraceLoadImage)
#pragma alloc_text(PAGE,    WmipTraceRegistry)
#pragma alloc_text(PAGEWMI, WmipTracePageFault)
#pragma alloc_text(PAGEWMI, WmipTraceNetwork)
#pragma alloc_text(PAGEWMI, WmipTraceIo)
#pragma alloc_text(PAGEWMI, WmiTraceContextSwap)
#pragma alloc_text(PAGE,    WmiStartContextSwapTrace)
#pragma alloc_text(PAGE,    WmiStopContextSwapTrace)
#endif

ULONG WmipTraceFileFlag = FALSE;
LONG WmipFileIndex = 0;
LONG WmipWorkItemCounter = 0;
PFILE_OBJECT *WmipFileTable = NULL;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
ULONG WmipKernelLoggerStartedOnce = 0;
LONG WmipTraceProcessRef  = 0;
PVOID WmipDiskIoNotify    = NULL;
PVOID WmipTdiIoNotify     = NULL;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

typedef struct _TRACE_DEVICE {
    PDEVICE_OBJECT      DeviceObject;
    ULONG               TraceClass;
} TRACE_DEVICE, *PTRACE_DEVICE;

VOID
FASTCALL
WmipEnableKernelTrace(
    IN ULONG EnableFlags
    )
/*++

Routine Description:

    This is called by WmipStartLogger in tracelog.c. Its purpose is to
    set up all the kernel notification routines that can produce event traces
    for capacity planning.

Arguments:

    ExtendedOn      a flag to indicate if extended mode tracing is requested

Return Value:

    None

--*/

{
    PREGENTRY RegEntry;
    PLIST_ENTRY RegEntryList;
    ULONG DevicesFound;
    long Index, DiskFound;
    PTRACE_DEVICE *deviceList, device;
    CCHAR stackSize;
    PIRP irp;
    PVOID notifyRoutine;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status;
    ULONG enableDisk, enableNetwork;

    PAGED_CODE();

    //
    // Since we cannot do anything, we will have to count the number
    // of entries we need to create first, and add some buffer
    //

    DiskFound = 0;

    enableDisk = (EnableFlags & EVENT_TRACE_FLAG_DISK_IO);
    enableNetwork = (EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP);

    if ( enableDisk || enableNetwork ) {

        //
        // Setting the callouts will cause new PDO registration to be enabled
        // from here on.
        //
        if (enableDisk) {
            WmipDiskIoNotify = (PVOID) (ULONG_PTR) &WmipTraceIo;
        }
        if (enableNetwork) {
            WmipTdiIoNotify = (PVOID) (ULONG_PTR) &WmipTraceNetwork;
        }

        DevicesFound = WmipInUseRegEntryCount;
        if (DevicesFound == 0) {
            return;
        }

        deviceList = (PTRACE_DEVICE*)
                        ExAllocatePoolWithTag(
                            PagedPool,
                            (DevicesFound) * sizeof(TRACE_DEVICE),
                            TRACEPOOLTAG);
        if (deviceList == NULL) {
            return;
        }

        RtlZeroMemory(deviceList, sizeof(TRACE_DEVICE) * DevicesFound);

        //
        // Now, we will go through what's already in the list and enable trace
        // notification routine. Devices who registered while after we've set
        // the callout will get another Irp to enable, but that's alright
        //

        device = (PTRACE_DEVICE) deviceList;        // start from first element

        Index = 0;

        WmipEnterSMCritSection();
        RegEntryList = WmipInUseRegEntryHead.Flink;
        while (RegEntryList != &WmipInUseRegEntryHead) {
            RegEntry = CONTAINING_RECORD(RegEntryList,REGENTRY,InUseEntryList);

            if (RegEntry->Flags & REGENTRY_FLAG_TRACED) {
                if ((ULONG) Index < DevicesFound) {
                    device->TraceClass
                        = RegEntry->Flags & WMIREG_FLAG_TRACE_NOTIFY_MASK;
                    if (device->TraceClass == WMIREG_NOTIFY_DISK_IO)
                        DiskFound++;
                    device->DeviceObject = RegEntry->DeviceObject;
                    device++;
                    Index++;
                }
            }
            RegEntryList = RegEntryList->Flink;
        }
        WmipLeaveSMCritSection();

        //
        // actually send the notification to diskperf or tdi here
        //
        stackSize = WmipServiceDeviceObject->StackSize;
        irp = IoAllocateIrp(stackSize, FALSE);

        device = (PTRACE_DEVICE) deviceList;
        while (--Index >= 0 && irp != NULL) {
            if (device->DeviceObject != NULL) {

                if ( (device->TraceClass == WMIREG_NOTIFY_TDI_IO) &&
                      enableNetwork ) {
                    notifyRoutine = (PVOID) (ULONG_PTR) &WmipTraceNetwork;
                }
                else if ( (device->TraceClass == WMIREG_NOTIFY_DISK_IO) &&
                           enableDisk ) {
                    notifyRoutine = (PVOID) (ULONG_PTR) &WmipTraceIo;
                }
                else {  // consider supporting generic callout for other devices
                    notifyRoutine = NULL;
                    device ++;
                    continue;
                }

                do {
                    IoInitializeIrp(irp, IoSizeOfIrp(stackSize), stackSize);
                    IoSetNextIrpStackLocation(irp);
                    irpStack = IoGetCurrentIrpStackLocation(irp);
                    irpStack->DeviceObject = WmipServiceDeviceObject;
                    irp->Tail.Overlay.Thread = PsGetCurrentThread();

                    status = WmipForwardWmiIrp(
                                irp,
                                IRP_MN_SET_TRACE_NOTIFY,
                                IoWMIDeviceObjectToProviderId(device->DeviceObject),
                                NULL,
                                sizeof(notifyRoutine),
                                &notifyRoutine
                                );

                    if (status == STATUS_WMI_TRY_AGAIN) {
                        IoFreeIrp(irp);
                        stackSize = WmipServiceDeviceObject->StackSize;
                        irp = IoAllocateIrp(stackSize, FALSE);
                        if (!irp) {
                            break;
                        }
                    }
                } while (status == STATUS_WMI_TRY_AGAIN);
            }
            device++;
        }
        if (irp) {
            IoFreeIrp(irp);
        }
        ExFreePoolWithTag(deviceList, TRACEPOOLTAG);
        // free the array that we created above
        //
    }

    if (EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS) {
        MmSetPageFaultNotifyRoutine(
            (PPAGE_FAULT_NOTIFY_ROUTINE) &WmipTracePageFault);
    }
    if (EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO) {
        //
        // NOTE: We assume StartLogger will always reserve space for
        // FileTable already
        //
        WmipTraceFileFlag = TRUE;
    }

    if (EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) {
        if (!(WmipKernelLoggerStartedOnce & EVENT_TRACE_FLAG_IMAGE_LOAD)) {
            PsSetLoadImageNotifyRoutine(
                (PLOAD_IMAGE_NOTIFY_ROUTINE) &WmipTraceLoadImage
                );
            WmipKernelLoggerStartedOnce |= EVENT_TRACE_FLAG_IMAGE_LOAD;
        }
    }

    if (EnableFlags & EVENT_TRACE_FLAG_REGISTRY) {
        CmSetTraceNotifyRoutine(
            (PCM_TRACE_NOTIFY_ROUTINE) &WmipTraceRegistry,
            FALSE
            );
    }
}


VOID
FASTCALL
WmipDisableKernelTrace(
    IN ULONG EnableFlags
    )
/*++

Routine Description:

    This is called by WmipStopLogger in tracelog.c. Its purpose of the
    disable all the kernel notification routines that was defined by
    WmipEnableKernelTrace

Arguments:

    EnableFlags     Flags indicated what was enabled and needs to be disabled

Return Value:

    None

--*/

{
    PVOID NullPtr = NULL;
    PREGENTRY RegEntry;
    PLIST_ENTRY RegEntryList;
    ULONG DevicesFound;
    long Index;
    PTRACE_DEVICE* deviceList, device;
    CCHAR stackSize;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status;
    ULONG enableDisk, enableNetwork;

    PAGED_CODE();

    //
    // first, disable partition change notification
    //

    if (EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO) {
        WmipTraceFileFlag = FALSE;
        if (WmipFileTable != NULL) {
            RtlZeroMemory(
                WmipFileTable,
                MAX_FILE_TABLE_SIZE * sizeof(PFILE_OBJECT));
        }
    }

    if (EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS) {
        MmSetPageFaultNotifyRoutine(NULL);
    }

    if (EnableFlags & EVENT_TRACE_FLAG_REGISTRY) {
        CmSetTraceNotifyRoutine(NULL,TRUE);
    }

    enableDisk = (EnableFlags & EVENT_TRACE_FLAG_DISK_IO);
    enableNetwork = (EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP);

    if (!enableDisk && !enableNetwork)
        return;     // NOTE: assumes all flags are already checked

    //
    // Note. Since this is in the middle is StopLogger, it is not possible
    // StartLogger will prevent kernel tracing from being enabled, hence
    // we need not worry about WmipEnableKernelTrace() being called while
    // this is in progress.
    //
    WmipDiskIoNotify = NULL;
    WmipTdiIoNotify = NULL;

    DevicesFound = WmipInUseRegEntryCount;

    deviceList = (PTRACE_DEVICE*)
                ExAllocatePoolWithTag(
                    PagedPool,
                    (DevicesFound) * sizeof(TRACE_DEVICE),
                    TRACEPOOLTAG);
    if (deviceList == NULL)
        return;

    RtlZeroMemory(deviceList, sizeof(TRACE_DEVICE) * DevicesFound);
    Index = 0;
    device = (PTRACE_DEVICE) deviceList;        // start from first element

    //
    // To disable we do not need to worry about TraceClass, since we simply
    // set all callouts to NULL
    //
    WmipEnterSMCritSection();
    RegEntryList = WmipInUseRegEntryHead.Flink;
    while (RegEntryList != &WmipInUseRegEntryHead) {
        RegEntry = CONTAINING_RECORD(RegEntryList, REGENTRY, InUseEntryList);
        if (RegEntry->Flags & REGENTRY_FLAG_TRACED) {
            if ((ULONG)Index < DevicesFound) {
                device->TraceClass
                    = RegEntry->Flags & WMIREG_FLAG_TRACE_NOTIFY_MASK;
                device->DeviceObject = RegEntry->DeviceObject;
                device++; Index++;
            }
        }
        RegEntryList = RegEntryList->Flink;
    }
    WmipLeaveSMCritSection();

    stackSize = WmipServiceDeviceObject->StackSize;
    irp = IoAllocateIrp(stackSize, FALSE);

    device = (PTRACE_DEVICE) deviceList;        // start from first element
    while (--Index >= 0 && irp != NULL) {
        if ((device->DeviceObject != NULL) &&
            ((device->TraceClass == WMIREG_NOTIFY_TDI_IO) ||
             (device->TraceClass == WMIREG_NOTIFY_DISK_IO))) {

            do {
                IoInitializeIrp(irp, IoSizeOfIrp(stackSize), stackSize);
                IoSetNextIrpStackLocation(irp);
                irpStack = IoGetCurrentIrpStackLocation(irp);
                irpStack->DeviceObject = WmipServiceDeviceObject;
                irp->Tail.Overlay.Thread = PsGetCurrentThread();

                status = WmipForwardWmiIrp(
                            irp,
                            IRP_MN_SET_TRACE_NOTIFY,
                            IoWMIDeviceObjectToProviderId(device->DeviceObject),
                            NULL,
                            sizeof(NullPtr),
                            &NullPtr
                            );

                if (status == STATUS_WMI_TRY_AGAIN) {
                    IoFreeIrp(irp);
                    stackSize = WmipServiceDeviceObject->StackSize;
                    irp = IoAllocateIrp(stackSize, FALSE);
                    if (!irp) {
                        break;
                    }
                }
                else {
                    break;
                }
            } while (TRUE);
        }
        device++;
    }

    if (irp) {
        IoFreeIrp(irp);
    }
    ExFreePoolWithTag(deviceList, TRACEPOOLTAG);
}

VOID
WmipSetTraceNotify(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG TraceClass,
    IN ULONG Enable
    )
{
    PIRP irp;
    PVOID NotifyRoutine = NULL;
    NTSTATUS status;
    CCHAR stackSize;
    PIO_STACK_LOCATION irpStack;

    if (Enable) {
        switch (TraceClass) {
            case WMIREG_NOTIFY_DISK_IO  :
                NotifyRoutine = WmipDiskIoNotify;
                break;
            case WMIREG_NOTIFY_TDI_IO   :
                NotifyRoutine = WmipTdiIoNotify;
                break;
            default :
                return;
        }
        if (NotifyRoutine == NULL)  // trace not enabled, so do not
            return;                 // send any Irp to enable
    }

    do {
        stackSize = WmipServiceDeviceObject->StackSize;
        irp = IoAllocateIrp(stackSize, FALSE);

        if (!irp)
            return;

        IoSetNextIrpStackLocation(irp);
        irpStack = IoGetCurrentIrpStackLocation(irp);
        irpStack->DeviceObject = WmipServiceDeviceObject;
        status = WmipForwardWmiIrp(
                     irp,
                     IRP_MN_SET_TRACE_NOTIFY,
                     IoWMIDeviceObjectToProviderId(DeviceObject),
                     NULL,
                     sizeof(NotifyRoutine),
                     &NotifyRoutine
                     );
        IoFreeIrp(irp);
    } while (status == STATUS_WMI_TRY_AGAIN);
}

//
// All the following routines are callout or notification routines for
// generating kernel event traces
//


NTKERNELAPI
VOID
FASTCALL
WmiTraceProcess(
    IN PEPROCESS Process,
    IN BOOLEAN Create
    )
/*++

Routine Description:

    This callout routine is called from ps\create.c and ps\psdelete.c.

Arguments:

    Process - PEPROCESS;
    Create - True if intended process is being created.

Return Value:

    None

--*/

{
    ULONG Size, LoggerId;
    NTSTATUS Status;
    PCHAR AuxPtr;
    PSYSTEM_TRACE_HEADER Header;
    PVOID BufferResource;
    ULONG SidLength = sizeof(ULONG);
    PTOKEN_USER LocalUser = NULL;
    PWMI_PROCESS_INFORMATION ProcessInfo;
    PWMI_LOGGER_CONTEXT LoggerContext;
    PVOID Token;
    PUNICODE_STRING pImageFileName;
    ANSI_STRING AnsiImageFileName;
    ULONG ImageLength, ImageOnlyLength;
    PCHAR Src;
    PCHAR Dst;
    ULONG LongImageName;
#if DBG
    LONG RefCount;
#endif

    PAGED_CODE();

    if ((WmipIsLoggerOn(WmipKernelLogger) == NULL) &&
        (WmipIsLoggerOn(WmipEventLogger) == NULL))
        return;

    Token = PsReferencePrimaryToken(Process);
    if (Token != NULL) {
        Status = SeQueryInformationToken(
            Token,
            TokenUser,
            &LocalUser);
        PsDereferencePrimaryTokenEx (Process, Token);
    } else {
        Status = STATUS_SEVERITY_ERROR;
    }

    if (NT_SUCCESS(Status)) {
        WmipAssert(LocalUser != NULL);  // temporary for SE folks
        if (LocalUser != NULL) {
            SidLength = SeLengthSid(LocalUser->User.Sid) + sizeof(TOKEN_USER);
        }
    } else {
        SidLength = sizeof(ULONG);
        LocalUser = NULL;
    }

    AnsiImageFileName.Buffer = NULL;
    // Get image name not limited to 16 chars.
    Status = SeLocateProcessImageName (Process, &pImageFileName);
    if (NT_SUCCESS (Status)) {
        ImageLength = pImageFileName->Length;
        if (ImageLength != 0) {
            Status = RtlUnicodeStringToAnsiString(&AnsiImageFileName, pImageFileName, TRUE);
            if (NT_SUCCESS (Status)) {
                ImageLength = AnsiImageFileName.Length;
            } else {
                ImageLength = 0;
            }
        }
        ExFreePool (pImageFileName);
    } else {
        ImageLength = 0;
    }
    // if ImageLength == 0, AnsiImageFileName has not been allocated at this point.

    if (ImageLength != 0) {
        Src = AnsiImageFileName.Buffer + ImageLength;
        while (Src != AnsiImageFileName.Buffer) {
            if (*--Src == '\\') {
                Src = Src + 1;
                break;
            }
        }

        ImageOnlyLength = ImageLength - (ULONG)(Src - AnsiImageFileName.Buffer);
        ImageLength = ImageOnlyLength + 1;
        LongImageName = TRUE;
    } else {
        Src = (PCHAR) Process->ImageFileName;
        // Process->ImageFileName is max 16 chars and always NULL-terminated.
        ImageLength = (ULONG) strlen (Src);
        if (ImageLength != 0) {
            ImageLength++;
        }
        LongImageName = FALSE;
        ImageOnlyLength = 0;
    }
    // if LongImageName == FALSE, AnsiImageFileName has not been allocated at this point.

    Size = SidLength + FIELD_OFFSET(WMI_PROCESS_INFORMATION, Sid) + ImageLength;

    for (LoggerId = 0; LoggerId < MAXLOGGERS; LoggerId++) {
        if (LoggerId != WmipKernelLogger && LoggerId != WmipEventLogger) {
            continue;
        }
#if DBG
        RefCount =
#endif
        WmipReferenceLogger(LoggerId);
        TraceDebug((4, "WmiTraceProcess: %d %d->%d\n",
                     LoggerId, RefCount-1, RefCount));        

        LoggerContext = WmipIsLoggerOn(LoggerId);
        if (LoggerContext != NULL) {
            if (LoggerContext->EnableFlags & EVENT_TRACE_FLAG_PROCESS) {
                Header = WmiReserveWithSystemHeader( LoggerId,
                                                     Size,
                                                     NULL,
                                                     &BufferResource);
                if (Header) {
                    if(Create) {
                        Header->Packet.HookId = WMI_LOG_TYPE_PROCESS_CREATE;
                    } else {
                        Header->Packet.HookId = WMI_LOG_TYPE_PROCESS_DELETE;
                    }
                    ProcessInfo = (PWMI_PROCESS_INFORMATION) (Header + 1);

                    ProcessInfo->PageDirectoryBase = MmGetDirectoryFrameFromProcess(Process);
                    ProcessInfo->ProcessId = HandleToUlong(Process->UniqueProcessId);
                    ProcessInfo->ParentId = HandleToUlong(Process->InheritedFromUniqueProcessId);
                    ProcessInfo->SessionId = MmGetSessionId (Process);
                    ProcessInfo->ExitStatus = (Create ? STATUS_SUCCESS : Process->ExitStatus);

                    AuxPtr = (PCHAR) (&ProcessInfo->Sid);

                    if (LocalUser != NULL) {
                        RtlCopyMemory(AuxPtr, LocalUser, SidLength);
                    } else {
                        *((PULONG) AuxPtr) = 0;
                    }

                    AuxPtr += SidLength;

                    if (ImageLength != 0) {
                        Dst = AuxPtr;
                        if (LongImageName) {
                            // ImageOnlyLength is from SeLocateProcessImageName(), 
                            // so we can trust it.
                            RtlCopyMemory (Dst, Src, ImageOnlyLength);
                            Dst += ImageOnlyLength;
                            *Dst++ = '\0';
                        } else {
                            // Copy 16 char name. Src is alwasy NULL-terminated.
                            while (*Dst++ = *Src++) {
                                ;
                            }
                        }
                    }

                    WmipReleaseTraceBuffer(BufferResource, LoggerContext);
                }

            }
        }
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmiTraceProcess: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    }
    if (LongImageName) {
        RtlFreeAnsiString (&AnsiImageFileName);
    }
    if (LocalUser != NULL) {
        ExFreePool(LocalUser);
    }
}


NTKERNELAPI
VOID
WmiTraceThread(
    IN PETHREAD Thread,
    IN PINITIAL_TEB InitialTeb OPTIONAL,
    IN BOOLEAN Create
    )
/*++

Routine Description:

    This callout routine is called from ps\create.c and ps\psdelete.c.
    It is a PCREATE_THREAD_NOTIFY_ROUTINE.

Arguments:

    Thread - PETHREAD structure
    InitialTeb - PINITIAL_TEB
    Create - True if intended thread is being created.

Return Value:

    None

--*/

{
    ULONG LoggerId;
    PSYSTEM_TRACE_HEADER Header;
    PVOID BufferResource;
    PWMI_LOGGER_CONTEXT LoggerContext;
#if DBG
    LONG RefCount;
#endif


    PAGED_CODE();

    if ((WmipIsLoggerOn(WmipKernelLogger) == NULL) &&
        (WmipIsLoggerOn(WmipEventLogger) == NULL)) {
        return;
    }

    for (LoggerId = 0; LoggerId < MAXLOGGERS; LoggerId++) {
        if (LoggerId != WmipKernelLogger && LoggerId != WmipEventLogger) {
            continue;
        }
#if DBG
        RefCount =
#endif
        WmipReferenceLogger(LoggerId);
        TraceDebug((4, "WmiTraceThread: %d %d->%d\n",
                     LoggerId, RefCount-1, RefCount));        

        LoggerContext = WmipIsLoggerOn(LoggerId);
        if (LoggerContext != NULL) {
            if (LoggerContext->EnableFlags & EVENT_TRACE_FLAG_THREAD) {
                if (Create) {
                        PWMI_EXTENDED_THREAD_INFORMATION ThreadInfo;
                    Header = (PSYSTEM_TRACE_HEADER)
                              WmiReserveWithSystemHeader( LoggerId,
                                                          sizeof(WMI_EXTENDED_THREAD_INFORMATION),
                                                          NULL,
                                                          &BufferResource);

                    if (Header) {
                        Header->Packet.HookId = WMI_LOG_TYPE_THREAD_CREATE;
                        ThreadInfo = (PWMI_EXTENDED_THREAD_INFORMATION) (Header + 1);

                            ThreadInfo->ProcessId = HandleToUlong(Thread->Cid.UniqueProcess);
                            ThreadInfo->ThreadId = HandleToUlong(Thread->Cid.UniqueThread);
                            ThreadInfo->StackBase = Thread->Tcb.StackBase;
                            ThreadInfo->StackLimit = Thread->Tcb.StackLimit;

                            if (InitialTeb != NULL) {
                                    if ((InitialTeb->OldInitialTeb.OldStackBase == NULL) &&
                                        (InitialTeb->OldInitialTeb.OldStackLimit == NULL)) {
                                            ThreadInfo->UserStackBase = InitialTeb->StackBase;
                                            ThreadInfo->UserStackLimit = InitialTeb->StackLimit;
                                    } else {
                                            ThreadInfo->UserStackBase = InitialTeb->OldInitialTeb.OldStackBase;
                                            ThreadInfo->UserStackLimit = InitialTeb->OldInitialTeb.OldStackLimit;
                                    }
                            } else {
                                    ThreadInfo->UserStackBase = NULL;
                                    ThreadInfo->UserStackLimit = NULL;
                            }

                            ThreadInfo->StartAddr = (Thread)->StartAddress;
                            ThreadInfo->Win32StartAddr = (Thread)->Win32StartAddress;
                            ThreadInfo->WaitMode = -1;

                        WmipReleaseTraceBuffer(BufferResource, LoggerContext);
                    }
                } else {
                        PWMI_THREAD_INFORMATION ThreadInfo;
                    Header = (PSYSTEM_TRACE_HEADER)
                              WmiReserveWithSystemHeader( LoggerId,
                                                          sizeof(WMI_THREAD_INFORMATION),
                                                          NULL,
                                                          &BufferResource);

                    if (Header) {
                        Header->Packet.HookId = WMI_LOG_TYPE_THREAD_DELETE;
                        ThreadInfo = (PWMI_THREAD_INFORMATION) (Header + 1);
                            ThreadInfo->ProcessId = HandleToUlong((Thread)->Cid.UniqueProcess);
                            ThreadInfo->ThreadId = HandleToUlong((Thread)->Cid.UniqueThread);
                        WmipReleaseTraceBuffer(BufferResource, LoggerContext);
                    }
                }
            }
        }
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmiTraceThread: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    }
}


VOID
FASTCALL
WmipTracePageFault(
    IN NTSTATUS Status,
    IN PVOID VirtualAddress,
    IN PVOID TrapFrame
    )
/*++

Routine Description:

    This callout routine is called from mm\mmfault.c.
    It is a PPAGE_FAULT_NOTIFY_ROUTINE

Arguments:

    Status              Used to tell the type of fault
    VirtualAddress      The virtual address responsible for the fault
    TrapFrame           Trap Frame

Return Value:

    None

--*/

{
    UCHAR Type;
    PVOID *AuxInfo;
    PSYSTEM_TRACE_HEADER Header;
    PVOID BufferResource;
    PWMI_LOGGER_CONTEXT LoggerContext;

    if (Status == STATUS_PAGE_FAULT_DEMAND_ZERO)
        Type = EVENT_TRACE_TYPE_MM_DZF;
    else if (Status == STATUS_PAGE_FAULT_TRANSITION)
        Type = EVENT_TRACE_TYPE_MM_TF;
    else if (Status == STATUS_PAGE_FAULT_COPY_ON_WRITE)
        Type = EVENT_TRACE_TYPE_MM_COW;
    else if (Status == STATUS_PAGE_FAULT_PAGING_FILE)
        Type = EVENT_TRACE_TYPE_MM_HPF;
    else if (Status == STATUS_PAGE_FAULT_GUARD_PAGE)
        Type = EVENT_TRACE_TYPE_MM_GPF;
    else {
#if DBG
        DbgPrintEx(DPFLTR_WMILIB_ID,
                   DPFLTR_INFO_LEVEL,
                   "WmipTracePageFault: Skipping fault %X\n",
                   Status);
#endif
        return;
    }

    LoggerContext = WmipIsLoggerOn(WmipKernelLogger);
    if (LoggerContext == NULL) {
        return;
    }

    Header = (PSYSTEM_TRACE_HEADER)
             WmiReserveWithSystemHeader(
                WmipKernelLogger,
                2 * sizeof(PVOID),
                NULL,
                &BufferResource);

    if (Header == NULL)
        return;
    Header->Packet.Group = (UCHAR) (EVENT_TRACE_GROUP_MEMORY >> 8);
    Header->Packet.Type  = Type;

    AuxInfo = (PVOID*) ((PCHAR)Header + sizeof(SYSTEM_TRACE_HEADER));

    AuxInfo[0] = VirtualAddress;
    AuxInfo[1] = 0;
    if (TrapFrame != NULL) {

#ifdef _X86_

        AuxInfo[1] = (PVOID) ((PKTRAP_FRAME)TrapFrame)->Eip;

#endif

#ifdef _IA64_

        AuxInfo[1] = (PVOID) ((PKTRAP_FRAME)TrapFrame)->StIIP;
#endif

#ifdef _AMD64_

        AuxInfo[1] = (PVOID) ((PKTRAP_FRAME)TrapFrame)->Rip;

#endif

    }
    WmipReleaseTraceBuffer(BufferResource, LoggerContext);
    return;
}

VOID
WmipTraceNetwork(
    IN ULONG GroupType,         // Group/type for the event
    IN PVOID EventInfo,         // Event data as defined in MOF
    IN ULONG EventInfoLen,      // Length of the event data
    IN PVOID Reserved           // not used
    )
/*++

Routine Description:

    This callout routine is called from tcpip.sys to log a network event.

Arguments:

    GroupType       a ULONG key to indicate the action 

    EventInfo       a pointer to contiguous memory containing information
                    to be attached to event trace

    EventInfoLen    length of EventInfo

    Reserved        Not used.

Return Value:

    None

--*/
{
    PPERFINFO_TRACE_HEADER Header;
    PWMI_BUFFER_HEADER BufferResource;
    PWMI_LOGGER_CONTEXT LoggerContext;
    
    UNREFERENCED_PARAMETER (Reserved);

    LoggerContext = WmipLoggerContext[WmipKernelLogger];
    Header = WmiReserveWithPerfHeader(EventInfoLen, &BufferResource);
    if (Header == NULL) {
        return;
    }

    Header->Packet.HookId = (USHORT) GroupType;
    RtlCopyMemory((PUCHAR)Header + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data),
                  EventInfo, 
                  EventInfoLen);

    WmipReleaseTraceBuffer(BufferResource, LoggerContext);
    return;
}

VOID
WmipTraceIo(
    IN ULONG DiskNumber,
    IN PIRP Irp,
    IN PVOID Counters   // use PDISK_PERFORMANCE if we need it
    )
/*++

Routine Description:

    This callout routine is called from DiskPerf
    It is a PPHYSICAL_DISK_IO_NOTIFY_ROUTINE

Arguments:

    DiskNumber          The disk number assigned by DiskPerf
    CurrentIrpStack     The Irp stack location that DiskPerf is at
    Irp                 The Irp that is being passed through DiskPerf

Return Value:

    None

--*/

{
    PIO_STACK_LOCATION CurrentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    WMI_DISKIO_READWRITE *IoTrace;
    ULONG Size;
    PLARGE_INTEGER IoResponse;
    PSYSTEM_TRACE_HEADER Header;
    PVOID BufferResource;
    PWMI_LOGGER_CONTEXT LoggerContext;
    ULONG FileTraceOn = WmipTraceFileFlag;
    PFILE_OBJECT fileObject = NULL;
    PTRACE_FILE_WORK_ITEM TraceFileWorkQueueItem;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(Counters);

    Size = sizeof(struct _WMI_DISKIO_READWRITE);

    LoggerContext = WmipIsLoggerOn(WmipKernelLogger);
    if (LoggerContext == NULL) {
        return;
    }

    Header = (PSYSTEM_TRACE_HEADER)
             WmiReserveWithSystemHeader(
                WmipKernelLogger,
                Size,
                Irp->Tail.Overlay.Thread,
                &BufferResource);

    if (Header == NULL) {
        return;
    }

    Header->Packet.Group = (UCHAR) (EVENT_TRACE_GROUP_IO >> 8);
    if (CurrentIrpStack->MajorFunction == IRP_MJ_READ)
        Header->Packet.Type = EVENT_TRACE_TYPE_IO_READ;
    else
        Header->Packet.Type = EVENT_TRACE_TYPE_IO_WRITE;

    IoTrace = (struct _WMI_DISKIO_READWRITE *)
              ((PCHAR) Header + sizeof(SYSTEM_TRACE_HEADER));
    IoResponse          = (PLARGE_INTEGER) &CurrentIrpStack->Parameters.Read;

    IoTrace->DiskNumber = DiskNumber;
    IoTrace->IrpFlags   = Irp->Flags;
    IoTrace->Size       = (ULONG) Irp->IoStatus.Information;
    IoTrace->ByteOffset = CurrentIrpStack->Parameters.Read.ByteOffset.QuadPart;
    IoTrace->ResponseTime = (ULONG) IoResponse->QuadPart;

    if (IoResponse->HighPart == 0) {
        IoTrace->ResponseTime = IoResponse->LowPart;
    } else {
        IoTrace->ResponseTime = 0xFFFFFFFF;
    }
    IoTrace->HighResResponseTime = IoResponse->QuadPart;

    if (FileTraceOn) {
        PFILE_OBJECT *fileTable;
        ULONG i;
        ULONG LoggerId;
        ULONG currentValue, newValue, retValue;
#if DBG
        LONG RefCount;
#endif

        if (Irp->Flags & IRP_ASSOCIATED_IRP) {
            PIRP AssociatedIrp = Irp->AssociatedIrp.MasterIrp;
            if (AssociatedIrp != NULL) {
                fileObject = AssociatedIrp->Tail.Overlay.OriginalFileObject;
            }
        } else {
            fileObject = Irp->Tail.Overlay.OriginalFileObject;
        }
        IoTrace->FileObject = fileObject;

        //
        // We are done with the IO Hook. Release the Buffer but take 
        // a refcount on the logger context so that the fileTable 
        // does not go away. 
        //
        LoggerId = LoggerContext->LoggerId;

#if DBG
        RefCount =
#endif
        WmipReferenceLogger(LoggerId);
        TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                     LoggerId, RefCount-1, RefCount));

        WmipReleaseTraceBuffer(BufferResource, LoggerContext);

        //
        // Rules for validating a file object.
        //
        // 1. File obejct cannot be NULL.
        // 2. Thread field in the IRP cannot be NULL.
        // 3. We log only paging and user mode IO.

        fileTable = (PFILE_OBJECT *) WmipFileTable;

        if ( (fileObject == NULL) ||
             (Irp->Tail.Overlay.Thread == NULL) ||
             ((!(Irp->Flags & IRP_PAGING_IO)) && (Irp->RequestorMode != UserMode)) ||
             (fileTable == NULL) ||
             (fileObject->FileName.Length == 0) ) {
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));

            return;
        }

        //
        // File Cache: WmipFileIndex points to a slot for next entry. 
        // Start with previous index and scan the table backwards. 
        // If found, return else queue work item after checking max work 
        // item limit. 
        //


        currentValue = WmipFileIndex;

        for (i=0; i <MAX_FILE_TABLE_SIZE; i++) {

            if (currentValue == 0) {
                currentValue = MAX_FILE_TABLE_SIZE - 1;
            }
            else {
                currentValue--;
            }
            if (fileTable[currentValue] == fileObject) {
                //
                // CacheHit
                //
#if DBG
                RefCount =
#endif
                WmipDereferenceLogger(LoggerId);
                TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                            LoggerId, RefCount+1, RefCount));
                return;
            }
        }


        //
        // Cache Miss: First check for work item queue throttle
        //
        
        retValue = WmipWorkItemCounter;
        do {
            currentValue = retValue;
            if (currentValue == ETW_WORK_ITEM_LIMIT) {
#if DBG
                RefCount =
#endif
                WmipDereferenceLogger(LoggerId);
                TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                            LoggerId, RefCount+1, RefCount));
                return;

            } else {
                newValue = currentValue + 1;
            }
            retValue = InterlockedCompareExchange(&WmipWorkItemCounter, newValue, currentValue);
        } while (currentValue != retValue);



        //
        // Cache Miss: Simply kick out the next item based on global index
        // while ensuring that the WmipFileIndex is always in range. 
        //

        retValue = WmipFileIndex;
        do {
            currentValue = retValue;
            if (currentValue == (MAX_FILE_TABLE_SIZE - 1)) {
                newValue = 0;
            } else {
                newValue = currentValue + 1;
            }
            retValue = InterlockedCompareExchange(&WmipFileIndex, newValue, currentValue); 
        } while (currentValue != retValue);

        //
        // Allocate additional memory (upto 4K) with the work item allocation.
        // This space is used in WmipTraceFile for ObQueryNameString call
        //

        TraceFileWorkQueueItem = ExAllocatePoolWithTag(NonPagedPool, 
                                                      MAX_FILENAME_TO_LOG, 
                                                      TRACEPOOLTAG);
        if (TraceFileWorkQueueItem == NULL) {
            InterlockedDecrement(&WmipWorkItemCounter);
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));
            return;
        }

        Status = ObReferenceObjectByPointer (
                    fileObject,
                    0L,
                    IoFileObjectType,
                    KernelMode
                    );

        if (!NT_SUCCESS(Status)) {
            ExFreePool(TraceFileWorkQueueItem);
            InterlockedDecrement(&WmipWorkItemCounter);
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));
            return;
        }

        ExInitializeWorkItem(
            &TraceFileWorkQueueItem->WorkItem,
            WmipTraceFile,
            TraceFileWorkQueueItem
            );

        TraceFileWorkQueueItem->FileObject            = fileObject;
        TraceFileWorkQueueItem->BufferSize            = MAX_FILENAME_TO_LOG;

        //
        // Insert the fileObject into the table before queuing work item
        //

        ASSERT(retValue < MAX_FILE_TABLE_SIZE);
        fileTable[retValue] = fileObject;

#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmiTraceFile: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

        ExQueueWorkItem(
            &TraceFileWorkQueueItem->WorkItem,
            DelayedWorkQueue
            );

    }
    else {
        WmipReleaseTraceBuffer(BufferResource, LoggerContext);
    }
    return;
}

VOID WmipTraceFile(
    IN PVOID TraceFileContext
    )
{
    ULONG len;
    PFILE_OBJECT fileObject;
    PUNICODE_STRING fileName;
    PPERFINFO_TRACE_HEADER Header;
    PWMI_BUFFER_HEADER BufferResource;
    PUCHAR AuxPtr;
    PWMI_LOGGER_CONTEXT LoggerContext;
    NTSTATUS Status;
    POBJECT_NAME_INFORMATION FileNameInfo;
    ULONG FileNameInfoOffset, ReturnLen;
    PTRACE_FILE_WORK_ITEM WorkItem = (PTRACE_FILE_WORK_ITEM) TraceFileContext;
#if DBG
    LONG RefCount;
#endif

    PAGED_CODE();


    FileNameInfoOffset = (ULONG) ALIGN_TO_POWER2(sizeof(TRACE_FILE_WORK_ITEM), WmiTraceAlignment);

    FileNameInfo = (POBJECT_NAME_INFORMATION) ((PUCHAR)TraceFileContext + 
                                                       FileNameInfoOffset);
    fileObject = WorkItem->FileObject;
    ASSERT(fileObject != NULL);
    ASSERT(WorkItem->BufferSize > FileNameInfoOffset);


    Status = ObQueryNameString( fileObject,
                                FileNameInfo,
                                WorkItem->BufferSize - FileNameInfoOffset,
                                &ReturnLen
                                );
    ObDereferenceObject(fileObject);

    if (NT_SUCCESS (Status)) {

        fileName = &FileNameInfo->Name;
        len = fileName->Length;

        if ((len > 0) && (fileName->Buffer != NULL)) {

            ULONG LoggerId = WmipKernelLogger;
            if (LoggerId < MAXLOGGERS) {
#if DBG
                RefCount =
#endif
                WmipReferenceLogger(LoggerId);
                TraceDebug((4, "WmipTraceFile: %d %d->%d\n",
                             LoggerId, RefCount-1, RefCount));
                LoggerContext = WmipIsLoggerOn(LoggerId);
                if (LoggerContext != NULL) {

                    Header = WmiReserveWithPerfHeader(
                                sizeof(PFILE_OBJECT) + len + sizeof(WCHAR),
                                &BufferResource);
                    if (Header != NULL) {
                        Header->Packet.Group = (UCHAR)(EVENT_TRACE_GROUP_FILE >> 8);
                        Header->Packet.Type  = EVENT_TRACE_TYPE_INFO;
                        AuxPtr = (PUCHAR)Header + 
                                 FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

                        *((PFILE_OBJECT*)AuxPtr) = fileObject;
                        AuxPtr += sizeof(PFILE_OBJECT);
    
                        RtlCopyMemory(AuxPtr, fileName->Buffer, len);
                        AuxPtr += len;
                        *((PWCHAR) AuxPtr) = UNICODE_NULL; // always put a NULL
    
                        WmipReleaseTraceBuffer(BufferResource, LoggerContext);
                    }
                }
#if DBG
                RefCount =
#endif
                WmipDereferenceLogger(LoggerId);
                TraceDebug((4, "WmiTraceThread: %d %d->%d\n",
                            LoggerId, RefCount+1, RefCount));
            }
        }
    }

    ExFreePool(TraceFileContext);
    InterlockedDecrement(&WmipWorkItemCounter);
}

VOID
WmipTraceLoadImage(
    IN PUNICODE_STRING ImageName,
    IN HANDLE ProcessId,
    IN PIMAGE_INFO ImageInfo
    )
{
    PSYSTEM_TRACE_HEADER Header;
    PUCHAR AuxInfo;
    PVOID BufferResource;
    ULONG Length, LoggerId;
    PWMI_LOGGER_CONTEXT LoggerContext;
#if DBG
    LONG RefCount;
#endif


    PAGED_CODE();
    UNREFERENCED_PARAMETER(ProcessId);

    if ((WmipIsLoggerOn(WmipKernelLogger) == NULL) &&
        (WmipIsLoggerOn(WmipEventLogger) == NULL)) {
        return;
    }
    if (ImageName == NULL) {
        return;
    }
    Length = ImageName->Length;
    if ((Length == 0) || (ImageName->Buffer == NULL)) {
        return;
    }

    for (LoggerId = 0; LoggerId < MAXLOGGERS; LoggerId++) {
        if (LoggerId != WmipKernelLogger && LoggerId != WmipEventLogger) {
            continue;
        }
#if DBG
        RefCount =
#endif
        WmipReferenceLogger(LoggerId);
        TraceDebug((4, "WmipTraceLoadImage: %d %d->%d\n",
                     LoggerId, RefCount-1, RefCount));        

        LoggerContext = WmipIsLoggerOn(LoggerId);
        if (LoggerContext != NULL) {
            if (LoggerContext->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) {
                PWMI_IMAGELOAD_INFORMATION ImageLoadInfo;

                Header = WmiReserveWithSystemHeader(
                            LoggerId,
                            FIELD_OFFSET (WMI_IMAGELOAD_INFORMATION, FileName) + Length + sizeof(WCHAR),
                            NULL,
                            &BufferResource);

                if (Header != NULL) {
                    Header->Packet.HookId = WMI_LOG_TYPE_PROCESS_LOAD_IMAGE;

                    ImageLoadInfo = (PWMI_IMAGELOAD_INFORMATION) (Header + 1);

                    ImageLoadInfo->ImageBase = ImageInfo->ImageBase;
                    ImageLoadInfo->ImageSize = ImageInfo->ImageSize;
                    ImageLoadInfo->ProcessId = HandleToUlong(ProcessId);

                    AuxInfo = (PUCHAR) &(ImageLoadInfo->FileName[0]);
                    RtlCopyMemory(AuxInfo, ImageName->Buffer, Length);
                    AuxInfo += Length;
                    *((PWCHAR) AuxInfo) = UNICODE_NULL; // put a trailing NULL

                    WmipReleaseTraceBuffer(BufferResource, LoggerContext);
                }
            }
        }
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmipTraceLoadImage: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    }
    PerfInfoFlushProfileCache();
}

VOID
WmipTraceRegistry(
    IN NTSTATUS         Status,
    IN PVOID            Kcb,
    IN LONGLONG         ElapsedTime,
    IN ULONG            Index,
    IN PUNICODE_STRING  KeyName,
    IN UCHAR            Type
    )
/*++

Routine Description:

    This routine is called to trace out registry calls

Arguments:

Return Value:

    None

--*/

{
    PCHAR   EventInfo;
    PSYSTEM_TRACE_HEADER Header;
    PVOID BufferResource;
    ULONG len = 0;
    PWMI_LOGGER_CONTEXT LoggerContext;

    PAGED_CODE();

    LoggerContext = WmipIsLoggerOn(WmipKernelLogger);
    if (LoggerContext == NULL) {
        return;
    }

    try {
        if( KeyName && KeyName->Buffer && KeyName->Length) {
            len += KeyName->Length;
            //
            // make sure it is a valid unicode string
            //
            if( len & 1 ) {
                len -= 1;
            }

            if ((len ==0 ) || (KeyName->Buffer[len/sizeof(WCHAR) -1] != 0) ) {
                //
                // make room for NULL terminator
                //
                len += sizeof(WCHAR);
            }
        } else {
            len += sizeof(WCHAR);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        // KeyName buffer is from user. AV can happen.
        return;
    }

    len += sizeof(PVOID) + sizeof(LONGLONG) + sizeof(ULONG);
#if defined(_WIN64)
    len += sizeof(LONG64);
#else
    len += sizeof(NTSTATUS);
#endif

    Header = (PSYSTEM_TRACE_HEADER)
             WmiReserveWithSystemHeader(
                        WmipKernelLogger,
                        len,
                        NULL,
                        &BufferResource);
    if (Header == NULL) {
        return;
    }

    Header->Packet.Group = (UCHAR) (EVENT_TRACE_GROUP_REGISTRY >> 8);
    Header->Packet.Type = Type;

    EventInfo = (PCHAR) ((PCHAR) Header + sizeof(SYSTEM_TRACE_HEADER));
#if defined(_WIN64)
    *((LONG64 *)EventInfo) = (LONG64)Status;
    EventInfo += sizeof(LONG64);
#else
    *((NTSTATUS *)EventInfo) = Status;
    EventInfo += sizeof(NTSTATUS);
#endif
    *((PVOID *)EventInfo) = Kcb;
    EventInfo += sizeof(PVOID);
    *((LONGLONG *)EventInfo) = ElapsedTime;
    EventInfo += sizeof(LONGLONG);
    *((ULONG *)EventInfo) = Index;
    EventInfo += sizeof(ULONG);

    len -= (sizeof(HANDLE) + sizeof(LONGLONG) + sizeof(ULONG) );
#if defined(_WIN64)
    len -= sizeof(LONG64);
#else
    len -= sizeof(NTSTATUS);
#endif

    try {
        if( KeyName && KeyName->Buffer && KeyName->Length) {
            RtlCopyMemory(EventInfo, KeyName->Buffer, len - sizeof(WCHAR));
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        // Cleanup just in case
        RtlZeroMemory(EventInfo, len - sizeof(WCHAR));
    }

    ((PWCHAR)EventInfo)[len/sizeof(WCHAR) -1] = UNICODE_NULL;

    WmipReleaseTraceBuffer(BufferResource, LoggerContext);
}

VOID
FASTCALL
WmiTraceContextSwap (
    IN PETHREAD OldEThread,
    IN PETHREAD NewEThread )
/*++

Routine Description:

    This routine is called to trace context swap
    operations.  It is called directly from the
    context swap procedure while the context swap
    lock is being held, so it is critical that this
    routine not take any locks.

    Assumptions:
    - This routine will only be called from the ContextSwap routine
    - This routine will always be called at IRQL >= DISPATCH_LEVEL
    - This routine will only be called when the PPerfGlobalGroupMask
      is not equal to null, and the context swap flag is set within 
      the structure to which PPerfGlobalGroupMask points to,
      and the kernel's WMI_LOGGER_CONTEXT struct has been fully initialized.
    - The Wmi kernel WMI_LOGGER_CONTEXT object, as well as all buffers
      it allocates are allocated from nonpaged pool.  All Wmi globals
      that we access are also in nonpaged memory.
    - This code has been locked into paged memory when the logger started
    - The logger context reference count has been incremented via the 
      InterlockedIncrement() operation in WmipReferenceLogger(WmipKernelLogger)
      by our start code.


Arguments:
    OldThread - ptr to ETHREAD object of thread
                being swapped out
    NewThread - ptr to ETHREAD object of thread
                being swapped in

Return Value:

    None

--*/
{
    UCHAR                       CurrentProcessor;
    PWMI_BUFFER_HEADER          Buffer;
    PPERFINFO_TRACE_HEADER      EventHeader;
    SIZE_T                      EventSize;
    PWMI_CONTEXTSWAP            ContextSwapData;

    //
    // Figure out which processor we are running on
    //
    CurrentProcessor = (UCHAR)KeGetCurrentProcessorNumber();

    //
    // If we currently have no context swap buffer for this processor
    // then we need to grab one from the ETW Free list.
    //
    Buffer = WmipContextSwapProcessorBuffers[CurrentProcessor];

    if (Buffer == NULL) {

        Buffer = WmipPopFreeContextSwapBuffer(
            CurrentProcessor);

        if( Buffer == NULL ) {
            return;
        }

        //
        // We have a legitimate buffer, so now we
        // set it as this processor's current cxtswap buffer
        //
        WmipContextSwapProcessorBuffers[CurrentProcessor] = Buffer;
    }
    
    if (Buffer->Offset <= Buffer->CurrentOffset) {
        //
        // Due to an rare unfortunate timing issue with buffer recycle, 
        // buffer CurrentOffset is corrupt. We should not write over
        // buffer boundary.
        //
        WmipPushDirtyContextSwapBuffer(CurrentProcessor, Buffer);
        //
        // Zero out the processor buffer pointer so that when we next come
        // into the trace code, we know to grab another one.
        //
        WmipContextSwapProcessorBuffers[CurrentProcessor] = NULL;

        return;
    }

    //
    // Compute the pointers to our event structures within the buffer
    // At this point, we will always have enough space in the buffer for
    // this event.  We check for a full buffer after we fill out the event
    //
    EventHeader     = (PPERFINFO_TRACE_HEADER)( (SIZE_T)Buffer
                    + (SIZE_T)Buffer->CurrentOffset);
    
    ContextSwapData = (PWMI_CONTEXTSWAP)( (SIZE_T)EventHeader
                    + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

    EventSize       = sizeof(WMI_CONTEXTSWAP)
                    + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);


    //
    // Fill out the event header
    //
    EventHeader->Marker = PERFINFO_TRACE_MARKER;
    EventHeader->Packet.Size = (USHORT) EventSize;
    EventHeader->Packet.HookId = PERFINFO_LOG_TYPE_CONTEXTSWAP;
    PerfTimeStamp(EventHeader->SystemTime);

    //
    // Assert that the event size is at alligned correctly
    //
    ASSERT( EventSize % WMI_CTXSWAP_EVENTSIZE_ALIGNMENT == 0);

    //
    // Fill out the event data struct for context swap
    //
    ContextSwapData->NewThreadId = HandleToUlong(NewEThread->Cid.UniqueThread);
    ContextSwapData->OldThreadId = HandleToUlong(OldEThread->Cid.UniqueThread);
    
    ContextSwapData->NewThreadPriority  = NewEThread->Tcb.Priority;
    ContextSwapData->OldThreadPriority  = OldEThread->Tcb.Priority;
    ContextSwapData->NewThreadQuantum   = NewEThread->Tcb.Quantum;
    ContextSwapData->OldThreadQuantum   = OldEThread->Tcb.Quantum;
    
    ContextSwapData->OldThreadWaitReason= OldEThread->Tcb.WaitReason;
    ContextSwapData->OldThreadWaitMode  = OldEThread->Tcb.WaitMode;
    ContextSwapData->OldThreadState     = OldEThread->Tcb.State;
    
    ContextSwapData->OldThreadIdealProcessor = 
        OldEThread->Tcb.IdealProcessor;
    
    //
    // Increment the offset.  Don't need synchronization here because
    // IRQL >= DISPATCH_LEVEL.
    //
    Buffer->CurrentOffset += (ULONG)EventSize;
    
    //
    // Check if the buffer is full by taking the difference between
    // the buffer's maximum offset and the current offset.
    //
    if ((Buffer->Offset - Buffer->CurrentOffset) <= EventSize) {

        //
        // Push the full buffer onto the FlushList.
        //
        WmipPushDirtyContextSwapBuffer(CurrentProcessor, Buffer);

        //
        // Zero out the processor buffer pointer so that when we next come
        // into the trace code, we know to grab another one.
        //
        WmipContextSwapProcessorBuffers[CurrentProcessor] = NULL;
    }

    return;
}

VOID
FASTCALL
WmiStartContextSwapTrace
    (
    )
/*++

Routine Description:

    Allocates the memory to track the per-processor buffers
    used by context swap tracing.  "locks" the logger by incrementing
    the logger context reference count by one.

    Assumptions:
    - This function will not run at DISPATCH or higher
    - The kernel logger context mutex has been acquired before entering
      this function.

    Calling Functions:
    - PerfInfoStartLog
    
Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Only used in checked builds - asserts if this code is called with
    // Irql > APC_LEVEL.
    //
    PAGED_CODE();

    //
    // Set the pointers to our buffers to NULL, indicating to the trace event
    // code that a buffer needs to be acquired.
    //
    RtlZeroMemory(
        WmipContextSwapProcessorBuffers,
        sizeof(PWMI_BUFFER_HEADER)*MAXIMUM_PROCESSORS);
}

VOID
FASTCALL
WmiStopContextSwapTrace
    (
    )
/*++

Routine Description:

    Forces a context swap on a processor by jumping onto it.
    Once a context swap has occured on a processor after the context
    swap tracing flag has been disabled, we are guaranteed that the
    buffer associated with that processor is not in use.  It is then
    safe to place that buffer on the flush list.

    Assumptions:
    - This function will not run at DISPATCH
    - The kernel logger context mutex was acquired before this function
      was called.

    Calling Functions:
    -PerfInfoStopLog

Arguments:

    None
    
Return Value:

    None; if we fail here there's nothing we can do anyway.

--*/
{
    PKTHREAD            ThisThread;
    KAFFINITY           OriginalAffinity;
    UCHAR               i;
    PWMI_LOGGER_CONTEXT LoggerContext;

    //
    // Only used in checked builds - asserts if this code is called with
    // Irql > APC_LEVEL.
    //
    PAGED_CODE();

    //
    // Remember the original thread affinity
    //
    ThisThread = KeGetCurrentThread();
    OriginalAffinity = ThisThread->Affinity;

    //
    // Get the kernel logger context- this should never fail.
    // If we can't get the logger context, then we have nowhere
    // to flush buffers and we might as well stop here.
    //
    LoggerContext = WmipLoggerContext[WmipKernelLogger];
    
    if( !WmipIsValidLogger( LoggerContext ) ) {
        return;
    }

    //
    // Loop through all processors and place their buffers on the flush list
    // This would probably break if the number of processors were decreased in
    // the middle of the trace.
    //
    for(i=0; i<KeNumberProcessors; i++) {
    
        //
        // Set the hard processor affinity to 1 << i
        // This effectively jumps onto the processor
        //
        KeSetSystemAffinityThread ( AFFINITY_MASK(i) );

        //
        // Check to make sure this processor even has a buffer, 
        // if it doesn't, then next loop
        //
        if(WmipContextSwapProcessorBuffers[i] == NULL) {
            continue;
        }

        //
        // Release the buffer to the flush list
        //
        WmipPushDirtyContextSwapBuffer(i, WmipContextSwapProcessorBuffers[i]);
        WmipContextSwapProcessorBuffers[i] = NULL;
    }

    //
    // Set our Affinity back to normal
    //
    KeSetSystemAffinityThread( OriginalAffinity );
    KeRevertToUserAffinityThread();

    return;
}

PWMI_LOGGER_CONTEXT
FASTCALL
WmipIsLoggerOn(
    IN ULONG LoggerId
    )
{
    PWMI_LOGGER_CONTEXT LoggerContext;

    if (LoggerId >= MAXLOGGERS) {
        return NULL;
    }
    LoggerContext = WmipLoggerContext[LoggerId];
    if (WmipIsValidLogger(LoggerContext)) {
        return LoggerContext;
    }
    else {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\alloc.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    alloc.c

Abstract:

    WMI data structure allocation routines

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmikmp.h"


// HEY: This is duplicated from wmium.h. 
//
// This guid is for notifications of changes to registration
// {B48D49A1-E777-11d0-A50C-00A0C9062910}
GUID GUID_REGISTRATION_CHANGE_NOTIFICATION = {0xb48d49a1, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10};

//
// This guid id for notifications of new mof resources being added
// {B48D49A2-E777-11d0-A50C-00A0C9062910}
GUID GUID_MOF_RESOURCE_ADDED_NOTIFICATION = {0xb48d49a2, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10};

//
// This guid id for notifications of new mof resources being added
// {B48D49A3-E777-11d0-A50C-00A0C9062910}
GUID GUID_MOF_RESOURCE_REMOVED_NOTIFICATION = {0xb48d49a3, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10};


//
// This defines the number of DataSources allocated in each DataSource chunk
#if DBG
#define DSCHUNKSIZE 4
#else
#define DSCHUNKSIZE 64
#endif

void WmipDSCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO WmipDSChunkInfo =
{
    { NULL, NULL },
    sizeof(DATASOURCE),
    DSCHUNKSIZE,
    WmipDSCleanup,
    FLAG_ENTRY_REMOVE_LIST,
    DS_SIGNATURE
};

LIST_ENTRY WmipDSHead;              // Head of registerd data source list
PLIST_ENTRY WmipDSHeadPtr;

//
// This defines the number of GuidEntrys allocated in each GuidEntry chunk
#if DBG
#define GECHUNKSIZE    4
#else
#define GECHUNKSIZE    512
#endif

void WmipGECleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO WmipGEChunkInfo =
{
    { NULL, NULL },
    sizeof(GUIDENTRY),
    GECHUNKSIZE,
    WmipGECleanup,
    FLAG_ENTRY_REMOVE_LIST,
    GE_SIGNATURE
};

LIST_ENTRY WmipGEHead;              // Head of registerd guid list
PLIST_ENTRY WmipGEHeadPtr;

//
// This defines the number of InstanceSets allocated in each InstanceSet chunk
#if DBG
#define ISCHUNKSIZE    4
#else
#define ISCHUNKSIZE    2048
#endif

void WmipISCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO WmipISChunkInfo =
{
    { NULL, NULL },
    sizeof(INSTANCESET),
    ISCHUNKSIZE,
    WmipISCleanup,
    0,
    IS_SIGNATURE
};

#if DBG
#define MRCHUNKSIZE    2
#else
#define MRCHUNKSIZE    16
#endif

void WmipMRCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO WmipMRChunkInfo =
{
    { NULL, NULL },
    sizeof(MOFRESOURCE),
    MRCHUNKSIZE,
    WmipMRCleanup,
    FLAG_ENTRY_REMOVE_LIST,
    MR_SIGNATURE
};

LIST_ENTRY WmipMRHead;                     // Head of Mof Resource list
PLIST_ENTRY WmipMRHeadPtr;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, WmipDSCleanup)
#pragma alloc_text (PAGE, WmipAllocDataSource)
#pragma alloc_text (PAGE, WmipGECleanup)
#pragma alloc_text (PAGE, WmipAllocGuidEntryX)
#pragma alloc_text (PAGE, WmipISCleanup)
#pragma alloc_text (PAGE, WmipMRCleanup)
#pragma alloc_text (PAGE, WmipFindGEByGuid)
#pragma alloc_text (PAGE, WmipFindDSByProviderId)
#pragma alloc_text (PAGE, WmipFindISByGuid)
#pragma alloc_text (PAGE, WmipFindMRByNames)
#pragma alloc_text (PAGE, WmipFindISinGEbyName)
#pragma alloc_text (PAGE, WmipRealloc)
#pragma alloc_text (PAGE, WmipIsNumber)
#endif


PBDATASOURCE WmipAllocDataSource(
    void
    )
/*++

Routine Description:

    Allocates a Data Source structure

Arguments:


Return Value:

    pointer to data source structure or NULL if one cannot be allocated

--*/
{
    PBDATASOURCE DataSource;

    DataSource = (PBDATASOURCE)WmipAllocEntry(&WmipDSChunkInfo);
    if (DataSource != NULL)
    {
        InitializeListHead(&DataSource->ISHead);
        DataSource->MofResourceCount = AVGMOFRESOURCECOUNT;
        DataSource->MofResources = DataSource->StaticMofResources;
        memset(DataSource->MofResources,
               0,
               AVGMOFRESOURCECOUNT * sizeof(PMOFRESOURCE));
    }

    return(DataSource);
}

void WmipDSCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*++

Routine Description:

    Cleans up data source structure and any other structures or handles
    associated with it.

Arguments:

    Data source structure to free

Return Value:

--*/
{
    PBDATASOURCE DataSource = (PBDATASOURCE)Entry;
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;
    ULONG i;

    UNREFERENCED_PARAMETER (ChunkInfo);

    WmipAssert(DataSource != NULL);
    WmipAssert(DataSource->Flags & FLAG_ENTRY_INVALID);

    WmipEnterSMCritSection();

    InstanceSetList = DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        DSISList);

        if (InstanceSet->GuidISList.Flink != NULL)
        {
            RemoveEntryList(&InstanceSet->GuidISList);
            InstanceSet->DataSource = NULL;
            InstanceSet->GuidEntry->ISCount--;
        }

        if ((InstanceSet->GuidEntry != NULL) &&
            (! (InstanceSet->Flags & IS_NEWLY_REGISTERED)))
        {

            if (IsEqualGUID(&InstanceSet->GuidEntry->Guid,
                            &WmipBinaryMofGuid))
            {
                WmipLeaveSMCritSection();
            
                WmipGenerateBinaryMofNotification(InstanceSet,
                                     &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION);

                WmipEnterSMCritSection();
            }

            WmipUnreferenceGE(InstanceSet->GuidEntry);
        }
        InstanceSet->GuidEntry = NULL;

        InstanceSetList = InstanceSetList->Flink;

        WmipUnreferenceIS(InstanceSet);
    }

    WmipLeaveSMCritSection();

    for (i = 0; i < DataSource->MofResourceCount; i++)
    {
        if (DataSource->MofResources[i] != NULL)
        {
            WmipUnreferenceMR(DataSource->MofResources[i]);
        }
    }

    if (DataSource->MofResources != DataSource->StaticMofResources)
    {
        WmipFree(DataSource->MofResources);
        DataSource->MofResources = NULL;
    }

    if (DataSource->RegistryPath != NULL)
    {
        WmipFree(DataSource->RegistryPath);
        DataSource->RegistryPath = NULL;
    }
}

void WmipGECleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*++

Routine Description:

    Cleans up guid entry structure and any other structures or handles
    associated with it.

Arguments:

    GuidEntry structure to free

Return Value:

--*/
{
    PBGUIDENTRY GuidEntry = (PBGUIDENTRY)Entry;
    
    UNREFERENCED_PARAMETER (ChunkInfo);

    WmipAssert(GuidEntry != NULL);
    WmipAssert(GuidEntry->Flags & FLAG_ENTRY_INVALID);

    GuidEntry->Guid.Data4[7] ^= 0xff;
    
    if (GuidEntry->CollectInProgress != NULL)
    {
        ExFreePool(GuidEntry->CollectInProgress);
        GuidEntry->CollectInProgress = NULL;
    }

}

PBGUIDENTRY WmipAllocGuidEntryX(
    ULONG LINE,
    PCHAR FILE
    )
{
    PBGUIDENTRY GuidEntry;
    PKEVENT Event;
	
#if ! DBG
	UNREFERENCED_PARAMETER(LINE);
	UNREFERENCED_PARAMETER(FILE);
#endif
    
    GuidEntry = NULL;
    Event = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(KEVENT),
                                  WMIPOOLTAG);

    if (Event != NULL)
    {
        GuidEntry = (PBGUIDENTRY)WmipAllocEntry(&WmipGEChunkInfo);
        if (GuidEntry != NULL)
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, "WMI: %p.%p Create GE %p (%x) at %s %d\n", PsGetCurrentProcessId(), PsGetCurrentThreadId(), GuidEntry, GuidEntry->RefCount, FILE, LINE));
                    
            InitializeListHead(&GuidEntry->ISHead);
            InitializeListHead(&GuidEntry->ObjectHead);
            GuidEntry->CollectInProgress = Event;
        } else {
            ExFreePool(Event);
        }
    }

    return(GuidEntry);
}


void WmipISCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
{
    PBINSTANCESET InstanceSet = (PBINSTANCESET)Entry;

    UNREFERENCED_PARAMETER (ChunkInfo);

    WmipAssert(InstanceSet != NULL);
    WmipAssert(InstanceSet->Flags & FLAG_ENTRY_INVALID);

    if (InstanceSet->IsBaseName != NULL)
    {
        WmipFree(InstanceSet->IsBaseName);
        InstanceSet->IsBaseName = NULL;
    }
}

void WmipMRCleanup(
    IN PCHUNKINFO ChunkInfo,
    IN PENTRYHEADER Entry
    )
{
    PMOFRESOURCE MofResource = (PMOFRESOURCE)Entry;

    PAGED_CODE();
    
    UNREFERENCED_PARAMETER (ChunkInfo);

    if ((MofResource->RegistryPath != NULL) &&
        (MofResource->MofResourceName != NULL) &&
        ((MofResource->Flags & MR_FLAG_USER_MODE) != MR_FLAG_USER_MODE))
    {
        WmipGenerateMofResourceNotification(MofResource->RegistryPath,
                                    MofResource->MofResourceName,
                                    &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION,
                                    MofResource->Flags & MR_FLAG_USER_MODE ?
                                             MOFEVENT_ACTION_IMAGE_PATH :
                                             MOFEVENT_ACTION_REGISTRY_PATH);
    }

    if (MofResource->RegistryPath != NULL)
    {
        WmipFree(MofResource->RegistryPath);
        MofResource->RegistryPath = NULL;
    }

    if (MofResource->MofResourceName != NULL)
    {
        WmipFree(MofResource->MofResourceName);
        MofResource->MofResourceName = NULL;
    }
}


PBGUIDENTRY WmipFindGEByGuid(
    LPGUID Guid,
    BOOLEAN MakeTopOfList
    )
/*++

Routine Description:

    Searches guid list for first occurence of guid. Guid's refcount is
    incremented if found.

Arguments:

    Guid is pointer to guid that is to be found

    MakeTopOfList is TRUE then if NE is found it is placed at the top of the
        NE list

Return Value:

    pointer to guid entry pointer or NULL if not found

--*/
{
    PLIST_ENTRY GuidEntryList;
    PBGUIDENTRY GuidEntry;

    WmipEnterSMCritSection();

    GuidEntryList = WmipGEHeadPtr->Flink;
    while (GuidEntryList != WmipGEHeadPtr)
    {
        GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                      GUIDENTRY,
                                      MainGEList);
        if (IsEqualGUID(Guid, &GuidEntry->Guid))
        {
            WmipReferenceGE(GuidEntry);

            if (MakeTopOfList)
            {
                RemoveEntryList(GuidEntryList);
                InsertHeadList(WmipGEHeadPtr, GuidEntryList);
            }

            WmipLeaveSMCritSection();
            WmipAssert(GuidEntry->Signature == GE_SIGNATURE);
            return(GuidEntry);
        }
        GuidEntryList = GuidEntryList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}


PBDATASOURCE WmipFindDSByProviderId(
    ULONG_PTR ProviderId
    )
/*++

Routine Description:

    This routine finds a DataSource on the provider id passed. DataSource's
    ref  count is incremented if found

Arguments:

    ProviderId is the data source provider id

Return Value:

    DataSource pointer or NULL if no data source was found

--*/
{
    PLIST_ENTRY DataSourceList;
    PBDATASOURCE DataSource;

    WmipEnterSMCritSection();
    DataSourceList = WmipDSHeadPtr->Flink;
    while (DataSourceList != WmipDSHeadPtr)
    {
        DataSource = CONTAINING_RECORD(DataSourceList,
                                      DATASOURCE,
                                      MainDSList);
        if (DataSource->ProviderId == ProviderId)
        {
            WmipReferenceDS(DataSource);
            WmipLeaveSMCritSection();
            WmipAssert(DataSource->Signature == DS_SIGNATURE);
            return(DataSource);
        }

        DataSourceList = DataSourceList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}


PBINSTANCESET WmipFindISByGuid(
    PBDATASOURCE DataSource,
    GUID UNALIGNED *Guid
    )
/*++

Routine Description:

    This routine will find an instance set within a data source list for a
    specific guid. Note that any instance sets that have been replaceed
    (have IS_REPLACED_BY_REFERENCE) are ignored and not returned. The
    InstanceSet that is found has its reference count increased.

Arguments:

    DataSource is the data source whose instance set list is searched
    Guid is a pointer to a guid which defines which instance set list to find

Return Value:

    InstanceSet pointer or NULL if not found

--*/
{
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;

    WmipEnterSMCritSection();
    InstanceSetList = DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                      INSTANCESET,
                                      DSISList);
        if (IsEqualGUID(&InstanceSet->GuidEntry->Guid, Guid))
        {
            WmipReferenceIS(InstanceSet);
            WmipLeaveSMCritSection();
            WmipAssert(InstanceSet->Signature == IS_SIGNATURE);
            return(InstanceSet);
        }

        InstanceSetList = InstanceSetList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}


PMOFRESOURCE WmipFindMRByNames(
    LPCWSTR ImagePath,
    LPCWSTR MofResourceName
    )
/*++

Routine Description:

    Searches mof resource list for a MR that has the same image path and
    resource name. If ine is found a reference count is added to it.

Arguments:

    ImagePath points at a string that has the full path to the image
        file that contains the MOF resource

    MofResourceName points at a string that has the name of the MOF
        resource

Return Value:

    pointer to mof resource or NULL if not found

--*/
{
    PLIST_ENTRY MofResourceList;
    PMOFRESOURCE MofResource;

    WmipEnterSMCritSection();

    MofResourceList = WmipMRHeadPtr->Flink;
    while (MofResourceList != WmipMRHeadPtr)
    {
        MofResource = CONTAINING_RECORD(MofResourceList,
                                      MOFRESOURCE,
                                      MainMRList);
        if ((wcscmp(MofResource->RegistryPath, ImagePath) == 0) &&
            (wcscmp(MofResource->MofResourceName, MofResourceName) == 0))
        {
            WmipReferenceMR(MofResource);
            WmipLeaveSMCritSection();
            WmipAssert(MofResource->Signature == MR_SIGNATURE);
            return(MofResource);
        }
        MofResourceList = MofResourceList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}

BOOLEAN WmipIsNumber(
    LPCWSTR String
    )
{
    while (*String != UNICODE_NULL)
    {
        if ((*String < L'0') || (*String > L'9'))
        {
            return(FALSE);
        }
        String++;
    }
    return(TRUE);
}

PBINSTANCESET WmipFindISinGEbyName(
    PBGUIDENTRY GuidEntry,
    PWCHAR InstanceName,
    PULONG InstanceIndex
    )
/*++

Routine Description:

    This routine finds the instance set containing the instance name passed
    within the GuidEntry passed. If found it will also return the index of
    the instance name within the instance set. The instance set found has its
    ref count incremented.

Arguments:

    GuidEntry contains the instance sets to look through
    InstanceName is the instance name to look for
    *InstanceIndex return instance index within set

Return Value:

    Instance set containing instance name or NULL of instance name not found

--*/
{
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;
    SIZE_T BaseNameLen;
    PWCHAR InstanceNamePtr;
    ULONG InstanceNameIndex;
    ULONG InstanceSetFirstIndex, InstanceSetLastIndex;
    ULONG i;

    WmipEnterSMCritSection();
    InstanceSetList = GuidEntry->ISHead.Flink;
    while (InstanceSetList != &GuidEntry->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
        if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
        {
            BaseNameLen = wcslen(InstanceSet->IsBaseName->BaseName);
            if (wcsncmp(InstanceName,
                        InstanceSet->IsBaseName->BaseName,
                        BaseNameLen) == 0)
            {
                InstanceNamePtr = InstanceName + BaseNameLen;
                InstanceNameIndex = _wtoi(InstanceNamePtr);
                InstanceSetFirstIndex = InstanceSet->IsBaseName->BaseIndex;
                InstanceSetLastIndex = InstanceSetFirstIndex + InstanceSet->Count;
                if (( (InstanceNameIndex >= InstanceSetFirstIndex) &&
                      (InstanceNameIndex < InstanceSetLastIndex)) &&
                    ((InstanceNameIndex != 0) || WmipIsNumber(InstanceNamePtr)))
                {
                   InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
                   *InstanceIndex = InstanceNameIndex - InstanceSetFirstIndex;
                   WmipReferenceIS(InstanceSet);
                   WmipAssert(InstanceSet->Signature == IS_SIGNATURE);
                   WmipLeaveSMCritSection();
                   return(InstanceSet);
                }
            }
        } else if (InstanceSet->Flags & IS_INSTANCE_STATICNAMES) {
            for (i = 0; i < InstanceSet->Count; i++)
            {
                if (wcscmp(InstanceName,
                           InstanceSet->IsStaticNames->StaticNamePtr[i]) == 0)
               {
                   InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
                   *InstanceIndex = i;
                   WmipReferenceIS(InstanceSet);
                   WmipAssert(InstanceSet->Signature == IS_SIGNATURE);
                   WmipLeaveSMCritSection();
                   return(InstanceSet);
               }
            }
        }
        InstanceSetList = InstanceSetList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}

BOOLEAN WmipRealloc(
    PVOID *Buffer,
    ULONG CurrentSize,
    ULONG NewSize,
    BOOLEAN FreeOriginalBuffer
    )
/*++

Routine Description:

    Reallocate a buffer to a larger size while preserving data

Arguments:

    Buffer on entry has the buffer to be reallocated, on exit has the new
        buffer

    CurrentSize is the current size of the buffer

    NewSize has the new size desired

Return Value:

    TRUE if realloc was successful

--*/
{
    PVOID NewBuffer;

    WmipAssert(NewSize > CurrentSize);

    NewBuffer = WmipAlloc(NewSize);
    if (NewBuffer != NULL)
    {
        memset(NewBuffer, 0, NewSize);
        memcpy(NewBuffer, *Buffer, CurrentSize);
        if (FreeOriginalBuffer)
        {
            WmipFree(*Buffer);
        }
        *Buffer = NewBuffer;
        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\consumer.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

   consumer.c

Abstract:

    Data Consumer apis

Author:

    AlanWar

Environment:

    Kernel mode

Revision History:


--*/

#include "wmikmp.h"
#include <evntrace.h>

#include <ntcsrmsg.h>

#define NTOSKRNL_WMI
#include <basemsg.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

void WmipCompleteGuidIrpWithError(
    PWMIGUIDOBJECT GuidObject
    );

NTSTATUS WmipCreatePumpThread(
    PWMIGUIDOBJECT Object
    );

void WmipClearThreadObjectList(
    PWMIGUIDOBJECT MainObject
    );

void
WmipGetGuidPropertiesFromGuidEntry(
    PWMIGUIDPROPERTIES GuidInfo, 
    PGUIDENTRY GuidEntry);

BOOLEAN WmipIsQuerySetGuid(
    PBGUIDENTRY GuidEntry
    );

NTSTATUS WmipAddProviderIdToPIList(
    PBINSTANCESET **PIPtrPtr,
    PULONG PICountPtr,
    PULONG PIMaxPtr,
    PBINSTANCESET *StaticPIPtr,
    PBINSTANCESET InstanceSet
);

NTSTATUS WmipPrepareForWnodeAD(
    IN PWMIGUIDOBJECT GuidObject,
    OUT LPGUID Guid,
    IN OUT ULONG *ProviderIdCount,
    OUT PBINSTANCESET **ProviderIdList,
    OUT BOOLEAN *InternalGuid       
    );

ULONG WmipStaticInstanceNameSize(
    PBINSTANCESET InstanceSet
    );

void WmipInsertStaticNames(
    PWNODE_ALL_DATA Wnode,
    ULONG MaxWnodeSize,
    PBINSTANCESET InstanceSet
    );

NTSTATUS WmipQueryGuidInfo(
    IN OUT PWMIQUERYGUIDINFO QueryGuidInfo
    );

void WmipCopyFromEventQueues(
    IN POBJECT_EVENT_INFO ObjectArray,
    IN ULONG HandleCount,
    OUT PUCHAR OutBuffer,
    OUT ULONG *OutBufferSizeUsed,
    OUT PWNODE_HEADER *LastWnode,                               
    IN BOOLEAN IsHiPriority
    );

void WmipClearIrpObjectList(
    PIRP Irp
    );

NTSTATUS WmipReceiveNotifications(
    PWMIRECEIVENOTIFICATION ReceiveNotification,
    PULONG OutBufferSize,
    PIRP Irp
    );


NTSTATUS WmipQueueNotification(
    PWMIGUIDOBJECT Object,
    PWMIEVENTQUEUE EventQueue,
    PWNODE_HEADER Wnode
    );

PWNODE_HEADER WmipDereferenceEvent(
    PWNODE_HEADER Wnode
    );

PWNODE_HEADER WmipIncludeStaticNames(
    PWNODE_HEADER Wnode
    );

NTSTATUS WmipWriteWnodeToObject(
    PWMIGUIDOBJECT Object,
    PWNODE_HEADER Wnode,
    BOOLEAN IsHighPriority
);

NTSTATUS WmipProcessEvent(
    PWNODE_HEADER InWnode,
    BOOLEAN IsHighPriority,
    BOOLEAN FreeBuffer
    );

NTSTATUS WmipRegisterUMGuids(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Cookie,
    IN PWMIREGINFO RegInfo,
    IN ULONG RegInfoSize,
    OUT HANDLE *RequestHandle,
    OUT ULONG64 *LoggerContext
    );

NTSTATUS WmipUnregisterGuids(
    PWMIUNREGGUIDS UnregGuids
    );

NTSTATUS WmipWriteMBToObject(
    IN PWMIGUIDOBJECT RequestObject,
    IN PWMIGUIDOBJECT ReplyObject,
    IN PUCHAR Message,
    IN ULONG MessageSize
    );

NTSTATUS WmipWriteMessageToGuid(
    IN PBGUIDENTRY GuidEntry,
    IN PWMIGUIDOBJECT ReplyObject,
    IN PUCHAR Message,
    IN ULONG MessageSize,
    OUT PULONG WrittenCount                             
);

NTSTATUS WmipCreateUMLogger(
    IN OUT PWMICREATEUMLOGGER CreateInfo
    );

NTSTATUS WmipMBReply(
    IN HANDLE RequestHandle,
    IN ULONG ReplyIndex,
    IN PUCHAR Message,
    IN ULONG MessageSize
    );

NTSTATUS WmipPrepareWnodeSI(
    IN PWMIGUIDOBJECT GuidObject,
    IN OUT PWNODE_SINGLE_INSTANCE WnodeSI,
    IN OUT ULONG *ProviderIdCount,
    OUT PBINSTANCESET **ProviderIdList,
    OUT BOOLEAN *IsDynamic,
    OUT BOOLEAN *InternalGuid       
    );

void WmipCreatePumpThreadRoutine(
    PVOID Context
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,WmipIsQuerySetGuid)
#pragma alloc_text(PAGE,WmipOpenBlock)
#pragma alloc_text(PAGE,WmipAddProviderIdToPIList)
#pragma alloc_text(PAGE,WmipPrepareForWnodeAD)
#pragma alloc_text(PAGE,WmipStaticInstanceNameSize)
#pragma alloc_text(PAGE,WmipInsertStaticNames)
#pragma alloc_text(PAGE,WmipQueryAllData)
#pragma alloc_text(PAGE,WmipQueryAllDataMultiple)
#pragma alloc_text(PAGE,WmipPrepareWnodeSI)
#pragma alloc_text(PAGE,WmipQuerySetExecuteSI)
#pragma alloc_text(PAGE,WmipQuerySingleMultiple)
#pragma alloc_text(PAGE,WmipEnumerateGuids)
#pragma alloc_text(PAGE,WmipQueryGuidInfo)
#pragma alloc_text(PAGE,WmipClearIrpObjectList)
#pragma alloc_text(PAGE,WmipReceiveNotifications)
#pragma alloc_text(PAGE,WmipQueueNotification)
#pragma alloc_text(PAGE,WmipDereferenceEvent)
#pragma alloc_text(PAGE,WmipIncludeStaticNames)
#pragma alloc_text(PAGE,WmipWriteWnodeToObject)
#pragma alloc_text(PAGE,WmipProcessEvent)
#pragma alloc_text(PAGE,WmipUMProviderCallback)
#pragma alloc_text(PAGE,WmipRegisterUMGuids)
#pragma alloc_text(PAGE,WmipUnregisterGuids)
#pragma alloc_text(PAGE,WmipWriteMBToObject)
#pragma alloc_text(PAGE,WmipWriteMessageToGuid)
#pragma alloc_text(PAGE,WmipCreateUMLogger)
#pragma alloc_text(PAGE,WmipMBReply)
#pragma alloc_text(PAGE,WmipGetGuidPropertiesFromGuidEntry)
#pragma alloc_text(PAGE,WmipClearThreadObjectList)
#pragma alloc_text(PAGE,WmipClearObjectFromThreadList)
#pragma alloc_text(PAGE,WmipCreatePumpThread)
#pragma alloc_text(PAGE,WmipCopyFromEventQueues)
#pragma alloc_text(PAGE,WmipCreatePumpThreadRoutine)
#pragma alloc_text(PAGE,WmipMarkHandleAsClosed)
#pragma alloc_text(PAGE,WmipCompleteGuidIrpWithError)
#endif

BOOLEAN WmipIsQuerySetGuid(
    PBGUIDENTRY GuidEntry
    )
{
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;

    PAGED_CODE();
    
    WmipAssert(GuidEntry != NULL);
    
    WmipEnterSMCritSection();
    InstanceSetList = GuidEntry->ISHead.Flink;
    while (InstanceSetList != &GuidEntry->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
        if ( (InstanceSet->Flags & 
                (IS_TRACED | IS_CONTROL_GUID | IS_EVENT_ONLY)) == 0 )
        {
            //
            // If there is at least one IS that isn't traced and isn't
            // an event only then it is a queryset guid
            //
            WmipLeaveSMCritSection();
            return (TRUE);
        }
        InstanceSetList = InstanceSetList->Flink;
    }
    WmipLeaveSMCritSection();
    
    return (FALSE);
    
}


NTSTATUS WmipOpenBlock(
    IN ULONG Ioctl,
    IN KPROCESSOR_MODE AccessMode,
    IN POBJECT_ATTRIBUTES CapturedObjectAttributes,
    IN ULONG DesiredAccess,
    OUT PHANDLE Handle
    )
{
    PBGUIDENTRY GuidEntry;
    PWMIGUIDOBJECT Object;
    NTSTATUS Status;

    PAGED_CODE();
    
    //
    // Creates a guid handle with the desired access
    //
    Status = WmipOpenGuidObject(CapturedObjectAttributes,
                                DesiredAccess,
                                AccessMode,
                                Handle,
                                &Object);
                            
                            
    if (NT_SUCCESS(Status))
    {        
        Object->Type = Ioctl;
        
        if (Ioctl != IOCTL_WMI_OPEN_GUID)
        {
            GuidEntry = WmipFindGEByGuid(&Object->Guid, FALSE);
        
            //
            // Establish our object on the guidentry list
            //
            WmipEnterSMCritSection();
            if (GuidEntry != NULL)
            {
                InsertTailList(&GuidEntry->ObjectHead,
                               &Object->GEObjectList);
                                     
            }
            Object->GuidEntry = GuidEntry;
            WmipLeaveSMCritSection();
            
            switch (Ioctl)
            {
                case IOCTL_WMI_OPEN_GUID_FOR_QUERYSET:
                {
                    //
                    // Guid is being opened for query/set/method operations so
                    // we need to insure that there is a guid entry and that
                    // the guid entry has InstanceSets attached and it is
                    // has at least one instance set that is not a traced 
                    // guid and is not an event only guid
                    //
                    if ((GuidEntry == NULL) ||
                        (GuidEntry->ISCount == 0) ||
                        (! WmipIsQuerySetGuid(GuidEntry)))
                    {
                        //
                        // Either we could not find a guidentry or there
                        // is no instance sets attached. We close the
                        // original handle and fail the IOCTL
                        //
                        ZwClose(*Handle);
                        Status = STATUS_WMI_GUID_NOT_FOUND;
                        break;
                    }
                    //
                    // Fall through
                    //
                }
                
                case IOCTL_WMI_OPEN_GUID_FOR_EVENTS:
                {
                    //
                    // Since we can register to receive events before
                    // the event provider has been registered we'll need
                    // to create the guid entry if one does not exist
                    //
                    
                    if (AccessMode == KernelMode)
                    {
                        Object->Flags |= WMIGUID_FLAG_KERNEL_NOTIFICATION;
                    }
                    
                    if (GuidEntry == NULL)
                    {
                        WmipAssert(Ioctl == IOCTL_WMI_OPEN_GUID_FOR_EVENTS);
                        
                        WmipEnterSMCritSection();
                        GuidEntry = WmipAllocGuidEntry();
                        if (GuidEntry != NULL)
                        {
                            //
                            // Initialize the new GuidEntry and place it 
                            // on the master GuidEntry list.
                            //
                            memcpy(&GuidEntry->Guid,
                                   &Object->Guid,
                                   sizeof(GUID));

                            InsertHeadList(WmipGEHeadPtr, &GuidEntry->MainGEList);
                            InsertTailList(&GuidEntry->ObjectHead,
                                           &Object->GEObjectList);
                            Object->GuidEntry = GuidEntry;
                            WmipLeaveSMCritSection();
                        } else {
                            WmipLeaveSMCritSection();
                            ZwClose(*Handle);
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            break;
                        }
                     }
                    
                    
                    //
                    // Now we need to see if we have to enable collection
                    // or events
                    //
                    Status = WmipEnableCollectOrEvent(GuidEntry,
                                         Ioctl,
                                         &Object->EnableRequestSent,
                                         0);
                    
                    if (! NT_SUCCESS(Status))
                    {
                        //
                        // For some reason enabling failed so just return
                        // the error
                        //
                        ZwClose(*Handle);
                    }
                    
                    //
                    // Don't unref the guid entry as that ref count is 
                    // taken by the object just placed on the list
                    //
                    break;
                }
                                                  
                default:
                {
                    //
                    // We should never get here.....
                    //
                    WmipAssert(FALSE);
            
                    ZwClose(*Handle);
                    Status = STATUS_ILLEGAL_FUNCTION;
                    break;
                }
            }
        } else {
            //
            // Mark this as a security object
            //
            Object->Flags |= WMIGUID_FLAG_SECURITY_OBJECT;
        }

        //
        // remove the ref taken when the object was created
        //
        ObDereferenceObject(Object);
    }
    return(Status);
}



NTSTATUS WmipAddProviderIdToPIList(
    PBINSTANCESET **PIPtrPtr,
    PULONG PICountPtr,
    PULONG PIMaxPtr,
    PBINSTANCESET *StaticPIPtr,
    PBINSTANCESET InstanceSet
)
{
    ULONG PICount;
    ULONG PIMax, NewPIMax;
    PBINSTANCESET *PIPtr, *OldPIPtr, *NewPIPtr;
    NTSTATUS Status;
    ULONG i;
 
    PAGED_CODE();
    
    Status = STATUS_SUCCESS;
    PICount = *PICountPtr;
    PIMax = *PIMaxPtr;
    PIPtr = *PIPtrPtr;
    
    //
    // Remember dynamic providerid
    //
       if (PICount == PIMax)
    {
        //
        // We have overflowed the PI List so we need to
        // reallocate a bigger buffer
        //
        NewPIMax = PIMax * 2;
        NewPIPtr = (PBINSTANCESET *)WmipAlloc(NewPIMax * 
                                              sizeof(PBINSTANCESET));
        OldPIPtr = PIPtr;
        if (NewPIPtr != NULL)
        {
            //
            // Copy provider ids from old to new buffer
            //
            memcpy(NewPIPtr, OldPIPtr, PIMax*sizeof(PBINSTANCESET));
            PIPtr = NewPIPtr;
            *PIPtrPtr = NewPIPtr;
            PIMax = NewPIMax;
            *PIMaxPtr = PIMax;
        } else {
            //
            // Bad break, we could not allocate more space
            // unref any instance sets and return an error
            //
            for (i = 0; i < PIMax; i++)
            {
                WmipUnreferenceIS(PIPtr[i]);
            }
            WmipUnreferenceIS(InstanceSet);
            *PIPtrPtr = NULL;
            
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
                        
        //
        // if previous buffer was not static then free it
        //
        if (OldPIPtr != StaticPIPtr)
        {
            WmipFree(OldPIPtr);
        }
    }
    
    if (NT_SUCCESS(Status))
    {
        //
        // Remember instance set
        //
        PIPtr[PICount++] = InstanceSet;
        *PICountPtr = PICount;
    }
    return(Status);
}

NTSTATUS WmipPrepareForWnodeAD(
    IN PWMIGUIDOBJECT GuidObject,
    OUT LPGUID Guid,
    IN OUT ULONG *ProviderIdCount,
    OUT PBINSTANCESET **ProviderIdList,
    OUT BOOLEAN *InternalGuid
    )
{
    PBINSTANCESET *PIPtr, *StaticPIPtr;
    ULONG PICount, PIMax;
    NTSTATUS Status;
    PBGUIDENTRY GuidEntry;
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;

    PAGED_CODE();

    GuidEntry = GuidObject->GuidEntry;
    
    if ((GuidEntry != NULL) && (GuidEntry->ISCount > 0))
    {
        //
        // We were passed a valid guid handle, get out the guid 
        //
        *Guid = GuidEntry->Guid;

        Status = STATUS_SUCCESS;
        if (GuidEntry->Flags & GE_FLAG_INTERNAL) 
        {
            *InternalGuid = TRUE;
        } else {        
            //
            // Build list of provider ids to whom the QAD will be targetted
            //
            *InternalGuid = FALSE;
        
            StaticPIPtr = *ProviderIdList;
            PIPtr = StaticPIPtr;
            PIMax = *ProviderIdCount;
            PICount = 0;
    
            WmipEnterSMCritSection();
        
            InstanceSetList = GuidEntry->ISHead.Flink;
            while ((InstanceSetList != &GuidEntry->ISHead) && 
                   NT_SUCCESS(Status))
            {
                InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                                INSTANCESET,
                                                GuidISList);
            
                //
                // Take a refcount on the instance set so that it won't
                // go away until after we are done with our query
                // The refcount gets removed by the caller when it is 
                // done with the list or in WmipAddProviderIdTOLlist  if it
                // returns an error
                //
                        
                if ((InstanceSet->Flags & (IS_TRACED | IS_CONTROL_GUID | IS_EVENT_ONLY)) == 0)
                {
                    //
                    // Only take those IS that are not traced or control
                    // guids and are not event only guids
                    //
                    WmipReferenceIS(InstanceSet);
                    Status = WmipAddProviderIdToPIList(&PIPtr,
                                                 &PICount,
                                                 &PIMax,
                                                 StaticPIPtr,
                                                 InstanceSet);
                }
                                             
                InstanceSetList = InstanceSetList->Flink;
            }
        
            WmipLeaveSMCritSection();            
        
            if (PICount == 0)
            {
                Status = STATUS_WMI_GUID_DISCONNECTED;
            } else {
                *ProviderIdCount = PICount;
                *ProviderIdList = PIPtr;
            }
        }
    } else {
        Status = STATUS_WMI_GUID_DISCONNECTED;
    }
    
    return(Status);
}



ULONG WmipStaticInstanceNameSize(
    PBINSTANCESET InstanceSet
    )
/*+++

Routine Description:

    This routine will calculate the size needed to place instance names in
    a WNODE_ALL_DATA

Arguments:

    WmiInstanceInfo describes to instance set whose instance name size
        is to be calculated

Return Value:

    Size needed to place instance names in a WNODE_ALL_DATA plus 3. The
    extra 3 bytes are added in case the OffsetInstanceNameOffsets need to be
    padded since they must be on a 4 byte boundary.
        
---*/
{
    SIZE_T NameSize;
    ULONG i;

    PAGED_CODE();
    
    //
    // If we already computed this then just return the results
    if (InstanceSet->WADInstanceNameSize != 0)
    {
        return(InstanceSet->WADInstanceNameSize);
    }

    //
    // Start with a name size of 3 in case the OffsetInstanceNameOffset will
    // need to be padded so that it starts on a 4 byte boundary.
    NameSize = 3;

    if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
    {
        //
        // For static base names we assume that there will never be more than
        // MAXBASENAMESUFFIXVALUE instances of a guid. So the size of each instance name 
        // would be the size of the base name plus the size of the suffix
        // plus a USHORT for the count (for counted string) plus a ULONG
        // to hold the offset to the instance name
        //
        WmipAssert((InstanceSet->IsBaseName->BaseIndex + InstanceSet->Count) < MAXBASENAMESUFFIXVALUE);
    
        NameSize += ((wcslen(InstanceSet->IsBaseName->BaseName) * sizeof(WCHAR)) +
                    MAXBASENAMESUFFIXSIZE * sizeof(WCHAR) + 
                    sizeof(USHORT) + 
                    sizeof(ULONG)) * InstanceSet->Count;
                
    } else if (InstanceSet->Flags & IS_INSTANCE_STATICNAMES)
    {
        //
        // For a static name list we count up each size of
        // the static instance names in the list and add a ULONG and a USHORT
        // for the offset and count (for counted string)
        for (i = 0; i < InstanceSet->Count; i++)
        {
            NameSize += (wcslen(InstanceSet->IsStaticNames->StaticNamePtr[i]) + 2) * sizeof(WCHAR) + sizeof(ULONG);
        }
    }

    InstanceSet->WADInstanceNameSize = (ULONG)NameSize;

    return(ULONG)(NameSize);
}

void WmipInsertStaticNames(
    PWNODE_ALL_DATA Wnode,
    ULONG MaxWnodeSize,
    PBINSTANCESET InstanceSet
    )
/*+++

Routine Description:

    This routine will copy into the WNODE_ALL_DATA instance names for a
    static instance name set. If the Wnode_All_data is too small then it
    is converted to a WNODE_TOO_SMALL

Arguments:

    Wnode points at the WNODE_ALL_DATA
    MaxWnodeSize is the maximum size of the Wnode
    WmiInstanceInfo is the Instance Info

Return Value:

---*/
{
    PWCHAR NamePtr;
    PULONG NameOffsetPtr;
    ULONG InstanceCount;
    ULONG i;
    WCHAR Index[MAXBASENAMESUFFIXSIZE+1];
    PWCHAR StaticName;
    ULONG SizeNeeded;
    SIZE_T NameLen;
    USHORT Len;
    ULONG PaddedBufferSize;
    size_t Size;
    HRESULT hr;

    PAGED_CODE();
    
    if ((InstanceSet->Flags &
                (IS_INSTANCE_BASENAME | IS_INSTANCE_STATICNAMES)) == 0)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,"WMI: Try to setup static names for dynamic guid\n"));
        return;
    }
    InstanceCount = InstanceSet->Count;

    //
    // Pad out the size of the incoming wnode to a 4 byte boundary since the
    // OffsetInstanceNameOffsets is being appended to the end of the
    // wnode and it must be on a 4 byte boundary
    //
    PaddedBufferSize = (Wnode->WnodeHeader.BufferSize + 3) & ~3;
    
    //
    // Compute the complete size needed to rewrite the WNODE to include
    // the instance names. 
    //
    //     Include the size that is needed to fill out 
    Size = WmipStaticInstanceNameSize(InstanceSet);

    //     Include the space needed for the array of offsets to the
    //     instance names plus the size of the names plus the padded
    //     size of the wnode
    SizeNeeded = (InstanceCount * sizeof(ULONG)) +
                 (ULONG)Size +
                 PaddedBufferSize;

    if (SizeNeeded > MaxWnodeSize)
    {
        //
        // If not enough space left in the buffer passed then build a
        // WNODE_TOO_SMALL as the result to indicate how much buffer
        // space is needed.
        //
        Wnode->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
        Wnode->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
        ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded = SizeNeeded;
        return;
    }

    //
    // Allocate space for the array of offsets to instance names
    //
    NameOffsetPtr = (PULONG)((PUCHAR)Wnode + PaddedBufferSize);
    Wnode->OffsetInstanceNameOffsets = (ULONG)((PUCHAR)NameOffsetPtr - (PUCHAR)Wnode);

    //
    // Point at the beginning of the area to write the instance names
    //
    NamePtr = (PWCHAR)(NameOffsetPtr + InstanceCount);


    if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
    {
        //
        // The instance name is based upon a basename with a trailing
        // index number to provide uniqueness
        //
        if (InstanceSet->Flags & IS_PDO_INSTANCENAME)
        {
            Wnode->WnodeHeader.Flags |= WNODE_FLAG_PDO_INSTANCE_NAMES;
        }

        for (i = 0; i < InstanceCount; i++)
        {
            //
            // Account for space used by length of string that follows
            //
            Size -= sizeof(USHORT);
            *NameOffsetPtr++ = (ULONG)((PUCHAR)NamePtr - (PUCHAR)Wnode);

            //
            // Copy over basename while accounting length used by it
            //
            hr = StringCbCopy(NamePtr+1,
                              Size,
                              InstanceSet->IsBaseName->BaseName);
            WmipAssert(hr == S_OK);

            //
            // Format unique index number
            //
            hr = StringCbPrintf(Index,
                                sizeof(Index),
                                BASENAMEFORMATSTRING,
                                InstanceSet->IsBaseName->BaseIndex+i);
            WmipAssert(hr == S_OK);

            //
            // Append unique index number to instance name
            //
            hr = StringCbCat(NamePtr+1,
                           Size,
                           Index);
            WmipAssert(hr == S_OK);
            
            NameLen = wcslen(NamePtr+1) + 1;
            *NamePtr = (USHORT)NameLen * sizeof(WCHAR);
            NamePtr += NameLen + 1;
            
            Size -= NameLen * sizeof(WCHAR);
        }
    } else if (InstanceSet->Flags & IS_INSTANCE_STATICNAMES) {
        //
        // Instance names are from a list of static names
        //
        for (i = 0; i < InstanceCount; i++)
        {
            *NameOffsetPtr++ = (ULONG)((PUCHAR)NamePtr - (PUCHAR)Wnode);
            StaticName = InstanceSet->IsStaticNames->StaticNamePtr[i];
            Len = (USHORT)((wcslen(StaticName)+1) * sizeof(WCHAR));
            *NamePtr++ = Len;
            
            //
            // Account for space used by length of string that follows
            //
            Size -= sizeof(USHORT);

            //
            // Copy over and account for static name
            //
            hr = StringCbCopyEx(NamePtr,
                           Size,
                           StaticName,
                           NULL,
                           &Size,
                           0);
            WmipAssert(hr == S_OK);
            
            NamePtr += Len / sizeof(WCHAR);
            
        }
    }
    Wnode->WnodeHeader.BufferSize = SizeNeeded;
}



//
// This defines how many provider ids will fit within the static block. If
// we need more than this, then we'll have to allocate memory for it
//
#if DBG
#define MANYPROVIDERIDS 1
#else
#define MANYPROVIDERIDS 16
#endif

NTSTATUS WmipQueryAllData(
    IN PWMIGUIDOBJECT GuidObject,
    IN PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    IN PWNODE_ALL_DATA Wnode,
    IN ULONG OutBufferLen,
    OUT PULONG RetSize
    )
{
    NTSTATUS Status;
    PBINSTANCESET StaticPIList[MANYPROVIDERIDS];
    PBINSTANCESET *PIList;
    PBINSTANCESET InstanceSet;
    WNODE_ALL_DATA WnodeAllData;
    BOOLEAN IsBufferTooSmall;
    PWNODE_HEADER WnodeHeader;
    LOGICAL UsesStaticNames;
    PWNODE_TOO_SMALL WnodeTooSmall = (PWNODE_TOO_SMALL)&WnodeAllData;
    PWNODE_ALL_DATA WnodeAD;
    ULONG BufferLeft;
    ULONG SizeNeeded;
    ULONG PICount;
    ULONG WnodeFlags, WnodeSize;
    PWNODE_HEADER WnodeLast;
    ULONG Linkage;
    ULONG i;
    GUID Guid;
    PUCHAR Buffer;
    ULONG BufferUsed;
    HANDLE KernelHandle;
    BOOLEAN InternalGuid;
    IO_STATUS_BLOCK Iosb;
    
    PAGED_CODE();
    
    //
    // Check Security
    //
    if (GuidObject != NULL)
    {
        Status = ObReferenceObjectByPointer(GuidObject,
                                            WMIGUID_QUERY,
                                            WmipGuidObjectType,
                                            AccessMode);
    } else {
        KernelHandle = Wnode->WnodeHeader.KernelHandle;

        Status = ObReferenceObjectByHandle(KernelHandle,
                                           WMIGUID_QUERY,
                                           WmipGuidObjectType,
                                           AccessMode,
                                           &GuidObject,
                                           NULL);
    }
                   
    if (NT_SUCCESS(Status))
    {
        //
        // Get the provider id list for the guid 
        //
        PIList = StaticPIList;
        PICount = MANYPROVIDERIDS;
        Status = WmipPrepareForWnodeAD(GuidObject,
                                       &Guid,
                                       &PICount,
                                       &PIList,
                                       &InternalGuid);
        if (NT_SUCCESS(Status))
        {
            if (InternalGuid)
            {
                //
                // This is an internal guid so we fill out the WNODE_ALL_DATA
                // and mark it to be completed by the user mode code
                //
                Wnode->WnodeHeader.Guid = Guid;
                Wnode->WnodeHeader.Flags |= WNODE_FLAG_INTERNAL;
                Wnode->WnodeHeader.Linkage = 0;
                *RetSize = sizeof(WNODE_HEADER);
                Status = STATUS_SUCCESS;
            } else {
                //
                // Get all of the information from the WNODE_HEADER so we can 
                // rebuild it
                //
                WnodeFlags = Wnode->WnodeHeader.Flags;
                WnodeSize = Wnode->WnodeHeader.BufferSize;
                    
                //
                // Loop over all provider ids and send each a WAD query
                //
                Buffer = (PUCHAR)Wnode;
                BufferLeft = OutBufferLen;
                IsBufferTooSmall = FALSE;
                SizeNeeded = 0;
                WnodeLast = NULL;
                for (i = 0; i < PICount; i++)
                {
                    InstanceSet = PIList[i];
                    
                    if ((IsBufferTooSmall) || (BufferLeft < sizeof(WNODE_ALL_DATA)))
                    {
                        //
                        // If we have already determined that the buffer is
                        // too small then we use the static WNODE_ALL_DATA
                        // just to get the size needed
                        //
                        WnodeAD = &WnodeAllData;
                        BufferLeft = sizeof(WNODE_ALL_DATA);
                        IsBufferTooSmall = TRUE;
                    } else {
                        //
                        // Otherwise we will append to the end of the buffer
                        //
                        WnodeAD = (PWNODE_ALL_DATA)Buffer;
                    }
                    
                    //
                    // Build the WNODE and send it off to the driver
                    //
                    WnodeHeader = (PWNODE_HEADER)WnodeAD;
                    WnodeHeader->BufferSize = sizeof(WNODE_HEADER);
                    UsesStaticNames =((InstanceSet->Flags & IS_INSTANCE_BASENAME) ||
                                      (InstanceSet->Flags & IS_INSTANCE_STATICNAMES));
                    WnodeHeader->Flags = WnodeFlags | (UsesStaticNames ?
                                                WNODE_FLAG_STATIC_INSTANCE_NAMES :
                                                0);
                    WnodeHeader->Guid = Guid;
                    WnodeHeader->ProviderId = PIList[i]->ProviderId;
                    WnodeHeader->Linkage = 0;

                    if (Irp != NULL)
                    {
                        Status = WmipForwardWmiIrp(Irp,
                                                   IRP_MN_QUERY_ALL_DATA,
                                                   WnodeHeader->ProviderId,
                                                   &WnodeHeader->Guid,
                                                   BufferLeft,
                                                   WnodeAD);
                    } else {
                        Status = WmipSendWmiIrp(
                                                IRP_MN_QUERY_ALL_DATA,
                                                WnodeHeader->ProviderId,
                                                &WnodeHeader->Guid,
                                                BufferLeft,
                                                WnodeAD,
                                                &Iosb);
                    }
                    
                    if (NT_SUCCESS(Status))
                    {
                        if (WnodeHeader->Flags & WNODE_FLAG_TOO_SMALL)
                        {
                            //
                            // There was not enough space to write the WNODE
                            // so we keep track of how much was needed and then
                            // switch to the mode where we just query for size needed
                            //
                            WnodeTooSmall = (PWNODE_TOO_SMALL)WnodeAD;
                            
                            SizeNeeded += WnodeTooSmall->SizeNeeded;
                            if (UsesStaticNames)
                            {
                                SizeNeeded = (SizeNeeded + 3) &~3;
                                SizeNeeded += WmipStaticInstanceNameSize(InstanceSet)+
                                              (InstanceSet->Count *sizeof(ULONG));
                            }
                                      
                            SizeNeeded = (SizeNeeded +7) & ~7;
                            
                            IsBufferTooSmall = TRUE;
                        } else if (IsBufferTooSmall) {
                            //
                            // We passed a minimum sized buffer, but it is large
                            // enough for the driver. Since we are just trying
                            // to get the size needed we get the size he needs
                            // and throw away his data
                            //
                            SizeNeeded += WnodeAD->WnodeHeader.BufferSize +
                                          WmipStaticInstanceNameSize(InstanceSet) +
                                          (InstanceSet->Count *sizeof(ULONG));
                            SizeNeeded = (SizeNeeded +7) & ~7;
        
                        } else {
                            //
                            // The driver returned a completed WNODE_ALL_DATA
                            // so we need to link the previous WNODE_ALL_DATA to
                            // this one, fill out any static instance names, and
                            // then update the buffer pointer and size
                            //
                            if (WnodeLast != NULL)
                            {
                                Linkage = (ULONG) ((PCHAR)WnodeAD - (PCHAR)WnodeLast);
                                WnodeLast->Linkage = Linkage;
                            }
                            WnodeLast = (PWNODE_HEADER)WnodeAD;
                            
                            if (UsesStaticNames)
                            {
                                //
                                // We need to insert the static names 
                                //
                                WmipInsertStaticNames(WnodeAD,
                                                      BufferLeft,
                                                      InstanceSet);
        
                                if (WnodeAD->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL)
                                {
                                    //
                                    // The static names caused us to run out of
                                    // buffer so we switch to mode  where we
                                    // query for the sizes
                                    //
                                    WnodeTooSmall = (PWNODE_TOO_SMALL)WnodeAD;
                                    IsBufferTooSmall = TRUE;
                                    BufferUsed = WnodeTooSmall->SizeNeeded;
                                } else {
                                    //
                                    // Static names fit so just pull out the updated
                                    // wnode size
                                    //
                                    BufferUsed = WnodeAD->WnodeHeader.BufferSize;
                                }                        
                            } else {
                                //
                                // Wnode has dynamic names so just add size returned
                                // by driver
                                //
                                BufferUsed = WnodeAD->WnodeHeader.BufferSize;
                            }
                            
                            //
                            // Update size needed and advance to free space in
                            // output buffer
                            //
                            BufferUsed = (BufferUsed + 7) & ~7;
                            SizeNeeded += BufferUsed;
                            
                            //
                            // Make sure that by adding in pad we don't run out of
                            // room in buffer
                            //
                            if ((! IsBufferTooSmall) && (BufferLeft >= BufferUsed))
                            {
                                BufferLeft -= BufferUsed;
                                Buffer += BufferUsed;
                            } else {
                                IsBufferTooSmall = TRUE;
                            }
                        }
                    } else {
                        //
                        // The driver failed the request, but that is no biggie
                        // as we just ignore it for now
                        //
                    }
                    
                    //
                    // We are done with the instance set so remove our ref
                    // on it so it can go away if need be
                    //
                    WmipUnreferenceIS(InstanceSet);
                }
                
                if (SizeNeeded == 0)
                {
                    //
                    // No devices responded to the WMI Query All Data so we
                    // return an error
                    //
                    Status = STATUS_WMI_GUID_NOT_FOUND;
                } else if ((IsBufferTooSmall) &&
                           (SizeNeeded > OutBufferLen)) {
                    //
                    // Our buffer passed was too small so return a WNODE_TOO_SMALL
                    //
                    WnodeTooSmall = (PWNODE_TOO_SMALL)Wnode;
                    WnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                    WnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                    WnodeTooSmall->SizeNeeded = SizeNeeded;
                    *RetSize = sizeof(WNODE_TOO_SMALL);
                    Status = STATUS_SUCCESS;
                } else {
                    *RetSize = SizeNeeded;
                    Status = STATUS_SUCCESS;
                }
        
                //
                // Make sure any memory allocated for the PI list is freed
                //
                if ((PIList != StaticPIList) && (PIList != NULL))
                {
                    WmipFree(PIList);           
                }    
            }
        }
        //
        // And remove ref on guid object
        //
        ObDereferenceObject(GuidObject);    
    }
    
    return(Status);
}

NTSTATUS WmipQueryAllDataMultiple(
    IN ULONG ObjectCount,
    IN PWMIGUIDOBJECT *ObjectList,
    IN PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    IN OUT PUCHAR BufferPtr,        
    IN ULONG BufferSize,
    IN PWMIQADMULTIPLE QadMultiple,
    OUT ULONG *ReturnSize
    )
{
    ULONG i;
    HANDLE *Handles;
    ULONG Count;
    WNODE_ALL_DATA WnodeAD;
    BOOLEAN BufferOverFlow;
    ULONG SkipSize, RetSize, SizeNeeded;
    ULONG WnodeSize;
    NTSTATUS Status, Status2;
    ULONG Linkage = 0;
    PWNODE_TOO_SMALL WnodeTooSmall;
    PWNODE_HEADER WnodePrev;
    PUCHAR Buffer;
    PWNODE_ALL_DATA Wnode;
    PWMIGUIDOBJECT Object = NULL;
    
    PAGED_CODE();


    Status = STATUS_SUCCESS;
    if (ObjectList == NULL)
    {
        //
        // Copy the handle list out of the system buffer since it will
        // be overwritten by the first query all data
        //
        Count = QadMultiple->HandleCount;
        Handles = (HANDLE *)WmipAlloc(Count * sizeof(HANDLE));
    
        if (Handles != NULL)
        {
            for (i = 0; i < Count; i++)
            {
                Handles[i] = QadMultiple->Handles[i].Handle;
            }
        
        } else {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        Count = ObjectCount;
        Handles = NULL;
    }

    SizeNeeded = 0;
    Buffer = BufferPtr;
        
    BufferOverFlow = FALSE;
    WnodePrev = NULL;        
    Wnode = (PWNODE_ALL_DATA)Buffer;
    WnodeSize = BufferSize;
    
    for (i = 0; i < Count; i++)
    {
        if ((Wnode == &WnodeAD) || (WnodeSize < sizeof(WNODE_ALL_DATA)))
        {
            //
            // If there is no more room, we are just querying for the
            // size that will be needed.
            //
            Wnode = &WnodeAD;
            WnodeSize = sizeof(WNODE_ALL_DATA);
            WnodePrev = NULL;
        } else {
            Wnode = (PWNODE_ALL_DATA)Buffer;
            WnodeSize = BufferSize;
        }
            
        //
        // Build WNODE_ALL_DATA in order to do the query
        //
        RtlZeroMemory(Wnode, sizeof(WNODE_ALL_DATA));
        Wnode->WnodeHeader.Flags = WNODE_FLAG_ALL_DATA;
        Wnode->WnodeHeader.BufferSize = sizeof(WNODE_HEADER);

        if (ObjectList == NULL)
        {
            Wnode->WnodeHeader.KernelHandle = Handles[i];
        } else {
            Object = ObjectList[i];
        }
        
        Status2 = WmipQueryAllData(Object,
                                   Irp,
                                   AccessMode,
                                   Wnode,
                                   WnodeSize,
                                   &RetSize);
                               
        if (NT_SUCCESS(Status2))
        {
            if (Wnode->WnodeHeader.Flags & WNODE_FLAG_INTERNAL) 
            {
                //
                // Skip any internal guid quesries 
                //
            } else if (Wnode->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL) {
                //
                // There is no enough room so just tally up
                // the size that will be needed.
                //
                WnodeTooSmall = (PWNODE_TOO_SMALL)Wnode;
                SizeNeeded += (WnodeTooSmall->SizeNeeded+7) & ~7;
                Wnode = &WnodeAD;
                BufferOverFlow = TRUE;
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,"WMI: %x Too Small %x needed, total %x\n",
                            ObjectList ? ObjectList[i] : Handles[i],
                            WnodeTooSmall->SizeNeeded, SizeNeeded));
            } else if (Wnode == &WnodeAD) {
                //
                // Even though this succeeded, we still aren't going
                // to be able to return any data so just count up
                // how much size we need
                //
                SizeNeeded += (RetSize+7) & ~7;
                BufferOverFlow = TRUE;
            
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                  DPFLTR_API_INFO_LEVEL,"WMI: %x Large Enough but full %x needed, total %x\n",
                            ObjectList ? ObjectList[i] : Handles[i],
                            RetSize, SizeNeeded));
                
            } else {
                //
                // We successfully got data. Link the previous wnode
                // to this one
                //
                if (WnodePrev != NULL)
                {
                    WnodePrev->Linkage = Linkage;
                }
                
                WnodePrev = (PWNODE_HEADER)Wnode;
                while (WnodePrev->Linkage != 0)
                {
                    WnodePrev = (PWNODE_HEADER)OffsetToPtr(WnodePrev,
                                                      WnodePrev->Linkage);
                }
                
                SkipSize = (RetSize+7) &~7;
                SizeNeeded += SkipSize;
                BufferSize -= SkipSize;
                Buffer += SkipSize;
                
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,"WMI: %x Large Enough %x needed, total %x\n",
                            ObjectList ? ObjectList[i] : Handles[i],
                            RetSize, SizeNeeded));
                
                Linkage = (ULONG) ((PCHAR)Buffer - (PCHAR)WnodePrev);
            }
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,"WMI: %x Failed %x, total %x\n",
                            ObjectList ? ObjectList[i] : Handles[i],
                            Status2,
                            SizeNeeded));
        }
    }

    if (Handles != NULL)
    {
        WmipFree(Handles);
    }
        
    if (BufferOverFlow)
    {
        WnodeTooSmall = (PWNODE_TOO_SMALL)BufferPtr;
        WnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
        WnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
        WnodeTooSmall->SizeNeeded = SizeNeeded;
        *ReturnSize = sizeof(WNODE_TOO_SMALL);
    } else {
        *ReturnSize = SizeNeeded;
    }
    
    return(Status);
}

NTSTATUS WmipPrepareWnodeSI(
    IN PWMIGUIDOBJECT GuidObject,
    IN OUT PWNODE_SINGLE_INSTANCE WnodeSI,
    IN OUT ULONG *ProviderIdCount,
    OUT PBINSTANCESET **ProviderIdList,
    OUT BOOLEAN *IsDynamic,
    OUT BOOLEAN *InternalGuid
    )
{
    NTSTATUS Status;
    PBGUIDENTRY GuidEntry;
    ULONG i;
    PWNODE_HEADER Wnode;
    PWCHAR CInstanceName;
    PWCHAR InstanceName;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    PBINSTANCESET *PIPtr = NULL;
    PBINSTANCESET *StaticPIPtr = NULL;
    ULONG PICount = 0, PIMax;
    BOOLEAN Done;

    PAGED_CODE();
    
    *IsDynamic = TRUE;
    GuidEntry = GuidObject->GuidEntry;
    Wnode = (PWNODE_HEADER)WnodeSI;
    
    if ((GuidEntry != NULL)  && (GuidEntry->ISCount > 0))
    {
        //
        // We were passed a valid guid handle, fill out the guid 
        // in WNODE_HEADER
        //
        Status = STATUS_SUCCESS;
        Wnode->Guid = GuidEntry->Guid;

        if (GuidEntry->Flags & GE_FLAG_INTERNAL) 
        {
            *InternalGuid = TRUE;
        } else {        
            *InternalGuid = FALSE;
            
            //
            // Obtain instance name from WNODE
            //
            CInstanceName = (PWCHAR)OffsetToPtr(WnodeSI, 
                                                WnodeSI->OffsetInstanceName);
            InstanceName = WmipCountedToSz(CInstanceName);
            if (InstanceName != NULL)
            {
                //
                // Remember the static provider id list and assume that the 
                // request is going to be dynamic
                //
                StaticPIPtr = *ProviderIdList;
                PIPtr = StaticPIPtr;
                PIMax = *ProviderIdCount;
                PICount = 0;
                
                //
                // March down instance set list to see if we have a 
                // static name and build the list of dynamic provider ids
                // 
                Done = FALSE;
            
                WmipEnterSMCritSection();
                if (GuidEntry->ISCount > 0)
                {
                    InstanceSetList = GuidEntry->ISHead.Flink;
                    while ((InstanceSetList != &GuidEntry->ISHead) && ! Done)
                    {
                        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                                        INSTANCESET,
                                                        GuidISList);
                                        
                        if ((InstanceSet->Flags & (IS_TRACED | IS_CONTROL_GUID | IS_EVENT_ONLY)) == 0)
                        {
                            //
                            // Only take those IS that are not traced or control
                            // guids and are not event only guids
                            //
                            if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
                            {
                                PBISBASENAME IsBaseName;
                                ULONG BaseIndex;
                                PWCHAR BaseName;
                                SIZE_T BaseNameLen;
                                PWCHAR SuffixPtr;
                                ULONG Suffix;
                                WCHAR SuffixText[MAXBASENAMESUFFIXSIZE+1];
                            
                                //
                                // See if the instance name is from this base name
                                //
                                IsBaseName = InstanceSet->IsBaseName;
                        
                                BaseIndex = IsBaseName->BaseIndex;
                                BaseName = IsBaseName->BaseName;
                                BaseNameLen = wcslen(BaseName);
                         
                                if ((wcslen(InstanceName) > BaseNameLen) && 
                                    (_wcsnicmp(InstanceName, BaseName, BaseNameLen) == 0))
                                {
                                    //
                                    // The suffix matches the beginning of our instance
                                    // name and our instance name is longer than the
                                    // suffix.
                                    //
                                    SuffixPtr = &InstanceName[BaseNameLen];
                                    Suffix = _wtoi(SuffixPtr);
                                    if ((WmipIsNumber(SuffixPtr) && 
                                        (Suffix >= BaseIndex) && 
                                        (Suffix < (BaseIndex + InstanceSet->Count))))
                                    {
                                        //
                                        // Our suffix is a number within the range for
                                        // this instance set
                                        //
                                        if (Suffix < MAXBASENAMESUFFIXVALUE)
                                        {
                                            StringCbPrintf(SuffixText,
                                                           sizeof(SuffixText),
                                                           BASENAMEFORMATSTRING,
                                                           Suffix);
                                            if (_wcsicmp(SuffixText, SuffixPtr) == 0)
                                            {
                                                //
                                                // Our instance name is part of the
                                                // instance set so note the provider id
                                                // and instance index
                                                //
                                                Wnode->Flags |= WNODE_FLAG_STATIC_INSTANCE_NAMES;
                                                Wnode->ProviderId = InstanceSet->ProviderId;
                                                WnodeSI->InstanceIndex = Suffix - BaseIndex;
                                                *IsDynamic = FALSE;
                                                Done = TRUE;
                                            }
                                        }
                                    }
                                }                    
                             } else if (InstanceSet->Flags & IS_INSTANCE_STATICNAMES) {
                                //
                                // See if the passed instance name matches any of the 
                                // static names for this instnace set
                                //
                                PWCHAR *StaticNames;
                        
                                StaticNames = InstanceSet->IsStaticNames->StaticNamePtr;
                                for (i =0; i < InstanceSet->Count; i++)
                                {
                                    if (_wcsicmp(StaticNames[i], InstanceName) == 0)
                                    {
                                        //
                                        // We matched our instance name with a static
                                        // instance name. Remember provider id and
                                        // instance index.
                                        //
                                        Wnode->Flags |= WNODE_FLAG_STATIC_INSTANCE_NAMES;
                                        Wnode->ProviderId = InstanceSet->ProviderId;
                                        WnodeSI->InstanceIndex = i;
                                        *IsDynamic = FALSE;
                                        Done = TRUE;
                                        break;
                                    }
                                }
                        
                            } else {
                                //
                                // Remember dynamic providerid
                                //
                                WmipReferenceIS(InstanceSet);
                                Status = WmipAddProviderIdToPIList(&PIPtr,
                                                             &PICount,
                                                             &PIMax,
                                                             StaticPIPtr,
                                                             InstanceSet);
                                if (! NT_SUCCESS(Status))
                                {
                                    Done = TRUE;
                                }
                             }
                         }
                        InstanceSetList = InstanceSetList->Flink;
                    }
                } else {
                    //
                    // There are no instance sets registered for this guid
                    //
                    Status = STATUS_WMI_GUID_DISCONNECTED;
                }
                
                WmipFree(InstanceName);             
                WmipLeaveSMCritSection();               
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            
        
            if (*IsDynamic)
            {
                //
                // Dynamic instance name so return list of dynamic providers
                //
                *ProviderIdCount = PICount;
                *ProviderIdList = PIPtr;
            } else {
                //
                // Static instance name so unref an dynamic instance sets
                //
                if (PIPtr != NULL)
                {
                    for (i = 0; i < PICount; i++)
                    {
                        WmipUnreferenceIS(PIPtr[i]);
                    }
                
                    if (PIPtr != StaticPIPtr)
                    {
                        WmipFree(PIPtr);
                    }
                }
            }
        }
    } else {
        Status = STATUS_WMI_GUID_DISCONNECTED;
    }
    
    return(Status);                             
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

const ACCESS_MASK DesiredAccessForFunction[] =
{
    WMIGUID_QUERY,         // IRP_MN_QUERY_ALL_DATA
    WMIGUID_QUERY,         // IRP_MN_QUERY_SINGLE_INSTANCE
    WMIGUID_SET,           // IRP_MN_CHANGE_SINGLE_INSTANCE
    WMIGUID_SET,           // IRP_MN_CHANGE_SINGLE_ITEM
    0,                     // IRP_MN_ENABLE_EVENTS
    0,                     // IRP_MN_DISABLE_EVENTS
    0,                     // IRP_MN_ENABLE_COLLECTION
    0,                     // IRP_MN_DISABLE_COLLECTION
    0,                     // IRP_MN_REGINFO
    WMIGUID_EXECUTE,       // IRP_MN_EXECUTE_METHOD
    0,                     // IRP_MN_TRACE_EVENT or IRP_MN_SET_TRACE_NOTIFY
    0                      // IRP_MN_REGINFO_EX
};

NTSTATUS WmipQuerySetExecuteSI(
    IN PWMIGUIDOBJECT GuidObject,
    IN PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    IN UCHAR MinorFunction,
    IN OUT PWNODE_HEADER Wnode,
    IN ULONG OutBufferSize,
    OUT PULONG RetSize
    )
{
    NTSTATUS Status, ReturnStatus;
    PBINSTANCESET StaticPIList[MANYPROVIDERIDS];
    PBINSTANCESET *PIList;
    HANDLE KernelHandle;
    ULONG PICount;
    BOOLEAN IsDynamic;
    ULONG i;
    BOOLEAN InternalGuid;
    IO_STATUS_BLOCK Iosb;
#if DBG
    BOOLEAN InstanceClaimed;
#endif

    PAGED_CODE();

    WmipAssert(((MinorFunction >= IRP_MN_QUERY_ALL_DATA) &&
                (MinorFunction <= IRP_MN_CHANGE_SINGLE_ITEM)) ||
               (MinorFunction == IRP_MN_EXECUTE_METHOD));


    //
    // Check Security
    //
    if (GuidObject != NULL)
    {
        Status = ObReferenceObjectByPointer(GuidObject,
                                            DesiredAccessForFunction[MinorFunction],
                                            WmipGuidObjectType,
                                            AccessMode);        
    } else {
        KernelHandle = Wnode->KernelHandle;
        Status = ObReferenceObjectByHandle(KernelHandle,
                                          DesiredAccessForFunction[MinorFunction],
                                          WmipGuidObjectType,
                                          AccessMode,
                                          &GuidObject,
                                          NULL);
    }
                   
    if (NT_SUCCESS(Status))
    {        
        PIList = StaticPIList;
        PICount = MANYPROVIDERIDS;
        Status = WmipPrepareWnodeSI(GuidObject,
                        (PWNODE_SINGLE_INSTANCE)Wnode,
                                &PICount,
                                &PIList,
                                &IsDynamic,
                                &InternalGuid);

        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,
                          "WMI: QSI Prepare [%s - %s] %x with %x PI at %p\n",
                          IsDynamic ? "Dynamic" : "Static", 
                          InternalGuid  ? "Internal" : "External",
                          Wnode->KernelHandle, PICount, PIList));
                      
        if (NT_SUCCESS(Status))
        {
            if (InternalGuid)
            {
                //
                // Internal guid query 
                //
                Wnode->Flags |= WNODE_FLAG_INTERNAL;
                Wnode->BufferSize = sizeof(WNODE_HEADER);
                Irp->IoStatus.Information = sizeof(WNODE_HEADER);
            } else {
                if (IsDynamic)
                {
                    //
                    // We need to loop over all dynamic instance names until
                    // one of them responds successfully and then we assume
                    // that they own the instance
                    //
#if DBG                
                    InstanceClaimed = FALSE;
#endif        
                    if ((MinorFunction == IRP_MN_CHANGE_SINGLE_ITEM) ||
                        (MinorFunction == IRP_MN_EXECUTE_METHOD))
                    {
                        Status = STATUS_WMI_ITEMID_NOT_FOUND;
                    } else {
                        Status = STATUS_WMI_INSTANCE_NOT_FOUND;
                    }
        
                    for (i = 0; i < PICount; i++)
                    {
                        Wnode->ProviderId = PIList[i]->ProviderId;
                        if (Irp != NULL)
                        {
                            ReturnStatus = WmipForwardWmiIrp(Irp,
                                               MinorFunction,
                                               Wnode->ProviderId,
                                               &Wnode->Guid,
                                               OutBufferSize,
                                               Wnode);

                            if (NT_SUCCESS(ReturnStatus))
                            {
                                *RetSize = (ULONG)Irp->IoStatus.Information;
                            }                           
                        } else {
                            ReturnStatus = WmipSendWmiIrp(
                                                       MinorFunction,
                                                       Wnode->ProviderId,
                                                       &Wnode->Guid,
                                                       OutBufferSize,
                                                       Wnode,
                                                       &Iosb);
                            
                            if (NT_SUCCESS(ReturnStatus))
                            {
                                *RetSize = (ULONG)Iosb.Information;
                            }
                        }
                        
                        //
                        // One of these status codes imply that the device does
                        // positively claim the instance name and so we break out
                        // and return the results
                        //
                        if ((NT_SUCCESS(ReturnStatus)) ||
                            (ReturnStatus == STATUS_WMI_SET_FAILURE) ||
                            (ReturnStatus == STATUS_WMI_ITEMID_NOT_FOUND) ||
                            (ReturnStatus == STATUS_WMI_READ_ONLY))
                        {
                            Status = ReturnStatus;
                            break;
                        }
                                       
                                       
                        //
                         // If the device does not own the instance it can
                        // only return STATUS_WMI_INSTANCE_NOT_FOUND or 
                        // STATUS_WMI_GUID_NOT_FOUND. Any other return code
                        // implies that the device owns the instance, but 
                         // encountered an error.
                        //                
                        if ( (ReturnStatus != STATUS_WMI_INSTANCE_NOT_FOUND) &&
                             (ReturnStatus != STATUS_WMI_GUID_NOT_FOUND))
                        {
                            WmipAssert(! InstanceClaimed);
    #if DBG                    
                            InstanceClaimed = TRUE;
    #endif                  
                            Status = ReturnStatus;
                        }
       
                        WmipUnreferenceIS(PIList[i]);
                     
                    }
                    
                    if ((PIList != StaticPIList) && (PIList != NULL))
                    {
                        WmipFree(PIList);
                    }    
                } else {
                    //
                    // Since we have a static instance name we can target directly
                    // at the device that has our instance name
                    //
                    if (Irp != NULL)
                    {
                        Status = WmipForwardWmiIrp(Irp,
                                                   MinorFunction,
                                                   Wnode->ProviderId,
                                                   &Wnode->Guid,
                                                   OutBufferSize,
                                                   Wnode);
                                               
                        *RetSize = (ULONG)Irp->IoStatus.Information;
                    } else {
                        Status = WmipSendWmiIrp(
                                                   MinorFunction,
                                                   Wnode->ProviderId,
                                                   &Wnode->Guid,
                                                   OutBufferSize,
                                                   Wnode,
                                                   &Iosb);
                                               
                        *RetSize = (ULONG)Iosb.Information;
                    }
                }
            }
        }
    
        //
        // And remove ref on guid object
        //
        ObDereferenceObject(GuidObject);    
    }

    return(Status);
}

NTSTATUS WmipQuerySingleMultiple(
    IN PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    IN OUT PUCHAR BufferPtr,        
    IN ULONG BufferSize,
    IN PWMIQSIMULTIPLE QsiMultiple,
    IN ULONG QueryCount,
    IN PWMIGUIDOBJECT *ObjectList,
    IN PUNICODE_STRING InstanceNames,    
    OUT ULONG *ReturnSize
    )
{
    PWMIQSIINFO QsiInfo;
    UCHAR WnodeQSIStatic[sizeof(WNODE_SINGLE_INSTANCE) + 
                         256*sizeof(WCHAR) + 
                         sizeof(ULONG)];
    PWNODE_SINGLE_INSTANCE WnodeQSI;
    ULONG WnodeQSISize;
    ULONG WnodeSizeNeeded;
    NTSTATUS Status, Status2;
    ULONG SizeNeeded;
    BOOLEAN BufferFull, BufferOverFlow;
    PWNODE_HEADER WnodePrev;
    PUCHAR Buffer;
    ULONG i;
    ULONG WnodeSize;
    PWNODE_SINGLE_INSTANCE Wnode;
    PWCHAR InstanceName;
    ULONG RetSize;
    PWNODE_TOO_SMALL WnodeTooSmall;
    ULONG Linkage = 0;
    ULONG SkipSize;
    PWMIGUIDOBJECT Object = NULL;
    UNICODE_STRING UString;
    HANDLE KernelHandle;

    PAGED_CODE();

    //
    // We are called by kernel mode and passed an object list and InstanceNames
    // or we are called by user mode and passed a QsiMultiple instead
    //
    WmipAssert( ((AccessMode == KernelMode) &&
                  (QsiMultiple == NULL) && 
                  (ObjectList != NULL) && 
                  (InstanceNames != NULL)) ||
                ((AccessMode == UserMode) &&
                  (QsiMultiple != NULL) && 
                  (ObjectList == NULL) && 
                  (InstanceNames == NULL)) );

    Status = STATUS_SUCCESS;
    if (ObjectList == NULL)
    {
        //
        // if this is a user call then we need to copy out the
        // QSIMULTIPLE information since it is in the system buffer and
        // will get overwritten on the first query
        //
        QsiInfo = (PWMIQSIINFO)WmipAlloc(QueryCount * sizeof(WMIQSIINFO));

        if (QsiInfo != NULL)
        {
            RtlCopyMemory(QsiInfo, 
                          &QsiMultiple->QsiInfo, 
                          QueryCount * sizeof(WMIQSIINFO));
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        Object = NULL;
    } else {
        QsiInfo = NULL;
    }

    if (NT_SUCCESS(Status))
    {
        SizeNeeded = 0;
        BufferFull = FALSE;
        BufferOverFlow = FALSE;
        WnodePrev = NULL;
        Buffer = BufferPtr;
        WnodeQSI = (PWNODE_SINGLE_INSTANCE)&WnodeQSIStatic;
        WnodeQSISize = sizeof(WnodeQSIStatic);
        for (i = 0; i < QueryCount; i++)
        {
            if (ObjectList == NULL)
            {
                UString.Length = QsiInfo[i].InstanceName.Length;
                UString.MaximumLength = QsiInfo[i].InstanceName.MaximumLength;
                UString.Buffer = QsiInfo[i].InstanceName.Buffer;
                KernelHandle = QsiInfo[i].Handle.Handle;
            } else {
                UString = InstanceNames[i];
                Object = ObjectList[i];
                KernelHandle = NULL;
            }
            
            WnodeSizeNeeded = (FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                             VariableData) +
                                UString.Length + 
                                sizeof(USHORT) + 7) & ~7;

            if ((BufferFull) || (BufferSize < WnodeSizeNeeded))
            {
                //
                // If there is no more room, we are just querying for the
                // size that will be needed.
                //
                if (WnodeSizeNeeded > WnodeQSISize)
                {
                    //
                    // Our temporary buffer is too small so lets alloc a
                    // larger one
                    //
                    if (WnodeQSI != (PWNODE_SINGLE_INSTANCE)WnodeQSIStatic)
                    {
                        WmipFree(WnodeQSI);
                    }
                    
                    WnodeQSI = (PWNODE_SINGLE_INSTANCE)WmipAllocNP(WnodeSizeNeeded);
                    if (WnodeQSI == NULL)
                    {
                        //
                        // We couldn't allocate a larger temporary buffer
                        // so we abort this call and try to exit gracefully
                        //
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                    
                    WnodeQSISize = WnodeSizeNeeded;
                }
                
                Wnode = WnodeQSI;
                WnodeSize = WnodeSizeNeeded;
                WnodePrev = NULL;
                BufferFull = TRUE;
            } else {
                //
                // Plenty of room so build wnode directly into the output
                // buffer
                //
                Wnode = (PWNODE_SINGLE_INSTANCE)Buffer;
                WnodeSize = BufferSize;
            }
            
            //
            // Build WNODE_SINGLE_INSTANCE in order to do the query
            //
            RtlZeroMemory(Wnode, sizeof(WNODE_SINGLE_INSTANCE));
            Wnode->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE;
            Wnode->WnodeHeader.BufferSize = WnodeSizeNeeded;
            Wnode->WnodeHeader.KernelHandle = KernelHandle;
            
            Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                     VariableData);
            Wnode->DataBlockOffset = WnodeSizeNeeded;
            InstanceName = (PWCHAR)OffsetToPtr(Wnode, 
                                               Wnode->OffsetInstanceName);

            
            *InstanceName++ = UString.Length;
            try
            {
                if (AccessMode == UserMode)
                {
                    ProbeForRead(UString.Buffer,
                                 UString.Length,
                                 sizeof(WCHAR));
                }
                 
                RtlCopyMemory(InstanceName,
                              UString.Buffer,
                              UString.Length);
                  
                
            } except(EXCEPTION_EXECUTE_HANDLER) {
                //
                // If an error occured probing then we fail the entire call
                //
                Status = GetExceptionCode();
                break;
            }
    
    
            Status2 = WmipQuerySetExecuteSI(Object,
                                            Irp,
                                            AccessMode,
                                            IRP_MN_QUERY_SINGLE_INSTANCE,
                                            (PWNODE_HEADER)Wnode,
                                            WnodeSize,
                                            &RetSize);
                                   
            if (NT_SUCCESS(Status2))
            {
                if (Wnode->WnodeHeader.Flags & WNODE_FLAG_INTERNAL) 
                {
                    //
                    // Skip any internal guid quesries 
                    //
                } else if (Wnode->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL) {
                    //
                    // There is no enough room so just tally up
                    // the size that will be needed.
                    //
                    WnodeTooSmall = (PWNODE_TOO_SMALL)Wnode;
                    SizeNeeded += (WnodeTooSmall->SizeNeeded+7) & ~7;
                    BufferFull = TRUE;
                    BufferOverFlow = TRUE;
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,
                                    "WMI: QSIM %ws too small %x SizeNeeded %x\n",
                                     UString.Buffer,
                                     (WnodeTooSmall->SizeNeeded+7) & ~7,
                                     SizeNeeded));
                } else if (BufferFull) {
                    //
                    // There was enough room, but the buffer was already
                    // filled so we just tally up the size needed
                    //
                    SizeNeeded += (RetSize+7) & ~7;
                    BufferOverFlow = TRUE;
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,
                                    "WMI: QSIM %ws big enough but full  %x SizeNeeded %x\n",
                                     UString.Buffer,
                                     (RetSize+7) & ~7,
                                     SizeNeeded));
                } else {
                    //
                    // We successfully got data. Link the previous wnode
                    // to this one
                    //
                    if (WnodePrev != NULL)
                    {
                        WnodePrev->Linkage = Linkage;
                    }
                    
                    WnodePrev = (PWNODE_HEADER)Wnode;
                    while (WnodePrev->Linkage != 0)
                    {
                        WnodePrev = (PWNODE_HEADER)OffsetToPtr(WnodePrev,
                                                          WnodePrev->Linkage);
                    }
                    
                    SkipSize = (RetSize+7) &~7;
                    SizeNeeded += SkipSize;
                    BufferSize -= SkipSize;
                    Buffer += SkipSize;

                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,
                                    "WMI: QSIM %ws big enough %x SizeNeeded %x\n",
                                     UString.Buffer,
                                     SkipSize,
                                     SizeNeeded));
                    
                    Linkage = (ULONG) ((PCHAR)Buffer - (PCHAR)WnodePrev);
                }
            } else {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,
                                    "WMI: QSIM %ws Failed SizeNeeded %x\n",
                                     UString.Buffer,
                                     SizeNeeded));
            }
        }
        
        if (WnodeQSI != (PWNODE_SINGLE_INSTANCE)WnodeQSIStatic)
        {
            WmipFree(WnodeQSI);
        }
                  
        if (NT_SUCCESS(Status) && (BufferFull))
        {
            WnodeTooSmall = (PWNODE_TOO_SMALL)BufferPtr;
            WnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
            WnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
            WnodeTooSmall->SizeNeeded = SizeNeeded;
            *ReturnSize = sizeof(WNODE_TOO_SMALL);
        } else {
            *ReturnSize = SizeNeeded;
        }

        if (QsiInfo != NULL)
        {
            WmipFree(QsiInfo);
        }
    }
    
    
    
    return(Status);
}

void
WmipGetGuidPropertiesFromGuidEntry(
    PWMIGUIDPROPERTIES GuidInfo, 
    PGUIDENTRY GuidEntry)
/*++
Routine Description:

    This routine fills GuidInfo with the properties for the Guid
    represented by the GuidEntry. Note that this call is made holding
    the SMCritSection.

Arguments:

Return Value:

--*/
{
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;

    PAGED_CODE();
    
    GuidInfo->GuidType = WMI_GUIDTYPE_DATA;
    GuidInfo->IsEnabled = FALSE;
    GuidInfo->LoggerId = 0;
    GuidInfo->EnableLevel = 0;
    GuidInfo->EnableFlags = 0;

    InstanceSetList = GuidEntry->ISHead.Flink;
    while (InstanceSetList != &GuidEntry->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        GuidISList);
        if (InstanceSet->Flags & IS_EVENT_ONLY) 
        {
            GuidInfo->GuidType = WMI_GUIDTYPE_EVENT;
        }
        if (((InstanceSet->Flags & IS_ENABLE_EVENT) ||
            (InstanceSet->Flags & IS_ENABLE_COLLECTION)) ||
            (InstanceSet->Flags & IS_COLLECTING))
        {
            GuidInfo->IsEnabled = TRUE;
        }
        if ( (InstanceSet->Flags & IS_TRACED) &&
             (InstanceSet->Flags & IS_CONTROL_GUID) )
        {
            GuidInfo->GuidType = WMI_GUIDTYPE_TRACECONTROL;
            break;
        }
        InstanceSetList = InstanceSetList->Flink;
    }
    

    if (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)
    {
        if (GuidInfo->GuidType == WMI_GUIDTYPE_TRACECONTROL) {
            //
            // If a NotificationEntry is found for a TraceControlGuid
            // it means that it is enabled.
            //
            ULONG64 LoggerContext = GuidEntry->LoggerContext;
            GuidInfo->IsEnabled = TRUE; 
            GuidInfo->LoggerId = WmiGetLoggerId(LoggerContext);
            GuidInfo->EnableLevel = WmiGetLoggerEnableLevel(LoggerContext);
            GuidInfo->EnableFlags = WmiGetLoggerEnableFlags(LoggerContext);
        }
    }
}

NTSTATUS WmipEnumerateGuids(
    ULONG Ioctl,
    PWMIGUIDLISTINFO GuidList,
    ULONG MaxBufferSize,
    ULONG *OutBufferSize
)
{
    ULONG TotalGuidCount;
    ULONG WrittenGuidCount;
    ULONG AllowedGuidCount;
    PWMIGUIDPROPERTIES GuidPtr;
    PBGUIDENTRY GuidEntry;
    PLIST_ENTRY GuidEntryList;
    

    PAGED_CODE();
    
    TotalGuidCount = 0;
    WrittenGuidCount = 0;
    AllowedGuidCount = (MaxBufferSize - FIELD_OFFSET(WMIGUIDLISTINFO, GuidList)) / sizeof(WMIGUIDPROPERTIES);
    
    GuidPtr = &GuidList->GuidList[0];
    
    WmipEnterSMCritSection();
    
    //
    // Fill up structure with list of guids
    //
    GuidEntryList = WmipGEHeadPtr->Flink;
    while (GuidEntryList != WmipGEHeadPtr)
    {
        GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                     GUIDENTRY,
                                     MainGEList);

        TotalGuidCount++;
        if (WrittenGuidCount < AllowedGuidCount)
        {
            GuidPtr[WrittenGuidCount].Guid = GuidEntry->Guid;
            WrittenGuidCount++;
        }
        
        GuidEntryList = GuidEntryList->Flink;
    }
    
    if (Ioctl == IOCTL_WMI_ENUMERATE_GUIDS_AND_PROPERTIES)
    {
        //
        // If needed fill struct with guid properties
        //
        TotalGuidCount = 0;
        WrittenGuidCount = 0;
        GuidEntryList = WmipGEHeadPtr->Flink;
        while (GuidEntryList != WmipGEHeadPtr)
        {
            GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                     GUIDENTRY,
                                     MainGEList);

            TotalGuidCount++;
            if (WrittenGuidCount < AllowedGuidCount)
            {
                WmipGetGuidPropertiesFromGuidEntry(&GuidPtr[WrittenGuidCount], 
                                               GuidEntry);
                WrittenGuidCount++;
            }
        
            GuidEntryList = GuidEntryList->Flink;
        }       
    }
    
    WmipLeaveSMCritSection();
    
    GuidList->TotalGuidCount = TotalGuidCount;
    GuidList->ReturnedGuidCount = WrittenGuidCount;
                 
    *OutBufferSize = FIELD_OFFSET(WMIGUIDLISTINFO, GuidList) +
                     WrittenGuidCount * sizeof(WMIGUIDPROPERTIES);
                 
    return(STATUS_SUCCESS);
}

NTSTATUS WmipQueryGuidInfo(
    IN OUT PWMIQUERYGUIDINFO QueryGuidInfo
    )
{
    HANDLE Handle;
    NTSTATUS Status;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    PBGUIDENTRY GuidEntry;
    PWMIGUIDOBJECT GuidObject;
    
    PAGED_CODE();
    
    Handle = QueryGuidInfo->KernelHandle.Handle;
    
    Status = ObReferenceObjectByHandle(Handle,
                                       WMIGUID_QUERY,
                                       WmipGuidObjectType,
                                       UserMode,
                                       &GuidObject,
                                       NULL);
                   
    if (NT_SUCCESS(Status))
    {
        GuidEntry = GuidObject->GuidEntry;
    
        if (GuidEntry != NULL)
        {
            //
            // Assume that the guid is not expensive and then loop over 
            // all instances to see if one of them is expensive.
            //
            QueryGuidInfo->IsExpensive = FALSE;
                
            WmipEnterSMCritSection();
            InstanceSetList = GuidEntry->ISHead.Flink;
            while (InstanceSetList != &GuidEntry->ISHead)
            {
                InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                                    INSTANCESET,
                                                    GuidISList);
            
                if (InstanceSet->Flags & IS_EXPENSIVE)
                {
                    //
                    // The guid is expensive so remember that and break
                    // out of loop
                    //
                    QueryGuidInfo->IsExpensive = TRUE;
                    break;
                }
                InstanceSetList = InstanceSetList->Flink;
            }
        
            WmipLeaveSMCritSection();
        } else {
            //
            // The guid object exists, but there is not a corresponding 
            // guidentry which is an error.
            //
            Status = STATUS_WMI_GUID_DISCONNECTED;
        }
    
    //
    // And remove ref on guid object
    //
        ObDereferenceObject(GuidObject);    
    
    }
    return(Status);
}

//
// The head of the list that contains the guid objects associated with
// an irp is in the DriverContext  part of the irp
//
#define IRP_OBJECT_LIST_HEAD(Irp) (PLIST_ENTRY)((Irp)->Tail.Overlay.DriverContext)

void WmipClearIrpObjectList(
    PIRP Irp
    )
{
    PLIST_ENTRY ObjectListHead;
    PLIST_ENTRY ObjectList, ObjectListNext;
    PWMIGUIDOBJECT Object;
        
    PAGED_CODE();
    
    //
    // This routine assumes that the SMCritSection is being held
    //
    ObjectListHead = IRP_OBJECT_LIST_HEAD(Irp);
    ObjectList = ObjectListHead->Flink;
    
    //
    // Loop over all objects associated with this irp and reset the
    // value for its associated irp since this irp is now going away
    //
    while (ObjectList != ObjectListHead)
    {
        Object = CONTAINING_RECORD(ObjectList,
                                   WMIGUIDOBJECT,
                                   IrpObjectList);
                            
        WmipAssert(Object->Irp == Irp);
        WmipAssert(Object->EventQueueAction == RECEIVE_ACTION_NONE);
        Object->Irp = NULL;
        RemoveEntryList(ObjectList);
        ObjectListNext = ObjectList->Flink;
        ObjectList = ObjectListNext;
    }
}

void WmipClearObjectFromThreadList(
    PWMIGUIDOBJECT Object
    )
{
    PLIST_ENTRY ThreadList;
    
    PAGED_CODE();

    ThreadList = &Object->ThreadObjectList;
    
    if (IsListEmpty(ThreadList))
    {
        //
        // if this is the last object on the thread list then we need
        // to close the handle (in the system handle table) to the user
        // mode process
        //
        ZwClose(Object->UserModeProcess);
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_API_INFO_LEVEL,
                          "WMI: Closed UserModeProcessHandle %x\n", Object->UserModeProcess));
    }

    Object->UserModeProcess = NULL;
    Object->UserModeCallback = NULL;
    Object->EventQueueAction = RECEIVE_ACTION_NONE;

    RemoveEntryList(ThreadList);
    InitializeListHead(ThreadList);
}

void WmipClearThreadObjectList(
    PWMIGUIDOBJECT MainObject
    )
{
    PWMIGUIDOBJECT Object;
    PLIST_ENTRY ObjectList;
#if DBG 
    HANDLE MyUserModeProcess;
    PUSER_THREAD_START_ROUTINE MyUserModeCallback;
#endif  
    
    PAGED_CODE();

    //
    // This routine assumes the SMCrit Section is held
    //
#if DBG     
    MyUserModeProcess = MainObject->UserModeProcess;
    MyUserModeCallback = MainObject->UserModeCallback;
#endif      
        
    ObjectList = &MainObject->ThreadObjectList;
    do 
    {
        Object = CONTAINING_RECORD(ObjectList,
                                   WMIGUIDOBJECT,
                                   ThreadObjectList);

        WmipAssert(Object->UserModeProcess == MyUserModeProcess);
        WmipAssert(Object->UserModeCallback == MyUserModeCallback);
        WmipAssert(Object->EventQueueAction == RECEIVE_ACTION_CREATE_THREAD);

        ObjectList = ObjectList->Flink;

        WmipClearObjectFromThreadList(Object);
        
    } while (! IsListEmpty(ObjectList));
}

void WmipNotificationIrpCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancel routine for a pending read notification irp.

Arguments:

    DeviceObject is the device object of the WMI service device

    Irp is the pending Irp to be cancelled

Return Value:


--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    WmipEnterSMCritSection();
    WmipClearIrpObjectList(Irp);
    WmipLeaveSMCritSection();

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT );
}


#define WmipHaveHiPriorityEvent(Object) \
      (((Object)->HiPriority.Buffer != NULL) &&  \
       ((Object)->HiPriority.NextOffset != 0))

#define WmipHaveLoPriorityEvent(Object) \
      (((Object)->LoPriority.Buffer != NULL) &&  \
       ((Object)->LoPriority.NextOffset != 0))

#define WmipSetHighWord(a, b) \
    (a) &= ~(0xffff0000); \
    (a) |= ( (USHORT)(b) << 16)

void WmipCopyFromEventQueues(
    IN POBJECT_EVENT_INFO ObjectArray,
    IN ULONG HandleCount,
    OUT PUCHAR OutBuffer,
    OUT ULONG *OutBufferSizeUsed,
    OUT PWNODE_HEADER *LastWnode,                               
    IN BOOLEAN IsHiPriority
    )
{

    PWMIGUIDOBJECT GuidObject;
    ULONG i, Earliest;
    ULONG SizeUsed, Size;
    PWNODE_HEADER InWnode, OutWnode;
    LARGE_INTEGER Timestamp, LastTimestamp;
    PWMIEVENTQUEUE EventQueue;


    //
    // Consider adding extra code for perf
    // 1. If only 1 object is passed
    // 2. Once we find the earliest event we look ahead in that same
    //    event queue buffer assuming that it will be earlier than
    //    events in other buffers. This makes sense when only one queue
    //    has events left in it.
    //
    
    PAGED_CODE();
    
    //
    // This routine assumes that the output buffer has been checked and
    // that it is large enough to accomodate all of the events. This
    // implies that this function is called while holding the critical
    // section.
    //
    
    //
    // See which guid objects have events to be processed
    //
    for (i = 0; i < HandleCount; i++)
    {
        GuidObject = ObjectArray[i].GuidObject;
        if (IsHiPriority)
        {
            if ((GuidObject->HiPriority.Buffer != NULL) &&
                (GuidObject->HiPriority.NextOffset != 0))
            {
                ObjectArray[i].NextWnode = (PWNODE_HEADER)GuidObject->HiPriority.Buffer;
                WmipSetHighWord(ObjectArray[i].NextWnode->Version,
                                GuidObject->HiPriority.EventsLost);
                GuidObject->HiPriority.EventsLost = 0;
                WmipAssert(ObjectArray[i].NextWnode != NULL);
            } else {
                ObjectArray[i].NextWnode = NULL;
            }                       
        } else {
            if ((GuidObject->LoPriority.Buffer != 0) &&
                (GuidObject->LoPriority.NextOffset != 0))
            {
                ObjectArray[i].NextWnode = (PWNODE_HEADER)GuidObject->LoPriority.Buffer;
                WmipSetHighWord(ObjectArray[i].NextWnode->Version,
                                GuidObject->LoPriority.EventsLost);
                GuidObject->LoPriority.EventsLost = 0;
                WmipAssert(ObjectArray[i].NextWnode != NULL);
            } else {
                ObjectArray[i].NextWnode = NULL;
            }                       
        }       
    }

    //
    // loop until all events in all guid objects have been
    // processed
    //
    SizeUsed = 0;
    Earliest = 0;
    OutWnode = NULL;
    while (Earliest != 0xffffffff)
    {
        Timestamp.QuadPart = 0x7fffffffffffffff;
        Earliest = 0xffffffff;
        for (i = 0; i < HandleCount; i++)
        {
            InWnode = (PWNODE_HEADER)ObjectArray[i].NextWnode;
            if ((InWnode != NULL) &&
                (InWnode->TimeStamp.QuadPart < Timestamp.QuadPart))
            {
                //
                // We found an event that is earlier than any previous
                // one so we remember the new candidate for earliest
                // event and also the previous early event
                //
                LastTimestamp = Timestamp;
                Timestamp = InWnode->TimeStamp;
                Earliest = i;
            }
        }

        if (Earliest != 0xffffffff)
        {
            //
            // We found the earliest event so copy it into the output
            // buffer
            //
            InWnode = (PWNODE_HEADER)ObjectArray[Earliest].NextWnode;
            Size = (InWnode->BufferSize + 7) & ~7;

            OutWnode = (PWNODE_HEADER)OutBuffer;
            RtlCopyMemory(OutWnode, InWnode, InWnode->BufferSize);
            OutWnode->Linkage = Size;
            
            OutBuffer += Size;
            SizeUsed += Size;

            if (InWnode->Linkage != 0)
            {
                InWnode = (PWNODE_HEADER)((PUCHAR)InWnode + InWnode->Linkage);
            } else {
                InWnode = NULL;
            }
            ObjectArray[Earliest].NextWnode = InWnode;
        }
    }
    
    *LastWnode = OutWnode;
    *OutBufferSizeUsed = SizeUsed;

    //
    // clean up event queue resources and reset the object
    //
    for (i = 0; i < HandleCount; i++)
    {
        
        GuidObject = ObjectArray[i].GuidObject;

        if (IsHiPriority)
        {
            EventQueue = &GuidObject->HiPriority;
        } else {
            EventQueue = &GuidObject->LoPriority;           
        }

        if (EventQueue->Buffer != NULL)
        {
            WmipFree(EventQueue->Buffer);
            EventQueue->Buffer = NULL;
            EventQueue->NextOffset = 0;
            EventQueue->LastWnode = NULL;
        }
        
        KeClearEvent(&GuidObject->Event);
    }
}

void WmipCompleteGuidIrpWithError(
    PWMIGUIDOBJECT GuidObject
    )
{
    PIRP OldIrp;

    PAGED_CODE();

    //
    // This routine assumes that the SM Critical Section is held
    //
    
    //
    // If this object is already being waited on by a different
    // irp then we need to fail the original irp since we only
    // allow a single irp to wait on a specific object
    //
    WmipAssert(GuidObject->IrpObjectList.Flink != NULL);
    WmipAssert(GuidObject->IrpObjectList.Blink != NULL);

    OldIrp = GuidObject->Irp;
    if (IoSetCancelRoutine(OldIrp, NULL))
    {
        //
        // If there was a cancel routine then this means that
        // the irp is still pending so we can go and complete it
        //
        WmipClearIrpObjectList(OldIrp);
        WmipAssert(GuidObject->Irp == NULL);
        OldIrp->IoStatus.Status = STATUS_INVALID_HANDLE;
        IoCompleteRequest(OldIrp, IO_NO_INCREMENT);
    }
}

NTSTATUS WmipMarkHandleAsClosed(
    HANDLE Handle
    )
{
    NTSTATUS Status;
    PWMIGUIDOBJECT GuidObject;

    PAGED_CODE();
    
    Status = ObReferenceObjectByHandle(Handle,
                                   WMIGUID_NOTIFICATION,
                                   WmipGuidObjectType,
                                   UserMode,
                                   &GuidObject,
                                   NULL);
    
    if (NT_SUCCESS(Status))
    {
        //
        // Mark object as no longer able to receive events
        //
        WmipEnterSMCritSection();
        GuidObject->Flags |= WMIGUID_FLAG_RECEIVE_NO_EVENTS;
        if (GuidObject->Irp != NULL)
        {
            //
            // If this object was is waiting in a pending irp then we
            // need to complete the irp to keep the pump moving
            //
            WmipCompleteGuidIrpWithError(GuidObject);
        }
        WmipLeaveSMCritSection();
        ObDereferenceObject(GuidObject);
    }
    
    return(Status);
    
}

NTSTATUS WmipReceiveNotifications(
    PWMIRECEIVENOTIFICATION ReceiveNotification,
    PULONG OutBufferSize,
    PIRP Irp
    )
{
    #define MANY_NOTIFICATION_OBJECTS 16
    ULONG i;
    PWMIGUIDOBJECT GuidObject;
    ULONG HandleCount;
    PHANDLE3264 HandleArray;
    OBJECT_EVENT_INFO *ObjectArray;
    OBJECT_EVENT_INFO StaticObjects[MANY_NOTIFICATION_OBJECTS];
    PUCHAR OutBuffer;
    UCHAR IsLoPriorityEvent, IsHighPriorityEvent, ReplacingIrp;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PWNODE_HEADER LastWnode;
    PLIST_ENTRY IrpListHead, ThreadListHead;
    ULONG MaxBufferSize, SizeUsed;
    PVOID UserProcessObject;
    HANDLE UserModeProcess;
    ULONG SizeLeft, SizeNeeded, HiTotalSizeNeeded, LoTotalSizeNeeded;
    PWNODE_TOO_SMALL WnodeTooSmall;
    ULONG j, ObjectCount;
    BOOLEAN DuplicateObject;
    PIMAGE_NT_HEADERS NtHeaders;
    SIZE_T StackSize, StackCommit;
#if defined(_WIN64)
    PVOID Wow64Process;
    PIMAGE_NT_HEADERS32 NtHeaders32;
#endif

    PAGED_CODE();
    
    MaxBufferSize = *OutBufferSize;
    
    HandleCount = ReceiveNotification->HandleCount;
    HandleArray = ReceiveNotification->Handles;

    //
    // Create space to store the object pointers so we can work with them
    //

    if (HandleCount > MANY_NOTIFICATION_OBJECTS)
    {
        ObjectArray = WmipAlloc(HandleCount * sizeof(OBJECT_EVENT_INFO));
        if (ObjectArray == NULL)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    } else {
        ObjectArray = StaticObjects;
    }        
#if DBG
    RtlZeroMemory(ObjectArray, HandleCount * sizeof(OBJECT_EVENT_INFO));
#endif
    
    //
    // First check that we all handles are entitled to receive notifications
    // and that the object is not already associated with an irp.
    // Also check if there are any hi or lo priority events
    //
    WmipEnterSMCritSection();

    IsLoPriorityEvent = 0;
    IsHighPriorityEvent = 0;
    ReplacingIrp = 0;
    HiTotalSizeNeeded = 0;
    LoTotalSizeNeeded = 0;
    ObjectCount = 0;
    for (i = 0; (i < HandleCount); i++)
    {
        Status = ObReferenceObjectByHandle(HandleArray[i].Handle,
                                       WMIGUID_NOTIFICATION,
                                       WmipGuidObjectType,
                                       UserMode,
                                       &GuidObject,
                                       NULL);
        if (! NT_SUCCESS(Status))
        {
            //
            // If one handle is bad then it spoils the whole request
            //
            //
            // Now try with Trace flags and if succeeds, 
            // We need to make sure the object is a trace request object. 
            //

            Status = ObReferenceObjectByHandle(HandleArray[i].Handle,
                               TRACELOG_REGISTER_GUIDS,
                               WmipGuidObjectType,
                               UserMode,
                               &GuidObject,
                               NULL);

            if (! NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            if (! (GuidObject->Flags & WMIGUID_FLAG_REQUEST_OBJECT) )
            {
                ObDereferenceObject(GuidObject);
                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }

        }

        //
        // Check that we do not have a duplicate object in the list
        //
        DuplicateObject = FALSE;
        for (j = 0; j < ObjectCount; j++)
        {
            if (GuidObject == ObjectArray[j].GuidObject)
            {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                                  "WMI: Duplicate object %p passed to WmiReceiveNotifciations\n",
                                GuidObject));
                ObDereferenceObject(GuidObject);
                DuplicateObject = TRUE;
                break;
            }
        }

        if (! DuplicateObject)
        {
            //
            // See if there was an irp attached to the guid object
            // already. We'll need to cancel it if all guid objects
            // are valid
            //
            if (GuidObject->Irp != NULL)
            {
                ReplacingIrp = 1;
            }


            //
            // We note if there are any lo and hi priority events
            //
            ObjectArray[ObjectCount++].GuidObject = GuidObject;        

            if (WmipHaveHiPriorityEvent(GuidObject))
            {
                IsHighPriorityEvent = 1;
            }

            if (WmipHaveLoPriorityEvent(GuidObject))
            {
                IsLoPriorityEvent = 1;
            }

            //
            // Clean up object in case it was part of a thread list
            //
            if (GuidObject->EventQueueAction == RECEIVE_ACTION_CREATE_THREAD)
            {
                WmipAssert(ReplacingIrp == 0);
                WmipClearObjectFromThreadList(GuidObject);
            }

            //
            // Calculate size needed to return data for this guid
            //
            HiTotalSizeNeeded += ((GuidObject->HiPriority.NextOffset + 7) & ~7);
            LoTotalSizeNeeded += ((GuidObject->LoPriority.NextOffset + 7) & ~7);
        }        
    }

    //
    // This is the total size needed to return all events
    //
    SizeNeeded = HiTotalSizeNeeded + LoTotalSizeNeeded;


    //
    // If any of the guid objects already had an irp attached then
    // we need to complete that irp with an error and move on
    //
    if (ReplacingIrp == 1)
    {
        for (i = 0; i < ObjectCount; i++)
        {
            GuidObject = ObjectArray[i].GuidObject;
            if (GuidObject->Irp != NULL)
            {
                WmipCompleteGuidIrpWithError(GuidObject);
            }
        }        
    }
    
    if ( (IsHighPriorityEvent | IsLoPriorityEvent) != 0 )
    {
        if (SizeNeeded <= MaxBufferSize)
        {
            //
            // There are events waiting to be recieved so pull them all 
            // out, high priority ones first then low priority ones.            // events will show up first.
            //
            OutBuffer = (PUCHAR)ReceiveNotification;
            LastWnode = NULL;
            SizeLeft = MaxBufferSize;
            SizeUsed = 0;

            if (IsHighPriorityEvent != 0)
            {
                WmipCopyFromEventQueues(ObjectArray,
                                        ObjectCount,
                                        OutBuffer,
                                        &SizeUsed,
                                        &LastWnode,
                                        TRUE);
                
                WmipAssert(SizeUsed <= SizeLeft);
                WmipAssert(SizeUsed = HiTotalSizeNeeded);
                
                OutBuffer += SizeUsed;
                SizeLeft -= SizeUsed;
            }

            if (IsLoPriorityEvent != 0)
            {
                WmipAssert(SizeLeft >= LoTotalSizeNeeded);
                
                WmipCopyFromEventQueues(ObjectArray,
                                        ObjectCount,
                                        OutBuffer,
                                        &SizeUsed,
                                        &LastWnode,
                                        FALSE);
                
                WmipAssert(SizeUsed <= SizeLeft);
                WmipAssert(SizeUsed == LoTotalSizeNeeded);
                
                SizeLeft -= SizeUsed;
            }

            //
            // We need to set the linkage field for the last wnode in
            // the list to 0 so it can mark the end of the list
            // correctly
            //
            if (LastWnode != NULL)
            {
                LastWnode->Linkage = 0;
            }
            
            //
            // Compute the number of bytes used to fill the output
            // buffer by subtracting the size left from the size passed
            // in
            //
            *OutBufferSize = MaxBufferSize - SizeLeft;
        } else {
            //
            // Not enough room to return all of the event data so we return
            // a WNODE_TOO_SMALL to indicate the size needed
            //
            WnodeTooSmall = (PWNODE_TOO_SMALL)ReceiveNotification;
            WnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
            WnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
            WnodeTooSmall->SizeNeeded = SizeNeeded;
            *OutBufferSize = sizeof(WNODE_TOO_SMALL);       
        }

    } else {
        //
        // There are no events waiting to be returned so we need to
        // create our wait structures, pend the irp and return pending
        //
        if (ReceiveNotification->Action == RECEIVE_ACTION_NONE)
        {
            IrpListHead = IRP_OBJECT_LIST_HEAD(Irp);
            InitializeListHead(IrpListHead);
            for (i = 0; i < ObjectCount; i++)
            {
                GuidObject = ObjectArray[i].GuidObject;
                GuidObject->Irp = Irp;
                GuidObject->EventQueueAction = RECEIVE_ACTION_NONE;
                InsertTailList(IrpListHead, &GuidObject->IrpObjectList);
            }

            IoSetCancelRoutine(Irp, WmipNotificationIrpCancel);
            if (Irp->Cancel && IoSetCancelRoutine(Irp, NULL))
            {
                Status = STATUS_CANCELLED;
            } else {
                IoMarkIrpPending(Irp);
                Status = STATUS_PENDING;
            }
        } else if (ReceiveNotification->Action == RECEIVE_ACTION_CREATE_THREAD) {
            //
            // Pump has called us to tell us that it is shutting down so we
            // need to establish a list linking the guid objects and
            // stashing away the callback address
            //

#if defined(_WIN64)
            
            //
            // For native Win64 processes, ensure that the thread start 
            // address is aligned properly
            //

            Wow64Process = _PsGetCurrentProcess()->Wow64Process;

            if ((Wow64Process == NULL) &&
                (((ULONG_PTR)ReceiveNotification->UserModeCallback.Handle64 & 0x7) != 0))
            {
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }
#endif

            //
            // Make sure that the process handle we get is valid and has
            // enough permissions to create the thread
            //
            Status = ObReferenceObjectByHandle(ReceiveNotification->UserModeProcess.Handle,
                                              PROCESS_CREATE_THREAD |
                                              PROCESS_QUERY_INFORMATION |
                                              PROCESS_VM_OPERATION |
                                              PROCESS_VM_WRITE |
                                              PROCESS_VM_READ ,
                                              NULL,
                                              UserMode,
                                              &UserProcessObject,
                                              NULL);


            if (NT_SUCCESS(Status))
            {
                //
                // Create a handle for the process that lives in the system
                // handle table so that it will be available in any thread
                // context. Note that one handle is created for each thread
                // object list and the handle is closed when the last
                // object is removed from the list
                // 
                Status = ObOpenObjectByPointer(UserProcessObject,
                                               OBJ_KERNEL_HANDLE,
                                               NULL,
                                               THREAD_ALL_ACCESS,
                                               NULL,
                                               KernelMode,
                                               &UserModeProcess);

                if (NT_SUCCESS(Status))
                {
                    //
                    // Get the default stack size and commit for this
                    // process and store it away in the guid object so
                    // that the pump threads created from kernel will
                    // have appropriatly sized stacks
                    //
                    
                    try {
                    
                        NtHeaders = RtlImageNtHeader(_PsGetCurrentProcess()->SectionBaseAddress);
                        if (NtHeaders != NULL)
                        {
#if defined(_WIN64)
                            if (Wow64Process != NULL) {
                                
                                NtHeaders32 = (PIMAGE_NT_HEADERS32) NtHeaders;
                                StackSize = NtHeaders32->OptionalHeader.SizeOfStackReserve;
                                StackCommit = NtHeaders32->OptionalHeader.SizeOfStackCommit;
                            } else {
#endif
                               StackSize = NtHeaders->OptionalHeader.SizeOfStackReserve;
                               StackCommit = NtHeaders->OptionalHeader.SizeOfStackCommit;
#if defined(_WIN64)
                            }
#endif
                        } else {
                            StackSize = 0;
                            StackCommit = 0;
                        }
                    } except (EXCEPTION_EXECUTE_HANDLER) {                          
                        StackSize = 0;
                        StackCommit = 0;
                    }
                    
                    GuidObject = ObjectArray[0].GuidObject;
                    GuidObject->UserModeCallback = (PUSER_THREAD_START_ROUTINE)(ULONG_PTR)ReceiveNotification->UserModeCallback.Handle;
                    GuidObject->EventQueueAction = RECEIVE_ACTION_CREATE_THREAD;
                    GuidObject->UserModeProcess = UserModeProcess;
                    GuidObject->StackSize = StackSize;
                    GuidObject->StackCommit = StackCommit;

                    ThreadListHead = &GuidObject->ThreadObjectList;
                    InitializeListHead(ThreadListHead);

                    for (i = 1; i < ObjectCount; i++)
                    {
                        GuidObject = ObjectArray[i].GuidObject;
                        GuidObject->UserModeCallback = (PUSER_THREAD_START_ROUTINE)(ULONG_PTR)ReceiveNotification->UserModeCallback.Handle;
                        GuidObject->EventQueueAction = RECEIVE_ACTION_CREATE_THREAD;
                        GuidObject->UserModeProcess = UserModeProcess;
                        GuidObject->StackSize = StackSize;
                        GuidObject->StackCommit = StackCommit;
                        InsertTailList(ThreadListHead, &GuidObject->ThreadObjectList);
                    }

                }

                ObDereferenceObject(UserProcessObject);
            }
            
            *OutBufferSize = 0;
        }
    }

Cleanup:
    //
    // Remove any object references that we took and free memory for
    // the object array
    //
    WmipLeaveSMCritSection();

    for (i = 0; i < ObjectCount; i++)
    {
        ObDereferenceObject(ObjectArray[i].GuidObject);
    }

    if (ObjectArray != StaticObjects)
    {
        WmipFree(ObjectArray);
    }
    

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                      "WMI: RCV Notification call -> 0x%x\n", Status));
    
    return(Status);    
}


NTSTATUS
WmipCsrClientMessageServer(
    IN PVOID CsrPort,                       
    IN OUT PCSR_API_MSG m,
    IN CSR_API_NUMBER ApiNumber,
    IN ULONG ArgLength
    )

/*++

Routine Description:

    This function sends an API datagram to the Windows Emulation Subsystem
    Server. 

Arguments:

    CsrPort - pointer to LPC port object that is connected to CSR on
              behalf of this process

    m - Pointer to the API request message to send.

    ApiNumber - Small integer that is the number of the API being called.

    ArgLength - Length, in bytes, of the argument portion located at the
        end of the request message.  Used to calculate the length of the
        request message.

Return Value:

    Status Code from either client or server

--*/

{
    NTSTATUS Status;

    //
    // Initialize the header of the message.
    //

    if ((LONG)ArgLength < 0)
    {
        ArgLength = (ULONG)(-(LONG)ArgLength);
        m->h.u2.s2.Type = 0;
    } else {
        m->h.u2.ZeroInit = 0;
    }

    ArgLength |= (ArgLength << 16);
    ArgLength +=     ((sizeof( CSR_API_MSG ) - sizeof( m->u )) << 16) |
                     (FIELD_OFFSET( CSR_API_MSG, u ) - sizeof( m->h ));
    m->h.u1.Length = ArgLength;
    m->CaptureBuffer = NULL;
    m->ApiNumber = ApiNumber;

    Status = LpcRequestPort( CsrPort,
                            (PPORT_MESSAGE)m);
    
    //
    // Check for failed status and do something.
    //
    if (! NT_SUCCESS( Status ))
    {       
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                          "WMI: %p.%p LpcRequestPort failed %x\n",
                          NtCurrentTeb()->ClientId.UniqueProcess,
                          NtCurrentTeb()->ClientId.UniqueThread,
                          Status));
        WmipAssert(FALSE);

        m->ReturnValue = Status;
    }

    //
    // The value of this function is whatever the server function returned.
    //

    return( m->ReturnValue );
}


VOID WmipPumpThreadApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )
/*++

Routine Description:

    Kernel mode APC that will register the current thread with CSR

Arguments:


Return Value:


--*/
{
    BASE_API_MSG m;
    PBASE_CREATETHREAD_MSG a = &m.u.CreateThread;
    PEPROCESS Process;

    UNREFERENCED_PARAMETER (NormalRoutine);
    UNREFERENCED_PARAMETER (NormalContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // Free memory used by APC
    //
    ExFreePool(Apc);
    
    //
    // Get the ExceptionPort from the process object. In a Win32
    // process this port is set by CSR to allow it to be notified when
    // an exception occurs. This code will also use it to register this
    // thread with CSR. Note that if the exception port is NULL then
    // the process is not a Win32 process and it doesn't matter if the
    // thread doesn't get registered.
    //
    Process = PsGetCurrentProcess();
    if (Process->ExceptionPort != NULL)
    {
        a->ThreadHandle = NULL;
        a->ClientId = NtCurrentTeb()->ClientId;

        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,
                          "WMI: Sending message To CSR for %p.%p\n",
                          NtCurrentTeb()->ClientId.UniqueProcess,
                          NtCurrentTeb()->ClientId.UniqueThread));
        WmipCsrClientMessageServer( Process->ExceptionPort,
                               (PCSR_API_MSG)&m,
                             CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                  BasepRegisterThread
                                                ),
                             sizeof( *a )
                           );
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                          "WMI: %p.%p Process %p has no exception port\n",
                          NtCurrentTeb()->ClientId.UniqueProcess,
                          NtCurrentTeb()->ClientId.UniqueThread,
                          Process));
        WmipAssert(FALSE);
    }
}

NTSTATUS WmipCreatePumpThread(
    PWMIGUIDOBJECT Object
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE ThreadHandle;
    PKAPC Apc;
    PKTHREAD ThreadObj;
    
    PAGED_CODE();

    //
    // First off we need to create the pump thread suspended so we'll
    // have a chance to queue a kernel apc before the thread starts
    // running
    //
    WmipEnterSMCritSection();
    if (Object->UserModeProcess != NULL)
    {
        Status = RtlCreateUserThread(Object->UserModeProcess,
                                     NULL,
                                     TRUE,
                                     0,
                                     Object->StackSize,
                                     Object->StackCommit,
                                     Object->UserModeCallback,
                                     (PVOID)0x1f1f1f1f,
                                     &ThreadHandle,
                                     NULL);

        if (NT_SUCCESS(Status))
        {

            //
            // Queue a kernel mode apc that will call into CSR to register
            // this newly created thread. Note that if the APC cannot be
            // run it is not fatal as we can allow the thread to run
            // without being registered with CSR. The APC is freed at the
            // end of the APC routine
            //

            Status = ObReferenceObjectByHandle(ThreadHandle,
                                               0,
                                               NULL,
                                               KernelMode,
                                               &ThreadObj,
                                               NULL);

            if (NT_SUCCESS(Status))
            {
                Apc = WmipAllocNP(sizeof(KAPC));
                if (Apc != NULL)
                {
                    KeInitializeApc(Apc,
                                    ThreadObj,
                                    OriginalApcEnvironment,
                                    WmipPumpThreadApc,
                                    NULL,
                                    NULL,
                                    KernelMode,
                                    NULL);

                    if (! KeInsertQueueApc(Apc,
                                           NULL,
                                           NULL,
                                           0))
                    {
                        ExFreePool(Apc);
                        WmipAssert(FALSE);
                    } 
                }
                ObDereferenceObject(ThreadObj);
            } else {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                                  "WMI: ObRef(ThreadObj) failed %x\n",
                                  Status));
                WmipAssert(FALSE);

                //
                // Status is still successful since the pump thread was
                // created, just not registered with CSR
                //
                Status = STATUS_SUCCESS;
            }

            //
            // If we successfully created the pump thread then mark all of
            // the related objects as not needing any thread creation
            // anymore
            //
            WmipClearThreadObjectList(Object);

            WmipLeaveSMCritSection();

            ZwResumeThread(ThreadHandle,
                          NULL);
            ZwClose(ThreadHandle);
        } else {
            WmipLeaveSMCritSection();
        }
    } else {
        WmipLeaveSMCritSection();
    }
    
    return(Status); 
}

void WmipCreatePumpThreadRoutine(
    PVOID Context
    )
/*+++

Routine Description:

    This routine is a worker routine that will create a user mode pump
    thread so that events can be delivered. 
        
Arguments:

    Context is a pointer to a CREATETHREADWORKITEM struct. It is freed
        in this routine

Return Value:


---*/
{
    PCREATETHREADWORKITEM WorkItem = (PCREATETHREADWORKITEM)Context;
    NTSTATUS Status;

    PAGED_CODE();

    if (ObReferenceObjectSafe(WorkItem->Object))
    {
        //
        // Only continue if the object is not being deleted
        //
        Status = WmipCreatePumpThread(WorkItem->Object);
        if (! NT_SUCCESS(Status))
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                              "WMI: Delayed pump thread creation failed %x\n",
                             Status));
        }
        
        ObDereferenceObject(WorkItem->Object);
    }

    //
    // Release reference to object taken when work item was queued
    //
    ObDereferenceObject(WorkItem->Object);
    ExFreePool(WorkItem);
}


#define WmipQueueEventToObject(Object, Wnode, IsHighPriority) \
    WmipQueueNotification(Object, IsHighPriority ? &Object->HiPriority : \
                                         &Object->LoPriority, \
                          Wnode);

NTSTATUS WmipQueueNotification(
    PWMIGUIDOBJECT Object,
    PWMIEVENTQUEUE EventQueue,
    PWNODE_HEADER Wnode
    )
{
    //
    // This routine assumes that the SMCritSection is held
    //
    PUCHAR Buffer;
    ULONG InWnodeSize;
    ULONG NextOffset;
    PUCHAR DestPtr;
    PWNODE_HEADER LastWnode;
    NTSTATUS Status;
    ULONG SizeNeeded;
    PCREATETHREADWORKITEM WorkItem;
        
    PAGED_CODE();
    
    //
    // If there is not a buffer allocated to store the event then
    // allocate one
    //
    if (EventQueue->Buffer == NULL)
    {
        //
        // If we get an event that is larger than the default max
        // buffer size then we bump the buffer size up to 64K, unless
        // it is larger than 64K where we bump up to the actual size of
        // the event.
        //
        SizeNeeded = (Wnode->BufferSize + 7) & ~7;

        if (SizeNeeded > EventQueue->MaxBufferSize) {
            EventQueue->MaxBufferSize = (SizeNeeded >= 65536) ? SizeNeeded : 65536;
        }
        
        Buffer = WmipAlloc(EventQueue->MaxBufferSize);
        if (Buffer != NULL)
        {
            EventQueue->Buffer = Buffer;
            EventQueue->NextOffset = 0;
            EventQueue->LastWnode = NULL;
        } else {
            EventQueue->EventsLost++;
            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                              DPFLTR_EVENT_INFO_LEVEL,
                              "WMI: Event 0x%x lost for object %p since could not alloc\n",
                              EventQueue->EventsLost, Object));
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    } else {
        Buffer = EventQueue->Buffer;
    }
    
    //
    // See if there is room to queue the WNODE
    //
    InWnodeSize = Wnode->BufferSize;
    NextOffset = ((EventQueue->NextOffset + InWnodeSize) + 7) &~7;
    if (NextOffset <= EventQueue->MaxBufferSize)
    {
        //
        // Link the previous wnode to this one, copy in the new wnode
        // and update the pointer to next free space
        //
        DestPtr = Buffer + EventQueue->NextOffset;
        LastWnode = EventQueue->LastWnode;
        if (LastWnode != NULL)
        {
            LastWnode->Linkage = (ULONG) ((PCHAR)DestPtr - (PCHAR)LastWnode);
        }
        
        EventQueue->LastWnode = (PWNODE_HEADER)DestPtr;
        EventQueue->NextOffset = NextOffset;
        memcpy(DestPtr, Wnode, InWnodeSize);
        
        //
        // Guid object gets signalled when event is placed into queue
        //
        KeSetEvent(&Object->Event, 0, FALSE);

        //
        // If consumer requested that we autostart a thread then we do
        // that now
        //
        if (Object->EventQueueAction == RECEIVE_ACTION_CREATE_THREAD)
        {
            if (KeIsAttachedProcess())
            {
                //
                // If the current thread is attached to a process then
                // it is not safe to create a thread. So we queue a
                // work item and let the work item create it
                //
                WorkItem = ExAllocatePoolWithTag(NonPagedPool,
                                                sizeof(CREATETHREADWORKITEM),
                                                WMIPCREATETHREADTAG);
                if (WorkItem != NULL)
                {
                    //
                    // Take reference on object. Reference released in
                    // worker routine
                    //
                    Status = ObReferenceObjectByPointer(Object,
                                               0,
                                               NULL,
                                               KernelMode);

                    if (NT_SUCCESS(Status))
                    {
                        WorkItem->Object = Object;
                        ExInitializeWorkItem(&WorkItem->WorkItem,
                                             WmipCreatePumpThreadRoutine,
                                             WorkItem);
                        ExQueueWorkItem(&WorkItem->WorkItem,
                                        DelayedWorkQueue);

                    } else {
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                          DPFLTR_ERROR_LEVEL,
                                          "WMI: Ref on object %p failed %x for queuing notification work item\n",
                                         Object,
                                         Status));
                        ExFreePool(WorkItem);
                    }                   
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                Status = WmipCreatePumpThread(Object);
            }
            
            if (! NT_SUCCESS(Status))
            {
                EventQueue->EventsLost++;
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                      DPFLTR_EVENT_INFO_LEVEL,
                                      "WMI: Event 0x%x lost for object %p since Thread create Failed\n",
                                      EventQueue->EventsLost, Object));
            }
        } else {
            Status = STATUS_SUCCESS;
        }
    } else {
        //
        // Not enough space, throw away the event
        //

        EventQueue->EventsLost++;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                              DPFLTR_EVENT_INFO_LEVEL,
                              "WMI: Event 0x%x lost for object %p since too large 0x%x\n",
                              EventQueue->EventsLost, Object, Wnode->BufferSize));
        Status = STATUS_BUFFER_TOO_SMALL;
    }
    return(Status);
}

PWNODE_HEADER WmipDereferenceEvent(
    PWNODE_HEADER Wnode
    )
{
    ULONG WnodeTargetSize;
    ULONG IsStaticInstanceNames;
    ULONG InstanceNameLen, InstanceNameLen2;
    PWNODE_SINGLE_INSTANCE WnodeTarget;
    PWCHAR Ptr;
    PWNODE_EVENT_REFERENCE WnodeRef = (PWNODE_EVENT_REFERENCE)Wnode;
    PBDATASOURCE DataSource;
    NTSTATUS Status;
    ULONG Retries;

    PAGED_CODE();
    
    //
    // Determine if the data source is valid or not
    //
    DataSource = WmipFindDSByProviderId(WnodeRef->WnodeHeader.ProviderId);
    if (DataSource == NULL)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                          "WMI: Invalid Data Source in referenced guid \n"));
        return(NULL);
    }
    
    //
    // Compute the size of any dynamic name that must go into the TargetWnode
    //
    IsStaticInstanceNames = WnodeRef->WnodeHeader.Flags & 
                             WNODE_FLAG_STATIC_INSTANCE_NAMES;
    if (IsStaticInstanceNames == 0)
    {
        InstanceNameLen = *WnodeRef->TargetInstanceName + sizeof(USHORT);
    } else {
        InstanceNameLen = 0;
    }
    
    WnodeTargetSize = WnodeRef->TargetDataBlockSize + 
                          FIELD_OFFSET(WNODE_SINGLE_INSTANCE, 
                                       VariableData) +
                          InstanceNameLen + 
                          8;

    Retries = 0;
    do
    {
        WnodeTarget = WmipAllocNP(WnodeTargetSize);
    
        if (WnodeTarget != NULL)
        {
            //
            // Build WNODE_SINGLE_INSTANCE that we use to query for event data
            //
            memset(WnodeTarget, 0, WnodeTargetSize);

            WnodeTarget->WnodeHeader.BufferSize = WnodeTargetSize;
            WnodeTarget->WnodeHeader.ProviderId = WnodeRef->WnodeHeader.ProviderId;
            memcpy(&WnodeTarget->WnodeHeader.Guid, 
                   &WnodeRef->TargetGuid,
                   sizeof(GUID));
            WnodeTarget->WnodeHeader.Version = WnodeRef->WnodeHeader.Version;
            WnodeTarget->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE |
                                           IsStaticInstanceNames;
                                       
            if (IsStaticInstanceNames != 0)
            {
                WnodeTarget->InstanceIndex = WnodeRef->TargetInstanceIndex;
                WnodeTarget->DataBlockOffset = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                        VariableData);
            } else {            
                WnodeTarget->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                           VariableData);
                Ptr = (PWCHAR)OffsetToPtr(WnodeTarget, WnodeTarget->OffsetInstanceName);
                InstanceNameLen2 = InstanceNameLen - sizeof(USHORT);
                *Ptr++ = (USHORT)InstanceNameLen2;
                memcpy(Ptr, 
                       &WnodeRef->TargetInstanceName[1], 
                       InstanceNameLen2);
                //
                // Round data block offset to 8 byte alignment
                //
                WnodeTarget->DataBlockOffset = ((FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                          VariableData) + 
                                            InstanceNameLen2 + 
                                            sizeof(USHORT)+7) & 0xfffffff8);
            }
            Status = WmipDeliverWnodeToDS(IRP_MN_QUERY_SINGLE_INSTANCE,
                                          DataSource,
                                          (PWNODE_HEADER)WnodeTarget,
                                          WnodeTargetSize);
                                      
            if (NT_SUCCESS(Status) &&
                (WnodeTarget->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL))
            {
                WnodeTargetSize = ((PWNODE_TOO_SMALL)WnodeTarget)->SizeNeeded;
                WmipFree(WnodeTarget);
                Retries++;
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } while ((Status == STATUS_BUFFER_TOO_SMALL) && (Retries < 2));
    
    WmipUnreferenceDS(DataSource);
    
    if (! NT_SUCCESS(Status))
    {
        WmipReportEventLog(EVENT_WMI_CANT_GET_EVENT_DATA,

                           EVENTLOG_WARNING_TYPE,
                            0,
                           Wnode->BufferSize,
                           Wnode,
                           0,
                           NULL);
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                          "WMI: Query to dereference WNODE failed %d\n",
                Status));
        if (WnodeTarget != NULL)
        {
            WmipFree(WnodeTarget);
            WnodeTarget = NULL;
        }
    } else {
        WnodeTarget->WnodeHeader.Flags |= (WnodeRef->WnodeHeader.Flags & 
                                              WNODE_FLAG_SEVERITY_MASK) |
                                             WNODE_FLAG_EVENT_ITEM;
    }
    return((PWNODE_HEADER)WnodeTarget);
}


PWNODE_HEADER WmipIncludeStaticNames(
    PWNODE_HEADER Wnode
    )
{
    PWNODE_HEADER ReturnWnode = Wnode;
    PWNODE_HEADER WnodeFull;
    PWNODE_ALL_DATA WnodeAllData;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    PWCHAR InstanceName = NULL;
    SIZE_T InstanceNameLen = 0;
    ULONG InstanceIndex;
    LPGUID EventGuid = &Wnode->Guid;
    SIZE_T WnodeFullSize;
    PWCHAR TargetInstanceName;
    WCHAR Index[MAXBASENAMESUFFIXSIZE+1];
    ULONG TargetProviderId;
    BOOLEAN IsError;
    PBINSTANCESET TargetInstanceSet;
    PBGUIDENTRY GuidEntry;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;

    PAGED_CODE();
    
    IsError = TRUE;
    TargetInstanceSet = NULL;
    GuidEntry = WmipFindGEByGuid(EventGuid, FALSE);
    
    if (GuidEntry != NULL)
    {
        //
        // Loop over all instance sets to find the one that corresponds
        // to our provider id
        //
        TargetProviderId = Wnode->ProviderId;
    
        WmipEnterSMCritSection();
        InstanceSetList = GuidEntry->ISHead.Flink;
        while (InstanceSetList != &GuidEntry->ISHead)
        {
            InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
                                        
            if (InstanceSet->ProviderId == TargetProviderId)
            {
                //
                // We found the instance set corrsponding to the provider id
                //
                TargetInstanceSet = InstanceSet;
                WmipReferenceIS(TargetInstanceSet);
                break;
            }
            InstanceSetList = InstanceSetList->Flink;
        }        
        WmipLeaveSMCritSection();
            
        //
        // Remove ref on the guid entry as we have refed the TargetInstanceSet
        //
        WmipUnreferenceGE(GuidEntry);
    }
        
    if (TargetInstanceSet != NULL)
    {
        if ((TargetInstanceSet->Flags &
            (IS_INSTANCE_BASENAME | IS_INSTANCE_STATICNAMES)) != 0)
        {

            if (Wnode->Flags & WNODE_FLAG_ALL_DATA) 
            {
                //
                // Fill instance names in WNODE_ALL_DATA. Allocate a
                // new buffer to hold all of the original wnode plus
                // the instance names. We need to add space for padding
                // the wnode to 4 bytes plus space for the array of
                // offsets to instance names plus space for the instanc
                // names
                //
                WnodeFullSize = ((Wnode->BufferSize+3) & ~3) +
                        (TargetInstanceSet->Count * sizeof(ULONG)) +
                              WmipStaticInstanceNameSize(TargetInstanceSet);
                WnodeFull = WmipAlloc(WnodeFullSize);
                if (WnodeFull != NULL)
                {
                    memcpy(WnodeFull, Wnode, Wnode->BufferSize);
                    WnodeAllData = (PWNODE_ALL_DATA)WnodeFull;
                    WmipInsertStaticNames(WnodeAllData,
                                          (ULONG)WnodeFullSize,
                                          TargetInstanceSet);
                    ReturnWnode = WnodeFull;
                    IsError = FALSE;
                }

            } else if ((Wnode->Flags & WNODE_FLAG_SINGLE_INSTANCE) ||
                       (Wnode->Flags & WNODE_FLAG_SINGLE_ITEM)) {
                //
                // Fill instance names in WNODE_SINGLE_INSTANCE or
                // _ITEM. 
                //
                WnodeFull = Wnode;

                WnodeSI = (PWNODE_SINGLE_INSTANCE)Wnode;
                InstanceIndex = WnodeSI->InstanceIndex;
                if (InstanceIndex < TargetInstanceSet->Count)
                {
                    if (TargetInstanceSet->Flags & IS_INSTANCE_STATICNAMES)
                    {
                        InstanceName = TargetInstanceSet->IsStaticNames->StaticNamePtr[InstanceIndex];
                        InstanceNameLen = (wcslen(InstanceName) + 2) * 
                                                               sizeof(WCHAR);
                    } else if (TargetInstanceSet->Flags & IS_INSTANCE_BASENAME) {
                         InstanceName = TargetInstanceSet->IsBaseName->BaseName;
                         InstanceNameLen = (wcslen(InstanceName) + 2 + 
                                       MAXBASENAMESUFFIXSIZE) * sizeof(WCHAR);
                    }
 
                    //
                    // Allocate a new Wnode and fill in the instance
                    // name. Include space for padding the wnode to a 2
                    // byte boundry and space for the instance name
                    //
                    WnodeFullSize = ((Wnode->BufferSize+1) & ~1) +
                                    InstanceNameLen;
                    
                    WnodeFull = WmipAlloc(WnodeFullSize);
                    
                    if (WnodeFull != NULL)
                    {
                        memcpy(WnodeFull, Wnode, Wnode->BufferSize);
                        WnodeFull->BufferSize = (ULONG)WnodeFullSize;
                        WnodeSI = (PWNODE_SINGLE_INSTANCE)WnodeFull;
                        WnodeSI->OffsetInstanceName = (Wnode->BufferSize+1)& ~1;
                        TargetInstanceName = (PWCHAR)((PUCHAR)WnodeSI + WnodeSI->OffsetInstanceName);
                        if (TargetInstanceSet->Flags & IS_INSTANCE_STATICNAMES)
                        {
                            InstanceNameLen -= sizeof(WCHAR);
                            *TargetInstanceName++ = (USHORT)InstanceNameLen;
                            StringCbCopy(TargetInstanceName,
                                         InstanceNameLen,
                                         InstanceName);
                        } else {
                            if (TargetInstanceSet->Flags & IS_PDO_INSTANCENAME)
                            {
                                WnodeFull->Flags |= WNODE_FLAG_PDO_INSTANCE_NAMES;
                            }
                            StringCbPrintf(Index,
                                           sizeof(Index),
                                           BASENAMEFORMATSTRING,
                                           TargetInstanceSet->IsBaseName->BaseIndex + 
                                                               InstanceIndex);
                            StringCbCopy(TargetInstanceName+1,
                                         InstanceNameLen,
                                         InstanceName);
                            
                            StringCbCat(TargetInstanceName+1,
                                        InstanceNameLen,
                                        Index);
                            InstanceNameLen = wcslen(TargetInstanceName+1);
                            *TargetInstanceName = ((USHORT)InstanceNameLen+1) * sizeof(WCHAR);
                        }
                        IsError = FALSE;
                        ReturnWnode = WnodeFull;
                    }
                }
            }
        }
    }
        
    if (IsError)
    {
        //
        // If we had an error resolving the instance name then report it
        // and remove the instance name from the event.
        //
        WmipReportEventLog(EVENT_WMI_CANT_RESOLVE_INSTANCE,
                           EVENTLOG_WARNING_TYPE,
                            0,
                           Wnode->BufferSize,
                           Wnode,
                           0,
                           NULL);
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_WARNING_LEVEL,
                          "WMI: Static instance name in event, but error processing\n"));
        if (Wnode->Flags & WNODE_FLAG_ALL_DATA)
        {
            WnodeAllData = (PWNODE_ALL_DATA)Wnode;
            WnodeAllData->OffsetInstanceNameOffsets = 0;
        } else if ((Wnode->Flags & WNODE_FLAG_SINGLE_INSTANCE) ||
                   (Wnode->Flags & WNODE_FLAG_SINGLE_ITEM))
        {
            WnodeSI = (PWNODE_SINGLE_INSTANCE)Wnode;
            WnodeSI->OffsetInstanceName = 0;
        }
    }

    if (TargetInstanceSet != NULL)
    {
        WmipUnreferenceIS(TargetInstanceSet);
    }
    
    return(ReturnWnode);
}

NTSTATUS WmipWriteWnodeToObject(
    PWMIGUIDOBJECT Object,
    PWNODE_HEADER Wnode,
    BOOLEAN IsHighPriority
)
/*+++

Routine Description:

    This routine will write a WNODE into the queue of events to be returned
    for a guid object. If there is an irp already waiting then it will be
    satisfied with the event otherwise it will be queued in the objects
    buffer. 
        
    This routine assumes that the SM Critical section is held
        
Arguments:

    Object is the object to which to send the request

    Wnode is the Wnode with the event
        
    IsHighPriority is TRUE if the event should go into the high priority
        queue

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    PIRP Irp;
    ULONG WnodeSize;
    PUCHAR OutBuffer;
    ULONG OutBufferSize;
    PIO_STACK_LOCATION IrpStack;
    PWNODE_TOO_SMALL WnodeTooSmall;    
    NTSTATUS Status;
    
    PAGED_CODE();
    
    //
    // Someone has registered to recieve this event so
    // see if there is an irp waiting to be completed or
    // if we should just queue it
    //
    Irp = Object->Irp;
    if ((Irp != NULL) &&
        (IoSetCancelRoutine(Irp, NULL)))
    {
        //
        // There is an irp waiting for this event, copy out the
        // event and complete the irp
        //
        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        OutBuffer = Irp->AssociatedIrp.SystemBuffer;
        OutBufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
        WnodeSize = Wnode->BufferSize;
        if (WnodeSize > OutBufferSize)
        {
            //
            // There is not enough room to return the event so
            // we return a WNODE_TOO_SMALL with the size needed
            // and then go and queue the event
            //
            WmipAssert(OutBufferSize >= sizeof(WNODE_TOO_SMALL));
            WnodeTooSmall = (PWNODE_TOO_SMALL)OutBuffer;
            WnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
            WnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
            WnodeTooSmall->SizeNeeded = WnodeSize;
            WnodeSize = sizeof(WNODE_TOO_SMALL);
            Status = WmipQueueEventToObject(Object,
                                   Wnode,
                                   IsHighPriority);
        } else {
            //
            // Plenty of room, copy the event into the irp
            // buffer and complete the irp
            //
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                              "WMI: Returning event to waiting irp for object %p\n", Object));
            RtlCopyMemory(OutBuffer, Wnode, WnodeSize);
            Status = STATUS_SUCCESS;
        }
        
        //
        // Remove link from all objects associated with the irp
        // since now the irp is going away.
        //
        WmipClearIrpObjectList(Irp);
        Irp->IoStatus.Information = WnodeSize;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    } else {
        //
        // There is no irp waiting to receive the event so we
        // need to queue it if we can
        //
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                          "WMI: Queued event to object %p\n", Object));
        Status = WmipQueueEventToObject(Object,
                                   Wnode,
                                   IsHighPriority);
    }
    
    return(Status);
}


NTSTATUS WmipProcessEvent(
    PWNODE_HEADER InWnode,
    BOOLEAN IsHighPriority,
    BOOLEAN FreeBuffer
    )
{
    LPGUID Guid;
    NTSTATUS Status, ReturnStatus;
    PBGUIDENTRY GuidEntry;
    PLIST_ENTRY ObjectList, ObjectListNext;
    PWMIGUIDOBJECT Object;
    LPGUID EventGuid = &InWnode->Guid;
    PWNODE_HEADER Wnode, WnodeTarget;    
    
    PAGED_CODE();
    
    //
    // If the event references a guid that needs to be queried then
    // go do the dereferencing here.
    //
    if (InWnode->Flags & WNODE_FLAG_EVENT_REFERENCE)
    {
        WnodeTarget = WmipDereferenceEvent(InWnode);
        if (WnodeTarget == NULL)
        {
            // TODO: Eventlog
            if (FreeBuffer)
            {
                ExFreePool(InWnode);
            }
            return(STATUS_UNSUCCESSFUL);
        }
        Wnode = WnodeTarget;
    } else {
        Wnode = InWnode;
        WnodeTarget = NULL;
    }

    //
    // Be sure to use the guid of the referenced event, not the event that
    // was originally fired.
    EventGuid = &Wnode->Guid;


    //
    // If it is Trace error notification, disable providers
    //
#ifndef MEMPHIS
    if (IsEqualGUID(EventGuid, & TraceErrorGuid)) {
        PWMI_TRACE_EVENT WmiEvent = (PWMI_TRACE_EVENT) InWnode;
        ULONG LoggerId = WmiGetLoggerId(InWnode->HistoricalContext);
        if ( InWnode->BufferSize >= sizeof(WMI_TRACE_EVENT) ) {
            //
            // Logger thread terminating will result in DisableTrace
            // through StopTrace. No need to call twice. 
            //
            if (WmiEvent->TraceErrorFlag == STATUS_SEVERITY_ERROR) {
                WmipDisableTraceProviders(LoggerId);
            }
        }
    }
#endif

    //
    // See if this event has a static name and if so fill it in
    if (Wnode->Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES)
    {
        Wnode = WmipIncludeStaticNames(Wnode);
    }
        
    //
    // See if any data provider has registered this event
    //
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_EVENT_INFO_LEVEL,
                      "WMI: Received event\n"));
    Guid = &Wnode->Guid;    
    GuidEntry = WmipFindGEByGuid(Guid, TRUE);
    if (GuidEntry != NULL)
    {
        //
        // Yup, so check if there are any open objects to the guid and
        // if anyone is interested in receiving events from them
        //
        ReturnStatus = STATUS_SUCCESS;
        WmipEnterSMCritSection();
        ObjectList = GuidEntry->ObjectHead.Flink;
        while (ObjectList != &GuidEntry->ObjectHead)
        {
            Object = CONTAINING_RECORD(ObjectList,
                                       WMIGUIDOBJECT,
                                       GEObjectList);

            //
            // ObRefSafe so that we can be sure that the object is not
            // in the process of being deleted. If this function
            // returns FALSE then the object is being deleted and so we
            // don't want to use it. If TRUE then it is safe to use the
            // object
            //
            ObjectListNext = ObjectList->Flink;
            if (ObReferenceObjectSafe(Object))
            {
                //
                // Make sure the object has not been marked as one that
                // should not receive any events since it is
                // transitioning to a closed state
                //
                if ((Object->Flags & WMIGUID_FLAG_RECEIVE_NO_EVENTS) == 0)
                {
                    if (Object->Flags & WMIGUID_FLAG_KERNEL_NOTIFICATION)
                    {
                        //
                        // KM clients get a direct callback
                        //
                        WMI_NOTIFICATION_CALLBACK Callback;
                        PVOID Context;

                        Callback = Object->Callback;
                        Context = Object->CallbackContext;
                        if (Callback != NULL)
                        {
                            (*Callback)(Wnode, Context);
                        }
                    } else {
                        //
                        // UM clients get event written into IRP or queued up
                        //
                        Status = WmipWriteWnodeToObject(Object,
                                                        Wnode,
                                                        IsHighPriority);

                        if (! NT_SUCCESS(Status))
                        {
                            //
                            // If any attempts to queue the event fail then we return
                            // an error
                            //
                            ReturnStatus = STATUS_UNSUCCESSFUL;
                        }
                    }
                }
                
                ObDereferenceObject(Object);
                //
                // Note that we cannot touch the object anymore
                //
            }
    
            ObjectList = ObjectListNext;
        }
        
        WmipLeaveSMCritSection();
        WmipUnreferenceGE(GuidEntry);
    } else {
        ReturnStatus = STATUS_WMI_GUID_NOT_FOUND;
    }
    
    if (FreeBuffer)
    {
        //
        // Free buffer passed by driver containing event
        //
        ExFreePool(InWnode);
    }

    if ((Wnode != InWnode) && (Wnode != WnodeTarget))
    {
        //
        // If we inserted static names then free it
        //
        WmipFree(Wnode);
    }

    if (WnodeTarget != NULL)
    {
        //
        // if we dereferenced then free it
        //
        WmipFree(WnodeTarget);
    }
    
    return(ReturnStatus);
}

NTSTATUS WmipUMProviderCallback(
    IN WMIACTIONCODE ActionCode,
    IN PVOID DataPath,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer
)
{
    PAGED_CODE();
    
    UNREFERENCED_PARAMETER (ActionCode);
    UNREFERENCED_PARAMETER (DataPath);
    UNREFERENCED_PARAMETER (BufferSize);
    UNREFERENCED_PARAMETER (Buffer);

    ASSERT(FALSE);
    return(STATUS_UNSUCCESSFUL);
}

NTSTATUS WmipRegisterUMGuids(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Cookie,
    IN PWMIREGINFO RegInfo,
    IN ULONG RegInfoSize,
    OUT HANDLE *RequestHandle,
    OUT ULONG64 *LoggerContext
    )
/*+++

Routine Description:

    This routine will register a set of user mode guids with WMI for use
    by tracelog. The following steps will occur:
        
        * A request object is created using the passed object attributes.
          Although the object created is unnamed, the object name passed
          is used to lookup a security descriptor to associate with the 
          object.
              
        * The guids are registered in the system.

Arguments:

    ObjectAttribtes is a pointer to the passed object attributes used to
        create the request object
            
    Cookie is a unique id to associate with the request object so that
        when a request is delivered the UM code can understand the context
        via the cookie.
            
    RegInfo is the registration information passed
        
    RegInfoSize is the number of bytes of registration information passed
        
    *RequestHandle returns with a handle to the request object. UM logger
        creation and tracelog enabled/disable requests are delivered to
        the object as WMI events.
        
    *LoggerContext returns with the logger context

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    NTSTATUS Status;
    PDEVICE_OBJECT Callback;
    PWMIGUIDOBJECT RequestObject;
    PREGENTRY RegEntry;
    PBGUIDENTRY GuidEntry;
    PWMIREGGUID RegGuid;
    PBDATASOURCE DataSource;
    PBINSTANCESET InstanceSet;
    OBJECT_ATTRIBUTES CapturedObjectAttributes;
    UNICODE_STRING CapturedGuidString;
    WCHAR CapturedGuidBuffer[WmiGuidObjectNameLength + 1];
    
    PAGED_CODE();

    Status = WmipProbeAndCaptureGuidObjectAttributes(&CapturedObjectAttributes,
                                                     &CapturedGuidString,
                                                     CapturedGuidBuffer,
                                                     ObjectAttributes);

    if (NT_SUCCESS(Status))
    {
        Callback = (PDEVICE_OBJECT)(ULONG_PTR) WmipUMProviderCallback;

        //
        // Establish a regentry for the data provider
        //
        WmipEnterSMCritSection();
        RegEntry = WmipAllocRegEntry(Callback,
                                     WMIREG_FLAG_CALLBACK |
                                     REGENTRY_FLAG_TRACED |
                                     REGENTRY_FLAG_NEWREGINFO | 
                                     REGENTRY_FLAG_INUSE |
                                     REGENTRY_FLAG_REG_IN_PROGRESS);
        WmipLeaveSMCritSection();
        
        if (RegEntry != NULL)
        {
            //
            // Build a request object for this data source so that any
            // enable requests can be posted to it while processing the 
            // WmiRegInfo
            //
            Status = WmipOpenGuidObject(&CapturedObjectAttributes,
                                        TRACELOG_REGISTER_GUIDS, 
                                        UserMode,
                                        RequestHandle,
                                        &RequestObject);

            if (NT_SUCCESS(Status))
            {
                Status = WmipProcessWmiRegInfo(RegEntry,
                                               RegInfo,
                                               RegInfoSize,
                                               RequestObject,
                                               FALSE,
                                               TRUE);

                if (NT_SUCCESS(Status))
                {
                    //
                    // Initialize/Update InstanceSet
                    //
                    DataSource = RegEntry->DataSource;
                    RegGuid = &RegInfo->WmiRegGuid[0];

                    InstanceSet = WmipFindISByGuid( DataSource, 
                                                &RegGuid->Guid );
                    if (InstanceSet == NULL)
                    {
                        Status = STATUS_WMI_GUID_NOT_FOUND;
                    }
                    else {
                        WmipUnreferenceIS(InstanceSet);
                    }
                    //
                    // Find out if this Guid is currently Enabled. If so find
                    // its LoggerContext
                    //
                    *LoggerContext = 0;
                    GuidEntry = WmipFindGEByGuid(&RegInfo->WmiRegGuid->Guid, 
                                                 FALSE);
                    if (GuidEntry != NULL)
                    {
                        if (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)
                        {
                            *LoggerContext = GuidEntry->LoggerContext;
                        }
                        WmipUnreferenceGE(GuidEntry);
                    }

                    RequestObject->Flags |= WMIGUID_FLAG_REQUEST_OBJECT;
                    RequestObject->RegEntry = RegEntry;
                    RequestObject->Cookie = Cookie;
                }
                else
                {
                    //
                    // If an error registering guids then clean up regentry
                    //
                    RegEntry->Flags |= (REGENTRY_FLAG_RUNDOWN | 
                                        REGENTRY_FLAG_NOT_ACCEPTING_IRPS);
                    WmipUnreferenceRegEntry(RegEntry);
                    ZwClose(*RequestHandle);
                }
                
                //
                // remove the ref from when the object was created
                //
                ObDereferenceObject(RequestObject);
                
            } 
            else {
                RegEntry->Flags |= (REGENTRY_FLAG_RUNDOWN | 
                                        REGENTRY_FLAG_NOT_ACCEPTING_IRPS);
                WmipUnreferenceRegEntry(RegEntry);
            }


        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return(Status);
}


NTSTATUS WmipUnregisterGuids(
    PWMIUNREGGUIDS UnregGuids
    )
{
    PBGUIDENTRY GuidEntry;
    
    PAGED_CODE();

    //
    // Check to see if this GUID got disabled in the middle
    // of Unregister Call. If so, send the LoggerContext back
    //

    GuidEntry = WmipFindGEByGuid(&UnregGuids->Guid, FALSE);
    if (GuidEntry != NULL)
    {
        if ((GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG) != 0)
        {

            UnregGuids->LoggerContext = GuidEntry->LoggerContext;
        }
        WmipUnreferenceGE(GuidEntry);
        return (STATUS_SUCCESS);
    }
    else {
        return (STATUS_WMI_INSTANCE_NOT_FOUND);
    }
}


NTSTATUS WmipWriteMBToObject(
    IN PWMIGUIDOBJECT RequestObject,
    IN PWMIGUIDOBJECT ReplyObject,
    IN PUCHAR Message,
    IN ULONG MessageSize
    )
/*+++

Routine Description:

    This routine will build a WNODE out of a message and then write it 
    into the Request object. If a reply object is specified then the reply
    object is linked into the request object so when the reply is written
    to the request object it can be routed to the reply object correctly,.
        
    This routine assumes that the SM Critical section is held
        
Arguments:

    RequestObject is the object to which to send the request
        
    ReplyObject is the object to which the request object shoudl reply.
        This may be NULL in the case that no reply is needed.
            
    Message is the message to be sent
    
    MessageSize is the size of the message in bytes

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    PWNODE_HEADER Wnode;
    ULONG WnodeSize;
    PUCHAR Payload;
    ULONG i;
    PMBREQUESTS MBRequest;
    NTSTATUS Status;
    
    PAGED_CODE();
    
    //
    // Allocate space to build a wnode out of the data passed
    //
    WnodeSize = sizeof(WNODE_HEADER) + MessageSize;    
    Wnode = WmipAlloc(WnodeSize);
    if (Wnode != NULL)
    {
        //
        // Create an internal wnode with the message as the payload
         //
        RtlZeroMemory(Wnode, sizeof(WNODE_HEADER));
        Wnode->BufferSize = WnodeSize;
        Wnode->Flags = WNODE_FLAG_INTERNAL;
        Wnode->Guid = RequestObject->Guid;
        Wnode->ProviderId = WmiMBRequest;
        Payload = (PUCHAR)Wnode + sizeof(WNODE_HEADER);
        RtlCopyMemory(Payload, Message, MessageSize);
        
        //
        // if this request requires a reply then update the lists for the
        // request and reply objects
        //
        if (ReplyObject != NULL)
        {
            // 
            // Find a free spot in the request object to link
            // in the reply.
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
        
            for (i = 0; i < MAXREQREPLYSLOTS; i++)
            {
                MBRequest = &RequestObject->MBRequests[i];
                if (MBRequest->ReplyObject == NULL)
                {
                    //
                    // We have a free slot so link request and reply
                    // objects together and send off the request.
                    // The request object takes a ref count on the reply
                    // object since it maintains a pointer to it. The
                    // refcount is released when the request object writes
                    // the reply back to the reply object.
                    //
                    Status = ObReferenceObjectByPointer(ReplyObject,
                                               0,
                                               WmipGuidObjectType,
                                               KernelMode);

                    if (NT_SUCCESS(Status))
                    {
                        MBRequest->ReplyObject = ReplyObject;
                        InsertTailList(&ReplyObject->RequestListHead,
                                       &MBRequest->RequestListEntry);

                        Wnode->Version = i;

                        Status = WmipWriteWnodeToObject(RequestObject,
                                                        Wnode,
                                                        TRUE);
                        if (! NT_SUCCESS(Status))
                        {
                            //
                            // If writing request failed, we need to cleanup
                            //
                            ObDereferenceObject(ReplyObject);
                            MBRequest->ReplyObject = NULL;
                            RemoveEntryList(&MBRequest->RequestListEntry);
                        }
                    }
                    break;
                }
            }
        } else {
            //
            // No reply required so we just write the message to the
            // object and continue with our business
            //
            Status = WmipWriteWnodeToObject(RequestObject,
                                            Wnode,
                                            TRUE);
        }
        
        WmipFree(Wnode);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status);
}

NTSTATUS WmipWriteMessageToGuid(
    IN PBGUIDENTRY GuidEntry,
    IN PWMIGUIDOBJECT ReplyObject,
    IN PUCHAR Message,
    IN ULONG MessageSize,
    OUT PULONG WrittenCount
)
/*+++

Routine Description:

    This routine will loop over all instance sets attached to a guid entry
    and if the data source for it is a user mode data source then it will
    get a request messsage sent to it.
        
    Note that if there are more than one providers to which a message is
    sent, then success is returned as long as writing to one of them is
    successful.
        
Arguments:

    GuidEntry is the guid entry for the control guid
        
    ReplyObject is the object to which the request object shoudl reply.
        This may be NULL in the case that no reply is needed.
            
    Message is the message to be sent
    
    MessageSize is the size of the message in bytes

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    NTSTATUS Status, Status2;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    PBDATASOURCE DataSource;
       
    PAGED_CODE();
    
    Status = STATUS_UNSUCCESSFUL;
    *WrittenCount = 0;
    
    WmipEnterSMCritSection();
    
    //
    // Loop over all instances and send create logger
    // request to all user mode data providers
    //
    InstanceSetList = GuidEntry->ISHead.Flink;
    while (InstanceSetList != &GuidEntry->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        GuidISList);
                                    
        DataSource = InstanceSet->DataSource;
        
        if (DataSource->Flags & DS_USER_MODE)
        {
            //
            // User mode guy, so send the request to him
            //
            ASSERT(DataSource->RequestObject != NULL);
            Status2 = WmipWriteMBToObject(DataSource->RequestObject,
                                       ReplyObject,
                                       Message,
                                       MessageSize);
                                   
            if (NT_SUCCESS(Status2))
            {
                Status = STATUS_SUCCESS;
                (*WrittenCount)++;
            }
        }
        
        InstanceSetList = InstanceSetList->Flink;
    }
    
    WmipLeaveSMCritSection();
    
    return(Status);            
}

NTSTATUS WmipCreateUMLogger(
    IN OUT PWMICREATEUMLOGGER CreateInfo
    )
/*+++

Routine Description:

    This routine will send a request to create a UM logger. First it will 
    find the providers associated with the control guid and then create a
    reply object which the providers will reply to when the UM logger is 
    created. Note that the reply object is created as an unnamed object, 
    but that the guid passed in the object name is used to look up the
    security descriptor for the reply object.
        
    Note that if there are more than one providers to which a message is
    sent, then success is returned as long as writing to one of them is
    successful.
        
Arguments:

    CreateInfo has the information needed to create the UM logger. 

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    NTSTATUS Status;
    PBGUIDENTRY GuidEntry;
    HANDLE ReplyHandle;
    PWMIGUIDOBJECT ReplyObject;
    ULONG MessageSize = 1;
    PWNODE_HEADER Wnode;
    ULONG ReplyCount;
    OBJECT_ATTRIBUTES CapturedObjectAttributes;
    UNICODE_STRING CapturedGuidString;
    WCHAR CapturedGuidBuffer[WmiGuidObjectNameLength + 1];
    
    PAGED_CODE();

    Status = WmipProbeAndCaptureGuidObjectAttributes(&CapturedObjectAttributes,
                                                     &CapturedGuidString,
                                                     CapturedGuidBuffer,
                                                     CreateInfo->ObjectAttributes);


    if (NT_SUCCESS(Status))
    {
        GuidEntry = WmipFindGEByGuid(&CreateInfo->ControlGuid, FALSE);
        if (GuidEntry != NULL)
        {
            //
            // Control guid is registered so create a reply object that the
            // provider will write to.
            //
            if (WmipIsControlGuid(GuidEntry))
            {
                //
                // Create the reply object
                //
                Status = WmipOpenGuidObject(&CapturedObjectAttributes,
                                            TRACELOG_CREATE_INPROC |
                                            TRACELOG_GUID_ENABLE |
                                            WMIGUID_NOTIFICATION,
                                            UserMode,
                                            &ReplyHandle,
                                            &ReplyObject);

                if (NT_SUCCESS(Status))
                {
                    //
                    // Send request to all providers who registered for control
                    // guid
                    //
                    ReplyObject->Flags |= WMIGUID_FLAG_REPLY_OBJECT;
                    InitializeListHead(&ReplyObject->RequestListHead);


                    Wnode = (PWNODE_HEADER) ((PUCHAR) CreateInfo+ sizeof(WMICREATEUMLOGGER));
                    MessageSize = Wnode->BufferSize;

                    Status = WmipWriteMessageToGuid(GuidEntry,
                                                    ReplyObject,
                                                    (PUCHAR)Wnode,
                                                    MessageSize,
                                                    &ReplyCount
                                                   );
                    if (NT_SUCCESS(Status))
                    {
                        //
                        // Create logger requests delivered ok so return handle
                        // to object that will receive the replies.
                        //
                        CreateInfo->ReplyHandle.Handle = ReplyHandle;
                        CreateInfo->ReplyCount = ReplyCount;
                    } else {
                        //
                        // We were not able to deliver the requests so we do not
                        // need to keep the reply object open
                        //
                        ZwClose(ReplyHandle);
                    }

                    //
                    // remove the ref taken when the object was created
                    //
                    ObDereferenceObject(ReplyObject);
                }
            }

            WmipUnreferenceGE(GuidEntry);
        } else {
            //
            // Control guid is not registered so return an error
            //

            Status = STATUS_WMI_INSTANCE_NOT_FOUND;
        }
    }
    
    return(Status);
}


NTSTATUS WmipMBReply(
    IN HANDLE RequestHandle,
    IN ULONG ReplyIndex,
    IN PUCHAR Message,
    IN ULONG MessageSize
    )
/*+++

Routine Description:

    This routine will write a MB reply message to the appropriate
    reply object and unlink the reply object from the request object;
        
Arguments:

    RequestHandle is the handle to the request object
        
    ReplyIndex is the index to the MBRequest entry for the reply object
        
    Message is the reply message
        
    MessageSize is the size of the reply message

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    NTSTATUS Status;
    PWMIGUIDOBJECT RequestObject, ReplyObject;
    PMBREQUESTS MBRequest;
    
    PAGED_CODE();
    
    Status = ObReferenceObjectByHandle(RequestHandle,
                                       TRACELOG_REGISTER_GUIDS,
                                       WmipGuidObjectType,
                                       UserMode,
                                       &RequestObject,
                                       NULL);

                                   
    if (NT_SUCCESS(Status))
    {
        if (ReplyIndex < MAXREQREPLYSLOTS)
        {
            //
            // Is the ReplyIndex passed valid ??
            //
            WmipEnterSMCritSection();
            MBRequest = &RequestObject->MBRequests[ReplyIndex];
            
            ReplyObject = MBRequest->ReplyObject;
            if (ReplyObject != NULL)
            {

                //
                // We have figured out who we need to reply to so
                // clear out the link between the reply object
                // and this request object
                //
                RemoveEntryList(&MBRequest->RequestListEntry);
                MBRequest->ReplyObject = NULL;
                ObDereferenceObject(ReplyObject);
                
                Status = WmipWriteMBToObject(ReplyObject,
                                  NULL,
                                  Message,
                                  MessageSize);
                if (! NT_SUCCESS(Status))
                {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_ERROR_LEVEL,
                                      "WMI: WmipWriteMBToObject(%p) failed %x\n",
                                      ReplyObject,
                                      Status));                 
                }
                
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
            
            WmipLeaveSMCritSection();
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
        ObDereferenceObject(RequestObject);
    }
    
    return(Status);
}


#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\dataprov.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    DataProv.c

Abstract:

    WMI internal data provider interface

Author:

    AlanWar

Environment:

    Kernel mode

Revision History:


--*/

#include "wmikmp.h"

NTSTATUS
WmipQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
WmipQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath
    );

NTSTATUS WmipSetWmiDataBlock(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    ULONG GuidIndex,
    ULONG InstanceIndex,
    ULONG BufferSize,
    PUCHAR Buffer
    );

NTSTATUS
WmipExecuteWmiMethod (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );

BOOLEAN
WmipFindGuid(
    IN PGUIDREGINFO GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex,
    OUT PULONG InstanceCount
    );

NTSTATUS
IoWMICompleteRequest(
    IN PWMILIB_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG BufferUsed,
    IN CCHAR PriorityBoost
    );

NTSTATUS
IoWMISystemControl(
    IN PWMILIB_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif


const GUIDREGINFO WmipGuidList[] =
{
    //
    // This is the pnp id guid which is registered by wmi into other device
    // objects' registration info. And requests to the innocent devices
    // are hijacked by wmi so that wmi can complete the request for it. We
    // have the WMIREG_FLAG_REMOVE_GUID set so that the guid is not registered
    // for the wmi device which does not support it.
    {
        DATA_PROVIDER_PNPID_GUID,
        0,
        WMIREG_FLAG_REMOVE_GUID
    },

    {
        DATA_PROVIDER_PNPID_INSTANCE_NAMES_GUID,
        0,
        WMIREG_FLAG_REMOVE_GUID
    },

    {
        MSAcpiInfoGuid,
        1,
        0
    },
    
#if  defined(_AMD64_) || defined(_IA64_) || defined(i386) || defined(MEMPHIS)
    {
        SMBIOS_DATA_GUID,
        1,
        0
    },

    {
        SYSID_UUID_DATA_GUID,
        1,
        0
    },

    {
        SYSID_1394_DATA_GUID,
        1,
        0
    },

    {
        MSSmBios_SMBiosEventlogGuid,
        1,
        0
    },
#endif

#if  defined(_IA64_) || defined(_X86_) || defined(_AMD64_)
    {
        MSMCAInfo_RawMCADataGuid,
        1,
        0
    },

#ifdef CPE_CONTROL  
    {
        MSMCAInfo_CPEControlGuid,
        1,
        0
    },
#endif  
    
    {
        MSMCAInfo_RawMCAEventGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        MSMCAInfo_RawCMCEventGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        MSMCAInfo_RawCorrectedPlatformEventGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },
    
#endif

};
#define WmipGuidCount (sizeof(WmipGuidList) / sizeof(GUIDREGINFO))

typedef enum
{
    PnPIdGuidIndex =      0,
    PnPIdInstanceNamesGuidIndex,
    MSAcpiInfoGuidIndex,
#if  defined(_AMD64_) || defined(_IA64_) || defined(i386) || defined(MEMPHIS)
    SmbiosDataGuidIndex,
    SysidUuidGuidIndex,
    Sysid1394GuidIndex,
    SmbiosEventGuidIndex,
#endif  
#if  defined(_IA64_) || defined(_X86_) || defined(_AMD64_)
    MCARawDataGuidIndex,
#ifdef CPE_CONTROL  
    CPEControlGuidIndex,
#endif  
    RawMCAEventGuidIndex,
    RawCMCEventGuidIndex,
    RawCPEEventGuidIndex,
#endif
} WMIGUIDINDEXES;
    

const WMILIB_INFO WmipWmiLibInfo =
{
    NULL,
    NULL,
    WmipGuidCount,
    (PGUIDREGINFO)WmipGuidList,
    WmipQueryWmiRegInfo,
    WmipQueryWmiDataBlock,
#ifdef CPE_CONTROL
    WmipSetWmiDataBlock,
#else
    NULL,
#endif
    NULL,
    NULL,
    NULL
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,WmipQueryWmiRegInfo)
#pragma alloc_text(PAGE,WmipQueryWmiDataBlock)
#pragma alloc_text(PAGE,WmipSetWmiDataBlock)
#pragma alloc_text(PAGE,WmipExecuteWmiMethod)
#pragma alloc_text(PAGE,WmipFindGuid)
#pragma alloc_text(PAGE,IoWMISystemControl)
#pragma alloc_text(PAGE,IoWMICompleteRequest)
#endif


NTSTATUS
WmipQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

Return Value:

    status

--*/
{
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (RegFlags);

    *RegistryPath = &WmipRegistryPath;

    RtlInitAnsiString(&AnsiString, "SMBiosData");

    Status = RtlAnsiStringToUnicodeString(InstanceName, &AnsiString, TRUE);

    return(Status);
}

NTSTATUS
WmipQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call IoWMICompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried. In the case
        of the PnPId guid this is the device object of the device on whose
        behalf the request is being processed.

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    ULONG sizeNeeded = 0, sizeSMBios;
    PUCHAR BufferPtr;
    PSMBIOSVERSIONINFO SMBiosVersionInfo;
    PULONG TableSize = NULL;

    PAGED_CODE();

    switch (GuidIndex)
    {
        case SmbiosDataGuidIndex:
        {
            //
            // SMBIOS data table query
#if defined(_AMD64_) || defined(_IA64_) || defined(i386) || defined(MEMPHIS)
            WmipAssert((InstanceIndex == 0) && (InstanceCount == 1));

            sizeNeeded = sizeof(SMBIOSVERSIONINFO) + sizeof(ULONG);
            if (BufferAvail >= sizeNeeded)
            {
                sizeSMBios = BufferAvail - sizeNeeded;
                SMBiosVersionInfo = (PSMBIOSVERSIONINFO)Buffer;
                TableSize = (PULONG) (Buffer + sizeof(SMBIOSVERSIONINFO));
                BufferPtr = Buffer + sizeNeeded;
            } else {
                sizeSMBios = 0;
                BufferPtr = NULL;
                SMBiosVersionInfo = NULL;
            }

            status = WmipGetSMBiosTableData(BufferPtr,
                                        &sizeSMBios,
                                        SMBiosVersionInfo);

            sizeNeeded += sizeSMBios;

            if (NT_SUCCESS(status))
            {
                *(TableSize) = sizeSMBios;
                *InstanceLengthArray = sizeNeeded;
            }
#else
            status = STATUS_WMI_GUID_NOT_FOUND;
#endif
            break;
        }

        case PnPIdGuidIndex:
        {
            PDEVICE_OBJECT pDO;
            UNICODE_STRING instancePath;
            PREGENTRY regEntry;
            ULONG dataBlockSize, paddedDataBlockSize, padSize;
            ULONG i;

            regEntry = WmipFindRegEntryByDevice(DeviceObject, FALSE);
            if (regEntry != NULL)
            {
                pDO = regEntry->PDO;
                WmipAssert(pDO != NULL);

                if (pDO != NULL)
                {
                    status = WmipPDOToDeviceInstanceName(pDO, &instancePath);
                    if (NT_SUCCESS(status))
                    {
                        dataBlockSize = instancePath.Length + sizeof(USHORT);
                        paddedDataBlockSize = (dataBlockSize + 7) & ~7;
                        padSize = paddedDataBlockSize - dataBlockSize;
                        sizeNeeded = paddedDataBlockSize * InstanceCount;
                        if (sizeNeeded <= BufferAvail)
                        {
                            for (i = InstanceIndex;
                                 i < (InstanceIndex + InstanceCount);
                                 i++)
                            {
                                *InstanceLengthArray++ = dataBlockSize;
                                *((PUSHORT)Buffer) = instancePath.Length;
                                Buffer += sizeof(USHORT);
                                RtlCopyMemory(Buffer,
                                                 instancePath.Buffer,
                                              instancePath.Length);
                                Buffer += instancePath.Length;
                                RtlZeroMemory(Buffer, padSize);
                                Buffer += padSize;
                            }
                        } else {
                            status = STATUS_BUFFER_TOO_SMALL;
                        }

                        RtlFreeUnicodeString(&instancePath);

                    } else {
                        status = STATUS_WMI_GUID_NOT_FOUND;
                    }
                } else {
                    status = STATUS_UNSUCCESSFUL;
                }

                WmipUnreferenceRegEntry(regEntry);
            } else {
                WmipAssert(FALSE);
                status = STATUS_WMI_GUID_NOT_FOUND;
            }

            break;
        }

        case PnPIdInstanceNamesGuidIndex:
        {
            PDEVICE_OBJECT pDO;
            UNICODE_STRING instancePath;
            PREGENTRY regEntry;

            regEntry = WmipFindRegEntryByDevice(DeviceObject, FALSE);
            if (regEntry != NULL)
            {
                pDO = regEntry->PDO;
                WmipAssert(pDO != NULL);

                if (pDO != NULL)
                {
                    status = WmipPDOToDeviceInstanceName(pDO, &instancePath);
                    if (NT_SUCCESS(status))
                    {
                        sizeNeeded = sizeof(ULONG) +
                                        instancePath.Length + 2 * sizeof(WCHAR) +
                        sizeof(USHORT);

                        if (sizeNeeded <= BufferAvail)
                        {
                            *((PULONG)Buffer) = 1;
                            Buffer += sizeof(ULONG);
                            *InstanceLengthArray = sizeNeeded;
                            *((PUSHORT)Buffer) = instancePath.Length + 2*sizeof(WCHAR);
                            Buffer += sizeof(USHORT);
                            RtlCopyMemory(Buffer,
                                          instancePath.Buffer,
                                          instancePath.Length);
                            Buffer += instancePath.Length;
                            *((PWCHAR)Buffer) = '_';
                            Buffer += sizeof(WCHAR);
                            *((PWCHAR)Buffer) = '0';
                        } else {
                            status = STATUS_BUFFER_TOO_SMALL;
                        }

                        RtlFreeUnicodeString(&instancePath);

                    } else {
                        status = STATUS_WMI_GUID_NOT_FOUND;
                    }
                } else {
                    status = STATUS_UNSUCCESSFUL;
                }

                WmipUnreferenceRegEntry(regEntry);
            } else {
                WmipAssert(FALSE);
                status = STATUS_WMI_GUID_NOT_FOUND;
            }

            break;
        }

        case MSAcpiInfoGuidIndex:
        {
            RTL_QUERY_REGISTRY_TABLE queryTable[4];
            ULONG bootArchitecture = 0;
            ULONG preferredProfile = 0;
            ULONG capabilities = 0;

            queryTable[0].QueryRoutine = NULL;
            queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT |
                                  RTL_QUERY_REGISTRY_REQUIRED;
            queryTable[0].Name = L"BootArchitecture";
            queryTable[0].EntryContext = &bootArchitecture;
            queryTable[0].DefaultType = REG_NONE;

            queryTable[1].QueryRoutine = NULL;
            queryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT |
                                  RTL_QUERY_REGISTRY_REQUIRED;
            queryTable[1].Name = L"PreferredProfile";
            queryTable[1].EntryContext = &preferredProfile;
            queryTable[1].DefaultType = REG_NONE;

            queryTable[2].QueryRoutine = NULL;
            queryTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT |
                                  RTL_QUERY_REGISTRY_REQUIRED;
            queryTable[2].Name = L"Capabilities";
            queryTable[2].EntryContext = &capabilities;
            queryTable[2].DefaultType = REG_NONE;

            queryTable[3].QueryRoutine = NULL;
            queryTable[3].Flags = 0;
            
            status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                            L"\\Registry\\Machine\\Hardware\\Description\\System",
                                            queryTable,
                                            NULL,
                                            NULL);

            if (NT_SUCCESS(status))
            {
                sizeNeeded = sizeof(MSAcpiInfo);
                if (sizeNeeded <= BufferAvail)
                {
                    PMSAcpiInfo info = (PMSAcpiInfo)Buffer;
                    info->BootArchitecture = bootArchitecture;
                    info->PreferredProfile = preferredProfile;
                    info->Capabilities = capabilities;
                    status = STATUS_SUCCESS;
                } else {
                    status = STATUS_BUFFER_TOO_SMALL;
                }
            } else {
                status = STATUS_WMI_GUID_NOT_FOUND;
            }
            break;
        }
        
        case Sysid1394GuidIndex:
        case SysidUuidGuidIndex:
        {
            PSYSID_UUID uuid;
            ULONG uuidCount;
            PSYSID_1394 x1394;
            ULONG x1394Count;
            PUCHAR data;
            ULONG count;

#if defined(_AMD64_) || defined(_IA64_) || defined(i386) || defined(MEMPHIS)

            status = WmipGetSysIds(&uuid,
                                   &uuidCount,
                                   &x1394,
                                   &x1394Count);

            if (NT_SUCCESS(status))
            {
                if (GuidIndex == Sysid1394GuidIndex)
                {
                    sizeNeeded = x1394Count * sizeof(SYSID_1394) +
                                 sizeof(ULONG);
                    data = (PUCHAR)x1394;
                    count = x1394Count;
                } else {
                    sizeNeeded = uuidCount * sizeof(SYSID_UUID) +
                                 sizeof(ULONG);
                    data = (PUCHAR)uuid;
                    count = uuidCount;
                }

                if (BufferAvail >= sizeNeeded)
                {
                    *InstanceLengthArray = sizeNeeded;
                    *((PULONG)Buffer) = count;
                    Buffer += sizeof(ULONG);
                    RtlCopyMemory(Buffer, data, sizeNeeded-sizeof(ULONG));
                    status = STATUS_SUCCESS;
                } else {
                    status = STATUS_BUFFER_TOO_SMALL;
                }
            }
#else
            status = STATUS_WMI_GUID_NOT_FOUND;
#endif

            break;
        }

        case SmbiosEventGuidIndex:
        {
            //
            // SMBIOS eventlog query

#if defined(_AMD64_) || defined(_IA64_) || defined(i386) || defined(MEMPHIS)
            WmipAssert((InstanceIndex == 0) && (InstanceCount == 1));

            if (BufferAvail == 0)
            {
                sizeNeeded = 0;
                BufferPtr = NULL;
            } else {
                sizeNeeded = BufferAvail;
                BufferPtr = Buffer;
            }

            status = WmipGetSMBiosEventlog(BufferPtr, &sizeNeeded);

            if (NT_SUCCESS(status))
            {
                *InstanceLengthArray = sizeNeeded;
            }
#else
            status = STATUS_WMI_GUID_NOT_FOUND;
#endif
            break;
        }

#if  defined(_IA64_) || defined(_X86_) || defined(_AMD64_)
        case MCARawDataGuidIndex:
        {
            sizeNeeded = BufferAvail;
            status = WmipGetRawMCAInfo(Buffer,
                                       &sizeNeeded);
                    
            if (NT_SUCCESS(status))
            {
                *InstanceLengthArray = sizeNeeded;
            }
            break;
        }
#endif
        
//
// For now don't expose the CPE control guid
//
#ifdef CPE_CONTROL
        case CPEControlGuidIndex:
        {
            sizeNeeded = sizeof(MSMCAInfo_CPEControl);
            if (BufferAvail >= sizeNeeded)
            {
                PMSMCAInfo_CPEControl cpeControl;

                cpeControl = (PMSMCAInfo_CPEControl)Buffer;
                cpeControl->CPEPollingInterval = WmipCpePollInterval;
                cpeControl->CPEGenerationEnabled = (WmipCpePollInterval != HAL_CPE_DISABLED) ?
                                                    TRUE :
                                                    FALSE;
                *InstanceLengthArray = sizeNeeded;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }
#endif

        default:
        {
            WmipAssert(FALSE);
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }

    status = IoWMICompleteRequest((PWMILIB_INFO)&WmipWmiLibInfo,
                                 DeviceObject,
                                 Irp,
                                 status,
                                 sizeNeeded,
                                 IO_NO_INCREMENT);
    return(status);
}


#ifdef CPE_CONTROL
NTSTATUS WmipSetWmiDataBlock(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    ULONG GuidIndex,
    ULONG InstanceIndex,
    ULONG BufferSize,
    PUCHAR Buffer
    )
{
    NTSTATUS status;
    ULONG sizeNeeded;
    
    PAGED_CODE();
    
    if (GuidIndex == CPEControlGuidIndex)
    {
        sizeNeeded = FIELD_OFFSET(MSMCAInfo_CPEControl,
                                  CPEGenerationEnabled) +
                     sizeof(BOOLEAN);
        if (BufferSize == sizeNeeded)
        {
            PMSMCAInfo_CPEControl cpeControl;

            cpeControl = (PMSMCAInfo_CPEControl)Buffer;
            status = WmipSetCPEPolling(cpeControl->CPEGenerationEnabled,
                                       cpeControl->CPEPollingInterval);
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {
        status = STATUS_WMI_READ_ONLY;
    }
    
    status = IoWMICompleteRequest((PWMILIB_INFO)&WmipWmiLibInfo,
                                 DeviceObject,
                                 Irp,
                                 status,
                                 0,
                                 IO_NO_INCREMENT);
    return(status);
}
#endif

BOOLEAN
WmipFindGuid(
    IN PGUIDREGINFO GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex,
    OUT PULONG InstanceCount
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid

    *InstanceCount returns the count of instances for the guid

Return Value:

    TRUE if guid is found else FALSE

--*/
{
    ULONG i;

    PAGED_CODE();

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, &GuidList[i].Guid))
        {
            *GuidIndex = i;
            *InstanceCount = GuidList[i].InstanceCount;
            return(TRUE);
        }
    }

    return(FALSE);
}


NTSTATUS
IoWMISystemControl(
    IN PWMILIB_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL. This routine will process
    all wmi requests received, forwarding them if they are not for this
    driver or determining if the guid is valid and if so passing it to
    the driver specific function for handing wmi requests.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

    status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG bufferSize;
    PUCHAR buffer;
    NTSTATUS status;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG guidIndex = 0;
    ULONG instanceCount = 0;
    ULONG instanceIndex = 0;

    PAGED_CODE();

    //
    // If the irp is not a WMI irp or it is not targetted at this device
    // or this device has not regstered with WMI then just forward it on.
    minorFunction = irpStack->MinorFunction;
    if ((minorFunction > IRP_MN_REGINFO_EX) ||
        (irpStack->Parameters.WMI.ProviderId != (ULONG_PTR)DeviceObject) ||
        (((minorFunction != IRP_MN_REGINFO) &&
         ((minorFunction != IRP_MN_REGINFO_EX))) &&
         (WmiLibInfo->GuidList == NULL)))
    {
        //
        // IRP is not for us so forward if there is a lower device object
        if (WmiLibInfo->LowerDeviceObject != NULL)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            return(IoCallDriver(WmiLibInfo->LowerDeviceObject, Irp));
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    if ((minorFunction != IRP_MN_REGINFO) &&
        (minorFunction != IRP_MN_REGINFO_EX))
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        if (WmipFindGuid(WmiLibInfo->GuidList,
                            WmiLibInfo->GuidCount,
                            (LPGUID)irpStack->Parameters.WMI.DataPath,
                            &guidIndex,
                            &instanceCount))
        {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

        if (NT_SUCCESS(status) &&
            ((minorFunction == IRP_MN_QUERY_SINGLE_INSTANCE) ||
             (minorFunction == IRP_MN_CHANGE_SINGLE_INSTANCE) ||
             (minorFunction == IRP_MN_CHANGE_SINGLE_ITEM) ||
             (minorFunction == IRP_MN_EXECUTE_METHOD)))
        {
            instanceIndex = ((PWNODE_SINGLE_INSTANCE)buffer)->InstanceIndex;

            if ( ((((PWNODE_HEADER)buffer)->Flags) &
                                     WNODE_FLAG_STATIC_INSTANCE_NAMES) == 0)
            {
                status = STATUS_WMI_INSTANCE_NOT_FOUND;
            }
        }

        if (! NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    switch(minorFunction)
    {
        case IRP_MN_REGINFO:
        case IRP_MN_REGINFO_EX:
        {
            ULONG guidCount;
            PGUIDREGINFO guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PUNICODE_STRING regPath;
            PWCHAR stringPtr;
            ULONG registryPathOffset;
            ULONG mofResourceOffset;
            ULONG bufferNeeded;
            ULONG i;
            ULONG_PTR nameInfo;
            ULONG nameSize, nameOffset, nameFlags;
            UNICODE_STRING name;
            UNICODE_STRING nullRegistryPath;

            WmipAssert(WmiLibInfo->QueryWmiRegInfo != NULL);
            WmipAssert(WmiLibInfo->QueryWmiDataBlock != NULL);

            name.Buffer = NULL;
            name.Length = 0;
            name.MaximumLength = 0;
            nameFlags = 0;
            status = WmiLibInfo->QueryWmiRegInfo(
                                                    DeviceObject,
                                                    &nameFlags,
                                                    &name,
                                                    &regPath);

            if (NT_SUCCESS(status) &&
                (! (nameFlags &  WMIREG_FLAG_INSTANCE_PDO) &&
                (name.Buffer == NULL)))
            {
                //
                // if PDO flag not specified then an instance name must be
                status = STATUS_INVALID_DEVICE_REQUEST;
            }

#if DBG
            if (nameFlags &  WMIREG_FLAG_INSTANCE_PDO)
            {
                WmipAssert(WmiLibInfo->LowerPDO != NULL);
            }
#endif
            if (NT_SUCCESS(status))
            {
                WmipAssert(WmiLibInfo->GuidList != NULL);

                guidList = WmiLibInfo->GuidList;
                guidCount = WmiLibInfo->GuidCount;

                nameOffset = FIELD_OFFSET(WMIREGINFOW, WmiRegGuid) +
                                      guidCount * sizeof(WMIREGGUIDW);

                if (nameFlags & WMIREG_FLAG_INSTANCE_PDO)
                {
                    nameSize = 0;
                    nameInfo = (ULONG_PTR)WmiLibInfo->LowerPDO;
                } else {
                    nameFlags |= WMIREG_FLAG_INSTANCE_LIST;
                    nameSize = name.Length + sizeof(USHORT);
                    nameInfo = nameOffset;
                }

                if (regPath == NULL)
                {
                    //
                    // No registry path specified. This is a bad thing for
                    // the device to do, but is not fatal
                    nullRegistryPath.Buffer = NULL;
                    nullRegistryPath.Length = 0;
                    nullRegistryPath.MaximumLength = 0;
                    regPath = &nullRegistryPath;
                }

                mofResourceOffset = 0;

                registryPathOffset = nameOffset + nameSize; 

                bufferNeeded = registryPathOffset +
                regPath->Length + sizeof(USHORT);

                if (bufferNeeded <= bufferSize)
                {
                    retSize = bufferNeeded;

                    wmiRegInfo = (PWMIREGINFO)buffer;
                    wmiRegInfo->BufferSize = bufferNeeded;
                    wmiRegInfo->NextWmiRegInfo = 0;
                    wmiRegInfo->MofResourceName = mofResourceOffset;
                    wmiRegInfo->RegistryPath = registryPathOffset;
                    wmiRegInfo->GuidCount = guidCount;

                    for (i = 0; i < guidCount; i++)
                    {
                        wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                        wmiRegGuid->Guid = guidList[i].Guid;
                        wmiRegGuid->Flags = guidList[i].Flags | nameFlags;
                        wmiRegGuid->InstanceInfo = nameInfo;
                        wmiRegGuid->InstanceCount = guidList[i].InstanceCount;
                    }

                    if ( nameFlags &  WMIREG_FLAG_INSTANCE_LIST)
                    {
                        stringPtr = (PWCHAR)((PUCHAR)buffer + nameOffset);
                        *stringPtr++ = name.Length;
                        RtlCopyMemory(stringPtr,
                                  name.Buffer,
                                  name.Length);
                    }

                    stringPtr = (PWCHAR)((PUCHAR)buffer + registryPathOffset);
                    *stringPtr++ = regPath->Length;
                    RtlCopyMemory(stringPtr,
                              regPath->Buffer,
                              regPath->Length);
                } else {
                    *((PULONG)buffer) = bufferNeeded;
                    retSize = sizeof(ULONG);
                }
            } else {
                retSize = 0;
            }

            if (name.Buffer != NULL)
            {
                ExFreePool(name.Buffer);
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = retSize;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            ULONG bufferAvail;
            PULONG instanceLengthArray;
            PUCHAR dataBuffer;
            ULONG instanceLengthArraySize;
            ULONG dataBlockOffset;
            PREGENTRY regEntry;

            wnode = (PWNODE_ALL_DATA)buffer;

            if (bufferSize < FIELD_OFFSET(WNODE_ALL_DATA,
                                          OffsetInstanceDataAndLength))
            {
                //
                // The buffer should never be smaller than the size of
                // WNODE_ALL_DATA, however if it is then return with an
                // error requesting the minimum sized buffer.
                WmipAssert(FALSE);
                status = IoWMICompleteRequest(WmiLibInfo,
                                              DeviceObject,
                                              Irp,
                                              STATUS_BUFFER_TOO_SMALL,
                                              FIELD_OFFSET(WNODE_ALL_DATA,
                                                           OffsetInstanceDataAndLength),
                                              IO_NO_INCREMENT);
                break;
            }

            //
            // If this is the pnp id guid then we need to get the instance
            // count from the regentry for the device and switch the
            // device object.

            if ((guidIndex == PnPIdGuidIndex) ||
                (guidIndex == PnPIdInstanceNamesGuidIndex))
            {
                regEntry = WmipFindRegEntryByProviderId(wnode->WnodeHeader.ProviderId,
                                                        FALSE);
                if (regEntry == NULL)
                {
                    //
                    // Why couldn't we get the regentry again ??
                    WmipAssert(FALSE);
                    status = IoWMICompleteRequest(WmiLibInfo,
                                              DeviceObject,
                                              Irp,
                                              STATUS_WMI_GUID_NOT_FOUND,
                                              0,
                                              IO_NO_INCREMENT);
                    break;
                }

                DeviceObject = regEntry->DeviceObject;
                instanceCount = (guidIndex == PnPIdGuidIndex) ? regEntry->MaxInstanceNames : 1;

                WmipUnreferenceRegEntry(regEntry);
            }

            wnode->InstanceCount = instanceCount;

            wnode->WnodeHeader.Flags &= ~WNODE_FLAG_FIXED_INSTANCE_SIZE;

            instanceLengthArraySize = instanceCount * sizeof(OFFSETINSTANCEDATAANDLENGTH);

            dataBlockOffset = (FIELD_OFFSET(WNODE_ALL_DATA, OffsetInstanceDataAndLength) + instanceLengthArraySize + 7) & ~7;

            wnode->DataBlockOffset = dataBlockOffset;
            if (dataBlockOffset <= bufferSize)
            {
                instanceLengthArray = (PULONG)&wnode->OffsetInstanceDataAndLength[0];
                dataBuffer = buffer + dataBlockOffset;
                bufferAvail = bufferSize - dataBlockOffset;
            } else {
                //
                // There is not enough room in the WNODE to complete
                // the query
                instanceLengthArray = NULL;
                dataBuffer = NULL;
                bufferAvail = 0;
            }

            status = WmiLibInfo->QueryWmiDataBlock(
                                             DeviceObject,
                                             Irp,
                                             guidIndex,
                                             0,
                                             instanceCount,
                                             instanceLengthArray,
                                             bufferAvail,
                                             dataBuffer);
            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            ULONG dataBlockOffset;
            PREGENTRY regEntry;

            wnode = (PWNODE_SINGLE_INSTANCE)buffer;

            if ((guidIndex == PnPIdGuidIndex) ||
                (guidIndex == PnPIdInstanceNamesGuidIndex))
            {
                regEntry = WmipFindRegEntryByProviderId(wnode->WnodeHeader.ProviderId,
                                                        FALSE);
                if (regEntry != NULL)
                {
                    DeviceObject = regEntry->DeviceObject;
                    WmipUnreferenceRegEntry(regEntry);          
                } else {
                    //
                    // Why couldn't we get the regentry again ??
                    WmipAssert(FALSE);
                    status = IoWMICompleteRequest(WmiLibInfo,
                                              DeviceObject,
                                              Irp,
                                              STATUS_WMI_GUID_NOT_FOUND,
                                              0,
                                              IO_NO_INCREMENT);
                    break;
                }

            }

            dataBlockOffset = wnode->DataBlockOffset;

            status = WmiLibInfo->QueryWmiDataBlock(
                                          DeviceObject,
                                          Irp,
                                          guidIndex,
                                          instanceIndex,
                                          1,
                                          &wnode->SizeDataBlock,
                                          bufferSize - dataBlockOffset,
                                          (PUCHAR)wnode + dataBlockOffset);

            break;
        }

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;

            if (WmiLibInfo->SetWmiDataBlock != NULL)
            {
                wnode = (PWNODE_SINGLE_INSTANCE)buffer;

                status = WmiLibInfo->SetWmiDataBlock(
                                     DeviceObject,
                                     Irp,
                                     guidIndex,
                                     instanceIndex,
                                     wnode->SizeDataBlock,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);
            } else {
                //
                // If set callback is not filled in then it must be readonly
                status = STATUS_WMI_READ_ONLY;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }


            break;
        }

        case IRP_MN_CHANGE_SINGLE_ITEM:
        {
            PWNODE_SINGLE_ITEM wnode;

            if (WmiLibInfo->SetWmiDataItem != NULL)
            {
                wnode = (PWNODE_SINGLE_ITEM)buffer;

                status = WmiLibInfo->SetWmiDataItem(
                                     DeviceObject,
                                     Irp,
                                     guidIndex,
                                     instanceIndex,
                                     wnode->ItemId,
                                     wnode->SizeDataItem,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);

            } else {
                //
                // If set callback is not filled in then it must be readonly
                status = STATUS_WMI_READ_ONLY;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;

            if (WmiLibInfo->ExecuteWmiMethod != NULL)
            {
                wnode = (PWNODE_METHOD_ITEM)buffer;

                status = WmiLibInfo->ExecuteWmiMethod(
                                         DeviceObject,
                                         Irp,
                                         guidIndex,
                                         instanceIndex,
                                         wnode->MethodId,
                                         wnode->SizeDataBlock,
                                         bufferSize - wnode->DataBlockOffset,
                                         buffer + wnode->DataBlockOffset);

            } else {
                //
                // If method callback is not filled in then it must be error
                status = STATUS_INVALID_DEVICE_REQUEST;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }

            break;
        }

        case IRP_MN_ENABLE_EVENTS:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                           DeviceObject,
                                                           Irp,
                                                           guidIndex,
                                                           WmiEventGeneration,
                                                           TRUE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            break;
        }

        case IRP_MN_DISABLE_EVENTS:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                           DeviceObject,
                                                           Irp,
                                                           guidIndex,
                                                           WmiEventGeneration,
                                                           FALSE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                         DeviceObject,
                                                         Irp,
                                                         guidIndex,
                                                         WmiDataBlockCollection,
                                                         TRUE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            break;
        }

        case IRP_MN_DISABLE_COLLECTION:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                         DeviceObject,
                                                         Irp,
                                                         guidIndex,
                                                         WmiDataBlockCollection,
                                                         FALSE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            break;
        }

        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }

    return(status);
}

NTSTATUS
IoWMICompleteRequest(
    IN PWMILIB_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG BufferUsed,
    IN CCHAR PriorityBoost
    )
/*++

Routine Description:


    This routine will do the work of completing a WMI irp. Depending upon the
    the WMI request this routine will fixup the returned WNODE appropriately.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

    Status has the return status code for the IRP

    BufferUsed has the number of bytes needed by the device to return the
       data requested in any query. In the case that the buffer passed to
       the device is too small this has the number of bytes needed for the
       return data. If the buffer passed is large enough then this has the
       number of bytes actually used by the device.

    PriorityBoost is the value used for the IoCompleteRequest call.

Return Value:

    status

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PUCHAR buffer;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG bufferSize;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (WmiLibInfo);
    UNREFERENCED_PARAMETER (DeviceObject);

    minorFunction = irpStack->MinorFunction;
    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    switch(minorFunction)
    {
        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;
            ULONG instanceCount;
            POFFSETINSTANCEDATAANDLENGTH offsetInstanceDataAndLength;
            ULONG i;
            PULONG instanceLengthArray;
            ULONG dataBlockOffset;

            wnode = (PWNODE_ALL_DATA)buffer;

            dataBlockOffset = wnode->DataBlockOffset;
            instanceCount = wnode->InstanceCount;
            bufferNeeded = dataBlockOffset + BufferUsed;

            if ((NT_SUCCESS(Status)) &&
                (bufferNeeded > irpStack->Parameters.WMI.BufferSize))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }

            if (! NT_SUCCESS(Status))
            {
                if (Status == STATUS_BUFFER_TOO_SMALL)
                {
                    wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                    wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                    wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                    wnodeTooSmall->SizeNeeded = bufferNeeded;

                    retSize = sizeof(WNODE_TOO_SMALL);
                    Status = STATUS_SUCCESS;
                } else {
                    retSize = 0;
                }
                break;
            }

            KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);

            instanceLengthArray = (PULONG)&wnode->OffsetInstanceDataAndLength[0];
            offsetInstanceDataAndLength = (POFFSETINSTANCEDATAANDLENGTH)instanceLengthArray;

            wnode->WnodeHeader.BufferSize = bufferNeeded;
            retSize = bufferNeeded;

            for (i = instanceCount; i != 0; i--)
            {
                offsetInstanceDataAndLength[i-1].LengthInstanceData = instanceLengthArray[i-1];
            }

            for (i = 0; i < instanceCount; i++)
            {
                offsetInstanceDataAndLength[i].OffsetInstanceData = dataBlockOffset;
                dataBlockOffset = (dataBlockOffset + offsetInstanceDataAndLength[i].LengthInstanceData + 7) & ~7;
            }

            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_SINGLE_INSTANCE)buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (NT_SUCCESS(Status))
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);

                WmipAssert(wnode->SizeDataBlock <= BufferUsed);

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_METHOD_ITEM)buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (NT_SUCCESS(Status))
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
                wnode->SizeDataBlock = BufferUsed;

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        default:
        {
            //
            // All other requests don't return any data
            retSize = 0;
            break;
        }

    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = retSize;
    IoCompleteRequest(Irp, PriorityBoost);
    return(Status);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\chunk.c ===
/*++                 

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    chunk.c

Abstract:
    
    This routine will manage allocations of chunks of structures

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmikmp.h"

PENTRYHEADER WmipAllocEntry(
    PCHUNKINFO ChunkInfo
    );

void WmipFreeEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

ULONG WmipUnreferenceEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

PWCHAR WmipCountedToSz(
    PWCHAR Counted
    );

#if HEAPVALIDATION
PVOID WmipAlloc(
    ULONG Size
    );

void WmipFree(
    PVOID p
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,WmipAllocEntry)
#pragma alloc_text(PAGE,WmipFreeEntry)
#pragma alloc_text(PAGE,WmipUnreferenceEntry)
#pragma alloc_text(PAGE,WmipCountedToSz)

#if HEAPVALIDATION
#pragma alloc_text(PAGE,WmipAllocWithTag)
#pragma alloc_text(PAGE,WmipAlloc)
#pragma alloc_text(PAGE,WmipFree)
#endif
#endif

//
// TODO: Use Ex lookaside lists instead of my own allocations
//

PENTRYHEADER WmipAllocEntry(
    PCHUNKINFO ChunkInfo
    )
/*++

Routine Description:

    This routine will allocate a single structure within a list of chunks
    of structures.

Arguments:

    ChunkInfo describes the chunks of structures

Return Value:

    Pointer to structure or NULL if one cannot be allocated. Entry returns
    with its refcount set to 1

--*/
{
    PLIST_ENTRY ChunkList, EntryList, FreeEntryHead;
    PCHUNKHEADER Chunk;
    PUCHAR EntryPtr;
    ULONG EntryCount, ChunkSize;
    PENTRYHEADER Entry;
    ULONG i;

    PAGED_CODE();
    
    WmipEnterSMCritSection();
    ChunkList = ChunkInfo->ChunkHead.Flink;

    //
    // Loop over all chunks to see if any chunk has a free entry for us
    while(ChunkList != &ChunkInfo->ChunkHead)
    {
        Chunk = CONTAINING_RECORD(ChunkList, CHUNKHEADER, ChunkList);
        if (! IsListEmpty(&Chunk->FreeEntryHead))
        {
            EntryList = RemoveHeadList(&Chunk->FreeEntryHead);
            Chunk->EntriesInUse++;
            WmipLeaveSMCritSection();
            Entry = (CONTAINING_RECORD(EntryList,
                                       ENTRYHEADER,
                                       FreeEntryList));
            WmipAssert(Entry->Flags & FLAG_ENTRY_ON_FREE_LIST);
            memset(Entry, 0, ChunkInfo->EntrySize);
            Entry->Chunk = Chunk;
            Entry->RefCount = 1;
            Entry->Flags = ChunkInfo->InitialFlags;
            Entry->Signature = ChunkInfo->Signature;
#if DBG
            InterlockedIncrement(&ChunkInfo->AllocCount);
#endif
            return(Entry);
        }
        ChunkList = ChunkList->Flink;
    }
    WmipLeaveSMCritSection();

    //
    // There are no more free entries in any of the chunks. Allocate a new
    // chunk if we can
    ChunkSize = (ChunkInfo->EntrySize * ChunkInfo->EntriesPerChunk) +
                  sizeof(CHUNKHEADER);
    Chunk = (PCHUNKHEADER)ExAllocatePoolWithTag(PagedPool,
                                            ChunkSize,
                        ChunkInfo->Signature);
    if (Chunk != NULL)
    {
        //
        // Initialize the chunk by building the free list of entries within
        // it while also initializing each entry.
        memset(Chunk, 0, ChunkSize);

        FreeEntryHead = &Chunk->FreeEntryHead;
        InitializeListHead(FreeEntryHead);

        EntryPtr = (PUCHAR)Chunk + sizeof(CHUNKHEADER);
        EntryCount = ChunkInfo->EntriesPerChunk - 1;

        for (i = 0; i < EntryCount; i++)
        {
            Entry = (PENTRYHEADER)EntryPtr;
            Entry->Chunk = Chunk;
            Entry->Flags = FLAG_ENTRY_ON_FREE_LIST;
            InsertHeadList(FreeEntryHead,
                           &((PENTRYHEADER)EntryPtr)->FreeEntryList);
            EntryPtr = EntryPtr + ChunkInfo->EntrySize;
        }
        //
        // EntryPtr now points to the last entry in the chunk which has not
        // been placed on the free list. This will be the entry returned
        // to the caller.
        Entry = (PENTRYHEADER)EntryPtr;
        Entry->Chunk = Chunk;
        Entry->RefCount = 1;
        Entry->Flags = ChunkInfo->InitialFlags;
        Entry->Signature = ChunkInfo->Signature;

        Chunk->EntriesInUse = 1;

        //
        // Now place the newly allocated chunk onto the list of chunks
        WmipEnterSMCritSection();
        InsertHeadList(&ChunkInfo->ChunkHead, &Chunk->ChunkList);
        WmipLeaveSMCritSection();

    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Could not allocate memory for new chunk %x\n",
                        ChunkInfo));
        Entry = NULL;
    }
    return(Entry);
}

void WmipFreeEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*++

Routine Description:

    This routine will free an entry within a chunk and if the chunk has no
    more allocated entries then the chunk will be returned to the pool.

Arguments:

    ChunkInfo describes the chunks of structures

    Entry is the chunk entry to free

Return Value:


--*/
{
    PCHUNKHEADER Chunk;

    PAGED_CODE();
    
    WmipAssert(Entry != NULL);
    WmipAssert(! (Entry->Flags & FLAG_ENTRY_ON_FREE_LIST));
    WmipAssert(Entry->Flags & FLAG_ENTRY_INVALID);
    WmipAssert(Entry->RefCount == 0);
    WmipAssert(Entry->Signature == ChunkInfo->Signature);

    Chunk = Entry->Chunk;
    WmipAssert(Chunk->EntriesInUse > 0);

    WmipEnterSMCritSection();
    if ((--Chunk->EntriesInUse == 0) &&
        (ChunkInfo->ChunkHead.Blink != &Chunk->ChunkList))
    {
        //
        // We return the chunks memory back to the heap if there are no
        // more entries within the chunk in use and the chunk was not the
        // first chunk to be allocated.
        RemoveEntryList(&Chunk->ChunkList);
        WmipLeaveSMCritSection();
        ExFreePoolWithTag(Chunk, ChunkInfo->Signature);
    } else {
        //
        // Otherwise just mark the entry as free and put it back on the
        // chunks free list.
#if DBG
//        memset(Entry, 0xCCCCCCCC, ChunkInfo->EntrySize);
#endif
        Entry->Flags = FLAG_ENTRY_ON_FREE_LIST;
        Entry->Signature = 0;
        InsertTailList(&Chunk->FreeEntryHead, &Entry->FreeEntryList);
        WmipLeaveSMCritSection();
    }
}


ULONG WmipUnreferenceEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*+++

Routine Description:

    This routine will remove a reference count from the entry and if the
    reference count reaches zero then the entry is removed from its active
    list and then cleaned up and finally freed.

Arguments:

    ChunkInfo points at structure that describes the entry

    Entry is the entry to unreference

Return Value:

    New refcount of the entry

---*/
{
    ULONG RefCount;

    PAGED_CODE();
    
    WmipAssert(Entry != NULL);
    WmipAssert(Entry->RefCount > 0);
    WmipAssert(Entry->Signature == ChunkInfo->Signature);

    WmipEnterSMCritSection();
    InterlockedDecrement(&Entry->RefCount);
    RefCount = Entry->RefCount;

    if (RefCount == 0)
    {
        //
        // Entry has reached a ref count of 0 so mark it as invalid and remove
        // it from its active list.
        Entry->Flags |= FLAG_ENTRY_INVALID;

        if ((Entry->InUseEntryList.Flink != NULL) &&
            (Entry->Flags & FLAG_ENTRY_REMOVE_LIST))
        {
            RemoveEntryList(&Entry->InUseEntryList);
        }

        WmipLeaveSMCritSection();

        if (ChunkInfo->EntryCleanup != NULL)
        {
            //
            // Call cleanup routine to free anything contained by the entry
            (*ChunkInfo->EntryCleanup)(ChunkInfo, Entry);
        }

        //
        // Place the entry back on its free list
        WmipFreeEntry(ChunkInfo, Entry);
    } else {
        WmipLeaveSMCritSection();
    }
    return(RefCount);
}

PWCHAR WmipCountedToSz(
    PWCHAR Counted
    )
{
    PWCHAR Sz;
    USHORT CountedLen;

    PAGED_CODE();
    
    CountedLen = *Counted++;
       Sz = WmipAlloc(CountedLen + sizeof(WCHAR));
    if (Sz != NULL)
    {
           memcpy(Sz, Counted, CountedLen);
        Sz[CountedLen/sizeof(WCHAR)] = UNICODE_NULL;
    }        

    return(Sz);
}

#ifdef HEAPVALIDATION

PVOID WmipAllocWithTag(
    ULONG Size,
    ULONG Tag
    )
{
    PVOID p;

    PAGED_CODE();

    p = ExAllocatePoolWithTag(PagedPool, Size, Tag);

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipAlloc %x (%x)\n", p, Size));

    return(p);
}



PVOID WmipAlloc(
    ULONG Size
    )
{
    PVOID p;

    PAGED_CODE();
    
    p = ExAllocatePoolWithTag(PagedPool, Size, 'pimW');

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipAlloc %x (%x)\n", p, Size));

    return(p);
}

void WmipFree(
    PVOID p
    )
{

    PAGED_CODE();
    
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipFree %x\n", p));
    WmipAssert(p != NULL);

    ExFreePool(p);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\diags.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

   diags.c

Abstract:

    Diagnostic helper apis

Author:

    AlanWar

Environment:

    Kernel mode

Revision History:


--*/

#include "wmikmp.h"


//
// Each diag request and result is stored in one of these structures. It
// can be uniquely identified by the following combination of properties
//
//    IrpMn
//    Guid
//    MethodId  (If IrpMn == IRP_MN_EXECUTE_METHOD, otherwise ignored)
//    InstanceContext
//    InstanceId
//
typedef struct
{
    ULONG NextOffset;               // Offset to next result/request
    UCHAR IrpMn;                    // Operation
    BOOLEAN IsValid;                // if FALSE then this is ignored
    UCHAR Reserved1;
    UCHAR Reserved2;
    GUID Guid;                 
    ULONG MethodId;
    ULONG InstanceContextOffset;    // Offset to instance context from
	                            // beginning of structure. If 0 then
                                    // no instance context.
    ULONG InstanceContextSize;
    ULONG InstanceIndex;
    ULONG DataOffset;               // Offset to data from beginning of
	                            // stru
    ULONG DataSize;
    ULONG OutDataSize;
    UCHAR VariableData[1];
} SCHEDULEDDIAG, *PSCHEDULEDDIAG;

//
// Results are stored under the Checkpoint reg key which is volatile
//
#define REGSTR_CHECKPOINT L"CheckpointDiags"

//
// Permament requests are stored under the Permament reg key
//
#define REGSTR_PERMAMENT L"PermamentDiags"

//
// Temporary requests are stored under the Scheduled reg key
//
#define REGSTR_SCHEDULED L"ScheduledDiags"

NTSTATUS
WmipOpenRegistryKeyEx(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess
    )

/*++

//
// Temporary requests are stored under the Scheduled reg key
//
#define REGSTR_SCHEDULED L"Scheduled"

NTSTATUS
WmipOpenRegistryKeyEx(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    Opens a registry key using the name passed in based at the BaseHandle node.
    This name may specify a key that is actually a registry path.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

            BaseHandle - Optional handle to the base path from which the key must be opened.
        If KeyName specifies a registry path that must be created, then this parameter
        must be specified, and KeyName must be a relative path.

    KeyName - Name of the Key that must be opened/created (possibly a registry path)

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;

    PAGED_CODE();

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL
                                );
    //
    // Simply attempt to open the path, as specified.
    //
    return ZwOpenKey( Handle, DesiredAccess, &objectAttributes );
}

NTSTATUS
WmipCreateRegistryKeyEx(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    )

/*++

Routine Description:

    Opens or creates a registry key using the name
    passed in based at the BaseHandle node. This name may specify a key
    that is actually a registry path, in which case each intermediate subkey
    will be created (if Create is TRUE).

    NOTE: Creating a registry path (i.e., more than one of the keys in the path
    do not presently exist) requires that a BaseHandle be specified.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Optional handle to the base path from which the key must be opened.
        If KeyName specifies a registry path that must be created, then this parameter
        must be specified, and KeyName must be a relative path.

    KeyName - Name of the Key that must be opened/created (possibly a registry path)

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    CreateOptions - Options passed to ZwCreateKey.

    Disposition - If Create is TRUE, this optional pointer receives a ULONG indicating
        whether the key was newly created:

            REG_CREATED_NEW_KEY - A new Registry Key was created
            REG_OPENED_EXISTING_KEY - An existing Registry Key was opened

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition, baseHandleIndex = 0, keyHandleIndex = 1, closeBaseHandle;
    HANDLE handles[2];
    BOOLEAN continueParsing;
    PWCHAR pathEndPtr, pathCurPtr, pathBeginPtr;
    ULONG pathComponentLength;
    UNICODE_STRING unicodeString;
    NTSTATUS status;

    PAGED_CODE();

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL
                                );
    //
    // Attempt to create the path as specified. We have to try it this
    // way first, because it allows us to create a key without a BaseHandle
    // (if only the last component of the registry path is not present).
    //
    status = ZwCreateKey(&(handles[keyHandleIndex]),
                         DesiredAccess,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING) NULL,
                         CreateOptions,
                         &disposition
                         );

    if (status == STATUS_OBJECT_NAME_NOT_FOUND && ARGUMENT_PRESENT(BaseHandle)) {
        //
        // If we get to here, then there must be more than one element of the
        // registry path that does not currently exist.  We will now parse the
        // specified path, extracting each component and doing a ZwCreateKey on it.
        //
        handles[baseHandleIndex] = NULL;
        handles[keyHandleIndex] = BaseHandle;
        closeBaseHandle = 0;
        continueParsing = TRUE;
        pathBeginPtr = KeyName->Buffer;
        pathEndPtr = (PWCHAR)((PCHAR)pathBeginPtr + KeyName->Length);
        status = STATUS_SUCCESS;

        while(continueParsing) {
            //
            // There's more to do, so close the previous base handle (if necessary),
            // and replace it with the current key handle.
            //
            if(closeBaseHandle > 1) {
                ZwClose(handles[baseHandleIndex]);
            }
            baseHandleIndex = keyHandleIndex;
            keyHandleIndex = (keyHandleIndex + 1) & 1;  // toggle between 0 and 1.
            handles[keyHandleIndex] = NULL;

            //
            // Extract next component out of the specified registry path.
            //
            for(pathCurPtr = pathBeginPtr;
                ((pathCurPtr < pathEndPtr) && (*pathCurPtr != OBJ_NAME_PATH_SEPARATOR));
                pathCurPtr++);

            if((pathComponentLength = (ULONG)((PCHAR)pathCurPtr - (PCHAR)pathBeginPtr))) {
                //
                // Then we have a non-empty path component (key name).  Attempt
                // to create this key.
                //
                unicodeString.Buffer = pathBeginPtr;
                unicodeString.Length = unicodeString.MaximumLength = (USHORT)pathComponentLength;

                InitializeObjectAttributes(&objectAttributes,
                                           &unicodeString,
                                           OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                           handles[baseHandleIndex],
                                           (PSECURITY_DESCRIPTOR) NULL
                                          );
                status = ZwCreateKey(&(handles[keyHandleIndex]),
                                     DesiredAccess,
                                     &objectAttributes,
                                     0,
                                     (PUNICODE_STRING) NULL,
                                     CreateOptions,
                                     &disposition
                                    );
                if(NT_SUCCESS(status)) {
                    //
                    // Increment the closeBaseHandle value, which basically tells us whether
                    // the BaseHandle passed in has been 'shifted out' of our way, so that
                    // we should start closing our base handles when we're finished with them.
                    //
                    closeBaseHandle++;
                } else {
                    continueParsing = FALSE;
                    continue;
                }
            } else {
                //
                // Either a path separator ('\') was included at the beginning of
                // the path, or we hit 2 consecutive separators.
                //
                status = STATUS_INVALID_PARAMETER;
                continueParsing = FALSE;
                continue;
            }

            if((pathCurPtr == pathEndPtr) ||
               ((pathBeginPtr = pathCurPtr + 1) == pathEndPtr)) {
                //
                // Then we've reached the end of the path
                //
                continueParsing = FALSE;
            }
        }

        if(closeBaseHandle > 1) {
            ZwClose(handles[baseHandleIndex]);
        }
    }

    if(NT_SUCCESS(status)) {
        *Handle = handles[keyHandleIndex];

        if(ARGUMENT_PRESENT(Disposition)) {
            *Disposition = disposition;
        }
    }

    return status;
}

NTSTATUS WmipReadValueKey(
    IN HANDLE Key,
    IN PUNICODE_STRING ValueName,
    IN ULONG ValueType,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *PartialInfoPtr,
    OUT PULONG InfoSizePtr
    )
{
    KEY_VALUE_PARTIAL_INFORMATION PartialInfo;
    ULONG InfoSize;
    PUCHAR Buffer;
    NTSTATUS Status;
    
    InfoSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION);
    Status = ZwQueryValueKey(Key,
                             ValueName,
                             KeyValuePartialInformation,
                                &PartialInfo,
                             InfoSize,
                             &InfoSize);
                         
    if (((Status != STATUS_BUFFER_OVERFLOW) && (! NT_SUCCESS(Status))) ||
         (PartialInfo.Type != ValueType))
    {
        //
        // if there is no value or it is not the correct type then don't
        // return anything
        //
        *PartialInfoPtr = NULL;
        *InfoSizePtr = 0;
    } else {
        //
        // Allocate a buffer to hold the previous and new diags
        //
        Buffer = ExAllocatePoolWithTag(PagedPool, 
                                           InfoSize, 
                                           WMIPSCHEDPOOLTAG);
        
        if (Buffer != NULL)
        {
            Status = ZwQueryValueKey(Key,
                                     ValueName,
                                       KeyValuePartialInformation,
                                     Buffer,
                                     InfoSize,
                                     &InfoSize);
                                 
            if (NT_SUCCESS(Status))                
            {
                *InfoSizePtr = InfoSize;
                *PartialInfoPtr = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
            } else {
                ExFreePool(Buffer);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return(Status);
}


NTSTATUS WmipOpenDiagRegKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING SubKey,
    IN ULONG DesiredAccess,
    IN BOOLEAN CreateIfNeeded,
    OUT PHANDLE Key
    )
{
    HANDLE BaseKey;
    NTSTATUS Status;
    ULONG Disposition;
    PDEVICE_OBJECT PDO;
    
    PAGED_CODE();
        
    Status = WmipGetDevicePDO(DeviceObject, &PDO);
    if (NT_SUCCESS(Status))
    {
        Status = IoOpenDeviceRegistryKey(PDO,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         DesiredAccess,
                                         &BaseKey);
                                     
        if (NT_SUCCESS(Status))
        {
            if (SubKey != NULL)
            {
                if (CreateIfNeeded)
                {
                    Status = WmipCreateRegistryKeyEx(Key,
                                                     BaseKey,
                                                     SubKey,
                                                     DesiredAccess,
                                                     REG_OPTION_NON_VOLATILE,
                                                     &Disposition);
                } else {
                    Status = WmipOpenRegistryKeyEx(Key,
                                               BaseKey,
                                               SubKey,
                                               DesiredAccess);
                }
                ZwClose(BaseKey);
            } else {
                *Key = BaseKey;
            }
        }
        ObDereferenceObject(PDO);
    }
    
    return(Status);
}

BOOLEAN WmipDoesSigMatchDiag(
    IN PSCHEDULEDDIAG Diag,
    IN UCHAR IrpMn,
    IN LPGUID Guid,
    IN ULONG InstanceContextSize,
    IN PUCHAR InstanceContext,
    IN ULONG InstanceIndex,
    IN ULONG MethodId
	)
/*++

Routine Description:

    This routine will determine if the diag passed matches the signature
	passed.		

Arguments:

    Diag is the diag structure to check 
		
    IrpMn is the irp operation to perform
		
    Guid is the guid for the diag request/result
		
    InstanceContextSize is the size of the optional instance context
		
    InstanceContext is a pointer to the optional instance context
		
    InstanceIndex is the instance index
		
    MethodId is the method id if the operation is IRP_MN_EXECUTE_METHOD

Return Value:

    TRUE if signature matches

--*/
{
	BOOLEAN RetVal = FALSE;
	PUCHAR DiagInstanceContext;
	
	if ((Diag->IsValid) &&
        (Diag->IrpMn == IrpMn) &&
        (IsEqualGUID(&Diag->Guid, Guid)) &&
        (Diag->InstanceContextSize == InstanceContextSize) &&
        ((IrpMn != IRP_MN_EXECUTE_METHOD) || (Diag->MethodId == MethodId)))
    {
    	//
		// Diag is valid and the IrpMn, Guid, InstanceContext size 
		// and Method Id match. Now if the InstanceContext data 
		// matches then we have a match.
		//
		if ((InstanceContext == NULL) && 
			(Diag->InstanceContextOffset == 0))
        {
			if (InstanceIndex == Diag->InstanceIndex)
			{
				//
				// There is no instance context, but the instance index
				// match so we have a match
				RetVal = TRUE;
			} 				
				
			//
  			// There is no instance context, but the instance index
			// do not match					
		} else {
   			DiagInstanceContext = OffsetToPtr(Diag, 
	    		                              Diag->InstanceContextOffset);
										  
   			if (RtlCompareMemory(DiagInstanceContext,
                                 InstanceContext,
                                 InstanceContextSize) == InstanceContextSize)
            {
				//
				// There is an instance context and it matches
				//
				RetVal = TRUE;
			}
		}
	}		
	return(RetVal);
}


PSCHEDULEDDIAG WmipFindDiagInBuffer(
    IN PUCHAR DiagList,
    IN ULONG DiagBufferSize,
    IN UCHAR IrpMn,
    IN LPGUID Guid,
    IN ULONG InstanceContextSize,
    IN PUCHAR InstanceContext,
    IN ULONG InstanceIndex,
    IN ULONG MethodId
)
/*++

Routine Description:

    This routine will search the diags in the DiagList buffer for a valid
	diag structure that matches the diag signature

Arguments:

    DiagList is the diag structures to check 
		
    DiagBufferSize is the size of the diag list
		
    IrpMn is the irp operation to perform
		
    Guid is the guid for the diag request/result
		
    InstanceContextSize is the size of the optional instance context
		
    InstanceContext is a pointer to the optional instance context
		
    InstanceIndex is the instance index
		
    MethodId is the method id if the operation is IRP_MN_EXECUTE_METHOD

Return Value:

    pointer to the diag that matches the signature or NULL if none do

--*/
{
	ULONG Offset;
	PSCHEDULEDDIAG Diag;
	
	Offset = 0;
	while (Offset < DiagBufferSize)
	{
		Diag = (PSCHEDULEDDIAG)OffsetToPtr(DiagList, Offset);
		if (WmipDoesSigMatchDiag(Diag,
                                 IrpMn,
                                 Guid,
                                 InstanceContextSize,
                                 InstanceContext,
                                 InstanceIndex,
                                 MethodId))
    	{
			//
			// we have a match, so return the pointer
			//
			return(Diag);
		}
		
		Offset += Diag->NextOffset;
	}
	return(NULL);
}

NTSTATUS WmipUpdateOrAppendDiag(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DiagType,
    IN PUNICODE_STRING DiagSet,
    IN UCHAR IrpMn,
    IN LPGUID Guid,
    IN ULONG InstanceContextSize,
    IN PUCHAR InstanceContext,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG DataSize,
    IN PUCHAR Data
    )
/*++

Routine Description:

    This routine will update or append a new diag to the diag set specified.
	If an existing diag with the same signature exists then the existing
	diag is made invalid and a new diag to replace it is appended. 
		
    CONSIDER: If we reach a threshold of many invalid diags then we may
		      want to repack the buffer.

Arguments:

    DeviceObject is the device object for the device
		
    DiagType is the type of diag, ie SCHEDULED, PERMAMENT or CHECKPOINT
		
    DiagSet is the unique diag set name
		
    IrpMn is the irp operation to perform
		
    Guid is the guid for the diag request/result
		
    InstanceContextSize is the size of the optional instance context
		
    InstanceContext is a pointer to the optional instance context
		
    InstanceIndex is the instance index
		
    MethodId is the method id if the operation is IRP_MN_EXECUTE_METHOD
		
    DataSize is the size of the request/result data
		
    Data is a pointer to the data


Return Value:

    NT status code

--*/
{
    KEY_VALUE_PARTIAL_INFORMATION PartialInfo;
    PKEY_VALUE_PARTIAL_INFORMATION DiagPartialInfo;
    NTSTATUS Status;
    UNICODE_STRING Scheduled;
    ULONG InstanceContextOffset, DataOffset;
    ULONG InfoSize;
    HANDLE Key;
    ULONG DiagSize, SizeNeeded;
    PUCHAR DiagBuffer;
    PSCHEDULEDDIAG Diag;
    PUCHAR Ptr;
    PUCHAR RegDataPtr;
    ULONG RegDataSize;

    PAGED_CODE();
    
    //
    // Get the current contents for the diag set
    //
    Status = WmipOpenDiagRegKey(DeviceObject,
                                    DiagType,
                                    KEY_WRITE | KEY_READ,
                                    TRUE,
                                    &Key);
                                
    if (NT_SUCCESS(Status))
    {
        //
        // Comupte size needed to append the new diagnostic
        //
        InstanceContextOffset = FIELD_OFFSET(SCHEDULEDDIAG, VariableData);
        DataOffset = ((InstanceContextOffset + 7) &~7) + InstanceContextSize;
        DiagSize = ((DataOffset+ 7)&~7) + DataSize;
    
        //
        // Obtain the size of the current diags already setup in the registry
        //
        InfoSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION);
        Status = ZwQueryValueKey(Key,
                                 DiagSet,
                                 KeyValuePartialInformation,
                                 &PartialInfo,
                                 InfoSize,
                                 &InfoSize);
        if (((Status != STATUS_BUFFER_OVERFLOW) && (! NT_SUCCESS(Status))) ||
            (PartialInfo.Type != REG_BINARY))
        {
            //
            // if there is no value or it is not a REG_BINARY then ignore
            // it.
            //
            InfoSize = 0;
            Status = STATUS_SUCCESS;
        }

        //
        // Allocate a buffer to hold the previous and new diags
        //
        SizeNeeded = InfoSize + DiagSize;
        
        DiagBuffer = ExAllocatePoolWithTag(PagedPool, 
                                           SizeNeeded, 
                                           WMIPSCHEDPOOLTAG);
        
        if (DiagBuffer != NULL)
        {
            //
            // If there are previous diagnostics then read them in
            //
            if (InfoSize != 0)
            {
                Status = ZwQueryValueKey(Key,
                                         DiagSet,
                                         KeyValuePartialInformation,
                                         DiagBuffer,
                                         InfoSize,
                                         &InfoSize);
				
                if (NT_SUCCESS(Status))
				{
					//
					// Setup pointers to the diag data
					//
                    DiagPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)DiagBuffer;
                    RegDataPtr = &DiagPartialInfo->Data[0];
                    RegDataSize = DiagPartialInfo->DataLength + DiagSize;
					
					//
					// See if there is a duplicate diag for the
					// diag signature
					//
					Diag = WmipFindDiagInBuffer(RegDataPtr,
                                                DiagPartialInfo->DataLength,
						                        IrpMn,
                                                Guid,
                                                InstanceContextSize,
                                                InstanceContext,
                                                InstanceIndex,
                                                MethodId);
											
                    if (Diag != NULL)
					{
						//
						// There is already a signature so we mark this as
						// invalid
						//
						ASSERT(Diag->IsValid);
						Diag->IsValid = FALSE;
					}
					
				} else {
					//
					// For some reason we failed reading in a second time
					//
					ASSERT(FALSE);
                    RegDataPtr = DiagBuffer;
	    			RegDataSize = DiagSize;
					Status = STATUS_SUCCESS;
				}
            } else {
				//
				// Setup pointers to the diag data
    			//
                RegDataPtr = DiagBuffer;
				RegDataSize = DiagSize;
    	    }
                                 
            if (NT_SUCCESS(Status))
            {                                         
                //
                // Initialize the Diag structure at the end of the diag buffer
                //															
                Diag = (PSCHEDULEDDIAG)OffsetToPtr(DiagBuffer, InfoSize);
                RtlZeroMemory(Diag, DiagSize);
      
				Diag->IsValid = TRUE;
                Diag->NextOffset = DiagSize;
                Diag->IrpMn = IrpMn;
                Diag->Guid = *Guid;
                Diag->MethodId = MethodId;
       
                if (InstanceContext != NULL)
                {
                    //
                    // If there is an instance context then initialize it
                    //
                    Diag->InstanceIndex = InstanceIndex;
                    Diag->InstanceContextOffset = InstanceContextOffset;
                    Diag->InstanceContextSize = InstanceContextSize;
                    Ptr = (PUCHAR)OffsetToPtr(Diag, InstanceContextOffset);
                    RtlCopyMemory(Ptr, InstanceContext, InstanceContextSize);
                }
        
                if (Data != NULL)
                {
                     //
                    // If there is data then initialize it
                    //
                    Diag->DataOffset = DataOffset;
                    Diag->DataSize = DataSize;
                    Ptr = (PUCHAR)OffsetToPtr(Diag, DataOffset);
                    RtlCopyMemory(Ptr, Data, DataSize);
                }
        
                //
                // Write diag buffer back to registry
                //
                Status = ZwSetValueKey(Key,
                                       DiagSet,
                                       0,
                                       REG_BINARY,
                                       RegDataPtr,
                                       RegDataSize);
            }        
            ExFreePool(DiagBuffer);
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        ZwClose(Key);
    }
    return(Status);

}


NTSTATUS IoWMIScheduleDiagnostic(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DiagSet,
    IN UCHAR IrpMn,
    IN LPGUID Guid,
    IN ULONG InstanceContextSize,
    IN PUCHAR InstanceContext,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG DataSize,
    IN PUCHAR Data
    )
{
	NTSTATUS Status;
	UNICODE_STRING Scheduled;
	
    PAGED_CODE();
    
    //
    // Get the current contents for the diag set
    //
    RtlInitUnicodeString(&Scheduled, REGSTR_SCHEDULED);
									
	Status = WmipUpdateOrAppendDiag(DeviceObject,
                                    &Scheduled,
                                    DiagSet,
                                    IrpMn,
                                    Guid,
                                    InstanceContextSize,
                                    InstanceContext,
                                    InstanceIndex,
                                    MethodId,
                                    DataSize,
                                    Data);
		
    return(Status);
}

NTSTATUS IoWMICancelDiagnostic(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DiagSet,
    IN UCHAR IrpMn,
    IN LPGUID Guid,
    IN ULONG InstanceContextSize,
    IN PUCHAR InstanceContext,
    IN ULONG InstanceIndex,
    IN ULONG MethodId
    )
{
    NTSTATUS Status;
    UNICODE_STRING Value;
    HANDLE Key;    
    KEY_VALUE_PARTIAL_INFORMATION PartialInfo;
    PKEY_VALUE_PARTIAL_INFORMATION DiagPartialInfo;
    UNICODE_STRING Scheduled;
    ULONG InstanceContextOffset, DataOffset;
    ULONG InfoSize;
    PUCHAR DiagBuffer;
    PSCHEDULEDDIAG Diag;
    PUCHAR Ptr;
    PUCHAR DiagList;
	ULONG DiagListSize;

    PAGED_CODE();
    
    //
    // Get the current contents for the diag set
    //
    RtlInitUnicodeString(&Scheduled, REGSTR_SCHEDULED);

    Status = WmipOpenDiagRegKey(DeviceObject,
                                    &Scheduled,
                                    KEY_WRITE | KEY_READ,
                                    TRUE,
                                    &Key);
                                
    if (NT_SUCCESS(Status))
    {
        //
        // Obtain the size of the current diags already setup in the registry
        //
        InfoSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION);
        Status = ZwQueryValueKey(Key,
                                 DiagSet,
                                 KeyValuePartialInformation,
                                 &PartialInfo,
                                 InfoSize,
                                 &InfoSize);
			
        if ( ((Status == STATUS_BUFFER_OVERFLOW) || NT_SUCCESS(Status)) &&
             (PartialInfo.Type == REG_BINARY) )
        {
            //
            // Allocate a buffer to hold the diag list
            //
            DiagBuffer = ExAllocatePoolWithTag(PagedPool, 
                                               InfoSize, 
                                               WMIPSCHEDPOOLTAG);
        
            if (DiagBuffer != NULL)
            {
                //
                // Read in all of the diags in the list
                //
                Status = ZwQueryValueKey(Key,
                                         DiagSet,
                                         KeyValuePartialInformation,
                                         DiagBuffer,
                                         InfoSize,
                                         &InfoSize);
				
                if (NT_SUCCESS(Status))
				{
					//
					// Setup pointers to the diag data
					//
                    DiagPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)DiagBuffer;
                    DiagList = &DiagPartialInfo->Data[0];
                    DiagListSize = DiagPartialInfo->DataLength;
					
					//
					// See if there is a duplicate diag for the
					// diag signature
					//
					Diag = WmipFindDiagInBuffer(DiagList,
                                                DiagListSize,
						                        IrpMn,
                                                Guid,
                                                InstanceContextSize,
                                                InstanceContext,
                                                InstanceIndex,
                                                MethodId);
											
                    if (Diag != NULL)
					{
						//
						// There is already a signature so we mark this as
						// invalid or cancelled.
						//
						ASSERT(Diag->IsValid);
						Diag->IsValid = FALSE;
						
                        //
                        // Write diag buffer back to registry
                        //
                        Status = ZwSetValueKey(Key,
                                       DiagSet,
                                       0,
                                       REG_BINARY,
                                       DiagList,
                                       DiagListSize);
					} else {
						Status = STATUS_OBJECT_NAME_NOT_FOUND;
					}
					
				} else {
					//
					// For some reason we failed reading in a second time
					//
					ASSERT(FALSE);
				}
				
                ExFreePool(DiagBuffer);
            } else {
				//
				// Couldn't alloc memory
    			//
				Status = STATUS_INSUFFICIENT_RESOURCES;
    	    }
        } else if (NT_SUCCESS(Status)) {
			//
			// Value is not a REG_BINARY so we skip it and return an error
			//
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
        ZwClose(Key);
    }
    return(Status);
}

NTSTATUS WmipSendMethodDiagRequest(
    PDEVICE_OBJECT DeviceObject,
    PSCHEDULEDDIAG Diag,
    PWNODE_METHOD_ITEM *WnodeMethodPtr
    )
{
    PWNODE_METHOD_ITEM WnodeMethod;
    NTSTATUS Status;
    ULONG SizeNeeded, DataOffset, InstanceOffset;
    BOOLEAN Looping;
    ULONG ProviderId;
    PWCHAR DPtr, SPtr;
    IO_STATUS_BLOCK Iosb;
    
    SizeNeeded = sizeof(WNODE_METHOD_ITEM) + 
                 Diag->InstanceContextSize + 
                 ((Diag->OutDataSize > Diag->DataSize) ? 
                                      Diag->OutDataSize : Diag->DataSize);
                                  

    Looping = TRUE;
    while(Looping)
    {
        WnodeMethod = ExAllocatePoolWithTag(NonPagedPool, 
                                        SizeNeeded,
                                        WMIPSCHEDPOOLTAG);
                                
        if (WnodeMethod != NULL)
        {
            //
            // Build the WNODE to query with
            //
            RtlZeroMemory(WnodeMethod, SizeNeeded);
        
            ProviderId = IoWMIDeviceObjectToProviderId(DeviceObject);
            
            InstanceOffset = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, 
                                          VariableData);
            DataOffset = (InstanceOffset + 
                          Diag->InstanceContextSize  +
                          sizeof(USHORT) + 7) &~7;
            
            WnodeMethod->WnodeHeader.BufferSize = DataOffset;
            WnodeMethod->WnodeHeader.ProviderId = ProviderId;
            WnodeMethod->WnodeHeader.Guid = Diag->Guid;
            WnodeMethod->WnodeHeader.Flags = WNODE_FLAG_METHOD_ITEM |
                                         WNODE_FLAG_DIAG_REQUEST;
            WnodeMethod->InstanceIndex = Diag->InstanceIndex;
            WnodeMethod->OffsetInstanceName = InstanceOffset;
			WnodeMethod->MethodId = Diag->MethodId;
            
            if (Diag->InstanceContextOffset != 0)
            {
                //
                // Copy in any instance context
                //
                DPtr = (PWCHAR)OffsetToPtr(WnodeMethod, InstanceOffset);
                SPtr = (PWCHAR)OffsetToPtr(Diag, Diag->InstanceContextOffset);
                *DPtr++ = (USHORT)Diag->InstanceContextSize;
                RtlCopyMemory(DPtr, SPtr, Diag->InstanceContextSize);
            } else {
                WnodeMethod->WnodeHeader.Flags |= WNODE_FLAG_STATIC_INSTANCE_NAMES;
            }
            
            WnodeMethod->DataBlockOffset = DataOffset;
            WnodeMethod->SizeDataBlock = Diag->DataSize;
            if (Diag->DataSize != 0)
            {
                //
                // Copy in method input data
                //
                DPtr = (PWCHAR)OffsetToPtr(WnodeMethod, DataOffset);
                SPtr = (PWCHAR)OffsetToPtr(Diag, Diag->DataOffset);
                RtlCopyMemory(DPtr, SPtr, Diag->DataSize);
            }
            
            Status = WmipSendWmiIrp(IRP_MN_EXECUTE_METHOD,
                                    ProviderId,
                                    &WnodeMethod->WnodeHeader.Guid,
                                    SizeNeeded,
                                    WnodeMethod,
                                    &Iosb);
                                
            if (NT_SUCCESS(Status))
            {
                if (Iosb.Information == sizeof(WNODE_TOO_SMALL))
                {
                    //
                    // Buffer was too small, so setup to alloc a bigger one
                    //
                    SizeNeeded = ((PWNODE_TOO_SMALL)WnodeMethod)->SizeNeeded;
                     ExFreePool(WnodeMethod);
                } else {
                    //
                    // We have successfully returned from the query
                    //
                    *WnodeMethodPtr = WnodeMethod;
                    Looping = FALSE;
                }
            } else {        
                //
                // Some sort of failure, we just return it to the caller
                //
                ExFreePool(WnodeMethod);
                Looping = FALSE;
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;            
            Looping = FALSE;
        }
    }
    return(Status);
}


NTSTATUS WmipSendQSIDiagRequest(
    PDEVICE_OBJECT DeviceObject,
    PSCHEDULEDDIAG Diag,
    PWNODE_SINGLE_INSTANCE *WnodeSIPtr
    )
{
    PWNODE_SINGLE_INSTANCE WnodeSI;
    NTSTATUS Status;
    ULONG SizeNeeded, DataOffset, InstanceOffset;
    BOOLEAN Looping;
    ULONG ProviderId;
    PWCHAR SPtr, DPtr;
    IO_STATUS_BLOCK Iosb;
    
    SizeNeeded = sizeof(WNODE_SINGLE_INSTANCE) + 
                 Diag->InstanceContextSize + 
                 (Diag->OutDataSize > Diag->DataSize) ? 
                                      Diag->OutDataSize : Diag->DataSize;
    Looping = TRUE;
    while(Looping)
    {
        WnodeSI = ExAllocatePoolWithTag(NonPagedPool, 
                                        SizeNeeded,
                                        WMIPSCHEDPOOLTAG);
                                
        if (WnodeSI != NULL)
        {
            //
            // Build the WNODE to query with
            //
            RtlZeroMemory(WnodeSI, SizeNeeded);
        
            ProviderId = IoWMIDeviceObjectToProviderId(DeviceObject);
            
            InstanceOffset = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, 
                                          VariableData);
            DataOffset = (InstanceOffset + 
                          Diag->InstanceContextSize +
                          sizeof(USHORT) + 7) &~7;
            
            WnodeSI->WnodeHeader.BufferSize = DataOffset;
            WnodeSI->WnodeHeader.ProviderId = ProviderId;
            WnodeSI->WnodeHeader.Guid = Diag->Guid;
            WnodeSI->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE |
                                         WNODE_FLAG_DIAG_REQUEST;
            WnodeSI->InstanceIndex = Diag->InstanceIndex;
            WnodeSI->OffsetInstanceName = InstanceOffset;
            
            if (Diag->InstanceContextOffset != 0)
            {
                //
                // Copy in any instance context
                //
                DPtr = (PWCHAR)OffsetToPtr(WnodeSI, InstanceOffset);
                SPtr = (PWCHAR)OffsetToPtr(Diag, Diag->InstanceContextOffset);
                *DPtr++ = (USHORT)Diag->InstanceContextSize;
                RtlCopyMemory(DPtr, SPtr, Diag->InstanceContextSize);
            } else {
                WnodeSI->WnodeHeader.Flags |= WNODE_FLAG_STATIC_INSTANCE_NAMES;
            }
            WnodeSI->DataBlockOffset = DataOffset;
            
            Status = WmipSendWmiIrp(IRP_MN_QUERY_SINGLE_INSTANCE,
                                    ProviderId,
                                    &WnodeSI->WnodeHeader.Guid,
                                    SizeNeeded,
                                    WnodeSI,
                                    &Iosb);
                                
            if (NT_SUCCESS(Status))
            {
                if (Iosb.Information == sizeof(WNODE_TOO_SMALL))
                {
                    //
                    // Buffer was too small, so setup to alloc a bigger one
                    //
                    SizeNeeded = ((PWNODE_TOO_SMALL)WnodeSI)->SizeNeeded;
                     ExFreePool(WnodeSI);
                } else {
                    //
                    // We have successfully returned from the query
                    //
                    *WnodeSIPtr = WnodeSI;
                    Looping = FALSE;
                }
            } else {        
                //
                // Some sort of failure, we just return it to the caller
                //
                ExFreePool(WnodeSI);
                Looping = FALSE;
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;            
            Looping = FALSE;
        }
    }
    return(Status);
}                                                         

NTSTATUS IoWMIStartScheduledDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DiagSet
    )
{
    NTSTATUS Status, Status2;
    HANDLE Key;
    UNICODE_STRING Scheduled;
    ULONG Index;
    KEY_FULL_INFORMATION KeyFullInfo;
    ULONG ReturnSize;
    PKEY_VALUE_PARTIAL_INFORMATION PartialInfo;
    ULONG InfoSize;
    PUCHAR DiagData;
    ULONG DiagSize;
    PSCHEDULEDDIAG Diag;
    ULONG Offset;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    PWNODE_METHOD_ITEM WnodeMethod;
	UNICODE_STRING Checkpoint;
	PUCHAR InstanceContext;
	PUCHAR Data;
    
    PAGED_CODE();
    
    RtlInitUnicodeString(&Scheduled, REGSTR_SCHEDULED);	
    RtlInitUnicodeString(&Checkpoint, REGSTR_CHECKPOINT);
	
    Status = WmipOpenDiagRegKey(DeviceObject,
                                &Scheduled,
                                KEY_READ,
                                FALSE,
                                &Key);                        
                            
    if (NT_SUCCESS(Status))
    {
        Status = WmipReadValueKey(Key,
                                  DiagSet,
                                  REG_BINARY,
                                  &PartialInfo,
                                  &InfoSize);
                              
        if (NT_SUCCESS(Status))
        {
            //
            // Loop over all Diags in the value and then send them
            // to the device
            //
            DiagData = &PartialInfo->Data[0];
            DiagSize = PartialInfo->DataLength;                
            Offset = 0;
            while (Offset < DiagSize)
            {
                //
                // Send the appropriate diag to the device object
                //
                Diag = (PSCHEDULEDDIAG)OffsetToPtr(DiagData, Offset);
                if (Diag->IsValid)
				{
                    switch(Diag->IrpMn)
                    {
                        case IRP_MN_QUERY_SINGLE_INSTANCE:
                        {
                            PWNODE_SINGLE_INSTANCE WnodeSI;
                            
                            Status2 = WmipSendQSIDiagRequest(DeviceObject,
                                                            Diag,
                                                            &WnodeSI);
                            if (NT_SUCCESS(Status2))
                            {
                                if (Diag->InstanceContextOffset != 0)
                                {
                                    InstanceContext = OffsetToPtr(Diag, 
                                                     Diag->InstanceContextOffset);
                                } else {
                                    InstanceContext = NULL;
                                }
                                                 
                                Data = OffsetToPtr(WnodeSI, 
                                                   WnodeSI->DataBlockOffset);
                                Status2 = WmipUpdateOrAppendDiag(
                                                        DeviceObject,
                                                        &Checkpoint,
                                                        DiagSet,
                                                        Diag->IrpMn,
                                                        &Diag->Guid,
                                                        Diag->InstanceContextSize,
                                                        InstanceContext,
                                                        Diag->InstanceIndex,
                                                        Diag->MethodId,
                                                        WnodeSI->SizeDataBlock,
                                                        Data);
                                                         
                                ExFreePool(WnodeSI);
                            }
                            break;
                        }
                        
                        case IRP_MN_EXECUTE_METHOD:
                        {
                            PWNODE_METHOD_ITEM WnodeMethod;
                            
                            Status2 = WmipSendMethodDiagRequest(DeviceObject,
                                                            Diag,
                                                            &WnodeMethod);
                            if (NT_SUCCESS(Status2))
                            {
                                if (Diag->InstanceContextOffset != 0)
                                {
                                    InstanceContext = OffsetToPtr(Diag, 
                                                     Diag->InstanceContextOffset);
                                } else {
                                    InstanceContext = NULL;
                                }
                                                 
                                Data = OffsetToPtr(WnodeMethod, 
                                                   WnodeMethod->DataBlockOffset);
                                               
                                Status2 = WmipUpdateOrAppendDiag(
                                                      DeviceObject,
                                                      &Checkpoint,
                                                      DiagSet,
                                                      Diag->IrpMn,
                                                      &Diag->Guid,
                                                      Diag->InstanceContextSize,
                                                         InstanceContext,
                                                      Diag->InstanceIndex,
                                                      Diag->MethodId,
                                                      WnodeMethod->SizeDataBlock,
                                                      Data);
                                                         
                                ExFreePool(WnodeMethod);
                            }
                            break;
                        }
                        
                        default:
                        {
                            WmipAssert(FALSE);
                            break;
                        }
                    }
				}
                
                //
                // Advance to next diagnostic in 
                //
                Offset += Diag->NextOffset;
            }
            ExFreePool(PartialInfo);
        }
                              
        ZwClose(Key);            
    }
    return(Status);
}

NTSTATUS IoWMIGetDiagnosticResult(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DiagSet,
    IN UCHAR IrpMn,
    IN LPGUID Guid,
    IN ULONG InstanceContextSize,
    IN PUCHAR InstanceContext,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN OUT ULONG *DataSize,
    OUT PUCHAR Data
    )
{
    NTSTATUS Status;
    UNICODE_STRING Checkpoint;
    HANDLE Key;
    PKEY_VALUE_PARTIAL_INFORMATION PartialInfo;
    ULONG InfoSize;
    PUCHAR DiagList;
    PSCHEDULEDDIAG Diag;
    ULONG DiagSize;
    PUCHAR DataPtr;
    
    PAGED_CODE();
    
    RtlInitUnicodeString(&Checkpoint, REGSTR_CHECKPOINT);
    Status = WmipOpenDiagRegKey(DeviceObject,
                                &Checkpoint,
                                KEY_READ,
                                FALSE,
                                &Key);
                        
                            
    if (NT_SUCCESS(Status))
    {
        Status = WmipReadValueKey(Key,
                                  DiagSet,
                                  REG_BINARY,
                                  &PartialInfo,
                                  &InfoSize);
                              
        if (NT_SUCCESS(Status))
        {
            //
            // See if a diag is available that matches the sig passed
            //
            DiagList = &PartialInfo->Data[0];
            DiagSize = PartialInfo->DataLength;                
            Diag = WmipFindDiagInBuffer(DiagList,
                                        DiagSize,
                                        IrpMn,
                                        Guid,
                                        InstanceContextSize,
                                        InstanceContext,
                                        InstanceIndex,
                                        MethodId);
            if (Diag != NULL)
            {
                if (Diag->DataOffset != 0)
                {
                    if (*DataSize >= Diag->DataSize)
                    {
                        //
                        // There is enough room, so copy out the data
                        //
                        DataPtr = OffsetToPtr(Diag, Diag->DataOffset);
                        RtlCopyMemory(Data, DataPtr, Diag->DataSize);
                    } else {
                        //
                        // Not enough room to return the data
                        //
                        Status = STATUS_BUFFER_TOO_SMALL;
                    }
                    *DataSize = Diag->DataSize;
                } else {
                    //
                    // There is no data for this diag result
                    //
                    *DataSize = 0;
                }
            } else {
                //
                // Diag was not in the list
                //
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }
            
            ExFreePool(PartialInfo);
        }
    }
    
    return(Status);
}

NTSTATUS IoWMISaveDiagnosticResult(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DiagSet,
    IN UCHAR IrpMn,
    IN LPGUID Guid,
    IN ULONG InstanceContextSize,
    IN PUCHAR InstanceContext,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG DataSize,
    IN PUCHAR Data
)
{
    NTSTATUS Status;
    UNICODE_STRING Checkpoint;
    
    PAGED_CODE();
    
    //
    // Write saved diagnostic results into the Checkpoint key
    //
    RtlInitUnicodeString(&Checkpoint, REGSTR_CHECKPOINT);
    Status = WmipUpdateOrAppendDiag(DeviceObject,
                                    &Checkpoint,
                                    DiagSet,
                                    IrpMn,
                                    Guid,
                                    InstanceContextSize,
                                    InstanceContext,
                                    InstanceIndex,
                                    MethodId,
                                    DataSize,
                                    Data);                         
        
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\ds.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ds.c

Abstract:

    WMI data provider registration code

Author:

    AlanWar

Environment:

    Kernel Mode

Revision History:


--*/

#include "wmikmp.h"

#include <strsafe.h>

void WmipEnableCollectionForNewGuid(
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    );

void WmipDisableCollectionForRemovedGuid(
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    );

ULONG WmipDetermineInstanceBaseIndex(
    LPGUID Guid,
    PWCHAR BaseName,
    ULONG InstanceCount
    );

ULONG WmipMangleInstanceName(
    LPGUID Guid,
    PWCHAR Name,
    ULONG MaxMangledNameLen,
    PWCHAR MangledName
    );

NTSTATUS WmipBuildInstanceSet(
    PWMIREGGUID RegGuid,
    PWMIREGINFOW WmiRegInfo,
    ULONG BufferSize,
    PBINSTANCESET InstanceSet,
    ULONG ProviderId,
    LPCTSTR MofImagePath
    );

NTSTATUS WmipLinkDataSourceToList(
    PBDATASOURCE DataSource,
    BOOLEAN AddDSToList
    );

void WmipSendGuidUpdateNotifications(
    NOTIFICATIONTYPES NotificationType,
    ULONG GuidCount,
    PTRCACHE *GuidList
    );

void WmipGenerateBinaryMofNotification(
    PBINSTANCESET BinaryMofInstanceSet,
    LPCGUID Guid        
    );

void WmipGenerateRegistrationNotification(
    PBDATASOURCE DataSource,
    ULONG NotificationCode
    );

NTSTATUS WmipAddMofResource(
    PBDATASOURCE DataSource,
    LPWSTR ImagePath,
    BOOLEAN IsImagePath,
    LPWSTR MofResourceName,
    PBOOLEAN NewMofResource
    );

PBINSTANCESET WmipFindISInDSByGuid(
    PBDATASOURCE DataSource,
    LPGUID Guid
    );

ULONG WmipUpdateAddGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    PBINSTANCESET *AddModInstanceSet
    );

PWCHAR GuidToString(
    PWCHAR s,
    ULONG SizeInBytes,
    LPGUID piid
    );

BOOLEAN WmipUpdateRemoveGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PBINSTANCESET *AddModInstanceSet
    );

BOOLEAN WmipIsEqualInstanceSets(
    PBINSTANCESET InstanceSet1,
    PBINSTANCESET InstanceSet2
    );

ULONG WmipUpdateModifyGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    PBINSTANCESET *AddModInstanceSet
    );

void WmipCachePtrs(
    LPGUID Ptr1,
    PBINSTANCESET Ptr2,
    ULONG *PtrCount,
    ULONG *PtrMax,
    PTRCACHE **PtrArray
    );

NTSTATUS WmipUpdateDataSource(
    PREGENTRY RegEntry,
    PWMIREGINFOW WmiRegInfo,
    ULONG RetSize
    );

void WmipRemoveDataSourceByDS(
    PBDATASOURCE DataSource
    );

NTSTATUS WmipRemoveDataSource(
    PREGENTRY RegEntry
    );

NTSTATUS WmipInitializeDataStructs(
    void
);

NTSTATUS WmipEnumerateMofResources(
    PWMIMOFLIST MofList,
    ULONG BufferSize,
    ULONG *RetSize
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WmipInitializeDataStructs)
#pragma alloc_text(PAGE,WmipEnableCollectionForNewGuid)
#pragma alloc_text(PAGE,WmipDisableCollectionForRemovedGuid)
#pragma alloc_text(PAGE,WmipDetermineInstanceBaseIndex)
#pragma alloc_text(PAGE,WmipMangleInstanceName)
#pragma alloc_text(PAGE,WmipBuildInstanceSet)
#pragma alloc_text(PAGE,WmipLinkDataSourceToList)
#pragma alloc_text(PAGE,WmipSendGuidUpdateNotifications)
#pragma alloc_text(PAGE,WmipGenerateBinaryMofNotification)
#pragma alloc_text(PAGE,WmipGenerateMofResourceNotification)
#pragma alloc_text(PAGE,WmipGenerateRegistrationNotification)
#pragma alloc_text(PAGE,WmipAddMofResource)
#pragma alloc_text(PAGE,WmipAddDataSource)
#pragma alloc_text(PAGE,WmipFindISInDSByGuid)
#pragma alloc_text(PAGE,WmipUpdateAddGuid)
#pragma alloc_text(PAGE,WmipUpdateRemoveGuid)
#pragma alloc_text(PAGE,WmipIsEqualInstanceSets)
#pragma alloc_text(PAGE,WmipUpdateModifyGuid)
#pragma alloc_text(PAGE,WmipCachePtrs)
#pragma alloc_text(PAGE,WmipUpdateDataSource)
#pragma alloc_text(PAGE,WmipRemoveDataSourceByDS)
#pragma alloc_text(PAGE,WmipRemoveDataSource)
#pragma alloc_text(PAGE,WmipEnumerateMofResources)
 
#if DBG
#pragma alloc_text(PAGE,GuidToString)
#endif
#endif


#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

const GUID WmipBinaryMofGuid = BINARY_MOF_GUID;

// {4EE0B301-94BC-11d0-A4EC-00A0C9062910}
const GUID RegChangeNotificationGuid =
{ 0x4ee0b301, 0x94bc, 0x11d0, { 0xa4, 0xec, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 } };


void WmipEnableCollectionForNewGuid(
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    )
{
    WNODE_HEADER Wnode;
    PBGUIDENTRY GuidEntry;
    ULONG Status;
    BOOLEAN IsTraceLog;

    PAGED_CODE();
    
    GuidEntry = WmipFindGEByGuid(Guid, FALSE);

    if (GuidEntry != NULL)
    {
        memset(&Wnode, 0, sizeof(WNODE_HEADER));
        memcpy(&Wnode.Guid, Guid, sizeof(GUID));
        Wnode.BufferSize = sizeof(WNODE_HEADER);

        WmipEnterSMCritSection();
        if ((GuidEntry->EventRefCount > 0) &&
            ((InstanceSet->Flags & IS_ENABLE_EVENT) == 0))

        {
            //
            // Events were previously enabled for this guid, but not for this
            // instance set so call data source for instance set to enable
            // the events. First set the in progress flag and InstanceSet
            // set flag to denote that events have been enabled for the
            // instance set.
            InstanceSet->Flags |= IS_ENABLE_EVENT;

            //
            // If it is Tracelog, NewGuid notifications are piggybacked with
            // Registration call return. 
            //
            IsTraceLog = ((InstanceSet->Flags & IS_TRACED) == IS_TRACED) ? TRUE : FALSE;
            if (IsTraceLog) 
            {
                if (!(InstanceSet->DataSource->Flags & DS_KERNEL_MODE) ) 
                {
                    if (GuidEntry != NULL)
                    {
                        WmipUnreferenceGE(GuidEntry);
                    }
                    WmipLeaveSMCritSection();
                    return;
                }
            
                //
                // For the Kernel Mode Trace Providers pass on the context
                //
                Wnode.HistoricalContext = GuidEntry->LoggerContext;
            }

            GuidEntry->Flags |= GE_FLAG_NOTIFICATION_IN_PROGRESS;

            WmipLeaveSMCritSection();
            WmipDeliverWnodeToDS(IRP_MN_ENABLE_EVENTS,
                                 InstanceSet->DataSource,
                                 &Wnode,
                                 Wnode.BufferSize);
            WmipEnterSMCritSection();

            //
            // Now we need to check if events were disabled while the enable
            // request was in progress. If so go do the work to actually
            // disable them.
            if (GuidEntry->EventRefCount == 0)
            {
                Status = WmipDoDisableRequest(GuidEntry,
                                          TRUE,
                                             IsTraceLog,
                                           GuidEntry->LoggerContext,
                                          GE_FLAG_NOTIFICATION_IN_PROGRESS);

            } else {
                GuidEntry->Flags &= ~GE_FLAG_NOTIFICATION_IN_PROGRESS;
            }
        }

        //
        // Now check to see if collection needs to be enabled for this guid
        //
        if ((GuidEntry->CollectRefCount > 0) &&
            ((InstanceSet->Flags & IS_ENABLE_COLLECTION) == 0)  &&
            (InstanceSet->Flags & IS_EXPENSIVE) )

        {
            //
            // Collection was previously enabled for this guid, but not
            // for this instance set so call data source for instance set
            // to enable collection. First set the in progress flag and
            // InstanceSet set flag to denote that collection has been enabled
            //  for the instance set.
            //
            GuidEntry->Flags |= GE_FLAG_COLLECTION_IN_PROGRESS;
            InstanceSet->Flags |= IS_ENABLE_COLLECTION;

            WmipLeaveSMCritSection();
            WmipDeliverWnodeToDS(IRP_MN_ENABLE_COLLECTION,
                                 InstanceSet->DataSource,
                                 &Wnode,
                                 Wnode.BufferSize);
            WmipEnterSMCritSection();

            //
            // Now we need to check if events were disabled while the enable
            // request was in progress. If so go do the work to actually
            // disable them.
            //
            if (GuidEntry->CollectRefCount == 0)
            {
                Status = WmipDoDisableRequest(GuidEntry,
                                          FALSE,
                                             FALSE,
                                           0,
                                          GE_FLAG_COLLECTION_IN_PROGRESS);

            } else {
                GuidEntry->Flags &= ~GE_FLAG_COLLECTION_IN_PROGRESS;
        
                //
                   // If there are any other threads that were waiting 
                // until all of the enable/disable work completed, we 
                // close the event handle to release them from their wait.
                //
                WmipReleaseCollectionEnabled(GuidEntry);
            }
        }
        WmipUnreferenceGE(GuidEntry);
        WmipLeaveSMCritSection();
    } else {
        WmipAssert(FALSE);
    }
}

void WmipDisableCollectionForRemovedGuid(
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    )
{
    WNODE_HEADER Wnode;
    PBGUIDENTRY GuidEntry;
    ULONG Status;
    BOOLEAN IsTraceLog;

    PAGED_CODE();
    
    GuidEntry = WmipFindGEByGuid(Guid, FALSE);

    if (GuidEntry != NULL)
    {
        memset(&Wnode, 0, sizeof(WNODE_HEADER));
        memcpy(&Wnode.Guid, Guid, sizeof(GUID));
        Wnode.BufferSize = sizeof(WNODE_HEADER);

        WmipEnterSMCritSection();

        if ((GuidEntry->EventRefCount > 0) &&
               ((InstanceSet->Flags & IS_ENABLE_EVENT) != 0))

        {
            // Events were previously enabled for this guid, but not for this
            // instance set so call data source for instance set to enable
            // the events. First set the in progress flag and InstanceSet
            // set flag to denote that events have been enabled for the
            // instance set.
            InstanceSet->Flags &= ~IS_ENABLE_EVENT;

            //
            // If it is Tracelog, RemoveGuid notifications are handled
            // through UnregisterGuids call. 
            //
            IsTraceLog = ((InstanceSet->Flags & IS_TRACED) == IS_TRACED) ? TRUE : FALSE;
            if (IsTraceLog)
            {
                if ( !(InstanceSet->DataSource->Flags & DS_KERNEL_MODE)) 
                {
                    WmipUnreferenceGE(GuidEntry);
                    WmipLeaveSMCritSection();
                    return;
                }
                Wnode.HistoricalContext = GuidEntry->LoggerContext;
            }


            GuidEntry->Flags |= GE_FLAG_NOTIFICATION_IN_PROGRESS;

            WmipLeaveSMCritSection();
            WmipDeliverWnodeToDS(IRP_MN_DISABLE_EVENTS,
                                 InstanceSet->DataSource,
                                 &Wnode,
                                 Wnode.BufferSize);
            WmipEnterSMCritSection();

            //
            // Now we need to check if events were disabled while the enable
            // request was in progress. If so go do the work to actually
            // disable them.
            if (GuidEntry->EventRefCount == 0)
            {
                Status = WmipDoDisableRequest(GuidEntry,
                                          TRUE,
                                             IsTraceLog,
                                           GuidEntry->LoggerContext,
                                          GE_FLAG_NOTIFICATION_IN_PROGRESS);

            } else {
                GuidEntry->Flags &= ~GE_FLAG_NOTIFICATION_IN_PROGRESS;
            }
        }

        //
        // Now check to see if collection needs to be enabled for this guid
        if ((GuidEntry->CollectRefCount > 0) &&
            ((InstanceSet->Flags & IS_ENABLE_COLLECTION) != 0))

        {
            // Collection was previously enabled for this guid, but not
            // for this instance set so call data source for instance set
            // to enable collection. First set the in progress flag and
            // InstanceSet set flag to denote that collection has been enabled
            //  for the instance set.
            GuidEntry->Flags |= GE_FLAG_COLLECTION_IN_PROGRESS;
            InstanceSet->Flags &= ~IS_ENABLE_COLLECTION;

            WmipLeaveSMCritSection();
            WmipDeliverWnodeToDS(IRP_MN_DISABLE_COLLECTION,
                                 InstanceSet->DataSource,
                                 &Wnode,
                                 Wnode.BufferSize);
            WmipEnterSMCritSection();

            //
            // Now we need to check if events were disabled while the enable
            // request was in progress. If so go do the work to actually
            // disable them.
            if (GuidEntry->CollectRefCount == 0)
            {
                Status = WmipDoDisableRequest(GuidEntry,
                                          FALSE,
                                             FALSE,
                                           0,
                                          GE_FLAG_COLLECTION_IN_PROGRESS);

            } else {
                GuidEntry->Flags &= ~GE_FLAG_COLLECTION_IN_PROGRESS;
        
                //
                // If there are any other threads that were waiting 
                // until all of the enable/disable work completed, we 
                // close the event handle to release them from their wait.
                //
                WmipReleaseCollectionEnabled(GuidEntry);
            }
        }
        WmipUnreferenceGE(GuidEntry);
        WmipLeaveSMCritSection();
    } else {
        WmipAssert(FALSE);
    }
}

ULONG WmipDetermineInstanceBaseIndex(
    LPGUID Guid,
    PWCHAR BaseName,
    ULONG InstanceCount
    )
/*++

Routine Description:

    Figure out the base index for the instance names specified by a base
    instance name. We walk the list of instances sets for the guid and if
    there is a match in the base instance name we set the base instance index
    above that used by the previously registered instance set.

Arguments:

    Guid points at guid for the instance names
    BaseName points at the base name for the instances
    InstanceCount is the count of instance names

Return Value:

    Base index for instance name

--*/
{
    PBGUIDENTRY GuidEntry;
    ULONG BaseIndex = 0;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    ULONG LastBaseIndex;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (InstanceCount);

    WmipEnterSMCritSection();
    
    GuidEntry = WmipFindGEByGuid(Guid, FALSE);
    if (GuidEntry != NULL)
    {
        InstanceSetList = GuidEntry->ISHead.Flink;
        while (InstanceSetList != &GuidEntry->ISHead)
        {
            InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
            if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
            {
                if (wcscmp(BaseName, InstanceSet->IsBaseName->BaseName) == 0)
                {
                    LastBaseIndex = InstanceSet->IsBaseName->BaseIndex + InstanceSet->Count;
                    if (BaseIndex <= LastBaseIndex)
                    {
                        BaseIndex = LastBaseIndex;
                    }
                }
            }
            InstanceSetList = InstanceSetList->Flink;
        }
        WmipUnreferenceGE(GuidEntry);
    }
    
    WmipLeaveSMCritSection();
    
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Static instance name %ws has base index %x\n",
                    BaseName, BaseIndex));
    return(BaseIndex);
}

ULONG WmipMangleInstanceName(
    LPGUID Guid,
    PWCHAR Name,
    ULONG MaxMangledNameLen,
    PWCHAR MangledName
    )
/*++

Routine Description:

    Copies a static instance name from the input buffer to the output
    buffer, mangling it if the name collides with another name for the
    same guid.

Arguments:

    Guid points at guid for the instance name
    Name points at the proposed instance name
    MaxMangledNameLen has the maximum number of chars in mangled name buffer
    MangledName points at buffer to return mangled name

Return Value:

    Actual length of mangled name

--*/
{
    PBGUIDENTRY GuidEntry;
    WCHAR ManglingChar;
    ULONG ManglePos;
    ULONG InstanceIndex;
    PBINSTANCESET InstanceSet;

    PAGED_CODE();
    
    WmipAssert(MaxMangledNameLen >= wcslen(Name));

    wcsncpy(MangledName, Name, MaxMangledNameLen);

    GuidEntry = WmipFindGEByGuid(Guid, FALSE);

    if (GuidEntry != NULL)
    {
        ManglePos = (ULONG)wcslen(MangledName)-1;
        ManglingChar = L'Z';

        //
        // Loop until we get a unique name
        InstanceSet = WmipFindISinGEbyName(GuidEntry,
                                           MangledName,
                                           &InstanceIndex);
        while (InstanceSet != NULL)
        {
            WmipUnreferenceIS(InstanceSet);
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Need to mangle name %ws\n",
                                MangledName));
            if (ManglingChar == L'Z')
            {
                ManglingChar = L'A';
                if (++ManglePos == MaxMangledNameLen)
                {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Instance Name could not be mangled\n"));
                    break;
                }
                MangledName[ManglePos+1] = UNICODE_NULL;
            } else {
                ManglingChar++;
            }
            MangledName[ManglePos] = ManglingChar;
            InstanceSet = WmipFindISinGEbyName(GuidEntry,
                                               MangledName,
                                               &InstanceIndex) ;
        }
        WmipUnreferenceGE(GuidEntry);
    }

    return(ULONG)(wcslen(MangledName)+1);
}


NTSTATUS WmipBuildInstanceSet(
    PWMIREGGUID RegGuid,
    PWMIREGINFOW WmiRegInfo,
    ULONG BufferSize,
    PBINSTANCESET InstanceSet,
    ULONG ProviderId,
    LPCTSTR MofImagePath
    )
{
    PWCHAR InstanceName, InstanceNamePtr;
    PBISBASENAME IsBaseName;
    PBISSTATICNAMES IsStaticName;
    ULONG SizeNeeded;
    ULONG SuffixSize;
    PWCHAR StaticNames;
    ULONG Len;
    ULONG InstanceCount;
    ULONG j;
    ULONG MaxStaticInstanceNameSize;
    PWCHAR StaticInstanceNameBuffer;
    ULONG InstanceNameOffset;
    NTSTATUS Status;

    PAGED_CODE();
    
    UNREFERENCED_PARAMETER (MofImagePath);

    //
    // Remember the count of instances for the guid in the DS
    //
    InstanceCount = RegGuid->InstanceCount;
    InstanceSet->Count = InstanceCount;

    InstanceSet->ProviderId = ProviderId;
    
    //
    // Reset any flags that might be changed by a new REGGUID
    //
    InstanceSet->Flags &= ~(IS_EXPENSIVE |
                            IS_EVENT_ONLY |
                            IS_PDO_INSTANCENAME |
                            IS_INSTANCE_STATICNAMES |
                            IS_INSTANCE_BASENAME);

    //
    // Finish initializing the Instance Set flags
    //
    if (RegGuid->Flags & WMIREG_FLAG_EXPENSIVE)
    {
        InstanceSet->Flags |= IS_EXPENSIVE;
    }

    if (RegGuid->Flags & WMIREG_FLAG_TRACED_GUID)
    {
        //
        // This guid is not queryable, but is used for sending trace
        // events. We mark the InstanceSet as special
        InstanceSet->Flags |= IS_TRACED;

        if (RegGuid->Flags & WMIREG_FLAG_TRACE_CONTROL_GUID)
        {
            InstanceSet->Flags |= IS_CONTROL_GUID;
        }
    }

    if (RegGuid->Flags & WMIREG_FLAG_EVENT_ONLY_GUID)
    {
        //
        // This guid is not queryable, but is only used for sending
        // events. We mark the InstanceSet as special
        InstanceSet->Flags |= IS_EVENT_ONLY;
    }

    InstanceName = (LPWSTR)OffsetToPtr(WmiRegInfo,
                                       RegGuid->BaseNameOffset);

    InstanceNameOffset = RegGuid->BaseNameOffset;
    if (RegGuid->Flags & WMIREG_FLAG_INSTANCE_LIST)
    {
        //
        // We have static list of instance names that might need mangling
        // We assume that any name mangling that must occur can be
        // done with a suffix of 5 or fewer characters. This allows
        // up to 100,000 identical static instance names within the
        // same guid. First lets get the amount of memory we'll need
        //
        SizeNeeded = FIELD_OFFSET(ISSTATICENAMES, StaticNamePtr) + 1;
        SuffixSize = MAXBASENAMESUFFIXSIZE;
        MaxStaticInstanceNameSize = 0;
        for (j = 0; j < InstanceCount; j++)
        {
            Status = WmipValidateWmiRegInfoString(WmiRegInfo,
                                                  BufferSize,
                                                  InstanceNameOffset,
                                                  &InstanceNamePtr);
                        
            if ((! NT_SUCCESS(Status)) || (InstanceNamePtr == NULL))
            {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipAddDataSource: bad static instance name %x\n", InstanceNamePtr));
                WmipReportEventLog(EVENT_WMI_INVALID_REGINFO,
                                       EVENTLOG_WARNING_TYPE,
                                       0,
                                       WmiRegInfo->BufferSize,
                                       WmiRegInfo,
                                       1,
                                       MofImagePath ? MofImagePath : TEXT("Unknown"));
                return(STATUS_INVALID_PARAMETER);
            }

            if (*InstanceNamePtr > MaxStaticInstanceNameSize)
            {
                MaxStaticInstanceNameSize = *InstanceNamePtr;
            }
            SizeNeeded += *InstanceNamePtr + 1 + SuffixSize +
                            (sizeof(PWCHAR) / sizeof(WCHAR));
                        
            InstanceNameOffset += *InstanceNamePtr + 2;
        }

        IsStaticName = (PBISSTATICNAMES)WmipAllocString(SizeNeeded);
        if (IsStaticName == NULL)
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipAddDataSource: alloc static instance names\n"));
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        InstanceSet->Flags |= IS_INSTANCE_STATICNAMES;
        InstanceSet->IsStaticNames = IsStaticName;
        StaticNames = (PWCHAR) ((PUCHAR)IsStaticName +
                                 (InstanceCount * sizeof(PWCHAR)));
        InstanceNamePtr = InstanceName;
        StaticInstanceNameBuffer = WmipAlloc(MaxStaticInstanceNameSize + sizeof(WCHAR));
        if (StaticInstanceNameBuffer == NULL)
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipAddDataSource: couldn't alloc StaticInstanceNameBuffer\n"));
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        for (j = 0; j < InstanceCount; j++)
        {
            IsStaticName->StaticNamePtr[j] = StaticNames;
            memcpy(StaticInstanceNameBuffer, InstanceNamePtr+1, *InstanceNamePtr);
            StaticInstanceNameBuffer[*InstanceNamePtr/sizeof(WCHAR)] = UNICODE_NULL;
            Len = WmipMangleInstanceName(&RegGuid->Guid,
                                        StaticInstanceNameBuffer,
                                       *InstanceNamePtr +
                                          SuffixSize + 1,
                                        StaticNames);
            StaticNames += Len;
            InstanceNamePtr += (*((USHORT *)InstanceNamePtr) + 2)/sizeof(WCHAR);
        }

        WmipFree(StaticInstanceNameBuffer);
    } else if (RegGuid->Flags & WMIREG_FLAG_INSTANCE_BASENAME) {
        //
        // We have static instance names built from a base name

        Status = WmipValidateWmiRegInfoString(WmiRegInfo,
                                                  BufferSize,
                                                  InstanceNameOffset,
                                                  &InstanceNamePtr);
                        
        if (! NT_SUCCESS(Status))
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipAddDataSource: Invalid instance base name %x\n",
                                    InstanceName));
            WmipReportEventLog(EVENT_WMI_INVALID_REGINFO,
                                       EVENTLOG_WARNING_TYPE,
                                       0,
                                       WmiRegInfo->BufferSize,
                                       WmiRegInfo,
                                       1,
                                       MofImagePath ? MofImagePath : TEXT("Unknown"));
            return(STATUS_INVALID_PARAMETER);
        }

        InstanceSet->Flags |= IS_INSTANCE_BASENAME;

        if (RegGuid->Flags & WMIREG_FLAG_INSTANCE_PDO)
        {
            InstanceSet->Flags |= IS_PDO_INSTANCENAME;
        }

        IsBaseName = (PBISBASENAME)WmipAlloc(*InstanceName +
                                              sizeof(WCHAR) +
                                              FIELD_OFFSET(ISBASENAME, 
                                                           BaseName));
        if (IsBaseName == NULL)
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipAddDataSource: alloc ISBASENAME failed\n"));
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        InstanceSet->IsBaseName = IsBaseName;

        memcpy(IsBaseName->BaseName, InstanceName+1, *InstanceName);
        IsBaseName->BaseName[*InstanceName/sizeof(WCHAR)] = UNICODE_NULL;
        IsBaseName->BaseIndex = WmipDetermineInstanceBaseIndex(
                                                    &RegGuid->Guid,
                                                    IsBaseName->BaseName,
                                                    RegGuid->InstanceCount);

    }
    return(STATUS_SUCCESS);
}

NTSTATUS WmipLinkDataSourceToList(
    PBDATASOURCE DataSource,
    BOOLEAN AddDSToList
    )
/*++

Routine Description:

    This routine will take a DataSource that was just registered or updated
    and link any new InstanceSets to an appropriate GuidEntry. Then if the
    AddDSToList is TRUE the DataSource itself will be added to the main
    data source list.

    This routine will do all of the linkages within a critical section so the
    data source and its new instances are added atomically. The routine will
    also determine if the guid entry associated with a InstanceSet is a
    duplicate of another that is already on the main guid entry list and if
    so will use the preexisting guid entry.

    This routine assumes that the SM critical section has been taken

Arguments:

    DataSource is a based pointer to a DataSource structure

    AddDSToList    is TRUE then data source will be added to the main list
        of data sources

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;
    PBGUIDENTRY GuidEntry;

    PAGED_CODE();
    
    InstanceSetList = DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        DSISList);
        //
        // If this instance set has just been registered then we need to
        // get it on a GuidEntry list.
        if (InstanceSet->Flags & IS_NEWLY_REGISTERED)
        {
            //
            // See if there is already a GUID entry for the instance set.
            // If not go allocate a new guid entry and place it on the
            // main guid list. If there already is a GuidEntry for the
            // InstanceSet we will assign the ref count that was given by
            // the WmipFindGEByGuid to the DataSource which will unreference
            // the GuidEntry when the DataSource is unregistered.
            GuidEntry = WmipFindGEByGuid((LPGUID)InstanceSet->GuidEntry, 
                                          FALSE);
            if (GuidEntry == NULL)
            {
                GuidEntry = WmipAllocGuidEntry();
                if (GuidEntry == NULL)
                {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipLinkDataSourceToList: WmipAllocGuidEntry failed\n"));
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }

                //
                // Initialize the new GuidEntry and place it on the master
                // GuidEntry list.
                memcpy(&GuidEntry->Guid,
                       (LPGUID)InstanceSet->GuidEntry,
                       sizeof(GUID));
           
                InsertHeadList(WmipGEHeadPtr, &GuidEntry->MainGEList);
            }
            InstanceSet->GuidEntry = GuidEntry;
            InstanceSet->Flags &= ~IS_NEWLY_REGISTERED;
            InsertTailList(&GuidEntry->ISHead, &InstanceSet->GuidISList);
            GuidEntry->ISCount++;
        }

        InstanceSetList = InstanceSetList->Flink;
    }


    if (AddDSToList)
    {
        WmipAssert(! (DataSource->Flags & FLAG_ENTRY_ON_INUSE_LIST));

        DataSource->Flags |= FLAG_ENTRY_ON_INUSE_LIST;
        InsertTailList(WmipDSHeadPtr, &DataSource->MainDSList);
    }

    return(STATUS_SUCCESS);
}

void WmipSendGuidUpdateNotifications(
    NOTIFICATIONTYPES NotificationType,
    ULONG GuidCount,
    PTRCACHE *GuidList
    )
{
    PUCHAR WnodeBuffer;
    PWNODE_SINGLE_INSTANCE Wnode;
    ULONG WnodeSize;
    LPGUID GuidPtr;
    ULONG i;
    PWCHAR InstanceName;
    PMSWmi_GuidRegistrationInfo RegInfo;
    ULONG DataBlockSize;
    GUID RegChangeGuid = MSWmi_GuidRegistrationInfoGuid;
#define REGUPDATENAME L"REGUPDATEINFO"

    PAGED_CODE();

    DataBlockSize = sizeof(MSWmi_GuidRegistrationInfo) +
                    GuidCount*sizeof(GUID) - sizeof(GUID);

    WnodeSize = sizeof(WNODE_SINGLE_INSTANCE) +
                sizeof(USHORT) + sizeof(REGUPDATENAME) + 8 + DataBlockSize;
    
    WnodeBuffer = WmipAlloc(WnodeSize);
    if (WnodeBuffer != NULL)
    {
        Wnode = (PWNODE_SINGLE_INSTANCE)WnodeBuffer;

        //
        // Setup a WNODE_SINGLE_INSTANCE event with the updated guid
        // registration information
        //
        memset(Wnode, 0, sizeof(WNODE_HEADER));
        Wnode->WnodeHeader.Guid = RegChangeGuid;
        Wnode->WnodeHeader.BufferSize = WnodeSize;
        Wnode->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE |
                                   WNODE_FLAG_EVENT_ITEM;
        Wnode->OffsetInstanceName = sizeof(WNODE_SINGLE_INSTANCE);
        Wnode->DataBlockOffset = ((Wnode->OffsetInstanceName +
                                   sizeof(USHORT) + sizeof(REGUPDATENAME) + 7) & ~7);
        Wnode->SizeDataBlock = DataBlockSize;

        InstanceName = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
        *InstanceName++ = sizeof(REGUPDATENAME);
        StringCbCopy(InstanceName, sizeof(REGUPDATENAME), REGUPDATENAME);

        RegInfo = (PMSWmi_GuidRegistrationInfo)OffsetToPtr(Wnode,
                                                       Wnode->DataBlockOffset);
        RegInfo->Operation = NotificationType; 
        RegInfo->GuidCount = GuidCount;
        
        GuidPtr = (LPGUID)RegInfo->GuidList;
        for (i = 0; i < GuidCount; i++)
        {
            *GuidPtr++ =  *GuidList[i].Guid;
        }

        WmipProcessEvent((PWNODE_HEADER)Wnode, TRUE, FALSE);

        WmipFree(WnodeBuffer);
    }

}


void WmipGenerateBinaryMofNotification(
    PBINSTANCESET BinaryMofInstanceSet,
    LPCGUID Guid        
    )
{
    PWNODE_SINGLE_INSTANCE Wnode;
    SIZE_T ImagePathLen, ResourceNameLen, InstanceNameLen, BufferSize;
    PWCHAR Ptr;
    ULONG i;
    HRESULT hr;

    PAGED_CODE();
    
    if (BinaryMofInstanceSet->Count == 0)
    {
        return;
    }

    for (i = 0; i < BinaryMofInstanceSet->Count; i++)
    {
        ImagePathLen = sizeof(USHORT);
        InstanceNameLen = (sizeof(USHORT) + 7) & ~7;

        if (BinaryMofInstanceSet->Flags & IS_INSTANCE_STATICNAMES)
        {
            ResourceNameLen = ((wcslen(BinaryMofInstanceSet->IsStaticNames->StaticNamePtr[i])+1) * sizeof(WCHAR)) + sizeof(USHORT);
        } else if (BinaryMofInstanceSet->Flags & IS_INSTANCE_BASENAME) {
            ResourceNameLen = (((wcslen(BinaryMofInstanceSet->IsBaseName->BaseName) +
                             MAXBASENAMESUFFIXSIZE) * sizeof(WCHAR)) + sizeof(USHORT));
        } else {
            return;
        }

        BufferSize = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData) +
                      InstanceNameLen +
                      ImagePathLen +
                      ResourceNameLen;

        Wnode = (PWNODE_SINGLE_INSTANCE)WmipAlloc(BufferSize);
        if (Wnode != NULL)
        {
            Wnode->WnodeHeader.BufferSize = (ULONG) BufferSize;
            Wnode->WnodeHeader.ProviderId = MOFEVENT_ACTION_BINARY_MOF;
            Wnode->WnodeHeader.Version = 1;
            Wnode->WnodeHeader.Linkage = 0;
            Wnode->WnodeHeader.Flags = (WNODE_FLAG_EVENT_ITEM |
                                        WNODE_FLAG_SINGLE_INSTANCE);
            memcpy(&Wnode->WnodeHeader.Guid,
                   Guid,
                   sizeof(GUID));
            WmiInsertTimestamp(&Wnode->WnodeHeader);
            Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                 VariableData);
            Wnode->DataBlockOffset = (ULONG)(Wnode->OffsetInstanceName + 
                                      InstanceNameLen);
            Wnode->SizeDataBlock = (ULONG)(ImagePathLen + ResourceNameLen);
            Ptr = (PWCHAR)&Wnode->VariableData;

            *Ptr++ = 0;              // Empty instance name
            
            Ptr = (PWCHAR)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
            *Ptr++ = 0;              // Empty image path

            // Instance name for binary mof resource
            ResourceNameLen -= sizeof(USHORT);
            if (BinaryMofInstanceSet->Flags & IS_INSTANCE_STATICNAMES)
            {
                *Ptr++ = (USHORT)ResourceNameLen;
                hr = StringCbCopy(Ptr,
                             ResourceNameLen,
                             BinaryMofInstanceSet->IsStaticNames->StaticNamePtr[i]);
                WmipAssert(hr == S_OK);
            } else if (BinaryMofInstanceSet->Flags & IS_INSTANCE_BASENAME) {
                hr = (USHORT)StringCbPrintfEx(Ptr+1,
                                                ResourceNameLen,
                                                NULL,
                                                NULL,
                                                STRSAFE_FILL_BEHIND_NULL,
                                                L"%ws%d",
                                                BinaryMofInstanceSet->IsBaseName->BaseName,
                                                BinaryMofInstanceSet->IsBaseName->BaseIndex+i) * sizeof(WCHAR);
                WmipAssert(hr == S_OK);
                *Ptr = (USHORT)ResourceNameLen;
            }

            WmipProcessEvent((PWNODE_HEADER)Wnode, TRUE, FALSE);
            WmipFree(Wnode);
        }
    }
}

void WmipGenerateMofResourceNotification(
    LPWSTR ImagePath,
    LPWSTR ResourceName,
    LPCGUID Guid,
    ULONG ActionCode
    )
{
    PWNODE_SINGLE_INSTANCE Wnode;
    SIZE_T ImagePathLen, ResourceNameLen, InstanceNameLen, BufferSize;
    PWCHAR Ptr;

    PAGED_CODE();

    ImagePathLen = (wcslen(ImagePath) + 2) * sizeof(WCHAR);

    ResourceNameLen = (wcslen(ResourceName) + 2) * sizeof(WCHAR);
    InstanceNameLen = ( sizeof(USHORT)+7 ) & ~7;
    BufferSize = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData) +
                      InstanceNameLen +
                      ImagePathLen +
                      ResourceNameLen;

    Wnode = (PWNODE_SINGLE_INSTANCE)WmipAlloc(BufferSize);
    if (Wnode != NULL)
    {
        Wnode->WnodeHeader.BufferSize = (ULONG) BufferSize;
        Wnode->WnodeHeader.ProviderId = ActionCode;
        Wnode->WnodeHeader.Version = 1;
        Wnode->WnodeHeader.Linkage = 0;
        Wnode->WnodeHeader.Flags = (WNODE_FLAG_EVENT_ITEM |
                                    WNODE_FLAG_SINGLE_INSTANCE |
                                    WNODE_FLAG_INTERNAL);
        memcpy(&Wnode->WnodeHeader.Guid,
               Guid,
               sizeof(GUID));
        WmiInsertTimestamp(&Wnode->WnodeHeader);
        Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                 VariableData);
        Wnode->DataBlockOffset = (ULONG)(Wnode->OffsetInstanceName + InstanceNameLen);
        Wnode->SizeDataBlock = (ULONG)(ImagePathLen + ResourceNameLen);
        Ptr = (PWCHAR)&Wnode->VariableData;

        *Ptr = 0;              // Empty instance name

                                 // ImagePath name
        Ptr = (PWCHAR)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
        ImagePathLen -= sizeof(USHORT);
        *Ptr++ = (USHORT)ImagePathLen;
        memcpy(Ptr, ImagePath, ImagePathLen);
        Ptr += (ImagePathLen / sizeof(WCHAR));

                                 // MofResource Name
        ResourceNameLen -= sizeof(USHORT);
        *Ptr++ = (USHORT)ResourceNameLen;
        memcpy(Ptr, ResourceName, ResourceNameLen);

        WmipProcessEvent((PWNODE_HEADER)Wnode, TRUE, FALSE);
        WmipFree(Wnode);
    }
}

void WmipGenerateRegistrationNotification(
    PBDATASOURCE DataSource,
    NOTIFICATIONTYPES NotificationType
    )
{
    PTRCACHE *Guids;
    ULONG GuidCount, GuidMax;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    LPGUID Guid;

    PAGED_CODE();
    
    WmipReferenceDS(DataSource);

    //
    // Loop over all instance sets for this data source
    //
    GuidCount = 0;
    GuidMax = 0;
    Guids = NULL;
    InstanceSetList =  DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {

        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        DSISList);

        //
        // Cache the guid and instance set so we can send registration
        // change notifications
        //
        Guid = &InstanceSet->GuidEntry->Guid;
        WmipCachePtrs(Guid,
                      InstanceSet,
                      &GuidCount,
                      &GuidMax,
                      &Guids);

        //
        // If we are adding a guid and it is already enabled then we
        // need to send an enable irp. Likewise if the guid is being
        // removed and is enabled then we need to send a disable
        //
        if (NotificationType == RegistrationAdd)
        {
            WmipEnableCollectionForNewGuid(Guid, InstanceSet);
        } else if (NotificationType == RegistrationDelete) {
            WmipDisableCollectionForRemovedGuid(Guid, InstanceSet);
        }

        InstanceSetList = InstanceSetList->Flink;
    }

    //
    // Send out event that informs about guid registration changes
    //
    WmipSendGuidUpdateNotifications(NotificationType,
                                    GuidCount,
                                    Guids);

    if (Guids != NULL)
    {
        WmipFree(Guids);
    }
    
    WmipUnreferenceDS(DataSource);
}

NTSTATUS WmipAddMofResource(
    PBDATASOURCE DataSource,
    LPWSTR ImagePath,
    BOOLEAN IsImagePath,
    LPWSTR MofResourceName,
    PBOOLEAN NewMofResource
    )
/*++

Routine Description:

    This routine will build MOFCLASSINFO structures for each guid that is 
    described in the MOF for the data source. If there are any errors in the
    mof resource then no mof information from the resource is retained and the
    resource data is unloaded. 

Arguments:

    DataSource is the data source structure of the data provider
        
    ImagePath points at a string that has the full path to the image
        file that contains the MOF resource
            
    MofResourceName points at a string that has the name of the MOF
        resource
        
Return Value:


--*/        
{
    PMOFRESOURCE MofResource;
    ULONG NewMofResourceCount;
    ULONG i;
    BOOLEAN FreeBuffer;
    size_t RegPathLen, ResNameLen;
    HRESULT hr;

    PAGED_CODE();
    
    MofResource = WmipFindMRByNames(ImagePath, 
                                    MofResourceName);
                     
    if (MofResource == NULL)
    {
        //
        // Mof Resource not previously specified, so allocate a new one
        MofResource = WmipAllocMofResource();
        if (MofResource == NULL)
        {    
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        if (IsImagePath)
        {
            MofResource->Flags |= MR_FLAG_USER_MODE;
        }

        RegPathLen = (wcslen(ImagePath)+1) * sizeof(WCHAR);
        MofResource->RegistryPath = WmipAlloc(RegPathLen);
        ResNameLen = (wcslen(MofResourceName) + 1) * sizeof(WCHAR);
        MofResource->MofResourceName = WmipAlloc(ResNameLen);

        if ((MofResource->RegistryPath == NULL) || 
            (MofResource->MofResourceName == NULL))
        {
            //
            // Allocation cleanup routine will free any memory alloced for MR
            WmipUnreferenceMR(MofResource);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    
        hr = StringCbCopy(MofResource->RegistryPath, RegPathLen, ImagePath);
        WmipAssert(hr == S_OK);
        hr = StringCbCopy(MofResource->MofResourceName, ResNameLen, MofResourceName);
        WmipAssert(hr == S_OK);

        WmipEnterSMCritSection();
        InsertTailList(WmipMRHeadPtr, &MofResource->MainMRList);
        WmipLeaveSMCritSection();
        *NewMofResource = TRUE;
    } else {
        *NewMofResource = FALSE;
    }
    
    if (DataSource != NULL)
    {
        WmipEnterSMCritSection();
        for (i = 0; i < DataSource->MofResourceCount; i++)
        {
            if (DataSource->MofResources[i] == MofResource)
            {
                //
                // If this mof resource is already been registered for
                // this data source then we do not need to worry about
                // it anymore.
                //
                WmipUnreferenceMR(MofResource);
                break;
            }
            
            if (DataSource->MofResources[i] == NULL)
            {
                DataSource->MofResources[i] = MofResource;
                break;
            }
        }
            
        if (i == DataSource->MofResourceCount)
        {
            NewMofResourceCount = DataSource->MofResourceCount + 
                                  AVGMOFRESOURCECOUNT;
            if (DataSource->MofResources != 
                     DataSource->StaticMofResources)
            {
                FreeBuffer = TRUE;
            } else {
                FreeBuffer = FALSE;
            }
        
            if (WmipRealloc((PVOID *)&DataSource->MofResources,
                         DataSource->MofResourceCount * sizeof(PMOFRESOURCE),
                         NewMofResourceCount * sizeof(PMOFRESOURCE),
                         FreeBuffer )  )
            {
                DataSource->MofResourceCount = NewMofResourceCount;
                DataSource->MofResources[i] = MofResource;
            }
        }
        WmipLeaveSMCritSection();
    }

    return(STATUS_SUCCESS);
}


NTSTATUS WmipAddDataSource(
    IN PREGENTRY RegEntry,
    IN PWMIREGINFOW WmiRegInfo,
    IN ULONG BufferSize,
    IN PWCHAR RegPath,
    IN PWCHAR ResourceName,
    IN PWMIGUIDOBJECT RequestObject,
    IN BOOLEAN IsUserMode
    )
/*+++

Routine Description:

    This routine will register a information in the WMI database for a 
    new DataSource or add additional guids to an existing data source.
        
Arguments:

    RegEntry is the regentry for the data provider
        
    WmiRegInfo is the registration information to register
        
    BufferSize is the size of WmiRegInfo in bytes
        
    RegPath is a pointer into WmiRegInfo to a counted string that is the 
        registry path (or image path for UM providers).
            
    ResourceName is a pointer into WmiRegInfo to a counted string that is the 
        resource name
            
    RequestObject is the request object associated with the UM provider.
        If this is NULL then the registration is for a driver
                        

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    PBDATASOURCE DataSource;
    PWMIREGGUID RegGuid;
    ULONG i;
    NTSTATUS Status, Status2;
    PBINSTANCESET InstanceSet;
    PBINSTANCESET BinaryMofInstanceSet = NULL;
    PWCHAR MofRegistryPath;
    PWCHAR MofResourceName;
    BOOLEAN AppendToDS;
    BOOLEAN NewMofResource;

    PAGED_CODE();    
    
    if (RegEntry->DataSource != NULL)
    {
        DataSource = RegEntry->DataSource;
        WmipAssert(DataSource != NULL);
        AppendToDS = TRUE;
    } else {
        DataSource = WmipAllocDataSource();
        AppendToDS = FALSE;
    }
    
    if (DataSource != NULL)
    {
        //
        // Loop over each guid being registered and build instance sets and
        // guid entries.
        //
        if (! AppendToDS)
        {
            DataSource->ProviderId = RegEntry->ProviderId;
            if (RequestObject != NULL)
            {
                DataSource->Flags |= DS_USER_MODE;
                DataSource->RequestObject = RequestObject;
            } else {
                DataSource->Flags |= DS_KERNEL_MODE;
            }
        
        }
    
        RegGuid = WmiRegInfo->WmiRegGuid;


        for (i = 0; i < WmiRegInfo->GuidCount; i++, RegGuid++)
        {
            if (! (RegGuid->Flags & WMIREG_FLAG_REMOVE_GUID))
            {

                //
                // Only trace control guids are registered. Trace transaction
                // guids will not be registered since they can not be enabled or
                // disabled individually. They will be kept on the ControlGuids'
                // instance set structure. 
                //

                if ( ( (RegGuid->Flags & WMIREG_FLAG_TRACED_GUID) != WMIREG_FLAG_TRACED_GUID ) || 
                       (RegGuid->Flags & WMIREG_FLAG_TRACE_CONTROL_GUID) )
                { 

                    //
                    // Allocate an instance set for this new set of instances
                    //
                    InstanceSet = WmipAllocInstanceSet();
                    if (InstanceSet == NULL)
                    {
                        WmipUnreferenceDS(DataSource);
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipAddDataSource: WmipAllocInstanceSet failed\n"));
                        return(STATUS_INSUFFICIENT_RESOURCES);
                    }

                    //
                    // We will allocate a proper guid entry for the instance 
                    // set when the data source gets linked into the main data 
                    // source list so we stash a pointer to the guid away now.
                    //
                    InstanceSet->GuidEntry = (PBGUIDENTRY)&RegGuid->Guid;

                    //
                    // Minimally initialize the InstanceSet and add it to 
                    // the DataSource's list of InstanceSets. We do this 
                    // first so that if there is any failure below and 
                    // the DataSource can'e be fully registered the instance 
                    // set and guid entry will be free when the DataSource is
                    // freed.
                    //
                    InstanceSet->DataSource = DataSource;
                    InstanceSet->Flags |= IS_NEWLY_REGISTERED;

                    Status = WmipBuildInstanceSet(RegGuid,
                                                  WmiRegInfo,
                                                  BufferSize,
                                                  InstanceSet,
                                                  RegEntry->ProviderId,
                                                  RegPath);

                    //
                    // If this is the guid that represents the binary mof data
                    // then remember the InstanceSet for  later
                    //
                    if (IsEqualGUID(&RegGuid->Guid, &WmipBinaryMofGuid))
                    {
                        BinaryMofInstanceSet = InstanceSet;
                    }


                    InsertHeadList(&DataSource->ISHead, &InstanceSet->DSISList);
  
                    if (! NT_SUCCESS(Status))
                    {
                        WmipUnreferenceDS(DataSource);
                        return(Status);
                    }
                }
            }
        }
        
        //
        // Now that the instance sets have been built successfully we 
        // can link them into the master list.
        //                        
        WmipEnterSMCritSection();
        Status = WmipLinkDataSourceToList(DataSource, (BOOLEAN)(! AppendToDS));
        WmipLeaveSMCritSection();

        if (! NT_SUCCESS(Status))
        {
            WmipUnreferenceDS(DataSource);
            return(Status);
        }
        
        RegEntry->DataSource = DataSource;
        
        //
        // We need to send out notification of new guids and mofs.
        //
        if (BinaryMofInstanceSet != NULL)
        {
            //
            // Send binary mof guid arrival notification
            //
            WmipGenerateBinaryMofNotification(BinaryMofInstanceSet,
                                      &GUID_MOF_RESOURCE_ADDED_NOTIFICATION);

        }

        //
        // Convert Registry path to a sz string so we can assign it to
        // the DS if the DS is a new one
        //
        if (RegPath != NULL)
        {
            MofRegistryPath = WmipCountedToSz(RegPath);
        } else {
            MofRegistryPath = NULL;
        }
        
        if ((AppendToDS == FALSE) && (MofRegistryPath != NULL))
        {
            DataSource->RegistryPath = MofRegistryPath;
        }
        
        if (ResourceName != NULL)
        {
            MofResourceName = WmipCountedToSz(ResourceName);        
        } else {
            MofResourceName = NULL;
        }
        
        //
        // Finally if we created a new data source we need to register
        // the mof for it. Only register those that have a RegistryPath
        // and a ResourceName
        //
        if ((MofRegistryPath != NULL) &&
            (*MofRegistryPath != 0) &&
            (MofResourceName != NULL) &&
            (*MofResourceName != 0))
        {
            //
            // If a mof is specified then add it to the list
            //
            Status2 = WmipAddMofResource(DataSource,
                                        MofRegistryPath,
                                        IsUserMode,
                                        MofResourceName, 
                                        &NewMofResource);
                                    
            if (NT_SUCCESS(Status2) && NewMofResource)
            {
                //
                // We successfully added a brand new MOF resource so
                // we need to fire an event for wbem.
                //
                WmipGenerateMofResourceNotification(MofRegistryPath,
                                                    MofResourceName,
                                      &GUID_MOF_RESOURCE_ADDED_NOTIFICATION,
                                      IsUserMode ?
                                             MOFEVENT_ACTION_IMAGE_PATH :
                                             MOFEVENT_ACTION_REGISTRY_PATH);
            }            
        }        
        
        //
        // Clean up registry path and mof resource name strings
        //
        if ((MofRegistryPath != NULL) && AppendToDS)
        {
            //
            // Only free if registry path not saved in DataSource
            //
            WmipAssert(MofRegistryPath != DataSource->RegistryPath);
            WmipFree(MofRegistryPath);
        }
        
        if (MofResourceName != NULL)
        {
            WmipFree(MofResourceName);
        }
        
        //
        // Send a notification about new/changed guids
        //
        WmipGenerateRegistrationNotification(DataSource,
                                             RegistrationAdd);
        
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return(Status);
}


PBINSTANCESET WmipFindISInDSByGuid(
    PBDATASOURCE DataSource,
    LPGUID Guid
    )
/*++

Routine Description:

    This routine will find the InstanceSet in the passed DataSource for the
    guid passed.

    This routine assumes that the SM critical section is held before it is
    called.

Arguments:

    DataSource is the data source from which the guid is to be removed

    Guid has the Guid for the InstanceSet to find

Return Value:

--*/
{
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;

    PAGED_CODE();
    
    InstanceSetList = DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        DSISList);

        if ((InstanceSet->GuidEntry != NULL) &&
             (IsEqualGUID(Guid, &InstanceSet->GuidEntry->Guid)))
        {
            WmipReferenceIS(InstanceSet);
            return(InstanceSet);
        }

        InstanceSetList = InstanceSetList->Flink;
    }
    return(NULL);
}

ULONG WmipUpdateAddGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    PBINSTANCESET *AddModInstanceSet
    )
/*++

Routine Description:

    This routine will add a new guid for the data source and send notification

    This routine assumes that the SM critical section is held before it is
    called.

Arguments:

    DataSource is the data source from which the guid is to be removed

    RegGuid has the Guid update data structure

    WmiRegInfo points at the beginning of the registration update info

Return Value:

    1 if guid was added or 0

--*/
{
    PBINSTANCESET InstanceSet;
    LPGUID Guid = &RegGuid->Guid;
    NTSTATUS Status;

    PAGED_CODE();
    
    //
    // Allocate an instance set for this new set of instances
    InstanceSet = WmipAllocInstanceSet();
    if (InstanceSet == NULL)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: WmipUpdateAddGuid: WmipAllocInstanceSet failed\n"));
        return(0);
    }

    //
    // We will allocate a proper guid entry for the instance set when
    // the data source gets linked into the main data source list so
    // we stash a pointer to the guid away now.
    InstanceSet->GuidEntry = (PBGUIDENTRY)Guid;

    //
    // Minimally initialize the InstanceSet and add it to the DataSource's
    // list of InstanceSets. We do this first so that if there is any
    // failure below and the DataSource can'e be fully registered the
    // instance set and guid entry will be free when the DataSource is
    // freed.
    InstanceSet->DataSource = DataSource;
    InstanceSet->Flags |= IS_NEWLY_REGISTERED;

    InsertHeadList(&DataSource->ISHead, &InstanceSet->DSISList);

    Status = WmipBuildInstanceSet(RegGuid,
                                  WmiRegInfo,
                                  BufferSize,
                                  InstanceSet,
                                  DataSource->ProviderId,
                                  DataSource->RegistryPath);

    if (! NT_SUCCESS(Status))
    {
        WmipUnreferenceIS(InstanceSet);
        return(0);
    }

    Status = WmipLinkDataSourceToList(DataSource,
                                          FALSE);

    *AddModInstanceSet = InstanceSet;

    return( NT_SUCCESS(Status) ? 1 : 0);
}

#if DBG
PWCHAR GuidToString(
    PWCHAR s,
    ULONG SizeInBytes,
    LPGUID piid
    )
{
    HRESULT hr;
    
    PAGED_CODE();
    
    hr = StringCbPrintf(s, SizeInBytes, L"%x-%x-%x-%x%x%x%x%x%x%x%x",                   
               piid->Data1, piid->Data2,
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);
    WmipAssert(hr == S_OK);

    return(s);
}
#endif


BOOLEAN WmipUpdateRemoveGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PBINSTANCESET *AddModInstanceSet
    )
/*++

Routine Description:

    This routine will remove the guid for the data source and send notification

    This routine assumes that the SM critical section is held before it is
    called.

Arguments:

    DataSource is the data source from which the guid is to be removed

    RegGuid has the Guid update data structure

Return Value:

    TRUE if guid was removed else FALSE

--*/
{
    PBINSTANCESET InstanceSet;
    LPGUID Guid = &RegGuid->Guid;
    BOOLEAN SendNotification;

    PAGED_CODE();
    
    InstanceSet = WmipFindISInDSByGuid(DataSource,
                                       Guid);
    if (InstanceSet != NULL)
    {
        WmipUnreferenceIS(InstanceSet);
        *AddModInstanceSet = InstanceSet;
        SendNotification = TRUE;
    } else {
#if DBG
        WCHAR s[256];
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: UpdateRemoveGuid %ws not registered by %ws\n",
                        GuidToString(s, sizeof(s), Guid), DataSource->RegistryPath));
#endif
        SendNotification = FALSE;
    }
    return(SendNotification);
}


BOOLEAN WmipIsEqualInstanceSets(
    PBINSTANCESET InstanceSet1,
    PBINSTANCESET InstanceSet2
    )
{
    ULONG i;
    ULONG Flags1, Flags2;

    PAGED_CODE();
    
    Flags1 = InstanceSet1->Flags & ~(IS_ENABLE_EVENT | IS_ENABLE_COLLECTION);
    Flags2 = InstanceSet2->Flags & ~(IS_ENABLE_EVENT | IS_ENABLE_COLLECTION);
    if (Flags1 == Flags2)
    {
        if (InstanceSet1->Flags & IS_INSTANCE_BASENAME)
        {
            if ((InstanceSet1->Count == InstanceSet2->Count) &&
                (wcscmp(InstanceSet1->IsBaseName->BaseName,
                        InstanceSet1->IsBaseName->BaseName) == 0))
            {
                return(TRUE);
            }
        } else if (InstanceSet1->Flags & IS_INSTANCE_BASENAME) {
            if (InstanceSet1->Count == InstanceSet2->Count)
            {
                for (i = 0; i < InstanceSet1->Count; i++)
                {
                    if (wcscmp(InstanceSet1->IsStaticNames->StaticNamePtr[i],
                               InstanceSet2->IsStaticNames->StaticNamePtr[i]) != 0)
                     {
                        return(FALSE);
                    }
                }
                return(TRUE);
            }
        } else {
            return(TRUE);
        }
    }

    return(FALSE);

}

ULONG WmipUpdateModifyGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    PBINSTANCESET *AddModInstanceSet
    )
/*++

Routine Description:

    This routine will modify an existing guid for the data source and
    send notification

    This routine assumes that the SM critical section is held before it is
    called.


    HEHEY: If a guid was opened when it was registered as cheap, but closed
        when the guid was registered expensive a disable collection will
            NOT be sent. Conversely if a guid was opened when it was
        registered as expensive and is closed when registed as cheap a
            disable collection may be sent.

Arguments:

    DataSource is the data source from which the guid is to be removed

    RegGuid has the Guid update data structure

    WmiRegInfo points at the beginning of the registration update info

Return Value:

    1 if guid was added or 2 if guid was modified else 0

--*/
{
    PBINSTANCESET InstanceSet;
    LPGUID Guid = &RegGuid->Guid;
    ULONG SendNotification;
    PBINSTANCESET InstanceSetNew;
    PVOID ToFree;
    NTSTATUS Status;

    PAGED_CODE();
    
    InstanceSet = WmipFindISInDSByGuid(DataSource,
                                       Guid);
    if (InstanceSet != NULL)
    {
        //
        // See if anything has changed with the instance names and if not
        // then don't bother to recreate the instance set

        InstanceSetNew = WmipAllocInstanceSet();
        if (InstanceSetNew == NULL)
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: UpdateModifyGuid Not enough memory to alloc InstanceSet\n"));
            WmipUnreferenceIS(InstanceSet);
            return(0);
        }
    
        Status = WmipBuildInstanceSet(RegGuid,
                             WmiRegInfo,
                             BufferSize,
                             InstanceSetNew,
                             DataSource->ProviderId,
                             DataSource->RegistryPath);
                         
        if (NT_SUCCESS(Status))
        {
            if (! WmipIsEqualInstanceSets(InstanceSet,
                                          InstanceSetNew))
            {
                ToFree = NULL;
                if (InstanceSet->IsBaseName != NULL) {
                    ToFree = (PVOID)InstanceSet->IsBaseName;
                }

                RemoveEntryList(&InstanceSet->GuidISList);
                Status = WmipBuildInstanceSet(RegGuid,
                             WmiRegInfo,
                             BufferSize,
                             InstanceSet,
                             DataSource->ProviderId,
                             DataSource->RegistryPath);
                if (NT_SUCCESS(Status))
                {
                    InsertHeadList(&InstanceSet->GuidEntry->ISHead,
                               &InstanceSet->GuidISList);
                } else {
                    //
                    // It is sad, but we weren't able to rebuild the instance
                    // set so the old one is gone. This is an unlikely
                    // situation that can really only occur when the machine
                    // is out of memory.
                    //
                }

                if (ToFree != NULL)
                {
                    WmipFree(ToFree);
                }

                *AddModInstanceSet = InstanceSet;
                SendNotification = 2;
            } else {
                //
                // The InstanceSets are identical so just delete the new one
                SendNotification = 0;
            }
            
            WmipUnreferenceIS(InstanceSetNew);
            WmipUnreferenceIS(InstanceSet);
        } else {
            //
            // We could not parse the new instance set so leave the old
            // one alone
            //
            WmipUnreferenceIS(InstanceSet);
            WmipUnreferenceIS(InstanceSetNew);
            SendNotification = FALSE;
        }
    } else {
        //
        // Guid not already registered so try to add it
        SendNotification = WmipUpdateAddGuid(DataSource,
                          RegGuid,
                          WmiRegInfo,
                          BufferSize,
                          AddModInstanceSet);
    }
    return(SendNotification);
}


void WmipCachePtrs(
    LPGUID Ptr1,
    PBINSTANCESET Ptr2,
    ULONG *PtrCount,
    ULONG *PtrMax,
    PTRCACHE **PtrArray
    )
{
    PTRCACHE *NewPtrArray;
    PTRCACHE *OldPtrArray;
    PTRCACHE *ActualPtrArray;

    PAGED_CODE();
    
    if (*PtrCount == *PtrMax)
    {
        NewPtrArray = WmipAlloc((*PtrMax + PTRCACHEGROWSIZE) * sizeof(PTRCACHE));
        if (NewPtrArray != NULL)
        {
            OldPtrArray = *PtrArray;
            memcpy(NewPtrArray, OldPtrArray, *PtrMax * sizeof(PTRCACHE));
            *PtrMax += PTRCACHEGROWSIZE;
            if (*PtrArray != NULL)
            {
                WmipFree(*PtrArray);
            }
            *PtrArray = NewPtrArray;
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Couldn't alloc memory for pointer cache\n"));
            return;
        }
    }
    ActualPtrArray = *PtrArray;
    ActualPtrArray[*PtrCount].Guid = Ptr1;
    ActualPtrArray[*PtrCount].InstanceSet = Ptr2;
    (*PtrCount)++;
}



NTSTATUS WmipUpdateDataSource(
    PREGENTRY RegEntry,
    PWMIREGINFOW WmiRegInfo,
    ULONG RetSize
    )
/*++

Routine Description:

    This routine will update a data source with changes to already registered
    guids.

Arguments:

    ProviderId is the provider id of the DataSource whose guids are being
        updated.

    WmiRegInfo has the registration update information

    RetSize has the size of the registration information returned from
        kernel mode.

Return Value:


--*/
{
    PBDATASOURCE DataSource;
    PUCHAR RegInfo;
    ULONG RetSizeLeft;
    ULONG i;
    PWMIREGGUID RegGuid;
    ULONG NextWmiRegInfo;
    PTRCACHE *RemovedGuids;
    PTRCACHE *AddedGuids;
    PTRCACHE *ModifiedGuids;
    ULONG RemovedGuidCount;
    ULONG AddedGuidCount;
    ULONG ModifiedGuidCount;
    ULONG RemovedGuidMax;
    ULONG AddedGuidMax;
    ULONG ModifiedGuidMax;
    PBINSTANCESET InstanceSet;
    ULONG Action;

    PAGED_CODE();
    
    DataSource = RegEntry->DataSource;
    if (DataSource == NULL)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: RegEntry %p requested update but is not registered\n",
                       RegEntry));
        return(STATUS_OBJECT_NAME_NOT_FOUND);
    }

    WmipReferenceDS(DataSource);
    AddedGuidCount = 0;
    ModifiedGuidCount = 0;
    RemovedGuidCount = 0;
    AddedGuidMax = 0;
    ModifiedGuidMax = 0;
    RemovedGuidMax = 0;
    ModifiedGuids = NULL;
    AddedGuids = NULL;
    RemovedGuids = NULL;

    NextWmiRegInfo = 0;
    RetSizeLeft = RetSize;
    WmipEnterSMCritSection();
    RegInfo = (PUCHAR)WmiRegInfo;
    for (i = 0; i < WmiRegInfo->GuidCount; i++)
    {
        RegGuid = &WmiRegInfo->WmiRegGuid[i];
        if (RegGuid->Flags & WMIREG_FLAG_REMOVE_GUID)
        {
            if (WmipUpdateRemoveGuid(DataSource,
                                         RegGuid,
                                         &InstanceSet))
            {
                WmipCachePtrs(&RegGuid->Guid,
                             InstanceSet,
                             &RemovedGuidCount,
                             &RemovedGuidMax,
                             &RemovedGuids);
            }
        } else  {
            Action = WmipUpdateModifyGuid(DataSource,
                                       RegGuid,
                                       WmiRegInfo,
                                       RetSize,
                                       &InstanceSet);
            if (Action == 1)
            {
                WmipCachePtrs(&RegGuid->Guid,
                                 InstanceSet,
                                 &AddedGuidCount,
                                 &AddedGuidMax,
                                 &AddedGuids);

            } else if (Action == 2) {
                WmipCachePtrs(&RegGuid->Guid,
                                 InstanceSet,
                                 &ModifiedGuidCount,
                                 &ModifiedGuidMax,
                                 &ModifiedGuids);
            }
        }
    }
    WmipLeaveSMCritSection();

    WmipUnreferenceDS(DataSource);

    if (RemovedGuidCount > 0)
    {
        for (i = 0; i < RemovedGuidCount; i++)
        {
            if (IsEqualGUID(RemovedGuids[i].Guid,
                            &WmipBinaryMofGuid))
            {
                WmipGenerateBinaryMofNotification(RemovedGuids[i].InstanceSet,
                                     &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION);
            }
                
            InstanceSet = RemovedGuids[i].InstanceSet;

            WmipDisableCollectionForRemovedGuid(RemovedGuids[i].Guid,
                                                InstanceSet);

            WmipEnterSMCritSection();
            //
            // If IS is on the GE list then remove it
            if (InstanceSet->GuidISList.Flink != NULL)
            {
                RemoveEntryList(&InstanceSet->GuidISList);
                InstanceSet->GuidEntry->ISCount--;
            }

            if (! (InstanceSet->Flags & IS_NEWLY_REGISTERED))
            {
                WmipUnreferenceGE(InstanceSet->GuidEntry);
            }

            InstanceSet->GuidEntry = NULL;

            //
            // Remove IS from the DS List
            RemoveEntryList(&InstanceSet->DSISList);
            WmipUnreferenceIS(InstanceSet);
            WmipLeaveSMCritSection();
        }

        WmipSendGuidUpdateNotifications(RegistrationDelete,
                                    RemovedGuidCount,
                                    RemovedGuids);
        WmipFree(RemovedGuids);
    }

    if (ModifiedGuidCount > 0)
    {
        for (i = 0; i < ModifiedGuidCount; i++)
        {
            if (IsEqualGUID(ModifiedGuids[i].Guid,
                            &WmipBinaryMofGuid))
            {
                WmipGenerateBinaryMofNotification(ModifiedGuids[i].InstanceSet,
                                      &GUID_MOF_RESOURCE_ADDED_NOTIFICATION);
            }
        }
        
        WmipSendGuidUpdateNotifications(RegistrationUpdate,
                                    ModifiedGuidCount,
                                    ModifiedGuids);
        WmipFree(ModifiedGuids);
    }

    if (AddedGuidCount > 0)
    {
        for (i = 0; i < AddedGuidCount; i++)
        {
            if (IsEqualGUID(AddedGuids[i].Guid,
                            &WmipBinaryMofGuid))
            {
                WmipGenerateBinaryMofNotification(AddedGuids[i].InstanceSet,
                                      &GUID_MOF_RESOURCE_ADDED_NOTIFICATION);
            }
                
            WmipEnableCollectionForNewGuid(AddedGuids[i].Guid,
                                           AddedGuids[i].InstanceSet);
        }
        WmipSendGuidUpdateNotifications(RegistrationAdd,
                                    AddedGuidCount,
                                    AddedGuids);
        WmipFree(AddedGuids);
    }
    return(STATUS_SUCCESS);
}

void WmipRemoveDataSourceByDS(
    PBDATASOURCE DataSource
    )
{    

    PAGED_CODE();
    
    WmipGenerateRegistrationNotification(DataSource,
                                         RegistrationDelete);

    WmipUnreferenceDS(DataSource);
}

NTSTATUS WmipRemoveDataSource(
    PREGENTRY RegEntry
    )
{
    PBDATASOURCE DataSource;
    NTSTATUS Status;

    PAGED_CODE();
    
    DataSource = RegEntry->DataSource;
    if (DataSource != NULL)
    {
        WmipReferenceDS(DataSource);
        WmipRemoveDataSourceByDS(DataSource);
        WmipUnreferenceDS(DataSource);
        Status = STATUS_SUCCESS;
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Attempt to remove non existant data source %p\n",
                        RegEntry));
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }
    return(Status);
}


NTSTATUS WmipEnumerateMofResources(
    PWMIMOFLIST MofList,
    ULONG BufferSize,
    ULONG *RetSize
    )
{
    PLIST_ENTRY MofResourceList;
    PMOFRESOURCE MofResource;
    ULONG MRCount;
    SIZE_T SizeNeeded, MRSize;
    PWMIMOFENTRY MofEntry;
    PWCHAR MRBuffer;
    ULONG i;
    HRESULT hr;

    PAGED_CODE();
    
    WmipEnterSMCritSection();

    MRCount = 0;
    SizeNeeded = 0;
    MofResourceList = WmipMRHeadPtr->Flink;
    while (MofResourceList != WmipMRHeadPtr)
    {
        MofResource = CONTAINING_RECORD(MofResourceList,
                                      MOFRESOURCE,
                                      MainMRList);
                                  
        MRCount++;
        SizeNeeded += (wcslen(MofResource->RegistryPath) + 
                       wcslen(MofResource->MofResourceName) + 2) * 
                           sizeof(WCHAR);
                                  
        MofResourceList = MofResourceList->Flink;
    }
    
    if (MRCount != 0)
    {
        MRSize = sizeof(WMIMOFLIST) + ((MRCount-1) * sizeof(WMIMOFENTRY));
        SizeNeeded += MRSize;
        
        if (BufferSize >= SizeNeeded)
        {
            MofList->MofListCount = MRCount;
            MofResourceList = WmipMRHeadPtr->Flink;
            i = 0;
            while (MofResourceList != WmipMRHeadPtr)
            {
                MofResource = CONTAINING_RECORD(MofResourceList,
                                      MOFRESOURCE,
                                      MainMRList);
                
                MofEntry = &MofList->MofEntry[i++];
                MofEntry->Flags = MofResource->Flags & MR_FLAG_USER_MODE ? 
                                                  WMIMOFENTRY_FLAG_USERMODE : 
                                                  0;
                                                  
                MofEntry->RegPathOffset = (ULONG) MRSize;
                MRBuffer = (PWCHAR)OffsetToPtr(MofList, MRSize);
                hr = StringCbCopy(MRBuffer,
                                  (BufferSize - MRSize),
                                  MofResource->RegistryPath);
                WmipAssert(hr == S_OK);             
                MRSize += (wcslen(MofResource->RegistryPath) + 1) * sizeof(WCHAR);
                
                MofEntry->ResourceOffset = (ULONG) MRSize;
                MRBuffer = (PWCHAR)OffsetToPtr(MofList, MRSize);
                hr = StringCbCopy(MRBuffer,
                                  (BufferSize - MRSize),
                                  MofResource->MofResourceName);
                WmipAssert(hr == S_OK);             
                MRSize += (wcslen(MofResource->MofResourceName) + 1) * sizeof(WCHAR);
                MofResourceList = MofResourceList->Flink;
            }           
        } else {
            //
            // Buffer not large enough, return size needed
            //
            MofList->MofListCount = (ULONG) SizeNeeded;
            *RetSize = sizeof(ULONG);
        }
        
    } else {
        //
        // No mof resources
        //
        MofList->MofListCount = 0;
        *RetSize = sizeof(WMIMOFLIST);
    }
    
    
    WmipLeaveSMCritSection();
    return(STATUS_SUCCESS);
}


NTSTATUS WmipInitializeDataStructs(
    void
)
/*++

Routine Description:

    This routine will do the work of initializing the WMI service

Arguments:

Return Value:

    Error status value
        
--*/
{
    ULONG Status;
    UCHAR RegInfoBuffer[sizeof(WMIREGINFOW) + 2 * sizeof(WMIREGGUIDW)];
    PWMIREGINFOW RegInfo = (PWMIREGINFOW)RegInfoBuffer;
    GUID InstanceInfoGuid = INSTANCE_INFO_GUID;
    GUID EnumerateGuidsGuid = ENUMERATE_GUIDS_GUID;
    PREGENTRY RegEntry;
    PDEVICE_OBJECT Callback;
    PLIST_ENTRY GuidEntryList;
    PBGUIDENTRY GuidEntry;
    BOOLEAN NewResource;

    PAGED_CODE();
    
    //
    // Initialize the various data structure lists that we maintain
    //
    WmipDSHeadPtr = &WmipDSHead;
    InitializeListHead(WmipDSHeadPtr);
    InitializeListHead(&WmipDSChunkInfo.ChunkHead);

    WmipGEHeadPtr = &WmipGEHead;
    InitializeListHead(WmipGEHeadPtr);
    InitializeListHead(&WmipGEChunkInfo.ChunkHead);

    WmipMRHeadPtr = &WmipMRHead;
    InitializeListHead(WmipMRHeadPtr);
    InitializeListHead(&WmipMRChunkInfo.ChunkHead);

    InitializeListHead(&WmipISChunkInfo.ChunkHead);

  
    //      
    // Register any internal data provider guids and mark them as such
    //
    Callback = (PDEVICE_OBJECT)(ULONG_PTR) WmipUMProviderCallback;
    
    //
    // Establish a regentry for the data provider
    //
    RegEntry = WmipAllocRegEntry(Callback,
                                 WMIREG_FLAG_CALLBACK |
                                 REGENTRY_FLAG_TRACED |
                                 REGENTRY_FLAG_NEWREGINFO | 
                                 REGENTRY_FLAG_INUSE |
                                 REGENTRY_FLAG_REG_IN_PROGRESS);
                             
    if (RegEntry != NULL)
    {
        //
        // This code assumes that no other data providers have
        // yet registered.
        //
        WmipAssert(WmipGEHeadPtr->Flink == WmipGEHeadPtr);
                
        RtlZeroMemory(RegInfo, sizeof(RegInfoBuffer));    
        RegInfo->BufferSize = sizeof(RegInfoBuffer);
        RegInfo->GuidCount = 2;
        RegInfo->WmiRegGuid[0].Guid = InstanceInfoGuid;
        RegInfo->WmiRegGuid[1].Guid = EnumerateGuidsGuid;
        Status = WmipAddDataSource(RegEntry,
                               RegInfo,
                               RegInfo->BufferSize,
                               NULL,
                               NULL,
                               NULL,
                               FALSE);
                           
        if (NT_SUCCESS(Status))
        {                          
            GuidEntryList = WmipGEHeadPtr->Flink;
            while (GuidEntryList != WmipGEHeadPtr)
            {   
                GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                              GUIDENTRY,
                                             MainGEList);

                GuidEntry->Flags |= GE_FLAG_INTERNAL;
        
                GuidEntryList = GuidEntryList->Flink;       
            }
        } else {
            RegEntry->Flags |= (REGENTRY_FLAG_RUNDOWN | 
                                    REGENTRY_FLAG_NOT_ACCEPTING_IRPS);
            WmipUnreferenceRegEntry(RegEntry);
        }
        
        Status = WmipAddMofResource(RegEntry->DataSource,
                                    WMICOREIMAGEPATH,
                                    TRUE,
                                    WMICORERESOURCENAME,
                                    &NewResource);
        WmipAssert(NewResource);
    }
    
        
    return(STATUS_SUCCESS);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\enabdisa.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

   enabdisa.c

Abstract:

    Enable and disable code

Author:

    AlanWar

Environment:

     Kernel mode

Revision History:


--*/

#include "wmikmp.h"
#include "tracep.h"

BOOLEAN
WmipIsISFlagsSet(
    PBGUIDENTRY GuidEntry,
    ULONG Flags
    );

NTSTATUS WmipDeliverWnodeToDS(
    CHAR ActionCode, 
    PBDATASOURCE DataSource,
    PWNODE_HEADER Wnode,
    ULONG BufferSize
   );

NTSTATUS WmipSendEnableDisableRequest(
    UCHAR ActionCode,
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    );

void WmipReleaseCollectionEnabled(
    PBGUIDENTRY GuidEntry
    );

void WmipWaitForCollectionEnabled(
    PBGUIDENTRY GuidEntry
    );

ULONG WmipSendEnableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    );

ULONG WmipDoDisableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext,
    ULONG InProgressFlag
    );

ULONG WmipSendDisableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    );

NTSTATUS WmipEnableCollectOrEvent(
    PBGUIDENTRY GuidEntry,
    ULONG Ioctl,
    BOOLEAN *RequestSent,
    ULONG64 LoggerContext
    );

NTSTATUS WmipDisableCollectOrEvent(
    PBGUIDENTRY GuidEntry,
    ULONG Ioctl,
    ULONG64 LoggerContext
    );

NTSTATUS WmipEnableDisableTrace(
    IN ULONG Ioctl,
    IN PWMITRACEENABLEDISABLEINFO TraceEnableInfo
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,WmipIsISFlagsSet)
#pragma alloc_text(PAGE,WmipDeliverWnodeToDS)
#pragma alloc_text(PAGE,WmipSendEnableDisableRequest)
#pragma alloc_text(PAGE,WmipReleaseCollectionEnabled)
#pragma alloc_text(PAGE,WmipWaitForCollectionEnabled)
#pragma alloc_text(PAGE,WmipSendEnableRequest)
#pragma alloc_text(PAGE,WmipDoDisableRequest)
#pragma alloc_text(PAGE,WmipSendDisableRequest)
#pragma alloc_text(PAGE,WmipEnableCollectOrEvent)
#pragma alloc_text(PAGE,WmipDisableCollectOrEvent)
#pragma alloc_text(PAGE,WmipEnableDisableTrace)
#pragma alloc_text(PAGE,WmipDisableTraceProviders)
#endif

BOOLEAN
WmipIsISFlagsSet(
    PBGUIDENTRY GuidEntry,
    ULONG Flags
    )
/*++

Routine Description:

    This routine determines whether any of the instance sets associated
    with the GuidEntry has ALL of the flags set

Arguments:

    GuidEntry  Pointer to the Guid Entry structure.
        
    Flags has flags required

Return Value:


--*/
{
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;

    PAGED_CODE();
    
    if (GuidEntry != NULL)
    {
        WmipEnterSMCritSection();
        InstanceSetList = GuidEntry->ISHead.Flink;
        while (InstanceSetList != &GuidEntry->ISHead)
        {
            InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
            if ( (InstanceSet->Flags & Flags) == Flags )
            {
                WmipLeaveSMCritSection();
                return (TRUE);
            }
            InstanceSetList = InstanceSetList->Flink;
        }
        WmipLeaveSMCritSection();
    }
    return (FALSE);
}

NTSTATUS WmipDeliverWnodeToDS(
    CHAR ActionCode, 
    PBDATASOURCE DataSource,
    PWNODE_HEADER Wnode,
    ULONG BufferSize
   )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    PWMIGUIDOBJECT GuidObject;

    PAGED_CODE();
    
    if (DataSource->Flags & DS_KERNEL_MODE)
    {    
        //
        // If KM provider then send an irp
        //
        Status = WmipSendWmiIrp(ActionCode,
                                DataSource->ProviderId,
                                &Wnode->Guid,
                                BufferSize,
                                Wnode,
                                &Iosb);
    } else if (DataSource->Flags & DS_USER_MODE) {
        //
        // If UM provider then send a MB message
        //
        GuidObject = DataSource->RequestObject;
        if (GuidObject != NULL)
        {
            Wnode->Flags |= WNODE_FLAG_INTERNAL;
            Wnode->ProviderId = ActionCode;
            Wnode->CountLost = GuidObject->Cookie;
            WmipEnterSMCritSection();
            Status = WmipWriteWnodeToObject(GuidObject,
                                            Wnode,
                                            TRUE);
            WmipLeaveSMCritSection();
        } else {
            Status = STATUS_SUCCESS;
        }
    } else {
        ASSERT(FALSE);
        Status = STATUS_UNSUCCESSFUL;
    }
                     
    return(Status);
}

NTSTATUS WmipSendEnableDisableRequest(
    UCHAR ActionCode,
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    )
/*++

Routine Description:

    This routine will deliver an event or collection WNODE to all data
    providers of a guid. This routine assumes that it is called with the
    SM critical section held. The routine does not hold the critical
    section for the duration of the call.

Arguments:

    ActionCode is WMI_ENABLE_EVENTS, WMI_DISABLE_EVENTS,
        WMI_ENABLE_COLLECTION or WMI_DISABLE_COLLECTION

    GuidEntry is the guid entry for the guid that is being enabled/disable
        or collected/stop collected

    IsEvent is TRUE then ActionCode is to enable or disable events.
        If FALSE then ActionCode is to enable or disbale collecton

    IsTraceLog is TRUE then enable is only sent to those guids registered as
        being a tracelog guid

    LoggerContext is a logger context handle that should be placed in the
        HistoricalContext field of the WNODE_HEADER if IsTraceLog is TRUE.

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
#if DBG
#define AVGISPERGUID 1
#else
#define AVGISPERGUID 64
#endif

    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    PBDATASOURCE DataSourceArray[AVGISPERGUID];
    PBDATASOURCE *DataSourceList;
    ULONG BufferSize;
    ULONG Status = 0;
    PWNODE_HEADER pWnode;
    ULONG i;
    PBDATASOURCE DataSource;
    ULONG DSCount;
    BOOLEAN IsEnable;
    ULONG IsFlags, IsUpdate;

    WMITRACE_NOTIFY_HEADER  TraceNotifyHeader;

    PAGED_CODE();

    if (GuidEntry->Flags & GE_FLAG_INTERNAL)
    {
        //
        // Guids that have been unregistered and Internally defined guids
        // have no data source to send requests to, so just leave happily
        return(STATUS_SUCCESS);
    }
            

    IsEnable = ((ActionCode == IRP_MN_ENABLE_EVENTS) ||
                (ActionCode == IRP_MN_ENABLE_COLLECTION));
    IsFlags = IsEvent ? IS_ENABLE_EVENT : IS_ENABLE_COLLECTION;

    //
    // Determine whether this is an update call and reset the bit
    //
    IsUpdate = (GuidEntry->Flags & GE_NOTIFICATION_TRACE_UPDATE);


    //
    // First we make a list of all of the DataSources that need to be called
    // while we have the critical section and take a reference on them so
    // they don't go away after we release them. Note that the DataSource
    // structure will stay, but the actual data provider may in fact go away.
    // In this case sending the request will fail.
    DSCount = 0;

    if (GuidEntry->ISCount > AVGISPERGUID)
    {
        DataSourceList = WmipAlloc(GuidEntry->ISCount * sizeof(PBDATASOURCE));
        if (DataSourceList == NULL)
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: alloc failed for DataSource array in WmipSendEnableDisableRequest\n"));

            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    } else {
        DataSourceList = &DataSourceArray[0];
    }
#if DBG
    memset(DataSourceList, 0, GuidEntry->ISCount * sizeof(PBDATASOURCE));
#endif

    InstanceSetList = GuidEntry->ISHead.Flink;
    while ((InstanceSetList != &GuidEntry->ISHead) &&
           (DSCount < GuidEntry->ISCount))
    {
        WmipAssert(DSCount < GuidEntry->ISCount);
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        GuidISList);


        //
        // We send requests to those data providers that are not inprocs when
        // it is an event being enabled or it is collection being enabled
        // and they are defined to be expensive (collection needs to be
        // enabled)
        if (
             ( (IsTraceLog && (InstanceSet->Flags & IS_TRACED)) ||
               ( ! IsTraceLog && (! (InstanceSet->Flags & IS_TRACED)) &&
                 (IsEvent || (InstanceSet->Flags & IS_EXPENSIVE))
               )
             )
           )
        {

            if ( (! IsEnable && (InstanceSet->Flags & IsFlags)) ||
                 ((IsEnable && ! (InstanceSet->Flags & IsFlags)) ||
                 (IsUpdate && IsTraceLog))
               )
            {
                DataSourceList[DSCount] = InstanceSet->DataSource;
                WmipReferenceDS(DataSourceList[DSCount]);
                DSCount++;
            }

            if (IsEnable)
            {
                InstanceSet->Flags |= IsFlags;
            } else {
                InstanceSet->Flags &= ~IsFlags;
            }
        }

        InstanceSetList = InstanceSetList->Flink;
    }


    if (IsUpdate) 
    { 
        GuidEntry->Flags &= ~GE_NOTIFICATION_TRACE_UPDATE;
    }


    WmipLeaveSMCritSection();

    //
    // Now without the critical section we send the request to all of the
    // data providers. Any new data providers who register after we made our
    // list will be enabled by the registration code.
    if (DSCount > 0)
    {
        pWnode = &TraceNotifyHeader.Wnode;
        RtlZeroMemory(pWnode, sizeof(TraceNotifyHeader));
        RtlCopyMemory(&pWnode->Guid, &GuidEntry->Guid, sizeof(GUID));
        BufferSize = sizeof(WNODE_HEADER);

        if (IsTraceLog)
        {
            BufferSize = sizeof(TraceNotifyHeader);
            TraceNotifyHeader.LoggerContext = LoggerContext;
            pWnode->Flags |= WNODE_FLAG_TRACED_GUID;
            //
            // If this GUID is already enabled then this must 
            // an update call. So mark it so. 
            // 
            if ( IsEnable &&  IsUpdate ) {
                pWnode->ClientContext = IsUpdate;
            }

        }
        pWnode->BufferSize = BufferSize;

        for (i = 0; i < DSCount; i++)
        {
            DataSource = DataSourceList[i];
            WmipAssert(DataSource != NULL);
            if (IsTraceLog) {
                if (DataSource->Flags & DS_KERNEL_MODE) {
                    pWnode->HistoricalContext = LoggerContext;
                }
                else if (DataSource->Flags & DS_USER_MODE) {
                    pWnode->HistoricalContext = 0;
                }
                else {
                    ASSERT(FALSE);
                }
            }
                                
            Status |= WmipDeliverWnodeToDS(ActionCode, 
                                          DataSource, 
                                          pWnode,
                                          BufferSize);
            

            WmipUnreferenceDS(DataSource);
        }
    }

    if( ! IsTraceLog )
    {

        Status = STATUS_SUCCESS;
    }

    if (DataSourceList != DataSourceArray)
    {
        WmipFree(DataSourceList);
    }

    WmipEnterSMCritSection();

    return(Status);
}

void WmipReleaseCollectionEnabled(
    PBGUIDENTRY GuidEntry
    )
{
    PAGED_CODE();
    
    if (GuidEntry->Flags & GE_FLAG_WAIT_ENABLED)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p enable releasning %p.%p %x event %p\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                     GuidEntry,
                                     GuidEntry->Flags));
                                 
        KeSetEvent(GuidEntry->CollectInProgress, 0, FALSE);
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p enable did release %p %x event %p\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                     GuidEntry,
                                     GuidEntry->Flags));
                                 
        GuidEntry->Flags &= ~GE_FLAG_WAIT_ENABLED;
    }
}

void WmipWaitForCollectionEnabled(
    PBGUIDENTRY GuidEntry
    )
{
    PAGED_CODE();
    
    WmipAssert((GuidEntry->Flags & GE_FLAG_COLLECTION_IN_PROGRESS) ==
                   GE_FLAG_COLLECTION_IN_PROGRESS);
    
    //
    // Collection Enable/Disable is in progress so
    // we cannot return just yet. Right now there could be a 
    // disable request being processed and if we didn't wait, we
    // might get back to this caller before that disable request
    // got around to realizing that it needs to send and enable 
    // request (needed by this thread's caller). So we'd have a 
    // situation where a thread though that collection was enabled
    // but in reality it wasn't yet enabled.
    if ((GuidEntry->Flags & GE_FLAG_WAIT_ENABLED) == 0)
    {
        KeInitializeEvent(GuidEntry->CollectInProgress, 
                          NotificationEvent,
                          FALSE);
        GuidEntry->Flags |= GE_FLAG_WAIT_ENABLED;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p for %p %x created event\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                 GuidEntry,
                                 GuidEntry->Flags));
    }
            
    WmipLeaveSMCritSection();
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p waiting for %p %x on event\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                     GuidEntry,
                                     GuidEntry->Flags));
    KeWaitForSingleObject(GuidEntry->CollectInProgress, 
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p done %p %x waiting on event\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                     GuidEntry,
                                     GuidEntry->Flags));
    WmipEnterSMCritSection();
    
}

ULONG WmipSendEnableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    )
/*++
Routine Description:

    This routine will send an enable collection or notification request to
    all of the data providers that have registered the guid being enabled.
    This routine will manage any race conditions that might occur when
    multiple threads are enabling and disabling the notification
    simultaneously.

    This routine is called while the SM critical section is being held and
    will increment the appropriate reference count. if the ref count
    transitions from 0 to 1 then the enable request will need to be forwarded
    to the data providers otherwise the routine is all done and returns.
    Before sending the enable request the routine checks to see if any
    enable or disable requests are currently in progress and if not then sets
    the in progress flag, releases the critical section and sends the enable
    request. If there was a request in progress then the routine does not
    send a request, but just returns. When the other thread that was sending
    the request returns from processing the request it will recheck the
    refcount and notice that it is greater than 0 and then send the enable
    request.


Arguments:

    GuidEntry is the guid entry that describes the guid being enabled. For
        a notification it may be NULL.

    NotificationContext is the notification context to use if enabling events

    IsEvent is TRUE if notifications are being enables else FALSE if
        collection is being enabled

    IsTraceLog is TRUE if enable is for a trace log guid

    LoggerContext is a context value to forward in the enable request

Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG InProgressFlag;
    ULONG RefCount;
    ULONG Status;

    PAGED_CODE();
    
    if (IsEvent)
    {
        InProgressFlag = GE_FLAG_NOTIFICATION_IN_PROGRESS;
        RefCount = GuidEntry->EventRefCount++;
    } else {
        InProgressFlag = GE_FLAG_COLLECTION_IN_PROGRESS;
        RefCount = GuidEntry->CollectRefCount++;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p enable collect for %p %x\n",
                  PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                  GuidEntry, GuidEntry->Flags ));
    }

    //
    // If the guid is transitioning from a refcount of 0 to 1 and there
    // is not currently a request in progress, then we need to set the
    // request in progress flag, release the critical section and
    // send an enable request. If there is a request in progress we can't
    // do another request. Whenever the current request finishes  it
    // will notice the ref count change and send the enable request on
    // our behalf.
    if ((RefCount == 0) &&
        ! (GuidEntry->Flags & InProgressFlag)) 
    {
        //
        // Take an extra ref count so that even if this gets disabled
        // while the enable request is in progress the GuidEntry
        // will stay valid.
        WmipReferenceGE(GuidEntry);
        GuidEntry->Flags |= InProgressFlag;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p NE %p flags -> %x at %d\n",
                  PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                  GuidEntry,
                  GuidEntry->Flags,
                  __LINE__));

EnableNotification:
        Status = WmipSendEnableDisableRequest((UCHAR)(IsEvent ?
                                                IRP_MN_ENABLE_EVENTS :
                                                IRP_MN_ENABLE_COLLECTION),
                                              GuidEntry,
                                              IsEvent,
                                              IsTraceLog,
                                              LoggerContext);

       RefCount = IsEvent ? GuidEntry->EventRefCount :
                            GuidEntry->CollectRefCount;

       if (RefCount == 0)
       {
           // This is the bogus situation we were worried about. While
           // the enable request was being processed the notification
           // was disabled. So leave the in progress flag set and
           // send the disable.

           Status = WmipSendEnableDisableRequest((UCHAR)(IsEvent ?
                                                    IRP_MN_DISABLE_EVENTS :
                                                    IRP_MN_DISABLE_COLLECTION),
                                                 GuidEntry,
                                                 IsEvent,
                                                 IsTraceLog,
                                                 LoggerContext);

            RefCount = IsEvent ? GuidEntry->EventRefCount :
                                 GuidEntry->CollectRefCount;

            if (RefCount > 0)
            {
                //
                // We have hit a pathological case. One thread called to
                // enable and while the enable request was being processed
                // another thread called to disable, but was postponed
                // since the enable was in progress. So once the enable
                // completed we realized that the ref count reached 0 and
                // so we need to disable and sent the disable request.
                // But while the disable request was being processed
                // an enable request came in so now we need to enable
                // the notification. Sheesh.
                goto EnableNotification;
            }
        }
        GuidEntry->Flags &= ~InProgressFlag;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p NE %p flags -> %x at %d\n",
                  PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                  GuidEntry,
                  GuidEntry->Flags,
                  __LINE__));
        
        //
        // If there are any other threads that were waiting until all of 
        // the enable/disable work completed, we close the event handle
        // to release them from their wait.
        //
        if (! IsEvent)
        {            
            WmipReleaseCollectionEnabled(GuidEntry);
        }

        //
        // Get rid of extra ref count we took above. Note that the
        // GuidEntry could be going away here if there was a
        // disable while the enable was in progress.
        WmipUnreferenceGE(GuidEntry);

    } else if (IsTraceLog && (GuidEntry->Flags & GE_NOTIFICATION_TRACE_UPDATE) ) {
        //
        // If it's a tracelog and we have a trace Update enable call, ignore the 
        // refcount and send it through. 
        //

        WmipReferenceGE(GuidEntry);

        Status = WmipSendEnableDisableRequest((UCHAR)(IsEvent ?
                                                IRP_MN_ENABLE_EVENTS :
                                                IRP_MN_ENABLE_COLLECTION),
                                              GuidEntry,
                                              IsEvent,
                                              IsTraceLog,
                                              LoggerContext);
        GuidEntry->EventRefCount--;

        WmipUnreferenceGE(GuidEntry);

    } else {
        if ((! IsEvent) && (GuidEntry->Flags & InProgressFlag))
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p going to wait for %p %x at %d\n",
                                          PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                          GuidEntry,
                                          GuidEntry->Flags,
                                          __LINE__));
            WmipWaitForCollectionEnabled(GuidEntry);
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p done to wait for %p %x at %d\n",
                                          PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                          GuidEntry,
                                          GuidEntry->Flags,
                                          __LINE__));
            
        }
        
        Status = STATUS_SUCCESS;
    }

    if (! IsEvent)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p enable collect done for %p %x\n",
                  PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                  GuidEntry,
                  GuidEntry->Flags));
    }

    return(Status);
}

ULONG WmipDoDisableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext,
    ULONG InProgressFlag
    )
{
    ULONG RefCount;
    ULONG Status;

    PAGED_CODE();
    
DisableNotification:
    Status = WmipSendEnableDisableRequest((UCHAR)(IsEvent ?
                                            IRP_MN_DISABLE_EVENTS :
                                            IRP_MN_DISABLE_COLLECTION),
                                          GuidEntry,
                                          IsEvent,
                                          IsTraceLog,
                                          LoggerContext);

    RefCount = IsEvent ? GuidEntry->EventRefCount :
                         GuidEntry->CollectRefCount;

    if (RefCount > 0)
    {
        //
        // While we were processing the disable request an
        // enable request arrived. Since the in progress
        // flag was set the enable request was not sent
        // so now we need to do that.

        Status = WmipSendEnableDisableRequest((UCHAR)(IsEvent ?
                                                 IRP_MN_ENABLE_EVENTS :
                                                 IRP_MN_ENABLE_COLLECTION),
                                              GuidEntry,
                                              IsEvent,
                                              IsTraceLog,
                                              LoggerContext);

        RefCount = IsEvent ? GuidEntry->EventRefCount:
                             GuidEntry->CollectRefCount;

        if (RefCount == 0)
        {
            //
            // While processing the enable request above the
            // notification was disabled and since a request
            // was in progress the disable request was not
            // forwarded. Now it is time to forward the
            // request.
            goto DisableNotification;
        }
    }
    GuidEntry->Flags &= ~InProgressFlag;
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p NE %p flags -> %x at %d\n",
                  PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                  GuidEntry,
                  GuidEntry->Flags,
                  __LINE__));
    
    //
    // If there are any other threads that were waiting until all of 
    // the enable/disable work completed, we close the event handle
    // to release them from their wait.
    //
    if (! IsEvent)
    {
        WmipReleaseCollectionEnabled(GuidEntry);
    }
    
    return(Status);
}

ULONG WmipSendDisableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    )
/*++
Routine Description:

    This routine will send an disable collection or notification request to
    all of the data providers that have registered the guid being disabled.
    This routine will manage any race conditions that might occur when
    multiple threads are enabling and disabling the notification
    simultaneously.

    This routine is called while the SM critical section is being held and
    will increment the appropriate reference count. if the ref count
    transitions from 1 to 0 then the disable request will need to be forwarded
    to the data providers otherwise the routine is all done and returns.
    Before sending the disable request the routine checks to see if any
    enable or disable requests are currently in progress and if not then sets
    the in progress flag, releases the critical section and sends the disable
    request. If there was a request in progress then the routine does not
    send a request, but just returns. When the other thread that was sending
    the request returns from processing the request it will recheck the
    refcount and notice that it is  0 and then send the disable
    request.


Arguments:

    GuidEntry is the Notification entry that describes the guid
        being enabled.

    GuidEntry is the guid entry that describes the guid being enabled. For
        a notification it may be NULL.

    NotificationContext is the notification context to use if enabling events

    IsEvent is TRUE if notifications are being enables else FALSE if
        collection is being enabled

    IsTraceLog is TRUE if enable is for a trace log guid

    LoggerContext is a context value to forward in the enable request

Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG InProgressFlag;
    ULONG RefCount;
    ULONG Status;

    PAGED_CODE();
    
    if (IsEvent)
    {
        InProgressFlag = GE_FLAG_NOTIFICATION_IN_PROGRESS;
        RefCount = GuidEntry->EventRefCount;
        if (RefCount == 0)
        {
            //
            // A bad data consumer is disabling his event more
            // than once. Just ignore it
            return(STATUS_SUCCESS);
        }

        RefCount = --GuidEntry->EventRefCount;
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p Disabling for %p %x\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                 GuidEntry,
                                 GuidEntry->Flags));
        InProgressFlag = GE_FLAG_COLLECTION_IN_PROGRESS;
        RefCount = --GuidEntry->CollectRefCount;
        WmipAssert(RefCount != 0xffffffff);
    }

    //
    // If we have transitioned to a refcount of zero and there is
    // not a request in progress then forward the disable request.
    if ((RefCount == 0) &&
        ! (GuidEntry->Flags & InProgressFlag))
    {

        //
        // Take an extra ref count so that even if this gets
        // disabled while the disable request is in progress the
        // GuidEntry will stay valid.
        GuidEntry->Flags |= InProgressFlag;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p NE %p flags -> %x at %d\n",
                  PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                  GuidEntry,
                  GuidEntry->Flags,
                  __LINE__));

        Status = WmipDoDisableRequest(GuidEntry,
                                      IsEvent,
                                      IsTraceLog,
                                      LoggerContext,
                                      InProgressFlag);
                                  
    } else {
        Status = STATUS_SUCCESS;
    }

    if (! IsEvent)
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p.%p Disable complete for %p %x\n",
                                 PsGetCurrentProcessId(), PsGetCurrentThreadId(),
                                 GuidEntry,
                                 GuidEntry->Flags));
    }
    return(Status);
}


NTSTATUS WmipEnableCollectOrEvent(
    PBGUIDENTRY GuidEntry,
    ULONG Ioctl,
    BOOLEAN *RequestSent,
    ULONG64 LoggerContext
    )
{
    LOGICAL DoEnable;
    BOOLEAN IsEvent, IsTracelog;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    NTSTATUS Status;

    PAGED_CODE();
    
    *RequestSent = FALSE;
    
    switch (Ioctl)
    {
        case IOCTL_WMI_OPEN_GUID_FOR_QUERYSET:
        {
            //
            // See if the guid requires an enable collection. Loop over all
            // instance sets that are not for tracelog or events.
            //
            DoEnable = FALSE;
            IsTracelog = FALSE;
            IsEvent = FALSE;
            WmipEnterSMCritSection();
            InstanceSetList = GuidEntry->ISHead.Flink;
            while (InstanceSetList != &GuidEntry->ISHead) 
            {
                InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        GuidISList);

                if ( ! ((InstanceSet->Flags & IS_TRACED) ||
                        ((InstanceSet->Flags & IS_EVENT_ONLY) && DoEnable)))
                {
                    //
                    // Only those guids not Traced guids, event only guids
                    // and unresolved references are not available for queries
                    DoEnable = (DoEnable || (InstanceSet->Flags & IS_EXPENSIVE));
                }
                InstanceSetList = InstanceSetList->Flink;
            }
        
            WmipLeaveSMCritSection();
            break;
        }
        
        case IOCTL_WMI_OPEN_GUID_FOR_EVENTS:
        {
            //
            // For events we always send enable request
            //
            DoEnable = TRUE;
            IsEvent = TRUE;
            IsTracelog = FALSE;
            //
            // Note: If this guid has GE_NOTIFICATION_TRACE_FLAG set, 
            // then it will get enabled for tracelog as well as for 
            // wmi events. 
            //
            break;
        }
        
        case IOCTL_WMI_ENABLE_DISABLE_TRACELOG:
        {
            //
            // Setup for a tracelog enable request
            //
            DoEnable = TRUE;
            IsEvent = TRUE;
            IsTracelog = TRUE;
            break;
        }
        
        default:
        {
            ASSERT(FALSE);
            return(STATUS_ILLEGAL_FUNCTION);
        }
    }
    
    if (DoEnable)
    {
        WmipEnterSMCritSection();
        Status = WmipSendEnableRequest(GuidEntry,
                              IsEvent,
                              IsTracelog,
                              LoggerContext);
        WmipLeaveSMCritSection();
                          
        if (NT_SUCCESS(Status))
        {
            *RequestSent = TRUE;
        }
    } else {
        Status = STATUS_SUCCESS;
    }
    return(Status);
}

NTSTATUS WmipDisableCollectOrEvent(
    PBGUIDENTRY GuidEntry,
    ULONG Ioctl,
    ULONG64 LoggerContext
    )
{
    BOOLEAN IsEvent, IsTracelog;
    NTSTATUS Status;

    PAGED_CODE();
    
    switch(Ioctl)
    {
        case IOCTL_WMI_OPEN_GUID_FOR_QUERYSET:
        {
            IsEvent = FALSE;
            IsTracelog = FALSE;
            break;
        }
        
        case IOCTL_WMI_OPEN_GUID_FOR_EVENTS:
        {
            //
            // For events we always send enable request
            //    
            IsEvent = TRUE;
            IsTracelog = FALSE;
            break;
        }
            
        case IOCTL_WMI_ENABLE_DISABLE_TRACELOG:
        {
            IsEvent = TRUE;
            IsTracelog = TRUE;
            break;
        }
        
        default:
        {
            ASSERT(FALSE);
            return(STATUS_ILLEGAL_FUNCTION);
        }
            
    }
    
    WmipEnterSMCritSection();
    Status = WmipSendDisableRequest(GuidEntry,
                              IsEvent,
                              IsTracelog,
                              LoggerContext);
    WmipLeaveSMCritSection();

    return(Status);
}

NTSTATUS WmipEnableDisableTrace(
    IN ULONG Ioctl,
    IN PWMITRACEENABLEDISABLEINFO TraceEnableInfo
    )
/*++

Routine Description:

    This routine will enable or disable a tracelog guid

Arguments:

   Ioctl is the IOCTL used to call this routine from UM
         
   TraceEnableInfo has all the info needed to enable or disable

Return Value:


--*/
{
    NTSTATUS Status;
    LPGUID Guid;
    PBGUIDENTRY GuidEntry;
    BOOLEAN RequestSent;
    BOOLEAN IsEnable;
    ULONG64 LoggerContext;
    
    PAGED_CODE();
    
    Guid = &TraceEnableInfo->Guid;
    
    Status = WmipCheckGuidAccess(Guid,
                                 TRACELOG_GUID_ENABLE,
                                 EtwpDefaultTraceSecurityDescriptor);

                
    if (NT_SUCCESS(Status))
    {

        //
        // The following code is serialized for Trace Guids. Only one 
        // control application can be enabling or disabling Trace Guids at a time. 
        // Must be taken before SMCritSection is taken. Otherwise deadlocks will result.
        //
        
        WmipEnterTLCritSection();

        IsEnable = TraceEnableInfo->Enable;

        //
        //Check for Heap and Crit Sec Tracing Guid.
        //

        if( IsEqualGUID(&HeapGuid,Guid)) {

            if(IsEnable){

	            SharedUserData->TraceLogging |= ENABLEHEAPTRACE;

                //
                // increment counter. The counter  
                // is composed of first two bytes
                //

                SharedUserData->TraceLogging += 0x00010000; 


            } else {

                SharedUserData->TraceLogging &= DISABLEHEAPTRACE;
            }

			WmipLeaveTLCritSection();
			return STATUS_SUCCESS;
        } else if(IsEqualGUID(&CritSecGuid,Guid)){  

            if(IsEnable) {

	            SharedUserData->TraceLogging |= ENABLECRITSECTRACE;

                //
                // increment counter. The counter  
                // is composed of first two bytes
                //

                SharedUserData->TraceLogging += 0x00010000; 

            } else {

                SharedUserData->TraceLogging &= DISABLECRITSECTRACE;
            }

			WmipLeaveTLCritSection();
			return STATUS_SUCCESS;

        } else if(IsEqualGUID(&NtdllTraceGuid,Guid)){  

            if(!IsEnable){

                SharedUserData->TraceLogging &= DISABLENTDLLTRACE;

            }
        }

        LoggerContext = TraceEnableInfo->LoggerContext;
        
        WmipEnterSMCritSection();

        GuidEntry = WmipFindGEByGuid(Guid, FALSE);
        
        if (GuidEntry == NULL )
        {
            //
            // The guid is not yet registered
            //
            if (IsEnable )
            {
                //
                // If the NtdllTraceGuid is not in list then we do not want to enable it
                // the NtdllTraceGuid will make an entry only to call starttrace
                //

                if(IsEqualGUID(&NtdllTraceGuid,Guid)){

                    Status = STATUS_ILLEGAL_FUNCTION;

                } else {

                    //
                    // If we are enabling a guid that is not yet registered
                    // we need to create the guid object for it
                    //

                    GuidEntry = WmipAllocGuidEntry();
                    if (GuidEntry != NULL)
                    {
                        //
                        // Initialize the guid entry and keep the ref count
                        // from creation. When tracelog enables we take a ref
                        // count and when it disables we release it
                        //
                        GuidEntry->Guid = *Guid;
                        GuidEntry->Flags |= GE_NOTIFICATION_TRACE_FLAG;
                        GuidEntry->LoggerContext = LoggerContext;
                        GuidEntry->EventRefCount = 1; 
                        InsertHeadList(WmipGEHeadPtr, &GuidEntry->MainGEList);
                        Status = STATUS_SUCCESS;                    
                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            } 

        } else {
            //
            // The control guid is already registered so lets go and
            // enabled or disable it
            //
            if (WmipIsControlGuid(GuidEntry))
            {
                if (IsEnable)
                {
                    GuidEntry->LoggerContext = LoggerContext;
                    if (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)
                    {
                        //
                        // We are trying to disable a trace guid that is not
                        // registered
                        //
                        GuidEntry->Flags |= GE_NOTIFICATION_TRACE_UPDATE;
                        Status = WmipEnableCollectOrEvent(GuidEntry,
                                             Ioctl,
                                             &RequestSent,
                                             LoggerContext);

                    } else {
                        GuidEntry->Flags |= GE_NOTIFICATION_TRACE_FLAG;
                        Status = WmipEnableCollectOrEvent(GuidEntry,
                                             Ioctl,
                                             &RequestSent,
                                             LoggerContext);
                        if (NT_SUCCESS(Status))
                        {
                            //
                            // We are enabling so take an extra ref count
                            // to account for it. The refcount will be lost
                            // when the control guid is disabled
                            //
                            WmipReferenceGE(GuidEntry);
                        }
                    }

                } else {

                    if (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)
                    {
                        //
                        // Send the disable collection call and then remove
                        // the refcount that was taken when we enabled
                        //
                        GuidEntry->Flags &= ~GE_NOTIFICATION_TRACE_FLAG;
                        Status = WmipDisableCollectOrEvent(GuidEntry,
                                                 Ioctl,
                                                 LoggerContext);
                        //
                        // Whether the Disable request succeeds or not
                        // we will remove the extra refcount since we 
                        // reset the NOTIFICATION_FLAG
                        //
                        GuidEntry->LoggerContext = 0;
                        WmipUnreferenceGE(GuidEntry);
                    } else {
                        Status = STATUS_WMI_ALREADY_DISABLED;
                    }
                }
            } else if ( IsListEmpty(&GuidEntry->ISHead)  && (! IsEnable) ) {
                //
                // If this GUID is not a control GUID, check to see if 
                // there are no instance sets for this GUID. If so, 
                // it is getting disabled before any instances 
                // registered it. Disable the GUID and clean up the GE. 
                //
                if (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)
                {
                    GuidEntry->Flags &= ~GE_NOTIFICATION_TRACE_FLAG;
                    GuidEntry->LoggerContext = 0;
                    WmipUnreferenceGE(GuidEntry);
                }
                Status = STATUS_SUCCESS;

            } else if(!IsEqualGUID(&NtdllTraceGuid,Guid)){

                Status = STATUS_ILLEGAL_FUNCTION;

            }

            WmipUnreferenceGE(GuidEntry);
        }

        WmipLeaveSMCritSection();

        WmipLeaveTLCritSection();
    }
    return(Status);
}


//
// When a Logger is shutdown, all providers logging to this logger
// are notified to stop logging first.
//

NTSTATUS 
WmipDisableTraceProviders (
    ULONG StopLoggerId
    )
{
    PBGUIDENTRY GuidEntry;
    PLIST_ENTRY GuidEntryList;
    ULONG LoggerId;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Find all the providers that are logging to this logger
    // and disable them automatically.
    //
CheckAgain:

    WmipEnterSMCritSection();

    GuidEntryList = WmipGEHeadPtr->Flink;
    while (GuidEntryList != WmipGEHeadPtr)
    {
        GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                     GUIDENTRY,
                                     MainGEList);

        if (GuidEntry->Flags & GE_NOTIFICATION_TRACE_FLAG)
        {
            LoggerId = WmiGetLoggerId(GuidEntry->LoggerContext);
            if (LoggerId == StopLoggerId) {
                //
                // Send Disable Notification
                //
                WmipReferenceGE(GuidEntry);
                GuidEntry->Flags &= ~GE_NOTIFICATION_TRACE_FLAG;
                Status = WmipSendDisableRequest(GuidEntry,
                          TRUE,
                          TRUE,
                          GuidEntry->LoggerContext);
                //
                // Since we reset the NOTIFICATION_TRACE_FLAG
                // we will take out the extra ref count whether the 
                // SendDisableRequest was successful or not. 
                //
                GuidEntry->LoggerContext = 0;
                WmipUnreferenceGE(GuidEntry);

                //
                // We need to remove the refcount that was taken when this
                // Guid was Enabled. 
                //

                WmipUnreferenceGE(GuidEntry);

                WmipLeaveSMCritSection();

                //
                // We have to jump out and restart the loop because we let go 
                // of the critsect during SendDisableRequest call
                //
                goto CheckAgain;

            }
        }
        GuidEntryList = GuidEntryList->Flink;
    }

    WmipLeaveSMCritSection();

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\mca.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    Mca.c

Abstract:

    Machine Check Architecture interface

Author:

    AlanWar

Environment:

    Kernel mode

Revision History:


--*/

#pragma warning(disable:4206)   // translation unit empty

#include "wmikmp.h"

#include <mce.h>

#include "hal.h"

#include "ntiologc.h"


#define MCA_EVENT_INSTANCE_NAME L"McaEvent"
#define MCA_UNDEFINED_CPU 0xffffffff

#if defined(_IA64_)
#define SAL_30_ERROR_REVISION 0x0002
#define HalpGetFwMceLogProcessorNumber( /* PERROR_RECORD_HEADER */ _Log ) \
    ((UCHAR) (_Log)->TimeStamp.Reserved )
#endif

#if defined(_X86_) || defined(_AMD64_)
#define HalpGetFwMceLogProcessorNumber( /* PMCA_EXCEPTION */ _Log ) \
    ( (_Log)->ProcessorNumber )
typedef MCA_EXCEPTION ERROR_LOGRECORD, *PERROR_LOGRECORD;
typedef MCA_EXCEPTION ERROR_RECORD_HEADER, *PERROR_RECORD_HEADER;
#endif

//
// Types of corrected errors that are tracked
//
typedef enum
{
    SingleBitEcc,
    CpuCache,
    CpuTlb,
    CpuBus,
    CpuRegFile
} MCECORRECTEDTYPE, *PMCECORRECTEDTYPE;

typedef struct
{
    LIST_ENTRY List;
    MCECORRECTEDTYPE Type;
    USHORT Counter;
    USHORT Flags;
    LARGE_INTEGER Timestamp;
    
    union
    {
        //
        // For SingleBitEcc type, indicates physical address of page
        // where error occured
        //
        PHYSICAL_ADDRESS SingleBitEccAddress;

        //
        // For Cpu* types, indicates cpu on which the error
        // occured
        //
        ULONG CpuId;
    };
} MCECORRECTEDEVENT, *PMCECORRECTEDEVENT;

#define CORRECTED_MCE_EVENT_BUSY 0x0001

BOOLEAN WmipMceEventDelivery(
    IN PVOID Reserved,
    IN KERNEL_MCE_DELIVERY_OPERATION Operation,
    IN PVOID Argument2
    );

BOOLEAN WmipMceDelivery(
    IN PVOID Reserved,
    IN KERNEL_MCE_DELIVERY_OPERATION Operation,
    IN PVOID Argument2
    );

void WmipMceWorkerRoutine(    
    IN PVOID Context             // Not Used
    );

NTSTATUS WmipGetLogFromHal(
    HAL_QUERY_INFORMATION_CLASS InfoClass,
    PVOID Token,
    PWNODE_SINGLE_INSTANCE *Wnode,
    PERROR_LOGRECORD *Mca,
    PULONG McaSize,
    ULONG MaxSize,
    LPGUID Guid
    );

NTSTATUS WmipRegisterMcaHandler(
    ULONG Phase
    );

NTSTATUS WmipBuildMcaCmcEvent(
    OUT PWNODE_SINGLE_INSTANCE Wnode,
    IN LPGUID EventGuid,
    IN PERROR_LOGRECORD McaCmcEvent,
    IN ULONG McaCmcSize
    );

NTSTATUS WmipGetRawMCAInfo(
    OUT PUCHAR Buffer,
    IN OUT PULONG BufferSize
    );

NTSTATUS WmipWriteMCAEventLogEvent(
    PUCHAR Event
    );

NTSTATUS WmipSetupWaitForWbem(
    void
    );

void WmipIsWbemRunningDispatch(    
    IN PKDPC Dpc,
    IN PVOID DeferredContext,     // Not Used
    IN PVOID SystemArgument1,     // Not Used
    IN PVOID SystemArgument2      // Not Used
    );

void WmipPollingDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,     // MCEQUERYINFO
    IN PVOID SystemArgument1,     // New polling interval
    IN PVOID SystemArgument2      // Not used
    );

void WmipIsWbemRunningWorker(
    PVOID Context
    );

BOOLEAN WmipCheckIsWbemRunning(
    void
    );

void WmipProcessPrevMcaLogs(
    void
    );

void WmipFreeCorrectedMCEEvent(
    PMCECORRECTEDEVENT Event
    );

PMCECORRECTEDEVENT WmipAllocCorrectedMCEEvent(
     MCECORRECTEDTYPE Type
    );

NTSTATUS WmipTrackCorrectedMCE(
    IN MCECORRECTEDTYPE Type,
    IN PERROR_RECORD_HEADER Record,
#if defined(_IA64_)
    IN PERROR_SECTION_HEADER Section,
#endif
    OUT ULONG *LogToEventlog
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,WmipAllocCorrectedMCEEvent)
#pragma alloc_text(PAGE,WmipFreeCorrectedMCEEvent)
#pragma alloc_text(PAGE,WmipTrackCorrectedMCE)
#pragma alloc_text(PAGE,WmipRegisterMcaHandler)
#pragma alloc_text(PAGE,WmipMceWorkerRoutine)
#pragma alloc_text(PAGE,WmipGetLogFromHal)
#pragma alloc_text(PAGE,WmipBuildMcaCmcEvent)
#pragma alloc_text(PAGE,WmipGetRawMCAInfo)
#pragma alloc_text(PAGE,WmipWriteMCAEventLogEvent)
#pragma alloc_text(PAGE,WmipGenerateMCAEventlog)
#pragma alloc_text(PAGE,WmipIsWbemRunningWorker)
#pragma alloc_text(PAGE,WmipCheckIsWbemRunning)
#pragma alloc_text(PAGE,WmipSetupWaitForWbem)
#pragma alloc_text(PAGE,WmipProcessPrevMcaLogs)
#endif


//
// Set to TRUE when the registry indicates that popups should be
// disabled. HKLM\System\CurrentControlSet\Control\WMI\DisableMCAPopups
//
ULONG WmipDisableMCAPopups;

//
// Guids for the various RAW MCA/CMC/CPE events
//
GUID WmipMSMCAEvent_CPUErrorGuid = MSMCAEvent_CPUErrorGuid;
GUID WmipMSMCAEvent_MemoryErrorGuid = MSMCAEvent_MemoryErrorGuid;
GUID WmipMSMCAEvent_PCIBusErrorGuid = MSMCAEvent_PCIBusErrorGuid;
GUID WmipMSMCAEvent_PCIComponentErrorGuid = MSMCAEvent_PCIComponentErrorGuid;
GUID WmipMSMCAEvent_SystemEventErrorGuid = MSMCAEvent_SystemEventErrorGuid;
GUID WmipMSMCAEvent_SMBIOSErrorGuid = MSMCAEvent_SMBIOSErrorGuid;
GUID WmipMSMCAEvent_PlatformSpecificErrorGuid = MSMCAEvent_PlatformSpecificErrorGuid;
GUID WmipMSMCAEvent_InvalidErrorGuid = MSMCAEvent_InvalidErrorGuid;
GUID WmipMSMCAEvent_MemoryPageRemoved = MSMCAEvent_MemoryPageRemovedGuid;

//
// GUIDs for the different error sections within a MCA
//
#if defined(_IA64_)
GUID WmipErrorProcessorGuid = ERROR_PROCESSOR_GUID;
GUID WmipErrorMemoryGuid = ERROR_MEMORY_GUID;
GUID WmipErrorPCIBusGuid = ERROR_PCI_BUS_GUID;
GUID WmipErrorPCIComponentGuid = ERROR_PCI_COMPONENT_GUID;
GUID WmipErrorSELGuid = ERROR_SYSTEM_EVENT_LOG_GUID;
GUID WmipErrorSMBIOSGuid = ERROR_SMBIOS_GUID;
GUID WmipErrorSpecificGuid = ERROR_PLATFORM_SPECIFIC_GUID;
#endif

//
// Each type of MCE has a control structure that is used to determine
// whether to poll or wait for an interrupt to determine when to query
// for the logs.  This is needed since we can get a callback from the
// HAL at high IRQL to inform us that a MCE log is available.
// Additionally Ke Timer used for polling will calls us at DPC level.
// So in the case of an interrupt we will queue a DPC. Within the DPC
// routine we will queue a work item so that we can get back to
// passive level and be able to call the hal to get the logs (Can only
// call hal at passive). The DPC and work item routines are common so a
// MCEQUERYINFO struct is passed around so that it can operate on the
// correct log type. Note that this implies that there may be multiple
// work items querying the hal for different log types at the same
// time. In addition this struct also contains useful log related
// information including the maximum log size (as reported by the HAL),
// the token that must be passed to the HAL when querying for the
// logs and the HAL InfoClass to use when querying for the logs.
//
// PollFrequency keeps track of the number of seconds before initiating a
// query. If it is 0 (HAL_CPE_DISABLED / HAL_CMC_DISABLED) then no
// polling occurs and if it is -1 (HAL_CPE_INTERRUPTS_BASED /
// HAL_CMC_INTERRUPTS_BASED) then no polling occurs either. There is
// only one work item active for each log type and this is enforced via
// ItemsOutstanding in that only whenever it transitions from 0 to 1 is
// the work item queued.
//
#define DEFAULT_MAX_MCA_SIZE 0x1000
#define DEFAULT_MAX_CMC_SIZE 0x1000
#define DEFAULT_MAX_CPE_SIZE 0x1000

typedef struct
{
    HAL_QUERY_INFORMATION_CLASS InfoClass;  // HAL Info class to use in MCE query
    ULONG PollFrequency;                    // Polling Frequency in seconds
    PVOID Token;                            // HAL Token to use in MCE Queries
    LONG ItemsOutstanding;                  // Number of interrupts or poll requests to process
    ULONG MaxSize;                          // Max size for log (as reported by HAL)
    GUID WnodeGuid;                         // GUID to use for the raw data event
    GUID SwitchToPollGuid;                  // GUID to use to fire event for switching to polled mode
    NTSTATUS SwitchToPollErrorCode;         // Eventlog error code that indicates a switch to polled mode
    ULONG WorkerInProgress;                 // Set to 1 if worker routine is running
    KSPIN_LOCK DpcLock;
    KDPC DeliveryDpc;                       // DPC to handle delivery
    KTIMER PollingTimer;                    // KTIMER used for polling
    KDPC PollingDpc;                        // DPC to use for polling
    WORK_QUEUE_ITEM WorkItem;               // Work item used to query for log
} MCEQUERYINFO, *PMCEQUERYINFO;

MCEQUERYINFO WmipMcaQueryInfo =
{
    HalMcaLogInformation,
    HAL_MCA_INTERRUPTS_BASED,               // Corrected MCA are delivered by interrupts
    NULL,
    0,
    DEFAULT_MAX_MCA_SIZE,
    MSMCAInfo_RawMCAEventGuid
};

MCEQUERYINFO WmipCmcQueryInfo =
{
    HalCmcLogInformation,
    HAL_CMC_DISABLED,
    NULL,
    0,
    DEFAULT_MAX_CMC_SIZE,
    MSMCAInfo_RawCMCEventGuid,
    MSMCAEvent_SwitchToCMCPollingGuid,
    MCA_WARNING_CMC_THRESHOLD_EXCEEDED,
    0
};
                               
MCEQUERYINFO WmipCpeQueryInfo =
{
    HalCpeLogInformation,
    HAL_CPE_DISABLED,
    NULL,
    0,
    DEFAULT_MAX_CPE_SIZE,
    MSMCAInfo_RawCorrectedPlatformEventGuid,
    MSMCAEvent_SwitchToCPEPollingGuid,
    MCA_WARNING_CPE_THRESHOLD_EXCEEDED,
    0
};


//
// Used for waiting until WBEM is ready to receive events
//
KTIMER WmipIsWbemRunningTimer;
KDPC WmipIsWbemRunningDpc;
WORK_QUEUE_ITEM WmipIsWbemRunningWorkItem;
LIST_ENTRY WmipWaitingMCAEvents = {&WmipWaitingMCAEvents, &WmipWaitingMCAEvents};

#define WBEM_STATUS_UNKNOWN 0   // Polling process for waiting is not started
#define WBEM_IS_RUNNING 1       // WBEM is currently running
#define WAITING_FOR_WBEM  2     // Polling process for waiting is started
UCHAR WmipIsWbemRunningFlag;



#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

//
// MCA information obtained at boot and holds the MCA that caused the
// system to bugcheck on the previous boot
//
ULONG WmipRawMCASize;
PMSMCAInfo_RawMCAData WmipRawMCA;

//
// Status of the MCE registration process
//
#define MCE_STATE_UNINIT     0
#define MCE_STATE_REGISTERED 1
#define MCE_STATE_RUNNING    2
#define MCE_STATE_ERROR      -1
ULONG WmipMCEState;


//
// Configurable paramters for managing thresholds for eventlog
// suppression and recovery action for corrected MCE
//

//
// Interval within which multiple identical errors will be reported as
// a single error to the system eventlog. Can be configured under
// HKLM\System\CurrentControlSet\Control\WMI\CoalesceCorrectedErrorInterval
// A value of 0 will cause no coalesce of identical errors
//
ULONG WmipCoalesceCorrectedErrorInterval = 5000;

//
// Number of single bit ecc errors that can occur in the same page
// before it is attempted to map out the page. Can be configured under : 
// HKLM\System\CurrentControlSet\Control\WMI\SingleBitEccErrorThreshold
// A value of 0 will cause no attempt to map out pages
//
ULONG WmipSingleBitEccErrorThreshold = 6;


//
// Maxiumum number of MCE events being tracked at one time. If there is
// more than this limit then the oldest ones are recycled. Can be
// configured under :
// HKLM\System\CurrentControlSet\Control\WMI\MaxCorrectedMCEOutstanding
// A value of 0 will disable tracking of corrected errors
//
ULONG WmipMaxCorrectedMCEOutstanding = 5;

//
// List of corrected MCE that are being tracked
//
LIST_ENTRY WmipCorrectedMCEHead = {&WmipCorrectedMCEHead, &WmipCorrectedMCEHead};
ULONG WmipCorrectedMCECount;

//
// Counter of maximum eventlog entries generated by any source. Can be
// configured under:
// HKLM\System\CurrentControlSet\Control\WMI\MaxCorrectedEventlogs
//
ULONG WmipCorrectedEventlogCounter = 20;

//
// Check if WBEM is already running and if not check if we've already
// kicked off the timer that will wait for wbem to start
//
#define WmipIsWbemRunning() ((WmipIsWbemRunningFlag == WBEM_IS_RUNNING) ? \
                                                       TRUE : \
                                                       FALSE)
void WmipInsertQueueMCEDpc(
    PMCEQUERYINFO QueryInfo
    );



NTSTATUS WmipWriteToEventlog(
    NTSTATUS ErrorCode,
    NTSTATUS FinalStatus
    )
{
    PIO_ERROR_LOG_PACKET ErrLog;
    NTSTATUS Status;

    ErrLog = IoAllocateErrorLogEntry(WmipServiceDeviceObject,
                                     sizeof(IO_ERROR_LOG_PACKET));

    if (ErrLog != NULL) {

        //
        // Fill it in and write it out as a single string.
        //
        ErrLog->ErrorCode = ErrorCode;
        ErrLog->FinalStatus = FinalStatus;

        ErrLog->StringOffset = 0;
        ErrLog->NumberOfStrings = 0;

        IoWriteErrorLogEntry(ErrLog);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return(Status);
}

NTSTATUS WmipFireOffWmiEvent(
    LPGUID Guid,
    ULONG DataSize,
    PVOID DataPtr            
    )
{
    PVOID Ptr;
    PWNODE_SINGLE_INSTANCE Wnode;
    PWCHAR Wptr;
    ULONG RoundedDataSize;
    NTSTATUS Status;

    RoundedDataSize = (DataSize + 1) & ~1;
    
    Wnode = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(WNODE_SINGLE_INSTANCE) +
                                       RoundedDataSize +
                                      sizeof(USHORT) +
                                       sizeof(MCA_EVENT_INSTANCE_NAME),
                                  WmipMCAPoolTag);

    if (Wnode != NULL)
    {
        Wnode->WnodeHeader.BufferSize = sizeof(WNODE_SINGLE_INSTANCE) +
                                       sizeof(USHORT) +
                                        RoundedDataSize +
                                       sizeof(MCA_EVENT_INSTANCE_NAME);
        Wnode->WnodeHeader.Guid = *Guid;

        Wnode->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE |
                                   WNODE_FLAG_EVENT_ITEM;
        KeQuerySystemTime(&Wnode->WnodeHeader.TimeStamp);

        Wnode->DataBlockOffset = sizeof(WNODE_SINGLE_INSTANCE);
        Wnode->SizeDataBlock = DataSize;
        if (DataPtr != NULL)
        {
            Ptr = OffsetToPtr(Wnode, Wnode->DataBlockOffset);
            memcpy(Ptr, DataPtr, DataSize);
        }
        Wnode->OffsetInstanceName = sizeof(WNODE_SINGLE_INSTANCE) + RoundedDataSize;

        Wptr = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
        *Wptr++ = sizeof(MCA_EVENT_INSTANCE_NAME);
        RtlCopyMemory(Wptr,
                      MCA_EVENT_INSTANCE_NAME,
                      sizeof(MCA_EVENT_INSTANCE_NAME));

        Status = IoWMIWriteEvent(Wnode);
        if (! NT_SUCCESS(Status))
        {
            ExFreePool(Wnode);
        }
    }
    else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(Status);
}

NTSTATUS WmipBuildMcaCmcEvent(
    OUT PWNODE_SINGLE_INSTANCE Wnode,
    IN LPGUID EventGuid,
    IN PERROR_LOGRECORD McaCmcEvent,
    IN ULONG McaCmcSize
    )
/*++

Routine Description:


    This routine will take a MCA or CMC log and build a
    WNODE_EVENT_ITEM for it.

    This routine may be called at DPC

Arguments:

    Wnode is the wnode buffer in which to build the event

    EventGuid is the guid to use in the event wnode

    McaCmcEvent is the MCA, CMC or CPE data payload to put into the
            event

    McaCmcSize is the size of the event data


Return Value:

    NT status code

--*/
{
    PMSMCAInfo_RawCMCEvent Ptr;
    ULONG Size;

    PAGED_CODE();

    Size = McaCmcSize + FIELD_OFFSET(MSMCAInfo_RawCMCEvent,
                                                     Records) +
                                        FIELD_OFFSET(MSMCAInfo_Entry, Data);
    
    RtlZeroMemory(Wnode, sizeof(WNODE_SINGLE_INSTANCE));
    Wnode->WnodeHeader.BufferSize = Size + sizeof(WNODE_SINGLE_INSTANCE);
    Wnode->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(WmipServiceDeviceObject);
    KeQuerySystemTime(&Wnode->WnodeHeader.TimeStamp);       
    Wnode->WnodeHeader.Guid = *EventGuid;
    Wnode->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE |
                               WNODE_FLAG_EVENT_ITEM |
                               WNODE_FLAG_STATIC_INSTANCE_NAMES;
    Wnode->DataBlockOffset = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                          VariableData);
    Wnode->SizeDataBlock = Size;
    Ptr = (PMSMCAInfo_RawCMCEvent)&Wnode->VariableData;
    Ptr->Count = 1;                           // 1 Record in this event
    Ptr->Records[0].Length = McaCmcSize;       // Size of log record in bytes
    if (McaCmcEvent != NULL)
    {
        RtlCopyMemory(Ptr->Records[0].Data, McaCmcEvent, McaCmcSize);
    }
    
    return(STATUS_SUCCESS);
}

NTSTATUS WmipQueryLogAndFireEvent(
    PMCEQUERYINFO QueryInfo
    )
/*++

Routine Description:

    Utility routine that will query the hal for a log and then if one
    is returned successfully then will fire the appropriate WMI events 

Arguments:

    QueryInfo is a pointer to the MCEQUERYINFO for the type of log that
    needs to be queried.

Return Value:

--*/
{
    PWNODE_SINGLE_INSTANCE Wnode;
    NTSTATUS Status, Status2;
    ULONG Size;
    PERROR_LOGRECORD Log;   

    PAGED_CODE();

    //
    // Call HAL to get the log
    //
    Status = WmipGetLogFromHal(QueryInfo->InfoClass,
                               QueryInfo->Token,
                               &Wnode,
                               &Log,
                               &Size,
                               QueryInfo->MaxSize,
                               &QueryInfo->WnodeGuid);

    if (NT_SUCCESS(Status))
    {
        //
        // Look at the event and fire it off as WMI events that
        // will generate eventlog events
        //
        WmipGenerateMCAEventlog((PUCHAR)Log,
                                Size,
                                FALSE);

        //
        // Fire the log off as a WMI event
        //
        Status2 = IoWMIWriteEvent(Wnode);
        if (! NT_SUCCESS(Status2))
        {
            //
            // IoWMIWriteEvent will free the wnode back to pool,
            // but not if it fails
            //
            ExFreePool(Wnode);
        }
        
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                          DPFLTR_MCA_LEVEL,
                          "WMI: MCE Event fired to WMI -> %x\n",
                          Status));
        
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                          DPFLTR_MCA_LEVEL,
                          "WMI: MCE Event for %p not available %x\n",
                          QueryInfo, Status));
    }
    return(Status);
}

void WmipMceWorkerRoutine(    
    IN PVOID Context             // MCEQUERYINFO
    )
/*++

Routine Description:

    Worker routine that handles polling for corrected MCA, CMC and CPE
    logs from the HAL and then firing them as WMI events.

Arguments:

    Context is a pointer to the MCEQUERYINFO for the type of log that
    needs to be queried.

Return Value:

--*/
{
    PMCEQUERYINFO QueryInfo = (PMCEQUERYINFO)Context;
    NTSTATUS Status;
    ULONG i;
    LONG x, Count;

    PAGED_CODE();

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                      "WMI: WmipMceWorkerRoutine %p enter\n",
                     QueryInfo));

    //
    // If the worker is already in progress then we just exit
    //
    WmipEnterSMCritSection();
    if (QueryInfo->WorkerInProgress == 0)
    {
        QueryInfo->WorkerInProgress = 1;
        WmipLeaveSMCritSection();
    } else {
        WmipLeaveSMCritSection();
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                          "WMI: WmipMceWorkerRoutine %p in progress\n",
                         QueryInfo));
        return;
    }

    //
    // Check to see if access has already been disabled
    //
    if (QueryInfo->PollFrequency != HAL_MCE_DISABLED)
    {
        //
        // We get all of the records by calling into the hal and querying
        // for the logs until the hal returns an error or we've
        // retrieved 256 records. We want to protect ourselves from the
        // case where a repeated corrected error would cause the loop
        // to be infinite.
        //
        i = 0;
        do
        {
            //
            // Remember how many corrected errors we have received up until
            // this point. We guarantee that we've handled them up
            // until this point
            //
            Count = QueryInfo->ItemsOutstanding;

            Status = WmipQueryLogAndFireEvent(QueryInfo);           
        } while ((NT_SUCCESS(Status) && (i++ < 256)));

        //
        // Reset counter back to 0, but check if any errors
        // had occured while we were processing. If so we go
        // back and make sure they are handled. Note that this
        // could cause a new worker thread to be created while we
        // are still processing these, but that is ok since we only
        // allow one worker thread to run at one time.
        //
        WmipEnterSMCritSection();
        x = InterlockedExchange(&QueryInfo->ItemsOutstanding,
                                0);
        if ((x > Count) && (i < 257))
        {
            //
            // Since there are still more corrected errors to
            // process, queue a new DPC to cause a new worker
            // routine to be run.
            //
            WmipInsertQueueMCEDpc(QueryInfo);
        }

        QueryInfo->WorkerInProgress = 0;
        WmipLeaveSMCritSection();
    }
}

void WmipMceDispatchRoutine(
    PMCEQUERYINFO QueryInfo
    )
{

    ULONG x;

    //
    // Increment the number of items that are outstanding for this info
    // class. If the number of items outstanding transitions from 0 to
    // 1 then this implies that a work item for this info class needs
    // to be queued
    //
    x = InterlockedIncrement(&QueryInfo->ItemsOutstanding);

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                      "WMI: WmipMceDispatchRoutine %p transition to %d\n",
                     QueryInfo,
                     x));

    if (x == 1)
    {
        ExQueueWorkItem(&QueryInfo->WorkItem,
                        DelayedWorkQueue);
    }
}

void WmipMceDpcRoutine(    
    IN PKDPC Dpc,
    IN PVOID DeferredContext,     // Not Used
    IN PVOID SystemArgument1,     // MCEQUERYINFO
    IN PVOID SystemArgument2      // Not used
    )
{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument2);

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                      "WMI: WmipMceDpcRoutine %p Enter\n",
                     SystemArgument1));
    
    WmipMceDispatchRoutine((PMCEQUERYINFO)SystemArgument1);
}


void WmipPollingDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,     // MCEQUERYINFO
    IN PVOID SystemArgument1,     // New polling Interval
    IN PVOID SystemArgument2      // Not used
    )
{
    PMCEQUERYINFO QueryInfo = (PMCEQUERYINFO)DeferredContext;
    LARGE_INTEGER li;
    ULONG PollingInterval = PtrToUlong(SystemArgument1);

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (SystemArgument2);

    if (QueryInfo->PollFrequency == HAL_MCE_INTERRUPTS_BASED)
    {
        //
        // HAL has instructed us to switch into polled mode and has
        // informed us of the new polling interval.
        //

        QueryInfo->PollFrequency = PollingInterval;

        li.QuadPart = -1 * (QueryInfo->PollFrequency * 1000000000);
        KeSetTimerEx(&QueryInfo->PollingTimer,
                     li,
                     QueryInfo->PollFrequency * 1000,
                     &QueryInfo->PollingDpc);

        //
        // Make a note in the eventlog that this has occured. 
        //
        WmipWriteToEventlog(QueryInfo->SwitchToPollErrorCode,
                            STATUS_SUCCESS
                           );
        
        //
        // Inform any WMI consumers that the switch has occured
        //
        WmipFireOffWmiEvent(&QueryInfo->SwitchToPollGuid,
                           0,
                           NULL);
    } else {
        //
        // Our timer fired so we need to poll
        //
        WmipMceDispatchRoutine(QueryInfo);
    }
}

BOOLEAN WmipMceDelivery(
    IN PVOID Reserved,
    IN KERNEL_MCE_DELIVERY_OPERATION Operation,
    IN PVOID Argument2
    )
/*++

Routine Description:


    This routine is called by the HAL when a CMC or CPE occurs. It is called
    at high irql

Arguments:

    Operation is the operation that the HAL is instructing us to do

    Reserved is the CMC token

    Parameter for operation specified.
        For CmcSwitchToPolledMode and CpeSwitchToPolledMode, Parameter
        specifies the number of seconds to between polling.


Return Value:

    TRUE to indicate that we handled the delivery

--*/
{
    PMCEQUERYINFO QueryInfo;
    BOOLEAN ret;
    
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                      "WMI: MceDelivery Operation %d(%p)\n",
                     Operation, Argument2));

    //
    // First figure out which type of MCE we are dealing with
    //
    switch (Operation)
    {
        case CmcAvailable:
        case CmcSwitchToPolledMode:
        {
            QueryInfo = &WmipCmcQueryInfo;
            break;
        }
        
        case CpeAvailable:
        case CpeSwitchToPolledMode:
        {
            QueryInfo = &WmipCpeQueryInfo;
            break;
        }

        case McaAvailable:
        {
            QueryInfo = &WmipMcaQueryInfo;
            break;
        }
        
        default:
        {
            WmipAssert(FALSE);
            return(FALSE);
        }
    }


    //
    // Next determine what action to perform
    //
    switch (Operation)
    {
        case CmcAvailable:
        case CpeAvailable:
        case McaAvailable:
        {
            //
            // Store the HAL token which is needed to retrieve the logs from
            // the hal
            //
            QueryInfo->Token = Reserved;

            //
            // If we are ready to handle the logs and we are dealing with thse
            // logs  on an interrupt basis, then go ahead and queue a DPC to handle
            // processing the log
            //
            if ((WmipMCEState == MCE_STATE_RUNNING) &&
                (QueryInfo->PollFrequency == HAL_MCE_INTERRUPTS_BASED))

            {
                KeAcquireSpinLockAtDpcLevel(&QueryInfo->DpcLock);
                KeInsertQueueDpc(&QueryInfo->DeliveryDpc,
                                 QueryInfo,
                                 NULL);
                KeReleaseSpinLockFromDpcLevel(&QueryInfo->DpcLock);
                ret = TRUE;
            } else {
                ret = FALSE;
            }
            break;
        }

        case CmcSwitchToPolledMode:
        case CpeSwitchToPolledMode:
        {
            KeInsertQueueDpc(&QueryInfo->PollingDpc,
                             Argument2,
                             NULL);
            ret = TRUE;
            break;
        }
        default:
        {
            ret = FALSE;
            break;
        }
    }

    return(ret);
}

BOOLEAN WmipMceEventDelivery(
    IN PVOID Reserved,
    IN KERNEL_MCE_DELIVERY_OPERATION Operation,
    IN PVOID Argument2
    )
/*++

Routine Description:


    This routine is called by the HAL when a situation occurs between
    the HAL and SAL interface. It is called at high irql

Arguments:

    Reserved has the Operation and EventType

    Argument2 has the SAL return code

Return Value:


--*/
{
    USHORT MceOperation;
    LONGLONG SalStatus;
    ULONG MceType;
    PMCEQUERYINFO QueryInfo;
    
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                      "WMI: MCEDelivery %p %d %p\n",
                      Reserved,
                      Operation,
                      Argument2
                     ));

    MceOperation = KERNEL_MCE_OPERATION(Reserved);
    MceType = KERNEL_MCE_EVENTTYPE(Reserved);
    SalStatus = (LONGLONG)Argument2;

    //
    // If the hal is notifying us that a GetStateInfo failed with
    // SalStatus == -15 then we need to retry our query later
    //
    if ((MceOperation == KERNEL_MCE_OPERATION_GET_STATE_INFO) &&
        (Operation == MceNotification) &&
        (SalStatus == (LONGLONG)-15))
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                          "WMI: Sal is asking us to retry getstateinfo for type %x\n",
                          MceType));

        switch(MceType)
        {
            case KERNEL_MCE_EVENTTYPE_CMC:
            {
                QueryInfo = &WmipCmcQueryInfo;              
                break;
            }

            case KERNEL_MCE_EVENTTYPE_CPE:
            {
                QueryInfo = &WmipCpeQueryInfo;
                break;
            }

            default:
            {
                QueryInfo = NULL;
            }
        }

        if (QueryInfo != NULL)
        {
            //
            // If CMC or CPE are interrupt based then queue up a new
            // DPC for performing the query. If polling based then
            // there are no worries, we just wait for the next polling
            // interval.
            //
            if ((WmipMCEState == MCE_STATE_RUNNING) &&
                (QueryInfo->PollFrequency == HAL_MCE_INTERRUPTS_BASED))

            {
                KeAcquireSpinLockAtDpcLevel(&QueryInfo->DpcLock);
                KeInsertQueueDpc(&QueryInfo->DeliveryDpc,
                                 QueryInfo,
                                 NULL);
                KeReleaseSpinLockFromDpcLevel(&QueryInfo->DpcLock);
            }
        }
        
    }
    
    return(FALSE);
    
}

void WmipProcessPrevMcaLogs(
    void
    )
/*++

Routine Description:

    This routine will flush out any of the previous MCA logs and then
    hang onto them for WMI to report.


Arguments:


Return Value:


--*/
{
    NTSTATUS status;
    PERROR_LOGRECORD log;
    PMSMCAInfo_RawMCAEvent event;
    ULONG size;
    PWNODE_SINGLE_INSTANCE wnode;
    LIST_ENTRY list;
    ULONG prevLogCount;
    PMSMCAInfo_Entry record;
    ULONG sizeNeeded;
    
    PAGED_CODE();

    InitializeListHead(&list);
    
    sizeNeeded = sizeof(ULONG);      // Need space for count of records
    prevLogCount = 0;
    do
    {
        //
        // Read a MCA log out of the HAL
        //
        status = WmipGetLogFromHal(HalMcaLogInformation,
                                   WmipMcaQueryInfo.Token,
                                   &wnode,
                                   &log,
                                   &size,
                                   WmipMcaQueryInfo.MaxSize,
                                   &WmipMcaQueryInfo.WnodeGuid);

        if (NT_SUCCESS(status))
        {
            //
            // Previous logs have a ErrorSeverity of Fatal since they
            // were fatal and brought down the system in last boot.
            // keep track of how much memory we will need           
            //
            prevLogCount++;
                                   // Need space for record length and
                                   // record padded to DWORD                                   
            sizeNeeded += sizeof(ULONG) + ((size +3)&~3);
            
            InsertTailList(&list, (PLIST_ENTRY)wnode);

            WmipGenerateMCAEventlog((PUCHAR)log,
                                    size,
                                    TRUE);                
        }
        
    } while (NT_SUCCESS(status));

    if (! IsListEmpty(&list))
    {
        //
        // We have collected a set of previous logs, so we need to
        // build the buffer containing the aggregation of those logs.
        // The buffer will correspond to the entire MOF structure for
        // the MSMCAInfo_RawMCAData class
        //
        WmipRawMCA = (PMSMCAInfo_RawMCAData)ExAllocatePoolWithTag(PagedPool,
                                                                  sizeNeeded,
                                                                  WmipMCAPoolTag);


        //
        // Fill in the count of logs that follow
        //
        if (WmipRawMCA != NULL)
        {
            WmipRawMCA->Count = prevLogCount;
        }

        //
        // Loop over all previous logs
        //
        WmipRawMCASize = sizeNeeded;
        record = &WmipRawMCA->Records[0];
        
        while (! IsListEmpty(&list))
        {           
            wnode = (PWNODE_SINGLE_INSTANCE)RemoveHeadList(&list);
            if (WmipRawMCA != NULL)
            {
                //
                // Get the log back from within the wnode
                //
                event = (PMSMCAInfo_RawMCAEvent)OffsetToPtr(wnode, wnode->DataBlockOffset);

                //
                // Copy the log data into our buffer. Note that we
                // assume there will only be 1 record within the event
                //
                size = event->Records[0].Length;
                record->Length = size;
                
                RtlCopyMemory(&record->Data[0], &event->Records[0].Data[0], size);
                
                size = FIELD_OFFSET(MSMCAInfo_Entry, Data) + (size +3)&~3;
                
                record = (PMSMCAInfo_Entry)((PUCHAR)record + size);
            }

            ExFreePool(wnode);
        }
    }
}

//#define TEST_EARLY_CPE
#ifdef TEST_EARLY_CPE
void WmipTestEarlyCPE(
    void
    )
{
//
// Test code to generate a previous MCA without having
// had generate one previously
//
    PERROR_SMBIOS s;
    UCHAR Buffer[0x400];
    PERROR_RECORD_HEADER rh;
    PERROR_SECTION_HEADER sh;
#define ERROR_SMBIOS_GUID \
{ 0xe429faf5, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

    ERROR_DEVICE_GUID ErrorSmbiosGuid = ERROR_SMBIOS_GUID;

    rh = (PERROR_RECORD_HEADER)Buffer;
    rh->Id = 0x12345678;
    rh->Revision.Revision = 0x0200;

    rh->Valid.Valid = 0;
    rh->TimeStamp.TimeStamp = 0x2001031900165323;

    sh = (PERROR_SECTION_HEADER)((PUCHAR)rh + sizeof(ERROR_RECORD_HEADER));
    memset(sh, 0, sizeof(Buffer));

    sh->Revision.Revision = 0x0200;

    sh->RecoveryInfo.RecoveryInfo = 0;

    sh->Length = sizeof(ERROR_SMBIOS);
    sh->Guid = ErrorSmbiosGuid;

    s = (PERROR_SMBIOS)sh;
    s->Valid.Valid = 0;
    s->Valid.EventType = 1;
    s->EventType = 0xa0;
    rh->Length = sizeof(ERROR_RECORD_HEADER) + sh->Length;

    HalSetSystemInformation(HalCpeLog,
                            rh->Length,
                            rh);
}
#endif

void WmipInsertQueueMCEDpc(
    PMCEQUERYINFO QueryInfo
    )
{
    KIRQL OldIrql;

    KeAcquireSpinLock(&QueryInfo->DpcLock,
                      &OldIrql);
    KeInsertQueueDpc(&QueryInfo->DeliveryDpc,
                     QueryInfo,
                     NULL);
    KeReleaseSpinLock(&QueryInfo->DpcLock,
                      OldIrql);
}

NTSTATUS WmipRegisterMcaHandler(
    ULONG Phase
    )
/*++

Routine Description:


    This routine will register a kernel MCA and CMC handler with the
    hal

Arguments:


Return Value:

    NT status code

--*/
{
    KERNEL_ERROR_HANDLER_INFO KernelMcaHandlerInfo;
    NTSTATUS Status;
    HAL_ERROR_INFO HalErrorInfo;
    ULONG ReturnSize;
    LARGE_INTEGER li;

    PAGED_CODE();

    if (Phase == 0)
    {
        //
        // Phase 0 initialization is done before device drivers are
        // loaded so that the kernel can register its kernel error
        // handler before any driver gets a chance to do so.
        //


        //
        // Validate registry values
        //
        if (WmipCorrectedEventlogCounter == 0)
        {
            //
            // set corrected eventlog counter to -1 to indicate that no
            // eventlog suppression should occur
            //
            WmipCorrectedEventlogCounter = 0xffffffff;
        }
        
        //
        // Get the size of the logs and any polling/interrupt policies
        //
        HalErrorInfo.Version = HAL_ERROR_INFO_VERSION;

        Status = HalQuerySystemInformation(HalErrorInformation,
                                           sizeof(HAL_ERROR_INFO),
                                           &HalErrorInfo,
                                           &ReturnSize);

        if ((NT_SUCCESS(Status)) &&
            (ReturnSize >= sizeof(HAL_ERROR_INFO)))
        {
            //
            // Initialize MCA QueryInfo structure
            //
            if (HalErrorInfo.McaMaxSize != 0)
            {
                WmipMcaQueryInfo.MaxSize = HalErrorInfo.McaMaxSize;
            }

            
            WmipMcaQueryInfo.Token = (PVOID)(ULONG_PTR) HalErrorInfo.McaKernelToken;

            //
            // Initialize DPC and Workitem for processing
            //
            KeInitializeDpc(&WmipMcaQueryInfo.DeliveryDpc,
                            WmipMceDpcRoutine,
                            NULL);

            KeInitializeDpc(&WmipMcaQueryInfo.PollingDpc,
                            WmipPollingDpcRoutine,
                            &WmipMcaQueryInfo);

            ExInitializeWorkItem(&WmipMcaQueryInfo.WorkItem,
                                 WmipMceWorkerRoutine,
                                 &WmipMcaQueryInfo);


            //
            // Initialize CMC QueryInfo structure
            //          
            if (HalErrorInfo.CmcMaxSize != 0)
            {
                WmipCmcQueryInfo.MaxSize = HalErrorInfo.CmcMaxSize;
            }
           
            WmipCmcQueryInfo.PollFrequency = HalErrorInfo.CmcPollingInterval;
            
            WmipCmcQueryInfo.Token = (PVOID)(ULONG_PTR) HalErrorInfo.CmcKernelToken;

            //
            // Initialize DPC and Workitem for processing
            //
            KeInitializeSpinLock(&WmipCmcQueryInfo.DpcLock);
            KeInitializeDpc(&WmipCmcQueryInfo.DeliveryDpc,
                            WmipMceDpcRoutine,
                            NULL);

            KeInitializeDpc(&WmipCmcQueryInfo.PollingDpc,
                            WmipPollingDpcRoutine,
                            &WmipCmcQueryInfo);

            ExInitializeWorkItem(&WmipCmcQueryInfo.WorkItem,
                                 WmipMceWorkerRoutine,
                                 &WmipCmcQueryInfo);

            KeInitializeTimerEx(&WmipCmcQueryInfo.PollingTimer,
                                NotificationTimer);

            //
            // Initialize CPE QueryInfo structure
            //          
            if (HalErrorInfo.CpeMaxSize != 0)
            {
                WmipCpeQueryInfo.MaxSize = HalErrorInfo.CpeMaxSize;
            }

            WmipCpeQueryInfo.PollFrequency = HalErrorInfo.CpePollingInterval;
            
            WmipCpeQueryInfo.Token = (PVOID)(ULONG_PTR) HalErrorInfo.CpeKernelToken;

            //
            // Initialize DPC and Workitem for processing
            //
            KeInitializeSpinLock(&WmipCpeQueryInfo.DpcLock);
            KeInitializeDpc(&WmipCpeQueryInfo.DeliveryDpc,
                            WmipMceDpcRoutine,
                            NULL);

            KeInitializeDpc(&WmipCpeQueryInfo.PollingDpc,
                            WmipPollingDpcRoutine,
                            &WmipCpeQueryInfo);

            ExInitializeWorkItem(&WmipCpeQueryInfo.WorkItem,
                                 WmipMceWorkerRoutine,
                                 &WmipCpeQueryInfo);
            
            KeInitializeTimerEx(&WmipCpeQueryInfo.PollingTimer,
                                NotificationTimer);

            //
            // Register our CMC and MCA callbacks. And if interrupt driven CPE
            // callbacks are enabled register them too
            //
            KernelMcaHandlerInfo.Version = KERNEL_ERROR_HANDLER_VERSION;
            KernelMcaHandlerInfo.KernelMcaDelivery = WmipMceDelivery;
            KernelMcaHandlerInfo.KernelCmcDelivery = WmipMceDelivery;
            KernelMcaHandlerInfo.KernelCpeDelivery = WmipMceDelivery;
            KernelMcaHandlerInfo.KernelMceDelivery = WmipMceEventDelivery;

            Status = HalSetSystemInformation(HalKernelErrorHandler,
                                             sizeof(KERNEL_ERROR_HANDLER_INFO),
                                             &KernelMcaHandlerInfo);

            if (NT_SUCCESS(Status))
            {
                WmipMCEState = MCE_STATE_REGISTERED;
#ifdef TEST_EARLY_CPE
                WmipTestEarlyCPE();
#endif
            } else {
                WmipMCEState = (ULONG) MCE_STATE_ERROR;
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                  DPFLTR_MCA_LEVEL | DPFLTR_ERROR_LEVEL,
                                  "WMI: Error %x registering MCA error handlers\n",
                                  Status));
            }
        }

    } else if (WmipMCEState != MCE_STATE_ERROR) {
        //
        // Phase 1 initialization is done after all of the boot drivers
        // have loaded and have had a chance to register for WMI event
        // notifications. At this point it is safe to go ahead and send
        // wmi events for MCA, CMC, CPE, etc

        //
        // If there were any MCA logs generated prior to boot then get
        // them out of the HAL and process them. Do this before
        // starting any polling since the SAL likes to have the
        // previous MCA records removed before being polled for CPE and
        // CMC
        //


#if 0
// DEBUG
                //
                // Test code to generate a previous MCA without having
                // had generate one previously
                //
                {
                    PERROR_SMBIOS s;
                    UCHAR Buffer[0x400];
                    PERROR_RECORD_HEADER rh;
                    PERROR_SECTION_HEADER sh;
#define ERROR_SMBIOS_GUID \
    { 0xe429faf5, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

                    ERROR_DEVICE_GUID ErrorSmbiosGuid = ERROR_SMBIOS_GUID;

                    rh = (PERROR_RECORD_HEADER)Buffer;
                    rh->Id = 0x12345678;
                    rh->Revision.Revision = 0x0200;

                    rh->Valid.Valid = 0;
                    rh->TimeStamp.TimeStamp = 0x2001031900165323;

                    sh = (PERROR_SECTION_HEADER)((PUCHAR)rh + sizeof(ERROR_RECORD_HEADER));
                    memset(sh, 0, sizeof(Buffer));

                    sh->Revision.Revision = 0x0200;

                    sh->RecoveryInfo.RecoveryInfo = 0;

                    sh->Length = sizeof(ERROR_SMBIOS);
                    sh->Guid = ErrorSmbiosGuid;

                    s = (PERROR_SMBIOS)sh;
                    s->Valid.Valid = 0;
                    s->Valid.EventType = 1;
                    s->EventType = 0xa0;
                    rh->Length = sizeof(ERROR_RECORD_HEADER) + sh->Length;
                    WmipGenerateMCAEventlog(Buffer,
                                            rh->Length,
                                            TRUE);
                }
// DEBUG
#endif

        
        HalErrorInfo.Version = HAL_ERROR_INFO_VERSION;

        Status = HalQuerySystemInformation(HalErrorInformation,
                                           sizeof(HAL_ERROR_INFO),
                                           &HalErrorInfo,
                                           &ReturnSize);

        if ((NT_SUCCESS(Status)) &&
            (ReturnSize >= sizeof(HAL_ERROR_INFO)))
        {
            if (HalErrorInfo.McaPreviousEventsCount != 0)
            {
                //
                // We need to flush out any previous MCA logs and then
                // make them available via WMI
                //
                WmipProcessPrevMcaLogs();                
            }           
        }        

        //
        // Establish polling timer for CMC, if needed
        //
        if ((WmipCmcQueryInfo.PollFrequency != HAL_CMC_DISABLED) &&
            (WmipCmcQueryInfo.PollFrequency != HAL_CMC_INTERRUPTS_BASED))
        {
            li.QuadPart = -1 * (WmipCmcQueryInfo.PollFrequency * 1000000000);
            KeSetTimerEx(&WmipCmcQueryInfo.PollingTimer,
                         li,
                         WmipCmcQueryInfo.PollFrequency * 1000,
                         &WmipCmcQueryInfo.PollingDpc);
        } else if (WmipCmcQueryInfo.PollFrequency == HAL_CMC_INTERRUPTS_BASED) {
            //
            // CMC is interrupt based so we need to kick off an attempt
            // to read any CMC that had previously occured
            //
            WmipInsertQueueMCEDpc(&WmipCmcQueryInfo);
        }

        //
        // Establish polling timer for Cpe, if needed
        //
        if ((WmipCpeQueryInfo.PollFrequency != HAL_CPE_DISABLED) &&
            (WmipCpeQueryInfo.PollFrequency != HAL_CPE_INTERRUPTS_BASED))
        {
            li.QuadPart = -1 * (WmipCpeQueryInfo.PollFrequency * 1000000000);
            KeSetTimerEx(&WmipCpeQueryInfo.PollingTimer,
                         li,
                         WmipCpeQueryInfo.PollFrequency * 1000,
                         &WmipCpeQueryInfo.PollingDpc);
        } else if (WmipCpeQueryInfo.PollFrequency == HAL_CPE_INTERRUPTS_BASED) {
            //
            // Cpe is interrupt based so we need to kick off an attempt
            // to read any Cpe that had previously occured
            //
            WmipInsertQueueMCEDpc(&WmipCpeQueryInfo);
        }

        //
        // Flag that we are now able to start firing events
        //
        WmipMCEState = MCE_STATE_RUNNING;
        
        Status = STATUS_SUCCESS;
    }
    else {
        Status = STATUS_UNSUCCESSFUL;
    }
    
    return(Status);
}

NTSTATUS WmipGetRawMCAInfo(
    OUT PUCHAR Buffer,
    IN OUT PULONG BufferSize
    )
/*++

Routine Description:

    Return raw MCA log that was already retrieved from hal

Arguments:


Return Value:

    NT status code

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    if (WmipRawMCA != NULL)
    {
        //
        // THere are logs so copy over all of the logs
        //
        if (*BufferSize >= WmipRawMCASize)
        {
            RtlCopyMemory(Buffer, WmipRawMCA, WmipRawMCASize);
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        *BufferSize = WmipRawMCASize;
    } else {
        //
        // There are no logs so return no records
        //
        if (*BufferSize >= sizeof(ULONG))
        {
            *(PULONG)Buffer = 0;
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        *BufferSize = sizeof(ULONG);        
    }
    
    return(status);
}


NTSTATUS WmipGetLogFromHal(
    IN HAL_QUERY_INFORMATION_CLASS InfoClass,
    IN PVOID Token,                        
    IN OUT PWNODE_SINGLE_INSTANCE *Wnode,
    OUT PERROR_LOGRECORD *Mca,
    OUT PULONG McaSize,
    IN ULONG MaxSize,
    IN LPGUID Guid                         
    )
/*++

Routine Description:

    This routine will call the HAL to get a log and possibly build a
    wnode event for it.

Arguments:

    InfoClass is the HalInformationClass that specifies the log
        information to retrieve

    Token is the HAL token for the log type

    *Wnode returns a pointer to a WNODE_EVENT_ITEM containing the log
        information if Wnode is not NULL

    *Mca returns a pointer to the log read from the hal. It may point
        into the memory pointed to by *Wnode

    *McaSize returns with the size of the log infomration.

    MaxSize has the maximum size to allocate for the log data

    Guid points to the guid to use if a Wnode is built

Return Value:

    NT status code

--*/
{
    NTSTATUS Status;
    PERROR_LOGRECORD Log;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    PULONG Ptr;
    ULONG Size, LogSize, WnodeSize;

    PAGED_CODE();

    //
    // If we are reading directly into a wnode then set this up
    //
    if (Wnode != NULL)
    {
        WnodeSize = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData) +
                    2 * sizeof(ULONG);
    } else {
        WnodeSize = 0;
    }

    //
    // Allocate a buffer to store the log reported from the hal. Note
    // that this must be in non paged pool as per the HAL.
    //
    Size = MaxSize + WnodeSize;
                                    
    Ptr = ExAllocatePoolWithTag(NonPagedPool,
                                Size,
                                WmipMCAPoolTag);
    if (Ptr != NULL)
    {
        Log = (PERROR_LOGRECORD)((PUCHAR)Ptr + WnodeSize);
        LogSize = Size - WnodeSize;

        *(PVOID *)Log = Token;
        
        Status = HalQuerySystemInformation(InfoClass,
                                           LogSize,
                                           Log,
                                           &LogSize);

        if (Status == STATUS_BUFFER_TOO_SMALL)
        {
            //
            // If our buffer was too small then the Hal lied to us when
            // it told us the maximum buffer size. This is ok as we'll
            // handle this situation by reallocating and trying again
            //
            ExFreePool(Log);

            //
            // Reallocate the buffer and call the hal to get the log
            //
            Size = LogSize + WnodeSize;
            Ptr = ExAllocatePoolWithTag(NonPagedPool,
                                        Size,
                                        WmipMCAPoolTag);
            if (Ptr != NULL)
            {
                Log = (PERROR_LOGRECORD)((PUCHAR)Ptr + WnodeSize);
                LogSize = Size - WnodeSize;

                *(PVOID *)Log = Token;
                Status = HalQuerySystemInformation(InfoClass,
                                                    LogSize,
                                                    Log,
                                                    &LogSize);

                //
                // The hal gave us a buffer size needed that was too
                // small, so lets stop right here and let him know]
                //
                WmipAssert(Status != STATUS_BUFFER_TOO_SMALL);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (NT_SUCCESS(Status))
        {
            //
            // We sucessfully read the data from the hal so build up
            // output buffers.
            //
            if (Wnode != NULL)
            {
                //
                // Caller requested buffer returned within a WNODE, so
                // build up the wnode around the log data
                //
                
                WnodeSI = (PWNODE_SINGLE_INSTANCE)Ptr;
                Status = WmipBuildMcaCmcEvent(WnodeSI,
                                              Guid,
                                              NULL,
                                              LogSize);
                *Wnode = WnodeSI;
            }
            
            *Mca = Log;
            *McaSize = LogSize;
        }

        if ((! NT_SUCCESS(Status)) && (Ptr != NULL))
        {
            //
            // If the function failed, but we have an allocated buffer
            // then clean it up
            //
            ExFreePool(Ptr);
        }
        
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(Status);
}

//
// Unlink and free a buffer to contain the corrected event information.
// Assumes that the SM Critical section is held
//
void WmipFreeCorrectedMCEEvent(
    PMCECORRECTEDEVENT Event
    )
{
    PAGED_CODE();
    
    RemoveEntryList(&Event->List);
    WmipCorrectedMCECount--;
    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                      DPFLTR_MCA_LEVEL,
                      "WMI: MCE event %p for type %d freed\n",
                      Event,
                      Event->Type));
    ExFreePool(Event);
}


PMCECORRECTEDEVENT WmipAllocCorrectedMCEEvent(
     MCECORRECTEDTYPE Type
    )
/*++

Routine Description:

    This routine will allocate and initialize a MCECORRECTEDEVENT
    structure for a new corrected mce event that the kernel is
    tracking. The routine ensures that only a fixed limit of corrected
    MCE events are allocated and if the limit is exceeded, then the
    oldest entry is recycled.

    This routine assumes that the WmipSMCriticalSection is held

Arguments:

    Type is the type of corrected MCE event


Return Value:

    pointer to MCECORRECTEDEVENT stucture or NULL if an entry could not
        be allocated

--*/
{
    PMCECORRECTEDEVENT Event, EventX;
    LARGE_INTEGER OldestTime;
    PLIST_ENTRY List;

    PAGED_CODE();

    if (WmipMaxCorrectedMCEOutstanding != 0)
    {

        if ((WmipCorrectedMCECount < WmipMaxCorrectedMCEOutstanding) ||
            (IsListEmpty(&WmipCorrectedMCEHead)))
        {
            //
            // Allocate a new event from pool
            //
            Event = (PMCECORRECTEDEVENT)ExAllocatePoolWithTag(PagedPool,
                                                             sizeof(MCECORRECTEDEVENT),
                                                             WmipMCAPoolTag);

            if (Event != NULL)
            {
                WmipCorrectedMCECount++;
            }

        } else {
            //
            // There are already enough mce being tracked, so pick the
            // oldest and recycle
            //
            List = WmipCorrectedMCEHead.Flink;
            
            Event = CONTAINING_RECORD(List,
                                      MCECORRECTEDEVENT,
                                      List);
            
            OldestTime = Event->Timestamp;
            
            List = List->Flink;
            
            while (List != &WmipCorrectedMCEHead)
            {
                EventX = CONTAINING_RECORD(List,
                                          MCECORRECTEDEVENT,
                                          List);

                if (EventX->Timestamp.QuadPart < OldestTime.QuadPart)
                {
                    Event = EventX;
                    OldestTime = EventX->Timestamp;
                }

                List = List->Flink;
            }

            RemoveEntryList(&Event->List);
        }
    } else {
        Event = NULL;
    }

    if (Event != NULL)
    {
        Event->Type = Type;
        Event->Counter = 1;
        Event->Flags = 0;
        KeQuerySystemTime(&Event->Timestamp);
        InsertHeadList(&WmipCorrectedMCEHead,
                       &Event->List);       
    }
    
    return(Event);
}

NTSTATUS WmipTrackCorrectedMCE(
    IN MCECORRECTEDTYPE Type,
    IN PERROR_RECORD_HEADER Record,
#if defined(_IA64_)
    IN PERROR_SECTION_HEADER Section,
#endif
    OUT ULONG *LogToEventlog
    )
{
    PLIST_ENTRY List;
    PMCECORRECTEDEVENT Event;
    LARGE_INTEGER DeltaTime;
    
    PAGED_CODE();

    //
    // By default we'll always want an eventlog entry for corrected
    // errors
    //
    
    switch(Type)
    {
        case CpuCache:
        case CpuTlb:
        case CpuBus:
        case CpuRegFile:
        {
            LARGE_INTEGER CurrentTime;
            ULONG CpuId;

            //
            // We got a corrected CPU cache error. If this happended on
            // this CPU before within a certain time window then we
            // want to suppress the eventlog message
            //
            CpuId = HalpGetFwMceLogProcessorNumber(Record);
            KeQuerySystemTime(&CurrentTime);
            
            WmipEnterSMCritSection();
            List = WmipCorrectedMCEHead.Flink;
            while (List != &WmipCorrectedMCEHead)
            {
                Event = CONTAINING_RECORD(List,
                                          MCECORRECTEDEVENT,
                                          List);
                
                if ((Type == Event->Type) &&
                    (CpuId == Event->CpuId))
                {
                    //
                    // We have seen a cpu error on this cpu before,
                    // check if it was within the time interval
                    //
                    DeltaTime.QuadPart = (CurrentTime.QuadPart -
                                          Event->Timestamp.QuadPart) /
                                         1000;
                    if ( (ULONG)DeltaTime.QuadPart <= WmipCoalesceCorrectedErrorInterval)
                    {
                        //
                        // Since it is within the interval, we suppress
                        // the event
                        //
                        *LogToEventlog = 0;
                    } else {
                        //
                        // Since it is not within the interval we do
                        // not suppress the event, but do need to
                        // update the time that the last error occurred
                        //
                        Event->Timestamp = CurrentTime;
                    }
                    goto CpuDone;
                }

                List = List->Flink;
            }

            //
            // This appears to be the first time we've seen
            // this physical address. Build an event structure
            // for it and put it on the watch list
            //
            Event = WmipAllocCorrectedMCEEvent(Type);
            
            if (Event != NULL)
            {
                Event->CpuId = CpuId;
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                  DPFLTR_MCA_LEVEL,
                                  "WMI: MCE event %p for type %d, cpuid %d added\n",
                                  Event,
                                  Event->Type,
                                  Event->CpuId));

            }
            
CpuDone:
            WmipLeaveSMCritSection();
            
            break;
        }
        
        case SingleBitEcc:
        {
#if defined(_IA64_)
            PERROR_MEMORY Memory;
            LARGE_INTEGER BytesRemoved;
            PHYSICAL_ADDRESS Address;
            NTSTATUS Status;
            
            //
            // We got a single bit ECC error. See if the physical
            // address for it is already on the list and if so bump the
            // counter and possibly try to remove the physical memory
            // form the system. If not then create a new entry for the
            // error.
            //

            Memory = (PERROR_MEMORY)Section;
            if (Memory->Valid.PhysicalAddress == 1)
            {
                //
                // Round down the the nearest page boundry since we are
                // tracking errors on a page basis. This means that 2
                // errors at different addresses in the same page are
                // considered 2 instances of the same error
                //
                Address.QuadPart = (Memory->PhysicalAddress) & ~(PAGE_SIZE-1);
                
                WmipEnterSMCritSection();
                List = WmipCorrectedMCEHead.Flink;
                while (List != &WmipCorrectedMCEHead)
                {
                    Event = CONTAINING_RECORD(List,
                                              MCECORRECTEDEVENT,
                                              List);
                    if ((Type == Event->Type) &&
                        ((Event->Flags & CORRECTED_MCE_EVENT_BUSY) == 0) &&
                        (Address.QuadPart == Event->SingleBitEccAddress.QuadPart))
                    {
                        //
                        // Don't report multiple errors for the same
                        // page ever, but update to the current
                        // timestamp
                        //
                        *LogToEventlog = 0;
                        KeQuerySystemTime(&Event->Timestamp);
                        
                        if ((WmipSingleBitEccErrorThreshold != 0) &&
                            (++Event->Counter >= WmipSingleBitEccErrorThreshold))
                        {
                            //
                            // We have crossed the threshold so lets
                            // attempt to map out the memory. 
                            // Mark the entry as busy and release the
                            // critical section since mapping out the
                            // memory may take a long time.
                            //
                            Event->Flags |= CORRECTED_MCE_EVENT_BUSY;
                            WmipLeaveSMCritSection();
                            
                            //
                            // MmMarkPhysicalMmemoryAsBad
                            // requires that the address and
                            // size be page aligned
                            //
                            BytesRemoved.QuadPart = PAGE_SIZE;
                            Status = MmMarkPhysicalMemoryAsBad(&Address,
                                                               &BytesRemoved);


                            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                              "WMI: Physical Address %p removal -> %x\n",
                                              Address.QuadPart,
                                              Status));

                            if (NT_SUCCESS(Status))
                            {
                                //
                                // Fire off a wmi event to announce
                                // that the memory has been mapped out
                                //
                                WmipFireOffWmiEvent(&WmipMSMCAEvent_MemoryPageRemoved,
                                                    sizeof(PHYSICAL_ADDRESS),
                                                    &Address);
                                //
                                // SInce mapping succeeded, we do not
                                // expect to see the physical address
                                // again so we can remove it from the
                                // list of tracked MCE
                                //
                                WmipEnterSMCritSection();
                                WmipFreeCorrectedMCEEvent(Event);
                            } else {
                                Event->Flags &= ~CORRECTED_MCE_EVENT_BUSY;
                                WmipEnterSMCritSection();
                            }                            
                        }
                        goto MemoryDone;
                    }

                    List = List->Flink;
                }

                //
                // This appears to be the first time we've seen
                // this physical address. Build an event structure
                // for it and put it on the watch list
                //
                Event = WmipAllocCorrectedMCEEvent(Type);

                if (Event != NULL)
                {
                    Event->SingleBitEccAddress = Address;
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                      DPFLTR_MCA_LEVEL,
                                      "WMI: MCE event %p for type %d, physaddr %I64x added\n",
                                      Event,
                                      Event->Type,
                                      Event->SingleBitEccAddress.QuadPart));
                }

MemoryDone:
                WmipLeaveSMCritSection();
            }
#endif

            break;
        }
        
        default:
        {
            WmipAssert(FALSE);
        }
    }
    
    return(STATUS_SUCCESS);
}

typedef enum
{
    CpuStateCheckCache = 0,
    CpuStateCheckTLB = 1,
    CpuStateCheckBus = 2,
    CpuStateCheckRegFile = 3,
    CpuStateCheckMS = 4
};

void WmipGenerateMCAEventlog(
    PUCHAR ErrorLog,
    ULONG ErrorLogSize,
    BOOLEAN IsFatal
    )
{

    PERROR_RECORD_HEADER RecordHeader;
#if defined(_IA64_)
    PERROR_SECTION_HEADER SectionHeader;
    PERROR_MODINFO ModInfo;
#endif
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PWCHAR w;
    ULONG BufferSize;
    PUCHAR Buffer, RawPtr = NULL;
    PWNODE_SINGLE_INSTANCE Wnode;
    PMSMCAEvent_Header Header;

    PAGED_CODE();
    
    RecordHeader = (PERROR_RECORD_HEADER)ErrorLog;

    //
    // Allocate a buffer large enough to accomodate any type of MCA.
    // Right now the largest is MSMCAEvent_MemoryError. If this changes
    // then this code should be updated
    //  
    BufferSize = ((sizeof(WNODE_SINGLE_INSTANCE) +
                   (sizeof(USHORT) + sizeof(MCA_EVENT_INSTANCE_NAME)) +7) & ~7) +
                 sizeof(MSMCAEvent_MemoryError) +
                 ErrorLogSize;

    //
    // Allocate a buffer to build the event
    //
    Buffer = ExAllocatePoolWithTag(PagedPool,
                                   BufferSize,
                                   WmipMCAPoolTag);
    
    if (Buffer != NULL)
    {
        //
        // Fill in the common fields of the WNODE
        //
        Wnode = (PWNODE_SINGLE_INSTANCE)Buffer;
        Wnode->WnodeHeader.BufferSize = BufferSize;
        Wnode->WnodeHeader.Linkage = 0;
        WmiInsertTimestamp(&Wnode->WnodeHeader);
        Wnode->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE |
                                   WNODE_FLAG_EVENT_ITEM;
        Wnode->OffsetInstanceName = sizeof(WNODE_SINGLE_INSTANCE);
        Wnode->DataBlockOffset = ((sizeof(WNODE_SINGLE_INSTANCE) +
                       (sizeof(USHORT) + sizeof(MCA_EVENT_INSTANCE_NAME)) +7) & ~7);

        w = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
        *w++ = sizeof(MCA_EVENT_INSTANCE_NAME);
        wcscpy(w, MCA_EVENT_INSTANCE_NAME);

        //
        // Fill in the common fields of the event data
        //
        Header = (PMSMCAEvent_Header)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
        Header->Cpu = MCA_UNDEFINED_CPU;   // assume CPU will be undefined
        Header->AdditionalErrors = 0;
        Header->LogToEventlog = 1;
            
#if defined(_IA64_)
        if ((ErrorLogSize < sizeof(ERROR_RECORD_HEADER)) ||
            (RecordHeader->Revision.Major != ERROR_MAJOR_REVISION_SAL_03_00) ||
            (RecordHeader->Length > ErrorLogSize))
        {
            //
            // Record header is not SAL 3.0 compliant so we do not try
            // to interpert the record. It is not compliant for one of
            // these reasons:
            //
            // 1. The error record size is not large enough to contain
            //    the entire error record header.
            // 2. The Major revision number does not match the major
            //    revision number expected by the code. Note that the
            //    minor revision number is not checked since changes to
            //    the minor revision number do not affect the format of
            //    the error record or sections.
            // 3. The error record size as specified in the error
            //    record header does not match the size obtained from
            //    the firmware.
            //
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                  "WMI: Invalid MCA Record revision %x or size %d at %p\n"
                                  "do !mca %p to dump MCA record\n",
                                  RecordHeader->Revision,
                                  RecordHeader->Length,
                                  RecordHeader,
                                  RecordHeader));
#endif
            Status = STATUS_INVALID_PARAMETER;
#if defined(_IA64_)
        } else {

            ULONG SizeUsed;
            ULONG CpuErrorState = CpuStateCheckCache;
            ULONG CpuErrorIndex = 0;
            BOOLEAN AdvanceSection;
            BOOLEAN FirstError;

            //
            // Valid 3.0 record, gather the record id and severity from
            // the header
            //
            Header->RecordId = RecordHeader->Id;
            Header->ErrorSeverity = RecordHeader->ErrorSeverity;
            Header->Cpu = HalpGetFwMceLogProcessorNumber(RecordHeader);

            //
            // Use the error severity value in the record header to
            // determine if the error was fatal. If the value is
            // ErrorRecoverable then assume that the error was fatal
            // since the HAL will change this value to ErrorCorrected
            //
            IsFatal = (RecordHeader->ErrorSeverity != ErrorCorrected ? TRUE : FALSE);
            
            //
            // Loop over all sections within the record.
            //
            // CONSIDER: Is it possible to have a record that only has a record
            //           header and no sections
            //
            SizeUsed = sizeof(ERROR_RECORD_HEADER);
            ModInfo = NULL;
            FirstError = TRUE;
            
            while (SizeUsed < ErrorLogSize)
            {
                //
                // Advance to the next section in the record
                //
                SectionHeader = (PERROR_SECTION_HEADER)(ErrorLog + SizeUsed);
                AdvanceSection = TRUE;
                
                Header->AdditionalErrors++;

                //
                // First validate that this is a valid section
                //
                if (((SizeUsed + sizeof(ERROR_SECTION_HEADER)) > ErrorLogSize) ||
                    (SectionHeader->Revision.Revision != SAL_30_ERROR_REVISION) ||
                    ((SizeUsed + SectionHeader->Length) > ErrorLogSize))
                {
                    //
                    // Not valid section header so we'll give up on
                    // the whole record. This could be because
                    //
                    // 1. There is not enough room in the buffer passed
                    //    by the FW for a complete section header
                    // 2. The section header revision is not correct
                    // 3. There is not enough room in the buffer passed
                    //    by the FW for the complete section 
                    //                              
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                          "WMI: Invalid MCA SectionHeader revision %d or length %d at %p\n"
                                          "do !mca %p to dump MCA record\n",
                                          SectionHeader->Revision,
                                          SectionHeader->Length,
                                          SectionHeader,
                                          RecordHeader));

                    //
                    // We'll break out of the loop since we don't know how to
                    // move on to the next MCA section since we don't
                    // understand any format previous to 3.0
                    //
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                } else {
                    //
                    // Now determine what type of section we have got. This is
                    // determined by looking at the guid in the section header.
                    // Each section type has a unique guid value
                    //
                    if (IsEqualGUID(&SectionHeader->Guid, &WmipErrorProcessorGuid))
                    {
                        //
                        // Build event for CPU eventlog MCA
                        //
                        PMSMCAEvent_CPUError Event;
                        PERROR_PROCESSOR Processor;
                        SIZE_T TotalSectionSize;

                        WmipAssert( sizeof(MSMCAEvent_MemoryError) >=
                                    sizeof(MSMCAEvent_CPUError) );

                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                          "WMI: MCA Section %p indicates processor error\n",
                                          SectionHeader));

                        //
                        // Validate that the section length is large
                        // enough to accomodate all of the information
                        // that it declares
                        //
                        if (SectionHeader->Length >= sizeof(ERROR_PROCESSOR))                            
                        {
                            Event = (PMSMCAEvent_CPUError)Header;
                            Processor = (PERROR_PROCESSOR)SectionHeader;

                            //
                            // Assume we won't be able to determine the
                            // various additional information from the
                            // error logs
                            //
                            if (FirstError)
                            {
                                Event->Type = IsFatal ? MCA_ERROR_CPU :
                                                        MCA_WARNING_CPU;
                                
                                Event->MajorErrorType = (ULONG)0xffffffff;
                                                
                                Event->Level = (ULONG)0xffffffff;
                                Event->CacheOp = (ULONG)0xffffffff;
                                Event->CacheMesi = (ULONG)0xffffffff;
                                Event->TLBOp = (ULONG)0xffffffff;
                                Event->BusType = (ULONG)0xffffffff;
                                Event->BusSev = (ULONG)0xffffffff;
                                Event->RegFileId = (ULONG)0xffffffff;
                                Event->RegFileOp = (ULONG)0xffffffff;
                                Event->MSSid = (ULONG)0xffffffff;
                                Event->MSOp = (ULONG)0xffffffff;
                                Event->MSArrayId = (ULONG)0xffffffff;
                                Event->MSIndex = (ULONG)0xffffffff;
                            }
                            
                            //
                            // Validate that section is large enough to
                            // handle all specified ERROR_MODINFO
                            // structs
                            //
                            TotalSectionSize = sizeof(ERROR_PROCESSOR) +
                                             ((Processor->Valid.CacheCheckNum +
                                                Processor->Valid.TlbCheckNum +
                                                Processor->Valid.BusCheckNum +
                                                Processor->Valid.RegFileCheckNum +
                                                Processor->Valid.MsCheckNum) *
                                               sizeof(ERROR_MODINFO));
                                           

                            if (SectionHeader->Length >= TotalSectionSize)
                            {
                                //
                                // Initialize pointer to the current ERROR_MOFINFO
                                //
                                if (ModInfo == NULL)
                                {
                                    ModInfo = (PERROR_MODINFO)((PUCHAR)Processor +
                                                                sizeof(ERROR_PROCESSOR));
                                } else {
                                    ModInfo++;
                                }

                                switch (CpuErrorState)
                                {
                                    case CpuStateCheckCache:
                                    {
                                        ERROR_CACHE_CHECK Check;

                                        if (Processor->Valid.CacheCheckNum > CpuErrorIndex)
                                        {
                                            //
                                            // We have a cache error that we need to
                                            // handle.
                                            // Advance to next error in the section,
                                            // but don't advance the section
                                            //

                                            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                                              "WMI: MCA ModInfo %p indicates cache error index %d\n",
                                                              ModInfo,
                                                              CpuErrorIndex));

                                            if (! IsFatal)
                                            {
                                                WmipTrackCorrectedMCE(CpuCache,
                                                                      RecordHeader,
                                                                      SectionHeader,
                                                                      &Header->LogToEventlog);
                                            }
                                            
                                            CpuErrorIndex++;
                                            AdvanceSection = FALSE;

                                            if (FirstError)
                                            {
                                                Event->Type = IsFatal ? MCA_ERROR_CACHE :
                                                                        MCA_WARNING_CACHE;

                                                Event->MajorErrorType = MCACpuCacheError;
                                                if (ModInfo->Valid.CheckInfo == 1)
                                                {
                                                    Check.CacheCheck = ModInfo->CheckInfo.CheckInfo;
                                                    Event->Level = (ULONG)Check.Level;
                                                    Event->CacheOp = (ULONG)Check.Operation;
                                                    if (Check.MESIValid == 1)
                                                    {
                                                        Event->CacheMesi = (ULONG)Check.MESI;
                                                    }
                                                }
                                            }

                                            break;
                                        } else {
                                            CpuErrorState = CpuStateCheckTLB;
                                            CpuErrorIndex = 0;
                                            // Fall through and see if there are any
                                            // TLB errors
                                        }                       
                                    }

                                    case CpuStateCheckTLB:
                                    {
                                        ERROR_TLB_CHECK Check;

                                        if (Processor->Valid.TlbCheckNum > CpuErrorIndex)
                                        {
                                            //
                                            // We have a cache error that we need to
                                            // handle.
                                            // Advance to next error in the section,
                                            // but don't advance the section
                                            //
                                            
                                            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                                              "WMI: MCA ModInfo %p indicates TLB error index %d\n",
                                                              ModInfo,
                                                              CpuErrorIndex));
                                            if (! IsFatal)
                                            {
                                                WmipTrackCorrectedMCE(CpuTlb,
                                                                      RecordHeader,
                                                                      SectionHeader,
                                                                      &Header->LogToEventlog);
                                            }
                                            
                                            CpuErrorIndex++;
                                            AdvanceSection = FALSE;

                                            if (FirstError)
                                            {
                                                Event->Type = IsFatal ? MCA_ERROR_TLB :
                                                                        MCA_WARNING_TLB;
                                                
                                                Event->MajorErrorType = MCACpuTlbError;
                                                
                                                if (ModInfo->Valid.CheckInfo == 1)
                                                {
                                                    Check.TlbCheck = ModInfo->CheckInfo.CheckInfo;
                                                    Event->Level = (ULONG)Check.Level;
                                                    Event->TLBOp = (ULONG)Check.Operation;
                                                }
                                            }

                                            break;
                                        } else {
                                            CpuErrorState = CpuStateCheckBus;
                                            CpuErrorIndex = 0;

                                            // Fall through and see if there are any
                                            // CPU Bus errors
                                        }
                                    }

                                    case CpuStateCheckBus:
                                    {
                                        ERROR_BUS_CHECK Check;
                                        
                                        if (Processor->Valid.BusCheckNum > CpuErrorIndex)
                                        {
                                            //
                                            // We have a cache error that we need to
                                            // handle.
                                            // Advance to next error in the section,
                                            // but don't advance the section
                                            //
                                            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                                              "WMI: MCA ModInfo %p indicates bus error index %d\n",
                                                              ModInfo,
                                                              CpuErrorIndex));
                                            
                                            if (! IsFatal)
                                            {
                                                WmipTrackCorrectedMCE(CpuBus,
                                                                      RecordHeader,
                                                                      SectionHeader,
                                                                      &Header->LogToEventlog);
                                            }
                                            
                                            CpuErrorIndex++;
                                            AdvanceSection = FALSE;

                                            if (FirstError)
                                            {
                                                Event->Type = IsFatal ? MCA_ERROR_CPU_BUS :
                                                                        MCA_WARNING_CPU_BUS;
                                                
                                                Event->MajorErrorType = MCACpuBusError;
                                                
                                                if (ModInfo->Valid.CheckInfo == 1)
                                                {
                                                    Check.BusCheck = ModInfo->CheckInfo.CheckInfo;
                                                    Event->BusType = (ULONG)Check.Type;
                                                    Event->BusSev = (ULONG)Check.Severity;
                                                }
                                            }

                                            break;
                                        } else {
                                            CpuErrorState = CpuStateCheckRegFile;
                                            CpuErrorIndex = 0;

                                            // Fall through and see if there are any
                                            // REG FILE errors
                                        }                       
                                    }

                                    case CpuStateCheckRegFile:
                                    {
                                        ERROR_REGFILE_CHECK Check;
                                        
                                        if (Processor->Valid.RegFileCheckNum > CpuErrorIndex)
                                        {
                                            //
                                            // We have a cache error that we need to
                                            // handle.
                                            // Advance to next error in the section,
                                            // but don't advance the section
                                            //
                                            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                                              "WMI: MCA ModInfo %p indicates reg file error index %d\n",
                                                              ModInfo,
                                                              CpuErrorIndex));

                                            if (! IsFatal)
                                            {
                                                WmipTrackCorrectedMCE(CpuRegFile,
                                                                      RecordHeader,
                                                                      SectionHeader,
                                                                      &Header->LogToEventlog);
                                            }
                                            
                                            CpuErrorIndex++;
                                            AdvanceSection = FALSE;

                                            if (FirstError)
                                            {
                                                Event->Type = IsFatal ? MCA_ERROR_REGISTER_FILE :
                                                                        MCA_WARNING_REGISTER_FILE;
                                                
                                                Event->MajorErrorType = MCACpuRegFileError;
                                                
                                                if (ModInfo->Valid.CheckInfo == 1)
                                                {
                                                    Check.RegFileCheck = ModInfo->CheckInfo.CheckInfo;
                                                    Event->RegFileOp = (ULONG)Check.Operation;
                                                    Event->RegFileId = (ULONG)Check.Identifier;
                                                }
                                            }

                                            break;
                                        } else {
                                            CpuErrorState = CpuStateCheckMS;
                                            CpuErrorIndex = 0;

                                            // Fall through and see if there are any
                                            // Micro Architecture errors
                                        }                       
                                    }

                                    case CpuStateCheckMS:
                                    {
                                        ERROR_MS_CHECK Check;
                                        
                                        if (Processor->Valid.MsCheckNum > CpuErrorIndex)
                                        {
                                            //
                                            // We have a cache error that we need to
                                            // handle.
                                            // Advance to next error in the section,
                                            // but don't advance the section
                                            //
                                            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                                              "WMI: MCA ModInfo %p indicates MAS error index %d\n",
                                                              ModInfo,
                                                              CpuErrorIndex));
                                            CpuErrorIndex++;
                                            AdvanceSection = FALSE;

                                            if (FirstError)
                                            {
                                                Event->Type = IsFatal ? MCA_ERROR_MAS :
                                                                        MCA_WARNING_MAS;
                                                
                                                Event->MajorErrorType = MCACpuMSError;
                                                if (ModInfo->Valid.CheckInfo == 1)
                                                {
                                                    Check.MsCheck = ModInfo->CheckInfo.CheckInfo;
                                                    Event->MSOp = (ULONG)Check.Operation;
                                                    Event->MSSid = (ULONG)Check.StructureIdentifier;
                                                    Event->Level = (ULONG)Check.Level;
                                                    Event->MSArrayId = (ULONG)Check.ArrayId;
                                                    if (Check.IndexValid == 1)
                                                    {
                                                        Event->MSIndex = (ULONG)Check.Index;
                                                    }
                                                }
                                            }

                                            break;
                                        } else {
                                            if (! FirstError)
                                            {
                                                //
                                                // There are no more errors left in the
                                                // error section so we don't want to
                                                // generate anything.
                                                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                                                  "WMI: MCA ModInfo %p indicates no error index %d\n",
                                                                  ModInfo,
                                                                  CpuErrorIndex));
                                                Header->AdditionalErrors--;
                                                goto DontGenerate;
                                            }
                                        }                                               
                                    }                   
                                }

                                if (FirstError)
                                {
                                    Event->Size = ErrorLogSize;
                                    RawPtr = Event->RawRecord;

                                    //
                                    // Finish filling in WNODE fields
                                    //
                                    Wnode->WnodeHeader.Guid = WmipMSMCAEvent_CPUErrorGuid;
                                    Wnode->SizeDataBlock = FIELD_OFFSET(MSMCAEvent_CPUError,
                                                                       RawRecord) +
                                                           ErrorLogSize;
                                }
                                Status = STATUS_SUCCESS;
                            }
                        } else {
                            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                              "WMI: MCA Processor Error Section %p has invalid size %d\n",
                                              SectionHeader,
                                              SectionHeader->Length));
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                            
                        }
                    } else if (IsEqualGUID(&SectionHeader->Guid, &WmipErrorMemoryGuid)) {
                        //
                        // Build event for MEMORY error eventlog MCA
                        //
                        PMSMCAEvent_MemoryError Event;
                        PERROR_MEMORY Memory;

                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                          "WMI: MCA Section %p indicates memory error\n",
                                          SectionHeader));
                        
                        Status = STATUS_SUCCESS;
                        if (FirstError)
                        {
                            //
                            // Ensure the record contains all of the
                            // fields that it is supposed to
                            //
                            if (SectionHeader->Length >= sizeof(ERROR_MEMORY))
                            {
                                Event = (PMSMCAEvent_MemoryError)Header;
                                Memory = (PERROR_MEMORY)SectionHeader;

                                //
                                // Take note of any recoverable single
                                // bit ECC errors. This may even cause
                                // the memory to be mapped out
                                //
                                if (! IsFatal)
                                {
                                    WmipTrackCorrectedMCE(SingleBitEcc,
                                                          RecordHeader,
                                                          SectionHeader,
                                                          &Header->LogToEventlog);
                                }

                                
                                //
                                // Fill in the data from the MCA within the WMI event
                                //
                                if ((Memory->Valid.PhysicalAddress == 1) &&
                                    (Memory->Valid.AddressMask == 1) &&
                                    (Memory->Valid.Card == 1) &&
                                    (Memory->Valid.Module == 1))
                                {
                                    Event->Type = IsFatal ? MCA_ERROR_MEM_1_2_5_4 :
                                                            MCA_WARNING_MEM_1_2_5_4;
                                } else if ((Memory->Valid.PhysicalAddress == 1) &&
                                           (Memory->Valid.AddressMask == 1) &&
                                           (Memory->Valid.Module == 1))

                                {
                                    Event->Type = IsFatal ? MCA_ERROR_MEM_1_2_5 :
                                                            MCA_WARNING_MEM_1_2_5;
                                } else if (Memory->Valid.PhysicalAddress == 1) 
                                {
                                    Event->Type = IsFatal ? MCA_ERROR_MEM_1_2:
                                                            MCA_WARNING_MEM_1_2;
                                } else {
                                    Event->Type = IsFatal ? MCA_ERROR_MEM_UNKNOWN:
                                                            MCA_WARNING_MEM_UNKNOWN;
                                }

                                Event->VALIDATION_BITS = Memory->Valid.Valid;
                                Event->MEM_ERROR_STATUS = Memory->ErrorStatus.Status;
                                Event->MEM_PHYSICAL_ADDR = Memory->PhysicalAddress;
                                Event->MEM_PHYSICAL_MASK = Memory->PhysicalAddressMask;
                                Event->RESPONDER_ID = Memory->ResponderId;
                                Event->TARGET_ID = Memory->TargetId;
                                Event->REQUESTOR_ID = Memory->RequestorId;
                                Event->BUS_SPECIFIC_DATA = Memory->BusSpecificData;
                                Event->MEM_NODE = Memory->Node;
                                Event->MEM_CARD = Memory->Card;
                                Event->MEM_BANK = Memory->Bank;
                                Event->xMEM_DEVICE = Memory->Device;
                                Event->MEM_MODULE = Memory->Module;
                                Event->MEM_ROW = Memory->Row;
                                Event->MEM_COLUMN = Memory->Column;
                                Event->MEM_BIT_POSITION = Memory->BitPosition;

                                Event->Size = ErrorLogSize;
                                RawPtr = Event->RawRecord;

                                //
                                // Finish filling in WNODE fields
                                //
                                Wnode->WnodeHeader.Guid = WmipMSMCAEvent_MemoryErrorGuid;
                                Wnode->SizeDataBlock = FIELD_OFFSET(MSMCAEvent_MemoryError,
                                                                   RawRecord) +
                                                       ErrorLogSize;
                            } else {
                                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                                  "WMI: MCA Memory Error Section %p has invalid size %d\n",
                                                  SectionHeader,
                                                  SectionHeader->Length));
                                Status = STATUS_INVALID_PARAMETER;
                                break;
                            }
                        }
                    } else if (IsEqualGUID(&SectionHeader->Guid, &WmipErrorPCIBusGuid)) {
                        //
                        // Build event for PCI Component MCA
                        //
                        PMSMCAEvent_PCIBusError Event;
                        PERROR_PCI_BUS PciBus;
                        NTSTATUS PCIBusErrorTypes[] = {
                            MCA_WARNING_PCI_BUS_PARITY,
                            MCA_ERROR_PCI_BUS_PARITY,
                            MCA_WARNING_PCI_BUS_SERR,
                            MCA_ERROR_PCI_BUS_SERR,
                            MCA_WARNING_PCI_BUS_MASTER_ABORT,
                            MCA_ERROR_PCI_BUS_MASTER_ABORT,
                            MCA_WARNING_PCI_BUS_TIMEOUT,
                            MCA_ERROR_PCI_BUS_TIMEOUT,
                            MCA_WARNING_PCI_BUS_PARITY,
                            MCA_ERROR_PCI_BUS_PARITY,
                            MCA_WARNING_PCI_BUS_PARITY,
                            MCA_ERROR_PCI_BUS_PARITY,
                            MCA_WARNING_PCI_BUS_PARITY,
                            MCA_ERROR_PCI_BUS_PARITY
                        };

                        NTSTATUS PCIBusErrorTypesNoInfo[] = {
                            MCA_WARNING_PCI_BUS_PARITY_NO_INFO,
                            MCA_ERROR_PCI_BUS_PARITY_NO_INFO,
                            MCA_WARNING_PCI_BUS_SERR_NO_INFO,
                            MCA_ERROR_PCI_BUS_SERR_NO_INFO,
                            MCA_WARNING_PCI_BUS_MASTER_ABORT_NO_INFO,
                            MCA_ERROR_PCI_BUS_MASTER_ABORT_NO_INFO,
                            MCA_WARNING_PCI_BUS_TIMEOUT_NO_INFO,
                            MCA_ERROR_PCI_BUS_TIMEOUT_NO_INFO,
                            MCA_WARNING_PCI_BUS_PARITY_NO_INFO,
                            MCA_ERROR_PCI_BUS_PARITY_NO_INFO,
                            MCA_WARNING_PCI_BUS_PARITY_NO_INFO,
                            MCA_ERROR_PCI_BUS_PARITY_NO_INFO,
                            MCA_WARNING_PCI_BUS_PARITY_NO_INFO,
                            MCA_ERROR_PCI_BUS_PARITY_NO_INFO
                        };
                        

                        WmipAssert( sizeof(MSMCAEvent_MemoryError) >=
                                    sizeof(MSMCAEvent_PCIBusError) );

                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                          "WMI: MCA Section %p indicates PCI Bus error\n",
                                          SectionHeader));
                        Status = STATUS_SUCCESS;
                        if (FirstError)
                        {
                            if (SectionHeader->Length >= sizeof(ERROR_PCI_BUS))
                            {
                                Event = (PMSMCAEvent_PCIBusError)Header;
                                PciBus = (PERROR_PCI_BUS)SectionHeader;

                                //
                                // Fill in the data from the MCA within the WMI event
                                //
                                if ((PciBus->Type.Type >= PciBusDataParityError) &&
                                    (PciBus->Type.Type <= PciCommandParityError))
                                {
                                    if ((PciBus->Valid.CmdType == 1) &&
                                        (PciBus->Valid.Address == 1) &&
                                        (PciBus->Valid.Id == 1))
                                    {
                                        Event->Type = PCIBusErrorTypes[(2 * (PciBus->Type.Type-1)) +
                                                                       (IsFatal ? 1 : 0)];
                                    } else {
                                        Event->Type = PCIBusErrorTypesNoInfo[(2 * (PciBus->Type.Type-1)) +
                                                                             (IsFatal ? 1 : 0)];
                                    }
                                } else {
                                    Event->Type = IsFatal ? MCA_ERROR_PCI_BUS_UNKNOWN : 
                                                            MCA_WARNING_PCI_BUS_UNKNOWN;
                                }

                                Event->VALIDATION_BITS = PciBus->Valid.Valid;
                                Event->PCI_BUS_ERROR_STATUS = PciBus->ErrorStatus.Status;
                                Event->PCI_BUS_ADDRESS = PciBus->Address;
                                Event->PCI_BUS_DATA = PciBus->Data;
                                Event->PCI_BUS_CMD = PciBus->CmdType;
                                Event->PCI_BUS_REQUESTOR_ID = PciBus->RequestorId;
                                Event->PCI_BUS_RESPONDER_ID = PciBus->ResponderId;
                                Event->PCI_BUS_TARGET_ID = PciBus->TargetId;
                                Event->PCI_BUS_ERROR_TYPE = PciBus->Type.Type;
                                Event->PCI_BUS_ID_BusNumber = PciBus->Id.BusNumber;
                                Event->PCI_BUS_ID_SegmentNumber = PciBus->Id.SegmentNumber;

                                Event->Size = ErrorLogSize;
                                RawPtr = Event->RawRecord;

                                //
                                // Finish filling in WNODE fields
                                //
                                Wnode->WnodeHeader.Guid = WmipMSMCAEvent_PCIBusErrorGuid;
                                Wnode->SizeDataBlock = FIELD_OFFSET(MSMCAEvent_PCIBusError,
                                                                   RawRecord) +
                                                       ErrorLogSize;
                            } else {
                                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                                  "WMI: PCI Bus Error Section %p has invalid size %d\n",
                                                  SectionHeader,
                                                  SectionHeader->Length));
                                Status = STATUS_INVALID_PARAMETER;
                                break;
                            }
                        }
                    } else if (IsEqualGUID(&SectionHeader->Guid, &WmipErrorPCIComponentGuid)) {
                        //
                        // Build event for PCI Component MCA
                        //
                        PMSMCAEvent_PCIComponentError Event;
                        PERROR_PCI_COMPONENT PciComp;

                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                          "WMI: MCA Section %p indicates PCI Component error\n",
                                          SectionHeader));
                        
                        WmipAssert( sizeof(MSMCAEvent_MemoryError) >=
                                    sizeof(MSMCAEvent_PCIComponentError) );

                        Status = STATUS_SUCCESS;
                        if (FirstError)
                        {
                            if (SectionHeader->Length >= sizeof(ERROR_PCI_COMPONENT))
                            {
                                Event = (PMSMCAEvent_PCIComponentError)Header;
                                PciComp = (PERROR_PCI_COMPONENT)SectionHeader;

                                //
                                // Fill in the data from the MCA within the WMI event
                                //
                                Event->Type = IsFatal ? MCA_ERROR_PCI_DEVICE :
                                                        MCA_WARNING_PCI_DEVICE;

                                Event->VALIDATION_BITS = PciComp->Valid.Valid;
                                Event->PCI_COMP_ERROR_STATUS = PciComp->ErrorStatus.Status;
                                Event->PCI_COMP_INFO_VendorId = (USHORT)PciComp->Info.VendorId;
                                Event->PCI_COMP_INFO_DeviceId = (USHORT)PciComp->Info.DeviceId;
                                Event->PCI_COMP_INFO_ClassCodeInterface = PciComp->Info.ClassCodeInterface;
                                Event->PCI_COMP_INFO_ClassCodeSubClass = PciComp->Info.ClassCodeSubClass;
                                Event->PCI_COMP_INFO_ClassCodeBaseClass = PciComp->Info.ClassCodeBaseClass;
                                Event->PCI_COMP_INFO_FunctionNumber = (UCHAR)PciComp->Info.FunctionNumber;
                                Event->PCI_COMP_INFO_DeviceNumber = (UCHAR)PciComp->Info.DeviceNumber;
                                Event->PCI_COMP_INFO_BusNumber = (UCHAR)PciComp->Info.BusNumber;
                                Event->PCI_COMP_INFO_SegmentNumber = (UCHAR)PciComp->Info.SegmentNumber;

                                Event->Size = ErrorLogSize;
                                RawPtr = Event->RawRecord;

                                //
                                // Finish filling in WNODE fields
                                //
                                Wnode->WnodeHeader.Guid = WmipMSMCAEvent_PCIComponentErrorGuid;
                                Wnode->SizeDataBlock = FIELD_OFFSET(MSMCAEvent_PCIComponentError,
                                                                   RawRecord) +
                                                       ErrorLogSize;
                            } else {
                                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                                  "WMI: PCI Component Error Section %p has invalid size %d\n",
                                                  SectionHeader,
                                                  SectionHeader->Length));
                                Status = STATUS_INVALID_PARAMETER;
                                break;
                            }
                        }
                    } else if (IsEqualGUID(&SectionHeader->Guid, &WmipErrorSELGuid)) {
                        //
                        // Build event for System Eventlog MCA
                        //
                        PMSMCAEvent_SystemEventError Event;
                        PERROR_SYSTEM_EVENT_LOG Sel;

                        WmipAssert( sizeof(MSMCAEvent_MemoryError) >=
                                    sizeof(MSMCAEvent_SystemEventError) );

                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                          "WMI: MCA Section %p indicates SEL error\n",
                                          SectionHeader));
                        Status = STATUS_SUCCESS;
                        if (FirstError)
                        {
                            if (SectionHeader->Length >= sizeof(ERROR_SYSTEM_EVENT_LOG))
                            {
                                Event = (PMSMCAEvent_SystemEventError)Header;
                                Sel = (PERROR_SYSTEM_EVENT_LOG)SectionHeader;

                                //
                                // Fill in the data from the MCA within the WMI event
                                //
                                Event->Type = IsFatal ? MCA_ERROR_SYSTEM_EVENT :
                                                        MCA_WARNING_SYSTEM_EVENT;

                                Event->VALIDATION_BITS = Sel->Valid.Valid;
                                Event->SEL_RECORD_ID = Sel->RecordId;       
                                Event->SEL_RECORD_TYPE = Sel->RecordType;
                                Event->SEL_TIME_STAMP = Sel->TimeStamp;
                                Event->SEL_GENERATOR_ID = Sel->GeneratorId;
                                Event->SEL_EVM_REV = Sel->EVMRevision;
                                Event->SEL_SENSOR_TYPE = Sel->SensorType;
                                Event->SEL_SENSOR_NUM = Sel->SensorNumber;
                                Event->SEL_EVENT_DIR_TYPE = Sel->EventDir;
                                Event->SEL_DATA1 = Sel->Data1;
                                Event->SEL_DATA2 = Sel->Data2;
                                Event->SEL_DATA3 = Sel->Data3;

                                Event->Size = ErrorLogSize;
                                RawPtr = Event->RawRecord;

                                //
                                // Finish filling in WNODE fields
                                //
                                Wnode->WnodeHeader.Guid = WmipMSMCAEvent_SystemEventErrorGuid;
                                Wnode->SizeDataBlock = FIELD_OFFSET(MSMCAEvent_SystemEventError,
                                                                   RawRecord) +
                                                       ErrorLogSize;
                            } else {
                                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                                  "WMI: System Eventlog Error Section %p has invalid size %d\n",
                                                  SectionHeader,
                                                  SectionHeader->Length));
                                Status = STATUS_INVALID_PARAMETER;
                                break;
                            }
                        }
                    } else if (IsEqualGUID(&SectionHeader->Guid, &WmipErrorSMBIOSGuid)) {
                        //
                        // Build event for SMBIOS MCA
                        //
                        PMSMCAEvent_SMBIOSError Event;
                        PERROR_SMBIOS Smbios;

                        WmipAssert( sizeof(MSMCAEvent_MemoryError) >=
                                    sizeof(MSMCAEvent_SMBIOSError) );


                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                          "WMI: MCA Section %p indicates smbios error\n",
                                          SectionHeader));
                        Status = STATUS_SUCCESS;
                        if (FirstError)
                        {
                            if (SectionHeader->Length >= sizeof(ERROR_SMBIOS))
                            {
                                Event = (PMSMCAEvent_SMBIOSError)Header;
                                Smbios = (PERROR_SMBIOS)SectionHeader;

                                //
                                // Fill in the data from the MCA within the WMI event
                                //
                                Event->Type = IsFatal ? MCA_ERROR_SMBIOS :
                                                        MCA_WARNING_SMBIOS;

                                Event->VALIDATION_BITS = Smbios->Valid.Valid;
                                Event->SMBIOS_EVENT_TYPE = Smbios->EventType;

                                Event->Size = ErrorLogSize;
                                RawPtr = Event->RawRecord;

                                //
                                // Finish filling in WNODE fields
                                //
                                Wnode->WnodeHeader.Guid = WmipMSMCAEvent_SMBIOSErrorGuid;
                                Wnode->SizeDataBlock = FIELD_OFFSET(MSMCAEvent_SMBIOSError,
                                                                   RawRecord) +
                                                       ErrorLogSize;
                            } else {
                                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                                  "WMI: SMBIOS Error Section %p has invalid size %d\n",
                                                  SectionHeader,
                                                  SectionHeader->Length));
                                Status = STATUS_INVALID_PARAMETER;
                                break;
                            }
                        }
                    } else if (IsEqualGUID(&SectionHeader->Guid, &WmipErrorSpecificGuid)) {
                        //
                        // Build event for Platform Specific MCA
                        //
                        PMSMCAEvent_PlatformSpecificError Event;
                        PERROR_PLATFORM_SPECIFIC Specific;

                        WmipAssert( sizeof(MSMCAEvent_MemoryError) >=
                                    sizeof(MSMCAEvent_PlatformSpecificError) );

                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                          "WMI: MCA Section %p indicates platform specific error\n",
                                          SectionHeader));
                        Status = STATUS_SUCCESS;
                        if (FirstError)
                        {
                            if (SectionHeader->Length >= sizeof(ERROR_PLATFORM_SPECIFIC))
                            {
                                Event = (PMSMCAEvent_PlatformSpecificError)Header;
                                Specific = (PERROR_PLATFORM_SPECIFIC)SectionHeader;

                                //
                                // Fill in the data from the MCA within the WMI event
                                //
                                Event->Type = IsFatal ? MCA_ERROR_PLATFORM_SPECIFIC :
                                                        MCA_WARNING_PLATFORM_SPECIFIC;

                                Event->VALIDATION_BITS = Specific->Valid.Valid;
                                Event->PLATFORM_ERROR_STATUS = Specific->ErrorStatus.Status;
                #if 0
                // TODO: Wait until we figure this out              
                                Event->PLATFORM_REQUESTOR_ID = Specific->;
                                Event->PLATFORM_RESPONDER_ID = Specific->;
                                Event->PLATFORM_TARGET_ID = Specific->;
                                Event->PLATFORM_BUS_SPECIFIC_DATA = Specific->;
                                Event->OEM_COMPONENT_ID = Specific->[16];
                #endif              
                                Event->Size = ErrorLogSize;
                                RawPtr = Event->RawRecord;

                                //
                                // Finish filling in WNODE fields
                                //
                                Wnode->WnodeHeader.Guid = WmipMSMCAEvent_PlatformSpecificErrorGuid;
                                Wnode->SizeDataBlock = FIELD_OFFSET(MSMCAEvent_PlatformSpecificError,
                                                                   RawRecord) +
                                                       ErrorLogSize;
                            } else {
                                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                                  "WMI: Platform specific Error Section %p has invalid size %d\n",
                                                  SectionHeader,
                                                  SectionHeader->Length));
                                Status = STATUS_INVALID_PARAMETER;
                                break;
                            }                           
                        }
                    } else {
                        //
                        // We don't recognize the guid, so we use a very generic
                        // eventlog message for it
                        //
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                              "WMI: Unknown Error GUID at %p\n",
                                              &SectionHeader->Guid));

                        //
                        // If we've already analyzed an error then we
                        // don't really care that this one can't be
                        // analyzed
                        //
                        if (FirstError)
                        {
                            Status = STATUS_INVALID_PARAMETER;
                        }
                    }
                }
                
                //
                // Advance to the next section within the Error record
                //
DontGenerate:               
                if (AdvanceSection)
                {
                    SizeUsed += SectionHeader->Length;
                    ModInfo = NULL;
                }

                //
                // If we've successfully parsed an error section then
                // we want to remember that. Only the first error gets
                // analyzed while we calculate the number of additional
                // errors following
                //
                if (NT_SUCCESS(Status))
                {
                    FirstError = FALSE;
                }
            }
        }
#endif

        //
        // If we were not able to build a specific event type then
        // we fallback and fire a generic one
        //
        if (! NT_SUCCESS(Status))
        {
            //
            // Build event for Unknown MCA
            //
            PMSMCAEvent_InvalidError Event;

            WmipAssert( sizeof(MSMCAEvent_MemoryError) >=
                        sizeof(MSMCAEvent_InvalidError) );

            Event = (PMSMCAEvent_InvalidError)Header;

            //
            // Fill in the data from the MCA within the WMI event
            //
            if (Header->Cpu == MCA_UNDEFINED_CPU)
            {
                Event->Type = IsFatal ? MCA_ERROR_UNKNOWN_NO_CPU :
                                        MCA_WARNING_UNKNOWN_NO_CPU;
            } else {
                Event->Type = IsFatal ? MCA_ERROR_UNKNOWN :
                                        MCA_WARNING_UNKNOWN;
            }

            Event->Size = ErrorLogSize;
            RawPtr = Event->RawRecord;

            //
            // Finish filling in WNODE fields
            //
            Wnode->WnodeHeader.Guid = WmipMSMCAEvent_InvalidErrorGuid;
            Wnode->SizeDataBlock = FIELD_OFFSET(MSMCAEvent_InvalidError,
                                               RawRecord) +
                                   ErrorLogSize;

        }

        //
        // Adjust the Error event count
        //
        if (Header->AdditionalErrors > 0)
        {
            Header->AdditionalErrors--;
        }
        
        //
        // Put the entire MCA record into the event
        //
        RtlCopyMemory(RawPtr,
                      RecordHeader,
                      ErrorLogSize);

        if ((! IsFatal) && (Header->LogToEventlog == 1))

        {
            if (WmipCorrectedEventlogCounter != 0)
            {
                //
                // Since this is a corrected error that is getting
                // logged to the eventlog we need to account for it
                //
                if ((WmipCorrectedEventlogCounter != 0xffffffff) &&
                    (--WmipCorrectedEventlogCounter == 0))
                {
                    WmipWriteToEventlog(MCA_INFO_NO_MORE_CORRECTED_ERROR_LOGS,
                                        STATUS_SUCCESS);
                }
            } else {
                //
                // We have exceeded the limit of corrected errors that
                // we are allowed to write into the eventlog, so we
                // just suppress it
                //
                Header->LogToEventlog = 0;
            }           
        }
        
        //
        // Now go and fire off the event
        //
        if ((WmipDisableMCAPopups == 0) &&
           (Header->LogToEventlog != 0))
        {
            IoRaiseInformationalHardError(STATUS_MCA_OCCURED,
                                          NULL,
                                          NULL);
        }

        if ((Header->LogToEventlog == 1) ||
            (WmipIsWbemRunning()))
        {
            //
            // Only fire off a WMI event if we want to log to the
            // eventlog or WBEM is up and running
            //
            Status = WmipWriteMCAEventLogEvent((PUCHAR)Wnode);
        }

        if (! NT_SUCCESS(Status))
        {
            ExFreePool(Wnode);
        }

    } else {
        //
        // Not enough memory to do a full MCA event so lets just do a
        // generic one
        //
        WmipWriteToEventlog(IsFatal ? MCA_WARNING_UNKNOWN_NO_CPU :
                                          MCA_ERROR_UNKNOWN_NO_CPU,
                           STATUS_INSUFFICIENT_RESOURCES);
    }
}



NTSTATUS WmipWriteMCAEventLogEvent(
    PUCHAR Event
    )
{
    PWNODE_HEADER Wnode = (PWNODE_HEADER)Event;
    NTSTATUS Status;

    PAGED_CODE();
    
    WmipEnterSMCritSection();
    
    if (WmipIsWbemRunning() ||
        WmipCheckIsWbemRunning())
    {
        //
        // We know WBEM is running so we can just fire off our event
        //
        WmipLeaveSMCritSection();
        Status = IoWMIWriteEvent(Event);
    } else {
        //
        // WBEM is not currently running and so startup a timer that
        // will keep polling it
        //
        if (WmipIsWbemRunningFlag == WBEM_STATUS_UNKNOWN)
        {
            //
            // No one has kicked off the waiting process for wbem so we
            // do that here. Note we need to maintain the critical
            // section to guard angainst another thread that might be
            // trying to startup the waiting process as well. Note that
            // if the setup fails we want to stay in the unknown state
            // so that the next time an event is fired we can retry
            // waiting for wbem
            //
            Status = WmipSetupWaitForWbem();
            if (NT_SUCCESS(Status))
            {
                WmipIsWbemRunningFlag = WAITING_FOR_WBEM;
            }
        }
        
        Wnode->ClientContext = Wnode->BufferSize;
        InsertTailList(&WmipWaitingMCAEvents,
                       (PLIST_ENTRY)Event);
        WmipLeaveSMCritSection();
        Status = STATUS_SUCCESS;
    }
    return(Status);
}

ULONG WmipWbemMinuteWait = 1;

NTSTATUS WmipSetupWaitForWbem(
    void
    )
{
    LARGE_INTEGER TimeOut;
    NTSTATUS Status;
    
    PAGED_CODE();

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                      "WMI: SetupWaitForWbem starting\n"));

    //
    // Initialize a kernel time to fire periodically so we can
    // check if WBEM has started or not
    //
    KeInitializeTimer(&WmipIsWbemRunningTimer);

    KeInitializeDpc(&WmipIsWbemRunningDpc,
                    WmipIsWbemRunningDispatch,
                    NULL);

    ExInitializeWorkItem(&WmipIsWbemRunningWorkItem,
                         WmipIsWbemRunningWorker,
                         NULL);

    TimeOut.HighPart = -1;
    TimeOut.LowPart = -1 * (WmipWbemMinuteWait * 60 * 1000 * 10000);    // 1 minutes
    KeSetTimer(&WmipIsWbemRunningTimer,
               TimeOut,
               &WmipIsWbemRunningDpc);

    Status = STATUS_SUCCESS;

    return(Status);
}

void WmipIsWbemRunningDispatch(    
    IN PKDPC Dpc,
    IN PVOID DeferredContext,     // Not Used
    IN PVOID SystemArgument1,     // Not Used
    IN PVOID SystemArgument2      // Not Used
    )
{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    ExQueueWorkItem(&WmipIsWbemRunningWorkItem,
                    DelayedWorkQueue);
}

void WmipIsWbemRunningWorker(
    PVOID Context
    )
{
    LARGE_INTEGER TimeOut;
    
    PAGED_CODE();
    
    UNREFERENCED_PARAMETER (Context);

    if (! WmipCheckIsWbemRunning())
    {
        //
        // WBEM is not yet started, so timeout in another minute to
        // check again
        //
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                          "WMI: IsWbemRunningWorker starting -> WBEM not started\n"));

        TimeOut.HighPart = -1;
        TimeOut.LowPart = (ULONG)(-1 * (1 *60 *1000 *10000));   // 1 minutes
        KeSetTimer(&WmipIsWbemRunningTimer,
                   TimeOut,
                   &WmipIsWbemRunningDpc);
        
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                          "WMI: WbemRunningWorker found wbem started\n"));

    }
}

BOOLEAN WmipCheckIsWbemRunning(
    void
    )
{
    OBJECT_ATTRIBUTES Obj;
    UNICODE_STRING Name;
    HANDLE Handle;
    LARGE_INTEGER TimeOut;
    BOOLEAN IsWbemRunning = FALSE;
    NTSTATUS Status;
    PWNODE_HEADER Wnode;

    PAGED_CODE();

    RtlInitUnicodeString(&Name,
                         L"\\BaseNamedObjects\\WBEM_ESS_OPEN_FOR_BUSINESS");

    
    InitializeObjectAttributes(
        &Obj,
        &Name,
        FALSE,
        NULL,
        NULL
        );

    Status = ZwOpenEvent(
                &Handle,
                SYNCHRONIZE,
                &Obj
                );

    if (NT_SUCCESS(Status))
    {
        TimeOut.QuadPart = 0;
        Status = ZwWaitForSingleObject(Handle,
                                       FALSE,
                                       &TimeOut);
        if (Status == STATUS_SUCCESS)
        {
            IsWbemRunning = TRUE;

            //
            // We've determined that WBEM is running so now lets see if
            // another thread has made that dermination as well. If not
            // then we can flush the MCA event queue and set the flag
            // that WBEM is running
            //
            WmipEnterSMCritSection();
            if (WmipIsWbemRunningFlag != WBEM_IS_RUNNING)
            {
                //
                // Flush the list of all MCA events waiting to be fired
                //
                while (! IsListEmpty(&WmipWaitingMCAEvents))
                {
                    Wnode = (PWNODE_HEADER)RemoveHeadList(&WmipWaitingMCAEvents);
                    WmipLeaveSMCritSection();
                    Wnode->BufferSize = Wnode->ClientContext;
                    Wnode->Linkage = 0;
                    Status = IoWMIWriteEvent(Wnode);
                    if (! NT_SUCCESS(Status))
                    {
                        ExFreePool(Wnode);
                    }
                    WmipEnterSMCritSection();
                }
                
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_MCA_LEVEL,
                                  "WMI: WBEM is Running and queus flushed\n"));
                
                WmipIsWbemRunningFlag = WBEM_IS_RUNNING;
            }
            WmipLeaveSMCritSection();
        }
        ZwClose(Handle);
    }
    return(IsWbemRunning);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\register.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    register.c

Abstract:

    Kerenel mode registration cache

Author:

    AlanWar

Environment:

    Kernel Mode

Revision History:


--*/

#include "wmikmp.h"

void WmipWaitForIrpCompletion(
    PREGENTRY RegEntry
    );

NTSTATUS WmipUpdateDS(
    PREGENTRY RegEntry
    );

NTSTATUS WmipRegisterDS(
    PREGENTRY RegEntry
);

void WmipRemoveDS(
    PREGENTRY RegEntry
);

NTSTATUS WmipValidateWmiRegInfoString(
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    ULONG Offset,
    PWCHAR *String
);


NTSTATUS WmipRegisterOrUpdateDS(
    PREGENTRY RegEntry,
    BOOLEAN Update
    );

void WmipRegistrationWorker(
    PVOID Context
   );

NTSTATUS WmipQueueRegWork(
    REGOPERATION RegOperation,
    PREGENTRY RegEntry
    );


#if defined(_WIN64)
PREGENTRY WmipFindRegEntryByProviderId(
    ULONG ProviderId,
    BOOLEAN ReferenceIrp
    );

ULONG WmipAllocProviderId(
    PDEVICE_OBJECT DeviceObject
    );

#endif
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WmipInitializeRegistration)

#pragma alloc_text(PAGE,WmipRegisterDevice)
#pragma alloc_text(PAGE,WmipDeregisterDevice)
#pragma alloc_text(PAGE,WmipUpdateRegistration)
#pragma alloc_text(PAGE,WmipDoUnreferenceRegEntry)
#pragma alloc_text(PAGE,WmipWaitForIrpCompletion)
#pragma alloc_text(PAGE,WmipFindRegEntryByDevice)
#pragma alloc_text(PAGE,WmipTranslatePDOInstanceNames)
#pragma alloc_text(PAGE,WmipPDOToDeviceInstanceName)
#pragma alloc_text(PAGE,WmipRemoveDS)
#pragma alloc_text(PAGE,WmipRegisterDS)
#pragma alloc_text(PAGE,WmipUpdateDS)
#pragma alloc_text(PAGE,WmipValidateWmiRegInfoString)
#pragma alloc_text(PAGE,WmipProcessWmiRegInfo)
#pragma alloc_text(PAGE,WmipRegisterOrUpdateDS)
#pragma alloc_text(PAGE,WmipQueueRegWork)
#pragma alloc_text(PAGE,WmipRegistrationWorker)
#pragma alloc_text(PAGE,WmipAllocRegEntry)

#if defined(_WIN64)
#pragma alloc_text(PAGE,WmipFindRegEntryByProviderId)
#pragma alloc_text(PAGE,WmipAllocProviderId)
#endif
#endif

LIST_ENTRY WmipInUseRegEntryHead = {&WmipInUseRegEntryHead,&WmipInUseRegEntryHead};
LONG WmipInUseRegEntryCount = 0;

KSPIN_LOCK WmipRegistrationSpinLock;

NPAGED_LOOKASIDE_LIST WmipRegLookaside;
KMUTEX WmipRegistrationMutex;

const GUID WmipDataProviderPnpidGuid = DATA_PROVIDER_PNPID_GUID;
const GUID WmipDataProviderPnPIdInstanceNamesGuid = DATA_PROVIDER_PNPID_INSTANCE_NAMES_GUID;

WORK_QUEUE_ITEM WmipRegWorkQueue;

//
// WmipRegWorkItemCount starts at 1 so that all drivers who register
// before phase 1 of WMI initialization won't kick off the reg work
// item. In phase 1 we decrement the count and if it is not zero then
// we kick it off since it is now same to send the drivers reg info
// irps
//
LONG WmipRegWorkItemCount = 1;
LIST_ENTRY WmipRegWorkList = {&WmipRegWorkList, &WmipRegWorkList};

void WmipInitializeRegistration(
    ULONG Phase
    )
{
    PAGED_CODE();

    if (Phase == 0)
    {
        //
        //  Initialize lookaside lists
        //
        ExInitializeNPagedLookasideList(&WmipRegLookaside,
                                   NULL,
                                   NULL,
                                   0,
                                   sizeof(REGENTRY),
                                   WMIREGPOOLTAG,
                                   0);

        //
        // Initialize Registration Spin Lock
        KeInitializeSpinLock(&WmipRegistrationSpinLock);
        
        // TODO: If we have any early registrants then we need to add them to
        //       the RegEntry list now.
    } else {
        //
        // Kick off work item that will send reg irps to all of the
        // drivers that have registered. We are sure there is at least
        // one device that needs this since there is the internal wmi
        // data device
        //
        ExInitializeWorkItem( &WmipRegWorkQueue,
                          WmipRegistrationWorker,
                          NULL );

        if (InterlockedDecrement(&WmipRegWorkItemCount) != 0)
        {
            ExQueueWorkItem(&WmipRegWorkQueue, DelayedWorkQueue);
        }
    }
}

#if defined(_WIN64)
LONG WmipProviderIdCounter = 1;
ULONG WmipAllocProviderId(
    PDEVICE_OBJECT DeviceObject
    )
{
    PAGED_CODE();
    
    UNREFERENCED_PARAMETER (DeviceObject);

    return(InterlockedIncrement(&WmipProviderIdCounter));
}
#else
#define WmipAllocProviderId(DeviceObject) ((ULONG)(DeviceObject))
#endif

PREGENTRY WmipAllocRegEntry(
    PDEVICE_OBJECT DeviceObject,
    ULONG Flags
    )
/*++

Routine Description:

    Allocate a REGENTRY structure. If successful the RegEntry returns with
    a ref count of 1.

    NOTE: This routine assumes that the registration critical section is held

Arguments:

    DeviceObject is the value to fill in the DeviceObject field of the
        RegEntry.

Return Value:

    pointer to a REGENTRY or NULL if no memory is available

--*/
{
    PREGENTRY RegEntry;

    PAGED_CODE();
    
    RegEntry = ExAllocateFromNPagedLookasideList(&WmipRegLookaside);

    if (RegEntry != NULL)
    {
        //
        // Initialize the RegEntry. Note that the regentry will start out with
        // a ref count of 1
        KeInitializeEvent(&RegEntry->Event,
                          SynchronizationEvent,
                          FALSE);


        RegEntry->Flags = Flags;
        RegEntry->DeviceObject = DeviceObject;
        RegEntry->RefCount = 1;
        RegEntry->IrpCount = 0;
        RegEntry->PDO = NULL;
        RegEntry->DataSource = NULL;

        RegEntry->ProviderId = WmipAllocProviderId(DeviceObject);

        //
        //  Now place the RegEntry on the in use list
        InterlockedIncrement(&WmipInUseRegEntryCount);

        ExInterlockedInsertTailList(&WmipInUseRegEntryHead,
                                    &RegEntry->InUseEntryList,
                                    &WmipRegistrationSpinLock);
    }
    return(RegEntry);
}

BOOLEAN WmipDoUnreferenceRegEntry(
    PREGENTRY RegEntry
    )
/*++

Routine Description:

    Remove a reference on a REGENTRY. If the last reference is removed
    then mark the RegEntry as available and put it on the free list;

Arguments:

    RegEntry is pointer to entry to free

Return Value:

    On checked builds returns TRUE if last ref count was removed from REGENTRY
    and it was placed back on free list.

--*/
{
    BOOLEAN Freed;
    ULONG ProviderId;

    PAGED_CODE();

    WmipEnterSMCritSection();
    Freed = (InterlockedDecrement(&RegEntry->RefCount) == 0 ? TRUE : FALSE);
    if (Freed)
    {
        //
        // We should only ever free this after the driver has released it
        WmipAssert(RegEntry->Flags & REGENTRY_FLAG_RUNDOWN);
        WmipAssert(RegEntry->Flags & REGENTRY_FLAG_NOT_ACCEPTING_IRPS);

        //
        // Make sure the ref to the PDO is removed
        //
        if (RegEntry->PDO != NULL)
        {
            ObDereferenceObject(RegEntry->PDO);
            RegEntry->PDO = NULL;
        }
        
        //
        // Remove entry from in use list
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_REGISTRATION_LEVEL, \
                      "WMI: RegEntry %p removed from list\n", \
                      RegEntry, __FILE__, __LINE__)); \
        ProviderId = RegEntry->ProviderId;
        ExInterlockedRemoveHeadList(RegEntry->InUseEntryList.Blink,
                                   &WmipRegistrationSpinLock);
        InterlockedDecrement(&WmipInUseRegEntryCount);
        WmipLeaveSMCritSection();

        WmipRemoveDS(RegEntry);

        ExFreeToNPagedLookasideList(&WmipRegLookaside,
                                   RegEntry);
    } else {
        WmipLeaveSMCritSection();
    }
    return(Freed);
}

void WmipWaitForIrpCompletion(
    PREGENTRY RegEntry
    )
/*++

Routine Description:

    Stall here until all WMI irps for this device are completed.

Arguments:

    RegEntry is pointer to entry for the device to stall

Return Value:


--*/
{
    PAGED_CODE();

    WmipAssert(RegEntry->Flags & REGENTRY_FLAG_RUNDOWN);
    WmipAssert(RegEntry->Flags & REGENTRY_FLAG_NOT_ACCEPTING_IRPS);

    if (RegEntry->IrpCount != 0)
    {
        //
        // CONSIDER: If irp is marked pending do we need to cancel it ???
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                          DPFLTR_REGISTRATION_LEVEL,
                          "WMI: Waiting for %x to complete all irps\n",
                  RegEntry->DeviceObject));

        KeWaitForSingleObject(&RegEntry->Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              (PLARGE_INTEGER)NULL);
        WmipAssert(RegEntry->IrpCount == 0);
    }
}

NTSTATUS WmipRegisterDevice(
    PDEVICE_OBJECT DeviceObject,
    ULONG RegistrationFlag
    )
/*++

Routine Description:

    Remember information about a new device being registered and
    then go and get the registration information.

Arguments:

    DeviceObject is a pointer to the device object being registered
        or the callback entry point

    RegistrationFlag is either WMIREG_FLAG_CALLBACK if DeviceObject is
        a callback pointer, or WMIREG_FLAG_TRACE_PROVIDER is DeviceObject
        can also generate event traces.

Return Value:

    NT status code

--*/
{
    PREGENTRY RegEntry;
    NTSTATUS Status;
    ULONG Flags;
#ifdef MEMPHIS
    ULONG IsCallback = 0;
#else
    ULONG IsCallback = RegistrationFlag & WMIREG_FLAG_CALLBACK;
#endif
    BOOLEAN UpdateDeviceStackSize = FALSE;

    PAGED_CODE();

    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                       DPFLTR_REGISTRATION_LEVEL,
                       "WMI: Registering device %p flags %x\n",
                       DeviceObject,
                       RegistrationFlag
                      ));
    
    WmipEnterSMCritSection();
    RegEntry = WmipFindRegEntryByDevice(DeviceObject, FALSE);
    if (RegEntry == NULL)
    {
        if (! IsCallback)
        {
            //
            // Data providers that register with a device object and not a
            // callback have their device object referenced so that it will
            // stick around while WMI needs it. This reference is removed
            // when the device unregisters with WMI and all WMI irps are
            // completed.
            Status = ObReferenceObjectByPointer(DeviceObject,
                                        0,
                                        NULL,    /* *IoDeviceObjectType */
                                        KernelMode);
            if (NT_SUCCESS(Status))
            {
                UpdateDeviceStackSize = TRUE;
            }
        } else {
            //
            // No reference counting is done for callbacks. It is the data
            // provider's responsibility to synchronize any unloading and
            // deregistration issues.
            Status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Allocate, initialize and place on active list
            Flags = REGENTRY_FLAG_NEWREGINFO | REGENTRY_FLAG_INUSE |
                            (IsCallback ? REGENTRY_FLAG_CALLBACK : 0);
#ifndef MEMPHIS
            if (RegistrationFlag & WMIREG_FLAG_TRACE_PROVIDER) {
                Flags |= REGENTRY_FLAG_TRACED;
                Flags |= (RegistrationFlag & WMIREG_FLAG_TRACE_NOTIFY_MASK);
            }
#endif
            Flags |= REGENTRY_FLAG_REG_IN_PROGRESS;
            RegEntry = WmipAllocRegEntry(DeviceObject, Flags);

            if (RegEntry != NULL)
            {               
                // We need to take an extra ref count before
                // releasing the critical section.  One class of drivers
                // (kmixer) will register and unregister multiple times 
                // in different threads and this can lead to a race where
                // the regentry is removed from the list twice
                //
                WmipReferenceRegEntry(RegEntry);
                WmipLeaveSMCritSection();
                
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                   DPFLTR_REGISTRATION_LEVEL,
                                   "WMI: Register alloced REGENTRY %p for %p\n",
                                   RegEntry,
                                   DeviceObject
                                  ));
                //
                // Go and get registration information from the driver
                //
                if (IsCallback)
                {
                    //
                    // We can perform registration callback now since
                    // we do not need to worry about deadlocks
                    //
                    Status = WmipRegisterDS(RegEntry);
                    if (NT_SUCCESS(Status))
                    {
                        //
                        // Mark regentry as fully registered so now we can start
                        // accepting unregister calls
                        //
                        RegEntry->Flags &= ~REGENTRY_FLAG_REG_IN_PROGRESS;
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                          DPFLTR_REGISTRATION_LEVEL,
                                          "WMI: WmipRegisterDS(%p) succeeded for callback %p\n",
                                          RegEntry, RegEntry->DeviceObject));
                    } else {
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                          DPFLTR_REGISTRATION_LEVEL,
                                          "WMI: WmipRegisterDS(%p) failed %x for device %p\n",
                                          RegEntry, Status, RegEntry->DeviceObject));

                        //
                        // Remove ref so regentry goes away
                        //
                        WmipUnreferenceRegEntry(RegEntry);
                    }
                    
                } else {
                    //
                    // We need to send the registration irp from within
                    // a work item and not in the context of this
                    // routine. This is becuase some drivers will not
                    // process irps while in the StartDevice/AddDevice
                    // context, so we'd get deadlock
                    //
                    Status = WmipQueueRegWork(RegisterSingleDriver, RegEntry);
                    if (! NT_SUCCESS(Status))
                    {
                        //
                        // If failed then remove regentry from list
                        //                      
                        RegEntry->Flags |= (REGENTRY_FLAG_RUNDOWN |
                                            REGENTRY_FLAG_NOT_ACCEPTING_IRPS);
                        WmipUnreferenceRegEntry(RegEntry);
                    }
                }

                //
                // Remove extra regentry ref count taken above
                //
                WmipUnreferenceRegEntry(RegEntry);

            } else {
                WmipLeaveSMCritSection();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                   DPFLTR_REGISTRATION_LEVEL,
                                   "WMI: Register could not alloc REGENTRY for %p\n",
                                   DeviceObject
                                  ));
            }
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                               DPFLTR_REGISTRATION_LEVEL,
                               "WMI: Register could not ObRef %p status  %x\n",
                               DeviceObject,
                               Status
                              ));
            WmipLeaveSMCritSection();
        }
    } else {
        //
        // A device object may only register once
        WmipLeaveSMCritSection();
        Status = STATUS_OBJECT_NAME_EXISTS;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                          DPFLTR_REGISTRATION_LEVEL,
                          "WMI: Device Object %x attempting to register twice\n",
                 DeviceObject));
        WmipUnreferenceRegEntry(RegEntry);
    }

    if (UpdateDeviceStackSize)
    {
        //
        // Since WMI will be forwarding irps to this device the WMI irp
        // stack size must be at least one larger than that of the device
        WmipUpdateDeviceStackSize(
                                  (CCHAR)(DeviceObject->StackSize+1));
    }

    return(Status);
}

NTSTATUS WmipDeregisterDevice(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Remove registration entry for a device

Arguments:

    DeviceObject is a pointer to the device object being deregistered


Return Value:

    NT status code

--*/
{
    NTSTATUS Status;
    PREGENTRY RegEntry;
    ULONG Flags;

    PAGED_CODE();

    WmipEnterSMCritSection();
    RegEntry = WmipFindRegEntryByDevice(DeviceObject, FALSE);
    if (RegEntry != NULL)
    {

        //
        // Mark the regentry as invalid so that no more irps are sent to the
        // device and the event will set when the last irp completes.
        Flags = InterlockedExchange(&RegEntry->Flags,
                        (REGENTRY_FLAG_RUNDOWN |
                         REGENTRY_FLAG_NOT_ACCEPTING_IRPS) );

        //
        // Once the regentry is marked as RUNDOWN then it will not be found
        // later so it is safe to release the lock.
        WmipLeaveSMCritSection();
        WmipUnreferenceRegEntry(RegEntry);

        //
        // Now if there are any outstanding irps for the device then we need
        // to wait here until they complete.
        WmipWaitForIrpCompletion(RegEntry);
        if (! (Flags & REGENTRY_FLAG_CALLBACK))
        {
            ObDereferenceObject(DeviceObject);
        }

        //
        // Release last reference to REGENTRY after KMREGINFO is set
        WmipUnreferenceRegEntry(RegEntry);

        Status = STATUS_SUCCESS;
    } else {
        WmipLeaveSMCritSection();
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                          DPFLTR_REGISTRATION_LEVEL,
                          "WMI: WmipDeregisterDevice called with invalid Device Object %x\n",
                 DeviceObject));
        Status = STATUS_INVALID_PARAMETER;
    }


    return(Status);
}

NTSTATUS WmipUpdateRegistration(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Flags that device has updated registration information

Arguments:

    DeviceObject is a pointer to the device object that wants to update
        its information


Return Value:

    NT status code

--*/
{
    NTSTATUS Status;
    PREGENTRY RegEntry;

    PAGED_CODE();

    RegEntry = WmipFindRegEntryByDevice(DeviceObject, FALSE);
    if (RegEntry != NULL)
    {
        Status = WmipQueueRegWork(RegisterUpdateSingleDriver,
                                  RegEntry);
        WmipUnreferenceRegEntry(RegEntry);
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return(Status);
}

#if defined(_WIN64)

PREGENTRY WmipDoFindRegEntryByProviderId(
    ULONG ProviderId,
    ULONG InvalidFlags
    )
{
    //
    // This routine assumes that any synchronization mechanism has
    // been taken. This routine can be called at dispatch level
    //
    
    PREGENTRY RegEntry;
    PLIST_ENTRY RegEntryList;
    
    RegEntryList = WmipInUseRegEntryHead.Flink;
    while (RegEntryList != &WmipInUseRegEntryHead)
    {
        RegEntry = CONTAINING_RECORD(RegEntryList,
                                     REGENTRY,
                                     InUseEntryList);

        if ((RegEntry->ProviderId == ProviderId) &&
            (! (RegEntry->Flags & InvalidFlags)))

        {
            return(RegEntry);
        }
        RegEntryList = RegEntryList->Flink;
    }
    return(NULL);
}

PREGENTRY WmipFindRegEntryByProviderId(
    ULONG ProviderId,
    BOOLEAN ReferenceIrp
    )
/*++

Routine Description:

    This routine will find a RegEntry that corresponds to the DeviceObject
    passed.

Arguments:

    DeviceObject is the device object that is the key for the RegEntry to find

    ReferenceIrp is TRUE then the Irp refcount will be incremented if a
        RegEntry is found for the device

Return Value:

    pointer to entry if available else NULL

--*/
{
    PREGENTRY RegEntry;

    PAGED_CODE();

    WmipEnterSMCritSection();

    RegEntry = WmipDoFindRegEntryByProviderId(ProviderId,
                                              REGENTRY_FLAG_RUNDOWN);
    if (RegEntry != NULL)
    {
        WmipReferenceRegEntry(RegEntry);
        if (ReferenceIrp)
        {
            InterlockedIncrement(&RegEntry->IrpCount);
        }
    }
    
    WmipLeaveSMCritSection();
    return(RegEntry);
}
#endif

PREGENTRY WmipDoFindRegEntryByDevice(
    PDEVICE_OBJECT DeviceObject,
    ULONG InvalidFlags
    )
{
    //
    // This routine assumes that any synchronization mechanism has
    // been taken. This routine can be called at dispatch level
    //
    
    PREGENTRY RegEntry;
    PLIST_ENTRY RegEntryList;
    
    RegEntryList = WmipInUseRegEntryHead.Flink;
    while (RegEntryList != &WmipInUseRegEntryHead)
    {
        RegEntry = CONTAINING_RECORD(RegEntryList,
                                     REGENTRY,
                                     InUseEntryList);

        if ((RegEntry->DeviceObject == DeviceObject) &&
            (! (RegEntry->Flags & InvalidFlags)))

        {
            return(RegEntry);
        }
        RegEntryList = RegEntryList->Flink;
    }
    return(NULL);
}

PREGENTRY WmipFindRegEntryByDevice(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN ReferenceIrp
    )
/*++

Routine Description:

    This routine will find a RegEntry that corresponds to the DeviceObject
    passed.

Arguments:

    DeviceObject is the device object that is the key for the RegEntry to find

    ReferenceIrp is TRUE then the Irp refcount will be incremented if a
        RegEntry is found for the device

Return Value:

    pointer to entry if available else NULL

--*/
{
    PREGENTRY RegEntry;

    PAGED_CODE();

    WmipEnterSMCritSection();

    RegEntry = WmipDoFindRegEntryByDevice(DeviceObject, REGENTRY_FLAG_RUNDOWN);
    if (RegEntry != NULL)
    {
        WmipReferenceRegEntry(RegEntry);
        if (ReferenceIrp)
        {
            InterlockedIncrement(&RegEntry->IrpCount);
        }
    }

    WmipLeaveSMCritSection();
    return(RegEntry);
}


void WmipDecrementIrpCount(
    IN PREGENTRY RegEntry
    )
/*++

Routine Description:

    This routine will decrement one from the active irp count for the
    regentry. If the active irp count reaches 0 and the flag is set that
    the device is waiting to be unloaded then the unload event is signalled
    so that the device can be unloaded.

Arguments:

    RegEntry is the registration entry for the device

Return Value:


--*/
{
    ULONG IrpCount;

    IrpCount = InterlockedDecrement(&RegEntry->IrpCount);
    if ((RegEntry->Flags & REGENTRY_FLAG_RUNDOWN) &&
        (IrpCount == 0))
    {
        //
        // If this is the last outstanding irp for the device and
        // the device is trying to unregister then set the event to
        // allow the deregister thread to continue.

        WmipAssert(RegEntry->Flags & REGENTRY_FLAG_NOT_ACCEPTING_IRPS);

        KeSetEvent(&RegEntry->Event,
                   0,
                   FALSE);

    }
}

NTSTATUS WmipPDOToDeviceInstanceName(
    IN PDEVICE_OBJECT PDO,
    OUT PUNICODE_STRING DeviceInstanceName
    )
/*++

Routine Description:

    This routine will return the device instance name that is associated with
    the PDO passed.

Arguments:

    PDO is the PDO whose device instance name is to be returned

    *DeviceInstanceName returns with the device instance name for the PDO.
        Note the string buffer must be freed.

Return Value:

    NT status ccode

--*/
{
#ifdef MEMPHIS
    DEVNODE DevNode;
    CHAR RegistryKeyName[255];
    ULONG Length = sizeof(RegistryKeyName);
    ANSI_STRING AnsiInstancePath;
#endif
    ULONG Status;

    PAGED_CODE();

#ifdef MEMPHIS
    DevNode = _NtKernPhysicalDeviceObjectToDevNode(PDO);
    if ((DevNode) &&
        (CM_Get_DevNode_Key(DevNode,
                            NULL,
                            &RegistryKeyName,
                            Length,
                            CM_REGISTRY_SOFTWARE) == CR_SUCCESS))
    {
        RtlInitAnsiString(&AnsiInstancePath, RegistryKeyName);
        Status = RtlAnsiStringToUnicodeString(DeviceInstanceName,
                                              &AnsiInstancePath,
                                              TRUE);
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                          DPFLTR_REGISTRATION_LEVEL,
                          "WMI: Error getting devnode key for PDO %x\n",
                 PDO));
        Status = STATUS_UNSUCCESSFUL;
    }
#else
    WmipAssert(PDO != NULL);
    Status = IoGetDeviceInstanceName(PDO, DeviceInstanceName);
#endif
    return(Status);
}

void WmipTranslatePDOInstanceNames(
    IN OUT PIRP Irp,
    IN UCHAR MinorFunction,
    IN ULONG MaxBufferSize,
    IN OUT PREGENTRY RegEntry
    )
/*++

Routine Description:

    This routine will check all REGGUID structures being returned from the
    data provider and convert any PDO instance name references to a
    static instance name reference.

Arguments:

    Irp points at the registration query irp

    MaxBufferSize is the maximum size that will fit into buffer

    RegEntry is registration structure for device being registered

Return Value:

--*/
{
    PUCHAR WmiRegInfoBase;
    PWMIREGINFO WmiRegInfo, WmiRegInfo2;
    PWMIREGGUID WmiRegGuid;
    PUCHAR FreeSpacePtr;
    ULONG FreeSpaceLeft = 0;
    ULONG i;
    BOOLEAN WmiRegInfoTooSmall = FALSE;
    PIO_STACK_LOCATION IrpStack;
    ULONG SizeNeeded;
    PDEVICE_OBJECT PDO = NULL, LastPDO = NULL, PnPIdPDO = NULL;
    UNICODE_STRING InstancePath;
    ULONG InstancePathLength;
    PVOID Buffer = Irp->AssociatedIrp.SystemBuffer;
    ULONG NextWmiRegInfo;
    ULONG Status;
    ULONG LastBaseNameOffset = 0;
    BOOLEAN AllowPnPIdMap = TRUE;
    ULONG ExtraRoom, MaxInstanceNames;
    PUCHAR FreeSpacePadPtr;
    ULONG PadSpace, FreeSpaceOffset;

    PAGED_CODE();

    WmiRegInfoBase = (PUCHAR)Buffer;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    FreeSpacePtr = NULL;
    SizeNeeded = (ULONG)((Irp->IoStatus.Information + 1) & 0xfffffffe);

    MaxInstanceNames = 0;

    WmiRegInfo = (PWMIREGINFO)WmiRegInfoBase;
    do
    {
        for (i = 0; i < WmiRegInfo->GuidCount;  i++)
        {
            WmiRegGuid = &WmiRegInfo->WmiRegGuid[i];

            //
            // If data provider already registers this guid then it overrides
            // any default mapping done here.
            if ((IsEqualGUID(&WmiRegGuid->Guid,
                             &WmipDataProviderPnpidGuid)) ||
                (IsEqualGUID(&WmiRegGuid->Guid,
                             &WmipDataProviderPnPIdInstanceNamesGuid)))
            {
                AllowPnPIdMap = FALSE;

                //
                // If we had remembered any PDO that is slated to be
                // used for PnPID mapping then make sure to deref it
                //
                if (PnPIdPDO != NULL)
                {
                    ObDereferenceObject(PnPIdPDO);
                    PnPIdPDO = NULL;
                }
            }

            if (WmiRegGuid->Flags & WMIREG_FLAG_INSTANCE_PDO)
            {               
                //
                // This instance name must be translated from PDO to
                // device instance name
                if (FreeSpacePtr == NULL)
                {
                    //
                    // Determine where any free space is in output buffer by
                    // figuring out where the last WmiRegInfo ends
                    WmiRegInfo2 = (PWMIREGINFO)WmiRegInfoBase;
                    while (WmiRegInfo2->NextWmiRegInfo != 0)
                    {
                        WmiRegInfo2 = (PWMIREGINFO)((PUCHAR)WmiRegInfo2 +
                                                 WmiRegInfo2->NextWmiRegInfo);
                    }
                    FreeSpacePtr = (PUCHAR)WmiRegInfo2 +
                                 ((WmiRegInfo2->BufferSize + 1) & 0xfffffffe);
                    FreeSpaceLeft = MaxBufferSize - (ULONG)(FreeSpacePtr - WmiRegInfoBase);

                }

                //
                // Keep track of the max number of instances for the PDO name
                MaxInstanceNames = MaxInstanceNames < WmiRegGuid->InstanceCount ?
                                            WmiRegGuid->InstanceCount :
                                            MaxInstanceNames;

                //
                // Get device instance name for the PDO
                PDO = (PDEVICE_OBJECT)WmiRegGuid->Pdo;
                if (PDO == LastPDO)
                {
                    WmiRegGuid->Flags |= WMIREG_FLAG_INSTANCE_BASENAME;
                    WmiRegGuid->BaseNameOffset = LastBaseNameOffset;
                } else {

                    Status = WmipPDOToDeviceInstanceName(PDO, &InstancePath);
                    if (NT_SUCCESS(Status))
                    {
                        if (AllowPnPIdMap &&
                            ((PnPIdPDO == NULL) || (PnPIdPDO == PDO)))
                        {
                            if (PnPIdPDO == NULL)
                            {
                                PnPIdPDO = PDO;
                                ObReferenceObject(PnPIdPDO);
                            }
                        } else {
                            //
                            // If the PDO value changes then we don't
                            // do any instance name stuff. In this case
                            // make sure we remove any ref on the PDO
                            //
                            AllowPnPIdMap = FALSE;
                            
                            if (PnPIdPDO != NULL)
                            {
                                ObDereferenceObject(PnPIdPDO);
                                PnPIdPDO = NULL;
                            }
                        }

                        InstancePathLength = InstancePath.Length +
                                              sizeof(USHORT) + sizeof(WCHAR);

                        SizeNeeded += InstancePathLength;
                        if ((WmiRegInfoTooSmall) ||
                            (InstancePathLength > FreeSpaceLeft))
                        {
                            WmiRegInfoTooSmall = TRUE;
                        } else {
                            WmiRegGuid->Flags |= WMIREG_FLAG_INSTANCE_BASENAME;

                            LastBaseNameOffset = (ULONG)(FreeSpacePtr - (PUCHAR)WmiRegInfo);
                            LastPDO = PDO;

                            WmiRegGuid->BaseNameOffset = LastBaseNameOffset;
                            (*(PUSHORT)FreeSpacePtr) = InstancePath.Length +
                                                          sizeof(WCHAR);
                            FreeSpacePtr +=  sizeof(USHORT);
                            RtlCopyMemory(FreeSpacePtr,
                                      InstancePath.Buffer,
                                      InstancePath.Length);
                             FreeSpacePtr += InstancePath.Length;
                             *((PWCHAR)FreeSpacePtr) = L'_';
                             FreeSpacePtr += sizeof(WCHAR);
                             FreeSpaceLeft -= InstancePathLength;
                        }
                    }

                    if (NT_SUCCESS(Status))
                    {
                        RtlFreeUnicodeString(&InstancePath);
                    }
                }

                if (MinorFunction == IRP_MN_REGINFO_EX)
                {
                    ObDereferenceObject(PDO);
                }
            }
        }
        LastPDO = NULL;
        NextWmiRegInfo = WmiRegInfo->NextWmiRegInfo;
        WmiRegInfo = (PWMIREGINFO)((PUCHAR)WmiRegInfo + NextWmiRegInfo);

    } while (NextWmiRegInfo != 0);

    //
    // If we can do automatic support for device information guid so add
    // registration for this guid to the registration information
    if (AllowPnPIdMap && (PnPIdPDO != NULL))
    {
        Status = WmipPDOToDeviceInstanceName(PDO, &InstancePath);
        if (NT_SUCCESS(Status))
        {
            //
            // Pad so that new WmiRegInfo starts on 8 byte boundry and
            // adjust free buffer size
            FreeSpacePadPtr = (PUCHAR)(((ULONG_PTR)FreeSpacePtr+7) & ~7);
            PadSpace = (ULONG)(FreeSpacePadPtr - FreeSpacePtr);
            FreeSpaceLeft -= PadSpace;
            FreeSpacePtr = FreeSpacePadPtr;

            //
            // Figure out how much space we will need to include extra guid
            InstancePathLength = InstancePath.Length +
                                 sizeof(USHORT) + sizeof(WCHAR);

            ExtraRoom = 2 * (InstancePathLength + sizeof(WMIREGGUID)) +
                          sizeof(WMIREGINFO);

            SizeNeeded += ExtraRoom + PadSpace;

            if ((WmiRegInfoTooSmall) ||
                (ExtraRoom > FreeSpaceLeft))
            {
                WmiRegInfoTooSmall = TRUE;
            } else {
                if (RegEntry->PDO == NULL)
                {
                    //
                    // If we haven't already established a PDO for this
                    // data provider then remember PDO and count of
                    // instance names for this device
                    // so we can get device properties
                    //
                    ObReferenceObject(PnPIdPDO);
                    RegEntry->PDO = PnPIdPDO;
                    RegEntry->MaxInstanceNames = MaxInstanceNames;

                    WmiRegInfo->NextWmiRegInfo = (ULONG)(FreeSpacePtr -
                                                         (PUCHAR)WmiRegInfo);

                    WmiRegInfo = (PWMIREGINFO)FreeSpacePtr;
                    FreeSpaceOffset = sizeof(WMIREGINFO) + 2*sizeof(WMIREGGUID);
                    FreeSpacePtr += FreeSpaceOffset;

                    RtlZeroMemory(WmiRegInfo, FreeSpaceOffset);
                    WmiRegInfo->BufferSize = ExtraRoom;
                    WmiRegInfo->GuidCount = 2;

                    WmiRegGuid = &WmiRegInfo->WmiRegGuid[0];
                    WmiRegGuid->Flags = WMIREG_FLAG_INSTANCE_BASENAME |
                                        WMIREG_FLAG_INSTANCE_PDO;
                    WmiRegGuid->InstanceCount = MaxInstanceNames;
                    WmiRegGuid->Guid = WmipDataProviderPnpidGuid;
                    WmiRegGuid->BaseNameOffset = FreeSpaceOffset;

                    (*(PUSHORT)FreeSpacePtr) = InstancePath.Length + sizeof(WCHAR);
                    FreeSpacePtr +=  sizeof(USHORT);
                    RtlCopyMemory(FreeSpacePtr,
                                  InstancePath.Buffer,
                                  InstancePath.Length);
                    FreeSpacePtr += InstancePath.Length;
                    *((PWCHAR)FreeSpacePtr) = L'_';
                    FreeSpacePtr += sizeof(WCHAR);
                    FreeSpaceOffset += sizeof(USHORT) +
                                       InstancePath.Length + sizeof(WCHAR);


                    WmiRegGuid = &WmiRegInfo->WmiRegGuid[1];
                    WmiRegGuid->Flags = WMIREG_FLAG_INSTANCE_LIST;
                    WmiRegGuid->InstanceCount = 1;
                    WmiRegGuid->Guid = WmipDataProviderPnPIdInstanceNamesGuid;
                    WmiRegGuid->BaseNameOffset = FreeSpaceOffset;

                    (*(PUSHORT)FreeSpacePtr) = InstancePath.Length;
                    FreeSpacePtr +=  sizeof(USHORT);
                    RtlCopyMemory(FreeSpacePtr,
                                  InstancePath.Buffer,
                                  InstancePath.Length);
                    FreeSpacePtr += InstancePath.Length;
                }

            }

            RtlFreeUnicodeString(&InstancePath);
        }

        ObDereferenceObject(PnPIdPDO);
    } else {
        WmipAssert(PnPIdPDO == NULL);
    }

    if (WmiRegInfoTooSmall)
    {
        *((PULONG)Buffer) = SizeNeeded;
        Irp->IoStatus.Information = sizeof(ULONG);
    } else {
        WmiRegInfo = (PWMIREGINFO)WmiRegInfoBase;
        WmiRegInfo->BufferSize = SizeNeeded;
        Irp->IoStatus.Information = SizeNeeded;
    }
}

NTSTATUS WmipValidateWmiRegInfoString(
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    ULONG Offset,
    PWCHAR *String
)
{
    PWCHAR s;

    PAGED_CODE();

    if ((Offset > BufferSize) || ((Offset & 1) != 0))
    {
        //
        // Offset is beyond bounds of buffer or is misaligned
        //
        return(STATUS_INVALID_PARAMETER);
    }

    if (Offset != 0)
    {
        s = (PWCHAR)OffsetToPtr(WmiRegInfo, Offset);
           if (*s + Offset > BufferSize)
        {
            //
               // string extends beyond end of buffer
            //
            return(STATUS_INVALID_PARAMETER);
        }
        *String = s;
    } else {
        //
        // Offset of 0 implies null string
        //
        *String = NULL;
    }

    return(STATUS_SUCCESS);
}

NTSTATUS WmipProcessWmiRegInfo(
    IN PREGENTRY RegEntry,
    IN PWMIREGINFO WmiRegInfo,
    IN ULONG BufferSize,
    IN PWMIGUIDOBJECT RequestObject,
    IN BOOLEAN Update,
    IN BOOLEAN IsUserMode
    )
/*+++

Routine Description:

    This routine will loop through all WMIREGINFO passed and verify the
    sizes and offsets are not out of bounds of the buffer. It will register
    the guids for each one. Note that if at least one of the WMIREGINFOs does
    register successfully then STATUS_SUCCESS is returned, but all
    WMIREGINFOs following the bad one are not registered.

Arguments:

    RegEntry is the RegEntry for the device or user mode object

    WmiRegInfo is the registration information to register

    BufferSize is the size of WmiRegInfo in bytes

    RequestObject is the request object associated with the UM provider.
        If this is NULL then the registration is for a driver

    Update is TRUE if this is a registration update

Return Value:

    STATUS_SUCCESS or an error code

---*/
{
    ULONG Linkage;
    NTSTATUS Status, FinalStatus;
    PWCHAR RegPath, ResourceName;
    ULONG GuidBufferSize;

    PAGED_CODE();

    FinalStatus = STATUS_INVALID_PARAMETER;

    do {
        //
        // First we validate that the WMIREGINFO looks correct
        //
        if (WmiRegInfo->BufferSize > BufferSize)
        {
            //
            // BufferSize specified in WmiRegInfo is beyond bounds of buffer
            //
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Validate registry path string
        //
        Status = WmipValidateWmiRegInfoString(WmiRegInfo,
                                              BufferSize,
                                              WmiRegInfo->RegistryPath,
                                              &RegPath);
        if (! NT_SUCCESS(Status))
        {
            break;
        }

        //
        // Validate resource name string
        //
        Status = WmipValidateWmiRegInfoString(WmiRegInfo,
                                              BufferSize,
                                              WmiRegInfo->MofResourceName,
                                              &ResourceName);
        if (! NT_SUCCESS(Status))
        {
            break;
        }

        //
        // Validate that the guid list fits within the bounds of the
        // buffer. Note that WmipAddDataSource verifies that the instance
        // names within each guid is within bounds.
        //
        GuidBufferSize = sizeof(WMIREGINFO) +
                          WmiRegInfo->GuidCount * sizeof(WMIREGGUID);
        if (GuidBufferSize > BufferSize)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Now call the core to parse the registration info and build
        // the data structures
        //
        if (Update)
        {
            //
            // CONSIDER: UM Code had held the critsect over all
            // WMIREGINFOs linked together
            //
            Status = WmipUpdateDataSource(RegEntry,
                                              WmiRegInfo,
                                              BufferSize);
#if DBG
            if (! NT_SUCCESS(Status))
            {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                  DPFLTR_REGISTRATION_LEVEL,
                                  "WMI: WmipUpdateDataSourceFailed %x for RegEntry %p\n",
                         Status, RegEntry));
            }
#endif
        } else {
            Status = WmipAddDataSource(RegEntry,
                                           WmiRegInfo,
                                           BufferSize,
                                           RegPath,
                                           ResourceName,
                                           RequestObject,
                                           IsUserMode);
        }

        if (NT_SUCCESS(Status))
        {
            //
            // if at least one of the registrations was added
            // successfully then the final status is success
            //
            FinalStatus = STATUS_SUCCESS;

        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                              DPFLTR_REGISTRATION_LEVEL,
                              "WMI: WmipAddDataSourceFailed %x for RegEntry %p\n",
                          Status, RegEntry));
        }

        Linkage = WmiRegInfo->NextWmiRegInfo;
        if (BufferSize >= (Linkage + sizeof(WMIREGINFO)))
        {
            //
            // There is enough room in the buffer for the next WMIREGINFO
            //
            WmiRegInfo = (PWMIREGINFO)((PUCHAR)WmiRegInfo + Linkage);
            BufferSize -= Linkage;
        } else {
            //
            // There is not enough room in buffer for next WMIREGINFO
            //
            break;
        }

    } while (Linkage != 0);

    return(FinalStatus);
}

//
// This defines the initial value of the buffer passed to each data provider
// to retrieve the registration information
#if DBG
#define INITIALREGINFOSIZE sizeof(WNODE_TOO_SMALL)
#else
#define INITIALREGINFOSIZE 8192
#endif

NTSTATUS WmipRegisterOrUpdateDS(
    PREGENTRY RegEntry,
    BOOLEAN Update
    )
{
    PUCHAR Buffer;
    IO_STATUS_BLOCK IoStatus;
    ULONG SizeNeeded;
    NTSTATUS Status;

    PAGED_CODE();

    IoStatus.Information = 0;

    //
    // Call the driver to get the registration information
    //
    SizeNeeded = INITIALREGINFOSIZE;
    do
    {
        Buffer = ExAllocatePoolWithTag(NonPagedPool, SizeNeeded,
                                       WmipRegisterDSPoolTag);
        if (Buffer != NULL)
        {
            //
            // First send IRP_MN_REGINFO_EX to see if we've got
            // a sophisticated client
            //
            Status = WmipSendWmiIrp(IRP_MN_REGINFO_EX,
                                    RegEntry->ProviderId,
                                    UlongToPtr(Update ?
                                                  WMIUPDATE :
                                                  WMIREGISTER),
                                    SizeNeeded,
                                    Buffer,
                                    &IoStatus);
                                                  
            if ((! NT_SUCCESS(Status)) &&
                (Status != STATUS_BUFFER_TOO_SMALL))
            {
                //
                // If IRP_MN_REGINFO_EX doesn't work then try our old
                // reliable IRP_MN_REGINFO
                //
                Status = WmipSendWmiIrp(IRP_MN_REGINFO,
                                        RegEntry->ProviderId,
                                        UlongToPtr(Update ?
                                                      WMIUPDATE :
                                                      WMIREGISTER),
                                        SizeNeeded,
                                        Buffer,
                                        &IoStatus);
            }

            if ((Status == STATUS_BUFFER_TOO_SMALL) ||
                (IoStatus.Information == sizeof(ULONG)))
            {
                //
                // if the buffer was too small then get the size we need
                // for the registration info and try again
                //
                SizeNeeded = *((PULONG)Buffer);
                ExFreePool(Buffer);
                Status = STATUS_BUFFER_TOO_SMALL;
            }

        } else {
            //
            // CONSIDER: retry this later to see if we can get more memory
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } while (Status == STATUS_BUFFER_TOO_SMALL);

    //
    // If registration info irp was successful then go process registration
    // information
    //
    if (NT_SUCCESS(Status))
    {
        Status = WmipProcessWmiRegInfo(RegEntry,
                                       (PWMIREGINFO)Buffer,
                                       (ULONG)IoStatus.Information,
                                       NULL,
                                       Update,
                                       FALSE);
    }

    if (Buffer != NULL)
    {
        ExFreePool(Buffer);
    }

    return(Status);
}


NTSTATUS WmipUpdateDS(
    PREGENTRY RegEntry
    )
{
    PAGED_CODE();

    return(WmipRegisterOrUpdateDS(RegEntry,
                                  TRUE));
}

NTSTATUS WmipRegisterDS(
    PREGENTRY RegEntry
)
{
    PAGED_CODE();

    return(WmipRegisterOrUpdateDS(RegEntry,
                                  FALSE));
}

void WmipRemoveDS(
    PREGENTRY RegEntry
)
{
    PAGED_CODE();

    WmipRemoveDataSource(RegEntry);
}


void WmipRegistrationWorker(
    PVOID Context
   )
{
    PREGISTRATIONWORKITEM RegWork;
    ULONG RegWorkCount;
    NTSTATUS Status;
    PLIST_ENTRY RegWorkList;
    PREGENTRY RegEntry;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Context);

    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                       DPFLTR_REGISTRATION_LEVEL,
                       "WMI: Registration Worker active, WmipRegWorkItemCount %d\n",
                       WmipRegWorkItemCount
                      ));
    
    WmipAssert(WmipRegWorkItemCount > 0);

    //
    // Synchronize with PnP.
    //
    IoControlPnpDeviceActionQueue(TRUE);

    do
    {
        WmipEnterSMCritSection();
        WmipAssert(! IsListEmpty(&WmipRegWorkList));
        RegWorkList = RemoveHeadList(&WmipRegWorkList);
        WmipLeaveSMCritSection();
        RegWork = CONTAINING_RECORD(RegWorkList,
                                    REGISTRATIONWORKITEM,
                                    ListEntry);

        RegEntry = RegWork->RegEntry;

        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                           DPFLTR_REGISTRATION_LEVEL,
                           "WMI: RegWorker %p for RegEntry %p active, RegOperation %d\n",
                           RegWork,
                           RegEntry,
                           RegWork->RegOperation
                          ));
        
        switch(RegWork->RegOperation)
        {
            case RegisterSingleDriver:
            {
                Status = WmipRegisterDS(RegEntry);
                if (NT_SUCCESS(Status))
                {
                    //
                    // Mark regentry as fully registered so now we can start
                    // accepting unregister calls
                    //
                    RegEntry->Flags &= ~REGENTRY_FLAG_REG_IN_PROGRESS;
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                      DPFLTR_REGISTRATION_LEVEL,
                                      "WMI: WmipRegisterDS(%p) succeeded for device %p\n",
                                      RegEntry,
                                      RegEntry->DeviceObject));
                } else {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                      DPFLTR_REGISTRATION_LEVEL,
                                      "WMI: WmipRegisterDS(%p) failed %x for device %p\n",
                                      RegEntry,
                                      Status,
                                      RegEntry->DeviceObject));
                    // CONSIDER: Do we remove regentry ??
                }
                //
                // Remove ref when work item was queued
                //
                WmipUnreferenceRegEntry(RegEntry);

                break;
            }

            case RegisterUpdateSingleDriver:
            {
                Status = WmipUpdateDS(RegEntry);
                if (! NT_SUCCESS(Status))
                {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                      DPFLTR_REGISTRATION_LEVEL,
                                      "WMI: WmipUpdateDS(%p) failed %x for device %p\n",
                                      RegEntry, Status, RegEntry->DeviceObject));
                } else {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                                      DPFLTR_REGISTRATION_LEVEL,
                                      "WMI: WmipUpdateDS(%p) succeeded for device %p\n",
                                      RegEntry,
                                      RegEntry->DeviceObject));
                }

                //
                // Remove ref when work item was queued
                //
                WmipUnreferenceRegEntry(RegEntry);
                break;
            }

            default:
            {
                WmipAssert(FALSE);
            }
        }
        WmipFree(RegWork);

        RegWorkCount = InterlockedDecrement(&WmipRegWorkItemCount);
    } while (RegWorkCount != 0);
    
    IoControlPnpDeviceActionQueue(FALSE);

    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                      DPFLTR_REGISTRATION_LEVEL,
                      "WMI: RegWork completed WmipRegWorkItemCount %d\n",
                      WmipRegWorkItemCount
                     ));
}

NTSTATUS WmipQueueRegWork(
    REGOPERATION RegOperation,
    PREGENTRY RegEntry
    )
{
    PREGISTRATIONWORKITEM RegWork;
    NTSTATUS Status;

    PAGED_CODE();

    WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                       DPFLTR_REGISTRATION_LEVEL,
                       "WMI: WmipQueueRegWork RegEntry %p REGOPERATION %x\n",
                       RegEntry,
                       RegOperation
                      ));
    
    RegWork = (PREGISTRATIONWORKITEM)WmipAlloc(sizeof(REGISTRATIONWORKITEM));
    if (RegWork != NULL)
    {
        //
        // Take an extra ref on the RegEntry which will be freed
        // after the work item is processed
        //
        WmipReferenceRegEntry(RegEntry);
        RegWork->RegOperation = RegOperation;
        RegWork->RegEntry = RegEntry;

        WmipEnterSMCritSection();
        InsertTailList(&WmipRegWorkList,
                       &RegWork->ListEntry);
        WmipLeaveSMCritSection();

        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                           DPFLTR_REGISTRATION_LEVEL,
                           "WMI: REGWORK %p for RegEntry %p inserted in list\n",
                           RegWork,
                           RegEntry
                          ));
        
        if (InterlockedIncrement(&WmipRegWorkItemCount) == 1)
        {
            //
            // If the list is transitioning from empty to non empty
            // then we need to fire up the worker thread to process
            //
            ExQueueWorkItem(&WmipRegWorkQueue, DelayedWorkQueue);
            
            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                               DPFLTR_REGISTRATION_LEVEL,
                               "WMI: ReQorkQueue %p kicked off WmipRegWorkItemCount %d\n",
                               WmipRegWorkQueue,
                               WmipRegWorkItemCount
                              ));
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                               DPFLTR_REGISTRATION_LEVEL,
                               "WMI: ReQorkQueue %p already active WmipRegWorkItemCount %d\n",
                               WmipRegWorkQueue,
                               WmipRegWorkItemCount
                              ));
        }
        Status = STATUS_SUCCESS;

        //
        // RegWork will be freed by the work item processing
        //
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID,
                           DPFLTR_REGISTRATION_LEVEL,
                           "WMI: Couldn not alloc REGWORK for RegEntry %p\n",
                           RegEntry
                          ));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status);
}

#if defined(_WIN64)
ULONG IoWMIDeviceObjectToProviderId(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine will lookup the provider id that corresponds with the
    device object passed.

Arguments:

Return Value:

    Returns provider id for device object

--*/
{
    PREGENTRY RegEntry;
    ULONG ProviderId;
    KIRQL OldIrql;

    KeAcquireSpinLock(&WmipRegistrationSpinLock,
                     &OldIrql);
    
    RegEntry = WmipDoFindRegEntryByDevice(DeviceObject,
                                         REGENTRY_FLAG_RUNDOWN);
    
    if (RegEntry != NULL)
    {
        ProviderId = RegEntry->ProviderId;
    } else {
        ProviderId = 0;
    }
    
    KeReleaseSpinLock(&WmipRegistrationSpinLock,
                      OldIrql);
    
    return(ProviderId);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\secure.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    Secure.c

Abstract:

    Security implementation for WMI objects

    WMI security is guid based, that is each guid can be assigned a security
    descriptor. There is also a default security descriptor that applies
    to any guid that does not have its own specific security descriptor.
    Security is enforced by relying upon the object manager. We define the
    WmiGuid object type and require all WMI requests to have a handle to the
    WmiGuid object. In this way the guid is opened with a specific ACCESS_MASK
    and if the caller is permitted those rights (as specified in the specific
    or default security descriptor) then a handle is returned. When the
    caller wants to do an operation he must pass the handle and before the
    operation is performed we check that the handle has the allowed access.

    Guid security descriptors are serialized as REG_BINARY values under the
    registry key HKLM\CurrentControlSet\Control\Wmi\Security. If no specific
    or default security descriptor for a guid exists then the all access
    is available for anyone. For this reason this registry key must be
    protected.

    WMI implements its own security method for the WmiGuid object type to
    allow it to intercept any changes to an objects security descriptor. By
    doing this we allow the standard security apis
    (Get/SetKernelObjectSecurity) to query and set the WMI security
    descriptors.

    A guid security descriptor contains the following specific rights:

        WMIGUID_QUERY                 0x0001
        WMIGUID_SET                   0x0002
        WMIGUID_NOTIFICATION          0x0004
        WMIGUID_READ_DESCRIPTION      0x0008
        WMIGUID_EXECUTE               0x0010
        TRACELOG_CREATE_REALTIME      0x0020
        TRACELOG_CREATE_ONDISK        0x0040
        TRACELOG_GUID_ENABLE          0x0080
        TRACELOG_ACCESS_KERNEL_LOGGER 0x0100


    Security is only implemented for NT and not MEMPHIS

Author:

    AlanWar

Environment:

    Kernel mode

Revision History:


--*/

#ifndef MEMPHIS

#include "strsafe.h"
#include "wmikmp.h"

NTSTATUS
WmipSecurityMethod (
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

VOID WmipDeleteMethod(
    IN  PVOID   Object
    );

VOID WmipCloseMethod(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    );

NTSTATUS
WmipSaveGuidSecurityDescriptor(
    PUNICODE_STRING GuidName,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
WmipSDRegistryQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
WmipCreateGuidObject(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN LPGUID Guid,
    OUT PHANDLE CreatorHandle,
    OUT PWMIGUIDOBJECT *Object
    );

NTSTATUS
WmipUuidFromString (
    IN PWCHAR StringUuid,
    OUT LPGUID Uuid
    );

BOOLEAN
WmipHexStringToDword(
    IN PWCHAR lpsz,
    OUT PULONG RetValue,
    IN ULONG cDigits,
    IN WCHAR chDelim
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WmipInitializeSecurity)
#pragma alloc_text(INIT,WmipCreateAdminSD)

#pragma alloc_text(PAGE,WmipGetGuidSecurityDescriptor)
#pragma alloc_text(PAGE,WmipSaveGuidSecurityDescriptor)
#pragma alloc_text(PAGE,WmipOpenGuidObject)
#pragma alloc_text(PAGE,WmipCheckGuidAccess)
#pragma alloc_text(PAGE,WmipSDRegistryQueryRoutine)
#pragma alloc_text(PAGE,WmipSecurityMethod)
#pragma alloc_text(PAGE,WmipDeleteMethod)
#pragma alloc_text(PAGE,WmipCreateGuidObject)
#pragma alloc_text(PAGE,WmipUuidFromString)
#pragma alloc_text(PAGE,WmipHexStringToDword)
#pragma alloc_text(PAGE,WmipCloseMethod)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#pragma data_seg("PAGEDATA")
#endif
//
// Subject context for the System process, captured at boot
SECURITY_SUBJECT_CONTEXT WmipSystemSubjectContext;

//
// Object type object created by Ob when registering WmiGuid object type
POBJECT_TYPE WmipGuidObjectType;

//
// SD attached to a guid when no specific or default SD exists in the
// registry. Created at boot, it allows all WMI access to WORLD and full
// access to System and Administrators group.
SECURITY_DESCRIPTOR WmipDefaultAccessSecurityDescriptor;
PSECURITY_DESCRIPTOR WmipDefaultAccessSd;

//
// Generic mapping for specific rights
const GENERIC_MAPPING WmipGenericMapping =
{
                                  // GENERIC_READ <--> WMIGUID_QUERY
        WMIGUID_QUERY,
                                  // GENERIC_WRUTE <--> WMIGUID_SET
        WMIGUID_SET,
                                  // GENERIC_EXECUTE <--> WMIGUID_EXECUTE
        WMIGUID_EXECUTE,
    WMIGUID_ALL_ACCESS | STANDARD_RIGHTS_READ
};


NTSTATUS
WmipSecurityMethod (
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This is the WMI security method for objects.  It is responsible
    for either retrieving, setting, and deleting the security descriptor of
    an object.  It is not used to assign the original security descriptor
    to an object (use SeAssignSecurity for that purpose).


    IT IS ASSUMED THAT THE OBJECT MANAGER HAS ALREADY DONE THE ACCESS
    VALIDATIONS NECESSARY TO ALLOW THE REQUESTED OPERATIONS TO BE PERFORMED.

    This code stolen directly from SeDefaultObjectMethod in
    \nt\private\ntos\se\semethod.c. It does not do anything special except
    serialize any SD that is being set for an object.

Arguments:

    Object - Supplies a pointer to the object being used.

    OperationCode - Indicates if the operation is for setting, querying, or
        deleting the object's security descriptor.

    SecurityInformation - Indicates which security information is being
        queried or set.  This argument is ignored for the delete operation.

    SecurityDescriptor - The meaning of this parameter depends on the
        OperationCode:

        QuerySecurityDescriptor - For the query operation this supplies the
            buffer to copy the descriptor into.  The security descriptor is
            assumed to have been probed up to the size passed in in Length.
            Since it still points into user space, it must always be
            accessed in a try clause in case it should suddenly disappear.

        SetSecurityDescriptor - For a set operation this supplies the
            security descriptor to copy into the object.  The security
            descriptor must be captured before this routine is called.

        DeleteSecurityDescriptor - It is ignored when deleting a security
            descriptor.

        AssignSecurityDescriptor - For assign operations this is the
            security descriptor that will be assigned to the object.
            It is assumed to be in kernel space, and is therefore not
            probed or captured.

    CapturedLength - For the query operation this specifies the length, in
        bytes, of the security descriptor buffer, and upon return contains
        the number of bytes needed to store the descriptor.  If the length
        needed is greater than the length supplied the operation will fail.
        It is ignored in the set and delete operation.

        This parameter is assumed to be captured and probed as appropriate.

    ObjectsSecurityDescriptor - For the Set operation this supplies the address
        of a pointer to the object's current security descriptor.  This routine
        will either modify the security descriptor in place or allocate a new
        security descriptor and use this variable to indicate its new location.
        For the query operation it simply supplies the security descriptor
        being queried.  The caller is responsible for freeing the old security
        descriptor.

    PoolType - For the set operation this specifies the pool type to use if
        a new security descriptor needs to be allocated.  It is ignored
        in the query and delete operation.

        the mapping of generic to specific/standard access types for the object
        being accessed.  This mapping structure is expected to be safe to
        access (i.e., captured if necessary) prior to be passed to this routine.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the operation is successful and an
        appropriate error status otherwise.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    //
    // If the object's security descriptor is null, then object is not
    // one that has security information associated with it.  Return
    // an error.
    //

    //
    //  Make sure the common parts of our input are proper
    //

    ASSERT( (OperationCode == SetSecurityDescriptor) ||
            (OperationCode == QuerySecurityDescriptor) ||
            (OperationCode == AssignSecurityDescriptor) ||
            (OperationCode == DeleteSecurityDescriptor) );

    //
    //  This routine simply cases off of the operation code to decide
    //  which support routine to call
    //

    switch (OperationCode) {

        case SetSecurityDescriptor:
        {
            UNICODE_STRING GuidName;
            WCHAR GuidBuffer[38];
            LPGUID Guid;
            SECURITY_INFORMATION LocalSecInfo;
            PSECURITY_DESCRIPTOR SecurityDescriptorCopy;
            ULONG SecurityDescriptorLength;
            NTSTATUS Status2;

            ASSERT( (PoolType == PagedPool) || (PoolType == NonPagedPool) );

            Status = ObSetSecurityDescriptorInfo( Object,
                                            SecurityInformation,
                                            SecurityDescriptor,
                                            ObjectsSecurityDescriptor,
                                            PoolType,
                                            GenericMapping
                                            );

            if (NT_SUCCESS(Status))
            {
                //
                // Serialize the guid's new security descriptor in
                // the registry. But first we need to get a copy of
                // it.

                SecurityDescriptorLength = 1024;
                do
                {
                    SecurityDescriptorCopy = ExAllocatePoolWithTag(
                                                            PoolType,
                                                            SecurityDescriptorLength,
                                                            WMIPOOLTAG);

                    if (SecurityDescriptorCopy == NULL)
                    {
                        Status2 = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                    LocalSecInfo = 0xffffffff;
                    Status2 = ObQuerySecurityDescriptorInfo( Object,
                                                             &LocalSecInfo,
                                                             SecurityDescriptorCopy,
                                                             &SecurityDescriptorLength,
                                                             ObjectsSecurityDescriptor);


                    if (Status2 == STATUS_BUFFER_TOO_SMALL)
                    {
                        ExFreePool(SecurityDescriptorCopy);
                    } else {
                        break;
                    }

                } while (TRUE);


                if (NT_SUCCESS(Status2))
                {
                    Guid = &((PWMIGUIDOBJECT)Object)->Guid;
                    StringCbPrintf(GuidBuffer,
                                   sizeof(GuidBuffer),
                          L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                         Guid->Data1, Guid->Data2,
                         Guid->Data3,
                         Guid->Data4[0], Guid->Data4[1],
                         Guid->Data4[2], Guid->Data4[3],
                         Guid->Data4[4], Guid->Data4[5],
                         Guid->Data4[6], Guid->Data4[7]);

                    RtlInitUnicodeString(&GuidName, GuidBuffer);

                    WmipSaveGuidSecurityDescriptor(&GuidName,
                                               SecurityDescriptorCopy);
                }

                if (SecurityDescriptorCopy != NULL)
                {
                    ExFreePool(SecurityDescriptorCopy);
                }

            }

            return(Status);
        }



    case QuerySecurityDescriptor:
    {

        //
        //  check the rest of our input and call the default query security
        //  method
        //

        ASSERT( CapturedLength != NULL );


        return ObQuerySecurityDescriptorInfo( Object,
                                              SecurityInformation,
                                              SecurityDescriptor,
                                              CapturedLength,
                                              ObjectsSecurityDescriptor );
    }

    case DeleteSecurityDescriptor:
    {

        //
        //  call the default delete security method
        //

        Status = ObDeassignSecurity(ObjectsSecurityDescriptor);
        return(Status);
    }

    case AssignSecurityDescriptor:

        ObAssignObjectSecurityDescriptor( Object,
                                          SecurityDescriptor,
                                          PoolType );
        return( STATUS_SUCCESS );

    default:

        //
        //  Bugcheck on any other operation code,  We won't get here if
        //  the earlier asserts are still checked.
        //

        KeBugCheckEx( SECURITY_SYSTEM, 1, (ULONG_PTR) STATUS_INVALID_PARAMETER, 0, 0 );
    }

}


NTSTATUS WmipInitializeSecurity(
    void
    )
/*++

Routine Description:

    This routine will initialize WMI security subsystem. Basically we
    create the WMIGUID object type, obtain the SECURITY_SUBJECT_CONTEXT for
    the System process and establish a SD that allows all access that is used
    when no default or specific SD is assigned to a guid.

Arguments:

Return Value:

    NT Status code

--*/

{
    NTSTATUS Status;
    UNICODE_STRING ObjectTypeName;
    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    ULONG DaclLength;
    PACL DefaultAccessDacl;

    PAGED_CODE();

    //
    // Establish a SD for those guids with no specific or default SD
    DaclLength = (ULONG)sizeof(ACL) +
                   (5*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                   SeLengthSid( SeLocalSystemSid ) +
                   SeLengthSid( SeExports->SeLocalServiceSid ) +
                   SeLengthSid( SeExports->SeNetworkServiceSid ) +
                   SeLengthSid( SeAliasAdminsSid ) +
                   SeLengthSid( SeAliasUsersSid ) +
                   8; // The 8 is just for good measure


    DefaultAccessDacl = (PACL)ExAllocatePoolWithTag(PagedPool,
                                                   DaclLength,
                                                   WMIPOOLTAG);
    if (DefaultAccessDacl == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = RtlCreateAcl( DefaultAccessDacl,
                           DaclLength,
                           ACL_REVISION2);
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlAddAccessAllowedAce (
                 DefaultAccessDacl,
                 ACL_REVISION2,
                 (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                 SeLocalSystemSid
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlAddAccessAllowedAce (
                 DefaultAccessDacl,
                 ACL_REVISION2,
                 TRACELOG_REGISTER_GUIDS,
                 SeAliasUsersSid
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlAddAccessAllowedAce (
                 DefaultAccessDacl,
                 ACL_REVISION2,
                 (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL | ACCESS_SYSTEM_SECURITY),
                 SeAliasAdminsSid
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = RtlAddAccessAllowedAce (
                 DefaultAccessDacl,
                 ACL_REVISION2,
                 (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                 SeExports->SeLocalServiceSid
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = RtlAddAccessAllowedAce (
                 DefaultAccessDacl,
                 ACL_REVISION2,
                 (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL),
                 SeExports->SeNetworkServiceSid
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    WmipDefaultAccessSd = &WmipDefaultAccessSecurityDescriptor;
    Status = RtlCreateSecurityDescriptor(
                 WmipDefaultAccessSd,
                 SECURITY_DESCRIPTOR_REVISION1
                 );

    Status = RtlSetDaclSecurityDescriptor(
                 WmipDefaultAccessSd,
                 TRUE,                       // DaclPresent
                 DefaultAccessDacl,
                 FALSE                       // DaclDefaulted
                 );
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlSetOwnerSecurityDescriptor(WmipDefaultAccessSd,
                                           SeAliasAdminsSid,
                                           FALSE);
    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = RtlSetGroupSecurityDescriptor(WmipDefaultAccessSd,
                                           SeAliasAdminsSid,
                                           FALSE);
    if (! NT_SUCCESS(Status))
    {
Cleanup:
        ExFreePool(DefaultAccessDacl);
        WmipDefaultAccessSd = NULL;
        return(Status);
    }

    //
    // Remember System process subject context
    SeCaptureSubjectContext(&WmipSystemSubjectContext);

    //
    // Establish WmiGuid object type
    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));

    ObjectTypeInitializer.Length = sizeof(OBJECT_TYPE_INITIALIZER);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = WmipGenericMapping;
    ObjectTypeInitializer.ValidAccessMask = WMIGUID_ALL_ACCESS | STANDARD_RIGHTS_ALL;

    //
    // All named objects may (must ?) have security descriptors attached
    // to them. If unnamed objects also must have security descriptors
    // attached then this must be TRUE
    ObjectTypeInitializer.SecurityRequired = TRUE;

    //
    // Tracks # handles open for object within a process
    ObjectTypeInitializer.MaintainHandleCount = FALSE;

    //
    // Need to be in non paged pool since KEVENT contained within the
    // object must be in non paged pool
    //
    ObjectTypeInitializer.PoolType = NonPagedPool;

    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(WMIGUIDOBJECT);

    //
    // Use a custom security procedure so that we can serialize any
    // changes to the security descriptor.
    ObjectTypeInitializer.SecurityProcedure = WmipSecurityMethod;

    //
    // We need to know when an object is being deleted
    //
    ObjectTypeInitializer.DeleteProcedure = WmipDeleteMethod;
    ObjectTypeInitializer.CloseProcedure = WmipCloseMethod;
    RtlInitUnicodeString(&ObjectTypeName, L"WmiGuid");

    Status = ObCreateObjectType(&ObjectTypeName,
                                &ObjectTypeInitializer,
                                NULL,
                                &WmipGuidObjectType);

    if (! NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    return(Status);
}

NTSTATUS WmipSDRegistryQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    Registry query values callback routine for reading SDs for guids

Arguments:

    ValueName - the name of the value

    ValueType - the type of the value

    ValueData - the data in the value (unicode string data)

    ValueLength - the number of bytes in the value data

    Context - Not used

    EntryContext - Pointer to PSECURITTY_DESCRIPTOR to store a pointer to
        store the security descriptor read from the registry value

Return Value:

    NT Status code

--*/
{
    PSECURITY_DESCRIPTOR *SecurityDescriptor;
    NTSTATUS Status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Context);
    UNREFERENCED_PARAMETER (ValueName);

    Status = STATUS_SUCCESS;
    if ((ValueType == REG_BINARY) &&
        (ValueData != NULL))
    {
        //
        // If a SD is specified in the registry then verify that it is
        // valid and if so then copy it
        //
        if (SeValidSecurityDescriptor(ValueLength,
                                      (PSECURITY_DESCRIPTOR)ValueData))
        {
            SecurityDescriptor = (PSECURITY_DESCRIPTOR *)EntryContext;
            *SecurityDescriptor = ExAllocatePoolWithTag(PagedPool,
                                                        ValueLength,
                                WMIPOOLTAG);
            if (*SecurityDescriptor != NULL)
            {
                RtlCopyMemory(*SecurityDescriptor,
                              ValueData,
                              ValueLength);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }
    return(Status);
}

NTSTATUS WmipSaveGuidSecurityDescriptor(
    PUNICODE_STRING GuidName,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

    This routine will serialize the security descriptor associated with a
    guid.

    Security descriptors are maintained as REG_BINARY values named by the guid
    in the registry under
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Wmi\Security

Arguments:

    GuidName is a pointer to a unicode string that represents the guid

    SecurityDescriptor points at a self relative security descriptor

Return Value:

    NT Status code

--*/
{
    ULONG SecurityDescriptorLength;
    NTSTATUS Status;

    PAGED_CODE();

    SecurityDescriptorLength = RtlLengthSecurityDescriptor(SecurityDescriptor);
    Status = RtlWriteRegistryValue(RTL_REGISTRY_CONTROL,
                              L"WMI\\Security",
                              GuidName->Buffer,
                              REG_BINARY,
                              SecurityDescriptor,
                              SecurityDescriptorLength);

    return(Status);
}

NTSTATUS WmipGetGuidSecurityDescriptor(
    IN PUNICODE_STRING GuidName,
    IN PSECURITY_DESCRIPTOR *SecurityDescriptor,
    IN PSECURITY_DESCRIPTOR UserDefaultSecurity
    )
/*++

Routine Description:

    This routine will retrieve the security descriptor associated with a
    guid. First it looks for a security descriptor specifically for the
    guid and if not found then looks for the default security descriptor.

    Security descriptors are maintained as REG_BINARY values named by the guid
    in the registry under
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Wmi\Security

Arguments:

    GuidName is a pointer to a unicode string that represents the guid

    *SecurityDescriptor returns the security descriptor for the guid. It
    must be freed back to pool unless it is the same value as that in
    WmipDefaultAccessSd which must NOT be freed.

Return Value:

    NT Status code

--*/
{
    RTL_QUERY_REGISTRY_TABLE QueryRegistryTable[3];
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR GuidSecurityDescriptor = NULL;
    PSECURITY_DESCRIPTOR DefaultSecurityDescriptor = NULL;

    PAGED_CODE();

    RtlZeroMemory(QueryRegistryTable, sizeof(QueryRegistryTable));

    QueryRegistryTable[0].QueryRoutine = WmipSDRegistryQueryRoutine;
    QueryRegistryTable[0].EntryContext = &GuidSecurityDescriptor;
    QueryRegistryTable[0].Name = GuidName->Buffer;
    QueryRegistryTable[0].DefaultType = REG_BINARY;

    QueryRegistryTable[1].QueryRoutine = WmipSDRegistryQueryRoutine;
    QueryRegistryTable[1].Flags = 0;
    QueryRegistryTable[1].EntryContext = &DefaultSecurityDescriptor;
    QueryRegistryTable[1].Name = DefaultSecurityGuidName;
    QueryRegistryTable[1].DefaultType = REG_BINARY;

    Status = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL,
                              L"WMI\\Security",
                              QueryRegistryTable,
                              NULL,
                              NULL);

    *SecurityDescriptor = NULL;
    if (NT_SUCCESS(Status))
    {
        //
        // If there is a guid specific SD then choose that and free any
        // default SD. Else we use the default SD unless that doesn't
        // exist and so there is no security
        if (GuidSecurityDescriptor != NULL)
        {
            *SecurityDescriptor = GuidSecurityDescriptor;
            if (DefaultSecurityDescriptor != NULL)
            {
                ExFreePool(DefaultSecurityDescriptor);
            }
        } else if (DefaultSecurityDescriptor != NULL) {
            *SecurityDescriptor = DefaultSecurityDescriptor;
        }
    }

    if (*SecurityDescriptor == NULL)
    {
        if (UserDefaultSecurity == NULL)
        {
            //
            // If the caller didn't provide a default, use the generic default
            //
            UserDefaultSecurity = WmipDefaultAccessSd;
        }
        //
        // Set the default security if none was found in the registry for
        // the Guid
        //
        *SecurityDescriptor = UserDefaultSecurity;
    }

    return(STATUS_SUCCESS);
}


NTSTATUS WmipOpenGuidObject(
    IN POBJECT_ATTRIBUTES CapturedObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN KPROCESSOR_MODE AccessMode,
    OUT PHANDLE Handle,
    OUT PWMIGUIDOBJECT *ObjectPtr
    )
/*++

Routine Description:

    This routine will open a handle to a WmiGuid object with the access rights
    specified. WmiGuid objects are temporary objects that are created on an
    as needed basis. We will always create a new unnamed guid object each time
    a guid is opened.

Arguments:

    GuidString is the string representation for the guid that refers to
        the object to open. Note that this parameter has NOT been probed.
         Parse UUID such as \WmiGuid\00000000-0000-0000-0000-000000000000

    DesiredAccess specifies the access requested

    *Handle returns a handle to the guid object

    *ObjectPtr returns containing a pointer to the object. This object
        will have a reference attached to it that must be derefed by
        the calling code.

Return Value:

    NT Status code

--*/
{
    NTSTATUS Status;
    GUID Guid;
    PWMIGUIDOBJECT GuidObject;
    HANDLE CreatorHandle;
    PUNICODE_STRING CapturedGuidString;

    PAGED_CODE();

    //
    // Validate guid object name passed by insuring that it is in the
    // correct object directory and the correct format for a uuid
    CapturedGuidString = CapturedObjectAttributes->ObjectName;

    if (RtlEqualMemory(CapturedGuidString->Buffer,
                         WmiGuidObjectDirectory,
                         (WmiGuidObjectDirectoryLength-1) * sizeof(WCHAR)) == 0)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    Status = WmipUuidFromString(&CapturedGuidString->Buffer[WmiGuidGuidPosition], &Guid);
    if (! NT_SUCCESS(Status))
    {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid uuid format for guid object %ws\n", CapturedGuidString->Buffer));
        return(Status);
    }

    //
    // If it does not exist then create an object for the guid ....
    //
    Status = WmipCreateGuidObject(CapturedObjectAttributes,
                                  DesiredAccess,
                                  &Guid,
                                  &CreatorHandle,
                                  &GuidObject);

    if (NT_SUCCESS(Status))
    {
        //
        // .... and try again to open it
        //
        Status = ObOpenObjectByPointer(GuidObject,
                                       0,
                                       NULL,
                                       DesiredAccess,
                                       WmipGuidObjectType,
                                       AccessMode,
                                       Handle);

        if (! NT_SUCCESS(Status))
        {
            //
            // Remove extra ref count taken by ObInsertObject since we
            // are returning an error
            //
            ObDereferenceObject(GuidObject);
        }

        //
        // Make sure to close handle obtained in creating object. We
        // attach to the system process since the handle was created in
        // its handle table.
        //
        KeAttachProcess( &PsInitialSystemProcess->Pcb );
        ZwClose(CreatorHandle);
        KeDetachProcess( );
        *ObjectPtr = GuidObject;
    }

    return(Status);
}

NTSTATUS WmipCreateGuidObject(
    IN OUT POBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN LPGUID Guid,
    OUT PHANDLE CreatorHandle,
    OUT PWMIGUIDOBJECT *Object
    )
/*++

Routine Description:

    This routine will create a new guid object for
    the guid passed. The handle returned is the handle issued to the creator
    of the object and should be closed after the object is opened.

    Guid Objects are created on the fly, but

Arguments:

    ObjectAttributes - Describes object being created. ObjectAttributes
                       is modified in this call.

    Guid is the guid for which the object is being created

    *CreatorHandle returns a handle to the created guid object. This handle
        is in the system process handle table

    *Object returns with a pointer to the object

Return Value:

    NT Status code

--*/
{
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    UNICODE_STRING UnicodeString;
    WCHAR *ObjectNameBuffer;
    WCHAR *GuidBuffer;
    NTSTATUS Status;
    ACCESS_STATE LocalAccessState;
    AUX_ACCESS_DATA AuxData;
    SECURITY_SUBJECT_CONTEXT SavedSubjectContext;
    PSECURITY_SUBJECT_CONTEXT SubjectContext;
    PWMIGUIDOBJECT NewObject;
    OBJECT_ATTRIBUTES UnnamedObjectAttributes;

    PAGED_CODE();

    ObjectNameBuffer = ObjectAttributes->ObjectName->Buffer;
    GuidBuffer = &ObjectNameBuffer[WmiGuidGuidPosition];
    RtlInitUnicodeString(&UnicodeString, GuidBuffer);

    //
    // Obtain security descriptor associated with the guid
    Status = WmipGetGuidSecurityDescriptor(&UnicodeString,
                                           &SecurityDescriptor, NULL);

    if (NT_SUCCESS(Status))
    {
        WmipAssert(SecurityDescriptor != NULL);

        //
        // Establish ObjectAttributes for the newly created object
        RtlInitUnicodeString(&UnicodeString, ObjectNameBuffer);

        UnnamedObjectAttributes = *ObjectAttributes;
        UnnamedObjectAttributes.Attributes = OBJ_OPENIF;
        UnnamedObjectAttributes.SecurityDescriptor = SecurityDescriptor;
        UnnamedObjectAttributes.ObjectName = NULL;


        //
        // Create an AccessState and wack on the token
        Status = SeCreateAccessState(&LocalAccessState,
                                     &AuxData,
                                     DesiredAccess,
                                     (PGENERIC_MAPPING)&WmipGenericMapping);

        if (NT_SUCCESS(Status))
        {
            SubjectContext = &LocalAccessState.SubjectSecurityContext;
            SavedSubjectContext = *SubjectContext;
            *SubjectContext = WmipSystemSubjectContext;

            //
            // Attach to system process so that the initial handle created
            // by ObInsertObject is not available to user mode. This handle
            // allows full access to the object.
            KeAttachProcess( &PsInitialSystemProcess->Pcb );

            Status = ObCreateObject(KernelMode,
                                    WmipGuidObjectType,
                                    &UnnamedObjectAttributes,
                                    KernelMode,
                                    NULL,
                                    sizeof(WMIGUIDOBJECT),
                                    0,
                                    0,
                                    (PVOID *)Object);

            if (NT_SUCCESS(Status))
            {
                //
                // Initialize WMIGUIDOBJECT structure
                //
                RtlZeroMemory(*Object, sizeof(WMIGUIDOBJECT));

                KeInitializeEvent(&(*Object)->Event,
                                  NotificationEvent,
                                  FALSE);

                (*Object)->HiPriority.MaxBufferSize = 0x1000;
                (*Object)->LoPriority.MaxBufferSize = 0x1000;
                (*Object)->Guid = *Guid;

                //
                // Take an extra refcount when inserting the object. We
                // need this ref count so that we can ensure that the
                // object will stick around while we are using it, but
                // after a handle has been made available to user mode
                // code. User mode can guess the handle and close it
                // even before we return it.
                //
                Status = ObInsertObject(*Object,
                                        &LocalAccessState,
                                        DesiredAccess,
                                        1,
                                        &NewObject,
                                        CreatorHandle);

                WmipAssert(Status != STATUS_OBJECT_NAME_EXISTS);
            }

            *SubjectContext = SavedSubjectContext;
            SeDeleteAccessState(&LocalAccessState);

            KeDetachProcess( );
        }

        if (SecurityDescriptor != WmipDefaultAccessSd)
        {
            ExFreePool(SecurityDescriptor);
        }
    }

    return(Status);
}

VOID WmipCloseMethod(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    )
/*++

Routine Description:

    This routine is called whenever a guid object handle is closed. We
    only need to worry about this for reply object and then only when the
    last handle to it is closed.

Arguments:

    Process

    Object

    GrantedAccess

    ProcessHandleCount

    SystemHandleCount

Return Value:


--*/
{
    PWMIGUIDOBJECT ReplyObject;
    PLIST_ENTRY RequestList;
    PMBREQUESTS MBRequest;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Process);
    UNREFERENCED_PARAMETER (GrantedAccess);
    UNREFERENCED_PARAMETER (ProcessHandleCount);

    if (SystemHandleCount == 1)
    {
        //
        // Only clean up if there are no more valid handles left
        //
        ReplyObject = (PWMIGUIDOBJECT)Object;

        if (ReplyObject->Flags & WMIGUID_FLAG_REPLY_OBJECT)
        {
            //
            // When a reply object is closed we need to make sure that
            // any referenece to it by a request object is cleaned up
            //
            ASSERT(ReplyObject->GuidEntry == NULL);

            WmipEnterSMCritSection();
            RequestList = ReplyObject->RequestListHead.Flink;

            while (RequestList != &ReplyObject->RequestListHead)
            {
                //
                //
                MBRequest = CONTAINING_RECORD(RequestList,
                                                  MBREQUESTS,
                                                  RequestListEntry);

                if (MBRequest->ReplyObject == ReplyObject)
                {
                    RemoveEntryList(&MBRequest->RequestListEntry);
                    MBRequest->ReplyObject = NULL;
                    ObDereferenceObject(ReplyObject);
                    break;
                }

                RequestList = RequestList->Flink;
            }

            WmipLeaveSMCritSection();
        }
    }
}



VOID WmipDeleteMethod(
    IN  PVOID   Object
    )
{
    PIRP Irp;
    PWMIGUIDOBJECT GuidObject, ReplyObject;
    PMBREQUESTS MBRequest;
    WNODE_HEADER Wnode;
    PREGENTRY RegEntry;
    PBDATASOURCE DataSource;
    ULONG i;

    PAGED_CODE();

    GuidObject = (PWMIGUIDOBJECT)Object;


    if (GuidObject->Flags & WMIGUID_FLAG_REQUEST_OBJECT)
    {
        //
        // This is a request object that is going away so we need to
        //
        ASSERT(GuidObject->GuidEntry == NULL);

        //
        // First reply to all reply objects that are waiting for
        // a reply
        //
        WmipEnterSMCritSection();
        for (i = 0; i < MAXREQREPLYSLOTS; i++)
        {
            MBRequest = &GuidObject->MBRequests[i];

            ReplyObject = MBRequest->ReplyObject;
            if (ReplyObject != NULL)
            {
                RtlZeroMemory(&Wnode, sizeof(WNODE_HEADER));
                Wnode.BufferSize = sizeof(WNODE_HEADER);
                Wnode.Flags = WNODE_FLAG_INTERNAL;
                Wnode.ProviderId = WmiRequestDied;
                WmipWriteWnodeToObject(ReplyObject,
                                       &Wnode,
                                       TRUE);

                RemoveEntryList(&MBRequest->RequestListEntry);
                MBRequest->ReplyObject = NULL;
                ObDereferenceObject(ReplyObject);
            }
        }

        //
        // next, unreference the regentry which will cause the regentry
        // to get a ref count of 0 and then ultimately remove the
        // DATASOURCE and all related data structures. But first make
        // sure to remove the pointer from the datasource to the
        // regentry
        //
        RegEntry = GuidObject->RegEntry;
        if (RegEntry != NULL)
        {
            DataSource = RegEntry->DataSource;
            if (DataSource != NULL)
            {
                DataSource->RequestObject = NULL;
            }

            RegEntry->Flags |= (REGENTRY_FLAG_RUNDOWN |
                                    REGENTRY_FLAG_NOT_ACCEPTING_IRPS);
            WmipUnreferenceRegEntry(RegEntry);
        }
        WmipLeaveSMCritSection();

    } else if (GuidObject->Flags & WMIGUID_FLAG_REPLY_OBJECT) {
        //
        // This is a reply obejct that is going away
        //
        ASSERT(GuidObject->GuidEntry == NULL);
    } else if (GuidObject->GuidEntry != NULL)  {
        //
        // If there is a guid entry associated with the object
        // then we need to see if we should disable collection
        // or events and then remove the obejct from the
        // guidentry list and finally remove the refcount on the guid
        // entry held by the object
        //
        if (GuidObject->EnableRequestSent)
        {
            WmipDisableCollectOrEvent(GuidObject->GuidEntry,
                                      GuidObject->Type,
                                      0);
        }

        WmipEnterSMCritSection();
        RemoveEntryList(&GuidObject->GEObjectList);
        WmipLeaveSMCritSection();

        WmipUnreferenceGE(GuidObject->GuidEntry);
    }

    if ((GuidObject->Flags & WMIGUID_FLAG_KERNEL_NOTIFICATION) == 0)
    {
        //
        // Clean up any queued events and irps for UM objects
        //
        if (GuidObject->HiPriority.Buffer != NULL)
        {
            WmipFree(GuidObject->HiPriority.Buffer);
        }

        if (GuidObject->LoPriority.Buffer != NULL)
        {
            WmipFree(GuidObject->LoPriority.Buffer);
        }

        WmipEnterSMCritSection();

        if (GuidObject->EventQueueAction == RECEIVE_ACTION_NONE)
        {
            Irp = GuidObject->Irp;

            if (Irp != NULL)
            {
                //
                // Since this object is going away and there is an irp waiting for
                // we need to make sure that the object is removed from the
                // irp's list.
                //
                WmipClearIrpObjectList(Irp);

                if (IoSetCancelRoutine(Irp, NULL))
                {
                    //
                    // If the irp has not been completed yet then we
                    // complete it now with an error
                    //
                    Irp->IoStatus.Information = 0;
                    Irp->IoStatus.Status = STATUS_INVALID_HANDLE;
                    IoCompleteRequest(Irp, IO_NO_INCREMENT);
                }
            }
        } else if (GuidObject->EventQueueAction == RECEIVE_ACTION_CREATE_THREAD) {
            //
            // If the object is going away and is part of a list of
            // objects waiting for an event to start a thread, all we
            // need to do is to removed the object from the list
            //
            WmipAssert(GuidObject->UserModeProcess != NULL);
            WmipAssert(GuidObject->UserModeCallback != NULL);
            WmipClearObjectFromThreadList(GuidObject);
        }
        WmipLeaveSMCritSection();
    }    
}

//
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOLEAN
WmipHexStringToDword(
    IN PWCHAR lpsz,
    OUT PULONG RetValue,
    IN ULONG cDigits,
    IN WCHAR chDelim
    )
{
    ULONG Count;
    ULONG Value;

    PAGED_CODE();

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    *RetValue = Value;

    if (chDelim != 0)
        return (*lpsz++ == chDelim) ? TRUE : FALSE;
    else
        return TRUE;
}


NTSTATUS
WmipUuidFromString (
    IN PWCHAR StringUuid,
    OUT LPGUID Uuid
    )
/*++

Routine Description:

    We convert a UUID from its string representation into the binary
    representation. Parse UUID such as 00000000-0000-0000-0000-000000000000

Arguments:

    StringUuid -  supplies the string representation of the UUID. It is
                  assumed that this parameter has been probed and captured

    Uuid - Returns the binary representation of the UUID.

Return Value:

    STATUS_SUCCESS or STATUS_INVALID_PARAMETER

--*/
{
    ULONG dw;
    PWCHAR lpsz = StringUuid;

    PAGED_CODE();

    if (!WmipHexStringToDword(lpsz, &Uuid->Data1, sizeof(ULONG)*2, '-'))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    lpsz += sizeof(ULONG)*2 + 1;


    if (!WmipHexStringToDword(lpsz, &dw, sizeof(USHORT)*2, '-'))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data2 = (USHORT)dw;
    lpsz += sizeof(USHORT)*2 + 1;


    if (!WmipHexStringToDword(lpsz, &dw, sizeof(USHORT)*2, '-'))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data3 = (USHORT)dw;
    lpsz += sizeof(USHORT)*2 + 1;


    if (!WmipHexStringToDword(lpsz, &dw, sizeof(UCHAR)*2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[0] = (UCHAR)dw;
    lpsz += sizeof(UCHAR)*2;


    if (!WmipHexStringToDword(lpsz, &dw, sizeof(UCHAR)*2, '-'))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[1] = (UCHAR)dw;
    lpsz += sizeof(UCHAR)*2+1;


    if (!WmipHexStringToDword(lpsz, &dw, sizeof(UCHAR)*2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[2] = (UCHAR)dw;
    lpsz += sizeof(UCHAR)*2;


    if (!WmipHexStringToDword(lpsz, &dw, sizeof(UCHAR)*2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[3] = (UCHAR)dw;
    lpsz += sizeof(UCHAR)*2;


    if (!WmipHexStringToDword(lpsz, &dw, sizeof(UCHAR)*2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[4] = (UCHAR)dw;
    lpsz += sizeof(UCHAR)*2;

    if (!WmipHexStringToDword(lpsz, &dw, sizeof(UCHAR)*2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[5] = (UCHAR)dw;
    lpsz += sizeof(UCHAR)*2;


    if (!WmipHexStringToDword(lpsz, &dw, sizeof(UCHAR)*2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[6] = (UCHAR)dw;
    lpsz += sizeof(UCHAR)*2;


    if (!WmipHexStringToDword(lpsz, &dw, sizeof(UCHAR)*2, 0))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Uuid->Data4[7] = (UCHAR)dw;

    return(STATUS_SUCCESS);
}

NTSTATUS
WmipCheckGuidAccess(
    IN LPGUID Guid,
    IN ACCESS_MASK DesiredAccess,
    IN PSECURITY_DESCRIPTOR UserDefaultSecurity
    )
/*++

Routine Description:

    Allows checking if the current user has the rights to access a guid.

Arguments:

    Guid is the guid whose security is to be checked

    DesiredAccess is the access that is desired by the user.
                  NOTE: This does not support GENERIC_* mappings or
                          ASSIGN_SYSTEM_SECURITY

Return Value:

    STATUS_SUCCESS or error

--*/
{
    BOOLEAN Granted;
    ACCESS_MASK PreviousGrantedAccess = 0;
    NTSTATUS Status;
    ACCESS_MASK GrantedAccess;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    UNICODE_STRING GuidString;
    WCHAR GuidBuffer[38];
    SECURITY_SUBJECT_CONTEXT SecuritySubjectContext;

    PAGED_CODE();

    StringCbPrintf(GuidBuffer,
                   sizeof(GuidBuffer),
             L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                         Guid->Data1, Guid->Data2,
                         Guid->Data3,
                         Guid->Data4[0], Guid->Data4[1],
                         Guid->Data4[2], Guid->Data4[3],
                         Guid->Data4[4], Guid->Data4[5],
                         Guid->Data4[6], Guid->Data4[7]);
    RtlInitUnicodeString(&GuidString, GuidBuffer);

    Status = WmipGetGuidSecurityDescriptor(&GuidString,
                                           &SecurityDescriptor,
                                           UserDefaultSecurity);

    if (NT_SUCCESS(Status))
    {
        SeCaptureSubjectContext(&SecuritySubjectContext);

        Granted = SeAccessCheck (SecurityDescriptor,
                             &SecuritySubjectContext,
                             FALSE,
                             DesiredAccess,
                             PreviousGrantedAccess,
                             NULL,
                             (PGENERIC_MAPPING)&WmipGenericMapping,
                             UserMode,
                             &GrantedAccess,
                             &Status);

        SeReleaseSubjectContext(&SecuritySubjectContext);

        if ((SecurityDescriptor != WmipDefaultAccessSd) &&
            (SecurityDescriptor != UserDefaultSecurity))
        {
            ExFreePool(SecurityDescriptor);
        }
    }

    return(Status);
}

NTSTATUS WmipCreateAdminSD(
    PSECURITY_DESCRIPTOR *Sd
    )
{
    ULONG DaclLength;
    PACL AdminDeviceDacl;
    PSECURITY_DESCRIPTOR AdminDeviceSd;
    NTSTATUS Status;

    PAGED_CODE();
    
    DaclLength = (ULONG)sizeof(ACL) +
                   (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                   SeLengthSid( SeAliasAdminsSid ) +
                   SeLengthSid( SeLocalSystemSid ) +
                   8; // The 8 is just for good measure

    AdminDeviceSd = (PSECURITY_DESCRIPTOR)ExAllocatePoolWithTag(PagedPool,
                                               DaclLength +
                                                  sizeof(SECURITY_DESCRIPTOR),
                                               WMIPOOLTAG);

    if (AdminDeviceSd != NULL)
    {
        AdminDeviceDacl = (PACL)((PUCHAR)AdminDeviceSd +
                                    sizeof(SECURITY_DESCRIPTOR));
        Status = RtlCreateAcl( AdminDeviceDacl,
                               DaclLength,
                               ACL_REVISION2);

        if (NT_SUCCESS(Status))
        {
            Status = RtlAddAccessAllowedAce (
                         AdminDeviceDacl,
                         ACL_REVISION2,
                         FILE_ALL_ACCESS,
                         SeAliasAdminsSid
                         );
            if (NT_SUCCESS(Status))
            {
                Status = RtlAddAccessAllowedAce (
                             AdminDeviceDacl,
                             ACL_REVISION2,
                             FILE_ALL_ACCESS,
                             SeLocalSystemSid
                             );
                if (NT_SUCCESS(Status))
                {
                    Status = RtlCreateSecurityDescriptor(
                                 AdminDeviceSd,
                                 SECURITY_DESCRIPTOR_REVISION1
                                 );
                    if (NT_SUCCESS(Status))
                    {
                        Status = RtlSetDaclSecurityDescriptor(
                                     AdminDeviceSd,
                                     TRUE,                       // DaclPresent
                                     AdminDeviceDacl,
                                     FALSE                       // DaclDefaulted
                                     );
                        if (NT_SUCCESS(Status))
                        {

                            //
                            // We need to make sure that there is an owner for the security
                            // descriptor since it is required when security is being checked
                            // when the device is being opened.
                            Status = RtlSetOwnerSecurityDescriptor(AdminDeviceSd,
                                                                   SeAliasAdminsSid,
                                                                   FALSE);
                        }
                    }
                }
            }
        }

        if (NT_SUCCESS(Status))
        {
            *Sd = AdminDeviceSd;
        } else {
            ExFreePool(AdminDeviceSd);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return(Status);
}


#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\globalog.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    globalog.c

Abstract:

    The global logger, which is started only by registry settings.
    Will start at boot.

Author:

    Jee Fung Pang (jeepang) 03-Nov-1998

Revision History:

--*/

#ifndef MEMPHIS
#include "wmikmp.h"
#include "ntos.h"
#include <evntrace.h>
#include "tracep.h"

#define MAX_REGKEYS         10
#define MAX_ENABLE_FLAGS    10
#define DOSDEVICES                      L"\\DosDevices\\"
#define UNCDEVICES                      L"\\??\\UNC"
#define DEFAULT_GLOBAL_LOGFILE_ROOT     L"%SystemRoot%"
#define DEFAULT_GLOBAL_DIRECTORY        L"\\System32\\LogFiles\\WMI"
#define DEFAULT_GLOBAL_LOGFILE          L"trace.log"
#define DEFAULT_TRACE_GUID_NAME         L"0811c1af-7a07-4a06-82ed-869455cdf713"

    //
    // NOTE: Need a trailing NULL entry so that RtlQueryRegistryValues()
    // knows when to stop
    //

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, WmipStartGlobalLogger)
#pragma alloc_text(PAGE, WmipQueryGLRegistryRoutine)
#pragma alloc_text(PAGE, WmipAddLogHeader)
#pragma alloc_text(PAGE, WmipDelayCreate)
#pragma alloc_text(PAGE, WmipCreateDirectoryFile)
#pragma alloc_text(PAGE, WmipCreateNtFileName)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
SECURITY_DESCRIPTOR EtwpDefaultSecurityDescriptor;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

extern HANDLE EtwpPageLockHandle;
//
// NOTE: If we are going to function earlier in boot, we need to see
// if the creation routines and logger routines can run at all while in
// boot path and being pagable
//

VOID
WmipStartGlobalLogger(
    )
/*++

Routine Description:

    This routine will check for registry entries to see if the global
    needs to be started at boot time.

Arguments:

    None

Return Value:


--*/
{
    struct _LOGGER_INFO {
        WMI_LOGGER_INFORMATION LoggerInfo;
        ULONG EnableFlags[MAX_ENABLE_FLAGS];
    } GLog;
    RTL_QUERY_REGISTRY_TABLE QueryRegistryTable[MAX_REGKEYS];
    NTSTATUS status;
    ULONG Win32Error = 0; // ERROR_SUCCESS
    ULONG StartRequested = 0;
    WCHAR NullString = UNICODE_NULL;
    UNICODE_STRING DefaultTraceGuidName;

    // We lock and unlock non-paged portion of ETW code so that we can keep global
    // logger in the memory while it's alive.
    EtwpPageLockHandle
        = MmLockPagableCodeSection((PVOID)(ULONG_PTR)WmipReserveTraceBuffer);
    MmUnlockPagableImageSection(EtwpPageLockHandle);
    KeInitializeGuardedMutex(&WmipTraceGuardedMutex);

    RtlZeroMemory(&EtwpDefaultSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));
    EtwpDefaultTraceSecurityDescriptor = &EtwpDefaultSecurityDescriptor;
    RtlInitUnicodeString(&DefaultTraceGuidName, DEFAULT_TRACE_GUID_NAME);
    status = WmipGetGuidSecurityDescriptor(
                &DefaultTraceGuidName,
                &EtwpDefaultTraceSecurityDescriptor,
                NULL
                );

    RtlZeroMemory(&GLog, sizeof(GLog));

    GLog.LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    GLog.LoggerInfo.MinimumBuffers = (ULONG) KeNumberProcessors + 1;
    GLog.LoggerInfo.MaximumBuffers = GLog.LoggerInfo.MinimumBuffers + 25;
    GLog.LoggerInfo.BufferSize     = PAGE_SIZE / 1024;
    GLog.LoggerInfo.Wnode.BufferSize = sizeof(WMI_LOGGER_INFORMATION);
    GLog.LoggerInfo.Wnode.Guid = GlobalLoggerGuid;
    GLog.LoggerInfo.LogFileMode = EVENT_TRACE_DELAY_OPEN_FILE_MODE |
                                  EVENT_TRACE_ADD_HEADER_MODE;
    RtlInitUnicodeString(&GLog.LoggerInfo.LoggerName, L"GlobalLogger");

    RtlZeroMemory(QueryRegistryTable,
                  sizeof(RTL_QUERY_REGISTRY_TABLE) * MAX_REGKEYS);

    QueryRegistryTable[0].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[0].EntryContext = (PVOID) &StartRequested;
    QueryRegistryTable[0].Name = L"Start";
    QueryRegistryTable[0].DefaultType = REG_DWORD;

    QueryRegistryTable[1].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[1].EntryContext = (PVOID) &GLog.LoggerInfo.BufferSize;
    QueryRegistryTable[1].Name = L"BufferSize";
    QueryRegistryTable[1].DefaultType = REG_DWORD;

    QueryRegistryTable[2].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[2].EntryContext = (PVOID)&GLog.LoggerInfo.MinimumBuffers;
    QueryRegistryTable[2].Name = L"MinimumBuffers";
    QueryRegistryTable[2].DefaultType = REG_DWORD;

    QueryRegistryTable[3].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[3].EntryContext = (PVOID) &GLog.LoggerInfo.FlushTimer;
    QueryRegistryTable[3].Name = L"FlushTimer";
    QueryRegistryTable[3].DefaultType = REG_DWORD;

    QueryRegistryTable[4].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[4].EntryContext = (PVOID)&GLog.LoggerInfo.MaximumBuffers;
    QueryRegistryTable[4].Name = L"MaximumBuffers";
    QueryRegistryTable[4].DefaultType = REG_DWORD;

    QueryRegistryTable[5].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[5].EntryContext = (PVOID) &GLog.LoggerInfo.LogFileName;
    QueryRegistryTable[5].Name = L"FileName";
    QueryRegistryTable[5].DefaultType = REG_SZ;
    QueryRegistryTable[5].DefaultData = &NullString;

    QueryRegistryTable[6].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[6].EntryContext = (PVOID) &GLog.EnableFlags[0];
    QueryRegistryTable[6].Name = L"EnableKernelFlags";
    QueryRegistryTable[6].DefaultType = REG_BINARY;

    QueryRegistryTable[7].QueryRoutine = WmipQueryGLRegistryRoutine;
    QueryRegistryTable[7].EntryContext = (PVOID)&GLog.LoggerInfo.Wnode.ClientContext;
    QueryRegistryTable[7].Name = L"ClockType";
    QueryRegistryTable[7].DefaultType = REG_DWORD;

    status = RtlQueryRegistryValues(
                RTL_REGISTRY_CONTROL,
                L"WMI\\GlobalLogger",
                QueryRegistryTable,
                NULL,
                NULL);

    if (NT_SUCCESS(status) && (StartRequested != 0)) {
        if (GLog.EnableFlags[0] != 0) {
            SHORT Length;
            for (Length=MAX_ENABLE_FLAGS-1; Length>=0; Length--) {
                if (GLog.EnableFlags[Length] != 0)
                    break;
            }
            if (Length >= 0) {
                PTRACE_ENABLE_FLAG_EXTENSION FlagExt;
                Length++;       // Index is 1 less!
                FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                          &GLog.LoggerInfo.EnableFlags;
                GLog.LoggerInfo.EnableFlags = EVENT_TRACE_FLAG_EXTENSION;
                FlagExt->Length = (UCHAR) Length;
                FlagExt->Offset = (UCHAR) GLog.LoggerInfo.Wnode.BufferSize;
                GLog.LoggerInfo.Wnode.BufferSize
                    += (ULONG) (Length * sizeof(ULONG));
            }
        }

        if (GLog.LoggerInfo.LogFileName.Buffer == NULL) {
            RtlCreateUnicodeString(
                &GLog.LoggerInfo.LogFileName,
                DEFAULT_GLOBAL_LOGFILE_ROOT); // Use ROOT as indicator
            if (GLog.LoggerInfo.LogFileName.Buffer == NULL)
                status = STATUS_NO_MEMORY;
            else
                status = STATUS_SUCCESS;
        }
        if (NT_SUCCESS(status)) {
            status = WmipStartLogger(&GLog.LoggerInfo);
        }
    }
    if (GLog.LoggerInfo.LogFileName.Buffer) {
        RtlFreeUnicodeString(&GLog.LoggerInfo.LogFileName);
    }
    // Write Win32 error to registry.
    if (!NT_SUCCESS(status)) {
        Win32Error = RtlNtStatusToDosError(status);
    }
    RtlWriteRegistryValue(RTL_REGISTRY_CONTROL,
                          L"WMI\\GlobalLogger",
                          L"Status",
                          REG_DWORD,
                          &Win32Error,
                          sizeof(ULONG));
}

NTSTATUS
WmipQueryGLRegistryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    Registry query values callback routine for reading SDs for guids

Arguments:

    ValueName - the name of the value

    ValueType - the type of the value

    ValueData - the data in the value (unicode string data)

    ValueLength - the number of bytes in the value data

    Context - Not used

    EntryContext - Pointer to PSECURITY_DESCRIPTOR to store a pointer to
        store the security descriptor read from the registry value

Return Value:

    NT Status code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();
    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(Context);

    if ( (ValueData != NULL) && (ValueLength > 0) && (EntryContext != NULL) ){
        if (ValueType == REG_DWORD) {
            if ((ValueLength >= sizeof(ULONG)) && (ValueData != NULL)) {
                *((PULONG)EntryContext) = *((PULONG)ValueData);
            }
        }
        else if (ValueType == REG_SZ) {
            if (ValueLength > sizeof(UNICODE_NULL)) {
                status = RtlCreateUnicodeString(
                            (PUNICODE_STRING) EntryContext,
                            (PCWSTR) ValueData);
            }
        }
        else if (ValueType == REG_BINARY) {
            if ((ValueLength >= sizeof(ULONG)) && (ValueData != NULL)) {
                RtlMoveMemory(EntryContext, ValueData, ValueLength);
            }
        }
    }
    return status;
}

NTSTATUS
WmipAddLogHeader(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN OUT PWMI_BUFFER_HEADER Buffer
    )
/*++

Routine Description:

    Add a standard logfile header in kernel moder. 
    To make sure the first buffer of the log file contains the file header,
    we pop a buffer from the free list, write the header, and flush the buffer
    right away.

Arguments:

    LoggerContext - The logger context

Return Value:

    NT Status code

--*/
{
    PTRACE_LOGFILE_HEADER LogfileHeader;
    USHORT HeaderSize;
    PSYSTEM_TRACE_HEADER EventTrace;
    PETHREAD Thread;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BufferProvided = (Buffer != NULL);
    ULONG LocalBuffer = FALSE;

    if (LoggerContext == NULL) {
        return STATUS_INVALID_PARAMETER;
    }
    // if this is a non-kernel logger started under wow64, 
    // we need to shrink the logfileheader
    if (LoggerContext->Wow && !LoggerContext->KernelTraceOn) {
        HeaderSize = sizeof(TRACE_LOGFILE_HEADER)
                     + LoggerContext->LoggerName.Length + sizeof(UNICODE_NULL)
                     + LoggerContext->LogFileName.Length + sizeof(UNICODE_NULL)
                     - 8;
    }
    else {
        HeaderSize = sizeof(TRACE_LOGFILE_HEADER)
                     + LoggerContext->LoggerName.Length + sizeof(UNICODE_NULL)
                     + LoggerContext->LogFileName.Length + sizeof(UNICODE_NULL);
    }
    if (LoggerContext->BufferSize < 
        (HeaderSize + sizeof(WMI_BUFFER_HEADER) + sizeof(SYSTEM_TRACE_HEADER))) {
        return STATUS_NO_MEMORY;
    }

    //
    // Pop a buffer from Free List
    //

    if (!BufferProvided) {
        Buffer = WmipGetFreeBuffer(LoggerContext);

        if (Buffer == NULL) {
            Buffer = ExAllocatePoolWithTag(NonPagedPool,
                        LoggerContext->BufferSize, TRACEPOOLTAG);
            if (Buffer == NULL) {

            //
            // No buffer available.
            //
                return STATUS_NO_MEMORY;
            }
            LocalBuffer = TRUE;

            Buffer->Flags = 1;

            WmipResetBufferHeader(LoggerContext, Buffer, WMI_BUFFER_TYPE_RUNDOWN);

            KeQuerySystemTime(&Buffer->TimeStamp);
        }
    }

    //
    // Fill in the Header Info.
    //
    Thread = PsGetCurrentThread();
    EventTrace = (PSYSTEM_TRACE_HEADER) (Buffer+1);
    EventTrace->Packet.Group = (UCHAR) EVENT_TRACE_GROUP_HEADER >> 8;
    EventTrace->Packet.Type  = EVENT_TRACE_TYPE_INFO;
    EventTrace->Packet.Size  = HeaderSize + sizeof(SYSTEM_TRACE_HEADER);
    EventTrace->Marker       = SYSTEM_TRACE_MARKER;
    EventTrace->ThreadId     = HandleToUlong(Thread->Cid.UniqueThread);
    EventTrace->KernelTime   = Thread->Tcb.KernelTime;
    EventTrace->UserTime     = Thread->Tcb.UserTime;
    EventTrace->SystemTime = LoggerContext->ReferenceTimeStamp;


    LogfileHeader = (PTRACE_LOGFILE_HEADER) (EventTrace+1);
    RtlZeroMemory(LogfileHeader, HeaderSize);

    LogfileHeader->BufferSize = LoggerContext->BufferSize;
    LogfileHeader->VersionDetail.MajorVersion = (UCHAR) NtMajorVersion;
    LogfileHeader->VersionDetail.MinorVersion = (UCHAR) NtMinorVersion;
    LogfileHeader->VersionDetail.SubVersion = TRACE_VERSION_MAJOR;
    LogfileHeader->VersionDetail.SubMinorVersion = TRACE_VERSION_MINOR;
    LogfileHeader->ProviderVersion = (NtBuildNumber & 0xffff);

    LogfileHeader->StartBuffers = 1;
    LogfileHeader->LogFileMode =
        LoggerContext->LoggerMode & (~(EVENT_TRACE_REAL_TIME_MODE));
    LogfileHeader->NumberOfProcessors = KeNumberProcessors;
    LogfileHeader->MaximumFileSize = LoggerContext->MaximumFileSize;
    LogfileHeader->TimerResolution = KeMaximumIncrement;

    if (LoggerContext->Wow && !LoggerContext->KernelTraceOn) {
        // We need to shrink a log file header for a non-kernel WOW64 logger.
        PUCHAR LoggerNamePtr64, LogFileNamePtr64;
        KeQueryPerformanceCounter((PLARGE_INTEGER)((PUCHAR)(&LogfileHeader->PerfFreq) - 8));
        *((PLARGE_INTEGER)((PUCHAR)(&LogfileHeader->StartTime) - 8)) 
                                            = LoggerContext->ReferenceSystemTime;
        *((PLARGE_INTEGER)((PUCHAR)(&LogfileHeader->BootTime) - 8)) 
                                            = KeBootTime;
        LogfileHeader->PointerSize = sizeof(ULONG);

        //
        // ReservedFlags to indicate using Perf Clock
        //
        *((PULONG)((PUCHAR)(&LogfileHeader->ReservedFlags) - 8)) 
                                            = LoggerContext->UsePerfClock;

        LoggerNamePtr64 = (PUCHAR) LogfileHeader
                            + sizeof(TRACE_LOGFILE_HEADER) 
                            - 8;
        *((PULONG)(&LogfileHeader->LoggerName)) = PtrToUlong(LoggerNamePtr64);

        LogFileNamePtr64 = (PUCHAR)LogfileHeader
                            + sizeof(TRACE_LOGFILE_HEADER) 
                            - 8 
                            + LoggerContext->LoggerName.Length
                            + sizeof(UNICODE_NULL);
        *((PULONG)((PUCHAR)(&LogfileHeader->LogFileName) - 4)) = PtrToUlong(LogFileNamePtr64);

        RtlCopyMemory(LoggerNamePtr64,
                        LoggerContext->LoggerName.Buffer,
                        LoggerContext->LoggerName.Length + sizeof(UNICODE_NULL));
        RtlCopyMemory(LogFileNamePtr64,
                        LoggerContext->LogFileName.Buffer,
                        LoggerContext->LogFileName.Length + sizeof(UNICODE_NULL));
        RtlQueryTimeZoneInformation((PRTL_TIME_ZONE_INFORMATION)((PUCHAR)(&LogfileHeader->TimeZone) - 8));
    }
    else {
        KeQueryPerformanceCounter(&LogfileHeader->PerfFreq);
        LogfileHeader->StartTime = LoggerContext->ReferenceSystemTime;
        LogfileHeader->BootTime = KeBootTime;
        LogfileHeader->PointerSize = sizeof(PVOID);

        //
        // ReservedFlags to indicate using Perf Clock
        //
        LogfileHeader->ReservedFlags = LoggerContext->UsePerfClock;

        LogfileHeader->LoggerName = (PWCHAR) ( (PUCHAR) LogfileHeader
                                                + sizeof(TRACE_LOGFILE_HEADER) );
        LogfileHeader->LogFileName = (PWCHAR) ( (PUCHAR)LogfileHeader->LoggerName
                                        + LoggerContext->LoggerName.Length
                                        + sizeof(UNICODE_NULL));

        RtlCopyMemory(LogfileHeader->LoggerName,
                            LoggerContext->LoggerName.Buffer,
                            LoggerContext->LoggerName.Length + sizeof(UNICODE_NULL));
        RtlCopyMemory(LogfileHeader->LogFileName,
                            LoggerContext->LogFileName.Buffer,
                            LoggerContext->LogFileName.Length + sizeof(UNICODE_NULL));
        RtlQueryTimeZoneInformation(&LogfileHeader->TimeZone);
    }

    //
    // Adjust the Offset;
    //
    Buffer->CurrentOffset += ALIGN_TO_POWER2(sizeof(SYSTEM_TRACE_HEADER) + HeaderSize, 
                                              WmiTraceAlignment);

    //
    // Log the Group Masks if it is from the kernel logger
    //
    if(LoggerContext == WmipLoggerContext[WmipKernelLogger]) {
        PPERFINFO_GROUPMASK PGroupMask;

        HeaderSize = sizeof(PERFINFO_GROUPMASK) + sizeof(SYSTEM_TRACE_HEADER);
        EventTrace = (PSYSTEM_TRACE_HEADER) ((PCHAR) Buffer + Buffer->CurrentOffset);
        EventTrace->Packet.Group = (UCHAR) EVENT_TRACE_GROUP_HEADER >> 8;
        EventTrace->Packet.Type  = EVENT_TRACE_TYPE_EXTENSION;
        EventTrace->Packet.Size  = HeaderSize;
        EventTrace->Marker       = SYSTEM_TRACE_MARKER;
        EventTrace->ThreadId     = HandleToUlong(Thread->Cid.UniqueThread);
        EventTrace->KernelTime   = Thread->Tcb.KernelTime;
        EventTrace->UserTime     = Thread->Tcb.UserTime;
        EventTrace->SystemTime   = LoggerContext->ReferenceTimeStamp;

        PGroupMask = (PPERFINFO_GROUPMASK) (EventTrace+1);
        ASSERT(PPerfGlobalGroupMask != NULL);
        RtlCopyMemory(PGroupMask, PPerfGlobalGroupMask, sizeof(PERFINFO_GROUPMASK));

        Buffer->CurrentOffset += ALIGN_TO_POWER2( HeaderSize, WmiTraceAlignment);
    }




    if (BufferProvided)
        return Status;
    //
    // The buffer is prepared properly.  Flush it so it can be written out to disk.
    //
    Status = WmipFlushBuffer(LoggerContext, Buffer, WMI_BUFFER_FLAG_NORMAL);

    if (LocalBuffer && (Buffer != NULL)) {
        ExFreePool(Buffer);
        return Status;
    }

    //
    // Reference count is overwriten during the flush,
    // Set it back before push the buffer into free list.
    //
    Buffer->ReferenceCount = 0;

    //
    // Set the buffer flags to "free" state
    //
    Buffer->State.Flush = 0;
    Buffer->State.InUse = 0;
    Buffer->State.Free = 1;

    //
    // Push into free list
    //
    InterlockedPushEntrySList(&LoggerContext->FreeList,
                              (PSLIST_ENTRY) &Buffer->SlistEntry);
    InterlockedIncrement(&LoggerContext->BuffersAvailable);
    InterlockedDecrement(&LoggerContext->BuffersInUse);
                    
    TraceDebug((2, "WmipAddLogHeader: Boot %I64u Current %I64u Difference %I64u\n",
                   KeBootTime, EventTrace->SystemTime,
                   EventTrace->SystemTime.QuadPart - KeBootTime.QuadPart));

    return Status;
}

NTSTATUS
WmipDelayCreate(
    OUT PHANDLE FileHandle,
    IN OUT PUNICODE_STRING FileName,
    IN ULONG Append
    )
/*++

Routine Description:

    This is called by the global logger to actually open the logfile
    when the first buffer needs to flush (instead of when the logger started)

Arguments:

    LoggerHandle    The handle to the logfile to be returned
    FileName        The logfile name. If the default was chosen, we will
                    returned the actual pathname in %systemroot%

Return Value:

    NT Status code

--*/
{
    PWCHAR Buffer;
    PWCHAR strBuffer = NULL;
    ULONG  DefaultFile, Length;
    UNICODE_STRING LogFileName;
    NTSTATUS Status;

    if (FileName == NULL)
        return STATUS_INVALID_PARAMETER;

    RtlInitUnicodeString(&LogFileName, DEFAULT_GLOBAL_LOGFILE_ROOT);
    DefaultFile = (RtlCompareUnicodeString(FileName, &LogFileName, TRUE) == 0);

    if (DefaultFile) {
        HRESULT hr;
        //
        // Try creating the file first
        //
        Length = (ULONG) (  NtSystemRoot.Length
                          + sizeof(WCHAR) * (wcslen(DEFAULT_GLOBAL_DIRECTORY) +
                                             wcslen(DEFAULT_GLOBAL_LOGFILE) + 1)
                          + sizeof(UNICODE_NULL));
        strBuffer = (PWCHAR) ExAllocatePoolWithTag(
                                        PagedPool, Length, TRACEPOOLTAG);
        if (strBuffer == NULL)
            return STATUS_NO_MEMORY;

        hr = StringCbPrintfW(strBuffer, 
                                  Length,
                                  L"%ws%ws\\%ws",
                                  NtSystemRoot.Buffer,
                                  DEFAULT_GLOBAL_DIRECTORY,
                                  DEFAULT_GLOBAL_LOGFILE);
        if (FAILED(hr)) {
            ExFreePool(strBuffer);
            return STATUS_INVALID_PARAMETER;
        }

        Status = WmipCreateNtFileName(strBuffer, &Buffer);
        if (!NT_SUCCESS(Status)) {
            ExFreePool(strBuffer);
            return Status;
        }

        Status = WmipCreateDirectoryFile(Buffer, FALSE, FileHandle, Append);
        if (!NT_SUCCESS(Status)) {
            ULONG DirLen;
            //
            // Probably directory does not exist, so try and create it
            //
            DirLen = (ULONG)
                     (wcslen(Buffer)-wcslen(DEFAULT_GLOBAL_LOGFILE)) - 5;
            Buffer[DirLen] = UNICODE_NULL;
            Status = WmipCreateDirectoryFile(Buffer, TRUE, NULL, Append);
            if (NT_SUCCESS(Status)) {
                Buffer[DirLen] = L'\\';
                DirLen += 4;
                Buffer[DirLen] = UNICODE_NULL;
                Status = WmipCreateDirectoryFile(Buffer, TRUE, NULL, Append);
                Buffer[DirLen] = L'\\';
            }
            if (NT_SUCCESS(Status)) {
                Status = WmipCreateDirectoryFile(Buffer, FALSE, FileHandle, Append);
            }
        }
        // Make sure that directory is there first

        if (NT_SUCCESS(Status)) {
            if (FileName->Buffer != NULL) {
                RtlFreeUnicodeString(FileName);
            }
            RtlInitUnicodeString(FileName, strBuffer);
            if (FileName->MaximumLength < Length)
                FileName->MaximumLength = (USHORT) Length;
        }
    }
    else {
        Status = WmipCreateNtFileName(FileName->Buffer, &Buffer);
        if (NT_SUCCESS(Status)) {
            Status = WmipCreateDirectoryFile(Buffer, FALSE, FileHandle, Append);
        }
    }

    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }
    return Status;
}

NTSTATUS
WmipCreateDirectoryFile(
    IN PWCHAR DirFileName,
    IN BOOLEAN IsDirectory,
    OUT PHANDLE FileHandle,
    IN ULONG Append
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    UNICODE_STRING LogDirName;
    HANDLE DirHandle = NULL;
    NTSTATUS Status;
    ULONG CreateDisposition;

    if (!IsDirectory && FileHandle == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlInitUnicodeString(&LogDirName, DirFileName);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &LogDirName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    if (IsDirectory) {
        CreateDisposition = FILE_OPEN_IF;
    } else if (Append) {
        CreateDisposition = FILE_OPEN_IF;
    } else {
        CreateDisposition = FILE_OVERWRITE_IF;
    }

    Status = ZwCreateFile(
                &DirHandle,
                FILE_GENERIC_READ | SYNCHRONIZE
                    | (IsDirectory ? FILE_GENERIC_WRITE : FILE_WRITE_DATA),
                &ObjectAttributes,
                &IoStatus,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                CreateDisposition,
                FILE_SYNCHRONOUS_IO_NONALERT
                    | (IsDirectory ? FILE_DIRECTORY_FILE
                                   : FILE_NO_INTERMEDIATE_BUFFERING),
                NULL,
                0);

    TraceDebug((2, "WmipCreateDirectoryFile: Create %ws Mode: %x status: %x\n",
                DirFileName, Append, Status));

    if (NT_SUCCESS(Status) && IsDirectory && (DirHandle != NULL)) {
        ZwClose(DirHandle);
        if (FileHandle) {
            *FileHandle = NULL;
        }
    }
    else {
        if (FileHandle) {
            *FileHandle = DirHandle;
        }
    }

    return Status;
}

NTSTATUS
WmipCreateNtFileName(
    IN  PWCHAR   strFileName,
    OUT PWCHAR * strNtFileName
)
{
    PWCHAR   NtFileName;
    ULONG    lenFileName;
    HRESULT  hr;

    if (strFileName == NULL) {
        *strNtFileName = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    lenFileName = sizeof(UNICODE_NULL)
                + (ULONG) (sizeof(WCHAR) * wcslen(strFileName));
    if ((strFileName[0] == L'\\') && (strFileName[1] == L'\\')) {
        lenFileName += (ULONG) (wcslen(UNCDEVICES) * sizeof(WCHAR));
    }
    else {
        lenFileName += (ULONG) (wcslen(DOSDEVICES) * sizeof(WCHAR));
    }
    NtFileName = (PWCHAR) ExAllocatePoolWithTag(
                            PagedPool, lenFileName, TRACEPOOLTAG);
    if (NtFileName == NULL) {
        *strNtFileName = NULL;
        return STATUS_NO_MEMORY;
    }

    if ((strFileName[0] == L'\\') && (strFileName[1] == L'\\')) {
        hr = StringCbPrintfW(NtFileName, 
                                  lenFileName, 
                                  L"%ws%ws", 
                                  UNCDEVICES, 
                                  &(strFileName[1]));
    }
    else {
        hr = StringCbPrintfW(NtFileName, 
                                  lenFileName, 
                                  L"%ws%ws", 
                                  DOSDEVICES, 
                                  strFileName);
    }
    if (FAILED(hr)) {
        ExFreePool(NtFileName);
        *strNtFileName = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    *strNtFileName = NtFileName;

    return STATUS_SUCCESS;
}
#endif // !MEMPHIS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\smbios.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    smbios.c.c

Abstract:

    SMBIOS interface for WMI

Author:

    AlanWar

Environment:

    Kernel mode

Revision History:


--*/

#if defined(_AMD64_) || defined(_IA64_) || defined(i386)

#include "wmikmp.h"
#include "arc.h"
#include "smbios.h"

void WmipGetSMBiosFromLoaderBlock(
    PVOID LoaderBlockPtr
    );

NTSTATUS WmipSMBiosDataRegQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

BOOLEAN WmipIsSMBiosKey(
    HANDLE ParentKeyHandle,
    PWCHAR KeyName,
    PUCHAR *SMBiosTableVirtualAddress,
    PULONG SMBiosTableLength
    );

NTSTATUS WmipSMBiosIdentifierRegQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

BOOLEAN WmipFindSMBiosEPSHeader(
    PUCHAR SMBiosVirtualAddress,
    ULONG BiosSize,
    PSMBIOS_EPS_HEADER EPSHeader
    );

NTSTATUS WmipFindSMBiosStructure(
    IN UCHAR Type,
    OUT PVOID *StructPtr,
    OUT PVOID *MapPtr,
    OUT PULONG MapSize
    );

NTSTATUS WmipFindSysIdTable(
    PPHYSICAL_ADDRESS SysidTablePhysicalAddress,
    PUCHAR SysIdBiosRevision,
    PULONG NumberEntries
    );

NTSTATUS WmipParseSysIdTable(
    PHYSICAL_ADDRESS PhysicalAddress,
    ULONG NumberEntries,
    PSYSID_UUID SysIdUuid,
    ULONG *SysIdUuidCount,
    PSYSID_1394 SysId1394,
    ULONG *SysId1394Count
    );

NTSTATUS WmipGetSysIds(
    PSYSID_UUID *SysIdUuid,
    ULONG *SysIdUuidCount,
    PSYSID_1394 *SysId1394,
    ULONG *SysId1394Count
    );

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
//
// These hold pointers to the SMBIOS data. If SMBIOS data is in the table
// format then WmipSMBiosTablePhysicalAddress holds the physical address of
// the table. If the SMBIOS was gathered at boot time by NTDETECT then
// WmipSMBiosTableVirtualAddress holds a pointer to a paged pool buffer that
// contains the SMBIOS data. In both cases WmipSMBiosTableLength holds the
// actual length of the SMBIOS table. If both the physical and virtual
// addresses are 0 then SMBIOS data is not available.
PHYSICAL_ADDRESS WmipSMBiosTablePhysicalAddress = {0};
PUCHAR WmipSMBiosTableVirtualAddress = NULL;
ULONG WmipSMBiosTableLength = 0;
SMBIOSVERSIONINFO WmipSMBiosVersionInfo = {0};
BOOLEAN WmipSMBiosChecked = FALSE;

//
// Have we tried to get SYSID yet and if so what was the utilmate status
BOOLEAN WmipSysIdRead;
NTSTATUS WmipSysIdStatus;

//
// Count and arrays of UUIDs and 1394 ids
PSYSID_UUID WmipSysIdUuid;
ULONG WmipSysIdUuidCount;

PSYSID_1394 WmipSysId1394;
ULONG WmipSysId1394Count;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WmipGetSMBiosFromLoaderBlock)

#pragma alloc_text(PAGE,WmipFindSMBiosEPSHeader)
#pragma alloc_text(PAGE,WmipFindSMBiosTable)
#pragma alloc_text(PAGE,WmipFindSMBiosStructure)
#pragma alloc_text(PAGE,WmipFindSysIdTable)
#pragma alloc_text(PAGE,WmipParseSysIdTable)
#pragma alloc_text(PAGE,WmipGetSysIds)
#pragma alloc_text(PAGE,WmipGetSMBiosTableData)
#pragma alloc_text(PAGE,WmipGetSMBiosEventlog)
#pragma alloc_text(PAGE,WmipDockUndockEventCallback)

#pragma alloc_text(PAGE,WmipSMBiosDataRegQueryRoutine)
#pragma alloc_text(PAGE,WmipSMBiosIdentifierRegQueryRoutine)
#pragma alloc_text(PAGE,WmipIsSMBiosKey)


#endif


BOOLEAN WmipFindSMBiosEPSHeader(
    PUCHAR SMBiosVirtualAddress,
    ULONG BiosSize,
    PSMBIOS_EPS_HEADER EPSHeader
    )
/*++

Routine Description:

    Search for the SMBIOS 2.1 EPS structure and copy it.

Arguments:

    SMBiosVirtualAddress is the beginning virtual address to start searching
        for the SMBIOS 2.1 EPS anchor string.

    BiosSize is the number of bytes to search for the anchor string

    EPSHeader is the memory into which the EPS header is copied
Return Value:

    Pointer to SMBIOS 2.1 EPS or NULL if EPS not found

--*/
{
    PUCHAR SearchEnd;
    UCHAR CheckSum;
    PSMBIOS_EPS_HEADER SMBiosEPSHeader;
    PDMIBIOS_EPS_HEADER DMIBiosEPSHeader;
    ULONG i;
    ULONG CheckLength;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (BiosSize);

    RtlZeroMemory(EPSHeader, sizeof(SMBIOS_EPS_HEADER));
    
    //
    // Scan the bios for the two anchor strings that that signal the SMBIOS
    // table.
    SearchEnd = SMBiosVirtualAddress + SMBIOS_EPS_SEARCH_SIZE -
                                             2 * SMBIOS_EPS_SEARCH_INCREMENT;

    while (SMBiosVirtualAddress < SearchEnd)
    {
       SMBiosEPSHeader = (PSMBIOS_EPS_HEADER)SMBiosVirtualAddress;
       DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)SMBiosVirtualAddress;

       //
       // First check for _DMI_ anchor string
       if ((*((PULONG)DMIBiosEPSHeader->Signature2) == DMI_EPS_SIGNATURE) &&
           (DMIBiosEPSHeader->Signature2[4] == '_'))
       {
           WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Found possible DMIBIOS EPS Header at %x\n", SMBiosEPSHeader));
           CheckLength = sizeof(DMIBIOS_EPS_HEADER);
       }

       //
       // Then check for full _SM_ anchor string
       else if ((*((PULONG)SMBiosEPSHeader->Signature) == SMBIOS_EPS_SIGNATURE) &&
                (SMBiosEPSHeader->Length >= sizeof(SMBIOS_EPS_HEADER)) &&
                (*((PULONG)SMBiosEPSHeader->Signature2) == DMI_EPS_SIGNATURE) &&
                (SMBiosEPSHeader->Signature2[4] == '_' ))
       {
           WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Found possible SMBIOS EPS Header at %p\n", SMBiosEPSHeader));
           CheckLength = SMBiosEPSHeader->Length;
       } else {
           //
           // Did not find anchor string, go search next paragraph
           SMBiosVirtualAddress += SMBIOS_EPS_SEARCH_INCREMENT;
           continue;
       }

       //
       // Verify anchor string with checksum
       CheckSum = 0;
       for (i = 0; i < CheckLength ; i++)
       {
           CheckSum = (UCHAR)(CheckSum + SMBiosVirtualAddress[i]);
       }

       if (CheckSum == 0)
       {
           WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Found SMBIOS EPS Header at %p\n", SMBiosEPSHeader));
           if (CheckLength == sizeof(DMIBIOS_EPS_HEADER))
           {
               //
               // We only had got a DMI header so copy that
               //
               RtlCopyMemory(&EPSHeader->Signature2[0],
                             DMIBiosEPSHeader,
                             sizeof(DMIBIOS_EPS_HEADER));
           } else {
               //
               // We got the full SMBIOS header so copy that
               //
               RtlCopyMemory(EPSHeader,
                             SMBiosEPSHeader,
                             sizeof(SMBIOS_EPS_HEADER));
           }
           return(TRUE);
       }
       SMBiosVirtualAddress += SMBIOS_EPS_SEARCH_INCREMENT;

    }

    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS EPS Header not found\n"));
    return(FALSE);
}

#ifndef _IA64_
//
// On X86 we look at the hardware device description keys to find the
// one that contains the SMBIOS data. The key is created by NTDETECT in
// the case that the machine only supports the 2.0 calling mechanism
//

//
// For x86 and ia64 the key is Someplace like
// HKLM\Hardware\System\MultiFunctionAdapter\<some number>
//
NTSTATUS WmipSMBiosIdentifierRegQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    Registry query values callback routine for reading SMBIOS data from
    registry.

Arguments:

    ValueName - the name of the value

    ValueType - the type of the value

    ValueData - the data in the value (unicode string data)

    ValueLength - the number of bytes in the value data

    Context - Not used

    EntryContext - Pointer to PUCHAR to store a pointer to
        store the SMBIOS data read from the registry value. If this is NULL
        then the caller is not interested in the SMBIOS data

Return Value:

    NT Status code -
        STATUS_SUCCESS - Identifier is valid for SMBIOS key
        STATUS_UNSUCCESSFUL - Identifier is not valid for SMBIOS key

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (ValueName);
    UNREFERENCED_PARAMETER (ValueLength);
    UNREFERENCED_PARAMETER (Context);
    UNREFERENCED_PARAMETER (EntryContext);

    Status =  ((ValueType == REG_SZ) &&
               (ValueData != NULL) &&
               (wcscmp(ValueData, SMBIOSIDENTIFIERVALUEDATA) == 0)) ?
                       STATUS_SUCCESS :
                       STATUS_UNSUCCESSFUL;

    return(Status);
}

NTSTATUS WmipSMBiosDataRegQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    Registry query values callback routine for reading SMBIOS data from
    registry.

Arguments:

    ValueName - the name of the value

    ValueType - the type of the value

    ValueData - the data in the value (unicode string data)

    ValueLength - the number of bytes in the value data

    Context - Not used

    EntryContext - Pointer to PUCHAR to store a pointer to
        store the SMBIOS data read from the registry value. If this is NULL
        then the caller is not interested in the SMBIOS data

Return Value:

    NT Status code -
        STATUS_SUCCESS - SMBIOS data is present in the value
        STATUS_INSUFFICIENT_RESOURCES - Not enough memory to keep SMBIOS data
        STATUS_UNSUCCESSFUL - SMBios data is not present in the value

--*/
{
    NTSTATUS Status;
    PCM_PARTIAL_RESOURCE_LIST PartialResourceList;
    PUCHAR Buffer;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptor;
    ULONG BufferSize;
    PREGQUERYBUFFERXFER RegQueryBufferXfer;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (ValueName);
    UNREFERENCED_PARAMETER (ValueLength);
    UNREFERENCED_PARAMETER (Context);

    WmipAssert(EntryContext != NULL);

    if ((ValueType == REG_FULL_RESOURCE_DESCRIPTOR) &&
        (ValueData != NULL))
    {
        //
        // On x86 get the actual SMBIOS data out of the registry and
        // place it into a buffer
        //
        RegQueryBufferXfer = (PREGQUERYBUFFERXFER)EntryContext;

        PartialResourceList = &(((PCM_FULL_RESOURCE_DESCRIPTOR)ValueData)->PartialResourceList);
        if (PartialResourceList->Count > 1)
        {
            //
            // Second partial resource descriptor contains SMBIOS data. There
            // should ALWAYS be a second partial resource descriptor and it
            // may have 0 bytes in the case that SMBIOS data was not collected
            // by NTDETECT.

            PartialDescriptor = &PartialResourceList->PartialDescriptors[0];
            Buffer = (PUCHAR)PartialDescriptor +
                             sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) +
                             PartialDescriptor->u.DeviceSpecificData.DataSize;
            PartialDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)Buffer;
            BufferSize = PartialDescriptor->u.DeviceSpecificData.DataSize;
            RegQueryBufferXfer->BufferSize = BufferSize;
            Status = STATUS_SUCCESS;
            if (BufferSize > 0)
            {
                RegQueryBufferXfer->Buffer = (PUCHAR)ExAllocatePoolWithTag(
                                                                  PagedPool,
                                                                  BufferSize,
                                                                  WMIPOOLTAG);
                if (RegQueryBufferXfer->Buffer != NULL)
                {
                    Buffer += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                    RtlCopyMemory(RegQueryBufferXfer->Buffer,
                                  Buffer,
                                  BufferSize);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Old NTDETECT.COM - No SMBIOS partial resource descriptor\n"));
            Status = STATUS_SUCCESS;
            RegQueryBufferXfer->BufferSize = 0;
        }
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }
    return(Status);
}

BOOLEAN WmipIsSMBiosKey(
    HANDLE ParentKeyHandle,
    PWCHAR KeyName,
    PUCHAR *SMBiosTableVirtualAddress,
    PULONG SMBiosTableLength
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING BaseKeyName;
    HANDLE KeyHandle;
    RTL_QUERY_REGISTRY_TABLE QueryTable[3];
    REGQUERYBUFFERXFER RegQueryBufferXfer = {0, NULL};

    PAGED_CODE();

    RtlInitUnicodeString(&BaseKeyName,
                         KeyName);

    InitializeObjectAttributes(&ObjectAttributes,
                               &BaseKeyName,
                               OBJ_CASE_INSENSITIVE,
                               ParentKeyHandle,
                               NULL);

    Status = ZwOpenKey(&KeyHandle,
                       KEY_READ,
                       &ObjectAttributes);
    if (NT_SUCCESS(Status))
    {
        RtlZeroMemory(QueryTable, sizeof(QueryTable));
        QueryTable[0].Name = SMBIOSIDENTIFIERVALUENAME;
        QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
        QueryTable[0].DefaultType = REG_SZ;
        QueryTable[0].QueryRoutine = WmipSMBiosIdentifierRegQueryRoutine;

        QueryTable[1].Name = SMBIOSDATAVALUENAME;
        QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED;
        QueryTable[1].EntryContext = &RegQueryBufferXfer;
        QueryTable[1].DefaultType = REG_FULL_RESOURCE_DESCRIPTOR;
        QueryTable[1].QueryRoutine = WmipSMBiosDataRegQueryRoutine;

        Status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE | RTL_REGISTRY_ABSOLUTE,
                                        (PWCHAR)KeyHandle,
                                        QueryTable,
                                        NULL,
                                        NULL);
        if (NT_SUCCESS(Status))
        {
            *SMBiosTableVirtualAddress = RegQueryBufferXfer.Buffer;
            *SMBiosTableLength = RegQueryBufferXfer.BufferSize;
        }

        ZwClose(KeyHandle);
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: H/D/S/MultifunctionAdapter subkey open error %x\n",
                 Status));
    }

    return(NT_SUCCESS(Status) ? TRUE : FALSE);
}

#endif

BOOLEAN WmipFindSMBiosTable(
    PPHYSICAL_ADDRESS SMBiosTablePhysicalAddress,
    PUCHAR *SMBiosTableVirtualAddress,
    PULONG SMBiosTableLength,
    PSMBIOSVERSIONINFO SMBiosVersionInfo
    )
/*++

Routine Description:

    Determines if the SMBIOS data is available

Arguments:

    SMBiosTablePhysicalAddress points to a variable to return the physical
        address of the SMBIOS 2.1 table. If table is not available then
        it returns with 0.

    SMBiosTableVirtualAddress points to a variable to return the virtual
        address of the SMBIOS 2.0 table as collected by NTDETECT. If the
        SMBIOS 2.0 data was not collected by NTDETECT it returns with 0.

    SMBiosTableLength points to a variable to return the length of the
        SMBIOS table data.

    SMBiosVersionInfo returns with the version information for SMBIOS

Return Value:

    TRUE if SMBIOS data is available, else FALSE

--*/
{
    PHYSICAL_ADDRESS BiosPhysicalAddress;
    PUCHAR BiosVirtualAddress;
    PDMIBIOS_EPS_HEADER DMIBiosEPSHeader;
#ifndef _IA64_  
    NTSTATUS Status;
    UNICODE_STRING BaseKeyName;
    HANDLE KeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG KeyIndex;
    ULONG KeyInformationLength;
    UCHAR KeyInformationBuffer[sizeof(KEY_BASIC_INFORMATION) +
                               (sizeof(WCHAR) * MAXSMBIOSKEYNAMESIZE)];
    PKEY_BASIC_INFORMATION KeyInformation;
#endif
    SMBIOS_EPS_HEADER SMBiosEPSHeader;
    BOOLEAN HaveEPSHeader = FALSE;
    BOOLEAN SearchForHeader = TRUE;

    PAGED_CODE();

    SMBiosTablePhysicalAddress->QuadPart = 0;
    *SMBiosTableVirtualAddress = NULL;
    *SMBiosTableLength = 0;

#ifndef _IA64_  
    //
    // First check registry to see if we captured SMBIOS 2.0 data in
    // NTDETECT. Search the keys under
    // MultiFunctionAdapter for the one
    // with the "PnP Bios" (x86)
    //
    RtlInitUnicodeString(&BaseKeyName,
                         SMBIOSPARENTKEYNAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &BaseKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&KeyHandle,
                       KEY_READ,
                       &ObjectAttributes);

    if (NT_SUCCESS(Status))
    {

        KeyIndex = 0;
        KeyInformation = (PKEY_BASIC_INFORMATION)KeyInformationBuffer;
        while (NT_SUCCESS(Status))
        {

            Status = ZwEnumerateKey(KeyHandle,
                                    KeyIndex++,
                                    KeyBasicInformation,
                                    KeyInformation,
                                    sizeof(KeyInformationBuffer) - sizeof(WCHAR),
                                    &KeyInformationLength);
            if (NT_SUCCESS(Status))
            {
                KeyInformation->Name[KeyInformation->NameLength / sizeof(WCHAR)] = UNICODE_NULL;
                if (WmipIsSMBiosKey(KeyHandle,
                                    KeyInformation->Name,
                                    SMBiosTableVirtualAddress,
                                    SMBiosTableLength))
                {
                    if (*SMBiosTableLength != 0)
                    {
                        SMBiosVersionInfo->Used20CallingMethod = TRUE;
                        SearchForHeader = FALSE;
                    }
                    break;
                }
            } else {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Status %x enum H\\D\\S\\MultiFunctionAdapter key, index %d\n",
                 Status, KeyIndex-1));
            }
        }
        ZwClose(KeyHandle);
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Status %x opening H\\D\\S\\MultiFunctionAdapter key\n",
                 Status));
    }
#endif
    
    if (SearchForHeader)
    {
        //
        // If not in registry then check for EPS in the BIOS
        BiosPhysicalAddress.QuadPart = SMBIOS_EPS_SEARCH_START;
        BiosVirtualAddress = MmMapIoSpace(BiosPhysicalAddress,
                                          SMBIOS_EPS_SEARCH_SIZE,
                                          MmNonCached);

        if (BiosVirtualAddress != NULL)
        {
            HaveEPSHeader = WmipFindSMBiosEPSHeader(BiosVirtualAddress,
                                                    SMBIOS_EPS_SEARCH_SIZE,
                                                    &SMBiosEPSHeader);
            MmUnmapIoSpace(BiosVirtualAddress, SMBIOS_EPS_SEARCH_SIZE);
        }
    } else {
         WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS data recovered from loader\n"));
    }
        
    if (HaveEPSHeader)
    {
        //
        // We found the EPS so just extract the physical
        // address of the table
        //
        DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)&SMBiosEPSHeader.Signature2[0];

        SMBiosVersionInfo->Used20CallingMethod = FALSE;

        SMBiosTablePhysicalAddress->HighPart = 0;
        SMBiosTablePhysicalAddress->LowPart = DMIBiosEPSHeader->StructureTableAddress;

        *SMBiosTableLength = DMIBiosEPSHeader->StructureTableLength;

        SMBiosVersionInfo->SMBiosMajorVersion = SMBiosEPSHeader.MajorVersion;
        SMBiosVersionInfo->SMBiosMinorVersion = SMBiosEPSHeader.MinorVersion;

        SMBiosVersionInfo->DMIBiosRevision = DMIBiosEPSHeader->Revision;
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS 2.1 data at (%x%x) size %x \n",
                      SMBiosTablePhysicalAddress->HighPart,
                      SMBiosTablePhysicalAddress->LowPart,
                      *SMBiosTableLength));
    }


    return(*SMBiosTableLength > 0 ? TRUE : FALSE);
}

NTSTATUS WmipGetSMBiosTableData(
    OUT PUCHAR Buffer,
    IN OUT PULONG BufferSize,
    OUT PSMBIOSVERSIONINFO SMBiosVersionInfo
    )
/*++

Routine Description:

    Registry query values callback routine for reading SMBIOS data from
    registry.

Arguments:

    Buffer is a pointer to a buffer in which to write the SMBIOS data

    *BufferSize has the maximum number of bytes available to write into
        Buffer. On return it has the actual size of the SMBIOS data.

Return Value:

    NT Status code -
        STATUS_SUCCESS - Buffer filled with SMBIOS data
        STATUS_BUFFER_TOO_SMALL - Buffer not filled with SMBIOS data,
                                  *BufferSize returns with buffer size neeeded

--*/
{
    NTSTATUS status;
    PUCHAR SMBiosDataVirtualAddress;

    PAGED_CODE();

    WmipEnterSMCritSection();
    if (! WmipSMBiosChecked)
    {
        //
        // See if there is any SMBIOS information and if so register
        WmipFindSMBiosTable(&WmipSMBiosTablePhysicalAddress,
                            &WmipSMBiosTableVirtualAddress,
                            &WmipSMBiosTableLength,
                            &WmipSMBiosVersionInfo);
        WmipSMBiosChecked = TRUE;
    }
    WmipLeaveSMCritSection();

    if (SMBiosVersionInfo != NULL)
    {
        *SMBiosVersionInfo = WmipSMBiosVersionInfo;
    }

    if (*BufferSize >= WmipSMBiosTableLength)
    {
        if (WmipSMBiosTablePhysicalAddress.QuadPart != 0)
        {
            //
            // 2.1 table format - map in table and copy
            SMBiosDataVirtualAddress = MmMapIoSpace(WmipSMBiosTablePhysicalAddress,
                                                    WmipSMBiosTableLength,
                                                    MmNonCached);
            if (SMBiosDataVirtualAddress != NULL)
            {
                RtlCopyMemory(Buffer,
                          SMBiosDataVirtualAddress,
                          WmipSMBiosTableLength);

                MmUnmapIoSpace(SMBiosDataVirtualAddress,
                               WmipSMBiosTableLength);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else if (WmipSMBiosTableVirtualAddress != NULL) {
            RtlCopyMemory(Buffer,
                          WmipSMBiosTableVirtualAddress,
                          WmipSMBiosTableLength);
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
    } else {
        status = STATUS_BUFFER_TOO_SMALL;
    }

    *BufferSize = WmipSMBiosTableLength;

    return(status);
}



#if defined(_IA64_)   // EFI actually
void WmipGetSMBiosFromLoaderBlock(
    PVOID LoaderBlockPtr
    )
{
    PLOADER_PARAMETER_BLOCK LoaderBlock = (PLOADER_PARAMETER_BLOCK)LoaderBlockPtr;
    PLOADER_PARAMETER_EXTENSION LoaderExtension = LoaderBlock->Extension;
    PSMBIOS_EPS_HEADER SMBiosEPSHeader;
    PDMIBIOS_EPS_HEADER DMIBiosEPSHeader;

    PAGED_CODE();
    
    if (LoaderExtension->Size >= sizeof(LOADER_PARAMETER_EXTENSION))
    {   
        SMBiosEPSHeader = LoaderExtension->SMBiosEPSHeader;

        if (SMBiosEPSHeader != NULL)
        {
            DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)&SMBiosEPSHeader->Signature2[0];

            WmipSMBiosVersionInfo.Used20CallingMethod = FALSE;

            WmipSMBiosTablePhysicalAddress.HighPart = 0;
            WmipSMBiosTablePhysicalAddress.LowPart = DMIBiosEPSHeader->StructureTableAddress;

            WmipSMBiosTableLength = DMIBiosEPSHeader->StructureTableLength;

            WmipSMBiosVersionInfo.SMBiosMajorVersion = SMBiosEPSHeader->MajorVersion;
            WmipSMBiosVersionInfo.SMBiosMinorVersion = SMBiosEPSHeader->MinorVersion;

            WmipSMBiosVersionInfo.DMIBiosRevision = DMIBiosEPSHeader->Revision;

            WmipSMBiosChecked = TRUE;

            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,
                              "WMI: SMBIOS 2.1 data from EFI at (%x%x) size %x \n",
                          WmipSMBiosTablePhysicalAddress.HighPart,
                          WmipSMBiosTablePhysicalAddress.LowPart,
                          WmipSMBiosTableLength));
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,
                              "WMI: No SMBIOS data in loader block\n"));
        }
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,
                          "WMI: Loader extension does not contain SMBIOS header\n"));
    }
}
#endif


#define WmipUnmapSMBiosStructure(Address, Size) \
    if ((Address) != NULL) MmUnmapIoSpace((Address), (Size));

NTSTATUS WmipFindSMBiosStructure(
    IN UCHAR Type,
    OUT PVOID *StructPtr,
    OUT PVOID *MapPtr,
    OUT PULONG MapSize
    )
/*++

Routine Description:

    Find a specific SMBIOS structure in the SMBIOS information.
    WmipUnmapSNVuisStructure should be called if this function returns
    successfully.

Arguments:

    Type is structure type to find

    *StructPtr returns with pointer to beginning of structure

    *MapPtr returns with pointer to address SMBIOS data was mapped.

    *MapSize returns with size mapped
Return Value:

    STATUS

--*/
{
    NTSTATUS Status;
    BOOLEAN Found;
    PUCHAR Ptr;
    PUCHAR PtrEnd;
    PSMBIOS_STRUCT_HEADER StructHeader;

    PAGED_CODE();

    //
    // Make sure SMBIOS table has been obtained. Note we already hold
    // the critical section
    if (! WmipSMBiosChecked)
    {
        //
        // See if there is any SMBIOS information and if so register
        Found = WmipFindSMBiosTable(&WmipSMBiosTablePhysicalAddress,
                            &WmipSMBiosTableVirtualAddress,
                            &WmipSMBiosTableLength,
                            &WmipSMBiosVersionInfo);
        WmipSMBiosChecked = TRUE;
    } else {
        Found = (WmipSMBiosTableLength > 0  ? TRUE : FALSE);
    }

    if (Found)
    {
        Status = STATUS_SUCCESS;
        if (WmipSMBiosTablePhysicalAddress.QuadPart != 0)
        {
            //
            // SMBIOS is available in physical memory
            *MapPtr = MmMapIoSpace(WmipSMBiosTablePhysicalAddress,
                                   WmipSMBiosTableLength,
                                   MmCached);
            if (*MapPtr != NULL)
            {
                *MapSize = WmipSMBiosTableLength;
                Ptr = *MapPtr;
            } else {
                //
                // Lets hope this is a temporary problem
                Status = STATUS_INSUFFICIENT_RESOURCES;
                Ptr = NULL;
            }
        } else if (WmipSMBiosTableVirtualAddress != NULL) {
            *MapPtr = NULL;
            Ptr = WmipSMBiosTableVirtualAddress;
        } else {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS table was found, but is not in physical or virtual memory\n"));
            WmipAssert(FALSE);
            Status = STATUS_UNSUCCESSFUL;
            Ptr = NULL;
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Now scan the SMBIOS table to find our structure
            *StructPtr = NULL;
            PtrEnd = (PVOID)((PUCHAR)Ptr + WmipSMBiosTableLength);
            Status = STATUS_UNSUCCESSFUL;
            StructHeader = NULL;
            try
            {
                while (Ptr < PtrEnd)
                {
                    StructHeader = (PSMBIOS_STRUCT_HEADER)Ptr;

                    if (StructHeader->Type == Type)
                    {
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS struct for type %d found at %p\n",
                             Type, Ptr));
                        *StructPtr = Ptr;
                        Status = STATUS_SUCCESS;
                        break;
                    }

                    Ptr+= StructHeader->Length;
                    while ( (*((USHORT UNALIGNED *)Ptr) != 0)  &&
                            (Ptr < PtrEnd) )
                    {
                        Ptr++;
                    }
                    Ptr += 2;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid SMBIOS data table %p at %p\n",
                         *MapPtr, StructHeader));
                WmipAssert(FALSE);
            }

            if (! NT_SUCCESS(Status) )
            {
                WmipUnmapSMBiosStructure(*MapPtr, *MapSize);
            }
        }
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }
    return(Status);
}

NTSTATUS WmipFindSysIdTable(
    PPHYSICAL_ADDRESS SysidTablePhysicalAddress,
    PUCHAR SysIdBiosRevision,
    PULONG NumberEntries
    )
/*++

Routine Description:

    Scan the system bios to search for the SYSID table

Arguments:

    *SysidTablePhysicalAddress returns with the physical address of the
        sysid table

    *SysIdBiosRevision returns with the bios revision of the sysid table

    *NumberEntries returns the number of SYSID entries in the table

Return Value:

    STATUS

--*/
{
    UCHAR Checksum;
    PUCHAR p;
    PSYSID_EPS_HEADER SysIdEps, SearchEnd;
    PHYSICAL_ADDRESS BiosPhysicalAddress;
    PUCHAR BiosVirtualAddress;
    ULONG i;
    NTSTATUS Status;

    PAGED_CODE();

    BiosPhysicalAddress.QuadPart = SYSID_EPS_SEARCH_START;
    BiosVirtualAddress = MmMapIoSpace(BiosPhysicalAddress,
                                      SYSID_EPS_SEARCH_SIZE,
                                      MmCached);

    SearchEnd = (PSYSID_EPS_HEADER)(BiosVirtualAddress + SYSID_EPS_SEARCH_SIZE);
    SysIdEps = (PSYSID_EPS_HEADER)BiosVirtualAddress;

    if (BiosVirtualAddress != NULL)
    {
        try
        {
            while (SysIdEps < SearchEnd)
            {
                if (((*(PULONG)SysIdEps->Signature) == SYSID_EPS_SIGNATURE) &&
                     (*(PUSHORT)(&SysIdEps->Signature[4]) == SYSID_EPS_SIGNATURE2) &&
                     (SysIdEps->Signature[6] == '_') )
                {
                    //
                    // This may be the SYSID table, check the checksum
                    Checksum = 0;
                    p = (PUCHAR)SysIdEps;
                    for (i = 0; i < sizeof(SYSID_EPS_HEADER); i++)
                    {
                        Checksum = (UCHAR)(Checksum + p[i]);
                    }

                    if (Checksum == 0)
                    {
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SYSID EPS found at %p\n",
                                     SysIdEps));
                        break;
                    } else {
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalis SYSID EPS checksum at %p\n",
                                  SysIdEps));
                    }
                }

                SysIdEps = (PSYSID_EPS_HEADER)( ((PUCHAR)SysIdEps) +
                                     SYSID_EPS_SEARCH_INCREMENT);
            }

            if (SysIdEps != SearchEnd)
            {
                SysidTablePhysicalAddress->HighPart = 0;
                SysidTablePhysicalAddress->LowPart = SysIdEps->SysIdTableAddress;
                *SysIdBiosRevision = SysIdEps->BiosRev;
                *NumberEntries = SysIdEps->SysIdCount;
                Status = STATUS_SUCCESS;
            } else {
                //
                // Not finding the SYSID EPS is a terminal error
                Status = STATUS_UNSUCCESSFUL;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid SYSID EPS Table at %p\n", SysIdEps));
            Status = STATUS_UNSUCCESSFUL;
        }

        MmUnmapIoSpace(BiosVirtualAddress, SYSID_EPS_SEARCH_SIZE);
    } else {
        //
        // Lets hope that failure to map memory is a temporary problem
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(Status);
}

typedef enum
{
	SYSID_UNKNOWN_TYPE,
	SYSID_UUID_TYPE,
	SYSID_1394_TYPE
} SYSID_ENTRY_TYPE, *PSYSID_ENTRY_TYPE;

NTSTATUS WmipParseSysIdTable(
    PHYSICAL_ADDRESS PhysicalAddress,
    ULONG NumberEntries,
    PSYSID_UUID SysIdUuid,
    ULONG *SysIdUuidCount,
    PSYSID_1394 SysId1394,
    ULONG *SysId1394Count
    )
/*++

Routine Description:

    Determine the set of UUIDs and 1394 Ids that are in the sysid table

Arguments:

    PhysicalAddress is the physical address of the SysId table

    NumberEntries is the number of entries in the SysId table

    SysIdUuid returns filled with an array of UUIDs. If NULL then no
        UUIDs are returned.

    *SysIdUuidCount returns with the number of UUIDs in the table

    SysId1394 returns filled with an array of 1394 ids. If NULL then no
        1394 ids are returned.

    *SysId1394Count returns with the number of 1394 ids in the table


Return Value:

    STATUS

--*/
{
    NTSTATUS Status;
    ULONG TableSize = NumberEntries * LARGEST_SYSID_TABLE_ENTRY;
    ULONG i;
    ULONG  j;
    PUCHAR VirtualAddress;
    PSYSID_TABLE_ENTRY SysId;
    PUCHAR p;
    UCHAR Checksum;
    ULONG Length;
    ULONG x1394Count, UuidCount;
    ULONG BytesLeft;
	SYSID_ENTRY_TYPE SysidType;

    PAGED_CODE();

    VirtualAddress = MmMapIoSpace(PhysicalAddress,
                                  TableSize,
                                  MmCached);

    if (VirtualAddress != NULL)
    {
        UuidCount = 0;
        x1394Count = 0;
        SysId = (PSYSID_TABLE_ENTRY)VirtualAddress;
        BytesLeft = TableSize;
        Status = STATUS_SUCCESS;

        for (i = 0; i < NumberEntries; i++)
        {
            //
            // Make sure we have not moved beyond the end of the mapped
            // memory.
            if (BytesLeft >= sizeof(SYSID_TABLE_ENTRY))
            {

                Length = SysId->Length;
				
				//
				// Determine what kind of sysid we have
				//
				if ((RtlCompareMemory(&SysId->Type,
									  SYSID_TYPE_UUID, 6) == 6) &&
					(Length == sizeof(SYSID_UUID_ENTRY)))
				{
					SysidType = SYSID_UUID_TYPE;
				} else if ((RtlCompareMemory(&SysId->Type,
											SYSID_TYPE_1394, 6) == 6) &&
						   (Length == sizeof(SYSID_1394_ENTRY))) {

					SysidType = SYSID_1394_TYPE;
				} else {
					//
					// unknown type SYSID
					//
					WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Unknown SYSID type %c%c%c%c%c%c found at %p\n",
								 SysId->Type[0],
								 SysId->Type[1],
								 SysId->Type[2],
								 SysId->Type[3],
								 SysId->Type[4],
								 SysId->Type[5],
								 SysId
							 ));
					Status = STATUS_UNSUCCESSFUL;
					break;
				}
				
                //
                // Validate checksum for this table entry

                if (BytesLeft >= Length)
                {
                    Checksum = 0;
                    p = (PUCHAR)SysId;
                    for (j = 0; j < Length; j++)
                    {
                        Checksum = (UCHAR)(Checksum + p[j]);
                    }

                    if (Checksum != 0)
                    {
                        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SYSID Table checksum is not valid at %p\n",
                                 SysId));
                        Status = STATUS_UNSUCCESSFUL;
                        break;
                    }

                    //
                    // Determine what kind of SYSID we have
                    if (SysidType == SYSID_UUID_TYPE)
                    {
                        if (BytesLeft >= sizeof(SYSID_UUID_ENTRY))
                        {
                            //
                            // _UUID_ type SYSID
                            UuidCount++;
                            if (SysIdUuid != NULL)
                            {
                                RtlCopyMemory(SysIdUuid,
                                              SysId->Data,
                                              sizeof(SYSID_UUID));
                                SysIdUuid++;
                            }
                         } else {
                            Status = STATUS_UNSUCCESSFUL;
                            break;
                         }
                    } else if (SysidType == SYSID_1394_TYPE) {
                        if (BytesLeft >= sizeof(SYSID_1394_ENTRY))
                        {
                            //
                            // _1394_ type SYSID
                            x1394Count++;
                            if (SysId1394 != NULL)
                            {
                                RtlCopyMemory(SysId1394,
                                              SysId->Data,
                                              sizeof(SYSID_1394));
                                SysId1394++;
                            }
                        } else {
                            Status = STATUS_UNSUCCESSFUL;
                            break;
                        }
                    } else {
						WmipAssert(FALSE);
						Status = STATUS_UNSUCCESSFUL;
						break;
					}
                    
                    //
                    // Advance to next sysid in table
                    SysId = (PSYSID_TABLE_ENTRY)(((PUCHAR)SysId) + Length);
                    BytesLeft -= Length;
                } else {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SYSID Table at %p is larger at %p than expected",
                             VirtualAddress, SysId));
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }
            } else {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SYSID Table at %p is larger at %p than expected",
                         VirtualAddress, SysId));
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
        }

        *SysIdUuidCount = UuidCount;
        *SysId1394Count = x1394Count;

        MmUnmapIoSpace(VirtualAddress, TableSize);
    } else {
        //
        // Lets hope that the failure to map is a temporary condition
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(Status);
}

NTSTATUS WmipGetSysIds(
    PSYSID_UUID *SysIdUuid,
    ULONG *SysIdUuidCount,
    PSYSID_1394 *SysId1394,
    ULONG *SysId1394Count
    )
/*++

Routine Description:

    This routine will obtain the 1394 and UUID sysids from the bios. First
    we look for a specific memory signature that contains a list of 1394 and
    UUID sysids. If we do not find that we then look at the SMBIOS information
    structure SYSTEM INFORMATION (type 1) which may have it embedded within
    it. If not then we give up.

Arguments:

    *SysIdUuid returns pointing to an array of UUID Sysids

    *SysIdUuidCount returns with the number of UUID Sysids in *SysIdUuid

    *SysId1394 returns pointing to an array of 1394 Sysids

    *SysId1394Count returns with the number of 1394 Sysids in *SysIdUuid


Return Value:

    NT Status code

--*/
{
    NTSTATUS Status;
    PHYSICAL_ADDRESS PhysicalAddress;
    UCHAR BiosRevision;
    ULONG NumberEntries;
    ULONG UuidCount, x1394Count;
    PSYSID_UUID Uuid;
    PSYSID_1394 x1394;
    ULONG TotalSize, x1394Size, UuidSize;

    PAGED_CODE();

    WmipEnterSMCritSection();

    //
    // First See if we have already obtained the SYSIDS
    if (! WmipSysIdRead)
    {
        //
        // First see if the sysids are maintained in a separate SYSID table
        Status = WmipFindSysIdTable(&PhysicalAddress,
                                    &BiosRevision,
                                    &NumberEntries);

        if (NT_SUCCESS(Status))
        {
            //
            // Get the count of entries in each table
            Status = WmipParseSysIdTable(PhysicalAddress,
                                         NumberEntries,
                                         NULL,
                                         &UuidCount,
                                         NULL,
                                         &x1394Count);

            if (NT_SUCCESS(Status))
            {
                 //
                // Get the entire SYSID table

                UuidSize = UuidCount * sizeof(SYSID_UUID);
                x1394Size = x1394Count * sizeof(SYSID_1394);
                TotalSize = UuidSize+x1394Size;

                if (TotalSize > 0)
                {
                    Uuid = ExAllocatePoolWithTag(PagedPool,
                                                 TotalSize,
                                                 WMISYSIDPOOLTAG);

                    if (Uuid == NULL)
                    {
                        WmipLeaveSMCritSection();
                        return(STATUS_INSUFFICIENT_RESOURCES);
                    }

                    x1394 = (PSYSID_1394)( ((PUCHAR)Uuid) + UuidSize );

                    //
                    // Now get the SYSIDs
                    Status = WmipParseSysIdTable(PhysicalAddress,
                                         NumberEntries,
                                         Uuid,
                                         &UuidCount,
                                         x1394,
                                         &x1394Count);

                    if (NT_SUCCESS(Status))
                    {
                        WmipSysIdUuid = Uuid;
                        WmipSysIdUuidCount = UuidCount;
                        WmipSysId1394 = x1394;
                        WmipSysId1394Count = x1394Count;
                    } else {
                        ExFreePool(Uuid);
                    }

                }

            }
        } else {
            //
            // Get SYSID information from SMBIOS
            PVOID MapAddress;
            PSMBIOS_SYSTEM_INFORMATION_STRUCT Info;
            ULONG MapSize;

            Status = WmipFindSMBiosStructure(SMBIOS_SYSTEM_INFORMATION,
                                             (PVOID *)&Info,
                                             &MapAddress,
                                             &MapSize);

            if (NT_SUCCESS(Status))
            {
                Uuid = NULL;
                WmipSysId1394 = NULL;
                WmipSysId1394Count = 0;
                try
                {
                    if (Info->Length > SMBIOS_SYSTEM_INFORMATION_LENGTH_20)
                    {
                        Uuid = ExAllocatePoolWithTag(PagedPool,
                                                           sizeof(SYSID_UUID),
                                                           WMISYSIDPOOLTAG);
                        if (Uuid != NULL)
                        {
                            RtlCopyMemory(Uuid,
                                          Info->Uuid,
                                          sizeof(SYSID_UUID));
                            WmipSysIdUuidCount = 1;
                            WmipSysIdUuid = Uuid;
                            Status = STATUS_SUCCESS;
                        } else {
                            ExFreePool(Uuid);
                            Status = STATUS_UNSUCCESSFUL;
                        }
                    } else {
                        WmipSysIdUuid = NULL;
                        WmipSysIdUuidCount = 0;
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid SMBIOS SYSTEM INFO structure %p\n",
                              Info));
                    WmipAssert(FALSE);
                    Status = STATUS_UNSUCCESSFUL;
                }

                WmipUnmapSMBiosStructure(MapAddress, MapSize);
            }
        }

        //
        // Mark that we were not able to obtain SysId Information
        WmipSysIdRead = (Status != STATUS_INSUFFICIENT_RESOURCES) ? TRUE : FALSE;
        WmipSysIdStatus = Status;
    }

    WmipLeaveSMCritSection();

    if (NT_SUCCESS(WmipSysIdStatus))
    {
        *SysIdUuid = WmipSysIdUuid;
        *SysIdUuidCount = WmipSysIdUuidCount;
        *SysId1394 = WmipSysId1394;
        *SysId1394Count = WmipSysId1394Count;
    }

    return(WmipSysIdStatus);
}

NTSTATUS WmipGetSMBiosEventlog(
    PUCHAR Buffer,
    PULONG BufferSize
    )
/*++

Routine Description:

    Return the contents of the SMBios eventlog

Arguments:

    Buffer is a pointer to a buffer that receives the eventlog

    *BufferSize on entry has the size of the buffer that can receive
        the eventlog data, on return it has the number of bytes used
        by the smbios eventlog data or the number of bytes needed for
        the smbios eventlog data.

Return Value:

    NT Status code -
        STATUS_SUCCESS - Buffer filled with SMBIOS eventlog data
        STATUS_BUFFER_TOO_SMALL - Buffer not filled with SMBIOS eventlog data,
                                  *BufferSize returns with buffer size neeeded

--*/
{
    PVOID MapAddress;
    PSMBIOS_SYSTEM_EVENTLOG_STRUCT SystemEventlog;
    ULONG MapSize;
    USHORT LogAreaLength;
    UCHAR AccessMethod;
    ACCESS_METHOD_ADDRESS AccessMethodAddress;
    PSMBIOS_EVENTLOG_INFO EventlogInfo;
    UCHAR LogHeaderDescExists;
    PUCHAR EventlogArea;
    NTSTATUS Status;
    USHORT LogTypeDescLength;
    ULONG SizeNeeded;

    PAGED_CODE();
    Status = WmipFindSMBiosStructure(SMBIOS_SYSTEM_EVENTLOG,
                                     (PVOID *)&SystemEventlog,
                                     &MapAddress,
                                     &MapSize);

    if (NT_SUCCESS(Status))
    {
        //
        // Copy data out of SMBIOS eventlog header so we can unmap quickly
        //
        LogAreaLength = SystemEventlog->LogAreaLength;
        AccessMethod = SystemEventlog->AccessMethod;
        AccessMethodAddress = SystemEventlog->AccessMethodAddress;

        if (SystemEventlog->Length >= SMBIOS_SYSTEM_EVENTLOG_LENGTH)
        {
            LogTypeDescLength = SystemEventlog->NumLogTypeDescriptors *
                                SystemEventlog->LenLogTypeDescriptors;
            LogHeaderDescExists = 1;
            if (SystemEventlog->Length != (LogTypeDescLength +
                                  FIELD_OFFSET(SMBIOS_SYSTEM_EVENTLOG_STRUCT,
                                               LogTypeDescriptor)))
            {
                //
                // The SMBIOS spec says that the Length of the structure
                // is the length of the base part of the structures plus
                // the length of the type descriptors. Since this is not
                // the case we may have run into a buggy bios
                //
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS System Eventlog struture %p size is %x, but expecting %x\n",
                           SystemEventlog,
                           SystemEventlog->Length,
                           (LogTypeDescLength +
                            FIELD_OFFSET(SMBIOS_SYSTEM_EVENTLOG_STRUCT,
                                         LogTypeDescriptor)) ));
                WmipAssert(FALSE);
                WmipUnmapSMBiosStructure(MapAddress, MapSize);
                Status = STATUS_UNSUCCESSFUL;
                return(Status);
            }
        } else {
            LogTypeDescLength = 0;
            LogHeaderDescExists = 0;
        }

        SizeNeeded = FIELD_OFFSET(SMBIOS_EVENTLOG_INFO, VariableData) +
                                         LogTypeDescLength +
                                         LogAreaLength;
        if (*BufferSize >= SizeNeeded)
        {
            EventlogInfo = (PSMBIOS_EVENTLOG_INFO)Buffer;
            EventlogInfo->LogTypeDescLength = LogTypeDescLength;
            EventlogInfo->LogHeaderDescExists = LogHeaderDescExists;
            EventlogInfo->Reserved = 0;

            EventlogArea = &EventlogInfo->VariableData[LogTypeDescLength];

            if (LogHeaderDescExists == 1)
            {
                //
                // if log header descriptors exist (smbios 2.1+) then copy
                // rest of smbios header plus log type descriptors
                //
                RtlCopyMemory(&EventlogInfo->LogAreaLength,
                              &SystemEventlog->LogAreaLength,
                              (SystemEventlog->Length -
                                  FIELD_OFFSET(SMBIOS_SYSTEM_EVENTLOG_STRUCT,
                                               LogAreaLength)));
            } else {
                //
                // if no log header descriptors then just copy smbios 2.0
                // defined fields and zero out rest of structure
                //
                RtlCopyMemory(&EventlogInfo->LogAreaLength,
                              &SystemEventlog->LogAreaLength,
                        FIELD_OFFSET(SMBIOS_EVENTLOG_INFO, LogHeaderFormat) -
                        FIELD_OFFSET(SMBIOS_EVENTLOG_INFO, LogAreaLength));

                *((PUSHORT)&EventlogInfo->LogHeaderFormat) = 0;
                EventlogInfo->LengthEachLogTypeDesc = 0;
            }

            WmipUnmapSMBiosStructure(MapAddress, MapSize);

            switch(AccessMethod)
            {
                case ACCESS_METHOD_MEMMAP:
                {
                    //
                    // Eventlog is maintained in physical memory
                    //
                    PHYSICAL_ADDRESS PhysicalAddress;
                    PUCHAR EventlogVirtualAddress;

                    PhysicalAddress.HighPart = 0;
                    PhysicalAddress.LowPart = AccessMethodAddress.AccessMethodAddress.PhysicalAddress32;
                    EventlogVirtualAddress = MmMapIoSpace(PhysicalAddress,
                                                LogAreaLength,
                                                MmCached);

                    if ((EventlogArea != NULL) &&
                        (EventlogVirtualAddress != NULL))
                    {
                        RtlCopyMemory(EventlogArea,
                                      EventlogVirtualAddress,
                                      LogAreaLength);
                        MmUnmapIoSpace(EventlogVirtualAddress,
                                       LogAreaLength);
                        Status = STATUS_SUCCESS;
                    } else {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                    break;
                };

                case ACCESS_METHOD_INDEXIO_1:
                {
//                  break;
                };

                case ACCESS_METHOD_INDEXIO_2:
                {
//                  break;
                };

                case ACCESS_METHOD_INDEXIO_3:
                {
//                  break;
                };

                case ACCESS_METHOD_GPNV:
                {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS Eventlog access method GPNV %x\n",
                                     AccessMethod));
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                };

                default:
                {
                    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: SMBIOS Eventlog access method %x\n",
                                     AccessMethod));
                    WmipAssert(FALSE);
                    Status = STATUS_UNSUCCESSFUL;
                }
            };

        } else {
            WmipUnmapSMBiosStructure(MapAddress, MapSize);
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        *BufferSize = SizeNeeded;
    }
    return(Status);
}

NTSTATUS
WmipDockUndockEventCallback(
    IN PVOID NotificationStructure,
    IN PVOID Context
    )
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER (NotificationStructure);
    UNREFERENCED_PARAMETER (Context);

    //
    // if SMBIOS data is obtained via the table in the bios, then reset
    // the flag to indicate that we need to rescan for the table. It is
    // possible that a dock or undock could have changed the data. If we
    // obtained the data from ntdetect then there is nothing we can do
    // since we cannot call the bios.
    if (WmipSMBiosTablePhysicalAddress.QuadPart != 0)
    {
        WmipEnterSMCritSection();
        WmipSMBiosChecked = FALSE;
        WmipLeaveSMCritSection();
    }

    return(STATUS_SUCCESS);
}

#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\notify.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Manages KM to UM notification queue

Author:

    AlanWar

Environment:

    Kernel Mode

Revision History:


--*/

#include "wmikmp.h"


void WmipInitializeNotifications(
    void
    );

void WmipEventNotification(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WmipInitializeNotifications)
#pragma alloc_text(PAGE,WmipEventNotification)
#endif

WORK_QUEUE_ITEM WmipEventWorkQueueItem;
LIST_ENTRY WmipNPEvent = {&WmipNPEvent, &WmipNPEvent};
KSPIN_LOCK WmipNPNotificationSpinlock;
LONG WmipEventWorkItems;
#if DBG
ULONG WmipNPAllocFail;
#endif

void WmipInitializeNotifications(
    void
    )
{
    PAGED_CODE();
    
    ExInitializeWorkItem( &WmipEventWorkQueueItem,
                          WmipEventNotification,
                          NULL );

    KeInitializeSpinLock(&WmipNPNotificationSpinlock);

}

void WmipEventNotification(
    IN PVOID Context
    )
/*++

Routine Description:

    Work item routine to call WmipNotifyUserMode on behalf of an event fired
    by a driver

Arguments:

    Context is not used

Return Value:


--*/
{
    PWNODE_HEADER WnodeEventItem;
    PLIST_ENTRY NotificationPacketList;
	PEVENTWORKCONTEXT EventContext;

    PAGED_CODE();
    
    UNREFERENCED_PARAMETER (Context);

    do
    {
        NotificationPacketList = ExInterlockedRemoveHeadList(
            &WmipNPEvent,
            &WmipNPNotificationSpinlock);

        WmipAssert(NotificationPacketList != NULL);

		EventContext = (PEVENTWORKCONTEXT)
                         CONTAINING_RECORD(NotificationPacketList,
                         EVENTWORKCONTEXT,
                         ListEntry);
		
        WnodeEventItem = EventContext->Wnode;

        //
        // Restore the Wnode->Version from ->ClientContext
        //
        WnodeEventItem->Version = WnodeEventItem->ClientContext;
        WnodeEventItem->ClientContext = 0;
        WnodeEventItem->Linkage = 0;

        WmipProcessEvent(WnodeEventItem,
                         FALSE,
                         TRUE);

        if (EventContext->RegEntry != NULL)
        {
            //
            // Unref for the ref count taken in IoWMIWriteEvent
            //
            WmipUnreferenceRegEntry(EventContext->RegEntry);
        }

		ExFreePool(EventContext);
    } while (InterlockedDecrement(&WmipEventWorkItems));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\traceapi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    traceapi.c

Abstract:

    This is the source file that implements the published routines of
    the performance event tracing and logging facility. These routines are
    be declared in ntos\inc\wmi.h

Author:

    Jee Fung Pang (jeepang) 03-Jan-2000

Revision History:

--*/

#include "wmikmp.h"
#include <ntos.h>
#include <evntrace.h>

#include <wmi.h>
#include "tracep.h"

extern SIZE_T MmMaximumNonPagedPoolInBytes;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, WmiStartTrace)
#pragma alloc_text(PAGE, WmiQueryTrace)
#pragma alloc_text(PAGE, WmiStopTrace)
#pragma alloc_text(PAGE, WmiUpdateTrace)
#pragma alloc_text(PAGE, WmiSetTraceBufferCallback)
#pragma alloc_text(PAGE, WmiFlushTrace)
#pragma alloc_text(PAGE, WmiQueryTraceInformation)

// #pragma alloc_text(PAGEWMI, NtTraceEvent)

// #pragma alloc_text(PAGEWMI, WmiTraceEvent)
#pragma alloc_text(PAGEWMI, WmiTraceKernelEvent)
// #pragma alloc_text(PAGEWMI, WmiTraceFastEvent)
// #pragma alloc_text(PAGEWMI, WmiTraceLongEvent)
// #pragma alloc_text(PAGEWMI, WmiTraceMessage)
// #pragma alloc_text(PAGEWMI, WmiTraceMessageVa)
#pragma alloc_text(PAGEWMI, WmiTraceUserMessage)
// #pragma alloc_text(PAGEWMI, WmiGetClock)
// #pragma alloc_text(PAGEWMI, WmiGetClockType)
#pragma alloc_text(PAGEWMI, WmiSetMark)
#endif

//
// Trace Control APIs
//


NTKERNELAPI
NTSTATUS
WmiStartTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This routine is used to create and start an event tracing session.
    NOTE: A special instance (KERNEL_LOGGER) is reserved exclusively for
    logging kernel tracing.

    To turn on KERNEL_LOGGER, LoggerInfo->Wnode.Guid should be set to
    SystemTraceControlGuid, and sufficient space must be provided in
    LoggerInfo->LoggerName.

    To turn on other loggers, simply provide a name in LoggerName. The
    logger id will be returned.

Arguments:

    LoggerInfo     a pointer to the structure for the logger's control
                    and status information

Return Value:

    The status of performing the action requested.

--*/

{
    NTSTATUS status;
    PWCHAR LogFileName = NULL;
    HANDLE FileHandle = NULL;
    ULONG DelayOpen;

    PAGED_CODE();

    if (LoggerInfo == NULL)
        return STATUS_INVALID_PARAMETER;

    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return STATUS_INVALID_BUFFER_SIZE;

    //
    // We assume that the caller is always kernel mode
    // First, we try and see it is a delay create.
    // If not, if we can even open the file
    //
    DelayOpen = LoggerInfo->LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE;

    if (!DelayOpen) {
        if (LoggerInfo->LogFileName.Buffer != NULL) { // && !delay_create
            status = WmipCreateNtFileName(
                        LoggerInfo->LogFileName.Buffer,
                        &LogFileName);
            if (!NT_SUCCESS(status))
                return status;
            status = WmipCreateDirectoryFile(LogFileName, 
                                            FALSE, 
                                            &FileHandle,
                                            LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND);
            if (LogFileName != NULL) {
                ExFreePool(LogFileName);
            }
            if (!NT_SUCCESS(status)) {
                return status;
            }
            ZwClose(FileHandle);
        }
    }

    status = WmipStartLogger(LoggerInfo);
    if (NT_SUCCESS(status)) {
        status = WmiFlushTrace(LoggerInfo);
    }
    return status;
}


NTKERNELAPI
NTSTATUS
WmiQueryTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This routine is called to query the status of a tracing session.
    Caller must pass in either the Logger Name or a valid Logger Id/Handle.

Arguments:

    LoggerInfo     a pointer to the structure for the logger's control
                    and status information

Return Value:

    The status of performing the action requested.

--*/

{
    PAGED_CODE();

    if (LoggerInfo == NULL)
        return STATUS_INVALID_PARAMETER;
    return WmipQueryLogger(LoggerInfo, NULL);
}


NTKERNELAPI
NTSTATUS
WmiStopTrace(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    It is called by WmipIoControl in wmi.c, with IOCTL_WMI_STOP_LOGGER
    to stop an instance of the logger. If the logger is the kernel logger,
    it will also turn off kernel tracing and unlock the routines previously
    locked. It will also free all the context of the logger.
    Calls StopLoggerInstance to do the actual work.

Arguments:

    LoggerInfo     a pointer to the structure for the logger's control
                    and status information

Return Value:

    The status of performing the action requested.

--*/

{
    PWMI_LOGGER_CONTEXT LoggerContext = NULL;
    NTSTATUS        Status;
    LARGE_INTEGER   TimeOut = {(ULONG)(-200 * 1000 * 1000 * 10), -1};
    ACCESS_MASK     DesiredAccess = TRACELOG_GUID_ENABLE;
    ULONG           LoggerId;
#if DBG
    LONG            RefCount;
#endif

    PAGED_CODE();

    if (LoggerInfo == NULL)
        return STATUS_INVALID_PARAMETER;

    TraceDebug((1, "WmiStopTrace: %d\n",
                    LoggerInfo->Wnode.HistoricalContext));
#if DBG
    Status = WmipVerifyLoggerInfo(LoggerInfo, &LoggerContext, "WmiStopTrace");
#else
    Status = WmipVerifyLoggerInfo(LoggerInfo, &LoggerContext);
#endif

    if (!NT_SUCCESS(Status) || (LoggerContext == NULL))
        return Status;

    LoggerId = LoggerContext->LoggerId;
    TraceDebug((1, "WmiStopTrace: Stopping %X %d slot %X\n",
                    LoggerContext, LoggerId, WmipLoggerContext[LoggerId]));

    if (LoggerContext->KernelTraceOn)
        DesiredAccess |= TRACELOG_ACCESS_KERNEL_LOGGER;

    Status = WmipCheckGuidAccess(
                &LoggerContext->InstanceGuid,
                DesiredAccess,
                EtwpDefaultTraceSecurityDescriptor
                );
    if (!NT_SUCCESS(Status)) {
#ifndef WMI_MUTEX_FREE
        InterlockedDecrement(&LoggerContext->MutexCount);
        TraceDebug((1, "WmiStopTrace: Release mutex1 %d %d\n",
            LoggerId, LoggerContext->MutexCount));
        WmipReleaseMutex(&LoggerContext->LoggerMutex);
#endif

#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmiStopTrace: Status1=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        return Status;
    }

    //
    // Reset the Event inside the mutex to be sure
    // before waiting on it.

    KeResetEvent(&LoggerContext->FlushEvent);

    Status = WmipStopLoggerInstance (LoggerContext);

#ifndef WMI_MUTEX_FREE
    InterlockedDecrement(&LoggerContext->MutexCount);
    TraceDebug((1, "WmiStopTrace: Release mutex3 %d %d\n",
        LoggerId, LoggerContext->MutexCount));
    WmipReleaseMutex(&LoggerContext->LoggerMutex); // Let others in
#endif

    if (NT_SUCCESS(Status)) {
        if (LoggerId == WmipKernelLogger)
            WmipKernelLogger = KERNEL_LOGGER;
        else if (LoggerId == WmipEventLogger)
            WmipEventLogger = 0XFFFFFFFF;
        else 
            Status = WmipDisableTraceProviders(LoggerId);

        if (LoggerInfo != NULL) {
            if (NT_SUCCESS(LoggerContext->LoggerStatus)) {
                LONG Buffers;

                Status = STATUS_TIMEOUT;
                Buffers = LoggerContext->BuffersAvailable;

                //
                // If all buffers are accounted for and the logfile handle
                // is NULL, then there is no reason to wait. 
                //

                if ( (Buffers == LoggerContext->NumberOfBuffers) && 
                     (LoggerContext->LogFileHandle == NULL) ) {
                    Status = STATUS_SUCCESS;
                }
                //
                // We need to wait for the logger thread to flush
                //
                while (Status == STATUS_TIMEOUT) {
                    Status = KeWaitForSingleObject(
                                &LoggerContext->FlushEvent,
                                Executive,
                                KernelMode,
                                FALSE,
                                &TimeOut
                                );
/*                    if (LoggerContext->NumberOfBuffers
                            == LoggerContext->BuffersAvailable)
                        break;
                    else if (LoggerContext->BuffersAvailable == Buffers) {
                        TraceDebug((1,
                            "WmiStopTrace: Logger %d hung %d != %d\n",
                            LoggerId, Buffers, LoggerContext->NumberOfBuffers));
                        KeResetEvent(&LoggerContext->FlushEvent);
//                        break;
                    } 
*/
                    TraceDebug((1, "WmiStopTrace: Wait status=%X\n",Status));
                }
            }
            //
            // Required for Query to work
            // But since CollectionOn is FALSE, it should be safe
            //
            Status = WmipQueryLogger(
                        LoggerInfo,
                        LoggerContext
                        );
        }
    }
#if DBG
    RefCount =
#endif
    WmipDereferenceLogger(LoggerId);
    TraceDebug((1, "WmiStopTrace: Stopped status=%X %d %d->%d\n",
                       Status, LoggerId, RefCount+1, RefCount));
    return Status;
}


NTKERNELAPI
NTSTATUS
WmiUpdateTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    It is called by WmipIoControl in wmi.c, with IOCTL_WMI_UPDATE_LOGGER
    to update certain characteristics of a running logger.

Arguments:

    LoggerInfo      a pointer to the structure for the logger's control
                    and status information

Return Value:

    The status of performing the action requested.

--*/

{
    NTSTATUS Status;
    ULONG Max_Buffers;
    PWMI_LOGGER_CONTEXT LoggerContext = NULL;
    ACCESS_MASK     DesiredAccess = TRACELOG_GUID_ENABLE;
    LARGE_INTEGER   TimeOut = {(ULONG)(-20 * 1000 * 1000 * 10), -1};
    ULONG           EnableFlags, TmpFlags;
    KPROCESSOR_MODE     RequestorMode;
    ULONG           LoggerMode, LoggerId, NewMode;
    UNICODE_STRING  NewLogFileName;
    PTRACE_ENABLE_FLAG_EXTENSION FlagExt = NULL;
    PERFINFO_GROUPMASK *PerfGroupMasks=NULL;
    ULONG GroupMaskSize;
    SECURITY_QUALITY_OF_SERVICE ServiceQos;
#if DBG
    LONG            RefCount;
#endif

    PAGED_CODE();

    
    //
    // see if Logger is running properly first. Error checking will be done
    // in WmiQueryTrace
    //

    if (LoggerInfo == NULL)
        return STATUS_INVALID_PARAMETER;

    EnableFlags = LoggerInfo->EnableFlags;

    TraceDebug((1, "WmiUpdateTrace: %d\n",
                    LoggerInfo->Wnode.HistoricalContext));
#if DBG
    Status = WmipVerifyLoggerInfo(LoggerInfo, &LoggerContext, "WmiUpdateTrace");
#else
    Status = WmipVerifyLoggerInfo(LoggerInfo, &LoggerContext);
#endif
    if (!NT_SUCCESS(Status) || (LoggerContext == NULL))
        return Status;

    LoggerId = LoggerContext->LoggerId;

    // at this point, LoggerContext must be non-NULL

    LoggerMode = LoggerContext->LoggerMode;   // local copy
    NewMode = LoggerInfo->LogFileMode;

    //
    // First, check to make sure that you cannot turn on certain modes
    // in UpdateTrace()
    //

    if ( ((NewMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) &&
          (NewMode & EVENT_TRACE_FILE_MODE_CIRCULAR))        ||

         ((NewMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) &&
          (NewMode & EVENT_TRACE_USE_LOCAL_SEQUENCE))        || 

         (!(LoggerMode & EVENT_TRACE_FILE_MODE_CIRCULAR) &&
          (NewMode & EVENT_TRACE_FILE_MODE_CIRCULAR))        ||

        // Cannot support append to circular
         ((NewMode & EVENT_TRACE_FILE_MODE_CIRCULAR) &&
          (NewMode & EVENT_TRACE_FILE_MODE_APPEND))

       ) {
#ifndef WMI_MUTEX_FREE
        InterlockedDecrement(&LoggerContext->MutexCount);
        TraceDebug((1, "WmiUpdateTrace: Release mutex1 %d %d\n",
            LoggerContext->LoggerId, LoggerContext->MutexCount));
        WmipReleaseMutex(&LoggerContext->LoggerMutex);
#endif
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmiUpdateTrace: Status2=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // support turn on or off real time dynamically
    //

    if (NewMode & EVENT_TRACE_REAL_TIME_MODE) {
        LoggerMode   |= EVENT_TRACE_REAL_TIME_MODE;
        DesiredAccess |= TRACELOG_CREATE_REALTIME;
    } else {
        if (LoggerMode & EVENT_TRACE_REAL_TIME_MODE)
            DesiredAccess |= TRACELOG_CREATE_REALTIME;  // turn off real time
        LoggerMode &= ~EVENT_TRACE_REAL_TIME_MODE;
    }
    if (NewMode & EVENT_TRACE_BUFFERING_MODE) {
        LoggerMode |= EVENT_TRACE_BUFFERING_MODE;
    }
    else {
        LoggerMode &= ~EVENT_TRACE_BUFFERING_MODE;
    }
    if (LoggerContext->KernelTraceOn)
        DesiredAccess |= TRACELOG_ACCESS_KERNEL_LOGGER;
    if (LoggerInfo->LogFileHandle != NULL)
        DesiredAccess |= TRACELOG_CREATE_ONDISK;

    Status = WmipCheckGuidAccess(
                &LoggerContext->InstanceGuid,
                DesiredAccess,
                EtwpDefaultTraceSecurityDescriptor
                );
    if (!NT_SUCCESS(Status)) {
#ifndef WMI_MUTEX_FREE
        InterlockedDecrement(&LoggerContext->MutexCount);
        TraceDebug((1, "WmiUpdateTrace: Release mutex1 %d %d\n",
            LoggerContext->LoggerId, LoggerContext->MutexCount));
        WmipReleaseMutex(&LoggerContext->LoggerMutex);
#endif
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmiUpdateTrace: Status2=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        return Status;
    }

    RtlZeroMemory(&NewLogFileName, sizeof(UNICODE_STRING));
    RequestorMode = KeGetPreviousMode();
    if (LoggerInfo->LogFileHandle != NULL) {
        PFILE_OBJECT    fileObject;
        OBJECT_HANDLE_INFORMATION handleInformation;
        ACCESS_MASK grantedAccess;
        LOGICAL bDelayOpenFlag;

        bDelayOpenFlag =  (LoggerContext->LogFileHandle == NULL &&
                          (LoggerContext->LoggerMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE));

        if (LoggerInfo->LogFileName.Buffer == NULL ||
            LoggerMode & EVENT_TRACE_FILE_MODE_NEWFILE ||
            NewMode & EVENT_TRACE_FILE_MODE_NEWFILE ) {
            // Do not allow snapping in or out of NEW_FILE mode.
            Status = STATUS_INVALID_PARAMETER;
            goto ReleaseAndExit;
        }
        // Save the new LogFileName
        //
        try {
            if (RequestorMode != KernelMode) {
                ProbeForRead(
                    LoggerInfo->LogFileName.Buffer,
                    LoggerInfo->LogFileName.Length,
                    sizeof (UCHAR) );
            }
            RtlCreateUnicodeString(
                &NewLogFileName,
                LoggerInfo->LogFileName.Buffer);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            if (NewLogFileName.Buffer != NULL) {
                RtlFreeUnicodeString(&NewLogFileName);
            }
#ifndef WMI_MUTEX_FREE
            InterlockedDecrement(&LoggerContext->MutexCount);
            TraceDebug((1, "WmiUpdateTrace: Release mutex3 %d %d\n",
                LoggerId, LoggerContext->MutexCount));
            WmipReleaseMutex(&LoggerContext->LoggerMutex);
#endif
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((1, "WmiUpdateTrace: Status5=EXCEPTION %d %d->%d\n",
                            LoggerId, RefCount+1, RefCount));
            return GetExceptionCode();
        }

        // Switching to a new logfile. This routine does not put any
        // headers into the logfile. The headers should be written out
        // by UpdateTrace() in user-mode.
        //
        fileObject = NULL;
        Status = ObReferenceObjectByHandle(
                    LoggerInfo->LogFileHandle,
                    0L,
                    IoFileObjectType,
                    RequestorMode,
                    (PVOID *) &fileObject,
                    &handleInformation);
        if (!NT_SUCCESS(Status)) {
            goto ReleaseAndExit;
        }

        if (RequestorMode != KernelMode) {
            grantedAccess = handleInformation.GrantedAccess;
            if (!SeComputeGrantedAccesses(grantedAccess, FILE_WRITE_DATA)) {
                ObDereferenceObject( fileObject );
                Status = STATUS_ACCESS_DENIED;
                goto ReleaseAndExit;
            }
        }
        ObDereferenceObject(fileObject); // Referenced in WmipCreateLogFile

        // Obtain the security context here so we can use it
        // later to impersonate the user, which we will do
        // if we cannot access the file as SYSTEM.  This
        // usually occurs if the file is on a remote machine.
        //
        ServiceQos.Length  = sizeof(SECURITY_QUALITY_OF_SERVICE);
        ServiceQos.ImpersonationLevel = SecurityImpersonation;
        ServiceQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        ServiceQos.EffectiveOnly = TRUE;
        Status = SeCreateClientSecurity(
                    CONTAINING_RECORD(KeGetCurrentThread(), ETHREAD, Tcb),
                    &ServiceQos,
                    FALSE,
                    & LoggerContext->ClientSecurityContext);
        if (!NT_SUCCESS(Status)) {
            goto ReleaseAndExit;
        }

        if (LoggerInfo->Checksum != NULL) {
            if (LoggerContext->LoggerHeader == NULL) {
                LoggerContext->LoggerHeader =
                    ExAllocatePoolWithTag(
                        PagedPool,
                        sizeof(WNODE_HEADER) + sizeof(TRACE_LOGFILE_HEADER),
                        TRACEPOOLTAG);
            }

    //
    // Although we allocate sizeof(WNODE_HEADER) + sizeof(TRACE_LOGFILE_HEADER)
    // chunk, we will only copy sizeof(WNODE_HEADER) + 
    // FIELD_OFFSET(TRACE_LOGFILE_HEADER, LoggerName) because we will not use 
    // the parts after the pointers. Also, this prevents AV when WOW UpdateTrace
    // calls are made with 32 bit TRACE_LOGFILE_HEADER.
    //

            if (LoggerContext->LoggerHeader != NULL) {
                RtlCopyMemory(
                    LoggerContext->LoggerHeader,
                    LoggerInfo->Checksum,
                    sizeof(WNODE_HEADER) + FIELD_OFFSET(TRACE_LOGFILE_HEADER, LoggerName));
            }
        }

        // We try to update the file name using LoggerContext->NewLogFileName.
        // This is freed by WmipCreateLogFile() in the logger thread. 
        // This have to be NULL. 
        if (NewLogFileName.Buffer != NULL) {
            ASSERT(LoggerContext->NewLogFileName.Buffer == NULL);
            LoggerContext->NewLogFileName = NewLogFileName;
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
            goto ReleaseAndExit;
        }

        //
        // Reset the event inside the mutex before waiting on it. 
        //
        KeResetEvent(&LoggerContext->FlushEvent);

        ZwClose(LoggerInfo->LogFileHandle);
        LoggerInfo->LogFileHandle = NULL;

        // must turn on flag just before releasing semaphore
        LoggerContext->RequestFlag |= REQUEST_FLAG_NEW_FILE;
        // Wake up the logger thread (system) to change the file
        Status = WmipNotifyLogger(LoggerContext);
        if (!NT_SUCCESS(Status)) {
            goto ReleaseAndExit;
        }
        // use the same event initialized by start logger
        //
        KeWaitForSingleObject(
            &LoggerContext->FlushEvent,
            Executive,
            KernelMode,
            FALSE,
            &TimeOut
            );
        KeResetEvent(&LoggerContext->FlushEvent);
        Status = LoggerContext->LoggerStatus;

        if (!NT_SUCCESS(Status) || !LoggerContext->CollectionOn) {
            goto ReleaseAndExit;
        }

        if (bDelayOpenFlag && (LoggerContext->LoggerId == WmipKernelLogger)) {
            LONG PerfLogInTransition;
            //
            // This is a update call from advapi32.dll after RunDown.
            // Call PerfInfoStartLog.
            //

            if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &EnableFlags;
                if ((FlagExt->Length == 0) || (FlagExt->Offset == 0)) {
                    Status = STATUS_INVALID_PARAMETER;
                    goto ReleaseAndExit;
                }
                if ((FlagExt->Length * sizeof(ULONG)) >
                    (LoggerInfo->Wnode.BufferSize - FlagExt->Offset)) {
                    Status = STATUS_INVALID_PARAMETER;
                    goto ReleaseAndExit;
                }
                GroupMaskSize = FlagExt->Length * sizeof(ULONG);
                if (GroupMaskSize < sizeof(PERFINFO_GROUPMASK)) {
                    GroupMaskSize = sizeof(PERFINFO_GROUPMASK);
                }
            } else {
                GroupMaskSize = sizeof(PERFINFO_GROUPMASK);
            }

            LoggerContext->EnableFlagArray = (PULONG) WmipExtendBase(LoggerContext, GroupMaskSize);

            if (LoggerContext->EnableFlagArray) {
                PCHAR FlagArray;

                RtlZeroMemory(LoggerContext->EnableFlagArray, GroupMaskSize);
                if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                    FlagArray = (PCHAR) (FlagExt->Offset + (PCHAR) LoggerInfo);
            
                    //
                    // Copy only the bytes actually supplied
                    //
                    RtlCopyMemory(LoggerContext->EnableFlagArray, FlagArray, FlagExt->Length * sizeof(ULONG));
            
                    EnableFlags = LoggerContext->EnableFlagArray[0];
            
                } else {
                    LoggerContext->EnableFlagArray[0] = EnableFlags;
                }
                // We need to protect PerfInfoStartLog from stopping thread.
                PerfLogInTransition =
                    InterlockedCompareExchange(&LoggerContext->PerfLogInTransition,
                                PERF_LOG_START_TRANSITION,
                                PERF_LOG_NO_TRANSITION);
                if (PerfLogInTransition != PERF_LOG_NO_TRANSITION) {
                    Status = STATUS_ALREADY_DISCONNECTED;
                    goto ReleaseAndExit;
                }
                PerfGroupMasks = (PERFINFO_GROUPMASK *) &LoggerContext->EnableFlagArray[0];
                Status = PerfInfoStartLog(PerfGroupMasks, PERFINFO_START_LOG_POST_BOOT);
                PerfLogInTransition =
                    InterlockedExchange(&LoggerContext->PerfLogInTransition,
                                PERF_LOG_NO_TRANSITION);
                ASSERT(PerfLogInTransition == PERF_LOG_START_TRANSITION);
                if (!NT_SUCCESS(Status)) {
                    goto ReleaseAndExit;
                }

            } else {
                Status = STATUS_NO_MEMORY;
                goto ReleaseAndExit;
            }
        }
    }

    if (LoggerContext->KernelTraceOn &&
        LoggerId == WmipKernelLogger &&
        IsEqualGUID(&LoggerInfo->Wnode.Guid, &SystemTraceControlGuid)) {
        TmpFlags = (~LoggerContext->EnableFlags & EnableFlags);
        if (TmpFlags != 0) {
            WmipEnableKernelTrace(TmpFlags);
        }
        TmpFlags = (LoggerContext->EnableFlags & ~EnableFlags);
        if (TmpFlags != 0) {
            WmipDisableKernelTrace(TmpFlags);
        }
        LoggerContext->EnableFlags = EnableFlags;
    }

    //
    // Cap Maximum Buffers to Max_Buffers
    //

    if ( LoggerInfo->MaximumBuffers > 0 ) {
        Max_Buffers = (LoggerContext->BufferSize > 0) ? 
                           (ULONG) (MmMaximumNonPagedPoolInBytes
                            / TRACE_MAXIMUM_NP_POOL_USAGE
                            / LoggerContext->BufferSize)
                        : 0;

        if (LoggerInfo->MaximumBuffers > Max_Buffers ) {
            LoggerInfo->MaximumBuffers = Max_Buffers;
        }
        if (LoggerInfo->MaximumBuffers > LoggerContext->MaximumBuffers) {
            LoggerContext->MaximumBuffers = LoggerInfo->MaximumBuffers;
        }

    }

#ifdef NTPERF
    if (PERFINFO_IS_LOGGING_TO_PERFMEM()) {
        //
        // Logging to Perfmem.  The Maximum should be the perfmem size.
        //
        LoggerContext->MaximumBuffers = PerfQueryBufferSizeBytes()/LoggerContext->BufferSize;
    }
#endif //NTPERF

    // Allow changing of FlushTimer
    if (LoggerInfo->FlushTimer > 0) {
        LoggerContext->FlushTimer = LoggerInfo->FlushTimer;
    }

    if (NewMode & EVENT_TRACE_KD_FILTER_MODE) {
        LoggerMode |= EVENT_TRACE_KD_FILTER_MODE;
        LoggerContext->BufferCallback = &KdReportTraceData;
    }
    else {
        LoggerMode &= ~EVENT_TRACE_KD_FILTER_MODE;
        if (LoggerContext->BufferCallback == &KdReportTraceData) {
            LoggerContext->BufferCallback = NULL;
        }
    }
    if (LoggerContext->LoggerMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE) {
        LoggerContext->LoggerMode = LoggerMode;
    }
    else {
        LoggerContext->LoggerMode = 
            (LoggerMode & ~EVENT_TRACE_DELAY_OPEN_FILE_MODE);
    }
    Status = WmipQueryLogger(LoggerInfo, LoggerContext);

ReleaseAndExit:
#ifndef WMI_MUTEX_FREE
    InterlockedDecrement(&LoggerContext->MutexCount);
    TraceDebug((1, "WmiUpdateTrace: Release mutex5 %d %d\n",
        LoggerId, LoggerContext->MutexCount));
    WmipReleaseMutex(&LoggerContext->LoggerMutex);
#endif

#if DBG
    RefCount =
#endif
    WmipDereferenceLogger(LoggerId);
    TraceDebug((1, "WmiUpdateTrace: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    return Status;
}


NTKERNELAPI
NTSTATUS
WmiFlushTrace(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    It is called by WmipIoControl in wmi.c, with IOCTL_WMI_FLUSH_LOGGER
    to flush all the buffers out of a particular logger

Arguments:

    LoggerInfo      a pointer to the structure for the logger's control
                    and status information

Return Value:

    The status of performing the action requested.

--*/

{
    NTSTATUS Status;
    PWMI_LOGGER_CONTEXT LoggerContext = NULL;
    ACCESS_MASK     DesiredAccess = TRACELOG_GUID_ENABLE;
    ULONG           LoggerId;
    ULONG           LoggerMode;
#if DBG
    LONG            RefCount;
#endif

    PAGED_CODE();
    //
    // see if Logger is running properly first. Error checking will be done
    // in WmiQueryTrace
    //

    if (LoggerInfo == NULL)
        return STATUS_INVALID_PARAMETER;

    TraceDebug((1, "WmiFlushTrace: %d\n",
                    LoggerInfo->Wnode.HistoricalContext));
#if DBG
    Status = WmipVerifyLoggerInfo(LoggerInfo, &LoggerContext, "WmiFlushTrace");
#else
    Status = WmipVerifyLoggerInfo(LoggerInfo, &LoggerContext);
#endif
    if (!NT_SUCCESS(Status) || (LoggerContext == NULL))
        return Status;

    LoggerId = LoggerContext->LoggerId;

    LoggerMode = LoggerContext->LoggerMode;
    if (LoggerMode & EVENT_TRACE_REAL_TIME_MODE) {
        DesiredAccess |= TRACELOG_CREATE_REALTIME;
    } 
    if (LoggerInfo->LogFileHandle != NULL) {
        DesiredAccess |= TRACELOG_CREATE_ONDISK;
    }
    if (LoggerContext->KernelTraceOn) {
        DesiredAccess |= TRACELOG_ACCESS_KERNEL_LOGGER;
    }
    Status = WmipCheckGuidAccess(
                &LoggerContext->InstanceGuid,
                DesiredAccess,
                EtwpDefaultTraceSecurityDescriptor
                );
    if (!NT_SUCCESS(Status)) {
#ifndef WMI_MUTEX_FREE
        InterlockedDecrement(&LoggerContext->MutexCount);
        TraceDebug((1, "WmiFlushTrace: Release mutex1 %d %d\n",
            LoggerContext->LoggerId, LoggerContext->MutexCount));
        WmipReleaseMutex(&LoggerContext->LoggerMutex);
#endif
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmiFlushTrace: Status2=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        return Status;
    }

    Status = WmipFlushLogger(LoggerContext, TRUE);
    if (NT_SUCCESS(Status)) {
        Status = WmipQueryLogger(LoggerInfo, LoggerContext);
    }
#ifndef WMI_MUTEX_FREE
    InterlockedDecrement(&LoggerContext->MutexCount);
    TraceDebug((1, "WmiFlushTrace: Release mutex %d %d\n",
        LoggerContext->LoggerId, LoggerContext->MutexCount));
    WmipReleaseMutex(&LoggerContext->LoggerMutex);
#endif
#if DBG
    RefCount =
#endif
    WmipDereferenceLogger(LoggerId);
    TraceDebug((1, "WmiFlushTrace: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    return Status;
}

//
// Trace Provider APIs
//
NTKERNELAPI
NTSTATUS
FASTCALL
WmiGetClockType(
    IN TRACEHANDLE LoggerHandle,
    OUT WMI_CLOCK_TYPE  *ClockType
    )
/*++

Routine Description:

    This is called by anyone internal to find the clock type 
    that is in use with a logger specified by the LoggerHandle

Arguments:

    LoggerHandle         Handle to a tracelog session

Return Value:

    The clock type

--*/

{
    ULONG   LoggerId;
#if DBG
    LONG    RefCount;
#endif
    PWMI_LOGGER_CONTEXT LoggerContext;

    LoggerId = WmiGetLoggerId(LoggerHandle);
    if (LoggerId < 1 || LoggerId >= MAXLOGGERS)
       return STATUS_INVALID_HANDLE;
#if DBG
 RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((4, "WmiGetClockType: %d %d->%d\n",
                 LoggerId, RefCount-1, RefCount));

    LoggerContext = WmipGetLoggerContext( LoggerId );
    if (!WmipIsValidLogger(LoggerContext)) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmiGetClockType: Status=%X %d %d->%d\n",
                        STATUS_WMI_INSTANCE_NOT_FOUND,
                        LoggerId, RefCount+1, RefCount));
        return STATUS_WMI_INSTANCE_NOT_FOUND;
    }

    *ClockType = WMICT_SYSTEMTIME;    // Default Clock Type

    if (LoggerContext->UsePerfClock & EVENT_TRACE_CLOCK_PERFCOUNTER) {
        *ClockType = WMICT_PERFCOUNTER;
    }
    else if (LoggerContext->UsePerfClock & EVENT_TRACE_CLOCK_CPUCYCLE) {
        *ClockType = WMICT_CPUCYCLE;
    }

#if DBG
    RefCount =
#endif
    WmipDereferenceLogger(LoggerId);

    return STATUS_SUCCESS;

}


NTKERNELAPI
LONG64
FASTCALL
WmiGetClock(
    IN WMI_CLOCK_TYPE ClockType,
    IN PVOID Context
    )
/*++

Routine Description:

    This is called anyone internal to use a particular clock for
    sequencing events.

Arguments:

    ClockType       Should use WMICT_DEFAULT most of the time.
                    Other clock types are for perf group.
    Context         Only used for process/thread times

Return Value:

    The clock value

--*/

{
    LARGE_INTEGER Clock;

    switch (ClockType) {
        case WMICT_DEFAULT :
            Clock.QuadPart = (*WmiGetCpuClock)();
            break;
        case WMICT_SYSTEMTIME:
            Clock.QuadPart = WmipGetSystemTime();
            break;
        case WMICT_PERFCOUNTER:
            Clock.QuadPart = WmipGetPerfCounter();
            break;
        case WMICT_PROCESS :  // defaults to Process times for now
        {
            PEPROCESS Process = (PEPROCESS) Context;
            if (Process == NULL)
                Process = PsGetCurrentProcess();
            else {
                ObReferenceObject(Process);
            }
            Clock.HighPart = Process->Pcb.KernelTime;
            Clock.LowPart  = Process->Pcb.UserTime;
            if (Context) {
                ObDereferenceObject(Process);
            }
            break;
        }
        case WMICT_THREAD  :  // defaults to Thread times for now
        {
            PETHREAD Thread = (PETHREAD) Context;
            if (Thread == NULL)
                Thread = PsGetCurrentThread();
            else {
                ObReferenceObject(Thread);
            }
            Clock.HighPart = Thread->Tcb.KernelTime;
            Clock.LowPart  = Thread->Tcb.UserTime;
            if (Context) {
                ObDereferenceObject(Thread);
            }
            break;
        }
        default :
            KeQuerySystemTime(&Clock);
    }
    return ((LONG64) Clock.QuadPart);
}


NTSYSCALLAPI
NTSTATUS
NTAPI
NtTraceEvent(
    IN HANDLE TraceHandle,
    IN ULONG  Flags,
    IN ULONG  FieldSize,
    IN PVOID  Fields
    )
/*++
Routine Description:

    This routine is used by WMI data providers to trace events.
    It calls different tracing functions depending on the Flags.

Arguments:

    TraceHandle     LoggerId
    Flags           Flags that indicate the type of the data being passed
    FieldSize       Size of the Fields
    Fields          Pointer to actual data (events)

Return Value:

    STATUS_SUCCESS  if the event trace is recorded successfully

--*/
{
    NTSTATUS Status;
    if (Flags & ETW_NT_FLAGS_TRACE_HEADER) {

retry:
        Status = WmiTraceEvent((PWNODE_HEADER)Fields, KeGetPreviousMode());

        if (Status == STATUS_NO_MEMORY) {
            //
            // This logging is from user mode, try to allocate more buffer.
            //
            PWNODE_HEADER Wnode = (PWNODE_HEADER) Fields;
            ULONG LoggerId = WmiGetLoggerId(Wnode->HistoricalContext);
            PWMI_LOGGER_CONTEXT LoggerContext;

            if (LoggerId < 1 || LoggerId >= MAXLOGGERS) {
                Status = STATUS_INVALID_HANDLE;
            } else {
                WmipReferenceLogger(LoggerId);

                LoggerContext = WmipGetLoggerContext(LoggerId);

                //
                // Make sure collection is still on before allocate more
                // free buffers.  This makes sure that logger thread
                // can free all allocated buffers.
                //
                if (WmipIsValidLogger(LoggerContext) && 
                                LoggerContext->CollectionOn) 
                {
                    if (WmipAllocateFreeBuffers (LoggerContext, 1) == 1) {
                        WmipDereferenceLogger(LoggerId);
                        InterlockedDecrement((PLONG)&LoggerContext->EventsLost);
                        goto retry;
                    } else {
                        Status = STATUS_NO_MEMORY;
                    }
                }
                WmipDereferenceLogger(LoggerId);
            }
        }
    }
    else if (Flags & ETW_NT_FLAGS_TRACE_MESSAGE) {
        if (FieldSize < sizeof(MESSAGE_TRACE_USER)) {
            return (STATUS_UNSUCCESSFUL);
        }
        try {
            ProbeForRead(
                    Fields,
                    FieldSize,
                    sizeof (UCHAR)
                    );
            return (WmiTraceMessage((TRACEHANDLE)TraceHandle,
                                    ((PMESSAGE_TRACE_USER)Fields)->MessageFlags,
                                    &((PMESSAGE_TRACE_USER)Fields)->MessageGuid,
                                    ((PMESSAGE_TRACE_USER)Fields)->MessageHeader.Packet.MessageNumber,
                                    &((PMESSAGE_TRACE_USER)Fields)->Data,
                                    ((PMESSAGE_TRACE_USER)Fields)->DataSize,
                                    NULL,0));

        } except  (EXCEPTION_EXECUTE_HANDLER) {
            TraceDebug((1, "NtTraceEvent: (ETW_NT_FLAGS_TRACE_MESSAGE) Status=EXCEPTION\n"));
            return GetExceptionCode();
        }
    }
    else {
        Status = STATUS_INVALID_PARAMETER;
    }
    return Status;
}


NTKERNELAPI
NTSTATUS
FASTCALL
WmiTraceEvent(
    IN PWNODE_HEADER Wnode,
    IN KPROCESSOR_MODE RequestorMode
    )
/*++

Routine Description:

    This routine is used by WMI data providers to trace events.
    It expects the user to pass in the handle to the logger.
    Also, the user cannot ask to log something that is larger than
    the buffer size (minus buffer header).

    This routine works at IRQL <= DISPATCH_LEVEL

Arguments:

    Wnode           The WMI node header that will be overloaded


Return Value:

    STATUS_SUCCESS  if the event trace is recorded successfully

--*/
{
    PEVENT_TRACE_HEADER TraceRecord = (PEVENT_TRACE_HEADER) Wnode;
    ULONG WnodeSize, Size, LoggerId = 0, Flags, HeaderSize;
    PWMI_BUFFER_HEADER BufferResource = NULL;
    NTSTATUS Status;
    PETHREAD Thread;
    PWMI_LOGGER_CONTEXT LoggerContext = NULL;
    ULONG Marker;
    MOF_FIELD MofFields[MAX_MOF_FIELDS];
    long MofCount = 0;
    LONG LoggerLocked = 0;
    LARGE_INTEGER TimeStamp;
#if DBG
    LONG RefCount = 0;
#endif

    if (TraceRecord == NULL)
        return STATUS_SEVERITY_WARNING;

    HeaderSize = sizeof(WNODE_HEADER);  // same size as EVENT_TRACE_HEADER

    try {

        if (RequestorMode != KernelMode) {
            ProbeForRead(
                TraceRecord,
                sizeof (EVENT_TRACE_HEADER),
                sizeof (UCHAR)
                );

            Marker = Wnode->BufferSize;     // check the first DWORD flags
            Size = Marker;

            if (Marker & TRACE_HEADER_FLAG) {
                if ( ((Marker & TRACE_HEADER_ENUM_MASK) >> 16)
                        == TRACE_HEADER_TYPE_INSTANCE )
                    HeaderSize = sizeof(EVENT_INSTANCE_GUID_HEADER);
                Size = TraceRecord->Size;
            }
        }
        else {
            Size = Wnode->BufferSize;     // take the first DWORD flags
            Marker = Size;
            if (Marker & TRACE_HEADER_FLAG) {
                if ( ((Marker & TRACE_HEADER_ENUM_MASK) >> 16)
                        == TRACE_HEADER_TYPE_INSTANCE )
                    HeaderSize = sizeof(EVENT_INSTANCE_GUID_HEADER);
                Size = TraceRecord->Size;
            }
        }
        WnodeSize = Size;           // WnodeSize is for the contiguous block
                                    // Size is for what we want in buffer

        Flags = Wnode->Flags;
        if (!(Flags & WNODE_FLAG_LOG_WNODE) &&
            !(Flags & WNODE_FLAG_TRACED_GUID)) {
            return STATUS_UNSUCCESSFUL;
        }

        LoggerId = WmiGetLoggerId(Wnode->HistoricalContext);
        if (LoggerId < 1 || LoggerId >= MAXLOGGERS) {
            return STATUS_INVALID_HANDLE;
        }

        LoggerLocked = WmipReferenceLogger(LoggerId);
#if DBG
        RefCount = LoggerLocked;
#endif
        TraceDebug((4, "WmiTraceEvent: %d %d->%d\n",
                        LoggerId, RefCount-1, RefCount));
        LoggerContext = WmipGetLoggerContext(LoggerId);
        if (!WmipIsValidLogger(LoggerContext)) {
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceEvent: Status1=%X %d %d->%d\n",
                            STATUS_INVALID_HANDLE, LoggerId,
                            RefCount+1, RefCount));
            return STATUS_INVALID_HANDLE;
        }

        if ((RequestorMode == KernelMode) &&
            (LoggerContext->LoggerMode & EVENT_TRACE_USE_PAGED_MEMORY)) {
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceEvent: Status1=%X %d %d->%d\n",
                            STATUS_UNSUCCESSFUL, LoggerId,
                            RefCount+1, RefCount));
            return STATUS_UNSUCCESSFUL;
        }

        if (Flags & WNODE_FLAG_USE_MOF_PTR) {
        //
        // Need to compute the total size required, since the MOF fields
        // in Wnode merely contains pointers
        //
            long i;
            PCHAR Offset = ((PCHAR)Wnode) + HeaderSize;
            ULONG MofSize, MaxSize;

            MaxSize = LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER);
            MofSize = WnodeSize - HeaderSize;
            // allow only the maximum
            if (MofSize > (sizeof(MOF_FIELD) * MAX_MOF_FIELDS)) {
                WmipDereferenceLogger(LoggerId);
                return STATUS_ARRAY_BOUNDS_EXCEEDED;
            }
            if (MofSize > 0) {               // Make sure we can read the rest
                if (RequestorMode != KernelMode) {
                    ProbeForRead( Offset, MofSize, sizeof (UCHAR) );
                }
                RtlCopyMemory(MofFields, Offset, MofSize);
            }
            Size = HeaderSize;

            MofCount = MofSize / sizeof(MOF_FIELD);
            for (i=0; i<MofCount; i++) {
                MofSize = MofFields[i].Length;
                if (MofSize >= (MaxSize - Size)) {  // check for overflow first
#if DBG
                    RefCount =
#endif
                    WmipDereferenceLogger(LoggerId);
                    TraceDebug((4, "WmiTraceEvent: Status2=%X %d %d->%d\n",
                                    STATUS_BUFFER_OVERFLOW, LoggerId,
                                    RefCount+1, RefCount));
                    return STATUS_BUFFER_OVERFLOW;
                }

                Size += MofSize;
            }
        }

        if ((LoggerContext->RequestFlag & REQUEST_FLAG_CIRCULAR_PERSIST) &&
            (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_CIRCULAR)) {
            if (! (Flags & WNODE_FLAG_PERSIST_EVENT) ) {
                ULONG RequestFlag = LoggerContext->RequestFlag
                                  & (~ (  REQUEST_FLAG_CIRCULAR_PERSIST
                                        | REQUEST_FLAG_CIRCULAR_TRANSITION));

                if (InterlockedCompareExchange(
                              (PLONG) &LoggerContext->RequestFlag,
                              RequestFlag | REQUEST_FLAG_CIRCULAR_TRANSITION,
                              RequestFlag | REQUEST_FLAG_CIRCULAR_PERSIST)) {

                    // All persistence events are fired in circular
                    // logfile, flush out all active buffers and flushlist
                    // buffers. Also mark the end of persistence event
                    // collection in circular logger.
                    //
                    // It is the provider's resposibility to ensure that 
                    // no persist event fires after this point. If it did,
                    // that event may be  overwritten during wrap around.
                    //
                    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
                        Status = WmipFlushLogger(LoggerContext, TRUE);
                    }
                }
            }
        }

// So, now reserve some space in logger buffer and set that to TraceRecord

        TraceRecord = (PEVENT_TRACE_HEADER)
            WmipReserveTraceBuffer( LoggerContext,
                                    Size,
                                    &BufferResource,
                                    &TimeStamp);

        if (TraceRecord == NULL) {
#if DBG
        RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceEvent: Status4=%X %d %d->%d\n",
                            STATUS_NO_MEMORY, LoggerId,
                            RefCount+1, RefCount));
            return STATUS_NO_MEMORY;
        }

        if (Flags & WNODE_FLAG_USE_MOF_PTR) {
        //
        // Now we need to probe and copy all the MOF data fields
        //
            PVOID MofPtr;
            ULONG MofLen;
            long i;
            PCHAR TraceOffset = (PCHAR) TraceRecord + HeaderSize;

            if (RequestorMode != KernelMode) {
                ProbeForRead(Wnode, HeaderSize, sizeof(UCHAR));
            }
            RtlCopyMemory(TraceRecord, Wnode, HeaderSize);
            TraceRecord->Size = (USHORT)Size;           // reset to Total Size
            for (i=0; i<MofCount; i++) {
                MofPtr = (PVOID) (ULONG_PTR) MofFields[i].DataPtr;
                MofLen = MofFields[i].Length;

                if (MofPtr == NULL || MofLen == 0)
                    continue;

                if (RequestorMode != KernelMode) {
                    ProbeForRead(MofPtr, MofLen, sizeof(UCHAR));
                }
                RtlCopyMemory(TraceOffset, MofPtr, MofLen);
                TraceOffset += MofLen;
            }
        }
        else {
            if (RequestorMode != KernelMode) {
                ProbeForRead(Wnode, Size, sizeof(UCHAR));
            }
            RtlCopyMemory(TraceRecord, Wnode, Size);
        }
        if (Flags & WNODE_FLAG_USE_GUID_PTR) {
            PVOID GuidPtr = (PVOID) (ULONG_PTR) ((PEVENT_TRACE_HEADER)Wnode)->GuidPtr;

            if (RequestorMode != KernelMode) {
                ProbeForReadSmallStructure(GuidPtr, sizeof(GUID), sizeof(UCHAR));
            }
            RtlCopyMemory(&TraceRecord->Guid, GuidPtr, sizeof(GUID));
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        if (BufferResource != NULL) {
            WmipReleaseTraceBuffer ( BufferResource, LoggerContext );
        }
        else {
            if (LoggerLocked) {
#if DBG
                RefCount =
#endif
                WmipDereferenceLogger(LoggerId);
            }
        }
        TraceDebug((4, "WmiTraceEvent: Status5=EXCEPTION %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));
        return GetExceptionCode();
    }

    //
    // By now, we have reserved space in the trace buffer
    //

    if (Marker & TRACE_HEADER_FLAG) {
        if (! (WNODE_FLAG_USE_TIMESTAMP & TraceRecord->Flags) ) {
            TraceRecord->TimeStamp = TimeStamp;
        }
        Thread = PsGetCurrentThread();
        if (Thread != NULL) {
            TraceRecord->KernelTime = Thread->Tcb.KernelTime;
            TraceRecord->UserTime   = Thread->Tcb.UserTime;
            TraceRecord->ThreadId   = HandleToUlong(Thread->Cid.UniqueThread);
            TraceRecord->ProcessId  = HandleToUlong(Thread->Cid.UniqueProcess);
        }
    }

    WmipReleaseTraceBuffer( BufferResource, LoggerContext );
    TraceDebug((4, "WmiTraceEvent: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    return STATUS_SUCCESS;
}


NTKERNELAPI
NTSTATUS
WmiTraceKernelEvent(
    IN ULONG GroupType,         // Group/type code for kernel event
    IN PVOID EventInfo,         // Event data as defined in MOF
    IN ULONG EventInfoLen,      // Length of the event data
    IN PETHREAD Thread )        // use NULL for current caller thread
/*++

Routine Description:

    This routine is used by trace kernel events only. These events can
    be charged to the given thread instead of the running thread. Because
    it can be called by I/O events at DPC level, this routine cannot be
    pageable when tracing is on.

    This routine works at IRQL <= DISPATCH_LEVEL

Arguments:

    GroupType       a ULONG key to indicate the action to be taken

    EventInfo       a pointer to contiguous memory containing information
                    to be attached to event trace

    EventInfoLen    length of EventInfo

    Thread          Pointer to thread where event is to be charged.
                    Currently used by disk IO and thread events.

Return Value:

    The status of performing the action requested

--*/
{
    PSYSTEM_TRACE_HEADER Header;
    ULONG Size;
    PWMI_BUFFER_HEADER BufferResource = NULL;
    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext[WmipKernelLogger];
    LARGE_INTEGER TimeStamp;
#if DBG
    LONG    RefCount;
#endif

#if DBG
    RefCount =
#endif
    WmipReferenceLogger(WmipKernelLogger);
    TraceDebug((4, "WmiTraceKernelEvent: 0 %d->%d\n", RefCount-1, RefCount));
// Make sure that kernel logger is enabled first
    if (!WmipIsValidLogger(LoggerContext)) {
        WmipDereferenceLogger(WmipKernelLogger);
        return STATUS_ALREADY_DISCONNECTED;
    }

// Compute total size of event trace record
    Size = sizeof(SYSTEM_TRACE_HEADER) + EventInfoLen;

    Header = (PSYSTEM_TRACE_HEADER)
            WmipReserveTraceBuffer( LoggerContext,
                                    Size,
                                    &BufferResource,
                                    &TimeStamp);

    if (Header == NULL) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(WmipKernelLogger);
        TraceDebug((4, "WmiTraceKernelEvent: Status1=%X 0 %d->%d\n",
                        STATUS_NO_MEMORY, RefCount+1, RefCount));
        return STATUS_NO_MEMORY;
    }

    // Get the current system time as time stamp for trace record
    Header->SystemTime = TimeStamp;

    if (Thread == NULL) {
        Thread = PsGetCurrentThread();
    }

//
// Now copy the necessary information into the buffer
//

    Header->Marker       = SYSTEM_TRACE_MARKER;
    Header->ThreadId     = HandleToUlong(Thread->Cid.UniqueThread);
    Header->ProcessId    = HandleToUlong(Thread->Cid.UniqueProcess);
    Header->KernelTime   = Thread->Tcb.KernelTime;
    Header->UserTime     = Thread->Tcb.UserTime;

    Header->Header       = (GroupType << 16) + Size;

    if (EventInfoLen > 0) {
        RtlCopyMemory (
            (UCHAR*) Header + sizeof(SYSTEM_TRACE_HEADER),
            EventInfo, EventInfoLen);
    }

#if DBG
    RefCount = WmipRefCount[LoggerContext->LoggerId] - 1;
#endif
    WmipReleaseTraceBuffer( BufferResource, LoggerContext );
    TraceDebug((4, "WmiTraceKernelEvent: 0 %d->%d\n",
                    RefCount+1, RefCount));

    return STATUS_SUCCESS;
}

#if 0

NTKERNELAPI
NTSTATUS
WmiTraceLongEvent(
    IN ULONG GroupType,
    IN PMOF_FIELD EventFields,
    IN ULONG FieldCount,
    IN PETHREAD Thread
    )
/*++

Routine Description:

    This routine is used by trace kernel events with long traces only.
    These events can be charged to the given thread instead of the running
    thread. Because it can be called by I/O events at DPC level, this routine
    cannot be pageable when tracing is on.

    This routine is used to trace filenames.

    This routine works at IRQL <= DISPATCH_LEVEL

Arguments:

    GroupType       a ULONG key to indicate the action to be taken

    EventFields     an array of structures describing each field
                    to be attached to event trace

    FieldCount      number of array entries in EventFields

    Thread          Pointer to thread where event is to be charged.

Return Value:

    The status of performing the action requested

--*/
{
    PSYSTEM_TRACE_HEADER Header;
    ULONG Size, i, maxLength;
    PWMI_BUFFER_HEADER BufferResource;
    NTSTATUS Status;
    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext[WmipKernelLogger];
    char *auxInfo;
#if DBG
    LONG RefCount;
#endif

// Make sure that kernel logger is enabled first
    if (LoggerContext == NULL)
        return STATUS_ALREADY_DISCONNECTED;

#if DBG
        RefCount =
#endif
    WmipReferenceLogger(WmipKernelLogger);
    /* Compute total size of event trace record */
    Size = sizeof(SYSTEM_TRACE_HEADER);
    maxLength = LoggerContext->BufferSize / 2;
    for (i=0; i<FieldCount; i++) {
        Size += EventFields[i].Length;
    }

    Header = (PSYSTEM_TRACE_HEADER)
             WmipReserveTraceBuffer(
                LoggerContext,
                Size,
                &BufferResource
                );

    if (Header == NULL) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(WmipKernelLogger);
        return STATUS_NO_MEMORY;
    }

    // Get the current system time as time stamp for trace record
    Header->SystemTime.QuadPart = (*LoggerContext->GetCpuClock)();

    if (Thread == NULL) {
        Thread = PsGetCurrentThread();
    }

//
// Now copy the necessary information into the buffer
//

    Header->Marker       = SYSTEM_TRACE_MARKER;
    Header->ThreadId     = HandleToUlong(Thread->Cid.UniqueThread);
    Header->ProcessId    = HandleToUlong(Thread->Cid.UniqueProcess);
    Header->KernelTime   = Thread->Tcb.KernelTime;
    Header->UserTime     = Thread->Tcb.UserTime;

    Header->Header       = (GroupType << 16) + Size;


    auxInfo = (char *) Header +  sizeof(SYSTEM_TRACE_HEADER);
    for (i=0; i<FieldCount; i++) {
        Size = EventFields[i].Length;

// For NT5, do not support large events
/*        if (Size > maxLength) {
            RtlCopyMemory(auxInfo, (PVOID) EventFields[i].DataPtr, maxLength/2);
            EventFields[i].DataPtr = (ULONGLONG)
                                        ((char*) EventFields[i].DataPtr +
                                                 (maxLength / 2));
            EventFields[i].Length -= maxLength / 2;
            GroupType &= 0xFFFFFF00;    // turn off event to info

            WmiTraceLongEvent(GroupType,
                &EventFields[i], FieldCount + 1 - i, Thread);
            break;
        }
*/
        RtlCopyMemory ( auxInfo, (PVOID) EventFields[i].DataPtr, Size);
        auxInfo += Size;
    }

    WmipReleaseTraceBuffer( BufferResource, LoggerContext );

    return STATUS_SUCCESS;
}
#endif


NTKERNELAPI
NTSTATUS
FASTCALL
WmiTraceFastEvent(
    IN PWNODE_HEADER Wnode
    )
/*++

Routine Description:

    This routine is used by short events using abbreviated header.

    This routine should work at any IRQL.

Arguments:

    Wnode           Header of event to record


Return Value:

    The status of performing the action requested

--*/
{
    ULONG Size;
    PTIMED_TRACE_HEADER Buffer;
    PTIMED_TRACE_HEADER Header = (PTIMED_TRACE_HEADER) Wnode;
    PWMI_BUFFER_HEADER BufferResource;
    ULONG LoggerId = (ULONG) Header->LoggerId; // get the lower ULONG!!
    PULONG Marker;
    PWMI_LOGGER_CONTEXT LoggerContext;
    LARGE_INTEGER TimeStamp;
#if DBG
    LONG RefCount;
#endif

    Marker = (PULONG) Wnode;
    if ((LoggerId == WmipKernelLogger) || (LoggerId >= MAXLOGGERS))
        return STATUS_INVALID_HANDLE;

    if ((*Marker & 0xF0000000) == TRACE_HEADER_ULONG32_TIME) {
        Size = Header->Size;
        if (Size == 0)
            return STATUS_INVALID_BUFFER_SIZE;
#if DBG
        RefCount =
#endif
        WmipReferenceLogger(LoggerId);
        LoggerContext = WmipGetLoggerContext(LoggerId);
        if (!WmipIsValidLogger(LoggerContext)) {
#if DBG
        RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            return STATUS_INVALID_HANDLE;
        }
        Buffer = WmipReserveTraceBuffer(LoggerContext, 
                                        Size, 
                                        &BufferResource,
                                        &TimeStamp);
        if (Buffer == NULL) {
#if DBG
        RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            return STATUS_NO_MEMORY;
        }
        (* (PULONG) Buffer) = *Marker;
        Buffer->EventId = Header->EventId;
        Buffer->TimeStamp = TimeStamp;

        RtlCopyMemory(Buffer+1, Header+1, Size-(sizeof(TIMED_TRACE_HEADER)));
        WmipReleaseTraceBuffer(BufferResource, LoggerContext);
        return STATUS_SUCCESS;
    }
    TraceDebug((4, "WmiTraceFastEvent: Invalid header %X\n", *Marker));
    return STATUS_INVALID_PARAMETER;
}

NTKERNELAPI
NTSTATUS
WmiTraceMessage(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    ...
)
/*++
Routine Description:
This routine is used by WMI data providers to trace Messages.
It expects the user to pass in the handle to the logger.
Also, the user cannot ask to log something that is larger than
the buffer size (minus buffer header).

Arguments:
//    IN TRACEHANDLE LoggerHandle   - LoggerHandle obtained earlier
//    IN ULONG MessageFlags,        - Flags which both control what standard values are logged and
//                                    the lower 16-bits are also included in the message header
//                                    to control decoding
//    IN PGUID MessageGuid,         - Pointer to the message GUID of this set of messages or if
//                                    TRACE_COMPONENTID is set the actual compnent ID
//    IN USHORT MessageNumber,      - The type of message being logged, associates it with the 
//                                    appropriate format string  
//    ...                           - List of arguments to be processed with the format string
//                                    these are stored as pairs of
//                                      PVOID - ptr to argument
//                                      ULONG - size of argument
//                                    and terminated by a pointer to NULL, length of zero pair.


Return Value:
STATUS_SUCCESS if the event trace is recorded successfully

NOTE:
        this routine is called from WmiTraceUserMessage path via an IOCTL so the probes and
        try/excepts have to be carefully managed
--*/
{
    va_list MessageArgList ;

    va_start(MessageArgList,MessageNumber);

    return (WmiTraceMessageVa(LoggerHandle,
                              MessageFlags,
                              MessageGuid,
                              MessageNumber,
                              MessageArgList));
}


NTSTATUS
WmiTraceMessageVa(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    va_list         MessageArgList
)
/*++ WmiTraceMessageVa
         The VA version of WmiTraceMessage
NOTE:
        this routine is called from WmiTraceUserMessage path via an IOCTL so the probes and
        try/excepts have to be carefully managed
--*/
{
    SSIZE_T dataBytes;
    PMESSAGE_TRACE_HEADER Header;
    PUCHAR pMessageData ;
    PWMI_BUFFER_HEADER BufferResource = NULL ;
    USHORT  size ;
    ULONG  LoggerId = (ULONG)-1 ; // initialise so we don't unlock it if not set
    ULONG SequenceNumber ;
    PWMI_LOGGER_CONTEXT LoggerContext = NULL;
    LARGE_INTEGER TimeStamp;
#if DBG
    LONG    RefCount;
#endif

    // Set the LoggerId up here, and lock it.
    // if we AV in the WmiUserTraceMessagePath we will
    // be caught by the try/except in that routine
    LoggerId = WmiGetLoggerId(LoggerHandle);
    if (LoggerId < 1 || LoggerId >= MAXLOGGERS)
       return STATUS_INVALID_HANDLE;

#if DBG
 RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((4, "WmiTraceMessage: %d %d->%d\n",
                 LoggerId, RefCount-1, RefCount));
    
    try {
        //
        // Determine the number bytes to follow header
        //
        dataBytes = 0;
        { // Allocation Block
            va_list ap;
            PCHAR source;
            ap = MessageArgList ;
            while ((source = va_arg (ap, PVOID)) != NULL) {
                SSIZE_T elemBytes;
                if ((elemBytes = va_arg (ap, SSIZE_T)) > 0) {
                   dataBytes += elemBytes;
                }      
            }
         } // end of allocation block

        // Figure the size of the message including the header
         size  = (USHORT) ((MessageFlags&TRACE_MESSAGE_SEQUENCE ? sizeof(ULONG):0) +
         		 (MessageFlags&TRACE_MESSAGE_GUID ? sizeof(GUID):0) +
                 (MessageFlags&TRACE_MESSAGE_COMPONENTID ? sizeof(ULONG):0) +
        		 (MessageFlags&(TRACE_MESSAGE_TIMESTAMP | TRACE_MESSAGE_PERFORMANCE_TIMESTAMP) ? sizeof(LARGE_INTEGER):0) +
         		 (MessageFlags&TRACE_MESSAGE_SYSTEMINFO ? 2 * sizeof(ULONG):0) +
                 sizeof (MESSAGE_TRACE_HEADER) +
                 (USHORT)dataBytes);

        //
        // Allocate Space in the Trace Buffer
        //
        // NOTE: we do not check for size here for reduce overhead, and because
        //       we trust ourselves to use WmiTraceLongEvent for large event traces (???)

        LoggerContext = WmipGetLoggerContext(LoggerId);
        if (!WmipIsValidLogger(LoggerContext)) {
#if DBG
     RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceMessage: Status1=%X %d %d->%d\n",
                        STATUS_INVALID_HANDLE, LoggerId,
                        RefCount+1, RefCount));
            return STATUS_INVALID_HANDLE;
        }

        if ((LoggerContext->RequestFlag & REQUEST_FLAG_CIRCULAR_PERSIST) &&
            (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_CIRCULAR)) {
            // Unset REQUEST_FLAG_CIRCULAR_PERSIST flag
            // Since persistent events will never be mixed with TraceMessage(), 
            // we'll just unset it once and for all without flushing.
            LoggerContext->RequestFlag &= (~( REQUEST_FLAG_CIRCULAR_PERSIST
                                            | REQUEST_FLAG_CIRCULAR_TRANSITION));
        }

        if ((KeGetPreviousMode() == KernelMode) &&
            (LoggerContext->LoggerMode & EVENT_TRACE_USE_PAGED_MEMORY)) {
#if DBG
     RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceMessage: Status1=%X %d %d->%d\n",
                        STATUS_UNSUCCESSFUL, LoggerId,
                        RefCount+1, RefCount));
            return STATUS_UNSUCCESSFUL;
        }

        Header = (PMESSAGE_TRACE_HEADER) WmipReserveTraceBuffer(LoggerContext,
                                                                size,
                                                                &BufferResource,
                                                                &TimeStamp);
        if (Header == NULL) {
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((4, "WmiTraceMessage: %d %d->%d\n",
                            LoggerId, RefCount+1, RefCount));

            return STATUS_NO_MEMORY;
        }
        //
        // Sequence Number is returned in the Marker field of the buffer
        //
        SequenceNumber = Header->Marker ;

        //
        // Now copy the necessary information into the buffer
        //

        Header->Marker = TRACE_MESSAGE | TRACE_HEADER_FLAG ;
        //
        // Fill in Header.
        //
        Header->Size = size ;
        Header->Packet.OptionFlags = ((USHORT)MessageFlags &
                                      (TRACE_MESSAGE_SEQUENCE |
                                      TRACE_MESSAGE_GUID |
                                      TRACE_MESSAGE_COMPONENTID |
                                      TRACE_MESSAGE_TIMESTAMP |
                                      TRACE_MESSAGE_PERFORMANCE_TIMESTAMP |
                                      TRACE_MESSAGE_SYSTEMINFO)) &
                                      TRACE_MESSAGE_FLAG_MASK ;
        // Message Number
        Header->Packet.MessageNumber =  MessageNumber ;

        //
        // Now add in the header options we counted.
        //
        pMessageData = &(((PMESSAGE_TRACE)Header)->Data);


        //
        // Note that the order in which these are added is critical New entries must
        // be added at the end!
        //
        // [First Entry] Sequence Number
        if (MessageFlags&TRACE_MESSAGE_SEQUENCE) {
            *((PULONG)pMessageData) = SequenceNumber;
        	pMessageData += sizeof(ULONG) ;
        }

        // [Second Entry] GUID ? or CompnentID ?
        if (MessageFlags&TRACE_MESSAGE_COMPONENTID) {
            *((PULONG)pMessageData) = *((PULONG) MessageGuid);
            pMessageData += sizeof(ULONG) ;
        } else if (MessageFlags&TRACE_MESSAGE_GUID) { // Can't have both
            *((LPGUID)pMessageData) = *MessageGuid;
        	pMessageData += sizeof(GUID) ;
        }
        
        // [Third Entry] Timestamp?
        if (MessageFlags&TRACE_MESSAGE_TIMESTAMP) {
            ((PLARGE_INTEGER)pMessageData)->HighPart = TimeStamp.HighPart;
            ((PLARGE_INTEGER)pMessageData)->LowPart = TimeStamp.LowPart;
            pMessageData += sizeof(LARGE_INTEGER);

        }


        // [Fourth Entry] System Information?
        // Note that some of this may NOT be valid depending on the current processing level
        // however we assume that the post-processing may still find it useful
        if (MessageFlags&TRACE_MESSAGE_SYSTEMINFO) {
            PCLIENT_ID Cid;        // avoid additional function calls

            Cid = &(PsGetCurrentThread()->Cid);
            // Executive Handles may be truncated
            *((PULONG)pMessageData) = HandleToUlong(Cid->UniqueThread);
            pMessageData += sizeof(ULONG) ;  

            *((PULONG)pMessageData) = HandleToUlong(Cid->UniqueProcess);   
            pMessageData += sizeof(ULONG) ;
        }
        //
        // Add New Header Entries immediately before this comment!
        //

        //
        // Now Copy in the Data.
        //
        { // Allocation Block
            va_list ap;
            PUCHAR source;
            ap = MessageArgList ;
            while ((source = va_arg (ap, PVOID)) != NULL) {
                SSIZE_T elemBytes, copiedBytes = 0 ;
                if ((elemBytes = va_arg (ap, SSIZE_T)) > 0 ) {
                    if (dataBytes < copiedBytes + elemBytes) {  // defend against bytes having changed
                        TraceDebug((1, "WmiTraceMessage: Invalid message - argument length changed"));
                        break;                                  // So we don't overrun
                    }
                    RtlCopyMemory (pMessageData, source, elemBytes);
                    copiedBytes += elemBytes ;
                    pMessageData += elemBytes;
                }
            }
        } // Allocation Block

    } except  (EXCEPTION_EXECUTE_HANDLER) {
        if (BufferResource != NULL) {
               WmipReleaseTraceBuffer ( BufferResource, LoggerContext );   // also unlocks the logger
        } else {
#if DBG
     RefCount =
#endif
             WmipDereferenceLogger(LoggerId);
        }
        TraceDebug((4, "WmiTraceMessage: Status6=EXCEPTION %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));
        return GetExceptionCode();
    }

    //
    // Buffer Complete, Release
    //
    WmipReleaseTraceBuffer( BufferResource, LoggerContext );  // Also unlocks the logger
        
    TraceDebug((4, "WmiTraceMessage: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));

    //
    // Return Success
    //
    return (STATUS_SUCCESS);
}

NTKERNELAPI
NTSTATUS
FASTCALL
WmiTraceUserMessage(
    IN PMESSAGE_TRACE_USER pMessage,
    IN ULONG    MessageSize
    )
/*++

Routine Description:

    This routine is used by trace User messages only. it is called via an IOCTL
    on the WMI Device.

Arguments:

    pMessage    a pointer to a Marshalled Message.
    MessageSize size of that message.

Return Value:

    The status of performing the action requested

--*/
{

    if (MessageSize < sizeof(MESSAGE_TRACE_USER)) {
        return (STATUS_UNSUCCESSFUL);
    }
    try {
        ProbeForRead(
                pMessage,
                MessageSize,
                sizeof (UCHAR)
                );
        return (WmiTraceMessage(pMessage->LoggerHandle,
                                pMessage->MessageFlags,
                                &pMessage->MessageGuid,
                                pMessage->MessageHeader.Packet.MessageNumber,
                                &pMessage->Data,pMessage->DataSize,
                                NULL,0));

    } except  (EXCEPTION_EXECUTE_HANDLER) {
         
         TraceDebug((1, "WmiTraceUserMessage: Status=EXCEPTION\n"));
         return GetExceptionCode();

    }
}


NTKERNELAPI
NTSTATUS
WmiSetMark(
    IN PWMI_SET_MARK_INFORMATION MarkInfo,
    IN ULONG InBufferLen
    )
/*++

Routine Description:

    This routine sets a mark in the kernel logger.

Arguments:

    MarkInfo - a pointer to a WMI_SET_MARK_INFORMATION strcture.

    InBufferLen - Buffer Size.

Return Value:

    status

--*/
{

    NTSTATUS Status;
    PERFINFO_HOOK_HANDLE Hook;
    ULONG TotalBytes;
    ULONG CopyBytes;
    USHORT HookId;

    if (PERFINFO_IS_ANY_GROUP_ON()) {
        if (MarkInfo->Flag & WMI_SET_MARK_WITH_FLUSH) {
            if (PERFINFO_IS_GROUP_ON(PERF_FOOTPRINT)) {
                MmEmptyAllWorkingSets();
                Status = MmPerfSnapShotValidPhysicalMemory();
            }
        }
        HookId = PERFINFO_LOG_TYPE_MARK;

        CopyBytes = InBufferLen - FIELD_OFFSET(WMI_SET_MARK_INFORMATION, Mark);
        TotalBytes = CopyBytes + sizeof(WCHAR);

        Status = PerfInfoReserveBytes(&Hook, HookId, TotalBytes);

        if (NT_SUCCESS(Status)){ 
            PWCHAR Mark = PERFINFO_HOOK_HANDLE_TO_DATA(Hook, PWCHAR); 

            RtlCopyMemory(Mark, &MarkInfo->Mark[0], CopyBytes);

            Mark[CopyBytes / sizeof(WCHAR)] = UNICODE_NULL;

            PERF_FINISH_HOOK(Hook);
        }
    } else {
        Status = STATUS_WMI_SET_FAILURE;
    }

    return Status;
}

NTKERNELAPI
NTSTATUS
WmiSetTraceBufferCallback(
    IN TRACEHANDLE  TraceHandle,
    IN WMI_TRACE_BUFFER_CALLBACK Callback,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine sets a Buffer Callback function for a kernel mode logger.

Arguments:

    TraceHandle - a handle to a logger.

    Callback - a pointer to a callback function.

    Context - Callback context.

Return Value:

    status

--*/
{
    ULONG   LoggerId;
#if DBG
    LONG    RefCount;
#endif
    PWMI_LOGGER_CONTEXT LoggerContext;

    PAGED_CODE();

    if (TraceHandle == (TRACEHANDLE) 0) {
        WmipGlobalBufferCallback = Callback;
        return STATUS_SUCCESS;
    }
    LoggerId = WmiGetLoggerId(TraceHandle);
    if (LoggerId == KERNEL_LOGGER_ID) {
        LoggerId = WmipKernelLogger;
    }
    else if (LoggerId < 1 || LoggerId >= MAXLOGGERS)
       return STATUS_INVALID_HANDLE;
#if DBG
 RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((4, "WmiSetTraceBufferCallback: %d %d->%d\n",
                 LoggerId, RefCount-1, RefCount));

    LoggerContext = WmipGetLoggerContext( LoggerId );
    if (!WmipIsValidLogger(LoggerContext)) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmiSetTraceBufferCallback: Status=%X %d %d->%d\n",
                        STATUS_WMI_INSTANCE_NOT_FOUND,
                        LoggerId, RefCount+1, RefCount));
        return STATUS_WMI_INSTANCE_NOT_FOUND;
    }

    LoggerContext->BufferCallback = Callback;
    LoggerContext->CallbackContext = Context;
#if DBG
    RefCount =
#endif
    WmipDereferenceLogger(LoggerId);
    return STATUS_SUCCESS;
}


NTKERNELAPI
NTSTATUS
WmiQueryTraceInformation(
    IN TRACE_INFORMATION_CLASS TraceInformationClass,
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG RequiredLength OPTIONAL,
    IN PVOID Buffer OPTIONAL
    )
/*++

Routine Description:

    This routine copies user-requested information to a user-provided buffer.
    If RequiredLength is given, the needed size for the requested information
    is returned.

Arguments:

    TraceInformationClass   Type of information requested
    TraceInformation        Output buffer for the information
    TraceInformationLength  The size of the TraceInformation
    RequiredLength          The size needed for the information
    Buffer                  Buffer used for use input. Depending on
                            TraceInformationClass, this may be required.

    NOTE: we do not consider NULL TraceInformation an error, In this case, we 
    only update RequiredLength, if that is given.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG LoggerId;
    ULONG EnableFlags;
    ULONG EnableLevel;
    ULONG LoggersLength;
    TRACEHANDLE TraceHandle;
    TRACEHANDLE AllHandles[MAXLOGGERS];
    NTSTATUS Status = STATUS_SUCCESS;
    PWNODE_HEADER Wnode = (PWNODE_HEADER) Buffer; // For most classes, but not all

    PAGED_CODE();

    try {
        if (ARGUMENT_PRESENT(RequiredLength)) {
            *RequiredLength = 0;
        }

        switch (TraceInformationClass) {

        case TraceIdClass:

            if (TraceInformationLength != sizeof( ULONG )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            if (Wnode == NULL) {
                return STATUS_INVALID_PARAMETER_MIX;
            }
            TraceHandle = Wnode->HistoricalContext;
            if ((TraceHandle == 0) || (TraceHandle == (ULONG) -1)) {
                return STATUS_INVALID_HANDLE;
            }

            LoggerId = WmiGetLoggerId(TraceHandle);

            if (LoggerId > MAXLOGGERS) {
                return STATUS_INVALID_HANDLE;
            }

            if (TraceInformation) {
                *((PULONG)TraceInformation) = LoggerId;
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = sizeof( ULONG );
            }
            break;

        case TraceHandleClass:
            if (TraceInformationLength != sizeof(TRACEHANDLE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            if (Buffer == NULL) {
                return STATUS_INVALID_PARAMETER_MIX;
            }
            LoggerId = *((PULONG) Buffer);
            TraceHandle = 0;
            TraceHandle = WmiSetLoggerId(LoggerId, &TraceHandle);

            if (TraceInformation) {
                *((PTRACEHANDLE)TraceInformation) = TraceHandle;
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = sizeof( TRACEHANDLE );
            }
            break;

        case TraceEnableFlagsClass:
            if (TraceInformationLength < sizeof(ULONG)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            if (Wnode == NULL) {
                return STATUS_INVALID_PARAMETER_MIX;
            }
            TraceHandle = Wnode->HistoricalContext;
            if ((TraceHandle == 0) || (TraceHandle == (ULONG) -1)) {
                return STATUS_INVALID_HANDLE;
            }

            EnableFlags = WmiGetLoggerEnableFlags(TraceHandle);

            if (TraceInformation) {
                *((PULONG)TraceInformation) = EnableFlags;
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = sizeof( ULONG );
            }
            break;

        case TraceEnableLevelClass:
            if (TraceInformationLength < sizeof(ULONG)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            if (Wnode == NULL) {
                return STATUS_INVALID_PARAMETER_MIX;
            }
            TraceHandle = Wnode->HistoricalContext;
            if ((TraceHandle == 0) || (TraceHandle == (ULONG) -1)) {
                return STATUS_INVALID_HANDLE;
            }

            EnableLevel = WmiGetLoggerEnableLevel(TraceHandle);

            if (TraceInformation) {
                *((PULONG)TraceInformation) = EnableLevel;
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = sizeof( ULONG );
            }
            break;

        case GlobalLoggerHandleClass:
            if (TraceInformationLength != sizeof(TRACEHANDLE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            WmipReferenceLogger(WMI_GLOBAL_LOGGER_ID);
            if (WmipLoggerContext[WMI_GLOBAL_LOGGER_ID] == NULL) {
                TraceHandle = 0;
                Status = STATUS_NOT_FOUND;
            }
            else {
                TraceHandle = WmipLoggerContext[WMI_GLOBAL_LOGGER_ID]->LoggerId;
            }

            WmipDereferenceLogger(WMI_GLOBAL_LOGGER_ID);
            if (TraceInformation) {
                *((PTRACEHANDLE)TraceInformation) = TraceHandle;
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = sizeof( TRACEHANDLE );
            }
            break;

        case EventLoggerHandleClass:
            if (TraceInformationLength != sizeof(TRACEHANDLE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            LoggerId = WmipEventLogger;
            if (WmipEventLogger == (ULONG) -1) {
                TraceHandle = 0;
                Status = STATUS_NOT_FOUND;
            }
            else {
                TraceHandle = LoggerId;
            }
            if (TraceInformation) {
                *((PTRACEHANDLE)TraceInformation) = TraceHandle;
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = sizeof( TRACEHANDLE );
            }
            break;

        case AllLoggerHandlesClass:
            // Returns all logger handles, except for kernel logger
            if (TraceInformationLength < sizeof(TRACEHANDLE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            LoggersLength = 0;
            for (LoggerId=1; LoggerId<MAXLOGGERS; LoggerId++) {
                WmipReferenceLogger(LoggerId);
                if (!WmipIsValidLogger(WmipLoggerContext[LoggerId])) {
                    AllHandles[LoggersLength] = 0;
                }
                else {
                    AllHandles[LoggersLength++] = LoggerId;
                }
                WmipDereferenceLogger(LoggerId);
            }
            LoggersLength *= sizeof(TRACEHANDLE);
            if (TraceInformation && (LoggersLength > 0)) {
                if (TraceInformationLength >= LoggersLength) {
                    RtlCopyMemory(TraceInformation, AllHandles, LoggersLength);
                }
                else {
                    RtlCopyMemory(TraceInformation, AllHandles, TraceInformationLength);
                    Status = STATUS_MORE_ENTRIES;
                }
            }
            if (ARGUMENT_PRESENT( RequiredLength )) {
                *RequiredLength = LoggersLength;
            }
            break;

        case TraceHandleByNameClass:
            // Returns a Trace Handle Given a Logger name as a UNICODE_STRING in buffer.
            {
                WMI_LOGGER_INFORMATION LoggerInfo;
                PUNICODE_STRING uString = Buffer;


                if (TraceInformationLength != sizeof(TraceHandle) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }
	            if (uString == NULL) {
		            return STATUS_INVALID_PARAMETER;
	            }
	            if (uString->Buffer == NULL || uString->Length == 0) {
		            return STATUS_INVALID_PARAMETER;
	            }

                RtlZeroMemory(&LoggerInfo, sizeof(LoggerInfo));
                LoggerInfo.Wnode.BufferSize = sizeof(LoggerInfo);
                LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID;

                RtlInitUnicodeString(&LoggerInfo.LoggerName, uString->Buffer);

                Status = WmiQueryTrace(&LoggerInfo);
                if (!NT_SUCCESS(Status)) {
                    return STATUS_NOT_FOUND;
                }

                TraceHandle = (TRACEHANDLE)LoggerInfo.Wnode.HistoricalContext;

                if (TraceInformation) {
                    *((PTRACEHANDLE)TraceInformation) = TraceHandle;
                }
                if (ARGUMENT_PRESENT( RequiredLength )) {
                    *RequiredLength = sizeof( TRACEHANDLE );
                }
            }
            break;


        default :
            return STATUS_INVALID_INFO_CLASS;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\sources.inc ===
!IF 0

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=wmi

TARGETNAME=wmi
TARGETPATH=obj
TARGETTYPE=LIBRARY

BUILD_PRODUCES=ntoswmi$(NT_UP)

INCLUDES=..;..\..\inc;$(PROJECT_ROOT)\win32\inc

MSC_WARNING_LEVEL=/W4 /WX

C_DEFINES=$(C_DEFINES) -DUNICODE

SOURCES=..\wmi.c \
        ..\register.c \
        ..\api.c \
        ..\notify.c \
        ..\callouts.c \
        ..\tracelog.c \
        ..\traceapi.c \
        ..\tracesup.c \
        ..\secure.c \
        ..\globalog.c \
        ..\wmidata.c \
        ..\dataprov.c \
        ..\alloc.c \
        ..\chunk.c \
        ..\ds.c \
        ..\consumer.c \
        ..\enabdisa.c \
        ..\smbios.c \
        ..\mca.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\tracesup.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    tracesup.c

Abstract:

    This is the source file that implements the private routines of
    the performance event tracing and logging facility. These routines
    work on manipulating the LoggerContext table and synchronization
    across event tracing sessions.

Author:

    Jee Fung Pang (jeepang) 03-Jan-2000

Revision History:

--*/

#include "wmikmp.h"
#include <ntos.h>
#include <evntrace.h>

#include <wmi.h>
#include "tracep.h"

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define KERNEL_LOGGER_CAPTION   L"NT Kernel Logger"
#define DEFAULT_BUFFERS         2
#define DEFAULT_AGE_LIMIT       15          // 15 minutes
#define SEMAPHORE_LIMIT         1024
#define CONTEXT_SIZE            PAGE_SIZE
#define DEFAULT_MAX_IRQL        DISPATCH_LEVEL
#define DEFAULT_MAX_BUFFERS     20

ULONG WmipKernelLogger = KERNEL_LOGGER;
ULONG WmipEventLogger = 0XFFFFFFFF;
KGUARDED_MUTEX WmipTraceGuardedMutex;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
ULONG   WmipLoggerCount = 0;
HANDLE  EtwpPageLockHandle = NULL;
PSECURITY_DESCRIPTOR EtwpDefaultTraceSecurityDescriptor;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

extern SIZE_T MmMaximumNonPagedPoolInBytes;
extern SIZE_T MmSizeOfPagedPoolInBytes;

WMI_GET_CPUCLOCK_ROUTINE WmiGetCpuClock = &WmipGetSystemTime;

//
// Function prototypes for routines used locally
//

NTSTATUS
WmipLookupLoggerIdByName(
    IN PUNICODE_STRING Name,
    OUT PULONG LoggerId
    );

PWMI_LOGGER_CONTEXT
WmipInitContext(
    );

NTSTATUS
WmipAllocateTraceBufferPool(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipFreeTraceBufferPool(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, WmipStartLogger)
#pragma alloc_text(PAGE, WmipQueryLogger)
#pragma alloc_text(PAGE, WmipStopLoggerInstance)
#pragma alloc_text(PAGE, WmipVerifyLoggerInfo)
#pragma alloc_text(PAGE, WmipExtendBase)
#pragma alloc_text(PAGE, WmipFreeLoggerContext)
#pragma alloc_text(PAGE, WmipInitContext)
#pragma alloc_text(PAGE, WmipAllocateTraceBufferPool)
#pragma alloc_text(PAGE, WmipFreeTraceBufferPool)
#pragma alloc_text(PAGE, WmipLookupLoggerIdByName)
#pragma alloc_text(PAGE, WmipShutdown)
#pragma alloc_text(PAGE, WmipFlushLogger)
#pragma alloc_text(PAGE, WmipNtDllLoggerInfo)
#pragma alloc_text(PAGE, WmipValidateClockType)
/* Look at the comments in the function body
#pragma alloc_text(PAGE, WmipDumpGuidMaps)
#pragma alloc_text(PAGE, WmipGetTraceBuffer)
*/
#pragma alloc_text(PAGEWMI, WmipNotifyLogger)
#endif


NTSTATUS
WmipStartLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    It is called by WmipIoControl in wmi.c, with IOCTL_WMI_START_LOGGER
    to start up an instance of the logger. It basically creates and
    initializes the logger instance context, and starts up a system
    thread for the logger (WmipLogger()). If the user has requested to
    turn on kernel tracing, it will also lock in the necessary routines
    after the logger has started.
    NOTE: A special instance (KERNEL_LOGGER) is reserved exclusively for
    logging kernel tracing.

    To turn on KERNEL_LOGGER, LoggerInfo->Wnode.Guid should be set to
    SystemTraceControlGuid, and sufficient space must be provided in
    LoggerInfo->LoggerName.

    To turn on other loggers, simply provide a name in LoggerName. The
    logger id will be returned.

Arguments:

    LoggerInfo     a pointer to the structure for the logger's control
                    and status information

Return Value:

    The status of performing the action requested.

--*/

{
    NTSTATUS Status;
    ULONG               LoggerId, EnableKernel, EnableFlags;
    HANDLE              ThreadHandle;
    PWMI_LOGGER_CONTEXT LoggerContext;
    LARGE_INTEGER       TimeOut = {(ULONG)(-20 * 1000 * 1000 * 10), -1};
    ACCESS_MASK         DesiredAccess = TRACELOG_GUID_ENABLE;
    PWMI_LOGGER_CONTEXT *ContextTable;
    PFILE_OBJECT        FileObject;
    GUID                InstanceGuid;
    KPROCESSOR_MODE     RequestorMode;
    SECURITY_QUALITY_OF_SERVICE ServiceQos;
    PTRACE_ENABLE_FLAG_EXTENSION FlagExt = NULL;
    PERFINFO_GROUPMASK *PerfGroupMasks=NULL;
    BOOLEAN             IsGlobalForKernel = FALSE;
    BOOLEAN             IsKernelRealTimeNoFile = FALSE;
    ULONG               GroupMaskSize;
    UNICODE_STRING      FileName, LoggerName;
    ULONG               LogFileMode;
#if DBG
    LONG                RefCount;
#endif

    PAGED_CODE();
    if (LoggerInfo == NULL)
        return STATUS_SEVERITY_ERROR;

    //
    // try and check for bogus parameter
    // if the size is at least what we want, we have to assume it's valid
    //
    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return STATUS_INVALID_BUFFER_SIZE;

    if (! (LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID) )
        return STATUS_INVALID_PARAMETER;

    LogFileMode = LoggerInfo->LogFileMode;
    if ( (LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) &&
         (LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ) {
        return STATUS_INVALID_PARAMETER;
    }

    if ( (LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) &&
         (LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE) ) {
        return STATUS_INVALID_PARAMETER;
    }

/*    if (LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE) {
        if ((LoggerInfo->LogFileName.Length == 0) ||
            (LoggerInfo->LogFileName.Buffer == NULL) )
            return STATUS_INVALID_PARAMETER;
    }*/
    if ( !(LogFileMode & EVENT_TRACE_REAL_TIME_MODE) ) {
        if ( !(LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE) )
            if (LoggerInfo->LogFileHandle == NULL)
                return STATUS_INVALID_PARAMETER;
    }

    // Cannot support append to circular
    if ( (LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) &&
         (LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) ) {
        return STATUS_INVALID_PARAMETER;
    }


    if (LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
        DesiredAccess |= TRACELOG_CREATE_REALTIME;
    }

    if ((LoggerInfo->LogFileHandle != NULL) ||
        (LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE)) {
        DesiredAccess |= TRACELOG_CREATE_ONDISK;
    }

    EnableFlags = LoggerInfo->EnableFlags;
    if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
        FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &EnableFlags;

        if ((FlagExt->Length == 0) || (FlagExt->Offset == 0))
            return STATUS_INVALID_PARAMETER;
        if ((FlagExt->Length * sizeof(ULONG)) >
            (LoggerInfo->Wnode.BufferSize - FlagExt->Offset))
            return STATUS_INVALID_PARAMETER;
    }

    if (LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE) {
        if ((LoggerInfo->LogFileName.Buffer == NULL) ||
            (LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ||
            (LoggerInfo->MaximumFileSize == 0) ||
            IsEqualGUID(&LoggerInfo->Wnode.Guid, &SystemTraceControlGuid))
            return STATUS_INVALID_PARAMETER;
    }

    if (LogFileMode & EVENT_TRACE_USE_KBYTES_FOR_SIZE) {
        // Default Minimum Buffers and default Buffer Size are computed
        // later in the Context initialization after Context allocation.
        // To avoid having to allocate memory for this error checking,
        // we compute local parameters. 
        ULONG LocalMinBuffers = (ULONG)KeNumberProcessors + DEFAULT_BUFFERS;
        ULONG LocalBufferSize = PAGE_SIZE / 1024;
        ULONG LocalMaxBuffers; 
        SIZE_T WmiMaximumPoolInBytes;

        if (LoggerInfo->BufferSize > 0) {
            if (LoggerInfo->BufferSize > MAX_WMI_BUFFER_SIZE) {
                LocalBufferSize = MAX_WMI_BUFFER_SIZE;
            }
            else {
                LocalBufferSize = LoggerInfo->BufferSize;
            }
        }
        if (LogFileMode & EVENT_TRACE_USE_PAGED_MEMORY) {
            WmiMaximumPoolInBytes = MmSizeOfPagedPoolInBytes;
        }
        else {
            WmiMaximumPoolInBytes = MmMaximumNonPagedPoolInBytes;
        }
        LocalMaxBuffers = (ULONG) (WmiMaximumPoolInBytes
                            / TRACE_MAXIMUM_NP_POOL_USAGE
                            / LocalBufferSize);
        if (LoggerInfo->MaximumBuffers != 0 && 
            LoggerInfo->MaximumBuffers < LocalMaxBuffers) {
            LocalMaxBuffers = LoggerInfo->MaximumBuffers;
        }
        if (LocalMinBuffers < LoggerInfo->MinimumBuffers && 
            LoggerInfo->MinimumBuffers < LocalMaxBuffers) {
            LocalMinBuffers = LoggerInfo->MinimumBuffers;
        }
        // MaximumFileSize must be multiples of buffer size
        if ((LoggerInfo->LogFileName.Buffer == NULL) ||
            (LoggerInfo->MaximumFileSize == 0) || 
            ((LoggerInfo->MaximumFileSize % LocalBufferSize) != 0) ||
            (LoggerInfo->MaximumFileSize < (LocalMinBuffers * LocalBufferSize))) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    RequestorMode = KeGetPreviousMode();

    LoggerName.Buffer = NULL;

    if (LoggerInfo->LoggerName.Length > 0) {
        try {
            if (RequestorMode != KernelMode) {
                ProbeForRead(
                    LoggerInfo->LoggerName.Buffer,
                    LoggerInfo->LoggerName.Length,
                    sizeof (UCHAR) );
            }
            if (! RtlCreateUnicodeString(
                    &LoggerName,
                    LoggerInfo->LoggerName.Buffer) ) {
                return STATUS_NO_MEMORY;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            if (LoggerName.Buffer) {
                RtlFreeUnicodeString(&LoggerName);
            }
            return GetExceptionCode();
        }
        Status = WmipLookupLoggerIdByName(&LoggerName, &LoggerId);
        if (NT_SUCCESS(Status)) {
            RtlFreeUnicodeString(&LoggerName);
            return STATUS_OBJECT_NAME_COLLISION;
        }
    }

//
// TODO: Perhaps make the last entry of table point to another table?
//
    ContextTable = (PWMI_LOGGER_CONTEXT *) &WmipLoggerContext[0];

    // If NULL GUID is given, generate a random GUID.
    RtlZeroMemory(&InstanceGuid, sizeof(GUID));
    if (IsEqualGUID(&LoggerInfo->Wnode.Guid, &InstanceGuid)) {
        Status = ExUuidCreate(&LoggerInfo->Wnode.Guid);
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }
    else {
        InstanceGuid = LoggerInfo->Wnode.Guid;
    }

    EnableKernel = IsEqualGUID(&InstanceGuid, &SystemTraceControlGuid);

    if (EnableKernel) {
        //
        // Check if this is the Real-Time No LogFile case.
        //
        if ((LogFileMode & EVENT_TRACE_REAL_TIME_MODE) &&
            !(LogFileMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE)){

            IsKernelRealTimeNoFile = TRUE;

        }
        //
        // This prevents multiple threads from continuing beyond this
        // point in the code.  Only the first thread will progress.
        //
        if (InterlockedCompareExchangePointer(  // if already running
                &ContextTable[WmipKernelLogger], ContextTable, NULL) != NULL)
            return STATUS_OBJECT_NAME_COLLISION;

        LoggerId = WmipKernelLogger;
        DesiredAccess |= TRACELOG_ACCESS_KERNEL_LOGGER;
    }
    else if (IsEqualGUID(&InstanceGuid, &GlobalLoggerGuid)) {
        LoggerId = WMI_GLOBAL_LOGGER_ID;
        if (InterlockedCompareExchangePointer(  // if already running
                &ContextTable[LoggerId], ContextTable, NULL) != NULL)
            return STATUS_OBJECT_NAME_COLLISION;
        if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            PULONG pFlag;
            pFlag = (PULONG) ((PCHAR)LoggerInfo + FlagExt->Offset);
            if (*pFlag != 0) {
                EnableKernel = TRUE;
                IsGlobalForKernel = TRUE;
                WmipKernelLogger = LoggerId;
            }
        }
        // everyone has access to send to this
    }
    else {   // other loggers requested
        for (LoggerId = 2; LoggerId < MAXLOGGERS; LoggerId++) {
            if ( InterlockedCompareExchangePointer(
                    &ContextTable[LoggerId],
                    ContextTable,
                    NULL ) == NULL )
                break;      // mark the slot as busy by putting in ServiceInfo
        }

        if (LoggerId >=  MAXLOGGERS) {    // could not find any more slots
            return STATUS_UNSUCCESSFUL;
        }
    }
#if DBG
    RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((1, "WmipStartLogger: %d %d->%d\n", LoggerId,
                    RefCount-1, RefCount));
    //
    // first, check to see if caller has access to proper Guids.
    //
    Status = WmipCheckGuidAccess(
                &InstanceGuid,
                DesiredAccess,
                EtwpDefaultTraceSecurityDescriptor
                );
    if (!NT_SUCCESS(Status)) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmipStartLogger: Status1=%X %d %d->%d\n",
                    Status, LoggerId, RefCount+1, RefCount));
        ContextTable[LoggerId] = NULL;
        return Status;
    }

    // Next, try and see if we need to get the logfile object first
    //
    FileObject = NULL;
    if (LoggerInfo->LogFileHandle != NULL) {
        OBJECT_HANDLE_INFORMATION handleInformation;
        ACCESS_MASK grantedAccess;

        Status = ObReferenceObjectByHandle(
                    LoggerInfo->LogFileHandle,
                    0L,
                    IoFileObjectType,
                    RequestorMode,
                    (PVOID *) &FileObject,
                    &handleInformation);

        if (NT_SUCCESS(Status)) {
