ncID;


	for( sourceID=0; sourceID<departureTime.totalDNSs; sourceID++ ) {
		printf("source %ld\n",sourceID);
		for( ncID=0; ncID<departureTime.totalNCs; ncID++ ) {

			printf("  NC %ld,   ",ncID);
			CyclicBuffer* pCB = departureTimeGetCB(sourceID, ncID);
			time = pCB->firstInjection;
			sek = (time / 10000000) %10000;
			mili = (time /10000) %1000;
			printf(" first %I64d.%I64d   ",sek,mili);
			for( int i=0; i<TOOL_CYCLIC_BUFFER; i++ ) {
				time = pCB->tab[i];
				sek = (time / 10000000) %10000;
				mili = (time /10000) %1000;
//				printf("%I64d \n",time);
				printf("%I64d.%I64d ",sek,mili);
			};
			printf("\n");

		};
	};

}




//the functions below implement a three dimensional table
//where we store the most recent arrival of an injected packet
//for a triplet (source,destination,NC) where:
//
// source is the DC where we injected the packet,
// destination is the DC where we observed the packet to arrive,
// NC is the naming context to which the packet belongs.
//
// the triplet is associated with a LONGLONG number that
// represents the time when we observed the packet to arrive
// at the destination


HRESULT timeCubeInit(TimeCube* timeCube, long totalDNSs, long totalNCs)
{
	timeCube->totalDNSs = totalDNSs;
	timeCube->totalNCs = totalNCs;
	timeCube->aTime = (LONGLONG*)malloc(totalDNSs*totalDNSs*totalNCs*sizeof(LONGLONG));

	if( timeCube->aTime == NULL )
		return S_FALSE;

	LONGLONG* p;
	p = timeCube->aTime;
	for( long i=0; i<totalDNSs*totalDNSs*totalNCs; i++) {
		*p = 0;
		p++;
	};

	return S_OK;
}

void timeCubeFree(TimeCube* timeCube)
{
	free(timeCube->aTime);
	timeCube->aTime = NULL;
}

LONGLONG timeCubeGet(TimeCube* timeCube, long sourceID, long destinationID, long ncID )
{
	if( timeCube->aTime == NULL )
		return -1;

	LONGLONG* p = timeCube->aTime;
	p += ncID + sourceID*(timeCube->totalNCs) + destinationID*(timeCube->totalNCs)*(timeCube->totalDNSs);
	return *p;
}

void timeCubePut(TimeCube* timeCube, long sourceID, long destinationID, long ncID, LONGLONG value )
{
	if( timeCube->aTime == NULL )
		return;

	LONGLONG* p = timeCube->aTime;
	p += ncID + sourceID*(timeCube->totalNCs) + destinationID*(timeCube->totalNCs)*(timeCube->totalDNSs);
	*p = value;
}


void timeCubePrint(TimeCube* timeCube)
{
	LONGLONG time,sek,mili;
	long sourceID, destinationID, ncID;

	if( timeCube->aTime == NULL )
		return;

	for( sourceID=0; sourceID<timeCube->totalDNSs; sourceID++ ) {
		printf("source %ld\n",sourceID);
		for( ncID=0; ncID<timeCube->totalNCs; ncID++ ) {
			printf("  nc %ld,   ",ncID);
			for( destinationID=0; destinationID<timeCube->totalDNSs; destinationID++ ) {
				time = timeCubeGet(timeCube, sourceID, destinationID, ncID );
				sek = (time / 10000000) %10000;
				mili = (time /10000) %1000;
//				printf("%I64d \n",time);
				printf("%I64d.%I64d ",sek,mili);
			};
			printf("\n");
		};
	};

}


void doubleSlash( WCHAR* inText, WCHAR* outText )
// copies the input text to the output text
// and duplicates each / character
//
// Example
//     SYSVOL\haifa.ntdev.microsoft.com\Policies
// will be converted into
//     SYSVOL\\haifa.ntdev.microsoft.com\\Policies
//
// The output string MUST have enough room to accompdate the result
// (at most twice the length of the input string)
{
	while( *inText != '\0' ) {
		if( *inText == '\\' ) {
			*outText++ = '\\';
			*outText++ = '\\';
		}
		else
			*outText++ = *inText;
		inText++;
	};
	*outText = '\0';
}


HRESULT setAttributeOfNode(IXMLDOMNode* pNode, WCHAR* name, LONGLONG value)
{

	WCHAR longlong[40];
	HRESULT hr;
	_variant_t var;


	IXMLDOMElement* pElem;
	hr=pNode->QueryInterface(IID_IXMLDOMElement,(void**)&pElem );
	if( hr != S_OK ) {
		printf("QueryInterface failed\n");
		return hr;
	};


	_i64tow(value,longlong,10);


	var = longlong;
	hr = pElem->setAttribute(name, var);
	if( hr != S_OK ) {
		printf("setAttribute failed\n");
		return hr;
	};

	return S_OK;
}



HRESULT convertLLintoCIM(IXMLDOMNode* pNode, BSTR attrName)
{
	HRESULT hr;
	LONGLONG ll;


	IXMLDOMElement* pElem;
	hr = pNode->QueryInterface(IID_IXMLDOMElement,(void**)&pElem );
	if( hr != S_OK ) {
//		printf("QueryInterface failed\n");
		return hr;
	};
		
	
	hr = getAttrOfNode(pElem,attrName,&ll);
	if( hr != S_OK ) {
//		printf("getAttrOfNode failed\n");
		return hr;
	};
	BSTR time = UTCFileTimeToCIM( ll );
	_variant_t var = time;
	SysFreeString( time );
	hr = pElem->setAttribute(attrName, var);
	if( hr != S_OK ) {
//		printf("setAttribute failed\n");
		return hr;
	};
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rpcspoof\replrpcimpl.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:
    ReplRpcImpl.cxx

Abstract:
    Calls to _DsReplicaGetInfo and _DsReplicatGetInfo2W are functionally
    equivilant to calls to DsReplicaGetInfo and DsReplicaGetInfo2W but use
    LDAP to retrieve the data instead of RPC when possible.

    See ReplRpcSpoofState.cxx.

    The following functions are spoofed in this file:
    _DsReplicaGetInfo

    ISSUE Sep 22, 2000 wlees
    The _DsReplicatGetInfo2W is not spoofed. The 2 version of this case differs in
    the arguments that may be passed to the server. Unfortunately, the additional
    arguments do not fit into the ldap model, and thus would have to be simulated at
    the client side. The primary purpose for the 2 version is to allow the rpc
    interface to do paging. If we were to spoof this call, we should map the paging
    state context into range syntax and back again.

Author:

    Chris King          [t-chrisk]    July-2000
    
Revision History:

--*/

#include <NTDSpchx.h>
#pragma hdrstop

#include <winldap.h>
#include <ntldap.h>
#include <drs.h>
#include <debug.h>

#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplRPCSpoofState.hxx"
#include "ReplRpcSpoofProto.hxx"

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0)

#define RANGE_OPTION L"range="
#define RANGE_OPTION_LENGTH  (sizeof(RANGE_OPTION) - sizeof(WCHAR))

DWORD
Repl_DeMarshalBerval(DS_REPL_STRUCT_TYPE dsReplStructType, 
                     berval * ldapValue[], OPTIONAL
                     DWORD dwNumValues,
                     puReplStructArray pReplStructArray, OPTIONAL
                     PDWORD pdwReplStructArrayLen);


DWORD
WINAPI
_DsReplicaGetInfo2W(
    IN  HANDLE              hRpc,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  LPCWSTR             pszObject OPTIONAL,
    IN  UUID *              puuidForSourceDsaObjGuid OPTIONAL,
    IN  LPCWSTR             pszAttributeName OPTIONAL,
    IN  LPCWSTR             pszValueDN OPTIONAL,
    IN  DWORD               dwFlags,
    IN  DWORD               dwEnumerationContext,
    OUT VOID **             ppInfo
    )

/*++

  Routine Descriptions:
    Functional equivilant to the RPC version this function gets data via LDAP
    when it can. The RPC interface is more functional than the LDAP interface.
    When an RPC call is made which can not be implemented in a straightforward
    manner via LDAP, this function defaults to making a DsReplicatGetInfoW call.
    Under these conditions DsReplicatGetInfo2W is called:

    * the Active Directory does not support replication via LDAP or the handle was retrieved 
      from DsBindWithCredW
    * ppuidForSourceDsaObjGuid is non-NULL

  Arguments:
    hRpc - Handle returned by _DsBindWithCredW or DsBindWithCredW
    InfoType - The replication information type
    pszObject - The object assocated with the replication attribute
    ppInfo - Resulting replication array container structure

  Return values:
    Various LDAP errors.
    
--*/ 
{
    DWORD err;
    LDAP * phLdap = NULL;
    phLdap = getBindings(hRpc);
    puReplStructArray pReplStructArray;
    // Emulate RPC interface. Make deleted objects visible.
    LDAPControlW     ctrlShowDeleted = { LDAP_SERVER_SHOW_DELETED_OID_W };
    LDAPControlW *   rgpctrlServerCtrls[] = { &ctrlShowDeleted,
                                              NULL };

    // Check for reasons to fallback
    // 1. Ldap connection could not be made
    // 2. Feature of rpc interface used, and ldap does not support yet
    // 3. Item code is obsolete
    if (!phLdap ||
        puuidForSourceDsaObjGuid ||
        pszAttributeName ||
        pszValueDN ||
        dwFlags ||
        (DS_REPL_INFO_CURSORS_FOR_NC == InfoType) ||
        (DS_REPL_INFO_CURSORS_2_FOR_NC == InfoType) ||
        (DS_REPL_INFO_METADATA_FOR_OBJ == InfoType) ||
        (DS_REPL_INFO_METADATA_FOR_ATTR_VALUE == InfoType) ||
        (DS_REPL_INFO_CLIENT_CONTEXTS == InfoType) || 
        (DS_REPL_INFO_SERVER_OUTGOING_CALLS == InfoType) ||
        // FUTURE-2002/05/07-BrettSh This call type is partially supported
        // below, it just doesn't return the starting timestamp.  When it
        // does, we can remove this last clause.
        (DS_REPL_INFO_PENDING_OPS == InfoType)
        )
    {
        // Fallback to RPC
        return DsReplicaGetInfo2W(
            hRpc,
            InfoType,
            pszObject,
            puuidForSourceDsaObjGuid,
            pszAttributeName,
            pszValueDN,
            dwFlags,
            dwEnumerationContext,
            ppInfo);
    }

    LDAPMessage * pLDAPMsg = NULL; 
    ATTRTYP attrId;
    LPCWSTR aAttributes[2] = {
        NULL, 
        NULL,
    };

    if (DS_REPL_INFO_NEIGHBORS == InfoType && !pszObject)
    {
        attrId = ROOT_DSE_MS_DS_REPL_ALL_INBOUND_NEIGHBORS;
    }
    else if (DS_REPL_INFO_REPSTO == InfoType && !pszObject)
    {
        attrId = ROOT_DSE_MS_DS_REPL_ALL_OUTBOUND_NEIGHBORS;
    }
    else
    {
        attrId = Repl_Info2AttrTyp(InfoType);
    }


    // Construct a range limited attribute
    LPCWSTR pszBase = Repl_GetLdapCommonName(attrId, TRUE);
    LPWSTR pszName = (LPWSTR) alloca( (wcslen( pszBase ) + 1 +
                                       RANGE_OPTION_LENGTH + 15 +
                                       1 + 1) * sizeof(WCHAR) );
    swprintf( pszName, L"%s;%s%d-*",
              pszBase, RANGE_OPTION, dwEnumerationContext );
    aAttributes[0] = pszName;

    struct berval** ppBerval = NULL;
    DWORD dwNumValues = 0;

    // Search
    err = ldap_search_ext_sW(
                            phLdap,
                            (PWCHAR)pszObject,
                            LDAP_SCOPE_BASE,
                            L"(objectclass=*)",
                            (LPWSTR*)aAttributes ,
                            0,                         // attrs only
                            rgpctrlServerCtrls,        // server ctrls
                            NULL,                      // client ctrls
                            NULL,                      // timeout
                            0,                         // size limit
                            &pLDAPMsg);
    if (err != LDAP_SUCCESS) {
        if (pLDAPMsg) {
            ldap_msgfree(pLDAPMsg);
        }
        return DsReplicaGetInfo2W(
                                 hRpc,
                                 InfoType,
                                 pszObject,
                                 puuidForSourceDsaObjGuid,
                                 pszAttributeName,
                                 pszValueDN,
                                 dwFlags,
                                 dwEnumerationContext,
                                 ppInfo);
    }
    if (!pLDAPMsg) {
        Assert(!"If we had success, we should have a message returned");
        return ERROR_INTERNAL_ERROR;
    }

    // Get values
    PWCHAR szRetAttribute;
    berelement * pCookie;
    DWORD dwRangeLower = 0, dwRangeUpper = 0xffffffff;
    szRetAttribute = ldap_first_attributeW(phLdap, pLDAPMsg, &pCookie);
    if (szRetAttribute) {
        LPWSTR p1;

        // Decode returned range, if any
        p1 = wcsstr( szRetAttribute, RANGE_OPTION );
        if (p1) {
            p1 += RANGE_OPTION_LENGTH / 2;
            dwRangeLower = _wtoi( p1 );
            Assert( dwRangeLower == dwEnumerationContext );
            p1 = wcschr( p1, L'-' );
            if (p1) {
                p1++;
                if (*p1 == L'*') {
                    dwRangeUpper = 0xffffffff;
                } else {
                    dwRangeUpper = _wtoi( p1 );
                }
            }
        }

        ppBerval = ldap_get_values_lenW(phLdap, pLDAPMsg, szRetAttribute);
        ldap_memfreeW(szRetAttribute);
        dwNumValues = ldap_count_values_len(ppBerval);
    }
    // It is legit for szRetAttribute or dwNumValues to be zero. It indicates
    // that there were not any values on this constructed attribute.

    // Demarshal blob
    DWORD dwInfoSize;
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId); 
    err = Repl_DeMarshalBerval(structId, ppBerval, dwNumValues, NULL, &dwInfoSize);
    Assert(!err);
    if (err) {
        if (pLDAPMsg) { ldap_msgfree(pLDAPMsg); }
        return ERROR_INTERNAL_ERROR;
    }

    *ppInfo = (void *)malloc(dwInfoSize);
    if (*ppInfo == NULL) {
        if (pLDAPMsg) { ldap_msgfree(pLDAPMsg); }
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pReplStructArray = (puReplStructArray)*ppInfo;
    err = Repl_DeMarshalBerval(structId, ppBerval, dwNumValues, pReplStructArray, &dwInfoSize);
    Assert(!err);
    if (err) {
        free(*ppInfo);
        *ppInfo = NULL;
        if (pLDAPMsg) { ldap_msgfree(pLDAPMsg); }
        return ERROR_INTERNAL_ERROR;
    }

    if (ROOT_DSE_MS_DS_REPL_PENDING_OPS == attrId) {
        // ISSUE: Need to fill this in using the queue statistics attribute
        memset( &(((DS_REPL_PENDING_OPSW *)pReplStructArray)->ftimeCurrentOpStarted), 0, sizeof( FILETIME ) );
    } else if (DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE == InfoType) {
        if (dwRangeUpper == 0xffffffff) {
            ((DS_REPL_ATTR_VALUE_META_DATA_2 *)pReplStructArray)->dwEnumerationContext =
            dwRangeUpper;
        } else {
            // The enumeration context is defined to be the next available item
            ((DS_REPL_ATTR_VALUE_META_DATA_2 *)pReplStructArray)->dwEnumerationContext =
            dwRangeUpper + 1;
        }
    }

    logPointer(*ppInfo, ppBerval, pLDAPMsg);

    return 0;
}

DWORD
WINAPI
_DsReplicaGetInfoW(
    HANDLE              hRpc,                       // in
    DS_REPL_INFO_TYPE   InfoType,                   // in
    LPCWSTR             pszObject,                  // in
    UUID *              puuidForSourceDsaObjGuid,   // in
    VOID **             ppInfo)                     // out
{
    return _DsReplicaGetInfo2W(
        hRpc,
        InfoType,
        pszObject,
        puuidForSourceDsaObjGuid,
        NULL, // pszAttributeName
        NULL, // pszValueDn
        0, // dwFlags
        0, // dwEnumerationContext
        ppInfo
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\schemard\schemard.c ===
////////////////////////////////////////////////////////////////////////
//
// Utility to read schemas from two running DSA's, load them into internal
// schema caches, and compare them for omissions and conflicts.
// Assumes the domains are named dc=<domainname>,dc=dbsd-tst,dc=microsoft,
// dc=com,o=internet
// Requires null administrator password on the PDC's running the DSA
// 
// Usage: schemard <1stMachineName> <1stDomainName> <2ndMachineName>
//                  <2ndDomainName>
// Example: schemard arob200 myworld kingsx sydney
//
// Currently uses the same static prefix table and functions in oidconv.c
// for OID to Id mapping. Will use dynamic tables later.
//
///////////////////////////////////////////////////////////////////////


#include <NTDSpch.h>
#pragma hdrstop

#include <schemard.h>


// Globals
SCHEMAPTR *CurrSchemaPtr, *SchemaPtr1 = NULL, *SchemaPtr2 = NULL;

char  *pOutFile = NULL;

char  *pSrcServer = NULL;
char  *pSrcDomain = NULL;
char  *pSrcUser   = NULL;
char  *pSrcPasswd = NULL;

char  *pTargetServer = NULL;
char  *pTargetDomain = NULL;
char  *pTargetUser   = NULL;
char  *pTargetPasswd = NULL;

char  *pSrcSchemaDN    = NULL;
char  *pTargetSchemaDN = NULL;

FILE  *logfp;
FILE  *OIDfp;

ULONG NoOfMods = 0;

extern PVOID PrefixTable;


extern void PrintOid(PVOID Oid, ULONG len);

extern NTSTATUS 
base64encode(
     VOID    *pDecodedBuffer,
     DWORD   cbDecodedBufferSize,
     UCHAR   *pszEncodedString,
     DWORD   cchEncodedStringSize,
     DWORD   *pcchEncoded       
    );

// Internal functions
void CreateFlagBasedAttModStr( MY_ATTRMODLIST *pModList,
                               ATT_CACHE *pSrcAtt,
                               ATT_CACHE *pTargetAtt,
                               ATTRTYP attrTyp );
void CreateFlagBasedClsModStr( MY_ATTRMODLIST *pModList,
                               CLASS_CACHE *pSrcAtt,
                               CLASS_CACHE *pTargetAtt,
                               ATTRTYP attrTyp );
BOOL IsMemberOf( ULONG id, ULONG *pList, ULONG cList );
void AddToModStruct( MY_ATTRMODLIST *pModList, 
                     USHORT         choice, 
                     ATTRTYP        attrType, 
                     int            type, 
                     ULONG          valCount, 
                     ATTRVAL        *pAVal
                   );
int CompareUlongList( ULONG      *pList1, 
                      ULONG      cList1, 
                      ULONG      *pList2, 
                      ULONG      cList2, 
                      ULONGLIST  **pL1, 
                      ULONGLIST  **pL2 
                    );
void AddToModStructFromLists( MODIFYSTRUCT *pModStr, 
                              ULONG        *pCount, 
                              ULONGLIST    *pL1, 
                              ULONGLIST    *pL2, 
                              ATTRTYP      attrTyp
                            );

void FileWrite_AttAdd( FILE *fp, ATT_CACHE **pac, ULONG  cnt );
void FileWrite_ClsAdd( FILE *fp, CLASS_CACHE **pcc, ULONG cnt );
void FileWrite_AttDel( FILE *fp, ATT_CACHE **pac, ULONG  cnt );
void FileWrite_ClsDel( FILE *fp, CLASS_CACHE **pcc, ULONG  cnt );
void FileWrite_Mod( FILE *fp, char  *pDN, MODIFYSTRUCT *pMod );

void GenWarning( char c, ULONG attrTyp, char *name);


///////////////////////////////////////////////////////////////
// Routine Description:
//      exit if out of memory
//
// Arguments:
//      nBytes - number of bytes to malloc
//
// Return Value:
//      address of allocated memory. Otherwise, calls exit
///////////////////////////////////////////////////////////////
PVOID
MallocExit(
    DWORD nBytes
    )
{
    PVOID Buf;

    Buf = malloc(nBytes);
    if (!Buf) {
        printf("Error, out of memory\n");
        exit(1);
    }
    return Buf;
}

///////////////////////////////////////////////////////////////
// Routine Description:
//      Processes command line arguments and loads into appropriate
//      globals
//
// Arguments:
//      argc - no. of command line arguments
//      argv - pointer to command line arguments
//
// Return Value:
//      0 on success, non-0 on error
///////////////////////////////////////////////////////////////

int ProcessCommandLine(int argc, char **argv)
{
   BOOL fFoundServer = FALSE;
   BOOL fFoundDomain = FALSE;
   BOOL fFoundUser = FALSE;
   BOOL fFoundPasswd = FALSE;
   int i;
   
   // Must have at least output file name, the two server names, and the
   // associated /f, /source and /target

   if (argc < 7) return 1;
  
   // First argument must be the /f followed by the output file name
   if (_stricmp(argv[1],"/f")) {
      printf("Missing Output file name\n");
      return 1;
   }
   pOutFile = argv[2];

   
   // Must be followed by /source for source dc arguments
   if (_stricmp(argv[3],"/source")) return 1;

   // ok, so we are now processing the source parameters

   i = 4;
   
   while( _stricmp(argv[i], "/target") && (i<12) ) {
     if (!_stricmp(argv[i],"/s")) {
       // server name 
       if (fFoundServer)  return 1;
       fFoundServer = TRUE; 
       pSrcServer = argv[++i];
     }
     if (!_stricmp(argv[i],"/d")) {
       // domain name
       if (fFoundDomain) return 1;
       fFoundDomain = TRUE;
       pSrcDomain = argv[++i];
     }
     if (!_stricmp(argv[i],"/u")) {
       // user name
       if (fFoundUser)  return 1;
       fFoundUser = TRUE;
       pSrcUser = argv[++i];
     }
     if (!_stricmp(argv[i],"/p")) {
       // server name
       if (fFoundPasswd)  return 1;
       fFoundPasswd = TRUE;
       pSrcPasswd = argv[++i];
     }
     i++;
   }

   if (!fFoundServer || !fFoundDomain) {
     printf("No Source server or domain specified\n");
     return 1;
   }

   if (_stricmp(argv[i++], "/target")) return 1;

   fFoundServer = FALSE;
   fFoundDomain = FALSE;
   fFoundUser = FALSE;
   fFoundPasswd = FALSE;

   while( i<argc) {
     if (!_stricmp(argv[i],"/s")) {
       // server name
       if (fFoundServer)  return 1;
       fFoundServer = TRUE;
       pTargetServer = argv[++i];
     }
     if (!_stricmp(argv[i],"/d")) {
       // domain name
       if (fFoundDomain) return 1;
       fFoundDomain = TRUE;
       pTargetDomain = argv[++i];
     }
     if (!_stricmp(argv[i],"/u")) {
       // user name
       if (fFoundUser)  return 1;
       fFoundUser = TRUE;
       pTargetUser = argv[++i];
     }
     if (!_stricmp(argv[i],"/p")) {
       // server name
       if (fFoundPasswd)  return 1;
       fFoundPasswd = TRUE;
       pTargetPasswd = argv[++i];
     }
     i++;
   }
   if (!fFoundServer || !fFoundDomain) {
     printf("No Target server or domain specified\n");
     return 1;
   }

   return 0;

}



void UsagePrint()
{
   printf("Command line errored\n");
   printf("Usage: Schemard /f <OutFile> /source /s <SrcServer> /d <SrcDomain> /u <SrcUser> /p <SrcPasswd> /target /s <TrgServer> /d <TrgDomain> /u <TrgUser> /p <TrgPasswd>\n");
   printf("OutFile:  Output file name (mandatory)\n");
   printf("SrcServer:  Server name for source schema (mandatory)\n");
   printf("SrcDomain:  Domain name in server for source schema (mandatory)\n");
   printf("SrcUser:   User name to authenticate with in source server (optional, default is administrator)\n");
   printf("SrcPasswd:   User passwd to authenticate with in source server (optional, default is NULL)\n");
   printf("TrgServer:  Server name for target schema (mandatory)\n");
   printf("TrgDomain:  Domain name in server for target schema (mandatory)\n");
   printf("TrgUser:   User name to authenticate with in target server (optional, default is administrator)\n");
   printf("TrgPasswd:   User passwd to authenticate with in target server (optional, default is NULL)\n");
}


void __cdecl main( int argc, char **argv )
{
    ULONG   i, Id;
    ULONG   CLSCOUNT;
    ULONG   ATTCOUNT;
    FILE   *fp;
 

    if ( ProcessCommandLine(argc, argv)) 
      {
         UsagePrint();
         exit( 1 );
      };

    // open log file
    logfp = fopen( "Schemard.log","w" );

    // open OID list file
    OIDfp = fopen( "schemard.OID","w" );

      // Create and initialize the Schema Pointer that will point 
      // to the schema cache of the first machine, then create the 
      // hashtables in the cache

    SchemaPtr1 = (SCHEMAPTR *) calloc( 1, sizeof(SCHEMAPTR) );
    if ( SchemaPtr1 == NULL ) { 
          printf("Cannot allocate schema pointer\n");
          exit( 1 );
       };
    SchemaPtr1->ATTCOUNT = MAX_ATTCOUNT;
    SchemaPtr1->CLSCOUNT = MAX_CLSCOUNT;
 
    if ( CreateHashTables( SchemaPtr1 ) != 0 ) {
       printf("Error creating hash tables\n");
       exit( 1 );
      };

 
    CLSCOUNT = SchemaPtr1->CLSCOUNT;
    ATTCOUNT = SchemaPtr1->ATTCOUNT;

      // Read the first Schema and add it to the Schema Cache

    if ( SchemaRead( pSrcServer, 
                     pSrcDomain, 
                     pSrcUser, 
                     pSrcPasswd, 
                     &pSrcSchemaDN, 
                     SchemaPtr1) != 0 )
          { 
            printf("Schema Read error\n");
            exit(1);
          };

    printf("End of first schema read\n"); 


     // Repeat the same steps to load the schema from the second machine

    SchemaPtr2 = (SCHEMAPTR *) calloc( 1, sizeof(SCHEMAPTR) );
    if ( SchemaPtr2 == NULL ) {
       printf("Cannot allocate schema pointer\n");
       exit( 1 );
     };
    SchemaPtr2->ATTCOUNT = MAX_ATTCOUNT;
    SchemaPtr2->CLSCOUNT = MAX_CLSCOUNT;

    if ( CreateHashTables(SchemaPtr2) != 0 ) {
        printf("Error creating hash tables\n");
        exit( 1 );
     };

    CLSCOUNT = SchemaPtr2->CLSCOUNT;
    ATTCOUNT = SchemaPtr2->ATTCOUNT;

    if ( SchemaRead( pTargetServer, 
                     pTargetDomain, 
                     pTargetUser, 
                     pTargetPasswd, 
                     &pTargetSchemaDN, 
                     SchemaPtr2 ) != 0 )
       { 
         printf("Schema Read error\n");
         exit( 1 );
       };


    printf("End of second schema read\n"); 


    // At this point, we have the two schemas loaded in two schema caches,
    // the schema in the source server pointed to by SchemaPtr1 and the 
    // the schema in the target server  by SchemaPtr2. 
    // Now look for adds. deletes, and mods between the target and the 
    // source schemas. Note that the order of Add/Modify/Delete is important
    // to take care of possible dependencies between schema operations

    fp = fopen( pOutFile,"w" );
    FindAdds( fp, SchemaPtr1, SchemaPtr2 );
    FindModify( fp, SchemaPtr1, SchemaPtr2 );
    FindDeletes( fp, SchemaPtr1, SchemaPtr2 );
    fclose( fp );
    fclose( logfp );
    fclose( OIDfp );
     

         // Free all allocated memory 
    printf("freeing memory\n");

    FreeCache( SchemaPtr1 );
    FreeCache( SchemaPtr2 );

    free( SchemaPtr1 );
    free( SchemaPtr2 );

    free( pSrcSchemaDN );
    free( pTargetSchemaDN );
   

};


// Define the list of attributes of an attribute-schema and a 
// class-schema object that we are interested in. Basically,
// we will read all attributes, but read the OID-syntaxed ones
// in binary to get back the BER-encoded strings for them

char *AttrSchList[] = {
       "attributeId;binary",
       "ldapDisplayName",
       "distinguishedName",
       "adminDisplayName",
       "adminDescription",
       "attributeSyntax;binary",
//       "nTSecurityDescriptor",
       "isSingleValued",
       "rangeLower",
       "rangeUpper",
       "mapiID",
       "linkID",
       "schemaIDGuid",
       "attributeSecurityGuid",
       "omObjectClass",
       "omSyntax",
       "searchFlags",
       "systemOnly",
       "showInAdvancedViewOnly",
       "isMemberOfPartialAttributeSet",
       "extendedCharsAllowed",
       "systemFlags",
     };

int cAttrSchList = sizeof(AttrSchList) / sizeof(AttrSchList[0]);

char *ClsSchList[] = {
       "governsId;binary",
       "ldapDisplayName",
       "distinguishedName",
       "adminDisplayName",
       "adminDescription",
       "defaultSecurityDescriptor",
//       "nTSecurityDescriptor",
       "defaultObjectCategory",
       "rDNAttId;binary",
       "objectClassCategory",
       "subClassOf;binary",
       "systemAuxiliaryClass;binary",
       "auxiliaryClass;binary",
       "systemPossSuperiors;binary",
       "possSuperiors;binary",
       "systemMustContain;binary",
       "mustContain;binary",
       "systemMayContain;binary",
       "mayContain;binary",
       "schemaIDGuid",
       "systemOnly",
       "systemFlags",
       "showInAdvancedViewOnly",
       "defaultHidingValue",
     }; 

int cClsSchList = sizeof(ClsSchList) / sizeof(ClsSchList[0]);

///////////////////////////////////////////////////////////////
// Routine Description:
//      Read the schema from the schema NC in the machine
//      pServerName, and load it in the cache tables. 
//      If no user name is specified, default is "administrator"
//      If no password is specified, defualt is "no password"
//
// Arguments: 
//      pServerName - Server Name
//      pDomainName - Domain name
//      pUserName   - User name (NULL if no user specified)
//      pPasswd     - Passwd (NULL if o passwd speciifed)
//      ppSchemaDN   - Pointer to store newly allocated schema NC DN should be freed 
//                     by caller
//      SCPtr       - Pointer to schema cache to load
//
// Return Value: 
//      0 if no errors, non-0 if error
///////////////////////////////////////////////////////////////

int SchemaRead( char *pServerName, 
                char *pDomainName, 
                char *pUserName, 
                char *pPasswd, 
                char **ppSchemaDN, 
                SCHEMAPTR *SCPtr)
{
   SEC_WINNT_AUTH_IDENTITY Credentials;
	LDAP            *ld;
	LDAPMessage     *res, *e;
    LDAPSearch      *pSearchPage = NULL;
    void            *ptr;
    char            *a;
    struct berval  **vals;
    ULONG            status;
    ULONG            version = 3;
    char *temp;

    struct l_timeval    strTimeLimit={ 600,0 };
    ULONG               ulDummyCount=0;
    const               cSize=100;


    char            **attrs = NULL;
    int              i;
    int              err;

    int count = 1;

    // open a connection to machine named MachineName
    if ( (ld = ldap_open( pServerName, LDAP_PORT )) == NULL ) {
        printf("Failed to open connection to %s\n", pServerName);
        return(1);
    }

    printf("Opened connection to %s\n", pServerName); 

    // Set version to 3
    ldap_set_option( ld, LDAP_OPT_VERSION, &version );


    attrs = MallocExit(2 * sizeof(char *));
    attrs[0] = _strdup("schemaNamingContext"); 
    attrs[1] = NULL;
    if ( ldap_search_s( ld,
                        "",
                        LDAP_SCOPE_BASE,
                        "(objectclass=*)",
                        attrs,
                        0,
                        &res ) != LDAP_SUCCESS ) {
          printf("Root DSE search failed\n");
          ldap_msgfree( res );
          return( 1 );
      }

    for ( e = ldap_first_entry( ld, res );
          e != NULL;
          e = ldap_next_entry( ld, e ) ) {

       for ( a = ldap_first_attribute( ld, e,
                                      (struct berelement**)&ptr);
             a != NULL;
             a = ldap_next_attribute( ld, e, (struct berelement*)ptr ) ) {
  
             vals = ldap_get_values_len( ld, e, a );

             if ( !_stricmp(a,"schemaNamingContext") ) {
                    *ppSchemaDN = MallocExit(vals[0]->bv_len + 1);
                    memcpy( *ppSchemaDN, vals[0]->bv_val, vals[0]->bv_len );
                    (*ppSchemaDN)[vals[0]->bv_len] = '\0';
             }
             ldap_value_free_len( vals );
       }
    }
    ldap_msgfree( res );
    free( attrs[0] );
    free( attrs ); attrs = NULL;



/************
    // do simple bind

    if ( pUserName == NULL ) {
       // No user specified, bind as administrator
        strcpy( pszBuffer, "CN=Administrator,CN=Users," );
    }
    else {
        strcpy( pszBuffer,"CN=" );
        strcat( pszBuffer,pUserName );
        strcat( pszBuffer,",CN=Users," );
    }
    strcat( pszBuffer, DomainDN );


    if ( (err = ldap_simple_bind_s( ld, pszBuffer, pPasswd))
                    != LDAP_SUCCESS ) {
           printf("Simple bind to server %s, domain %s with user %s failed, error is %d\n", pServerName, DomainDN, pszBuffer, err);
           return( 1 );
       }

    printf("Successfully bound to %s\n", pServerName);
***********/


    // Do SSPI bind
    memset(&Credentials, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));
    Credentials.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;    
    
    // Domain name must be there. If User Name is not supplied,
    // use "administrator". If no password is supplied, use null

    Credentials.Domain = pDomainName;
    Credentials.DomainLength = strlen(pDomainName);
    if ( pUserName == NULL ) {    
      Credentials.User = "Administrator";
      Credentials.UserLength = strlen("Administrator");
    }
    else {
      Credentials.User = pUserName;
      Credentials.UserLength = strlen(pUserName);
    }
    if ( pPasswd == NULL ) {
      Credentials.Password = "";
      Credentials.PasswordLength = 0;
    }
    else {
      Credentials.Password = pPasswd;
      Credentials.PasswordLength = strlen(pPasswd); 
    }


    err = ldap_bind_s(ld,
              NULL,  // use credentials instead
              (VOID*) &Credentials,
              LDAP_AUTH_SSPI);

    if (err != LDAP_SUCCESS) {
         printf("SSPI bind failed %d\n", err);
         return (1);
    }

    printf( "SSPI bind succeeded\n");






      // Select the attributes of an attribute schema object to 
      // search for. We want all attributes 

    attrs = MallocExit((cAttrSchList + 1) * sizeof(char *));
    for ( i = 0; i < cAttrSchList; i++ ) {
       
       attrs[i] = _strdup(AttrSchList[i]);
    }
    attrs[i] = NULL;


	  // Search for  attribute schema entries, return all attrs  
      // Since no. of attributes is large, we need to do paged search

      // initialize the paged search
      pSearchPage = ldap_search_init_page( ld,
                                           *ppSchemaDN,
                                           LDAP_SCOPE_ONELEVEL, 
                                           "(objectclass=attributeSchema)",
                                           attrs,
                                           0,
                                           NULL,
                                           NULL,
                                           600,
                                           0,
                                           NULL
                                         );


      if ( !pSearchPage )
         {
            printf("SchemaRead: Error initializing paged Search\n");
            return 1;
         }  


      while( TRUE )
          {
             status = ldap_get_next_page_s( ld,
                                            pSearchPage,
                                            &strTimeLimit,
                                            cSize,
                                            &ulDummyCount,
                                            &res
                                          );

             if ( status == LDAP_TIMEOUT )
             {
                printf("timeout: continuing\n");
                continue;

             }

             if ( status == LDAP_SUCCESS )
             {
               printf("Got Page %d\n", count++);
               if ( AddAttributesToCache( ld, res, SCPtr ) != 0 ) {
                 printf("Error adding attribute schema objects in AddAttributestoCache\n");
                 return( 1 );
                };

                continue;

             }

             if ( status == LDAP_NO_RESULTS_RETURNED )
             {
                 printf("End Page %d\n", count);
                 // these are signs that our paged search is done
                 status = LDAP_SUCCESS;
                 break;
             }
             else {
               printf("SchemaRead: Unknown error in paged search: %d\n", status);
               return 1;
             }

          }// while 


      // Free the attrs array entries

    for( i = 0; i < cAttrSchList; i++ )
      { free( attrs[i] ); }
    free( attrs ); attrs = NULL;
	  // free the search results

    ldap_msgfree( res );


     // Now search for class schema objects. Select the attributes 
     // to search for. We want all attributes, but we want the values 
     // of governsId, RDNAttId, subClassof, systemAuxiliaryClass, 
     // systemPossSuperiors, systemMayContain and systemMustContain 
     // in binary (as dotted decimal OID strings)
    attrs = MallocExit((cClsSchList + 1) * sizeof(char *));
    for ( i = 0; i < cClsSchList; i++ ) {
       attrs[i] = _strdup(ClsSchList[i]);
    }
    attrs[i] = NULL;


      // Now search for all class schema entries and get all attributes 

	if ( ldap_search_s( ld,
                        *ppSchemaDN,
			            LDAP_SCOPE_ONELEVEL,
			            "(objectclass=classSchema)",
			            attrs,
		        	    0,
			            &res ) != LDAP_SUCCESS ) {
		  ldap_perror( ld, "ldap_search_s" );
		  printf("Insuccess");
		  return( 1 );
	  }
	else
		printf("Success\n");

      //  Find all class schema entries and add to class cache structure 

    if ( AddClassesToCache( ld, res, SCPtr ) != 0 ) {  
         printf("Error adding class schema objects in AddClasstoCache\n");
         return( 1 );
       };  

      // Free the attrs array entries

     for( i = 0; i < cClsSchList; i++ ) { free( attrs[i] ); }
     free( attrs ); attrs = NULL;
	  // Free the search results 

	ldap_msgfree( res );   

	// End of schema read. Close and free connection resources 

	ldap_unbind( ld );

    return(0);
}




///////////////////////////////////////////////////////////////////////
// Routine Description:
//     Find all schema objects that occur in source schema but not in the
//     target, and  write them out in a ldif file so that they will
//     be added to the target schema
//
// Arguments: 
//     fp     -- File pointer to (opened) ldif output file
//     SCPtr1 - Pointer to the source schema
//     SCPtr2 - Pointer to the target schema
//
// Retuen Value: None
///////////////////////////////////////////////////////////////////////

void FindAdds( FILE *fp, SCHEMAPTR *SCPtr1, SCHEMAPTR *SCPtr2 )
{
    ATT_CACHE    *pac, *p1;
    CLASS_CACHE  *pcc, *p2;
    HASHCACHE    *ahcId, *ahcClass; 
    HASHCACHESTRING *ahcName, *ahcClassName;
    ULONG         ATTCOUNT, CLSCOUNT;
    ATT_CACHE    *ppAttAdds[MAX_ATT_CHANGE]; 
    CLASS_CACHE  *ppClsAdds[MAX_CLS_CHANGE]; 
    ULONG         Id;
    ULONG         i, j, cnt = 0;

    // First find all objects that appear in source schema but
    // not in target. These will be adds to the target schema

    ahcId    = SCPtr1->ahcId;
    ahcClass = SCPtr1->ahcClass ;
    ahcName  = SCPtr1->ahcName;
    ahcClassName = SCPtr1->ahcClassName ;
    ATTCOUNT = SCPtr1->ATTCOUNT;
    CLSCOUNT = SCPtr1->CLSCOUNT;

    for ( i = 0; i < ATTCOUNT; i++ )
        { if ( (ahcName[i].pVal != NULL) && (ahcName[i].pVal != FREE_ENTRY) ) {
          pac = (ATT_CACHE *) ahcName[i].pVal;
          if( GetAttByName(SCPtr2, pac->nameLen, pac->name, &p1) != 0 )
             { 
               ppAttAdds[cnt++] = pac;
             }
          }
     }
    FileWrite_AttAdd( fp, ppAttAdds, cnt );
   
    cnt = 0;
    for ( i = 0; i < CLSCOUNT; i++ )
        { if ( (ahcClassName[i].pVal != NULL) 
                  && (ahcClassName[i].pVal != FREE_ENTRY) ) {
          pcc = (CLASS_CACHE *) ahcClassName[i].pVal;
          if( GetClassByName(SCPtr2, pcc->nameLen, pcc->name, &p2) != 0 )
            { 
              ppClsAdds[cnt++] = pcc;
            }
          }
     }

     // Ok, now we got the list of classes to be added. Now do a 
     // dependency analysis to add the classes in the right order

     for ( i = 0; i < cnt; i++ ) {

        for( j = i+1; j < cnt; j++ ) {
           p2 = ppClsAdds[i];
           Id = ppClsAdds[j]->ClassId;
           if ( IsMemberOf( Id, p2->pSubClassOf, p2->SubClassCount )
                  || IsMemberOf( Id, p2->pAuxClass, p2->AuxClassCount )
                  || IsMemberOf( Id, p2->pSysAuxClass, p2->SysAuxClassCount )
                  || IsMemberOf( Id, p2->pPossSup, p2->PossSupCount )
                  || IsMemberOf( Id, p2->pSysPossSup, p2->SysPossSupCount )
              ) {
             ppClsAdds[i] = ppClsAdds[j];
             ppClsAdds[j] = p2;
           }
        }
     }
     FileWrite_ClsAdd( fp, ppClsAdds, cnt );
}


///////////////////////////////////////////////////////////////////////
// Routine Description:
//     Find all schema objects that occur in the target schema but not 
//     in the source schema, and wirte out to the ldif file so that
//     they will be deleted from the target schema
//
// Arguments:
//     fp     - File pointer to (opened) ldif output file
//     SCPtr1 - Pointer to the source schema
//     SCPtr2 - Pointer to the target schema
//
// Retuen Value: None
///////////////////////////////////////////////////////////////////////

void FindDeletes( FILE *fp, SCHEMAPTR *SCPtr1, SCHEMAPTR *SCPtr2 )
{
    ATT_CACHE    *pac, *p1;
    CLASS_CACHE  *pcc, *p2;
    HASHCACHE    *ahcId, *ahcClass;
    HASHCACHESTRING *ahcName, *ahcClassName;
    ULONG         ATTCOUNT, CLSCOUNT;
    ATT_CACHE    *ppAttDels[MAX_ATT_CHANGE];
    CLASS_CACHE  *ppClsDels[MAX_CLS_CHANGE];
    ULONG         Id;
    ULONG         i, j, cnt = 0;
    

    // Find the objects that
    // needs to be deleted on the target schema
    
    ahcId    = SCPtr2->ahcId;
    ahcClass = SCPtr2->ahcClass ;
    ahcName  = SCPtr2->ahcName;
    ahcClassName = SCPtr2->ahcClassName ;
    ATTCOUNT = SCPtr2->ATTCOUNT;
    CLSCOUNT = SCPtr2->CLSCOUNT;


    for ( i = 0; i < CLSCOUNT; i++ )
        { if ( (ahcClassName[i].pVal != NULL) 
                   && (ahcClassName[i].pVal != FREE_ENTRY) ) {
          pcc = (CLASS_CACHE *) ahcClassName[i].pVal;
          if( GetClassByName(SCPtr1, pcc->nameLen, pcc->name, &p2) != 0 )
             { 
               ppClsDels[cnt++] = pcc;
             }
          }
     }

    // Now order the deletes to take care of dependencies

     for ( i = 0; i < cnt; i++ ) {
        for( j = i+1; j < cnt; j++ ) {
           p2 = ppClsDels[j];
           Id = ppClsDels[i]->ClassId;
           if ( IsMemberOf( Id, p2->pSubClassOf, p2->SubClassCount )
                  || IsMemberOf( Id, p2->pAuxClass, p2->AuxClassCount )
                  || IsMemberOf( Id, p2->pSysAuxClass, p2->SysAuxClassCount )
                  || IsMemberOf( Id, p2->pPossSup, p2->PossSupCount )
                  || IsMemberOf( Id, p2->pSysPossSup, p2->SysPossSupCount )
              ) {
             ppClsDels[j] = ppClsDels[i];
             ppClsDels[i] = p2;
           }
        }
     }
    FileWrite_ClsDel(fp, ppClsDels, cnt);

    cnt = 0;
    p1 = (ATT_CACHE *) MallocExit( sizeof(ATT_CACHE) );
    for ( i = 0; i < ATTCOUNT; i++ )
        { if ( (ahcName[i].pVal != NULL) && (ahcName[i].pVal != FREE_ENTRY) ) {
          pac = (ATT_CACHE *) ahcName[i].pVal;
          if( GetAttByName(SCPtr1, pac->nameLen, pac->name, &p1) != 0 )
             {
               ppAttDels[cnt++] = pac;
             }
          }
     }
    FileWrite_AttDel( fp, ppAttDels, cnt );

}




///////////////////////////////////////////////////////////////////////
// Routine Description:
//     Find and write out to an ldif file all schema objects in target
//     schema that needs to be modified because they are different from 
//     the same object in the source schema (same = same OID)
//
// Arguments:
//     fp     -- File pointer to (opened) ldif output file
//     SCPtr1 - Pointer to the source schema
//     SCPtr2 - Pointer to the target schema
//
// Retuen Value: None
///////////////////////////////////////////////////////////////////////


void FindModify( FILE *fp, SCHEMAPTR *SCPtr1, SCHEMAPTR *SCPtr2 )
{
    ATT_CACHE    *pac, *p1;
    CLASS_CACHE  *pcc, *p2;
    ULONG         i;
    HASHCACHE    *ahcId    = SCPtr1->ahcId ;
    HASHCACHE    *ahcClass = SCPtr1->ahcClass ;
    ULONG         ATTCOUNT = SCPtr1->ATTCOUNT;
    ULONG         CLSCOUNT = SCPtr1->CLSCOUNT;

      // Find and write attribute modifications

    for ( i = 0; i < ATTCOUNT; i++ )
      { if ( (ahcId[i].pVal != NULL ) && (ahcId[i].pVal != FREE_ENTRY) ) {
          pac = (ATT_CACHE *) ahcId[i].pVal;
          FindAttModify( fp, pac, SCPtr2 );
        };
      }

    printf("No. of attributes modified %d\n", NoOfMods);
    NoOfMods = 0;
        
      // Find and write class modifications

    for ( i = 0; i < CLSCOUNT; i++)
      { if ( (ahcClass[i].pVal != NULL) 
                 && (ahcClass[i].pVal != FREE_ENTRY) ) {
          pcc = (CLASS_CACHE *) ahcClass[i].pVal;
          FindClassModify( fp, pcc, SCPtr2 );
        };
      }
    printf("No. of classes modified %d\n", NoOfMods);

}




///////////////////////////////////////////////////////////////////////
// Routine Descrpition:
//     Given an attribute schema object, find any/all  modifications
//     that need to be made to it because it is different from
//     the same attribute schema object in the source schema. 
//     Modifications to non-system-only attributeas are written out
//     to an ldif files, warnings are generated in the log file
//     if any system-only attribute needs to be modified. 
//
// Arguments: 
//     fp  - File pointer to (opened) ldif output file
//     pac - ATT_CACHE to compare
//     SCPtr - Pointer to source schema to look up
//
// Return Value: None
////////////////////////////////////////////////////////////////////////

void FindAttModify( FILE *fp, ATT_CACHE *pac, SCHEMAPTR *SCPtr )
{
    ULONG          i;
    ULONG          ATTCOUNT = SCPtr->ATTCOUNT;
    ATT_CACHE     *p;
    
    MODIFYSTRUCT   ModStruct;
    ULONG          modCount = 0;
    ULONGLIST     *pL1, *pL2;
    ATTRVAL       *pAVal;


     // Do a dummy LogConflict to reset the static flag in that
     // routine. This is done to print out only attributes for which
     // conflicts have been found
     
    if( GetAttByName( SCPtr, pac->nameLen, pac->name, &p ) == 0 ) {

      // There exists an attribute schema object with the same AttId.
      // Now compare the two objects and look for changes

           // ldap-diplay-name (every schema obj. has one, so if
           // they don't match, simply replace with the one in
           // source schema)

       if ( _stricmp( pac->name,p->name ) != 0 )  {
           pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
           pAVal->valLen = pac->nameLen;
           pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
           memcpy( pAVal->pVal, pac->name, pAVal->valLen + 1 ); 
           AddToModStruct( &(ModStruct.ModList[modCount]), 
                           AT_CHOICE_REPLACE_ATT, 
                           ATT_LDAP_DISPLAY_NAME, 
                           STRING_TYPE, 
                           1, 
                           pAVal);
           modCount++;
       }

            // admin-display-name (same logic as ldap-display-name)

       if ( _stricmp( pac->adminDisplayName,p->adminDisplayName ) != 0 )  {
           pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
           pAVal->valLen = pac->adminDisplayNameLen;
           pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
           memcpy( pAVal->pVal, pac->adminDisplayName, pAVal->valLen + 1 );
           AddToModStruct( &(ModStruct.ModList[modCount]), 
                           AT_CHOICE_REPLACE_ATT, 
                           ATT_ADMIN_DISPLAY_NAME, 
                           STRING_TYPE, 
                           1, 
                           pAVal);
           modCount++;
       }

           // admin-description (no action necessary if not present
           // in both the given attribute and the matching attribute in
           // source schema, or if present in both but same. Otherwise,
           // need to modify) 

       if ( (pac->adminDescr || p->adminDescr) &&
                ( !(pac->adminDescr)  ||
                  !(p->adminDescr)  ||
                  ( _stricmp(pac->adminDescr,p->adminDescr) != 0) 
                )   // End &&
          )  {
              pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
              if ( pac->adminDescr ) {

                 // present in source schema. So replace with source value
                 // if also present in given attribute, else add the source
                 // value to the given attribute

                 pAVal->valLen = pac->adminDescrLen;
                 pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
                 memcpy( pAVal->pVal, pac->adminDescr, pAVal->valLen + 1 ); 
                 if ( p->adminDescr ) {
                     AddToModStruct( &(ModStruct.ModList[modCount]), 
                                     AT_CHOICE_REPLACE_ATT, 
                                     ATT_ADMIN_DESCRIPTION, 
                                     STRING_TYPE, 
                                     1, 
                                     pAVal);
                 }
                 else {
                     AddToModStruct( &(ModStruct.ModList[modCount]), 
                                     AT_CHOICE_ADD_VALUES, 
                                     ATT_ADMIN_DESCRIPTION, 
                                     STRING_TYPE, 
                                     1, 
                                     pAVal);
                 }
              }
              else {
                 // not present in source schema, so remove the
                 // value from the given attribute

                 pAVal->valLen = p->adminDescrLen;
                 pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
                 memcpy( pAVal->pVal, p->adminDescr, pAVal->valLen + 1 ); 
                 AddToModStruct( &(ModStruct.ModList[modCount]), 
                                 AT_CHOICE_REMOVE_VALUES, 
                                 ATT_ADMIN_DESCRIPTION, 
                                 STRING_TYPE, 
                                 1, 
                                 pAVal);
              }

              modCount++;
          }

              // range-lower (similar logic as admin-description above)

      if ( (pac->rangeLowerPresent != p->rangeLowerPresent)
             || ( (pac->rangeLowerPresent && p->rangeLowerPresent)  &&
                    (pac->rangeLower != p->rangeLower) ) // end of ||
         ) {
          
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                     pac, p, ATT_RANGE_LOWER );

           modCount++;
       }

             // range-upper

      if ( (pac->rangeUpperPresent != p->rangeUpperPresent)
             || ( (pac->rangeUpperPresent && p->rangeUpperPresent)  &&
                    (pac->rangeUpper != p->rangeUpper) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_RANGE_UPPER );
           modCount++;
       }

            // Search-Flags

      if ( (pac->bSearchFlags != p->bSearchFlags)
             || ( (pac->bSearchFlags && p->bSearchFlags)  &&
                    (pac->SearchFlags != p->SearchFlags) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_SEARCH_FLAGS );
           modCount++;
       }


          // System-Flags

      if ( (pac->bSystemFlags != p->bSystemFlags)
             || ( (pac->bSystemFlags && p->bSystemFlags)  &&
                    (pac->sysFlags != p->sysFlags) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_SYSTEM_FLAGS );
           modCount++;
       }


           // Hide-From-Address-Book

      if ( (pac->bHideFromAB != p->bHideFromAB)
             || ( (pac->bHideFromAB && p->bHideFromAB)  &&
                    (pac->HideFromAB != p->HideFromAB) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_SHOW_IN_ADVANCED_VIEW_ONLY );
           modCount++;
       }


           // System-Only

      if ( (pac->bSystemOnly != p->bSystemOnly)
             || ( (pac->bSystemOnly && p->bSystemOnly)  &&
                    (pac->SystemOnly != p->SystemOnly) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_SYSTEM_ONLY );
           modCount++;
       }
       
           // Is-Single-Valued

      if ( (pac->bisSingleValued != p->bisSingleValued)
             || ( (pac->bisSingleValued && p->bisSingleValued)  &&
                    (pac->isSingleValued != p->isSingleValued) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_IS_SINGLE_VALUED );
           modCount++;
       }

         // Member-Of-Partial-Attribute-Set

      if ( (pac->bMemberOfPartialSet != p->bMemberOfPartialSet)
             || ( (pac->bMemberOfPartialSet && p->bMemberOfPartialSet)  &&
                    (pac->MemberOfPartialSet != p->MemberOfPartialSet) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, 
                                    ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET );
           modCount++;
       }

          // Attribute-Security-Guid

      if ( (pac->bPropSetGuid != p->bPropSetGuid)
             || ( (pac->bPropSetGuid && p->bPropSetGuid)  &&
                     (memcmp(&(pac->propSetGuid), &(p->propSetGuid), sizeof(GUID)) != 0 ) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_ATTRIBUTE_SECURITY_GUID );
           modCount++;
       }

          // NT-Security-Descriptor

       if ( (pac->NTSDLen != p->NTSDLen)  ||
               (memcmp(pac->pNTSD, p->pNTSD, pac->NTSDLen) != 0) 
          ) {
           pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
           pAVal->valLen = pac->NTSDLen;
           pAVal->pVal = (UCHAR *) MallocExit(pac->NTSDLen);
           memcpy( pAVal->pVal, pac->pNTSD, pac->NTSDLen );
           AddToModStruct( &(ModStruct.ModList[modCount]),
                           AT_CHOICE_REPLACE_ATT,
                           ATT_NT_SECURITY_DESCRIPTOR,
                           BINARY_TYPE,
                           1,
                           pAVal);
           modCount++;
       }

       if (modCount != 0) {
          // at least one attribute needs to be modified,
          // so write out to ldif file
           NoOfMods++;
           ModStruct.count = modCount;
           FileWrite_Mod( fp, p->DN, &ModStruct );
       }

       // Check for modifications to System-Only Attributes. We will 
       // only generate warnings for these

       if ( pac->syntax != p->syntax ) 
             GenWarning( 'a', ATT_ATTRIBUTE_SYNTAX, pac->name );
       if ( pac->OMsyntax != p->OMsyntax ) 
             GenWarning( 'a', ATT_OM_SYNTAX, pac->name );
#if 0
Nope, a schema upgrade required modifications
       if ( pac->isSingleValued != p->isSingleValued ) 
             GenWarning( 'a', ATT_IS_SINGLE_VALUED, pac->name );
#endif 0
       if ( pac->ulMapiID != p->ulMapiID )
             GenWarning( 'a', ATT_MAPI_ID, pac->name );
#if 0
Nope, a schema upgrade required modifications
       if ( pac->bSystemOnly != p->bSystemOnly )
             GenWarning( 'a', ATT_SYSTEM_ONLY, pac->name );
#endif 0
       if ( pac->bExtendedChars != p->bExtendedChars )
             GenWarning( 'a', ATT_EXTENDED_CHARS_ALLOWED, pac->name );
       if ( memcmp(&(pac->propGuid), &(p->propGuid), sizeof(GUID)) != 0 )
             GenWarning( 'a', ATT_SCHEMA_ID_GUID, pac->name);
       if ( memcmp(&pac->propSetGuid, &p->propSetGuid, sizeof(GUID)) != 0 )
             GenWarning( 'a', ATT_ATTRIBUTE_SECURITY_GUID, pac->name );
      }
  
}


///////////////////////////////////////////////////////////////////////
// Routine Descrpition:
//     Given an class schema object, find any/all  modifications
//     that need to be made to it because it is different from
//     the same class schema object in the source schema.
//     Modifications to non-system-only attributeas are written out
//     to an ldif files, warnings are generated in the log file
//     if any system-only attribute needs to be modified.
//
// Arguments:
//     fp  - File pointer to (opened) ldif output file
//     pac - CLASS_CACHE to compare
//     SCPtr - Pointer to source schema to look up
//
// Return Value: None
////////////////////////////////////////////////////////////////////////

void FindClassModify( FILE *fp, CLASS_CACHE *pcc, SCHEMAPTR *SCPtr )
{
    ULONG         i;
    ULONG         CLSCOUNT = SCPtr->CLSCOUNT;
    CLASS_CACHE  *p;

    MODIFYSTRUCT  ModStruct;
    ULONG         modCount = 0, tempCount;
    ULONGLIST    *pL1, *pL2;
    ATTRVAL      *pAVal;

    if ( GetClassByName( SCPtr, pcc->nameLen, pcc->name, &p ) == 0 ) {

      // There exists a class schema object with the same ClassId.
      // Now compare the two objects and look for changes

           // ldap-diplay-name (every schema obj. has one, so if
           // they don't match, simply replace with the one in
           // source schema)

       if ( _stricmp( pcc->name,p->name ) != 0 ) {
           pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
           pAVal->valLen = pcc->nameLen;
           pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
           memcpy( pAVal->pVal, pcc->name, pAVal->valLen + 1 ); 
           AddToModStruct( &(ModStruct.ModList[modCount]), 
                           AT_CHOICE_REPLACE_ATT, 
                           ATT_LDAP_DISPLAY_NAME, 
                           STRING_TYPE, 
                           1, 
                           pAVal);
           modCount++;       
       }

           // admin-display-name (same logic as ldap-display-name)

       if ( _stricmp( pcc->adminDisplayName,p->adminDisplayName ) != 0 )  {
           pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
           pAVal->valLen = pcc->adminDisplayNameLen;
           pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
           memcpy( pAVal->pVal, pcc->adminDisplayName, pAVal->valLen + 1 );
           AddToModStruct( &(ModStruct.ModList[modCount]), 
                           AT_CHOICE_REPLACE_ATT, 
                           ATT_ADMIN_DISPLAY_NAME, 
                           STRING_TYPE, 
                           1, 
                           pAVal);
           modCount++;
       }
          // System-Flags

      if (pcc->ClassCategory != p->ClassCategory) {
          pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
          pAVal->pVal = (UCHAR *) MallocExit(16);
          _ultoa(pcc->ClassCategory, pAVal->pVal, 10 );
          pAVal->valLen = strlen(pAVal->pVal);
          AddToModStruct( &(ModStruct.ModList[modCount]), 
                          AT_CHOICE_REPLACE_ATT, 
                          ATT_OBJECT_CLASS_CATEGORY,
                          STRING_TYPE, 
                          1, 
                          pAVal);
           modCount++;
       }

           // NT-Security-Descriptor

       if ( (pcc->NTSDLen != p->NTSDLen)  ||
               (memcmp(pcc->pNTSD, p->pNTSD, pcc->NTSDLen) != 0)
          ) {
           pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
           pAVal->valLen = pcc->NTSDLen;
           pAVal->pVal = (UCHAR *) MallocExit(pcc->NTSDLen);
           memcpy( pAVal->pVal, pcc->pNTSD, pcc->NTSDLen );
           AddToModStruct( &(ModStruct.ModList[modCount]),
                           AT_CHOICE_REPLACE_ATT,
                           ATT_NT_SECURITY_DESCRIPTOR,
                           BINARY_TYPE,
                           1,
                           pAVal);
           modCount++;
       }

          // admin-description (no action necessary if not present
          // in both the given class and the matching class in
          // source schema, or if present in both but same. Otherwise,
          // need to modify)

       if ( (pcc->adminDescr || p->adminDescr) &&
               ( !(pcc->adminDescr)  ||
                 !(p->adminDescr)  ||
                 ( _stricmp(pcc->adminDescr,p->adminDescr) != 0) 
               )   /* && */
          )  {
              pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
              if (pcc->adminDescr) {
                 pAVal->valLen = pcc->adminDescrLen;
                 pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
                 memcpy( pAVal->pVal, pcc->adminDescr, pAVal->valLen + 1 ); 
                 if ( p->adminDescr ) {
                     AddToModStruct( &(ModStruct.ModList[modCount]), 
                                     AT_CHOICE_REPLACE_ATT, 
                                     ATT_ADMIN_DESCRIPTION, 
                                     STRING_TYPE, 
                                     1, 
                                     pAVal);
                 }
                 else {
                     AddToModStruct( &(ModStruct.ModList[modCount]), 
                                     AT_CHOICE_ADD_VALUES, 
                                     ATT_ADMIN_DESCRIPTION, 
                                     STRING_TYPE, 
                                     1, 
                                     pAVal);
                 }
              }
              else {
                 pAVal->valLen = p->adminDescrLen;
                 pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
                 memcpy( pAVal->pVal, p->adminDescr, pAVal->valLen + 1 ); 
                 AddToModStruct( &(ModStruct.ModList[modCount]), 
                                 AT_CHOICE_REMOVE_VALUES, 
                                 ATT_ADMIN_DESCRIPTION, 
                                 STRING_TYPE, 
                                 1, 
                                 pAVal);
              }
              
              modCount++;
          }

         // default-security-descriptor (similar logic as 
         // admin-description above)

      if ( (pcc->SDLen || p->SDLen ) &&
              ( (pcc->SDLen != p->SDLen) ||
                   (memcmp(pcc->pSD, p->pSD, pcc->SDLen) != 0)
              )  // &&
         ) {
              CreateFlagBasedClsModStr( &(ModStruct.ModList[modCount]),
                                        pcc, p, 
                                        ATT_DEFAULT_SECURITY_DESCRIPTOR);
              modCount++;
       } 

         // Hide-From-Address-Book

      if ( (pcc->bHideFromAB != p->bHideFromAB)
             || ( (pcc->bHideFromAB && p->bHideFromAB)  &&
                    (pcc->HideFromAB != p->HideFromAB) ) // end of ||
         ) {
           CreateFlagBasedClsModStr( &(ModStruct.ModList[modCount]),
                                    pcc, p, ATT_SHOW_IN_ADVANCED_VIEW_ONLY );
           modCount++;
       }

        // Default-Hiding-Value

      if ( (pcc->bDefHidingVal != p->bDefHidingVal)
             || ( (pcc->bDefHidingVal && p->bDefHidingVal)  &&
                    (pcc->DefHidingVal != p->DefHidingVal) ) // end of ||
         ) {
           CreateFlagBasedClsModStr( &(ModStruct.ModList[modCount]),
                                    pcc, p, ATT_DEFAULT_HIDING_VALUE );
           modCount++;
       }
     

        // And finally the mays, musts, possSups, and auxClasses

      if ( CompareUlongList( pcc->pMayAtts, pcc->MayCount,  
                             p->pMayAtts, p->MayCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_MAY_CONTAIN);
       }

      if ( CompareUlongList( pcc->pSysMayAtts, pcc->SysMayCount,  
                             p->pSysMayAtts, p->SysMayCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_SYSTEM_MAY_CONTAIN);
       }

      if ( CompareUlongList( pcc->pMustAtts, pcc->MustCount,  
                             p->pMustAtts, p->MustCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_MUST_CONTAIN);
       }

      if ( CompareUlongList( pcc->pSysMustAtts, pcc->SysMustCount,  
                             p->pSysMustAtts, p->SysMustCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_SYSTEM_MUST_CONTAIN);
       }

      if ( CompareUlongList( pcc->pPossSup, pcc->PossSupCount,  
                             p->pPossSup, p->PossSupCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_POSS_SUPERIORS);
       }

      if ( CompareUlongList( pcc->pSysPossSup, pcc->SysPossSupCount,  
                             p->pSysPossSup, p->SysPossSupCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_SYSTEM_POSS_SUPERIORS);
       }

      if ( CompareUlongList( pcc->pSysAuxClass, pcc->SysAuxClassCount, 
                             p->pSysAuxClass, p->SysAuxClassCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_SYSTEM_AUXILIARY_CLASS);
       }

       if (modCount != 0) {
          // at least one attribute needs to be modified
          // so write out to ldif file
           NoOfMods++;
           ModStruct.count = modCount;
           FileWrite_Mod( fp, p->DN, &ModStruct ); 
       }


       // For system-only attributes, we do not write to the ldif file,
       // just generate a warning in the log file

       if ( pcc->SDLen != p->SDLen ) {
           GenWarning( 'c', ATT_DEFAULT_SECURITY_DESCRIPTOR, pcc->name );
       }
       else { if( memcmp( pcc->pSD, p->pSD, p->SDLen) !=0 )
                GenWarning( 'c', ATT_DEFAULT_SECURITY_DESCRIPTOR, pcc->name );
         };
       if ( pcc->RDNAttIdPresent != p->RDNAttIdPresent ) {
           GenWarning( 'c', ATT_RDN_ATT_ID, pcc->name );
        }
       if ( pcc->RDNAttIdPresent && p->RDNAttIdPresent ) {
         if ( pcc->RDNAttId != p->RDNAttId )
              GenWarning( 'c', ATT_RDN_ATT_ID, pcc->name );
       }
       if ( pcc->bSystemOnly != p->bSystemOnly ) {
            GenWarning( 'c', ATT_SYSTEM_ONLY, pcc->name );
       }
       if ( memcmp(&(pcc->propGuid), &(p->propGuid), sizeof(GUID)) ) {
            GenWarning( 'c', ATT_SCHEMA_ID_GUID, p->name );
       }
       if ( pcc->SubClassCount != p->SubClassCount ) {
            GenWarning( 'c', ATT_SUB_CLASS_OF, pcc->name );
       }
       else {
           tempCount = p->SubClassCount;
           if ( CompareList( pcc->pSubClassOf, p->pSubClassOf,tempCount ) )
               GenWarning( 'c', ATT_SUB_CLASS_OF, pcc->name );
       }

      // system-may-contain, system-must-contain, system-poss-superiors,
      // and system-auxiliary-class are also added through the ldif file
      // to take care of of schema.ini changes. This warning is generated
      // in addition

       if ( pcc->SysAuxClassCount != p->SysAuxClassCount )  {
            GenWarning( 'c', ATT_SYSTEM_AUXILIARY_CLASS, pcc->name );
       }
       else {
           tempCount = p->SysAuxClassCount;
           if ( CompareList( pcc->pSysAuxClass, p->pSysAuxClass, tempCount ) )
               GenWarning( 'c', ATT_SYSTEM_AUXILIARY_CLASS, pcc->name );
       }
       if ( pcc->SysMustCount != p->SysMustCount )  {
            GenWarning( 'c', ATT_SYSTEM_MUST_CONTAIN, pcc->name );
       }
       else {
           tempCount = p->SysMustCount;
           if ( CompareList( pcc->pSysMustAtts, p->pSysMustAtts, tempCount ) )
               GenWarning( 'c', ATT_SYSTEM_MUST_CONTAIN, pcc->name );
       }
       if ( pcc->SysMayCount != p->SysMayCount )  {
            GenWarning( 'c', ATT_SYSTEM_MAY_CONTAIN,pcc->name );
       }
       else {
           tempCount = p->SysMayCount;
           if ( CompareList( pcc->pSysMayAtts, p->pSysMayAtts, tempCount ) )
               GenWarning( 'c', ATT_SYSTEM_MAY_CONTAIN, pcc->name );
       }
       if ( pcc->SysPossSupCount != p->SysPossSupCount)  {
            GenWarning( 'c', ATT_SYSTEM_POSS_SUPERIORS, pcc->name );
       }
       else {
           tempCount = p->SysPossSupCount;
           if ( CompareList( pcc->pSysPossSup, p->pSysPossSup, tempCount) )
               GenWarning( 'c', ATT_SYSTEM_POSS_SUPERIORS, pcc->name);
       }
    }


}

////////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//      Helper routine that takes in adds to a given attribute modlist
//      structure based on the given attribute. Reduces some code
//      duplication.
//
//  Arguments:
//      pModList - pointer to ATTR_MODLIST to fill up
//      pSrcAtt - ATT_CACHE from source schema
//      pTargetAtt - ATT_CACHE from target schema
//      attrTyp - attribute type of interest
//
//  Return Value: None
/////////////////////////////////////////////////////////////////////// 

void CreateFlagBasedAttModStr( MY_ATTRMODLIST *pModList,
                               ATT_CACHE *pSrcAtt,
                               ATT_CACHE *pTargetAtt,
                               ATTRTYP attrTyp)
{
    ATTRVAL    *pAVal;
    BOOL        fInSrc = FALSE, fInTarget = FALSE;
    int         printType = 0;
    ATT_CACHE  *pac = pSrcAtt;
    ATT_CACHE  *p = pTargetAtt;

    pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));

    switch (attrTyp) {

       case ATT_RANGE_LOWER:
           fInSrc = pac->rangeLowerPresent;
           fInTarget = p->rangeLowerPresent;
           printType = STRING_TYPE;

           pAVal->pVal = (UCHAR *) MallocExit(sizeof(ULONG)+1);
           if ( !(pac->rangeLowerPresent) ) {
             // No range lower in source, target value needs to be deleted
              _ultoa( p->rangeLower, pAVal->pVal, 10 );
           }
           else { _ultoa( pac->rangeLower, pAVal->pVal, 10 );}
           pAVal->valLen = strlen(pAVal->pVal);
           break;

       case ATT_RANGE_UPPER:
          fInSrc = pac->rangeUpperPresent;
          fInTarget = p->rangeUpperPresent;
           printType = STRING_TYPE;

          pAVal->pVal = (UCHAR *) MallocExit(sizeof(ULONG)+1);
          if ( !(pac->rangeUpperPresent) ) {
            // No range upper in source, target value needs to be deleted
             _ultoa( p->rangeUpper, pAVal->pVal, 10 );
          }
          else { _ultoa( pac->rangeUpper, pAVal->pVal, 10 );}
          pAVal->valLen = strlen(pAVal->pVal);
          break;
       case ATT_SEARCH_FLAGS:
          fInSrc = pac->bSearchFlags;
          fInTarget = p->bSearchFlags;
          printType = STRING_TYPE;
          pAVal->pVal = (UCHAR *) MallocExit(sizeof(ULONG)+1);
          if ( !(pac->bSearchFlags) ) {
             // No search flag in source, target value needs to be deleted
              _ultoa( p->SearchFlags, pAVal->pVal, 10 );
           }
           else { _ultoa( pac->SearchFlags, pAVal->pVal, 10 );}
           pAVal->valLen = strlen(pAVal->pVal);
           break;

       case ATT_SYSTEM_FLAGS:
          fInSrc = pac->bSystemFlags;
          fInTarget = p->bSystemFlags;
          printType = STRING_TYPE;

          pAVal->pVal = (UCHAR *) MallocExit(sizeof(ULONG)+1);
          if ( !(pac->bSystemFlags) ) {
            // No system-flag in source, target value needs to be deleted
             _ultoa( p->sysFlags, pAVal->pVal, 10 );
          }
          else { _ultoa( pac->sysFlags, pAVal->pVal, 10 );}
          pAVal->valLen = strlen(pAVal->pVal);
          break;

       case ATT_ATTRIBUTE_SECURITY_GUID:
          fInSrc = pac->bPropSetGuid;
          fInTarget = p->bPropSetGuid;
          printType = BINARY_TYPE;

          pAVal->pVal = (UCHAR *) MallocExit(sizeof(GUID));
          if ( !(pac->bPropSetGuid) ) {
            // No system-flag in source, target value needs to be deleted
             memcpy(pAVal->pVal, &(p->propSetGuid), sizeof(GUID) );
          }
          else { memcpy(pAVal->pVal, &(pac->propSetGuid), sizeof(GUID));}
          pAVal->valLen = sizeof(GUID);
          break;

       case ATT_SHOW_IN_ADVANCED_VIEW_ONLY:
           fInSrc = pac->bHideFromAB;
           fInTarget = p->bHideFromAB;
           printType = STRING_TYPE;
           pAVal->pVal = (UCHAR *) MallocExit(strlen("FALSE")+1); // TRUE or FALSE
           if ( !(pac->bHideFromAB) ) {
             if ( p->HideFromAB ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           else {
             if ( pac->HideFromAB ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           pAVal->valLen = strlen(pAVal->pVal);
           break;

       case ATT_SYSTEM_ONLY:
           fInSrc = pac->bSystemOnly;
           fInTarget = p->bSystemOnly;
           printType = STRING_TYPE;
           pAVal->pVal = (UCHAR *) MallocExit(strlen("FALSE")+1); // TRUE or FALSE
           if ( !(pac->bSystemOnly) ) {
             if ( p->SystemOnly ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           else {
             if ( pac->SystemOnly ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           pAVal->valLen = strlen(pAVal->pVal);
           break;

       case ATT_IS_SINGLE_VALUED:
           fInSrc = pac->bisSingleValued;
           fInTarget = p->bisSingleValued;
           printType = STRING_TYPE;
           pAVal->pVal = (UCHAR *) MallocExit(strlen("FALSE")+1); // TRUE or FALSE
           if ( !(pac->bisSingleValued) ) {
             if ( p->isSingleValued ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           else {
             if ( pac->isSingleValued ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           pAVal->valLen = strlen(pAVal->pVal);
           break;

       case ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET:
           fInSrc = pac->bMemberOfPartialSet;
           fInTarget = p->bMemberOfPartialSet;
           printType = STRING_TYPE;
           pAVal->pVal = (UCHAR *) MallocExit(strlen("FALSE")+1); // TRUE or FALSE
           if ( !(pac->bMemberOfPartialSet) ) {
             if ( p->MemberOfPartialSet ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           else {
             if ( pac->MemberOfPartialSet ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           pAVal->valLen = strlen(pAVal->pVal);
           break;
       default:
           printf("Error, don't understand attrTyp 0x%08x\n", attrTyp);
           exit(1);
     }  /* Switch */


     if ( !fInSrc ) {
         // not in source, delete from target
               AddToModStruct( pModList,
                               AT_CHOICE_REMOVE_VALUES,
                               attrTyp,
                               printType,
                               1,
                               pAVal);
      }
      else {
           if ( !fInTarget ) {
            // in source but not in target, add to target
               AddToModStruct( pModList,
                               AT_CHOICE_ADD_VALUES,
                               attrTyp,
                               printType,
                               1,
                               pAVal);
            }
            else {
               // in both source and target, so replace in target
               AddToModStruct( pModList,
                               AT_CHOICE_REPLACE_ATT,
                               attrTyp,
                               printType,
                               1,
                               pAVal);
            }
       }
}


////////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//      Helper routine that takes in adds to a given attribute modlist
//      structure based on the given attribute. Reduces some code
//      duplication.
//
//  Arguments:
//      pModList - pointer to ATTR_MODLIST to fill up
//      pSrcAtt - CLASS_CACHE from source schema
//      pTargetAtt - CLASS_CACHE from target schema
//      attrTyp - attribute type of interest
//
//  Return Value: None
///////////////////////////////////////////////////////////////////////

void CreateFlagBasedClsModStr( MY_ATTRMODLIST *pModList,
                               CLASS_CACHE *pSrcCls,
                               CLASS_CACHE *pTargetCls,
                               ATTRTYP attrTyp)
{
    ATTRVAL      *pAVal;
    BOOL          fInSrc = FALSE, fInTarget = FALSE;
    int           printType = 0;
    CLASS_CACHE  *pcc = pSrcCls;
    CLASS_CACHE  *p = pTargetCls;

    pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));

    switch (attrTyp) {

       case ATT_DEFAULT_SECURITY_DESCRIPTOR:
           fInSrc = (pcc->SDLen ? 1 : 0);
           fInTarget = (p->SDLen ? 1 : 0);
           printType = STRING_TYPE;

           if ( pcc->SDLen ) {
               pAVal->valLen = pcc->SDLen+1;
               pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen);
               memcpy( pAVal->pVal, pcc->pSD, pAVal->valLen );
           }
           else {
              pAVal->valLen = p->SDLen+1;
              pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen);
              memcpy( pAVal->pVal, p->pSD, pAVal->valLen );
           }
           break;

       case ATT_SHOW_IN_ADVANCED_VIEW_ONLY:
           fInSrc = pcc->bHideFromAB;
           fInTarget = p->bHideFromAB;
           printType = STRING_TYPE;

           pAVal->pVal = (UCHAR *) MallocExit(strlen("FALSE")+1); // TRUE or FALSE
           if ( !(pcc->bHideFromAB) ) {
             if ( p->HideFromAB ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           else {
             if ( pcc->HideFromAB ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           pAVal->valLen = strlen(pAVal->pVal);
           break;

       case ATT_DEFAULT_HIDING_VALUE:
           fInSrc = pcc->bDefHidingVal;
           fInTarget = p->bDefHidingVal;
           printType = STRING_TYPE;

           pAVal->pVal = (UCHAR *) MallocExit(strlen("FALSE")+1); // TRUE or FALSE
           if ( !(pcc->bDefHidingVal) ) {
             if ( p->DefHidingVal ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           else {
             if ( pcc->DefHidingVal ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           pAVal->valLen = strlen(pAVal->pVal);
           break;
       default:
           printf("Error, don't understand attrTyp 0x%08x\n", attrTyp);
           exit(1);
     }

     if ( !fInSrc ) {
          // not in source, so delete from target
               AddToModStruct( pModList,
                               AT_CHOICE_REMOVE_VALUES,
                               attrTyp,
                               printType,
                               1,
                               pAVal);
      }
      else {
            if ( !fInTarget ) {
              // in source but not in target, so add to target
               AddToModStruct( pModList,
                               AT_CHOICE_ADD_VALUES,
                               attrTyp,
                               printType,
                               1,
                               pAVal);
            }
            else {
               // in both source and target, so replace in target
               AddToModStruct( pModList,
                               AT_CHOICE_REPLACE_ATT,
                               attrTyp,
                               printType,
                               1,
                               pAVal);
            }
      }

}

/////////////////////////////////////////////////////////////////
// Helper routine to fill up an ATTR_MODLIST structure given all
// the values
/////////////////////////////////////////////////////////////////

void AddToModStruct( MY_ATTRMODLIST *pModList, 
                     USHORT choice, 
                     ATTRTYP attrType, 
                     int type, 
                     ULONG valCount, 
                     ATTRVAL *pAVal)
{
    pModList->choice = choice;
    pModList->type = type;
    pModList->AttrInf.attrTyp = attrType;
    pModList->AttrInf.AttrVal.valCount = valCount;
    pModList->AttrInf.AttrVal.pAVal = pAVal;
}

//////////////////////////////////////////////////////////////////
// Finds if a given ULONG is in agiven list of ULONGs
/////////////////////////////////////////////////////////////////

BOOL IsMemberOf( ULONG id, ULONG *pList, ULONG cList )
{
    ULONG i;

    for ( i = 0; i < cList; i++ ) {
       if ( id == pList[i] ) {
          return TRUE;
       }
    }
    return FALSE;
}

int __cdecl auxsort( const void * pv1, const void * pv2 )
/*
 * Cheap function needed by qsort
 */
{
    return (*(int *)pv1 - *(int *)pv2);
}

/////////////////////////////////////////////////////////////////
//
//  Routine Description:
//     Takes in two list of ULONGs, and returns two lists with
//     (1) things in list 1 but not in list 2, and (2) things in list 2
//     but not in list 1. Null lists are returns if the two lists
//     are identical
//
//  Arguments:
//     pList1 - pointer to List 1
//     cList1 - no.of elements in List 1
//     pList2 - pointer to List 2
//     cList2 - no. of elements in List 2
//     pL1 - return list for elements in List 1 but not in List 2
//     pL2 - return list for elements in List 2 but not in List 1
//
//  Return Value:
//     0 if List 1 and List 2 are identical, 1 otherwise
//////////////////////////////////////////////////////////////////

int CompareUlongList( ULONG *pList1, ULONG cList1, 
                      ULONG *pList2, ULONG cList2,
                      ULONGLIST **pL1, ULONGLIST **pL2 )
{
    ULONG       i, j;
    ULONGLIST  *temp1, *temp2;

    *pL1 = *pL2 = NULL;

    if ( (cList1 == 0) && (cList2 == 0) ) {
        // both lists empty
        return 0;
    }

    // at least one list is non empty
    if ( cList1 == 0 ) {
       // First list empty, just return the List 2 in *pL2
       temp1 = (ULONGLIST *) MallocExit(sizeof(ULONGLIST));
       temp1->count = cList2;
       temp1->List = (ULONG *) MallocExit(cList2*sizeof(ULONG));
       memcpy( temp1->List, pList2, cList2*sizeof(ULONG) );
       *pL2 = temp1;
       return 1;
    }
    if ( cList2 == 0 ) {
       // Second list empty, just return List 1 in *pL1
       temp1 = (ULONGLIST *) MallocExit(sizeof(ULONGLIST));
       temp1->count = cList1;
       temp1->List = (ULONG *) MallocExit(cList1*sizeof(ULONG));
       memcpy( temp1->List, pList1, cList1*sizeof(ULONG) );
       *pL1 = temp1;
       return 1;
    }

    // else, both lists non-empty

    qsort( pList1, cList1, sizeof(ULONG), auxsort );
    qsort( pList2, cList2, sizeof(ULONG), auxsort );

    // In most cases, the lists will be same. So take a chance
    // and do a memcmp and return if equal
    if ( cList1 == cList2 ) {
       // equal size, may be same
       if ( memcmp(pList1, pList2, cList1*sizeof(ULONG)) == 0 ) {
            return 0;
       }
    }

    // They are not the same. So find differences. We do a 
    // a simple O(n^2) linear search since the lists are 
    // usually small 

    (*pL1) = temp1 = (ULONGLIST *) MallocExit(sizeof(ULONGLIST));
    (*pL2) = temp2 = (ULONGLIST *) MallocExit(sizeof(ULONGLIST));
    temp1->count = 0;
    temp2->count = 0;

    // Allocate maximum space that may be needed

    temp1->List = (ULONG *) MallocExit(cList1*sizeof(ULONG));
    temp2->List = (ULONG *) MallocExit(cList2*sizeof(ULONG));
    for ( i = 0; i < cList1; i++ ) {
        if ( !IsMemberOf( pList1[i], pList2, cList2 ) ) {
           temp1->List[temp1->count++] = pList1[i];
         }
    }

    for ( j = 0; j < cList2; j++ ) {
        if ( !IsMemberOf(pList2[j], pList1, cList1 ) ) {
           temp2->List[temp2->count++] = pList2[j];
         }
    }

    if ( temp1->count == 0 ) {
       // nothing to send back  in *pL1
       free( temp1->List );
       free( temp1 );
       *pL1 = NULL;
    }
    if ( temp2->count == 0 ) {
       // nothing to send back in *pL2
       free( temp2->List );
       free( temp2 );
       *pL2 = NULL;
    }

    return 1;
}

//////////////////////////////////////////////////////////////////
// 
//  Routine Description:
//      Helper routine to fill up  ATTR_MODLISTis appropriately
//      given two lists. The routine adds ATTR_MODLISTs for 
//      adds for things in pL1, and ATTR_MODLISTs for deletes
//      for things in pL2. The input lists pL1 and pL2 are
//      freed after being used.
//
//  Arguments:
//      pModStruct - Pointer to ModifyStruct
//      pCount - Pointer to start index inside MODIFYSTRUCT to put 
//               ATTR_MODLISTs in. This is incremented on every
//               ATTR_MODLIST add, and contains the final value on return
//      pL1 - Pointer to list of ULONGs to add ATTR_MODLISTs with
//            "add values" choice 
//      pL2 - Pointer to list of ULONGs to add ATTR_MODLISTs with
//            "remove values" choice 
//      attrTyp  - attribute type whose values are added/removed
//
//  Return Values - None
/////////////////////////////////////////////////////////////////////

void AddToModStructFromLists( MODIFYSTRUCT *pModStr, 
                              ULONG *pCount, 
                              ULONGLIST *pL1, 
                              ULONGLIST *pL2, 
                              ATTRTYP attrTyp)
{
    ATTRVAL *pAVal;
    ULONG    i;


    if ( pL1 != NULL ) {
        // things in list 1 but not in list 2. These are value adds
        pAVal = (ATTRVAL *) MallocExit((pL1->count)*sizeof(ATTRVAL));
        for ( i = 0; i < pL1->count; i++ ) {
           pAVal[i].pVal = IdToOid( pL1->List[i] );
           pAVal[i].valLen = strlen( pAVal[i].pVal );
        }
        AddToModStruct( &(pModStr->ModList[*pCount]), 
                        AT_CHOICE_ADD_VALUES, 
                        attrTyp, 
                        STRING_TYPE, 
                        pL1->count, 
                        pAVal);
        free( pL1->List );
        free( pL1 );
        (*pCount)++;
     }
     if ( pL2 != NULL ) {

         // things in list 2 but not in list 1. These are value deletes
         pAVal = (ATTRVAL *) MallocExit((pL2->count)*sizeof(ATTRVAL));
         for ( i = 0; i < pL2->count; i++ ) {
              pAVal[i].pVal = IdToOid( pL2->List[i] );
              pAVal[i].valLen = strlen( pAVal[i].pVal );
         }
         AddToModStruct( &(pModStr->ModList[*pCount]), 
                         AT_CHOICE_REMOVE_VALUES, 
                         attrTyp, 
                         STRING_TYPE, 
                         pL2->count, 
                         pAVal);
         (*pCount)++;
         free( pL2->List );
         free( pL2 );
     }
}


//////////////////////////////////////////////////////////////////////
// Routine Description:
//   Compares two equal sized arrays of ULONGs to see if they are the same
//   (Difference from CompareUlongLists is that no diff lists are returned)
//
// Arguments: List1, List2 - pointers to the two lists
//            Length       - length of the lists
//
// Return value: 0 if equal, non-0 if not
///////////////////////////////////////////////////////////////////////

int CompareList( ULONG *List1, ULONG *List2, ULONG Length )
{
    ULONG i;

    // This could have been checked before calling this function
    // Just checked it here to avoid checking it in every place
    // we call and avoid bugs if we forget.  

    if ( Length == 0 ) return ( 0 );

    qsort( List1, Length, sizeof(ULONG), auxsort );
    qsort( List2, Length, sizeof(ULONG), auxsort );
    for ( i = 0; i < Length; i++ )
      {
        if ( List1[i] != List2[i] ) return( 1 );
      };
    return( 0 );
}


/////////////////////////////////////////////////////////////////////
// Routine to convert bool value to appropriate string
/////////////////////////////////////////////////////////////////////

char *BoolToStr( unsigned x )
{
   if ( x ) {
     return ("TRUE");
   }
   else { 
     return ("FALSE");
   }
}

/////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//     Takes in an array of att_caches and writes out to ldif file to
//     add them to the target schema
//
//  Arguments:
//      fp - File pointer to (opened) ldif file
//      ppac - pointer to att_cache array
//      cnt - no. of elements in the array
//
//  Return Values: None
//////////////////////////////////////////////////////////////////////

void FileWrite_AttAdd( FILE *fp, ATT_CACHE **ppac, ULONG cnt )
{
   char        *newDN = NULL;
   ULONG       i;
   ATT_CACHE  *pac;
   NTSTATUS    status;
   UCHAR       EncodingString[512];
   DWORD       cCh;

   printf("No. of attributes to add %d\n", cnt);
   fprintf(OIDfp,"\n\n------------------- New Attribute OIDs----------------------\n\n");
   for ( i = 0; i < cnt; i++ ) {
      pac = ppac[i];

      // write ldapDisplayName and OID out to OID file
      fprintf(OIDfp, "%25s : %s\n", pac->name, IdToOid(pac->id));
      fflush(OIDfp);
      
      // Change DN to target schema 
      ChangeDN( pac->DN, &newDN, pTargetSchemaDN );

      // Now write out all attributes of interest, converting binary
      // ones to base64 strings

      fprintf( fp, "dn: %s\n", newDN );
      free(newDN); newDN = NULL;

      fprintf( fp, "changetype: ntdsSchemaAdd\n" );
      fprintf( fp, "objectClass: attributeSchema\n" );
      fprintf( fp, "ldapDisplayName: %s\n", pac->name );
      fprintf( fp, "adminDisplayName: %s\n", pac->adminDisplayName );
      if ( pac->adminDescr) {
        fprintf( fp, "adminDescription: %s\n", pac->adminDescr );
      }
      fprintf( fp, "attributeId: %s\n", IdToOid( pac->id ) );
      fprintf( fp, "attributeSyntax: %s\n", IdToOid( pac->syntax ) );
      fprintf( fp, "omSyntax: %d\n", pac->OMsyntax );
      fprintf( fp, "isSingleValued: %s\n", BoolToStr( pac->isSingleValued ) );
      if (pac->bSystemOnly) {
         fprintf( fp, "systemOnly: %s\n", BoolToStr( pac->SystemOnly ) );
      }
      if (pac->bExtendedChars) {
      fprintf( fp, "extendedCharsAllowed: %s\n", BoolToStr( pac->ExtendedChars) );
      }
      if (pac->bSearchFlags) {
        fprintf( fp, "searchFlags: %d\n", pac->SearchFlags );
      }
      if ( pac->rangeLowerPresent ) {
        fprintf( fp, "rangeLower: %d\n", pac->rangeLower );
      }
      if ( pac->rangeUpperPresent ) {
        fprintf( fp, "rangeUpper: %d\n", pac->rangeUpper );
      }

      if (pac->OMObjClass.length) {
          status = base64encode( pac->OMObjClass.elements,
                                 pac->OMObjClass.length,
                                 EncodingString,
                                 512, &cCh );
          if (status == STATUS_SUCCESS ) {
            fprintf( fp, "omObjectClass:: %s\n", EncodingString );
          }
          else {
            // log a warning
            fprintf(logfp, "WARNING: unable to convert omObjectClass for attribute %s\n", pac->name);
          }
      }
      else {
         // if OM_S_OBJECT syntax, log a warning
         if (pac->OMsyntax == 127) {
            fprintf(logfp, "Attribute %s has om-syntax=127 but no om-object-class\n", pac->name);
         }
      }

      status = base64encode( &pac->propGuid, 
                             sizeof(GUID), 
                             EncodingString, 
                             512, &cCh );
      if (status == STATUS_SUCCESS ) {
        fprintf( fp, "schemaIdGuid:: %s\n", EncodingString );
      }
      else {
        // log a warning
        fprintf(logfp, "WARNING: unable to convert schemaIdGuid for attribute %s\n", pac->name);
      }

      if (pac->bPropSetGuid) {
          status = base64encode( &pac->propSetGuid, 
                                 sizeof(GUID), 
                                 EncodingString, 
                                 512, &cCh );
          if (status == STATUS_SUCCESS ) {
            fprintf( fp, "attributeSecurityGuid:: %s\n", EncodingString );
          }
          else {
            // log a warning
            fprintf(logfp, "WARNING: unable to convert attribute-security-guid for attribute %s\n", pac->name);
          }
      }
      if (pac->NTSDLen) {
         status = base64encode( pac->pNTSD, 
                                pac->NTSDLen,
                                EncodingString, 
                                512, &cCh );
         if (status == STATUS_SUCCESS ) {
           fprintf( fp, "nTSecurityDescriptor:: %s\n", EncodingString );
         }
 else { printf("Error converting NTSD in Att\n");}
      }
      if ( pac->ulLinkID ) {
        fprintf( fp,"linkID: %d\n", pac->ulLinkID );
      }
      if ( pac->ulMapiID ) {
        fprintf( fp,"mapiID: %d\n", pac->ulMapiID );
      } 
      if (pac->bHideFromAB) {
        fprintf( fp, "showInAdvancedViewOnly: %s\n", BoolToStr( pac->HideFromAB ) );
      }
      if (pac->bMemberOfPartialSet) {
        fprintf( fp, "isMemberOfPartialAttributeSet: %s\n", BoolToStr( pac->MemberOfPartialSet ) );
      }
      if ( pac->sysFlags ) {
        // The attribute has a system-flag. System-Flags is a
        // reserved attribute and cannot n general be added by an user call.
        // we will allow adding if a registry key is set to take care of
        // upcoming schema changes. 
        fprintf( fp, "systemFlags: %d\n", pac->sysFlags );
      } 
      fprintf( fp, "\n" );
      fflush(fp);
   }
}

/////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//     Takes in an array of class_caches and writes out to ldif file to
//     add them to the target schema
//
//  Arguments:
//      fp - File pointer to (opened) ldif file
//      ppcc - pointer to class_cache array
//      cnt - no. of elements in the array
//
//  Return Values: None
//////////////////////////////////////////////////////////////////////

void FileWrite_ClsAdd( FILE *fp, CLASS_CACHE **ppcc, ULONG cnt )
{
   // Need to change the DN
   char          *newDN = NULL;
   CLASS_CACHE  *pcc;
   ULONG         i, j, guidSize = sizeof(GUID);
   UCHAR        *pGuid;
   NTSTATUS      status;
   UCHAR         EncodingString[512];
   DWORD         cCh;

   printf("No. of classes to add %d\n", cnt);

   fprintf(OIDfp,"\n\n--------------------- New  Class OIDs---------------------\n\n");

   for ( i = 0; i < cnt; i++ ) {
     pcc = ppcc[i];

      // write ldapDisplayName and OID out to OID file
      fprintf(OIDfp, "%25s : %s\n", pcc->name, IdToOid(pcc->ClassId));
      fflush(OIDfp);

     // change DN to that of target schema
     ChangeDN( pcc->DN, &newDN, pTargetSchemaDN );

     // Now write out all attributes of interest, converting binary
     // values to base64 string

     fprintf( fp, "dn: %s\n", newDN );
     free(newDN); newDN = NULL;

     fprintf( fp, "changetype: ntdsSchemaAdd\n" );
     fprintf( fp, "objectClass: classSchema\n" );
     fprintf( fp, "ldapDisplayName: %s\n", pcc->name );
     fprintf( fp, "adminDisplayName: %s\n", pcc->adminDisplayName );
     if ( pcc->adminDescr ) {
       fprintf( fp, "adminDescription: %s\n", pcc->adminDescr );
     }
     fprintf( fp, "governsId: %s\n", IdToOid(pcc->ClassId) );
     fprintf( fp, "objectClassCategory: %d\n", pcc->ClassCategory );
     if ( pcc->RDNAttIdPresent ) {
       fprintf( fp, "rdnAttId: %s\n", IdToOid(pcc->RDNAttId) );
     }
     fprintf( fp, "subClassOf: %s\n", IdToOid(*(pcc->pSubClassOf)) );
     if ( pcc->AuxClassCount ) {
        for ( j = 0; j < pcc->AuxClassCount; j++ ) {
          fprintf( fp, "auxiliaryClass: %s\n",IdToOid((pcc->pAuxClass)[j]) ); 
        }
     }
     if ( pcc->SysAuxClassCount ) {
        for ( j = 0; j < pcc->SysAuxClassCount; j++ ) {
          fprintf( fp, "systemAuxiliaryClass: %s\n",IdToOid((pcc->pSysAuxClass)[j]) ); 
        }
     }
     if ( pcc->MustCount ) {
        for ( j = 0; j < pcc->MustCount; j++ ) {
          fprintf( fp, "mustContain: %s\n",IdToOid((pcc->pMustAtts)[j]) ); 
        }
     }
     if ( pcc->SysMustCount ) {
        for ( j = 0; j < pcc->SysMustCount; j++ ) {
          fprintf( fp, "systemMustContain: %s\n",IdToOid((pcc->pSysMustAtts)[j]) ); 
        }
     }
     if ( pcc->MayCount ) {
        for ( j = 0; j < pcc->MayCount; j++ ) {
          fprintf( fp, "mayContain: %s\n",IdToOid((pcc->pMayAtts)[j]) ); 
        }
     }
     if ( pcc->SysMayCount ) {
        for ( j = 0; j < pcc->SysMayCount; j++ ) {
          fprintf( fp, "systemMayContain: %s\n",IdToOid((pcc->pSysMayAtts)[j]) ); 
        }
     }
     if ( pcc->PossSupCount ) {
        for ( j = 0; j < pcc->PossSupCount; j++ ) {
          fprintf( fp, "possSuperiors: %s\n",IdToOid((pcc->pPossSup)[j]) ); 
        }
     }
     if ( pcc->SysPossSupCount ) {
        for ( j = 0; j < pcc->SysPossSupCount; j++ ) {
          fprintf( fp, "systemPossSuperiors: %s\n",IdToOid((pcc->pSysPossSup)[j]) ); 
        }
     }

     status = base64encode( &pcc->propGuid, 
                            sizeof(GUID), 
                            EncodingString, 
                            512, &cCh );
     if ( status == STATUS_SUCCESS ) {
        fprintf( fp, "schemaIdGuid:: %s\n", EncodingString );
     }
     else {
        // log a warning
        fprintf(logfp, "WARNING: unable to convert schemaIdGuid for class %s\n", pcc->name);
     }

/********
     if (pcc->NTSDLen) {
        status = base64encode(  pcc->pNTSD, 
                                pcc->NTSDLen,
                                EncodingString, 
                                512, &cCh );
        if (status == STATUS_SUCCESS ) {
           fprintf( fp, "nTSecurityDescriptor:: %s\n", EncodingString );
        }
 else { printf("Error converting NTSD in Cls\n");}
     }
*******/

     if (pcc->SDLen) {
           fprintf( fp, "defaultSecurityDescriptor: %s\n", pcc->pSD );
     }

     if (pcc->bHideFromAB) {
           fprintf( fp, "showInAdvancedViewOnly: %s\n", BoolToStr(pcc->HideFromAB));
     }
     if (pcc->bDefHidingVal) {
           fprintf( fp, "defaultHidingValue: %s\n", BoolToStr(pcc->DefHidingVal));
     }
     if (pcc->bSystemOnly) {
           fprintf( fp, "systemOnly: %s\n", BoolToStr(pcc->SystemOnly));
     }
     if (pcc->pDefaultObjCat) {
           ChangeDN( pcc->pDefaultObjCat, &newDN, pTargetSchemaDN );
           fprintf( fp, "defaultObjectCategory: %s\n", newDN);
           free(newDN); newDN = NULL;
     }
     if ( pcc->sysFlags ) {
        // The attribute has a system-flag. System-Flags is a
        // reserved attribute and cannot n general be added by an user call.
        // we will allow adding if a registry key is set to take care of
        // upcoming schema changes. 
        fprintf( fp, "systemFlags: %d\n", pcc->sysFlags );
     }

     fprintf( fp, "\n" );
     fflush(fp);
   } /* for */
}


/////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//     Takes in an array of att_caches and writes out to ldif file to
//     delete them from the target schema
//
//  Arguments:
//      fp - File pointer to (opened) ldif file
//      ppac - pointer to att_cache array
//      cnt - no. of elements in the array
//
//  Return Values: None
//////////////////////////////////////////////////////////////////////

void FileWrite_AttDel( FILE *fp, ATT_CACHE **ppac, ULONG cnt )
{
   ULONG i;

   printf("No. of attributes to delete %d\n", cnt);

   fprintf(OIDfp,"\n\n --------------Deleted Attribute OIDs---------------\n\n");
   for ( i = 0; i < cnt; i++ ) {
     
      // write ldapDisplayName and OID out to OID file
      fprintf(OIDfp, "%25s : %s\n", ppac[i]->name, IdToOid(ppac[i]->id));
      fflush(OIDfp);

     fprintf( fp, "dn: %s\n", (ppac[i])->DN );
     fprintf( fp, "changetype: ntdsSchemaDelete\n\n" );
     fflush(fp);
   }
}

/////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//     Takes in an array of class_caches and writes out to ldif file to
//     delete them from the target schema
//
//  Arguments:
//      fp - File pointer to (opened) ldif file
//      ppcc - pointer to class_cache array
//      cnt - no. of elements in the array
//
//  Return Values: None
//////////////////////////////////////////////////////////////////////

void FileWrite_ClsDel( FILE *fp, CLASS_CACHE **ppcc, ULONG cnt )
{
   ULONG i;

   printf("No. of classes to delete %d\n", cnt);

   fprintf(OIDfp,"\n\n----------------------- Deleted Class OIDs-------------------------\n\n");
   for ( i = 0; i < cnt; i++ ) {

      // write ldapDisplayName and OID out to OID file
      fprintf(OIDfp, "%25s : %s\n", ppcc[i]->name, IdToOid(ppcc[i]->ClassId));
      fflush(OIDfp);

     fprintf( fp, "dn: %s\n", (ppcc[i])->DN );
     fprintf( fp, "changetype: ntdsSchemaDelete\n\n" );
     fflush(fp);
   }
}


// Define attrtype to ldapDisplayName string mappings for
// modify printings

typedef struct _attrtoStr {
   ULONG attrTyp;
   char  *strName;
} ATTRTOSTR;

ATTRTOSTR AttrToStrMappings[] = {
     { ATT_LDAP_DISPLAY_NAME ,           "ldapDisplayName" },
     { ATT_ADMIN_DISPLAY_NAME,           "adminDisplayName" },
     { ATT_OBJ_DIST_NAME,                "distinguishedName" }, 
     { ATT_ADMIN_DESCRIPTION,            "adminDescription" },
     { ATT_ATTRIBUTE_ID,                 "attributeId" },
     { ATT_ATTRIBUTE_SYNTAX,             "attributeSyntax" },
     { ATT_IS_SINGLE_VALUED,             "isSingleValued" },
     { ATT_RANGE_LOWER,                  "rangeLower" },
     { ATT_RANGE_UPPER,                  "rangeUpper" },
     { ATT_MAPI_ID,                      "mapiId" },
     { ATT_LINK_ID,                      "linkId" },
     { ATT_SCHEMA_ID_GUID,               "schemaIdGuid" },
     { ATT_ATTRIBUTE_SECURITY_GUID,      "attributeSecurityGuid" },
     { ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET, "isMemberOfPartialAttributeSet" },
     { ATT_SYSTEM_FLAGS,                 "systemFlags" },
     { ATT_SHOW_IN_ADVANCED_VIEW_ONLY,   "showInAdvancedViewOnly" },
     { ATT_DEFAULT_SECURITY_DESCRIPTOR,  "defaultSecurityDescriptor" },
     { ATT_DEFAULT_OBJECT_CATEGORY,      "defaultObjectCategory" },
     { ATT_DEFAULT_HIDING_VALUE,         "defaultHidingValue" },
     { ATT_NT_SECURITY_DESCRIPTOR,       "nTSecurityDescriptor" },
     { ATT_OM_OBJECT_CLASS,              "oMObjectClass" },
     { ATT_OM_SYNTAX,                    "oMSyntax" },
     { ATT_SEARCH_FLAGS,                 "searchFlags" },
     { ATT_SYSTEM_ONLY,                  "systemOnly" },
     { ATT_EXTENDED_CHARS_ALLOWED,       "extendedCharsAllowed" },
     { ATT_GOVERNS_ID,                   "governsId" },
     { ATT_RDN_ATT_ID,                   "rdnAttId" },
     { ATT_OBJECT_CLASS_CATEGORY,        "objectClassCategory" },
     { ATT_SUB_CLASS_OF,                 "subClassOf" },
     { ATT_SYSTEM_AUXILIARY_CLASS,       "systemAuxiliaryClass" },
     { ATT_AUXILIARY_CLASS,              "auxiliaryClass" },
     { ATT_SYSTEM_POSS_SUPERIORS,        "systemPossSuperiors" },
     { ATT_POSS_SUPERIORS,               "possSuperiors" },
     { ATT_SYSTEM_MUST_CONTAIN,          "systemMustContain" },
     { ATT_MUST_CONTAIN,                 "mustContain" },
     { ATT_SYSTEM_MAY_CONTAIN,           "systemMayContain" },
     { ATT_MAY_CONTAIN,                  "mayContain" },
};
int cAttrToStrMappings = sizeof(AttrToStrMappings) / sizeof(AttrToStrMappings[0]);

char *AttrToStr( ULONG attrTyp )
{
    int i;

    for ( i = 0; i < cAttrToStrMappings; i++ )
        {
          if ( attrTyp == AttrToStrMappings[i].attrTyp )
             return( AttrToStrMappings[i].strName );
        };
    return( NULL );
};


/////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//     Takes in the DN of an object (attribute or class) and a 
//     modifystruct and writes out to ldif file to make the modification
//     to the object in the target schema
//
//  Arguments:
//      fp - File pointer to (opened) ldif file
//      pDN - Pointer to DN of the object to be modified in target schema
//      pMod - Pointer to modifystruct
//
//  Return Values: None
//////////////////////////////////////////////////////////////////////

void FileWrite_Mod( FILE *fp, char  *pDN, MODIFYSTRUCT *pMod )
{
    ULONG     i, j;
    char     *pAttrStr;
    ATTRVAL  *pAVal;
    NTSTATUS  status;
    UCHAR     EncodingString[512];
    DWORD     cCh;
 
    fprintf( fp, "dn: %s\n", pDN );
    fprintf( fp, "changetype: ntdsSchemaModify\n" );
    
    // print out all the ATTR_MODLISTs in the MODIFYSTRUCT

    for ( i = 0; i < pMod->count; i++ ) {
        pAVal = pMod->ModList[i].AttrInf.AttrVal.pAVal;
        pAttrStr = AttrToStr( pMod->ModList[i].AttrInf.attrTyp );
        if ( pAttrStr == NULL ) {
          printf("Unknown attribute %x\n", pMod->ModList[i].AttrInf.attrTyp);
          return;
        }
        switch ( pMod->ModList[i].choice ) {
           case AT_CHOICE_ADD_VALUES:
              fprintf( fp,"add: %s\n", pAttrStr );
              break;
           case AT_CHOICE_REMOVE_VALUES:
              fprintf( fp,"delete: %s\n", pAttrStr );
              break;
           case AT_CHOICE_REPLACE_ATT:
              fprintf( fp,"replace: %s\n", pAttrStr );
              break;
           default:
              printf("Undefined choice for attribute %s\n", pAttrStr);
         } /* switch */
    
        // Now print out the values
        switch ( pMod->ModList[i].type ) {
           case STRING_TYPE:
             for ( j = 0; j < pMod->ModList[i].AttrInf.AttrVal.valCount; j++ ) {
               fprintf( fp, "%s: %s\n", pAttrStr, pAVal[j].pVal );
             }
             break;
           case BINARY_TYPE:
             for ( j = 0; j < pMod->ModList[i].AttrInf.AttrVal.valCount; j++ ) {
                status = base64encode( pAVal[j].pVal,
                                       pAVal[j].valLen,
                                       EncodingString,
                                       512, &cCh );
                if (status == STATUS_SUCCESS ) {
                  fprintf( fp, "%s:: %s\n", pAttrStr, EncodingString );
                }
                else {
                  printf("Error converting binary value for attribute %s\n", pAttrStr);
                }
              }
             break;
           default:
             printf("ERROR: unknown type for attribute %s\n", pAttrStr);
        } /* switch */
        fprintf( fp, "-\n" );
    }
    fprintf( fp, "\n" );
}     
           
void GenWarning( char c, ULONG attrTyp, char *name)
{
   switch( c ) {
      case 'a':
         fprintf( logfp, "MOD-WARNING: system-only mod (%s) for attribute %s\n", AttrToStr(attrTyp), name );
         break;
      case 'c':            
         fprintf( logfp, "MOD-WARNING: system-only mod (%s) for class %s\n", AttrToStr(attrTyp), name );
    }
}














     

////////////////////////////////////////////////////////////////////////
// Debug routines for printing, and changing schema cache randomly 
// for testing
// These will be taken off before checkin
/////////////////////////////////////////////////////////////////////

int Schemaprint1(SCHEMAPTR *SCPtr)
{
   ULONG i;
   ATT_CACHE *p;
   int count=0;

   HASHCACHE*         ahcId    = SCPtr->ahcId ;
   HASHCACHESTRING*   ahcName  = SCPtr->ahcName ;
   ULONG              ATTCOUNT = SCPtr->ATTCOUNT;
   ULONG              CLSCOUNT = SCPtr->CLSCOUNT;

   for(i=0; i < ATTCOUNT; i++)
    { if ((ahcId[i].pVal !=NULL) && (ahcId[i].pVal != FREE_ENTRY)) {
      p = (ATT_CACHE *) ahcId[i].pVal;
      printf("********************************************************\n");
      printf("Name = %s, AdDisName=%s, AdDesc=%s, DN=%s, Id = %x\n", p->name, p
->adminDisplayName, p->adminDescr, p->DN, p->id);
      printf("syntax = %d\n", p->syntax);
      printf("Is SingleValued = %d\n", p->isSingleValued);
      printf("Range Lower = %d, indicator = %d\n", p->rangeLower, p->rangeLowerPresent);
      printf("Range Upper = %d, Indicator = %d\n", p->rangeUpper, p->rangeUpperPresent);
      printf("MapiID = %d\n", p->ulMapiID);
      printf("LinkID = %d\n", p->ulLinkID);
      printf("Schema-ID-GUID = %d,%d,%d\n", p->propGuid.Data1, p->propGuid.Data2, p->propGuid.Data3);
      printf("OM Object Class = %s\n", (char *) p->OMObjClass.elements);
      printf("OM Syntax = %d\n", p->OMsyntax);
      printf("Search Flags = %d\n", p->SearchFlags);
      printf("System Only = %d\n",p->bSystemOnly);
      printf("Is Single Valued = %d\n",p->bisSingleValued);
      printf("Extended Chars = %d\n", p->bExtendedChars);
      count++;
    };
   };
  return(count);
};


int Schemaprint2(SCHEMAPTR *SCPtr)
{
   ULONG i, j;
   int count = 0;
   CLASS_CACHE *p;
   HASHCACHE*         ahcClass     = SCPtr->ahcClass ;
   HASHCACHESTRING*   ahcClassName = SCPtr->ahcClassName ;
   ULONG              ATTCOUNT     = SCPtr->ATTCOUNT;
   ULONG              CLSCOUNT     = SCPtr->CLSCOUNT;

   printf("in print2\n");
   for(i=0; i < CLSCOUNT; i++)
    { if ((ahcClass[i].pVal !=NULL) && (ahcClass[i].pVal != FREE_ENTRY))  {
      p = (CLASS_CACHE *) ahcClass[i].pVal;
      printf("********************************************************\n");
      printf("Name = %s, AdDisName=%s, AdDesc=%s, DN=%s, Id = %x\n", p->name, p->adminDisplayName, p->adminDescr, p->DN, p->ClassId);

/**********
      printf("Class Category = %d, System Only = %d\n", p->ClassCategory, p->bSystemOnly);
      if (p->RDNAttIdPresent)
         printf("RDN Att Id is %x\n", p->RDNAttId);
      printf("Sub Class count = %u\n", p->SubClassCount);
      if(p->SubClassCount > 0)
        { printf("Sub Class Of: ");
          for(j=0;j<p->SubClassCount;j++)
             printf("%x, ", p->pSubClassOf[j]);
           printf("\n");
         };
      printf("Aux Class count = %u\n", p->AuxClassCount);
      if(p->AuxClassCount > 0)
        { printf("System Auxiliary Class: ");
          for(j=0;j<p->AuxClassCount;j++)
             printf("%x, ", p->pAuxClass[j]);
           printf("\n");
         };
      printf("Superior count = %u, System Sup Count = %u\n", p->SysPossSupCount,p->PossSupCount);
      if(p->SysPossSupCount > 0)
        { printf("System Possible Superiors: ");
          for(j=0;j<p->SysPossSupCount;j++)
             printf("%x, ", p->pSysPossSup[j]);
           printf("\n");
         };
      if(p->PossSupCount > 0)
        { printf(" Possible Superiors: ");
          for(j=0;j<p->PossSupCount;j++)
             printf("%x, ", p->pPossSup[j]);
           printf("\n");
         };
      printf("Must count = %u, System Must Count = %u\n", p->SysMustCount, p->MustCount);
      if(p->SysMustCount > 0)
        { printf("Must Contain: ");
          for(j=0;j<p->SysMustCount;j++)
             printf("%x, ", p->pSysMustAtts[j]);
           printf("\n");
         };
      if(p->MustCount > 0)
        { printf("System Must Contain: ");
          for(j=0;j<p->MustCount;j++)
             printf("%x, ", p->pMustAtts[j]);
           printf("\n");
         };
      printf("May count = %u, System may Count = %u\n", p->SysMayCount, p->MayCount);
      if(p->SysMayCount > 0)
        { printf("May Contain: ");
          for(j=0;j<p->SysMayCount;j++)
             printf("%x, ", p->pSysMayAtts[j]);
           printf("\n");
         };
      if(p->MayCount > 0)
        { printf("System May Contain: ");
          for(j=0;j<p->MayCount;j++)
             printf("%x, ", p->pMayAtts[j]);
           printf("\n");
         };
      count++;
**************/
    };
   };
   return(count);
};


void ChangeSchema(SCHEMAPTR *SCPtr)
{
 
    HASHCACHE*         ahcId    = SCPtr->ahcId ;
    HASHCACHE*         ahcClass = SCPtr->ahcClass ;
    ULONG              ATTCOUNT = SCPtr->ATTCOUNT;
    ULONG              CLSCOUNT = SCPtr->CLSCOUNT;
    ATT_CACHE *pac;
    CLASS_CACHE *pcc;

    FILE *fp;
    int i, j, k;

    //pTHStls->CurrSchemaPtr = SCPtr;

    fp = fopen("Modfile","a");

    srand((unsigned) time(NULL));

    // First, delete a few schema objects from schema 1
    //
    // Do not delete object with id 0 (objectClass), as
    // if this is deleted, and then searched for in the cache,
    // SCGetAttById will still find it 

    for ( i = 0; i < 5; i++ ) {
        j = rand() % ATTCOUNT;
        while ( (ahcId[j].pVal == NULL) || (ahcId[j].pVal == FREE_ENTRY) ) 
          j = rand() % ATTCOUNT; 
        pac = ahcId[j].pVal;
        if ( pac->id == 0 )
          { fprintf(fp, "Not deleting Id 0 attribute object: %s\n", pac->name);
            continue;
          };
        fprintf(fp,"Deleted Attribute %s\n", pac->name);
        FreeAttPtrs(SCPtr,pac);
        FreeAttcache(pac);
     };
    fprintf(fp,"\n");

    for ( i = 0; i < 5; i++ ) {
        j = rand() % CLSCOUNT;
        while ( (ahcClass[j].pVal == NULL) || (ahcClass[j].pVal == FREE_ENTRY)) 
          j = rand() % CLSCOUNT; 
        pcc = ahcClass[j].pVal;
        if ( pcc->ClassId == 0 )
          { fprintf(fp, "Not deleting Id 0 class object: %s\n", pcc->name);
            continue;
          };
        fprintf(fp,"Deleted Class %s\n", pcc->name);
        FreeClassPtrs(SCPtr, pcc);
        FreeClasscache(pcc);
     };

    fprintf(fp,"\n");

    // Next, modify a few attribute and class schema objects
    
    for(i=0; i <5; i++) {
       j = rand() % ATTCOUNT;
       while ((ahcId[j].pVal==NULL) || (ahcId[j].pVal==FREE_ENTRY))
            j=rand() % ATTCOUNT;
       pac = ahcId[j].pVal;
       fprintf(fp,"Modified Attribute %s\n", pac->name);
       if(pac->rangeLowerPresent==0) pac->rangeLowerPresent=1;
       else pac->rangeLower = 1000;
       if(pac->isSingleValued) pac->isSingleValued = FALSE;
       else pac->isSingleValued = TRUE;
       pac->propGuid.Data2 = 1000;
      };

    fprintf(fp,"\n");

       
    for(i=0; i <5; i++) {
       j = rand() % CLSCOUNT;
       while ((ahcClass[j].pVal==NULL) || (ahcClass[j].pVal==FREE_ENTRY))
           j=rand() % CLSCOUNT;
       pcc = ahcClass[j].pVal;
       fprintf(fp,"Modified Class %s\n", pcc->name);
       if (pcc->RDNAttIdPresent) pcc->RDNAttId=100;
       if (pcc->SubClassCount==0) pcc->SubClassCount=1;
       else pcc->SubClassCount = 0;
       if (pcc->SysMayCount!=0) {
         k = rand() % pcc->SysMayCount;
         pcc->pSysMayAtts[k]=2000;
         fprintf(fp,"   Changed MyMay list element %d\n", k);
         }
       if (pcc->SysMustCount!=0)  {
         k = rand() % pcc->SysMustCount;
         pcc->pSysMustAtts[k]=1000;
         fprintf(fp,"   Changed MyMust list element %d\n", k);
         }
       if (pcc->SysPossSupCount!=0)  {
         k = rand() % pcc->SysPossSupCount;
         pcc->pSysPossSup[k]=1000;
         fprintf(fp,"   Changed MyPossSup list element %d\n", k);
         }
      };
    fprintf(fp,"*********************************************\n");
    fclose(fp);

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\schemard\cache.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <schemard.h>


// Global Prefix Table pointer
PVOID PrefixTable = NULL;

// Global variable indicating next index to assign to a new prefix
ULONG DummyNdx = 1;

//Internal debug function
void PrintOid(PVOID Oid, ULONG len);


///////////////////////////////////////////////////////
//     Functions for hashing by Id and by name
//////////////////////////////////////////////////////

__inline ULONG IdHash(ULONG hkey, ULONG count)
{
    return((hkey << 3) % count);
}

__inline ULONG NameHash( ULONG size, PUCHAR pVal, ULONG count )
{
    ULONG val=0;
    while(size--) {
        // Map A->a, B->b, etc.  Also maps @->', but who cares.
        val += (*pVal | 0x20);
        pVal++;
    }
    return (val % count);
}


/*++
Routine Description:

    Find an attcache given its attribute id.

Arguments:
    SCPtr  - Pointer to the schema cache to search in
    attrid - the attribute id to look up.
    ppAttcache - the attribute cache returned

Return Value:
    Returns non-zero on error (non-find), 0 otherwise.
--*/

int __fastcall GetAttById( SCHEMAPTR *SCPtr, ULONG attrid, 
                           ATT_CACHE** ppAttcache )

{
    register ULONG  i;
    HASHCACHE      *ahcId    =  SCPtr->ahcId;
    ULONG           ATTCOUNT = SCPtr->ATTCOUNT;

    for (i=IdHash(attrid,ATTCOUNT);
         (ahcId[i].pVal && (ahcId[i].hKey != attrid)); i++){
        if (i >= ATTCOUNT) {
            i=0;
        }
    }
    *ppAttcache = (ATT_CACHE*)ahcId[i].pVal;
    return (!ahcId[i].pVal);
}


/*++
Routine Description:

    Find an attcache given its MAPI property id.

Arguments:
    SCPtr  - Pointer to the schema cache to search in
    ulPropID - the jet column id to look up.
    ppAttcache - the attribute cache returned

Return Value:
    Returns non-zero on error (non-find), 0 otherwise.
--*/
int __fastcall GetAttByMapiId( SCHEMAPTR *SCPtr, ULONG ulPropID, 
                               ATT_CACHE** ppAttcache )

{
    register ULONG  i;
    HASHCACHE      *ahcMapi  = SCPtr->ahcMapi;
    ULONG           ATTCOUNT = SCPtr->ATTCOUNT;

    for (i=IdHash(ulPropID,ATTCOUNT);
         (ahcMapi[i].pVal && (ahcMapi[i].hKey != ulPropID)); i++){
        if (i >= ATTCOUNT) {
            i=0;
        }
    }
    *ppAttcache = (ATT_CACHE*)ahcMapi[i].pVal;
    return (!ahcMapi[i].pVal);
}


/*++
Routine Description:

    Find an attcache given its name.

Arguments:
    SCPtr  - Pointer to schema cache to search in
    ulSize - the num of chars in the name.
    pVal - the chars in the name
    ppAttcache - the attribute cache returned

Return Value:
    Returns non-zero on error (non-find), 0 otherwise.

--*/
int __fastcall GetAttByName( SCHEMAPTR *SCPtr, ULONG ulSize, 
                             PUCHAR pVal, ATT_CACHE** ppAttcache )
{
    register ULONG i;
    HASHCACHESTRING* ahcName = SCPtr->ahcName;
    ULONG ATTCOUNT = SCPtr->ATTCOUNT;

    for (i=NameHash(ulSize,pVal,ATTCOUNT);
         (ahcName[i].pVal &&            // this hash spot refers to an object,
            (ahcName[i].length != ulSize || // but the size is wrong
              _memicmp(ahcName[i].value,pVal,ulSize))); // or the value is wrong
             i++){
          if (i >= ATTCOUNT) {
               i=0;
          }
     }

    *ppAttcache = (ATT_CACHE*)ahcName[i].pVal;
    return (!ahcName[i].pVal);
}


/*++
Routine Description:

    Find a classcache given its class id

Arguments:
    SCPtr  - Pointer to the schema cache to search in
    classid - class id to look up
    ppClasscache - the class cache returned

Return Value:
    Returns non-zero on error (non-find), 0 otherwise.
--*/
int __fastcall GetClassById( SCHEMAPTR *SCPtr, ULONG classid, 
                             CLASS_CACHE** ppClasscache )
{
    register ULONG i;
    HASHCACHE*  ahcClass     = SCPtr->ahcClass;
    ULONG CLSCOUNT = SCPtr->CLSCOUNT;

    for (i=IdHash(classid,CLSCOUNT);
         (ahcClass[i].pVal && (ahcClass[i].hKey != classid)); i++){
        if (i >= CLSCOUNT) {
            i=0;
        }
    }
    *ppClasscache = (CLASS_CACHE*)ahcClass[i].pVal;
    return (!ahcClass[i].pVal);
}


/*++
Routine Description:

    Find a classcache given its name.

Arguments:
    SCPtr  - Pointer to schema cache to search in
    ulSize - the num of chars in the name.
    pVal - the chars in the name
    ppClasscache - the class cache returned

Return Value:
    Returns non-zero on error (non-find), 0 otherwise.

--*/

int __fastcall GetClassByName( SCHEMAPTR *SCPtr, ULONG ulSize, 
                               PUCHAR pVal, CLASS_CACHE** ppClasscache )
{
    register ULONG i;
    HASHCACHESTRING* ahcClassName = SCPtr->ahcClassName;
    ULONG CLSCOUNT = SCPtr->CLSCOUNT;

    int Retry=0;
    UCHAR newname[MAX_RDN_SIZE];

    for (i=NameHash(ulSize,pVal,CLSCOUNT);
          (ahcClassName[i].pVal &&       // this hash spot refers to an object,
            (ahcClassName[i].length != ulSize || // but the size is wrong
              _memicmp(ahcClassName[i].value,pVal,ulSize))); // or value is wrong
             i++){
            if (i >= CLSCOUNT) {
                i=0;
            }
        }

    *ppClasscache = (CLASS_CACHE*)ahcClassName[i].pVal;
    return (!ahcClassName[i].pVal);
}


/*++
Routine Description: 
      Creates the different hash tables in the schema cache

Arguments: 
      SCPtr - Pointer to schema cache

Return Value: 
      0 if no error, non-0 if error
--*/

int CreateHashTables( SCHEMAPTR *CurrSchemaPtr )
{  
    PVOID ptr;
    ULONG i;

    ptr = CurrSchemaPtr->ahcId 
          = calloc( CurrSchemaPtr->ATTCOUNT, sizeof(HASHCACHE) );
    if ( ptr == NULL ) return( 1 ); 

    ptr = CurrSchemaPtr->ahcMapi 
          = calloc( CurrSchemaPtr->ATTCOUNT, sizeof(HASHCACHE) );
    if ( ptr == NULL ) return (1 );

    ptr = CurrSchemaPtr->ahcName 
          = calloc( CurrSchemaPtr->ATTCOUNT, sizeof(HASHCACHESTRING) );
    if ( ptr == NULL ) return( 1 );

    ptr = CurrSchemaPtr->ahcClass 
          = calloc( CurrSchemaPtr->CLSCOUNT, sizeof(HASHCACHE) );
    if ( ptr == NULL ) return( 1 );

    ptr = CurrSchemaPtr->ahcClassName 
          = calloc( CurrSchemaPtr->CLSCOUNT, sizeof(HASHCACHESTRING) );
    if ( ptr == NULL ) return( 1 );

      // Initialize the hash tables 
      //(Needed? calloc seems to initialize mem to 0 anyway)

    for ( i = 0; i < CurrSchemaPtr->ATTCOUNT; i++ ) {
           CurrSchemaPtr->ahcName[i].pVal = NULL;
           CurrSchemaPtr->ahcId[i].pVal   = NULL;
           CurrSchemaPtr->ahcMapi[i].pVal = NULL;
        }

    for ( i = 0; i < CurrSchemaPtr->CLSCOUNT; i++ ) {
           CurrSchemaPtr->ahcClassName[i].pVal = NULL;
           CurrSchemaPtr->ahcClass[i].pVal = NULL;
        }
   
    return( 0 );
}



// Define the mappings to map from a LDAP display name of an attribute
// (in the attribute schema and class schema entries) to an internal
// constant (we have used the ids defined in attids.h, though this
// is not necessary. This mapping is only so that we can use a switch
// statement based on the attribute, and hence what values we map to
// is irrelevent as long as they are distinct
// The ;binary s are added to the names of those attributes whose
// values are returned in binary, since the binary option also
// appends the ;binary to the attribute name in addition to
// transforming the value
   

typedef struct _AttributeMappings {
       char      *attribute_name;
       ATTRTYP   type;
 } AttributeMappings;

AttributeMappings LDAPMapping[] = {
       { "ldapDisplayName",              ATT_LDAP_DISPLAY_NAME },
       { "adminDisplayName",             ATT_ADMIN_DISPLAY_NAME },
       { "distinguishedName",            ATT_OBJ_DIST_NAME },
       { "adminDescription",             ATT_ADMIN_DESCRIPTION },
       { "attributeID;binary",           ATT_ATTRIBUTE_ID },
       { "attributeSyntax;binary",       ATT_ATTRIBUTE_SYNTAX },
       { "isSingleValued",               ATT_IS_SINGLE_VALUED },
       { "rangeLower",                   ATT_RANGE_LOWER },
       { "rangeUpper",                   ATT_RANGE_UPPER },
       { "mapiID",                       ATT_MAPI_ID },
       { "linkID",                       ATT_LINK_ID },
       { "schemaIDGUID",                 ATT_SCHEMA_ID_GUID },
       { "attributeSecurityGUID",        ATT_ATTRIBUTE_SECURITY_GUID },
       { "isMemberOfPartialAttributeSet",ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET },
       { "systemFlags",                  ATT_SYSTEM_FLAGS },
       { "defaultHidingValue",           ATT_DEFAULT_HIDING_VALUE },
       { "showInAdvancedViewOnly",       ATT_SHOW_IN_ADVANCED_VIEW_ONLY },
       { "defaultSecurityDescriptor",    ATT_DEFAULT_SECURITY_DESCRIPTOR },
       { "defaultObjectCategory",        ATT_DEFAULT_OBJECT_CATEGORY },
       { "nTSecurityDescriptor",         ATT_NT_SECURITY_DESCRIPTOR },
       { "OMObjectClass",                ATT_OM_OBJECT_CLASS },
       { "OMSyntax",                     ATT_OM_SYNTAX },
       { "searchFlags",                  ATT_SEARCH_FLAGS },
       { "systemOnly",                   ATT_SYSTEM_ONLY },
       { "extendedCharsAllowed",         ATT_EXTENDED_CHARS_ALLOWED },
       { "governsID;binary",             ATT_GOVERNS_ID },
       { "rDNAttID;binary",              ATT_RDN_ATT_ID },
       { "objectClassCategory",          ATT_OBJECT_CLASS_CATEGORY },
       { "subClassOf;binary",            ATT_SUB_CLASS_OF },
       { "systemAuxiliaryClass;binary",  ATT_SYSTEM_AUXILIARY_CLASS },
       { "auxiliaryClass;binary",        ATT_AUXILIARY_CLASS },
       { "systemPossSuperiors;binary",   ATT_SYSTEM_POSS_SUPERIORS },
       { "possSuperiors;binary",         ATT_POSS_SUPERIORS },
       { "systemMustContain;binary",     ATT_SYSTEM_MUST_CONTAIN },
       { "mustContain;binary",           ATT_MUST_CONTAIN },
       { "systemMayContain;binary",      ATT_SYSTEM_MAY_CONTAIN },
       { "mayContain;binary",            ATT_MAY_CONTAIN },
 };

int cLDAPMapping = sizeof(LDAPMapping) / sizeof(LDAPMapping[0]);


ATTRTYP StrToAttr( char *attr_name )
{
    int i;
      
    for ( i = 0; i < cLDAPMapping; i++)
        {
          if ( _stricmp( attr_name, LDAPMapping[i].attribute_name ) == 0 ) {
             return( LDAPMapping[i].type );
          }
        };
    return( -1 );
};
      


////////////////////////////////////////////////////////////////
// The next few functions are used to implement a mapping table 
// to map BER Encoded OID string prefixes to internal Ids. An 
// arbitrary, but unique, id is assigned to each prefix. The
// tables are implemented using the generic table packages
// defined in ntrtl.h
//////////////////////////////////////////////////////////////////


PVOID PrefixToNdxAllocate( RTL_GENERIC_TABLE *Table, CLONG ByteSize )
{
   return( malloc(ByteSize) );
}

VOID PrefixToNdxFree( RTL_GENERIC_TABLE *Table, PVOID Buffer )
{
   free( Buffer );
}


RTL_GENERIC_COMPARE_RESULTS
PrefixToNdxCompare( RTL_GENERIC_TABLE   *Table,
                    PVOID               FirstStruct,
                    PVOID               SecondStruct )
{

    PPREFIX_MAP PrefixMap1 = (PPREFIX_MAP) FirstStruct;
    PPREFIX_MAP PrefixMap2 = (PPREFIX_MAP) SecondStruct;
    int diff;

    // Compare the prefix parts
    if ( ( 0 == (diff = (PrefixMap1->Prefix).length 
                             - (PrefixMap2->Prefix).length)) &&
            (0 == (diff = memcmp( (PrefixMap1->Prefix).elements, (PrefixMap2->Prefix).elements, (PrefixMap1->Prefix).length))))
          { return( GenericEqual ); }
    else if ( diff > 0 )
          { return( GenericGreaterThan ); }
    return ( GenericLessThan );
}


void PrefixToNdxTableAdd( PVOID *Table, PPREFIX_MAP PrefixMap )
{
    PVOID ptr;
    
    if ( *Table == NULL ) {
        *Table = malloc( sizeof(RTL_GENERIC_TABLE) );
        if( *Table == NULL) {
          // malloc failed
          printf("ERROR: PrefixToNdxTableAdd: Malloc failed\n");
          return;
        }
        RtlInitializeGenericTable(
                    (RTL_GENERIC_TABLE *) *Table,
                    PrefixToNdxCompare,
                    PrefixToNdxAllocate,
                    PrefixToNdxFree,
                    NULL );
     }

    ptr = RtlInsertElementGenericTable(
                        (RTL_GENERIC_TABLE *) *Table,
                        PrefixMap,
                        sizeof(PREFIX_MAP), 
                        NULL );         
   
}

    
PPREFIX_MAP PrefixToNdxTableLookup( PVOID *Table, PPREFIX_MAP PrefixMap )
{
    if ( *Table == NULL ) return( NULL );
    return(RtlLookupElementGenericTable(
                            (RTL_GENERIC_TABLE *) *Table,
                            PrefixMap) );
}

ULONG AssignNdx()
{

    // Assign the next index from DummyNdx
    return (DummyNdx++);

}


/*++
Routine Description:
    Converts a BEREncoded OID to an Internal Id

Arguments:
    OidStr - BER Encoded OID
    oidLen - Length of OidStr

Return Value:
    The internal id generated
--*/

ULONG OidToId(UCHAR *OidStr, ULONG oidLen)
{
    PREFIX_MAP PrefixMap;
    PPREFIX_MAP Result;
    ULONG length;
    ULONG PrefixLen, longID = 0;
    PVOID Oid;
    ULONG Ndx, Id, TempId=0;

    OID oidStruct;

    length = oidLen;
    Oid = OidStr;

    // Convert to Prefix here
    if ( (length > 2) &&
       (((unsigned char *)Oid)[length - 2] & 0x80)) {
      PrefixLen = length - 2;
      if ( (((unsigned char *)Oid)[length - 3] & 0x80)) {
        // Last decimal encoded took three or more octets. Will need special
        // encoding while creating the internal id to enable proper
        // decoding
        longID = 1;
      }
      // no special encoding in attrtyp needed
      else {
        longID = 0;
      }
    }
    else {
        PrefixLen = length - 1;
    }

    if (length == PrefixLen + 2) {
      TempId = ( ((unsigned char *)Oid)[length - 2] & 0x7f) << 7;
    }
    TempId += ((unsigned char *)Oid)[length - 1];
    if (longID) {
      TempId |= 0x8000;
    }
    
    PrefixMap.Prefix.length = PrefixLen;
    PrefixMap.Prefix.elements = malloc( PrefixLen );
    if (PrefixMap.Prefix.elements == NULL) {
       printf("OidToId: Error allocating memory\n");
       Id = 0xffffffff;
       return Id;
    }
    memcpy( PrefixMap.Prefix.elements, Oid, PrefixLen );


    // See if prefix is already in table. If so, return the 
    // corresponding index, else assign a new index to the Prefix

    if ( (Result = PrefixToNdxTableLookup(&PrefixTable, &PrefixMap)) != NULL ) {
        Ndx = Result->Ndx;
    }
    else {
       // Not in table, assign a new index and add to table
       PrefixMap.Ndx = AssignNdx(); 
       PrefixToNdxTableAdd( &PrefixTable, &PrefixMap );
       Ndx = PrefixMap.Ndx;
    }


    // Now form the internal Id from the Index


    Id = (Ndx << 16);
    Id = (Id | TempId);
    return Id;
}
       
    
/*++
Routine Description:
    Convert an internal Id to a dotted decimal OID

Arguments:
    Id - Id to convert

Return Values:
    Pointer to dotted decimal OID string on success, NULL on failure
--*/

UCHAR *IdToOid(ULONG Id )
{
    PPREFIX_MAP ptr;
    OID_t Oid;
    OID oidStruct;
    unsigned             len;
    BOOL                 fOK;
    UCHAR  *pOutBuf;
    ULONG Ndx;


    Ndx = ( Id & 0xFFFF0000 ) >> 16;

    if (PrefixTable == NULL) {
        printf("IdToOid: No prefix table\n");
        return NULL;
    }
   
    // This function uses a simple linear search of the table. This
    // is used instead of RtlGenericLookupElement... as it seems that
    // the created table can be searched only by one key, and we have 
    // searched it by OID string while creating the table

    ptr = RtlEnumerateGenericTable( (PRTL_GENERIC_TABLE) PrefixTable, TRUE );
    while( ptr != NULL ) {
      if ( ptr->Ndx == Ndx ) break;
      ptr = RtlEnumerateGenericTable( (PRTL_GENERIC_TABLE) PrefixTable, FALSE );
    }

    if (ptr == NULL) {
      printf("IdToOid: No prefix found for Id %x\n", Id);
      return NULL;
    }

    if ((Id & 0xFFFF ) < 0x80) {
       Oid.length = ptr->Prefix.length + 1;
       Oid.elements = malloc(Oid.length);
       if (Oid.elements == NULL) {
          // malloc failed
          printf("IdToOid: malloc failed\n");
          return NULL;
       }
       memcpy (Oid.elements, ptr->Prefix.elements,Oid.length);
       (( unsigned char *)Oid.elements)[ Oid.length - 1 ] =
          ( unsigned char ) (Id  & 0x7F );
    }
    else {
       Oid.length = ptr->Prefix.length + 2;
       Oid.elements = malloc(Oid.length);
       if (Oid.elements == NULL) {
          // malloc failed
          printf("IdToOid: malloc failed\n");
          return NULL;
       }
       memcpy (Oid.elements, ptr->Prefix.elements,Oid.length);

      (( unsigned char *)Oid.elements)[ Oid.length - 1 ] =
          ( unsigned char ) (Id  & 0x7F );
      (( unsigned char *)Oid.elements)[ Oid.length - 2 ] =
          ( unsigned char )  (( (Id & 0xFF80) >> 7 ) | 0x80 );

    }

    // Now Oid contains the BER Encoded string. Convert to
    // dotted decimal

    oidStruct.Val = (unsigned *) alloca( (1 + Oid.length)*(sizeof(unsigned)) );

    fOK = MyDecodeOID(Oid.elements, Oid.length, &oidStruct);
    free(Oid.elements);
    if(!fOK) {
        printf("IdToOid: error Decoding Id %x\n", Id);
        return NULL;
    }

    // Allocate memory for output. Assume all oid strings less than 512 chars
    pOutBuf = (UCHAR *)malloc(512);
    if (NULL == pOutBuf) {
        printf("Memory allocation error\n");
        return NULL;
    }

    // Now, turn the OID to a string
    len = MyOidStructToString(&oidStruct,pOutBuf);

    return pOutBuf;

}


///////////////////////////////////////////////////
// Routine Description:
//      Add all attribute schema entries to the attribute caches.
//
// Arguments: 
//      ld -  LDAP connection 
//      res -  LDAP message containing all attribute schema entries,
//      SCPtr - Pointer to schema cache to add attributes to
//
// Output: 0 if no errors, non-0 if error
//////////////////////////////////////////////////

int AddAttributesToCache( LDAP *ld, LDAPMessage *res, SCHEMAPTR *SCPtr )
{
	int             i, count=0;
    LDAPMessage     *e;
	char            *a, *dn;
	void            *ptr;
	struct berval   **vals;
    ATTRTYP         attr_type;
    ATT_CACHE        *pac;

	  // step through each schema entry returned 

	for ( e = ldap_first_entry( ld, res );
	      e != NULL;
	      e = ldap_next_entry( ld, e )) {


	     // Create an ATT_CACHE structure and initialize it

       pac = (ATT_CACHE *) malloc( sizeof(ATT_CACHE) );
       if (NULL == pac) {
           printf("Memory allocation error\n");
           return 1;
       }
       memset( pac,0,sizeof(ATT_CACHE) );
       count++; 

          // For each attribute of the entry, get the value(s),
          // check attribute type, and fill in the appropriate field
          // of the ATTCACHE structure

       for ( a = ldap_first_attribute( ld, e,
		      			               (struct berelement**)&ptr);
		         a != NULL;
		         a = ldap_next_attribute( ld, e,
				    	                  (struct berelement*)ptr ) ) {

		   vals = ldap_get_values_len( ld, e, a );
           attr_type = StrToAttr( a );
           switch ( attr_type ) {
             case ATT_ATTRIBUTE_ID :
                  { 
                    pac->id = OidToId(vals[0]->bv_val,vals[0]->bv_len);
                    break;
                  };
             case ATT_LDAP_DISPLAY_NAME :
                  { 
                    pac->nameLen = vals[0]->bv_len;
                    pac->name = (UCHAR *)calloc(pac->nameLen+1, sizeof(UCHAR));
                    if( pac->name == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pac->name, vals[0]->bv_val, vals[0]->bv_len); 
                    pac->name[pac->nameLen] = '\0';
                    break;
                  };
             case ATT_OBJ_DIST_NAME :
                  { 
                    pac->DNLen = vals[0]->bv_len;
                    pac->DN = (UCHAR *)calloc(pac->DNLen+1, sizeof(UCHAR));
                    if( pac->DN == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pac->DN, vals[0]->bv_val, vals[0]->bv_len); 
                    pac->DN[pac->DNLen] = '\0';
                    break;
                  };
             case ATT_ADMIN_DISPLAY_NAME :
                  { 
                    pac->adminDisplayNameLen = vals[0]->bv_len;
                    pac->adminDisplayName 
                      = (UCHAR *)calloc(pac->adminDisplayNameLen+1, sizeof(UCHAR));
                    if( pac->adminDisplayName == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pac->adminDisplayName, vals[0]->bv_val, vals[0]->bv_len); 
                    pac->adminDisplayName[pac->adminDisplayNameLen] = '\0';
                    break;
                  };
             case ATT_ADMIN_DESCRIPTION :
                  { 
                    pac->adminDescrLen = vals[0]->bv_len;
                    pac->adminDescr 
                      = (UCHAR *)calloc(pac->adminDescrLen+1, sizeof(UCHAR));
                    if( pac->adminDescr == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pac->adminDescr, vals[0]->bv_val, vals[0]->bv_len); 
                    pac->adminDescr[pac->adminDescrLen] = '\0';
                    break;
                  };
             case ATT_NT_SECURITY_DESCRIPTOR :
                  { pac->NTSDLen = (DWORD) vals[0]->bv_len;
                    pac->pNTSD = malloc(pac->NTSDLen);
                    if ( pac->pNTSD == NULL )
                       { printf("Memory allocation error\n"); return(1);};
                    memcpy(pac->pNTSD, vals[0]->bv_val, vals[0]->bv_len);
                    break;
                  };
             case ATT_ATTRIBUTE_SYNTAX :
                  { if ( vals[0]->bv_val != NULL )
                       pac->syntax = OidToId(vals[0]->bv_val, vals[0]->bv_len); 
                    break; 
                  };
             case ATT_IS_SINGLE_VALUED :
                  { if ( _stricmp(vals[0]->bv_val, "TRUE") == 0 )
                       pac->isSingleValued = TRUE;
                    else pac->isSingleValued = FALSE;
                    pac->bisSingleValued = TRUE;
                    break;
                  };
             case ATT_RANGE_LOWER :
                  { pac->rangeLowerPresent = TRUE;
                    pac->rangeLower = (unsigned) atol(vals[0]->bv_val);
                    break;
                  };
             case ATT_RANGE_UPPER :
                  { pac->rangeUpperPresent = TRUE;
                    pac->rangeUpper = (unsigned) atol(vals[0]->bv_val);
                    break;
                  };
             case ATT_MAPI_ID :
                  { pac->ulMapiID = (unsigned) atol(vals[0]->bv_val);
                    break;
                  };
             case ATT_LINK_ID :
                  { pac->ulLinkID = (unsigned) atol(vals[0]->bv_val); 
                    break;
                  };
             case ATT_SCHEMA_ID_GUID :
                  { memcpy(&pac->propGuid, vals[0]->bv_val, sizeof(GUID));
                    break; 
                  };
             case ATT_ATTRIBUTE_SECURITY_GUID :
                  { memcpy(&pac->propSetGuid, vals[0]->bv_val, sizeof(GUID));
                    pac->bPropSetGuid = TRUE;
                    break; 
                  };
             case ATT_OM_OBJECT_CLASS :
                  { pac->OMObjClass.length = vals[0]->bv_len;
                    pac->OMObjClass.elements = malloc(vals[0]->bv_len);
                    if( pac->OMObjClass.elements == NULL ) 
                      {printf("Memory Allocation error\n"); return(1);};
                    memcpy(pac->OMObjClass.elements, vals[0]->bv_val,vals[0]->bv_len);
                    break;
                  };
             case ATT_OM_SYNTAX :
                  { pac->OMsyntax = atoi(vals[0]->bv_val);
                    break;
                  };
             case ATT_SEARCH_FLAGS :
                  { pac->SearchFlags = atoi(vals[0]->bv_val);
                    pac->bSearchFlags = TRUE;
                    break;
                  }
             case ATT_SYSTEM_ONLY :
                  { if ( _stricmp(vals[0]->bv_val, "TRUE" ) == 0)
                       pac->SystemOnly = TRUE;
                    else pac->SystemOnly = FALSE;
                    pac->bSystemOnly = TRUE;
                    break;
                  }
             case ATT_SHOW_IN_ADVANCED_VIEW_ONLY:
                  { if ( _stricmp(vals[0]->bv_val, "TRUE" ) == 0)
                       pac->HideFromAB = TRUE;
                    else pac->HideFromAB = FALSE;
                    pac->bHideFromAB = TRUE;
                    break;
                  }
             case ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET :
                  { if ( _stricmp(vals[0]->bv_val, "TRUE" ) == 0)
                       pac->MemberOfPartialSet = TRUE;
                    else pac->MemberOfPartialSet = FALSE;
                    pac->bMemberOfPartialSet = TRUE;
                    break;
                  }
             case ATT_EXTENDED_CHARS_ALLOWED:
                  { if ( _stricmp(vals[0]->bv_val, "TRUE") == 0 )
                       pac->ExtendedChars = TRUE;
                    else pac->ExtendedChars = FALSE;
                    pac->bExtendedChars = TRUE;
                    break;
                  }
             case ATT_SYSTEM_FLAGS :
                  { pac->sysFlags = atoi(vals[0]->bv_val);
                    pac->bSystemFlags = TRUE;
                    break;
                  };
           }   // End of Switch  
        
            // Free the structure holding the values

          ldap_value_free_len( vals );

      }  // End of for loop to read all atrributes of one entry

         // Add ATTCACHE structure to cache
     
       if( AddAttcacheToTables( pac, SCPtr ) != 0 ) {
           printf("Error adding ATTCACHE in AddAttcacheToTables\n");
           return( 1 );
         };

	}  // end of for loop to read all entries
    printf("No. of attributes read = %d\n", count);

    return( 0 );
}




//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Add all class schema entries to the class caches.
//
// Arguments:
//      ld -  LDAP connection
//      res -  LDAP message containing all class schema entries,
//      SCPtr - Pointer to schema cache to add attributes to
//
// Return Value: 0 if no errors, non-0 if error
//////////////////////////////////////////////////////////////////////

int AddClassesToCache( LDAP *ld, LDAPMessage *res, SCHEMAPTR *SCPtr )
{
	int             i, count;
    LDAPMessage     *e;
	char            *a, *dn;
	void            *ptr;
	struct berval   **vals;
    ATTRTYP         attr_type;
    CLASS_CACHE      *pcc;
    

    // Step through each class schema entry returned 

	for ( e = ldap_first_entry( ld, res );
	      e != NULL;
	      e = ldap_next_entry( ld, e ) ) {


         // Create a CLASS_CACHE structure and initialize it 

        pcc = (CLASS_CACHE *) malloc( sizeof(CLASS_CACHE) );
        if ( pcc == NULL ) {
            printf("Error Allocating Classcache\n");
            return(1);
         };
        memset( pcc, 0, sizeof(CLASS_CACHE) );

         // For each attribute of the entry, get the value(s),
         // check attribute type, and fill in the appropriate field
         // of the CLASSCACHE structure

		for ( a = ldap_first_attribute( ld, e,
						                (struct berelement**)&ptr);
		      a != NULL;
		      a = ldap_next_attribute( ld, e,
					                   (struct berelement*)ptr ) ) {
		    vals = ldap_get_values_len( ld, e, a );
            attr_type = StrToAttr( a );
            switch (attr_type) {
              case ATT_LDAP_DISPLAY_NAME :
                  { 
                    pcc->nameLen = vals[0]->bv_len;
                    pcc->name = (UCHAR *)calloc(pcc->nameLen+1, sizeof(UCHAR));
                    if( pcc->name == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pcc->name, vals[0]->bv_val, vals[0]->bv_len); 
                    pcc->name[pcc->nameLen] = '\0';
                    break;
                  };
              case ATT_OBJ_DIST_NAME :
                  {
                    pcc->DNLen = vals[0]->bv_len;
                    pcc->DN = (UCHAR *)calloc(pcc->DNLen+1, sizeof(UCHAR));
                    if( pcc->DN == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pcc->DN, vals[0]->bv_val, vals[0]->bv_len);
                    pcc->DN[pcc->DNLen] = '\0';
                    break;
                  };
              case ATT_ADMIN_DISPLAY_NAME :
                  {
                    pcc->adminDisplayNameLen = vals[0]->bv_len;
                    pcc->adminDisplayName
                      = (UCHAR *)calloc(pcc->adminDisplayNameLen+1, sizeof(UCHAR
));
                    if( pcc->adminDisplayName == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pcc->adminDisplayName, vals[0]->bv_val, vals[0]->bv_len);
                    pcc->adminDisplayName[pcc->adminDisplayNameLen] = '\0';
                    break;
                  };
              case ATT_ADMIN_DESCRIPTION :
                  {
                    pcc->adminDescrLen = vals[0]->bv_len;
                    pcc->adminDescr
                      = (UCHAR *)calloc(pcc->adminDescrLen+1, sizeof(UCHAR));
                    if( pcc->adminDescr == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pcc->adminDescr, vals[0]->bv_val, vals[0]->bv_len);
                    pcc->adminDescr[pcc->adminDescrLen] = '\0';
                    break;
                  };
              case ATT_GOVERNS_ID :
                  { pcc->ClassId = OidToId(vals[0]->bv_val,vals[0]->bv_len);
                    break;
                  };
              case ATT_DEFAULT_SECURITY_DESCRIPTOR :
                  { pcc->SDLen = (DWORD) vals[0]->bv_len;
                    pcc->pSD = malloc(pcc->SDLen + 1);
                    if ( pcc->pSD == NULL )
                       { printf("Memory allocation error\n"); return(1);};
                    memcpy(pcc->pSD, vals[0]->bv_val, vals[0]->bv_len);
                    pcc->pSD[pcc->SDLen] = '\0';
                    break;
                  };
              case ATT_DEFAULT_OBJECT_CATEGORY :
                  {
                    pcc->DefaultObjCatLen = vals[0]->bv_len;
                    pcc->pDefaultObjCat = (UCHAR *)calloc(pcc->DefaultObjCatLen+1, sizeof(UCHAR));
                    if ( NULL == pcc->pDefaultObjCat )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pcc->pDefaultObjCat, vals[0]->bv_val, vals[0]->bv_len);
                    pcc->pDefaultObjCat[pcc->DefaultObjCatLen] = '\0';
                    break;
    
                  }
              case ATT_NT_SECURITY_DESCRIPTOR :
                  { pcc->NTSDLen = (DWORD) vals[0]->bv_len;
                    pcc->pNTSD = malloc(pcc->NTSDLen);
                    if ( pcc->pNTSD == NULL )
                       { printf("Memory allocation error\n"); return(1);};
                    memcpy(pcc->pNTSD, vals[0]->bv_val, vals[0]->bv_len);
                    break;
                  };
              case ATT_RDN_ATT_ID : 
                  { pcc->RDNAttIdPresent = TRUE;
                    pcc->RDNAttId = OidToId(vals[0]->bv_val,vals[0]->bv_len);
                    break;
                  };
              case ATT_OBJECT_CLASS_CATEGORY :
                  { pcc->ClassCategory = atoi(vals[0]->bv_val);
                    break;
                  };
              case ATT_SUB_CLASS_OF : 
                  { 
                    AddToList(&pcc->SubClassCount, &pcc->pSubClassOf, vals);
                    break;
                  }; 
              case ATT_SYSTEM_AUXILIARY_CLASS : 
                  { 
                    AddToList(&pcc->SysAuxClassCount, &pcc->pSysAuxClass, vals);
                    break;
                  } 
              case ATT_AUXILIARY_CLASS:
                  { 
                    AddToList(&pcc->AuxClassCount, &pcc->pAuxClass, vals);
                    break;
                  } 
              case ATT_SYSTEM_POSS_SUPERIORS : 
                  {
                    AddToList(&pcc->SysPossSupCount, &pcc->pSysPossSup, vals);
                    break;
                  }
              case ATT_POSS_SUPERIORS : 
                  { 
                    AddToList(&pcc->PossSupCount, &pcc->pPossSup, vals);
                    break;
                  };
              case ATT_SYSTEM_MUST_CONTAIN:
                  {
                    AddToList(&pcc->SysMustCount, &pcc->pSysMustAtts, vals);
                    break;
                  }
              case ATT_MUST_CONTAIN : 
                  {
                    AddToList(&pcc->MustCount, &pcc->pMustAtts, vals);
                    break;
                  };
              case ATT_SYSTEM_MAY_CONTAIN:
                  {
                    AddToList(&pcc->SysMayCount, &pcc->pSysMayAtts, vals);
                    break;
                  }
              case ATT_MAY_CONTAIN : 
                  {
                    AddToList(&pcc->MayCount, &pcc->pMayAtts, vals);
                    break;
                  };
              case ATT_SCHEMA_ID_GUID :
                  { memcpy(&pcc->propGuid, vals[0]->bv_val, sizeof(GUID));
                    break;
                  };
              case ATT_SYSTEM_ONLY :
                  { if ( _stricmp(vals[0]->bv_val, "TRUE") == 0 )
                       pcc->SystemOnly = TRUE;
                    else pcc->SystemOnly = FALSE;
                    pcc->bSystemOnly = TRUE;
                    break;
                  }
             case ATT_SHOW_IN_ADVANCED_VIEW_ONLY :
                  { if ( _stricmp(vals[0]->bv_val, "TRUE" ) == 0)
                       pcc->HideFromAB = TRUE;
                    else pcc->HideFromAB = FALSE;
                    pcc->bHideFromAB = TRUE;
                    break;
                  }
              case ATT_DEFAULT_HIDING_VALUE :
                  { if ( _stricmp(vals[0]->bv_val, "TRUE") == 0 )
                       pcc->DefHidingVal = TRUE;
                    else pcc->DefHidingVal = FALSE;
                    pcc->bDefHidingVal = TRUE;
                    break;
                  }   
              case ATT_SYSTEM_FLAGS :
                  { pcc->sysFlags = atoi(vals[0]->bv_val);
                    pcc->bSystemFlags = TRUE;
                    break;
                  };
            }   // End of Switch 

           // Free the structure holding the values

		 ldap_value_free_len( vals );

		} // end of for loop to read all attributes of a class

 
         // Add CLASSCACHE structure to cache

       if ( AddClasscacheToTables( pcc, SCPtr ) != 0 ) {
           printf("Error adding CLASSCACHE in AddClasscacheToTables\n");
           return( 1 );
         };

 	 } // End of for loop to read all class-schema entries
    return( 0 );
}



//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Adds an ATT_CACHE structure to the different attribute cache tables
//
// Arguments: 
//      pAC -  Pointer to an ATT_CACHE structure
//      SCPtr - Pointer to schema cache 
//
// Return Value: 0 if no errors, non-0 if error
/////////////////////////////////////////////////////////////////////

int AddAttcacheToTables( ATT_CACHE *pAC, SCHEMAPTR *SCPtr )
{

    ULONG i;
    int err;
    ATTRTYP aid;

    ULONG       ATTCOUNT  = SCPtr->ATTCOUNT; 
    HASHCACHE*  ahcId     = SCPtr->ahcId;
    HASHCACHE*  ahcMapi   = SCPtr->ahcMapi; 
    HASHCACHESTRING* ahcName = SCPtr->ahcName; 


    aid = pAC->id;

    for ( i = IdHash(aid,ATTCOUNT);
          ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY); i++ ) {
           if ( i >= ATTCOUNT ) { i = 0; }
       }
     ahcId[i].hKey = aid;
     ahcId[i].pVal = pAC;


    if ( pAC->ulMapiID ) {
        // if this att is MAPI visible, add it to MAPI cache 

        for ( i = IdHash(pAC->ulMapiID, ATTCOUNT);
              ahcMapi[i].pVal && (ahcMapi[i].pVal != FREE_ENTRY); i++ ) {
            if ( i >= ATTCOUNT ) { i = 0; }
        }
        ahcMapi[i].hKey = pAC->ulMapiID;
        ahcMapi[i].pVal = pAC;
    }

    if ( pAC->name ) {
        // if this att has a name, add it to the name cache 

        for ( i = NameHash(pAC->nameLen, pAC->name, ATTCOUNT);
              ahcName[i].pVal && (ahcName[i].pVal!= FREE_ENTRY); i++ ) {
            if ( i >= ATTCOUNT ) { i = 0; }
        }

        ahcName[i].length = pAC->nameLen;
        ahcName[i].value = malloc(pAC->nameLen);
        if (NULL == ahcName[i].value) {
            printf("Memory allocation error\n");
            return 1;
        }
        memcpy(ahcName[i].value,pAC->name,pAC->nameLen);
        ahcName[i].pVal = pAC;
    }

    return( 0 );
}


//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Adds a CLASS_CACHE structure to the different class cache tables
//
// Arguments:
//      pCC -  Pointer to an CLASS_CACHE structure
//      SCPtr - Pointer to schema cache
//
// Return Value: 0 if no errors, non-0 if error
/////////////////////////////////////////////////////////////////////

int AddClasscacheToTables( CLASS_CACHE *pCC, SCHEMAPTR *SCPtr )
{
    ULONG       CLSCOUNT  = SCPtr->CLSCOUNT;
    HASHCACHE*  ahcClass  = SCPtr->ahcClass;
    HASHCACHESTRING* ahcClassName = SCPtr->ahcClassName;

    int i,start;

    // add to class cache

    start=i=IdHash(pCC->ClassId,CLSCOUNT);


    do {
        if (ahcClass[i].pVal==NULL || (ahcClass[i].pVal== FREE_ENTRY))
        {
            break;
        }
        i=(i+1)%CLSCOUNT;

    }while(start!=i);

    ahcClass[i].hKey = pCC->ClassId;
    ahcClass[i].pVal = pCC;

    if (pCC->name) {
        /* if this class has a name, add it to the name cache */

        start=i=NameHash(pCC->nameLen, pCC->name, CLSCOUNT);
        do
        {
          if (ahcClassName[i].pVal==NULL || (ahcClassName[i].pVal== FREE_ENTRY))
           {
              break;
           }
          i=(i+1)%CLSCOUNT;

        }while(start!=i);

        ahcClassName[i].length = pCC->nameLen;
        ahcClassName[i].value = malloc(pCC->nameLen);
        if (NULL == ahcClassName[i].value) {
            printf("Memory allocation error\n");
            return 1;
        }
        memcpy(ahcClassName[i].value,pCC->name,pCC->nameLen);
        ahcClassName[i].pVal = pCC;
    }

    return 0;
}




//////////////////////////////////////////////////////////////////
// Routine Description:
//     Free all allocated memory in a schema cache 
//
// Arguments: 
//     SCPtr - Pointer to the schema cache
//
// Return Value: None
/////////////////////////////////////////////////////////////////

void FreeCache(SCHEMAPTR *SCPtr)
{
    if (SCPtr==NULL) return;

  {
    ULONG            ATTCOUNT      = SCPtr->ATTCOUNT ;
    ULONG            CLSCOUNT      = SCPtr->CLSCOUNT ;
    HASHCACHE        *ahcId        = SCPtr->ahcId ;
    HASHCACHE        *ahcMapi      = SCPtr->ahcMapi ;
    HASHCACHESTRING  *ahcName      = SCPtr->ahcName ;
    HASHCACHE        *ahcClass     = SCPtr->ahcClass ;
    HASHCACHESTRING  *ahcClassName = SCPtr->ahcClassName ;

    ULONG        i;
    ATT_CACHE   *pac;
    CLASS_CACHE *pcc;
   

    for ( i = 0; i < ATTCOUNT; i++ ) {
       if ( ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY) ) {
            pac = (ATT_CACHE *) ahcId[i].pVal;
            FreeAttcache( pac );
         };
      }

    for ( i = 0; i < CLSCOUNT; i++ ) {
       if ( ahcClass[i].pVal && (ahcClass[i].pVal != FREE_ENTRY) ) {
           pcc = (CLASS_CACHE *) ahcClass[i].pVal;
           FreeClasscache( pcc );
         };
      }

      // Free the Cache tables themselves

    free( ahcId );
    free( ahcName );
    free( ahcMapi );
    free( ahcClass );
    free( ahcClassName );
  }
}

////////////////////////////////////////////////////////////////////////
// Routine Description:
//     Remove an att_cache from all hash tables
//
// Arguments: 
//     SCPtr - Pointer to schema cache 
//     pAC - Att_cache structure to remove
//
// Return Value: None
//////////////////////////////////////////////////////////////////////// 

void FreeAttPtrs ( SCHEMAPTR *SCPtr, ATT_CACHE *pAC )
{
    ULONG    ATTCOUNT  = SCPtr->ATTCOUNT ;
    HASHCACHE*  ahcId     = SCPtr->ahcId ;
    HASHCACHE*  ahcMapi   = SCPtr->ahcMapi ;
    HASHCACHESTRING* ahcName   = SCPtr->ahcName ;

    register ULONG i;

 
    for ( i = IdHash(pAC->id,ATTCOUNT);
          (ahcId[i].pVal && (ahcId[i].hKey != pAC->id)); 
          i++ ) {
        if ( i >= ATTCOUNT ) {
        i = 0;
        }
    }
    ahcId[i].pVal = FREE_ENTRY;
    ahcId[i].hKey = 0;


    if ( pAC->ulMapiID ) {
        for ( i = IdHash(pAC->ulMapiID,ATTCOUNT);
              (ahcMapi[i].pVal && (ahcMapi[i].hKey != pAC->ulMapiID)); 
              i++ ) {
        if ( i >= ATTCOUNT ) {
            i = 0;
        }
        }
        ahcMapi[i].pVal = FREE_ENTRY;
        ahcMapi[i].hKey = 0;
    }

    if (pAC->name) {
        for ( i = NameHash(pAC->nameLen,pAC->name,ATTCOUNT);

         // this hash spot refers to an object, but the size or the
         // value is wrong

              (ahcName[i].pVal &&
               (ahcName[i].length != pAC->nameLen ||
                _memicmp(ahcName[i].value,pAC->name,pAC->nameLen)));
              i++ ) {
        if ( i >= ATTCOUNT ) {
            i = 0;
        }
        }
        ahcName[i].pVal = FREE_ENTRY;
        free(ahcName[i].value);
        ahcName[i].value = NULL;
        ahcName[i].length = 0;
    }

}

////////////////////////////////////////////////////////////////////////
// Routine Description:
//     Remove an class_cache from all hash tables
//
// Arguments:
//     SCPtr - Pointer to schema cache
//     pAC - class_cache structure to remove
//
// Return Value: None
////////////////////////////////////////////////////////////////////////

void FreeClassPtrs (SCHEMAPTR * SCPtr, CLASS_CACHE *pCC )
{
    register ULONG i;
    ULONG    CLSCOUNT  = SCPtr->CLSCOUNT ;
    HASHCACHE*  ahcClass   = SCPtr->ahcClass ;
    HASHCACHESTRING* ahcClassName   = SCPtr->ahcClassName ;


    for (i=IdHash(pCC->ClassId,CLSCOUNT);
         (ahcClass[i].pVal && (ahcClass[i].hKey != pCC->ClassId)); i++){
        if (i >= CLSCOUNT) {
        i=0;
        }
    }
    ahcClass[i].pVal = FREE_ENTRY;
    ahcClass[i].hKey = 0;

    if (pCC->name) {
        for (i=NameHash(pCC->nameLen,pCC->name,CLSCOUNT);
         // this hash spot refers to an object, but the size is
         // wrong or the value is wrong
         (ahcClassName[i].pVal &&
          (ahcClassName[i].length != pCC->nameLen ||
           _memicmp(ahcClassName[i].value,pCC->name,pCC->nameLen)));
         i++) {
        if (i >= CLSCOUNT) {
            i=0;
        }
        }
        ahcClassName[i].pVal = FREE_ENTRY;
        free(ahcClassName[i].value);
        ahcClassName[i].value = NULL;
        ahcClassName[i].length = 0;
    }



}


// Frees an att_cache structure

void FreeAttcache(ATT_CACHE *pac)
{
    if ( pac->name ) free( pac->name );
    if ( pac->DN ) free( pac->DN );
    if ( pac->adminDisplayName ) free( pac->adminDisplayName );
    if ( pac->adminDescr ) free( pac->adminDescr );
    free( pac );
}

// Frees a class_cache structure

void FreeClasscache(CLASS_CACHE *pcc)
{
    if ( pcc->name ) free( pcc->name );
    if ( pcc->DN ) free( pcc->DN );
    if ( pcc->adminDisplayName ) free( pcc->adminDisplayName );
    if ( pcc->adminDescr ) free( pcc->adminDescr );
    if ( pcc->pSD )  free( pcc->pSD );
    if ( pcc->pSubClassOf ) free( pcc->pSubClassOf );
    if ( pcc->pAuxClass ) free( pcc->pAuxClass );
    if ( pcc->pSysAuxClass ) free( pcc->pSysAuxClass );
    if ( pcc->pSysMustAtts ) free( pcc->pSysMustAtts );
    if ( pcc->pMustAtts ) free( pcc->pMustAtts );
    if ( pcc->pSysMayAtts ) free( pcc->pSysMayAtts );
    if ( pcc->pMayAtts ) free( pcc->pMayAtts );
    if ( pcc->pSysPossSup ) free( pcc->pSysPossSup );
    if ( pcc->pPossSup ) free( pcc->pPossSup );
}

// Frees the Oid strings malloced by us that are pointed at from
// the PREFIX_MAP structures in the table. The table entries themselves
// cannot be freed by us

void FreeTable(PVOID Table)
{
    
    PPREFIX_MAP ptr;

    if (Table == NULL) {
        return;
    }

    for (ptr = RtlEnumerateGenericTable((PRTL_GENERIC_TABLE) Table, TRUE);
         ptr != NULL;
         ptr = RtlEnumerateGenericTable((PRTL_GENERIC_TABLE) Table, FALSE))
     {
       if ( ptr->Prefix.elements != NULL ) free( ptr->Prefix.elements );
     }
}


// Debug routines


void PrintPrefix(ULONG length, PVOID Prefix)
{
    BYTE *pb;
    ULONG ib;
    UCHAR temp[512];

       pb = (LPBYTE) Prefix;
       if (pb != NULL) {
         for ( ib = 0; ib <length; ib++ )
          {
             sprintf( &temp[ ib * 2 ], "%.2x", *(pb++) );
          }
         temp[2*length]='\0';
         printf("Prefix is %s\n", temp);
       }
}

void PrintOid(PVOID Oid, ULONG len)
{
    BYTE *pb;
    ULONG ib;
    UCHAR temp[512];

       pb = (LPBYTE) Oid;
       if (pb != NULL) {
         for ( ib = 0; ib < len; ib++ )
          {
             sprintf( &temp[ ib * 2 ], "%.2x", *(pb++) );
          }
         temp[2*len]='\0';
         printf("Oid is %s\n", temp);
        }
}

      
void PrintTable(PVOID PrefixTable)
{
    PPREFIX_MAP ptr;      
    int count = 0;
    BYTE *pb;
    ULONG ib;
    UCHAR temp[512];
   
    if (PrefixTable == NULL) {
        printf("PrintTable: Null Table Pointer Passed\n");
        return;
    }

    printf("     ***********Table Print**************\n");

    for (ptr = RtlEnumerateGenericTable((PRTL_GENERIC_TABLE) PrefixTable, TRUE);
         ptr != NULL;
         ptr = RtlEnumerateGenericTable((PRTL_GENERIC_TABLE) PrefixTable, FALSE)) 
    { 
       pb = (LPBYTE) ptr->Prefix.elements;
       if (pb != NULL) {
         for ( ib = 0; ib < ptr->Prefix.length; ib++ )
          {
             sprintf( &temp[ ib * 2 ], "%.2x", *(pb++) );
          }
         temp[2*ptr->Prefix.length]='\0';
         printf("Ndx=%-4d Length=%-3d Prefix=%s\n",ptr->Ndx,ptr->Prefix.length, temp);
        }

      } 
    printf("         ***End Table print*************\n");
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\schemard\schemard.h ===
#include <ntdspch.h>
#include <winldap.h>

#include <attids.h>
#include <objids.h>
#include <drs.h>
#include <mdcodes.h>
#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>

#define MAX_ATTCOUNT 4096
#define MAX_CLSCOUNT 1024

#define MAX_ATT_CHANGE 2000
#define MAX_CLS_CHANGE 200

// typedefs for structures to be stored in Oid to id mapping tables

typedef struct _PREFIX_MAP {
    ULONG                 Ndx;
    OID_t                 Prefix;
} PREFIX_MAP;

typedef PREFIX_MAP *PPREFIX_MAP;

// My own definitions for CLASSCACHE and ATTCACHE, since they are
// somewhat different from the ones used by DS

typedef struct _att_cache
{
    ATTRTYP    id;                    /* Attribute Id */
    UCHAR      *name;                 /* ldapDisplay name (null terminated) */
    ULONG      nameLen;               /* strlen(name) (doesn't include NULL) */
    UCHAR      *DN;                   /* DN */
    ULONG      DNLen;                 /* DN length */      
    UCHAR      *adminDisplayName;     /* Admin Display Name */
    ULONG      adminDisplayNameLen;   /* Admin Display Name length */      
    UCHAR      *adminDescr;           /* Admin Description */
    ULONG      adminDescrLen;         /* Admin Description length */      
    PSECURITY_DESCRIPTOR pNTSD;       /* NT SD on the attribute-schema obj */
    DWORD      NTSDLen;               /* Length of NT SD. */
    int        syntax;                /* Syntax */
    BOOL       isSingleValued;        /* Single Valued or Multi-valued? */
    BOOL       rangeLowerPresent;     /* Lower range present */
    ULONG      rangeLower;            /* Optional - Lower range */
    BOOL       rangeUpperPresent;     /* Upper range present */ 
    ULONG      rangeUpper;            /* Optional - Upper range */
    ULONG      ulMapiID;              /* MAPI PropID (not PropTag) */
    ULONG      ulLinkID;              /* unique link/backlink id */
    GUID       propGuid;              /* Guid of this att for security */
    GUID       propSetGuid;           /* Guid of the property set of this */
    OID_t      OMObjClass;            /* class of OM object referenced */
    int        OMsyntax;              /* OM syntax */
    ULONG      sysFlags;              /* System-Flags */
    DWORD      SearchFlags;           /* 1=indexed, 2=and use it for ANR*/
    BOOL       HideFromAB;            /* HideFromAB value */
    BOOL       MemberOfPartialSet;    /* Member-of-partial-set or not */
    BOOL       SystemOnly;            /* System-Only attr? */
    BOOL       ExtendedChars;         /* skip character set checking? */
    unsigned   bPropSetGuid:1;        /* Is attribute-security guid present? */
    unsigned   bSystemFlags:1;        /* Is system flags present? */
    unsigned   bSearchFlags:1;        /* Is search flag present? */
    unsigned   bHideFromAB:1;         /* Is Hide-from-AB present? */
    unsigned   bMemberOfPartialSet:1; /* Is mem-of-Par-att-set value present */
    unsigned   bSystemOnly:1;         /* Is system-only present? */
    unsigned   bExtendedChars:1;      /* Is Extended-Chars present?  */
    unsigned   bDefunct:1;            /* Attribute is already deleted? */
    unsigned   bisSingleValued:1;     /* is is-single-valued present? */
} ATT_CACHE;

typedef struct _class_cache
{
    UCHAR     *name;                 /* Class name (ldapDisplayName) 
                                         (null terminated)   UTF8 */
    ULONG     nameLen;               /* strlen(name) (doesn't include NULL) */
    UCHAR     *DN;                   /* DN */
    ULONG     DNLen;                 /* DN length */      
    UCHAR     *adminDisplayName;     /* Admin Display Name */
    ULONG     adminDisplayNameLen;   /* Admin Display Name length */
    UCHAR     *adminDescr;           /* Admin Description */
    ULONG     adminDescrLen;         /* Admin Description length */
    ULONG     ClassId;               /* Class ID */
    UCHAR     *pSD;                  /* Default SD for this class */
    DWORD     SDLen;                 /* Length of default SD. */
    PSECURITY_DESCRIPTOR pNTSD;      /* NT SD on the class-schema obj */
    DWORD     NTSDLen;               /* Length of NT SD. */
    BOOL      RDNAttIdPresent;       /* RDN Att Id present? */
    ULONG     RDNAttId;              /* Naming attribute for this class */
    ULONG     ClassCategory;         /* X.500 object type for this class */
    UCHAR     *pDefaultObjCat;       /* Default search category 
                                          to put on instances */
    ULONG     DefaultObjCatLen;    /* Default search category length */ 
    ULONG     SubClassCount;         /* count of superclasses */
    ULONG     *pSubClassOf;          /* ptr to array of superclasses */
    ULONG     AuxClassCount;         /* count of auxiliary classes */
    ULONG     *pAuxClass;            /* ptr to array of aux classes */
    ULONG     SysAuxClassCount;      /* count of Sys aux classes */
    ULONG     *pSysAuxClass;         /* ptr to array of Sys aux classes*/
    ULONG     sysFlags;              /* System-Flags */
    GUID      propGuid;              /* Guid of this class for security */

    unsigned  PossSupCount;          /* Possible superior count */
    unsigned  MustCount;             /* Count of Must Atts */
    unsigned  MayCount;              /* Count of May Atts */

    ATTRTYP   *pPossSup;             /* ptr to array of poss supis */
    ATTRTYP   *pMustAtts;            /* Pointer to array of Must Atts */
    ATTRTYP   *pMayAtts;             /* Pointer to array of May Atts */

    unsigned  SysMustCount;          /* Count of System Must Atts */
    unsigned  SysMayCount;           /* Count of System May Atts */
    unsigned  SysPossSupCount;       /* Count of System PossSup */

    ATTRTYP   *pSysMustAtts;         /* Pointer to array of System MustAtts */
    ATTRTYP   *pSysMayAtts;          /* Pointer to array of System MayAtts */
    ULONG     *pSysPossSup;          /* Pointer to array of System PossSup */

    BOOL       HideFromAB;            /* Hide-From-AB val for the 
                                         class-schema object */
    BOOL       DefHidingVal;          /* default ATT_HIDE_FROM_ADDRESS_BOOK 
                                         value for newly created instances 
                                         of this class */
    BOOL      SystemOnly;            /* System-only class? */
    unsigned  bDefHidingVal:1;       /* Is DefHidingVal present? */
    unsigned  bHideFromAB:1;         /* Is HideFromAB present? */ 
    unsigned  bSystemOnly:1;         /* Is system-only present? */ 
    unsigned  bSystemFlags:1;        /* Is system flags present? */
    unsigned  bDefunct:1;            /* Class is already deleted? */
} CLASS_CACHE;

#define STRING_TYPE 1
#define BINARY_TYPE 2

typedef struct _MY_ATTRMODLIST
{

    USHORT      choice;                 /* modification type:
                                         *  Valid values:
                                         *    - AT_CHOICE_ADD_ATT
                                         *    - AT_CHOICE_REMOVE_ATT
                                         *    - AT_CHOICE_ADD_VALUES
                                         *    - AT_CHOICE_REMOVE_VALUES
                                         *    - AT_CHOICE_REPLACE_ATT
                                         */
    int    type;       // Type = string or binary. User fr printing
    ATTR AttrInf;                       /* information about the attribute  */
} MY_ATTRMODLIST;


// List of attributes to modify. 
typedef struct _ModifyStruct {
    ULONG count;            // No. of attributes
    MY_ATTRMODLIST ModList[30];  // At most 30 attributes for a class/attribute  
} MODIFYSTRUCT;

typedef struct _ulongList {
    ULONG count;
    ULONG *List;
} ULONGLIST;

PVOID
MallocExit(
    DWORD nBytes
    );

// Table functions to map Oids to Ids and vice-versa

PVOID        PrefixToNdxAllocate( RTL_GENERIC_TABLE *Table, CLONG ByteSize );
void         PrefixToIdFree( RTL_GENERIC_TABLE *Table, PVOID Buffer );
RTL_GENERIC_COMPARE_RESULTS 
             PrefixToNdxCompare( RTL_GENERIC_TABLE   *Table,
                                 PVOID   FirstStruct,
                                 PVOID   SecondStruct );
void         PrefixToNdxTableAdd( PVOID *Table, PPREFIX_MAP PrefixMap );
PPREFIX_MAP  PrefixToNdxTableLookup( PVOID *Table, PPREFIX_MAP PrefixMap );
ULONG        AssignNdx(); 
ULONG        OidToId( UCHAR *Oid, ULONG length );
UCHAR        *IdToOid( ULONG Id );
unsigned     MyOidStringToStruct ( UCHAR * pString, unsigned len, OID * pOID );
unsigned     MyOidStructToString ( OID *pOID, UCHAR *pOut );
BOOL         MyDecodeOID(unsigned char *pEncoded, int len, OID *pOID);
unsigned     MyEncodeOID(OID *pOID, unsigned char * pEncoded);



// Functions to load schema into schema cache
int __fastcall   GetAttById( SCHEMAPTR *SCPtr, ULONG attrid, 
                             ATT_CACHE** ppAttcache);
int __fastcall   GetAttByMapiId( SCHEMAPTR *SCPtr, ULONG ulPropID, 
                                 ATT_CACHE** ppAttcache );
int __fastcall   GetAttByName( SCHEMAPTR *SCPtr, ULONG ulSize, 
                               PUCHAR pVal, ATT_CACHE** ppAttcache );
int __fastcall   GetClassById( SCHEMAPTR *SCPtr, ULONG classid, 
                               CLASS_CACHE** ppClasscache );
int __fastcall   GetClassByName( SCHEMAPTR *SCPtr, ULONG ulSize, 
                                 PUCHAR pVal, CLASS_CACHE** ppClasscache );

int      CreateHashTables( SCHEMAPTR *SCPtr );
int      SchemaRead( char *pServerName, char *pDomainName, char *pUserName,
                     char *pPasswd, char **ppSchemaDN, SCHEMAPTR *SCPtr );
int      AddAttributesToCache( LDAP *ld, LDAPMessage *res, SCHEMAPTR *SCPtr); 
int      AddClassesToCache( LDAP *ld, LDAPMessage *res, SCHEMAPTR *SCPtr); 
int      AddAttcacheToTables( ATT_CACHE *p, SCHEMAPTR *SCPtr );
int      AddClasscacheToTables( CLASS_CACHE *p, SCHEMAPTR *SCPtr );
ATTRTYP  StrToAttr( char *attr_name );
void     AddToList(ULONG * puCount, ULONG **pauVal, struct berval **vals);



// Functions used to find and list conflicts between two schemas

void     ChangeDN(char *oldDN, char **newDN, char *targetSchemaDN);
void     FindAdds( FILE *fp, SCHEMAPTR *SCPtr1, SCHEMAPTR * SCPtr2 );
void     FindDeletes( FILE *fp, SCHEMAPTR *SCPtr1, SCHEMAPTR * SCPtr2 );
void     FindModify( FILE *fp, SCHEMAPTR *SCPtr1, SCHEMAPTR * SCPtr2 );
void     FindAttModify( FILE *fp, ATT_CACHE *pac, SCHEMAPTR * SCPtr );
void     FindClassModify( FILE *fp, CLASS_CACHE *pcc, SCHEMAPTR * SCPtr );
int      CompareList( ULONG *List1, ULONG *List2, ULONG Length );
void     LogConflict( char objType, char *s, 
                      UCHAR *name, ATTRTYP id );
void     LogOmission( char objType, UCHAR *name, 
                      ATTRTYP id);



// Functions to free schema cach memory and mapping tables at the end

void     FreeCache( SCHEMAPTR *SCPtr );
void     FreeAttPtrs( SCHEMAPTR *SCPtr, ATT_CACHE *pac );
void     FreeClassPtrs( SCHEMAPTR *SCPtr, CLASS_CACHE *pcc );
void     FreeAttcache( ATT_CACHE *pac );
void     FreeClasscache( CLASS_CACHE *pcc );
void     FreeTable( PVOID OidTable );


// Debug functions to change schema and prints

void     ChangeSchema(SCHEMAPTR *SCPtr);
int      Schemaprint1(SCHEMAPTR *SCPtr);
int      Schemaprint2(SCHEMAPTR *SCPtr);
void     PrintTable(PVOID OidTable);
void     PrintPrefix(ULONG lenght, PVOID Prefix);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\schemard\schematools.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <schemard.h>

#define iswdigit(x) ((x) >= '0' && (x) <= '9')

/*++
 * Walk an LDAP berval structure and adds all the unsigned values into an array
 * puCount && pauVal are in/out parameters
 ++*/
void AddToList(ULONG * puCount, ULONG **pauVal, struct berval  **vals)
{
    ULONG   i;
    ULONG   *pau;
    ULONG   NewCount = ldap_count_values_len(vals);

    *puCount = NewCount;
    pau = calloc(1,(*puCount)*sizeof(ULONG));
    if ( !pau ) {
        printf("Memeory Allocation error\n");
        *puCount = 0;
        *pauVal = NULL;
        return;
    }

    *pauVal = pau;

    for ( i = 0; i < NewCount; i++ ) {
        *pau = OidToId( vals[i]->bv_val,vals[i]->bv_len );
        ++pau;
    }

    return;
}



unsigned
MyOidStringToStruct (
        UCHAR * pString,
        unsigned len,
        OID * pOID
        )
/*++
Routine Description:
    A stripped down version of the OidStringToStruct in oidconv.c
    Translates a string of the format "X.Y.Z"
    to an oid structure of the format {count=3, val[]={X,Y,Z}}
    No checks performed as we expect the OID values in the directory
    to be already correct

Arguments
    pString - the string format oid.
    pLen - the length of pString in characters.
    pOID - pointer to an OID structure to fill in.  Note: the value field must
    be pre-allocated and the len field should hold the number of values
    pre-allocated.

Return Values
    0 if successfull, non-0 if a failure occurred.
--*/
{
    int i;
    int numVals = pOID->cVal;
    unsigned val;
    UCHAR * pCur = pString;
    UCHAR * pEnd = pString + len;


    // Must have non-zero length
    if (len == 0) {
        return 1;
    }

    // pCur is now positioned on the first character in the
    // first decimal in the string 

    pOID->cVal = 0;

    while (pCur < pEnd) {
        if (!iswdigit(*pCur)) {
            return 2;
        }
        val = *pCur - '0';
        ++pCur;
        while (pCur < pEnd && *pCur != '.') {
            if (!iswdigit(*pCur)) {
                return 3;
            }
            val = 10*val + *pCur - '0';
            ++pCur;
        }
        // Keep track of whether we found a dot for the last character.
        if(pOID->cVal >= numVals) {
            return 4;
        }
        pOID->Val[pOID->cVal] = val;
        pOID->cVal++;
        ++pCur;
    }
    return 0;
}

unsigned
MyOidStructToString (
        OID *pOID,
        UCHAR *pOut
        )
/*++
Routine Description:
    Translates a structure in the format
         {count=3, val[]={X,Y,Z}}
    to a string of the format "X.Y.Z".

Arguments
    pOID - pointer to an OID structure to translate from.
    pOut - preallocated string to fill in.

Return Values
    the number of characters in the resulting string.
--*/
{
    int i;
    UCHAR *pCur = pOut;

    for (i=0; i<pOID->cVal; i++) {
      _ultoa(pOID->Val[i], pCur, 10);
  
      while (*pCur) {
          ++pCur;
      }
      if (i != (pOID->cVal - 1)) {
        *pCur++ = '.';
      }
    }
    return (UINT)(pCur - pOut);
}

/*++ DecodeOID
 *
 * Takes a BER encoded OID as an octet string and returns the OID in
 * structure format.
 *
 * INPUT:
 *    pEncoded - Pointer to a buffer holding the encoded octet string.
 *    len      - Length of the encoded OID
 *    pOID     - Pointer to a *preallocated* OID structure that will
 *               be filled in with the decoded OID.
 *
 * OUTPUT:
 *    pOID     - Structure is filled in with the decoded OID
 *
 * RETURN VALUE:
 *    0        - value could not be decoded (bad OID)
 *    non-0    - OID decoded successfully
 */
BOOL MyDecodeOID(unsigned char *pEncoded, int len, OID *pOID) {
    unsigned cval;
    unsigned val;
    int i, j;

    if (len <=2) {
    return FALSE;
    }

    // The first two values are encoded in the first octet.

    pOID->Val[0] = pEncoded[0] / 40;
    pOID->Val[1] = pEncoded[0] % 40;
    cval = 2;
    i = 1;

    while (i < len) {
    j = 0;
    val = pEncoded[i] & 0x7f;
    while (pEncoded[i] & 0x80) {
        val <<= 7;
        ++i;
        if (++j > 4 || i >= len) {
        // Either this value is bigger than we can handle (we
        // don't handle values that span more than four octets)
        // -or- the last octet in the encoded string has its
        // high bit set, indicating that it's not supposed to
        // be the last octet.  In either case, we're sunk.
        return FALSE;
        }
        val |= pEncoded[i] & 0x7f;
    }
    pOID->Val[cval] = val;
    ++cval;
    ++i;
    }
    pOID->cVal = cval;

    return TRUE;
}

/*++ EncodeOID
 *
 * Takes an OID in structure format and constructs a BER encoded octet
 * string representing that OID.
 *
 * INPUT:
 *    pOID     - Pointer to an OID structure to be encoded
 *    pEncoded - Pointer to a *preallocated* buffer that will hold the
 *               encoded octet string.  Sould be at least 4*MAX_OID_VALS long
 *
 * OUTPUT:
 *    pEncoded - Buffer holds the encoded OID
 *
 * RETURN VALUE:
 *    0        - Value could not be encoded (bad OID)
 *    non-0    - Length of resulting octet string, in bytes
 */
unsigned MyEncodeOID(OID *pOID, unsigned char * pEncoded){
    int i;
    unsigned len;
    unsigned val;

    // The first two values in the OID are encoded into a single octet
    // by a really appalling rule, as shown here.

    *pEncoded = (pOID->Val[0] * 40) + pOID->Val[1];
    len = 1;

    // For all subsequent values, each is encoded across multiple bytes
    // in big endian order (MSB first), seven bits per byte, with the
    // high bit being clear on the last byte, and set on all others.

    // PERFHINT - The checks below are pretty inelegant. The value can be
    // directly checked against the hex value instead of building up the
    // bit patterns in a strange way. Should clean up later. However, test
    // thoroughly after changing.

    for (i=2; i<pOID->cVal; i++) {
    val = pOID->Val[i];
    if (val > ((0x7f << 14) | (0x7f << 7) | 0x7f) ) {
        // Do we need 4 octets to represent the value?
        // Make sure it's not 5
        // Assert(0 == (val & ~((0x7f << 21) | (0x7f << 14) | (0x7f << 7) | 0x7f)));
        if (val & ~((0x7f << 21) | (0x7f << 14) | (0x7f << 7) | 0x7f)) {
          return 0;   // we can't encode things this big
        }
        pEncoded[len++] = 0x80 | ((val >> 21) & 0x7f);
    }
    if (val > ((0x7f << 7) | 0x7f) ) {
        // Do we need 3 octets to represent the value?
        pEncoded[len++] = 0x80 | ((val >> 14) & 0x7f);
    }
    if (val > 0x7f) {
        // Do we need 2 octets to represent the value?
        pEncoded[len++] = 0x80 | ((val >> 7) & 0x7f);
    }
    // Encode the low 7 bits into the last octet for this value
    pEncoded[len++] = val & 0x7f;
    }

    return len;
}


void ChangeDN( char *oldDN, char **newDN, char *targetSchemaDN )
{
   char  rdn[MAX_RDN_SIZE];
   int   i, j = 0;

   // find the rdn
   // Position at the beginning
   i = 3;
   while ( oldDN[i] != ',' ) {
     rdn[j++] = oldDN[i++];
   }
   rdn[j++] = ',';
   rdn[j]='\0';
   *newDN = MallocExit(j + 4 + strlen(targetSchemaDN));   
   strcpy( *newDN,"CN=" );
   strcat( *newDN,rdn );
   strcat( *newDN, targetSchemaDN );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\schemard\base64.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    base64.c

ABSTRACT:

    Base64 encoding and decoding functions.

DETAILS:
    
CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#include "debug.h"


NTSTATUS
base64encode(
      VOID    *pDecodedBuffer,
      DWORD   cbDecodedBufferSize,
      UCHAR   *pszEncodedString,
      DWORD   cchEncodedStringSize,
      DWORD   *pcchEncoded   
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pDecodedBuffer (IN) - buffer to encode.
    cbDecodedBufferSize (IN) - size of buffer to encode.
    cchEncodedStringSize (IN) - size of the buffer for the encoded string.
    pszEncodedString (OUT) = the encoded string.
    pcchEncoded (OUT) - size in characters of the encoded string.

Return Values:

    0 - success.
    STATUS_INVALID_PARAMETER
    STATUS_BUFFER_TOO_SMALL

--*/
{
    static char rgchEncodeTable[64] = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    DWORD   ib;
    DWORD   ich;
    DWORD   cchEncoded;
    BYTE    b0, b1, b2;
    BYTE *  pbDecodedBuffer = (BYTE *) pDecodedBuffer;

    // Calculate encoded string size.
    cchEncoded = 1 + (cbDecodedBufferSize + 2) / 3 * 4;

    if (NULL != pcchEncoded) {
        *pcchEncoded = cchEncoded;
    }

    if (cchEncodedStringSize < cchEncoded) {
        // Given buffer is too small to hold encoded string.
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Encode data byte triplets into four-byte clusters.
    ib = ich = 0;
    while (ib < cbDecodedBufferSize) {
        b0 = pbDecodedBuffer[ib++];
        b1 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;
        b2 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;

        pszEncodedString[ich++] = rgchEncodeTable[b0 >> 2];
        pszEncodedString[ich++] = rgchEncodeTable[((b0 << 4) & 0x30) | ((b1 >> 4) & 0x0f)];
        pszEncodedString[ich++] = rgchEncodeTable[((b1 << 2) & 0x3c) | ((b2 >> 6) & 0x03)];
        pszEncodedString[ich++] = rgchEncodeTable[b2 & 0x3f];
    }

    // Pad the last cluster as necessary to indicate the number of data bytes
    // it represents.
    switch (cbDecodedBufferSize % 3) {
      case 0:
        break;
      case 1:
        pszEncodedString[ich - 2] = '=';
        // fall through
      case 2:
        pszEncodedString[ich - 1] = '=';
        break;
    }

    // Null-terminate the encoded string.
    pszEncodedString[ich++] = '\0';

    //Assert(ich == cchEncoded);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rpcspoof\replrpcspoofstate.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:
    ReplRpcSpoofState.cxx

Abstract:
    To spoof the replication RPC calls an RPC and LDAP connection
    need to be associated with the handle passed back to the user
    and pointers returend from RPC and LDAP need to be associated
    with their appropreate clean up functions. To make these associations
    STL map class is used.

    The spoofed _ functions are functionally the same as their RPC
    counter parts. They interoperate in the same way. The RPC handle
    returned by _DsBindWithCredW can be used by non spoofed RPC functions.
    If an RPC handle returned from DsBindWithCredW is passed to any
    spoofed RPC functions the spoofed functions will place calls to the
    non spoofed RPC functions.

    The following functions are spoofed in this file:

    _DsBindWithCredW
    _DsUnBind
    _DsReplicaFreeInfo

Author:

    Chris King          [t-chrisk]    July-2000

Revision History:

--*/
#include <NTDSpchx.h>
#pragma hdrstop

#include <ntdsa.h>
#include <drs.h>
#include <winldap.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles

#include <map>
using namespace std;

#include "ReplRpcSpoofProto.hxx"
#include "ReplRpcSpoofState.hxx"

typedef struct _memoryLog {
    berval ** ppBerval;
    LDAPMessage * pLDAPMsg;
} memoryLog;

typedef map<HANDLE, LDAP *, less<HANDLE> > mBindings; // f:HANDLE->LDAP *
typedef map<PVOID, memoryLog, less<PVOID> > mBervalPtr;  // f:pvoid->berval **

// Note, these global structures should be protected by a synchronization
// mechanism if we ever use this library for multi-threaded clients.
mBindings gmBindings;
mBervalPtr gmBervalPtrs;
// Process-wide default data provider
BOOL gfUseLdap = TRUE;

DWORD
WINAPI
_DsBindWithCredW(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    HANDLE          *phDS)
/*++

  Routine Descriptions:
    Functional equivilant to the RPC version this function also opens an LDAP session if
    support is discovered for returning replication information via LDAP. A mapping between
    the RPC and LDAP handle is established.

  Arguments:
    DomainControllerName - DC
    DnsDomainName - DNS name
    AuthIdentity - Auth object
    phDS - an RPC handle which could be used by non spoofed RPC functions

  Return values:
    Various LDAP errors.

--*/
{
    DWORD ret;
    LDAP * phLdap = NULL;
    HANDLE hRpc;
    ULONG  ulOptions;
    LPWSTR pszTargetName;
    LDAPMessage * pRes = NULL;
    LPWSTR pszLdapHostList = NULL;
    PWCHAR szFilter = L"(objectclass=*)";
    PWCHAR attrs[2] = { L"supportedExtension", NULL };
    LPWSTR *ppszExtensions = NULL;
    BOOL fServerSupportsLdapReplInfo;
    BindState * pBindState;

    ret = DsBindWithCredW(DomainControllerName,
                          DnsDomainName,
                          AuthIdentity,
                          &hRpc);
    if (ret != NO_ERROR) {
        return ret;
    }

    // Crack DS handle to retrieve extensions of the target DSA.
    pBindState = (BindState *) hRpc;

    // Check for GETCHGREPLY_V5 (WHISTLER BETA 2)
    // We now require Whistler beta 2 since the name and range parsing for
    // RootDSE replication attributes has changed.
    fServerSupportsLdapReplInfo =
        IS_DRS_EXT_SUPPORTED(pBindState->pServerExtensions,
                             DRS_EXT_GETCHGREPLY_V5 );

    // Open an LDAP session and see if replication information via LDAP is supported
    if (gfUseLdap && fServerSupportsLdapReplInfo) {
        if (DomainControllerName){
            pszTargetName = (LPWSTR)DomainControllerName;
        } else {
            pszTargetName = (LPWSTR)DnsDomainName;
        }

        // Ldap supports a list of host:port pairs to try in order.
        // We try to connect to the GC port first if we can, since that allows us
        // to lookup readonly objects.  Ldap will make writeable objects on the GC
        // look like readonly objects, but that shouldn't matter for our
        // constructed attributes.
        pszLdapHostList = (LPWSTR) malloc(
            (wcslen(pszTargetName) * 2 + 15) * sizeof( WCHAR ) );
        if (pszLdapHostList == NULL) {
            // DsBindWithCred succeeded !? Go with it.
            // phLdap already NULL - Fall back
            goto cleanup;
        }
        swprintf( pszLdapHostList, L"%s:%d %s:%d",
                  pszTargetName, LDAP_GC_PORT,
                  pszTargetName, LDAP_PORT );

        // Init connection block
        phLdap = ldap_initW(pszLdapHostList, 0);
        if (NULL == phLdap) {
            // This routine does not connect and should not fail
            // DsBindWithCred succeeded !? Go with it.
            // phLdap already NULL - Fall back
            goto cleanup;
        }

        // use only A record dns name discovery
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        (void)ldap_set_optionW( phLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );
        // Don't follow referrals. The RPC interface doesn't.
        ulOptions = PtrToUlong(LDAP_OPT_OFF);
        (void)ldap_set_optionW( phLdap, LDAP_OPT_REFERRALS, &ulOptions );

        // Bind
        ret = ldap_bind_sW(phLdap, pszTargetName, (PWCHAR)AuthIdentity, LDAP_AUTH_SSPI);
        if (ret != LDAP_SUCCESS)
        {
            printf("Cannot connect or bind LDAP connection to %ls.\n", pszTargetName);
            // Fall back
            ldap_unbind(phLdap);
            phLdap = NULL; // Fall back
            goto cleanup;
        }
    }

cleanup:
    if (pszLdapHostList) {
        free( pszLdapHostList );
    }
    if (ppszExtensions) {
        ldap_value_freeW( ppszExtensions );
    }
    if (pRes) {
        ldap_msgfree(pRes);
    }

    gmBindings[hRpc] = phLdap;
    *phDS = hRpc;
    return 0;
}

DWORD
_DsUnBind(HANDLE *phRpc)
/*++

  Routine Descriptions:
    Functional equivilant to the RPC version this function closes the associated
    RPC session and LDAP session if one was established.

  Arguments:
    phDS - opaque session handle

  Return values:
    None.

--*/
{
    LDAP * phLdap = getBindings(*phRpc);
    if (phLdap)
        ldap_unbind(phLdap);

    DsUnBind(phRpc);

    return 0;
}

LDAP *
getBindings(HANDLE hRpc)
/*++

  Routine Descriptions:
    Maps the RPC session handle to the LDAP handle.

  Arguments:
    hRpc - an RPC handle

  Return values:
    Returns LDAP handle if one is associated with the hRpc handle.

--*/
{
    LDAP * phLdap = NULL;

    mBindings::iterator itr;
    itr = gmBindings.find(hRpc);
    if (itr != gmBindings.end())
        phLdap = (*itr).second;

    return phLdap;
}

void
logPointer(void * pReplStruct, berval ** ppBerval, LDAPMessage * pLDAPMsg)
/*++

  Routine Descriptions:
    This function associates pointers to replication
    structures returned by _DsReplicaGetInfoW and 2W to the berval and ldap
    message the data came in on.

  Arguments:
    pReplStruct - pointer to replication structure returned by _DsReplicaGetInfoW
    ppBerval - pointer to the berval associated with the pLDAPMsg
    pLDAPMsg - the LDAP message will contain only the ppBerval

--*/
{
    memoryLog memLog = {
        ppBerval, pLDAPMsg
    };
    gmBervalPtrs[pReplStruct] = memLog;
}

VOID
WINAPI
_DsReplicaFreeInfo(
    DS_REPL_INFO_TYPE   InfoType,
    VOID *              pInfo
    )
/*++

  Routine Descriptions:
    Searches for an association between pInfo and any LDAP structures. If no association
    is found then the pInfo was returned by DsReplicaGetInfo and should be freed with
    DsReplicaFreeInfo. If an association was found then LDAP memory functions are used
    to free the associated LDAP structures.

  Arguments:
    InfoType - type of information pointed to by pInfo
    pInfo - pointer to replication structure returned by _DsReplicaGetInfoW

--*/
{
    mBervalPtr::iterator itr;
    itr = gmBervalPtrs.find(pInfo);
    if (itr == gmBervalPtrs.end())
    {
        // This pointer belongs to the RPC interface
        DsReplicaFreeInfo(InfoType, pInfo);
    }
    else
    {
        memoryLog memLog = (*itr).second;

        // pInfo pointer refers to a de-marshaled repl structure
        if (memLog.ppBerval)
            ldap_value_free_len(memLog.ppBerval);
        if (memLog.pLDAPMsg)
            ldap_msgfree(memLog.pLDAPMsg);
        free(pInfo);

        gmBervalPtrs.erase(itr);
    }
}


BOOL
_DsBindSpoofSetTransportDefault(
    BOOL fUseLdap
    )

/*++

Routine Description:

    Change the default data provider for the spoofing library.
    This is a process-wide default.
    At process initialization, the spoofing library uses Ldap.

Arguments:

    fUseLdap - TRUE to use LDAP, false to use DsBind/RPC

Return Value:

    BOOL - Old value

--*/

{
    BOOL fOldValue = gfUseLdap;
    gfUseLdap = fUseLdap;
    return fOldValue;
} /* _DsBindSpoofSetTransportDefault */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\schupgr\schupgr.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <sddl.h>
#include <tchar.h>
#include "permit.h"
#include "schupgr.h"
#include "dsconfig.h"
#include "locale.h"
#include "winnlsp.h"



// Internal functions

DWORD  FindLdifFiles();
DWORD  GetObjVersionFromInifile(int *Version);
PVOID  MallocExit(DWORD nBytes);


// Global for writing log file

FILE *logfp;

// Global to fill yp with ldif file prefixes (ex. d:\winnt\system32\sch)

WCHAR  LdifFilePrefix[MAX_PATH];


// Globals to store version-from and version-to for the schema
// This will be set by the main function, and used by both DN conversion
// and actual import

int VersionFrom = 0, VersionTo = 0;


//////////////////////////////////////////////////////////////////////////
//
// Routine Description:
//
//    Main routine for schema upgrade
//    Does the following in order
//        * Get the computer name
//        * ldap connect and SSPI bind to the server
//        * Get the naming contexts by doing ldap search on root DSE
//        * Get the objectVersion X on the schema container (VersionFrom)
//          (0 if none present)
//        * Get the objectVersion Y in the new schema.ini file (VersionTo)
//          (0 if none present)
//        * Gets the schema FSMO if not already there
//        * put the AD in schema-upgrade mode
//        * Calls the exe ldifde.exe to import the schema changes
//          from the ldif files schZ.ldf into the DS. The files are
//          searched for in the system directory (where winnt32 puts them)
//        * resets schema-upgrade mode in the DS
//
// Return Values:
//
//    None. Error messages are printed out to the console
//    and logged in the file schupgr.log. Process bails out on error on any
//    of the above steps (taking care of proper cleaning-up)
//
///////////////////////////////////////////////////////////////////////// 

void 
_cdecl main( )
{

    // general ldap variables (open, bind, errors)
    LDAP            *ld;   
    DWORD           LdapErr;
    SEC_WINNT_AUTH_IDENTITY Credentials;

    // for ldap searches (naming contexts, objectVersion on schema)
    LDAPMessage     *res, *e;
    WCHAR           *attrs[10];

    // for ldap mods (FSMO)
    LDAPModW         Mod;
    LDAPModW        *pMods[5];

    // Others
    WCHAR           *ServerName = NULL;
    WCHAR           *DomainDN = NULL;
    WCHAR           *ConfigDN = NULL;
    WCHAR           *SchemaDN = NULL;
    WCHAR           SystemDir[MAX_PATH];
    WCHAR           NewFile[ MAX_PATH ];
    WCHAR           LdifLogFile[MAX_PATH], LdifErrFile[MAX_PATH];
    WCHAR           TempStr[25];   // for itoa conversions
    WCHAR           RenamedFile[100];
    WCHAR           VersionStr[100], LdifLogStr[100];
    WCHAR           CommandLine[512];
    DWORD           BuffSize = MAX_COMPUTERNAME_LENGTH + 1;
    int             i, NewSchVersion = 0, StartLdifLog = 0;
    DWORD           err = 0;
    BOOL            fDomainDN, fConfigDN, fSchemaDN;
    PWCHAR          *pwTemp;

    // for running ldifde.exe
    PROCESS_INFORMATION  procInf;
    STARTUPINFOW          startInf;

    UINT               Codepage;
                   // ".", "uint in decimal", null
    char               achCodepage[12] = ".OCP";

    //
    // Set locale to the default
    //
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%u", Codepage);
    }
    setlocale(LC_ALL, achCodepage);
    
    SetThreadUILanguage(0);


    // Find the log file no. X to start with for ldif.log.X
    // so that old ldif log files are not deleted 

    wcscpy(LdifLogFile,L"ldif.log.");
    _itow( StartLdifLog, VersionStr, 10 );
    wcscat(LdifLogFile,VersionStr);
    while ( (logfp = _wfopen(LdifLogFile,L"r")) != NULL) {
       fclose(logfp);
       StartLdifLog++;
       wcscpy(LdifLogFile,L"ldif.log.");
       _itow( StartLdifLog, LdifLogStr, 10 );
       wcscat(LdifLogFile, LdifLogStr);
    }

    // Open the schupgr log file. Erase any earlier log file

    logfp = _wfopen(L"schupgr.log", L"w");
    if (!logfp) {
      // error opening log file
      printf("Cannot open log file schupgr.log. Make sure you have permissions to create files in the current directory.\n");
      exit (1);
    }


    // get the server name
    ServerName = MallocExit(BuffSize * sizeof(WCHAR));
    while ((GetComputerNameW(ServerName, &BuffSize) == 0)
            && (ERROR_BUFFER_OVERFLOW == (err = GetLastError()))) {
        free(ServerName);
        BuffSize *= 2;
        ServerName = MallocExit(BuffSize * sizeof(WCHAR));
        err = 0;
    }

    if (err) {
         LogMessage(LOG_AND_PRT, MSG_SCHUPGR_SERVER_NAME_ERROR,
                    _itow(err, TempStr, 10), NULL);
         exit (1);
    }

    // connect through ldap

    if ( (ld = ldap_openW( ServerName, LDAP_PORT )) == NULL ) {
       LogMessage(LOG_AND_PRT, MSG_SCHUPGR_CONNECT_FAIL, ServerName, NULL);
       exit(1);
    }

    LogMessage(LOG_AND_PRT, MSG_SCHUPGR_CONNECT_SUCCEED, ServerName, NULL);

    // SSPI bind with current credentials

    memset(&Credentials, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));
    Credentials.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    LdapErr = ldap_bind_s(ld,
              NULL,  // use credentials instead
              (VOID*) &Credentials,
              LDAP_AUTH_SSPI);

    if (LdapErr != LDAP_SUCCESS) {
         LogMessage(LOG_AND_PRT, MSG_SCHUPGR_BIND_FAILED, 
                    _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
         ldap_unbind( ld );
         exit(1);
    }

    LogMessage(LOG_AND_PRT, MSG_SCHUPGR_BIND_SUCCEED, NULL, NULL);

     
    // Get the root domain DN, schema DN, and config DN

    attrs[0] = _wcsdup(L"rootDomainNamingContext");
    attrs[1] = _wcsdup(L"configurationNamingContext");
    attrs[2] = _wcsdup(L"schemaNamingContext");
    attrs[3] = NULL;
    if ( (LdapErr =ldap_search_sW( ld,
                        L"\0",
                        LDAP_SCOPE_BASE,
                        L"(objectclass=*)",
                        attrs,
                        0,
                        &res )) != LDAP_SUCCESS ) {
         LogMessage(LOG_AND_PRT, MSG_SCHUPGR_ROOT_DSE_SEARCH_FAIL,
                    _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
         ldap_unbind( ld );
         exit( 1 );
     }

    fDomainDN = FALSE;
    fConfigDN = FALSE;
    fSchemaDN = FALSE;

    for ( e = ldap_first_entry( ld, res );
          e != NULL;
          e = ldap_next_entry( ld, e ) ) {

          pwTemp = ldap_get_valuesW(ld, e, L"rootDomainNamingContext");
          if (pwTemp[0]) {
              if (DomainDN) {
                  free(DomainDN);
              }
              DomainDN = MallocExit((wcslen(pwTemp[0]) + 1) * sizeof(WCHAR));
              wcscpy(DomainDN, pwTemp[0]);
              fDomainDN = TRUE;
          }
          ldap_value_freeW(pwTemp);

          pwTemp = ldap_get_valuesW(ld, e, L"configurationNamingContext");
          if (pwTemp[0]) {
              if (ConfigDN) {
                  free(ConfigDN);
              }
              ConfigDN = MallocExit((wcslen(pwTemp[0]) + 1) * sizeof(WCHAR));
              wcscpy(ConfigDN, pwTemp[0]);
              fConfigDN = TRUE;
          }
          ldap_value_freeW(pwTemp);

          pwTemp = ldap_get_valuesW(ld, e, L"schemaNamingContext");
          if (pwTemp[0]) {
              if (SchemaDN) {
                  free(SchemaDN);
              }
              SchemaDN = MallocExit((wcslen(pwTemp[0]) + 1) * sizeof(WCHAR));
              wcscpy(SchemaDN, pwTemp[0]);
              fSchemaDN = TRUE;
          }
          ldap_value_freeW(pwTemp);
    }
    ldap_msgfree( res );
    free( attrs[0] );
    free( attrs[1] );
    free( attrs[2] );

    if ( !fDomainDN || !fConfigDN || !fSchemaDN ) {
      // One of the naming contexts were not found in the ldap read
      LogMessage(LOG_AND_PRT, MSG_SCHUPGR_MISSING_NAMING_CONTEXT, NULL, NULL);
      exit (1);
    }

    LogMessage(LOG_ONLY, MSG_SCHUPGR_NAMING_CONTEXT, DomainDN, NULL);
    LogMessage(LOG_ONLY, MSG_SCHUPGR_NAMING_CONTEXT, SchemaDN, NULL);
    LogMessage(LOG_ONLY, MSG_SCHUPGR_NAMING_CONTEXT, ConfigDN, NULL);

    // Get the schema version on the DC. if it is not found,
    // it is set to 0 (already initialized)

    attrs[0] = _wcsdup(L"objectVersion");
    attrs[1] = NULL;

    LdapErr = ldap_search_sW( ld,
                       SchemaDN,
                       LDAP_SCOPE_BASE,
                       L"(objectclass=DMD)",
                       attrs,
                       0,
                       &res );

    if ( (LdapErr != LDAP_SUCCESS) && (LdapErr != LDAP_NO_SUCH_ATTRIBUTE)) {
          LogMessage(LOG_AND_PRT, MSG_SCHUPGR_OBJ_VERSION_FAIL,
          _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
          ldap_unbind( ld );
          exit( 1 );
    }

    if (LdapErr==LDAP_NO_SUCH_ATTRIBUTE) {
       LogMessage(LOG_AND_PRT, MSG_SCHUPGR_NO_OBJ_VERSION, NULL, NULL);
    }

    // If an attribute is returned, find the value, else if no object
    // version value on schema container, we have already defaulted to 0

    if (LdapErr == LDAP_SUCCESS) {
       for ( e = ldap_first_entry( ld, res );
             e != NULL;
             e = ldap_next_entry( ld, e ) ) {

          pwTemp = ldap_get_valuesW(ld, e, L"objectVersion");
          if (pwTemp[0]) {
             VersionFrom = _wtoi( pwTemp[0]);
          }
          ldap_value_freeW(pwTemp);

       }
    }

    ldap_msgfree( res );
    free( attrs[0] );

    if (VersionFrom != 0) {
       LogMessage(LOG_AND_PRT, MSG_SCHUPGR_VERSION_FROM_INFO, 
       _itow(VersionFrom, TempStr, 10), NULL);
    }


    // find the version that they are trying to upgrade to.
    // Assumtion here is that they have ran winnt32 before this,
    // and so the schema.ini from the build they are trying to upgrade
    // to is copied in the windows directory
 
    err = GetObjVersionFromInifile(&VersionTo);
    if (err) {
       LogMessage(LOG_AND_PRT, MSG_SCHUPGR_NO_SCHEMA_VERSION,
                  _itow(err, TempStr, 10), NULL);
       ldap_unbind(ld);
       exit(1);
    }

    LogMessage(LOG_AND_PRT, MSG_SCHUPGR_VERSION_TO_INFO, 
               _itow(VersionTo, TempStr, 10), NULL);

    // If version is less than 10, and we are trying to upgrade to 10
    // or later, we cannot upgrade. Schema at version
    // 10 required a clean install
    
    if ((VersionFrom < 10) && (VersionTo >= 10)) {
       LogMessage(LOG_AND_PRT, MSG_SCHUPGR_CLEAN_INSTALL_NEEDED, NULL, NULL);
       exit(1);
    }


    // Check that all ldif files SchX.ldf (where X = VersionFrom+1 to 
    // VersionTo), exist

    // First create the prefix for all ldif files. This will be used
    // to search for the files both during DN conversion and during
    // import. so create it here. The prefix will look like
    // c:\winnt\system32\sch

    GetSystemDirectoryW(SystemDir, MAX_PATH);
    wcscat(SystemDir, L"\\");

    wcscpy(LdifFilePrefix, SystemDir);
    wcscat(LdifFilePrefix, LDIF_STRING);

    if ( err = FindLdifFiles() ) {
       // Error. Proper error message printed out by the function
       ldap_unbind( ld );
       exit (1);
    }

    // Ok, the ldif files to import from are all there  

     // Get the Schema FSMO

     pMods[0] = &Mod;
     pMods[1] = NULL;

     Mod.mod_op = LDAP_MOD_ADD;
     Mod.mod_type = _wcsdup(L"becomeSchemaMaster");
     attrs[0] = _wcsdup(L"1");
     attrs[1] = NULL;
     Mod.mod_vals.modv_strvals = attrs;

     if ( (LdapErr = ldap_modify_sW( ld, L"\0", pMods ))
                  != LDAP_SUCCESS ) {
          LogMessage(LOG_AND_PRT, MSG_SCHUPGR_FSMO_TRANSFER_ERROR,
                     _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
          ldap_unbind( ld );
          exit (1);
     }
     free(attrs[0]);
     free(pMods[0]->mod_type);

     // Check the schema version again. It is possible that the schema
     // changes were already made in the old FSMO, and the changes are
     // brought in by the FSMO transfer

     attrs[0] = _wcsdup(L"objectVersion");
     attrs[1] = NULL;

     LdapErr = ldap_search_sW( ld,
                         SchemaDN,
                         LDAP_SCOPE_BASE,
                         L"(objectclass=DMD)",
                         attrs,
                         0,
                         &res );
    if ( (LdapErr != LDAP_SUCCESS) && (LdapErr != LDAP_NO_SUCH_ATTRIBUTE)) {
           LogMessage(LOG_AND_PRT, MSG_SCHUPGR_OBJ_VERSION_RECHECK_FAIL,
                      _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
           ldap_unbind( ld );
           exit( 1 );
     }
 
     if ( LdapErr == LDAP_SUCCESS ) {
        for ( e = ldap_first_entry( ld, res );
              e != NULL;
              e = ldap_next_entry( ld, e ) ) {

            pwTemp = ldap_get_valuesW(ld, e, L"objectVersion");
            if (pwTemp[0]) {
               NewSchVersion = _wtoi( pwTemp[0]);
            }
            ldap_value_freeW(pwTemp);
        }
     }

     ldap_msgfree( res );
     free(attrs[0]);

     if (NewSchVersion == VersionTo) {
         // The schema already changed and the schema changes were
         // brought in by the FSMO transfer
          LogMessage(LOG_AND_PRT, MSG_SCHUPGR_RECHECK_OK, NULL, NULL);
          ldap_unbind(ld);
          exit (0);
      }
      else {
        if (NewSchVersion != VersionFrom) {
          // some changes were brought in, what to do? For now,
          // I will start from NewSchVersion
          // This is because the source has changes at least up to
          // NewSchVersion, and since we have done a FSMO transfer,
          // it has brought in the most uptodate schema

          VersionFrom = NewSchVersion;
        }
      }

    // Tell the AD that a schema upgrade is in progess

    pMods[0] = &Mod;
    pMods[1] = NULL;

    Mod.mod_op = LDAP_MOD_ADD;
    Mod.mod_type = _wcsdup(L"SchemaUpgradeInProgress");
    attrs[0] = _wcsdup(L"1");
    attrs[1] = NULL;
    Mod.mod_vals.modv_strvals = attrs;

    if ( (LdapErr = ldap_modify_sW( ld, L"\0", pMods ))
                 != LDAP_SUCCESS ) {
         LogMessage(LOG_AND_PRT, MSG_SCHUPGR_REQUEST_SCHEMA_UPGRADE,
                    _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
         LogMessage(LOG_AND_PRT, MSG_SCHUPGR_GENERAL_FAILURE, NULL, NULL );
         ldap_unbind( ld );
         exit (1);
    }
    free(attrs[0]);
    free(pMods[0]->mod_type);


    // From here on, we do things in try-finally block, so that anything
    // happens we will still reset schema-upgrade mode

    __try {

       // Everything is set. Now Import

       FILE *errfp;
       
       // Create the error file name. Only way to check if
       // ldifde failed or not. ldifde creates the error file
       // in the current directory, so thats where we will look

       wcscpy(LdifErrFile,L"ldif.err");

       // Now do the imports from the ldif files

       for ( i=VersionFrom+1; i<=VersionTo; i++) {

           _itow( i, VersionStr, 10 );

           // create the file name to import
           wcscpy( NewFile, LdifFilePrefix );
           wcscat( NewFile, VersionStr );
           wcscat( NewFile, LDIF_SUFFIX);

           // Create the command line first. 
           wcscpy( CommandLine, SystemDir);
           wcscat( CommandLine, L"ldifde -i -f " );
           wcscat( CommandLine, NewFile );
           wcscat( CommandLine, L" -s ");
           wcscat( CommandLine, ServerName );
           wcscat( CommandLine, L" -c " );
           // We assume all DNs areterminated with DC=X where the root domain
           // DN need to be put in
           wcscat( CommandLine, L"DC=X " );
           wcscat( CommandLine, DomainDN );
           wcscat( CommandLine, L" -j .");

           LogMessage(LOG_ONLY, MSG_SCHUPGR_COMMAND_LINE, CommandLine, NULL);
           memset(&startInf, 0, sizeof(startInf));
           startInf.cb = sizeof(startInf);

           // now call ldifde to actually do the import

           // Delete any earlier ldif error file
           DeleteFileW(LdifErrFile);
   
           CreateProcessW(NULL,
                         CommandLine, NULL,NULL,0,0,NULL,NULL,&startInf,&procInf);
   
           // Make the calling process wait for lidifde to finish import

           if ( WaitForSingleObject( procInf.hProcess, INFINITE )
                     == WAIT_FAILED ) {
              err = GetLastError();
              LogMessage(LOG_AND_PRT, MSG_SCHUPGR_LDIFDE_WAIT_ERROR,
                         _itow(err, TempStr, 10), NULL);
              CloseHandle(procInf.hProcess);
              CloseHandle(procInf.hThread);
              __leave;
           }
           CloseHandle(procInf.hProcess);
           CloseHandle(procInf.hThread);

           // ok, ldifde fninished. 

           // First save the log file

           wcscpy(LdifLogFile,L"ldif.log.");
           _itow( StartLdifLog, LdifLogStr, 10 );
           wcscat(LdifLogFile,LdifLogStr);
           CopyFileW(L"ldif.log",LdifLogFile, FALSE);
           StartLdifLog++;

           // Check if an error file is created.
           // Bail out in that case

           errfp = NULL;
           if ( (errfp = _wfopen(LdifErrFile,L"r")) != NULL) {
              // file opened successfully, so there is an error
              // Bail out

              fclose(errfp);
              wcscpy(RenamedFile,L"ldif.err.");
              wcscat(RenamedFile,VersionStr);
              LogMessage(LOG_AND_PRT, MSG_SCHUPGR_IMPORT_ERROR, NewFile, RenamedFile);
              CopyFileW(L"ldif.err",RenamedFile,FALSE);
              break;
           }
              
 
       } /* for */
    }
    __finally {

        // Tell the AD that a schema upgrade is no longer in progess

        pMods[0] = &Mod;
        pMods[1] = NULL;

        Mod.mod_op = LDAP_MOD_ADD;
        Mod.mod_type = _wcsdup(L"SchemaUpgradeInProgress");
        attrs[0] = _wcsdup(L"0");
        attrs[1] = NULL;
        Mod.mod_vals.modv_strvals = attrs;

        if ( (LdapErr = ldap_modify_sW( ld, L"\0", pMods ))
                     != LDAP_SUCCESS ) {
             LogMessage(LOG_AND_PRT, MSG_SCHUPGR_REQUEST_SCHEMA_UPGRADE,
                        _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
             ldap_unbind( ld );
             exit (1);
        }
        free(attrs[0]);
        free(pMods[0]->mod_type);

        ldap_unbind( ld );

        free(ServerName);
        free(DomainDN);
        free(ConfigDN);
        free(SchemaDN);
    }
}

//////////////////////////////////////////////////////////////////////
//
// Routine Decsription:
//
//     Reads the objectVersion key in the SCHEMA section of the
//     schema.ini file and returns the value in *Version. If the
//     key cannot be read, 0 is returned in *Version
//     The schema.ini file is used is the one in windows directory,
//     the assumption being that winnt32 is run before this is run,
//     which would copy the schema.ini from the build we are trying
//     to upgrade to to the windows directory
//
// Arguments:
//     Version - Pointer to DWORD to return version in
// 
// Return Value:
//     0
// 
///////////////////////////////////////////////////////////////////////

DWORD GetObjVersionFromInifile(int *Version)
{
    DWORD nChars;
    char Buffer[32];
    char IniFileName[MAX_PATH] = "";
    BOOL fFound = FALSE;

    char  *SCHEMASECTION = "SCHEMA";
    char  *OBJECTVER = "objectVersion";
    char  *DEFAULT = "NOT_FOUND";


    // form the file name. It will look like c:\winnt\schema.ini
    // Windows directory is where winnt32 copies the latest schema.ini
    // to
    nChars = GetWindowsDirectoryA(IniFileName, MAX_PATH);
    if (nChars == 0 || nChars > MAX_PATH) {
        return GetLastError();
    }
    strcat(IniFileName,"\\schema.ini");

    *Version = 0;

    GetPrivateProfileStringA(
        SCHEMASECTION,
        OBJECTVER,
        DEFAULT,
        Buffer,
        sizeof(Buffer)/sizeof(char),
        IniFileName
        );

    if ( _stricmp(Buffer, DEFAULT) ) {
         // Not the default string, so got a value
         *Version = atoi(Buffer);
         fFound = TRUE;
    }

    if (fFound) {
       return 0;
    }
    else {
       // schema.ini we are looking at must have a version, since
       // we are upgrading to it. This part also catches errors like
       // the file is not there in the windows directory for some reason
       return 1;
    }
}


//////////////////////////////////////////////////////////////////////
// 
// Routine Description:
//
//     Helper file to open the correct ldif file, convert DNs in it
//     to conform to current domain, and write it out to a new file
//
// Arguments:
//
//     Version - Schema version on DC
//     pDomainDN - Pointer to Domain DN string
//     pConfigDN - Pointer to config DN string
//     pNewFile  - Pointer to space to write the new filename to
//                 (must be already allocated)
//
// Return Value:
//
//     0 on success, non-0 on error
//
//////////////////////////////////////////////////////////////////////

DWORD 
FindLdifFiles()
{
    WCHAR VersionStr[100]; // Not more than 99 digits for schema version!! 
    FILE  *fInp;
    int   i;
    WCHAR FileName[MAX_PATH];

    // Create the input ldif file name from the schema version no.
    // The file name is Sch(Version).ldf

    for ( i=VersionFrom+1; i<=VersionTo; i++ ) {
       
        wcscpy( FileName, LdifFilePrefix);

        // use version no. to find suffix
        _itow( i, VersionStr, 10 );
        wcscat( FileName, VersionStr );
        wcscat( FileName, LDIF_SUFFIX);
    
        if ( (fInp = _wfopen(FileName, L"r")) == NULL) {
           LogMessage(LOG_AND_PRT, MSG_SCHUPGR_MISSING_LDIF_FILE, FileName, NULL);
           return UPG_ERROR_CANNOT_OPEN_FILE;
        }
        fclose(fInp);
    }
    return 0;
}

PVOID
MallocExit(DWORD nBytes)
{
    PVOID  pRet;

    pRet = malloc(nBytes);
    if (!pRet) {
        LogMessage(LOG_AND_PRT, MSG_SCHUPGR_MEMORY_ERROR,
                   NULL, NULL);
        exit (1);
    }

    return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\sbsmunge\sbsmunge.cxx ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <rpc.h>		//  for UuidCreate()
#include <seopaque.h>	//	for ACE manipulation
#include <crypto\md5.h>	//	for hashing SD
#include <esent.h>


#define NO_GRBIT		0
#define Call( func )	{ if ( ( err = (func) ) != JET_errSuccess ) GotoHandleError( err ); }
#define GotoHandleError( func )	\
						{ SetErr( err = (func), __FILE__, __LINE__ ); goto HandleError; }

#ifdef DBG
#define Assert( exp )	{ if ( !( exp ) ) DebugBreak(); }
#else
#define Assert( exp )
#endif

DWORD					g_dwErr						= ERROR_SUCCESS;
const CHAR *			g_szFileErr					= NULL;
DWORD					g_dwLineErr					= 0;

//  save first occurrence of error so that it may be
//  reported upon program termination
//
VOID SetErr(
	const DWORD			dwErr,
	const CHAR *		szFileErr,
	const DWORD			dwLineErr )
	{
	if ( ERROR_SUCCESS == g_dwErr )
		{
		g_dwErr = dwErr;
		g_szFileErr = szFileErr;
		g_dwLineErr = dwLineErr;
		}
	}


//  ================================================================
class CPRINTF
//  ================================================================
	{
	public:
		CPRINTF() {}
		virtual ~CPRINTF() {}

	public:
		virtual void __cdecl operator()( const _TCHAR* szFormat, ... ) const = 0;
	};

//  ================================================================
class CPRINTFNULL : public CPRINTF
//  ================================================================
	{
	public:
		void __cdecl operator()( const _TCHAR* szFormat, ... ) const
			{
			va_list arg_ptr;
			va_start( arg_ptr, szFormat );
			va_end( arg_ptr );
			}
	};

//  ================================================================
class CPRINTFFILE : public CPRINTF
//  ================================================================
	{
	public:
		CPRINTFFILE( FILE * const pfile ) : m_pfile( pfile )	{}

		void __cdecl operator()( const _TCHAR* szFormat, ... ) const
			{
			va_list arg_ptr;
			va_start( arg_ptr, szFormat );
			_vftprintf( m_pfile, szFormat, arg_ptr );
			va_end( arg_ptr );
			}

	private:
		FILE * const	m_pfile;
	};

const CPRINTF *			g_pcprintf;


#define ROOTTAG			2

const DWORD				g_cbPage					= 8192;
const DWORD				g_cbSIDMax					= 32;
const DWORD				g_cbSIDWithDomainSid		= 24;
const DWORD				g_cbSIDWithDomainSidAndRid	= 28;

const CHAR * const		g_szHiddenTable				= "hiddentable";
const CHAR * const		g_szSBSUpdateCol			= "SBSUpdate";
const CHAR * const		g_szDatatable				= "datatable";
const CHAR * const		g_szPDNTRDNIndex			= "PDNT_index";
const CHAR * const		g_szDNTCol					= "DNT_col";
const CHAR * const		g_szRDNCol					= "ATTm589825";
const CHAR * const		g_szCommonNameCol			= "ATTm3";
const CHAR * const		g_szObjectClassCol			= "ATTc0";
const CHAR * const		g_szSystemFlagsCol			= "ATTj590199";
const CHAR * const		g_szDomainComponentCol		= "ATTm1376281";
const CHAR * const		g_szDnsRootCol				= "ATTm589852";
const CHAR * const		g_szNetbiosNameCol			= "ATTm589911";
const CHAR * const		g_szGUIDCol					= "ATTk589826";
const CHAR * const		g_szSIDCol					= "ATTr589970";
const CHAR * const		g_szSIDSyntaxPrefix			= "ATTr";
const CHAR * const		g_szSDTable					= "sd_table";
const CHAR * const		g_szSDIdCol					= "sd_id";
const CHAR * const		g_szSDHashCol				= "sd_hash";
const CHAR * const		g_szSDValueCol				= "sd_value";
const CHAR * const		g_szSDOwner					= "Owner";
const CHAR * const		g_szSDGroup					= "Group";
const CHAR * const		g_szSDDACL					= "DACL";
const CHAR * const		g_szSDSACL					= "SACL";


//	UNDONE: should I just include ntdsadef.h
//	instead of redefining these?
//
#define CLASS_CROSS_REF								0x0003000b
#define FLAG_CR_NTDS_NC								0x00000001
#define FLAG_CR_NTDS_DOMAIN							0x00000002
#define FLAG_CR_NTDS_NOT_GC_REPLICATED				0x00000004


BOOL FValidDnsDomainName(
	const WCHAR *	wszDomainName,
	DWORD * const	pcDomainComponents )
	{
	*pcDomainComponents = 0;

	for ( const WCHAR * wszDomainNameT = wcschr( wszDomainName, L'.' );
		NULL != wszDomainNameT;
		wszDomainNameT = wcschr( wszDomainNameT, L'.' ) )
		{
		wszDomainNameT++;	//	skip "." delimiter
		if ( 0 == *wszDomainNameT )
			{
			//	"." delimiter was the last character in the string
			//
			return FALSE;
			}

		(*pcDomainComponents)++;
		}

	//	account for last component
	//
	(*pcDomainComponents)++;

	//	DNS domain name must have at least two components
	//
	return ( (*pcDomainComponents) > 1 );
	}


JET_ERR ErrCheckUpgradable( JET_SESID sesid, JET_DBID dbid )
	{
	JET_ERR				err;
	JET_COLUMNDEF		columndef;
	OSVERSIONINFOEX		osvi;

	//	can only run this for SBS
	//
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	if ( !GetVersionEx( (LPOSVERSIONINFO)&osvi ) )
		{
		GotoHandleError( GetLastError() );
		}
	else if ( !( osvi.wSuiteMask & ( VER_SUITE_SMALLBUSINESS | VER_SUITE_SMALLBUSINESS_RESTRICTED ) ) )
		{
		GotoHandleError( ERROR_NOT_SUPPORTED );
		}

	//	verify this database hasn't previously been munged
	//
	err = JetGetColumnInfo(
				sesid,
				dbid,
				g_szHiddenTable,
				g_szSBSUpdateCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo );
	if ( JET_errColumnNotFound == err )
		{
		//	column doesn't exist, which means the
		//	database hasn't been munged before, so
		//	we can go ahead and do it now
		//
		err = JET_errSuccess;
		}
	else if ( err >= JET_errSuccess )
		{
		//	the existence of this column means that
		//	this database has already been munged
		//
		GotoHandleError( JET_errDatabaseAlreadyUpgraded );
		}
	else
		{
		GotoHandleError( err );
		}

HandleError:
	return err;
	}


//	"fix up" the domain DN
//
JET_ERR ErrMungeDomainDN(
	JET_SESID			sesid,
	JET_TABLEID			tableid,
	const WCHAR *		wszDomainComponentOld,
	const WCHAR *		wszDomainComponentNew,
	const JET_COLUMNID	columnidDNT,
	const JET_COLUMNID	columnidRDN,
	const JET_COLUMNID	columnidDomainComponent,
	DWORD *				pdwPDNT )
	{
	JET_ERR				err;
	DWORD				cbActual;
	const WCHAR *		wszNextDomainComponentOld		= wcschr( wszDomainComponentOld, L'.' );
	const WCHAR *		wszNextDomainComponentNew		= wcschr( wszDomainComponentNew, L'.' );

	if ( NULL != wszNextDomainComponentOld )
		{
		//	old and new domain names were already validated to ensure
		//	they have the same number of components
		//
		Assert( NULL != wszNextDomainComponentOld );

		//	more domain components still exist, process those first
		//	(since we need to work backwards from the end of the full 
		//	DNS domain name)
		//
		Call( ErrMungeDomainDN(
					sesid,
					tableid,
					wszNextDomainComponentOld + 1,	//	skip '.'
					wszNextDomainComponentNew + 1,	//	skip '.'
					columnidDNT,
					columnidRDN,
					columnidDomainComponent,
					pdwPDNT ) );
		}
	else
		{
		//	old and new domain names were already validated to ensure
		//	they have the same number of components
		//
		Assert( NULL == wszNextDomainComponentOld );

		//	fudge pointers so that following name length calculation will work
		//
		wszNextDomainComponentOld = wszDomainComponentOld + wcslen( wszDomainComponentOld );
		wszNextDomainComponentNew = wszDomainComponentNew + wcslen( wszDomainComponentNew );
		}


	//	process this component
	//
	const DWORD		cbDomainComponentOld	= ( wszNextDomainComponentOld - wszDomainComponentOld ) * sizeof( WCHAR );
	const DWORD		cbDomainComponentNew	= ( wszNextDomainComponentNew - wszDomainComponentNew ) * sizeof( WCHAR );

	//	find the object using the DNT of the previous component
	//
	Call( JetMakeKey(
				sesid,
				tableid,
				pdwPDNT,
				sizeof(DWORD),
				JET_bitNewKey ) );
	Call( JetMakeKey(
				sesid,
				tableid,
				wszDomainComponentOld,
				cbDomainComponentOld,
				NO_GRBIT ) );
	Call( JetSeek( sesid, tableid, JET_bitSeekEQ ) );

	//	retrieve PDNT for next domain component
	//	(remember we are working recursively
	//	back through the domain components in
	//	the DNS domain name)
	//
	Call( JetRetrieveColumn(
				sesid,
				tableid,
				columnidDNT,
				pdwPDNT,
				sizeof(DWORD),
				&cbActual,
				NO_GRBIT,
				NULL ) )
	Assert( sizeof(DWORD) == cbActual );

	//	update Domain Component for this object
	//
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReplace ) );

	Call( JetSetColumn(
				sesid,
				tableid,
				columnidRDN,
				wszDomainComponentNew,
				cbDomainComponentNew,
				NO_GRBIT,
				NULL ) );
	Call( JetSetColumn(
				sesid,
				tableid,
				columnidRDN,
				wszDomainComponentNew,
				cbDomainComponentNew,
				NO_GRBIT,
				NULL ) );

	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );
				
	(*g_pcprintf)(
		"\n  DNT %d (0x%x), columnid %d: replaced Domain Component with '%.*S'",
		*pdwPDNT,
		*pdwPDNT,
		columnidDomainComponent,
		cbDomainComponentNew / sizeof(WCHAR),
		wszDomainComponentNew );

HandleError:
	return err;
	}


//  generate pretty GUID
//
VOID FormatGUID(
	CHAR * const		szBuf,
	const BYTE *		pb,
	const DWORD			cb )
	{
	const GUID * const	pguid	= (GUID *)pb;

	if ( sizeof(GUID) == cb )
		{
		sprintf(
			szBuf,
			"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
			pguid->Data1,
			pguid->Data2,
			pguid->Data3,
			pguid->Data4[0],
			pguid->Data4[1],
			pguid->Data4[2],
			pguid->Data4[3],
			pguid->Data4[4],
			pguid->Data4[5],
			pguid->Data4[6],
			pguid->Data4[7] );
		}
	else
		{
		strcpy( szBuf, "NULL/zero-length" );
		}
	}


//	determine, by the name of the column, if the specified column is a SID-syntax attribute
//	UNDONE: could use strncmpi(), except that I don't want to link in the C-runtime
//
BOOL FIsSIDSyntax( CHAR * const szColumnName )
	{
	const DWORD		cbPrefix	= lstrlen( g_szSIDSyntaxPrefix );
	const CHAR		chSave		= szColumnName[cbPrefix];

	szColumnName[cbPrefix] = 0;

	const BOOL		fIsSIDSyntax	= ( 0 == lstrcmpi( szColumnName, g_szSIDSyntaxPrefix ) );

	szColumnName[cbPrefix] = chSave;

	return fIsSIDSyntax;
	}


//	routine to byte-swap a DWORD
//
inline DWORD DwReverseBytes( const DWORD dw )
	{
	//	UNDONE: this currently only works for x86
	//
	__asm mov	eax, dw
	__asm bswap	eax
	}


//	HACK: the DS wanted account SIDs ordered by RID, so the last
//	DWORD of all SIDs (not just account SIDs) were byte-swapped
//
VOID InPlaceSwapSID( PSID psid )
	{
	const DWORD		cSubAuthorities		= *GetSidSubAuthorityCount( psid );

	if ( cSubAuthorities > 0 )
		{
		DWORD *		pdwLastSubAuthority	= GetSidSubAuthority( psid, cSubAuthorities - 1 );

		*pdwLastSubAuthority = DwReverseBytes( *pdwLastSubAuthority );
		}
	}


DWORD ErrCheckEqualDomainSID(
	BYTE *			pbSID,
	BYTE *			pbDomainSID,
	BOOL *			pfDomainOnly,
	BOOL *			pfSameDomain )
	{
	DWORD			err;
	DWORD			cbDomainSID					= g_cbSIDMax;
	BYTE			rgbDomainSID[g_cbSIDMax];

	//	initialize return values
	//
	err = ERROR_SUCCESS;
	*pfDomainOnly = FALSE;
	*pfSameDomain = FALSE;

	//  extract the domain portion of the SID
	//
	if ( GetWindowsAccountDomainSid( pbSID, rgbDomainSID, &cbDomainSID ) )
		{
		//  see if the domain portion of the SID matches
		//
		if ( EqualSid( pbDomainSID, rgbDomainSID ) )
			{
			//  see if this is a domain-only SID or if this is an account SID
			//
			*pfDomainOnly = EqualSid( pbDomainSID, pbSID );
			*pfSameDomain = TRUE;
			}
		}

	else if ( ( err = GetLastError() ) == ERROR_NON_ACCOUNT_SID )
		{
		//	this is a valid SID, just not one with a domain portion
		//
		err = ERROR_SUCCESS;
		}
	else
		{
		//	unexpected error
		//
		GotoHandleError( err );
		}

HandleError:
	return err;
	}


JET_ERR ErrReplaceDomainSID(
	JET_SESID	 	sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	const DWORD		ibLongValue,
	BYTE *			pbDomainSIDNew,
	BYTE *			pbAccountSID )
	{
	JET_ERR			err;
	BYTE			rgbSIDNew[g_cbSIDMax];
	DWORD			cbSIDNew;
	JET_SETINFO		setcol;

	setcol.cbStruct = sizeof(JET_SETINFO);
	setcol.ibLongValue = ibLongValue;
	setcol.itagSequence = 1;

	//  copy SID to a temporary buffer
	//
	if ( !CopySid( g_cbSIDMax, rgbSIDNew, pbDomainSIDNew ) )
		{
		GotoHandleError( GetLastError() );
		}

	//  see if this is a domain-only SID or an account SID
	//
	if ( NULL != pbAccountSID )
		{
		const DWORD		cSubAuthoritiesOld	= *GetSidSubAuthorityCount( pbAccountSID );
		const DWORD		cSubAuthoritiesNew	= *GetSidSubAuthorityCount( rgbSIDNew ) + 1;
		const DWORD		dwRID				= *GetSidSubAuthority( pbAccountSID, cSubAuthoritiesOld - 1 );

		//  append existing RID to new domain SID to form new account SID
		//
		*GetSidSubAuthorityCount( rgbSIDNew ) = (UCHAR)cSubAuthoritiesNew;
		*GetSidSubAuthority( rgbSIDNew, cSubAuthoritiesNew - 1 ) = dwRID;

		//	length shouldn't change
		//
		Assert( GetLengthSid( rgbSIDNew ) == GetLengthSid( pbAccountSID ) );
		}

	//  for SID-syntax columns, must respect byte-swapping expected by the DS,
	//	for SID's embedded in other structures (ie. ACE's), no transformation is performed
	//
	if ( 0 == ibLongValue )
		{
		InPlaceSwapSID( rgbSIDNew );
		}

	//  perform the actual record replace
	//
	Call( JetSetColumn(
				sesid,
				tableid,
				columnid,
				rgbSIDNew,
				GetLengthSid( rgbSIDNew ),
				JET_bitSetOverwriteLV,		//	WARNING: assumes length doesn't change
				&setcol ) );

HandleError:
	return err;
	}


//  "fix up" one object
//
JET_ERR ErrMungeObject(
	JET_SESID				sesid,
	JET_TABLEID				tableid,
	const WCHAR *			wszDomainNameNew,
	BYTE *					pbDomainSIDOld,
	BYTE *					pbDomainSIDNew,
	const DWORD				iretcolDNT,
	const DWORD				iretcolObjectClass,
	const DWORD				iretcolSystemFlags,
	const JET_COLUMNID		columnidRDN,
	const JET_COLUMNID		columnidCommonName,
	const JET_COLUMNID		columnidDnsRoot,
	const JET_COLUMNID		columnidNetbiosName,
	const JET_COLUMNID		columnidGUID,
	JET_RETRIEVECOLUMN *	rgretcol,
	const DWORD				cretcol )
	{
	JET_ERR					err;
	const DWORD				dwDNT				= *(DWORD *)rgretcol[iretcolDNT].pvData;
	BOOL					fUpdateDnsRoot		= FALSE;
	BOOL					fUpdateNetbiosName	= FALSE;
	GUID					guid;
	DWORD					iretcol;

	//	generate a new GUID for this object
	//
	Call( UuidCreate( &guid ) );

	//  prepare a copy buffer for the record update
	//
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReplace ) )

	//	first update the record with the new GUID
	//
	Call( JetSetColumn(
				sesid,
				tableid,
				columnidGUID,
				&guid,
				sizeof(guid),
				JET_bitSetOverwriteLV,		//	WARNING: assumes length doesn't change
				NULL ) );

	//	determine if this is a cross-ref object
	//
	if ( JET_errSuccess == rgretcol[iretcolObjectClass].err
		&& ( *(DWORD *)rgretcol[iretcolObjectClass].pvData ) == CLASS_CROSS_REF )
		{
		//	this is a cross-ref, check flags to determine if it's
		//	a Domain, Schema, or Config cross-ref
		//
		Assert( sizeof(DWORD) == rgretcol[iretcolObjectClass].cbActual );

		if ( JET_errSuccess == rgretcol[iretcolSystemFlags].err )
			{
			Assert( sizeof(DWORD) == rgretcol[iretcolSystemFlags].cbActual );

			const DWORD		dwSystemFlags	= *(DWORD *)rgretcol[iretcolSystemFlags].pvData;
			if ( dwSystemFlags & FLAG_CR_NTDS_NC )
				{
				if ( dwSystemFlags & FLAG_CR_NTDS_DOMAIN )
					{
					//	this is a Domain cross-ref
					//
					fUpdateDnsRoot = TRUE;
					fUpdateNetbiosName = TRUE;
					}
				else if ( dwSystemFlags & FLAG_CR_NTDS_NOT_GC_REPLICATED )
					{
					//	should be impossible - NDNC's shouldn't be created yet
					//	in the distribution dit
					//
					Assert( FALSE );
					}
				else
					{
					//	must be Config or Schema cross-ref
					//
					fUpdateDnsRoot = TRUE;
					}
				}
			else
				{
				//	should be impossible - FLAG_CR_NTDS_NC should be set
				//	for all cross-ref objects
				//
				Assert( FALSE );
				}
			}
		else
			{
			//	should be impossible - all cross-ref objects should have
			//	a SystemFlags attribute that describes the cross-ref type
			//
			Assert( FALSE );
			}
		}

	//	update DNS Root if it was deemed necessary
	//
	if ( fUpdateDnsRoot )
		{
		Call( JetSetColumn(
					sesid,
					tableid,
					columnidDnsRoot,
					wszDomainNameNew,
					wcslen( wszDomainNameNew ) * sizeof(WCHAR),
					NO_GRBIT,
					NULL ) );
		(*g_pcprintf)(
			"\n  DNT %d (0x%x), columnid %d: replaced DNS Root with '%S'",
			dwDNT,
			dwDNT,
			columnidDnsRoot,
			wszDomainNameNew );
		}

	//	update Netbios Name if it was deemed necessary
	//
	if ( fUpdateNetbiosName )
		{
		//	use first component of DNS domain name for Netbios name
		//	(it's already been prevalidated to have at least two
		//	components
		//
		const DWORD		cbNetbiosNameNew	= ( wcschr( wszDomainNameNew, L'.' ) - wszDomainNameNew ) * sizeof(WCHAR);

		Call( JetSetColumn(
					sesid,
					tableid,
					columnidNetbiosName,
					wszDomainNameNew,
					cbNetbiosNameNew,
					NO_GRBIT,
					NULL ) );
		Call( JetSetColumn(
					sesid,
					tableid,
					columnidRDN,
					wszDomainNameNew,
					cbNetbiosNameNew,
					NO_GRBIT,
					NULL ) );
		Call( JetSetColumn(
					sesid,
					tableid,
					columnidCommonName,
					wszDomainNameNew,
					cbNetbiosNameNew,
					NO_GRBIT,
					NULL ) );
		(*g_pcprintf)(
			"\n  DNT %d (0x%x), columnid %d: replaced Netbios Name with '%.*S'",
			dwDNT,
			dwDNT,
			columnidNetbiosName,
			cbNetbiosNameNew / sizeof(WCHAR),
			wszDomainNameNew );
		}

	//  now examine all SID-syntax columns and modify the domain portion
	//  of the SID as appropriate
	//
	for ( iretcol = 0; iretcol < cretcol; iretcol++ )
		{
		//  filter out non-SID-syntax columns
		//
		if ( iretcolDNT != iretcol
			&& iretcolObjectClass != iretcol
			&& iretcolSystemFlags != iretcol
			&& rgretcol[iretcol].cbActual > 0 )
			{
			BOOL	fDomainOnly;
			BOOL	fSameDomain;

			//  account for any byte-swapping performed on the persisted data
			//
			InPlaceSwapSID( rgretcol[iretcol].pvData );

			Call( ErrCheckEqualDomainSID(
						(BYTE *)rgretcol[iretcol].pvData,
						pbDomainSIDOld,
						&fDomainOnly,
						&fSameDomain ) );

			if ( fSameDomain )
				{
				//	if domain-only SID, verify length won't change
				//
				Assert( !fDomainOnly
					|| rgretcol[iretcol].cbActual == GetLengthSid( pbDomainSIDNew ) );

				//  replace the domain portion of the SID
				//
				Call( ErrReplaceDomainSID(
							sesid,
							tableid,
							rgretcol[iretcol].columnid,
							0,
							pbDomainSIDNew,
							( fDomainOnly ? NULL : (BYTE *)rgretcol[iretcol].pvData ) ) );

				(*g_pcprintf)(
					"\n  DNT %d (0x%x), columnid %d: replaced %s SID",
					dwDNT,
					dwDNT,
					rgretcol[iretcol].columnid,
					( fDomainOnly ? "Domain-only" : "Account" ) );
				}
			}
		}

	//  actually update the record
	//
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

HandleError:
	return err;
	}


//	"fix up" all the objects in the Datatable
//
JET_ERR ErrMungeDatatable(
	JET_SESID				sesid,
	JET_DBID				dbid,
	const WCHAR *			wszDomainNameOld,
	const WCHAR *			wszDomainNameNew,
	BYTE *					pbDomainSIDOld,
	BYTE *					pbDomainSIDNew,
	const DWORD				dwDNTStart )
	{
	JET_ERR					err;
	JET_TABLEID				tableid;
	JET_COLUMNLIST			columnlist;
	JET_COLUMNDEF			columndef;
	JET_COLUMNID			columnidRDN;
	JET_COLUMNID			columnidCommonName;
	JET_COLUMNID			columnidDomainComponent;
	JET_COLUMNID			columnidDnsRoot;
	JET_COLUMNID			columnidNetbiosName;
	JET_COLUMNID			columnidGUID;
	CHAR					szColumnName[JET_cbNameMost+1];
	DWORD					cbActual;
	const DWORD				iretcolDNT			= 0;
	const DWORD				iretcolObjectClass	= 1;
	const DWORD				iretcolSystemFlags	= 2;
	const DWORD				iretcolSID			= 3;
	const DWORD				cretcolKnown		= 4;	//	DNT, ObjectClass, SystemFlags, ObjectSID
	DWORD					iretcol				= 0;
	DWORD					cretcol				= 0;
	JET_RETRIEVECOLUMN *	rgretcol			= NULL;
	BYTE *					rgbSID				= NULL;
	DWORD					dwPDNT				= ROOTTAG;
	DWORD					dwDNTLast			= 0;
	DWORD					cTotal				= 0;

	Call( JetOpenTable(
				sesid,
				dbid,
				g_szDatatable,
				NULL,
				0,
				JET_bitTableDenyRead|JET_bitTableSequential,
				&tableid ) );

	//	retrieve column information
	//
	Call( JetGetTableColumnInfo( sesid, tableid, NULL, &columnlist, sizeof(columnlist), JET_ColInfoList ) );

	//	initialise with the number of known columns
	//	to be retrieved
	//
	cretcol = cretcolKnown;

	//	determine how many SID-syntax columns there are
	//
	for ( err = JetMove( sesid, columnlist.tableid, JET_MoveFirst, NO_GRBIT );
		JET_errNoCurrentRecord != err;
		err = JetMove( sesid, columnlist.tableid, JET_MoveNext, NO_GRBIT ) )
		{
		//	validate error returned by record navigation
		//
		Call( err );

		//  extract column name
		//
		Call( JetRetrieveColumn(
					sesid,
					columnlist.tableid,
					columnlist.columnidcolumnname,
					szColumnName,
					sizeof(szColumnName),
					&cbActual,
					NO_GRBIT,
					NULL ) );
		szColumnName[cbActual] = 0;

		//  bump the count of columns to be retrieved if
		//  this is a SID-syntax attribute (other than
		//	ObjectSID, which is a known column and has
		//	already been accounted for)
		//
		if ( FIsSIDSyntax( szColumnName )
			&& 0 != lstrcmpi( szColumnName, g_szSIDCol ) )
			{
			cretcol++;
			}
		}


	//	now allocate enough JET_RETRIEVECOLUMN structures and data
	//	retrieval buffers
	//
	rgretcol = (JET_RETRIEVECOLUMN *)LocalAlloc(
										LMEM_ZEROINIT,
										cretcol * ( sizeof(JET_RETRIEVECOLUMN) + g_cbSIDMax ) );
	if ( NULL == rgretcol )
		{
		GotoHandleError( GetLastError() );
		}

	//	buffer for retrieved data follows JET_RETRIEVECOLUMN structures
	//
	rgbSID = (BYTE *)rgretcol + ( cretcol * sizeof(JET_RETRIEVECOLUMN) );

	//  we will not actually be retrieving the RDN
	//  only setting it, so just need the columnid
	//
	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szRDNCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	columnidRDN = columndef.columnid;

	//  we will not actually be retrieving the CommonName
	//  only setting it, so just need the columnid
	//
	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szCommonNameCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	columnidCommonName = columndef.columnid;

	//  we will not actually be retrieving the DomainComponent
	//  only setting it, so just need the columnid
	//
	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szDomainComponentCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	columnidDomainComponent = columndef.columnid;

	//  we will not actually be retrieving the DNSRoot
	//  only setting it, so just need the columnid
	//
	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szDnsRootCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	columnidDnsRoot = columndef.columnid;

	//  we will not actually be retrieving the NetbiosName
	//  only setting it, so just need the columnid
	//
	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szNetbiosNameCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	columnidNetbiosName = columndef.columnid;

	//  we will not actually be retrieving the GUID,
	//  only setting it, so just need the columnid
	//
	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szGUIDCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	columnidGUID = columndef.columnid;

	//  set up a JET_RETRIEVECOLUMN array entry for
	//	the DNT column
	//
	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szDNTCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	rgretcol[iretcolDNT].columnid = columndef.columnid;
	rgretcol[iretcolDNT].pvData = rgbSID;
	rgretcol[iretcolDNT].cbData = g_cbSIDMax;
	rgretcol[iretcolDNT].itagSequence = 1;
	Assert( sizeof(DWORD) < g_cbSIDMax );	//	DNT should fit in retrieval buffer
	rgbSID += g_cbSIDMax;					//	setup for next entry

	//  set up a JET_RETRIEVECOLUMN array entry for
	//	the ObjectClass attribute
	//
	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szObjectClassCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	rgretcol[iretcolObjectClass].columnid = columndef.columnid;
	rgretcol[iretcolObjectClass].pvData = rgbSID;
	rgretcol[iretcolObjectClass].cbData = g_cbSIDMax;
	rgretcol[iretcolObjectClass].itagSequence = 1;		//	only care about CLASS_CROSS_REF, which is always itag 1
	Assert( sizeof(DWORD) < g_cbSIDMax );	//	ObjectClass should fit in retrieval buffer
	rgbSID += g_cbSIDMax;					//	setup for next entry

	//  set up a JET_RETRIEVECOLUMN array entry for
	//	the ObjectClass attribute
	//
	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szSystemFlagsCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	rgretcol[iretcolSystemFlags].columnid = columndef.columnid;
	rgretcol[iretcolSystemFlags].pvData = rgbSID;
	rgretcol[iretcolSystemFlags].cbData = g_cbSIDMax;
	rgretcol[iretcolSystemFlags].itagSequence = 1;
	Assert( sizeof(DWORD) < g_cbSIDMax );	//	SystemFlags should fit in retrieval buffer
	rgbSID += g_cbSIDMax;					//	setup for next entry

	//  set up a JET_RETRIEVECOLUMN array entry for
	//	the ObjectSID attribute
	//
	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szSIDCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	rgretcol[iretcolSID].columnid = columndef.columnid;
	rgretcol[iretcolSID].pvData = rgbSID;
	rgretcol[iretcolSID].cbData = g_cbSIDMax;
	rgretcol[iretcolSID].itagSequence = 1;
	rgbSID += g_cbSIDMax;					//	setup for next entry


	//  now set up a JET_RETRIEVECOLUMN array entry for SID-syntax attribute
	//
	iretcol = cretcolKnown;
	for ( err = JetMove( sesid, columnlist.tableid, JET_MoveFirst, NO_GRBIT );
		JET_errNoCurrentRecord != err;
		err = JetMove( sesid, columnlist.tableid, JET_MoveNext, NO_GRBIT ) )
		{
		//	validate error returned by record navigation
		//
		Call( err );

		//  extract column name
		//
		Call( JetRetrieveColumn(
					sesid,
					columnlist.tableid,
					columnlist.columnidcolumnname,
					szColumnName,
					sizeof(szColumnName),
					&cbActual,
					NO_GRBIT,
					NULL ) );
		szColumnName[cbActual] = 0;


		//	setup a JET_RETRIEVECOLUMN structure for
		//	each SID-syntax attribute (except for
		//	ObjectSID, which is a known column and
		//	has already been accounted for)
		//
		if ( FIsSIDSyntax( szColumnName )
			&& 0 != lstrcmpi( szColumnName, g_szSIDCol ) )
			{
			//	initialize buffer with name of column
			//	(so we can report it below)
			//
			lstrcpyn( (CHAR *)rgbSID, szColumnName, g_cbSIDMax );

			Call( JetRetrieveColumn(
						sesid,
						columnlist.tableid,
						columnlist.columnidcolumnid,
						&rgretcol[iretcol].columnid,
						sizeof(rgretcol[iretcol].columnid),
						NULL,
						NO_GRBIT,
						NULL ) );

			rgretcol[iretcol].pvData = rgbSID;
			rgretcol[iretcol].cbData = g_cbSIDMax;
			rgretcol[iretcol].itagSequence = 1;

			//  set up for next array entry
			//
			iretcol++;
			rgbSID += g_cbSIDMax;
			}
		}

	Assert( iretcol == cretcol );

	(*g_pcprintf)( "\n" );
	(*g_pcprintf)( "  DNT column: '%s' (columnid %d)\n", g_szDNTCol, rgretcol[iretcolDNT].columnid );
	(*g_pcprintf)( "  RDN column: '%s' (columnid %d)\n", g_szRDNCol, columnidRDN );
	(*g_pcprintf)( "  Common-Name column: '%s' (columnid %d)\n", g_szCommonNameCol, columnidCommonName );
	(*g_pcprintf)( "  Object-Class column: '%s' (columnid %d)\n", g_szObjectClassCol, rgretcol[iretcolObjectClass].columnid );
	(*g_pcprintf)( "  System-Flags column: '%s' (columnid %d)\n", g_szSystemFlagsCol, rgretcol[iretcolSystemFlags].columnid );
	(*g_pcprintf)( "  Domain-Component column: '%s' (columnid %d)\n", g_szDomainComponentCol, columnidDomainComponent );
	(*g_pcprintf)( "  DNS-Root column: '%s' (columnid %d)\n", g_szDnsRootCol, columnidDnsRoot );
	(*g_pcprintf)( "  Netbios-Name column: '%s' (columnid %d)\n", g_szNetbiosNameCol, columnidNetbiosName );
	(*g_pcprintf)( "  Object-GUID column: '%s' (columnid %d)\n", g_szGUIDCol, columnidGUID );
	(*g_pcprintf)( "  Object-SID column: '%s' (columnid %d)\n", g_szSIDCol, rgretcol[iretcolSID].columnid );
	(*g_pcprintf)( "  Other SID-syntax columns:" );

	//  report any other SID-syntax columns
	//
	if ( cretcol > cretcolKnown )
		{
		(*g_pcprintf)( "\n" );
		for ( DWORD iretcolT = cretcolKnown; iretcolT < cretcol; iretcolT++ )
			{
			(*g_pcprintf)(
				"        '%s' (columnid %d)\n",
				(CHAR *)rgretcol[iretcolT].pvData,
				rgretcol[iretcolT].columnid );
			}
		}
	else
		{
		(*g_pcprintf)( " <none>\n" );
		}

	//  wrap in a transaction only because LV updates require
	//  a transaction
	//
	Call( JetBeginTransaction( sesid ) );

	//	switch to PDNT+RDN index
	//
	Call( JetSetCurrentIndex( sesid, tableid, g_szPDNTRDNIndex ) );

	(*g_pcprintf)( "Fixing up the domain DN... " );

	Call( ErrMungeDomainDN(
				sesid,
				tableid,
				wszDomainNameOld,
				wszDomainNameNew,
				rgretcol[iretcolDNT].columnid,
				columnidRDN,
				columnidDomainComponent,
				&dwPDNT ) );

	//	switch to primary index
	//
	Call( JetSetCurrentIndex( sesid, tableid, NULL ) );		//	

	(*g_pcprintf)( "\nScanning records of table '%s' beginning at DNT %d (0x%x)... ", g_szDatatable, dwDNTStart, dwDNTStart );

	Call( JetMakeKey( sesid, tableid, &dwDNTStart, sizeof(dwDNTStart), JET_bitNewKey ) );
	for ( err = JetSeek( sesid, tableid, JET_bitSeekGT );
		JET_errNoCurrentRecord != err;
		err = JetMove( sesid, tableid, JET_MoveNext, NO_GRBIT ) )
		{
		//	validate error returned by record navigation
		//
		Call( err );

		//  keep track of how many objects we've visited
		//
		cTotal++;

		//  retrieve relevant data
		//
		Call( JetRetrieveColumns( sesid, tableid, rgretcol, cretcol ) );

		//  update the object
		//
		Call( ErrMungeObject(
					sesid,
					tableid,
					wszDomainNameNew,
					pbDomainSIDOld,
					pbDomainSIDNew,
					iretcolDNT,
					iretcolObjectClass,
					iretcolSystemFlags,
					columnidRDN,
					columnidCommonName,
					columnidDnsRoot,
					columnidNetbiosName,
					columnidGUID,
					rgretcol,
					cretcol ) );

		//	every thousand updates, commit the transaction to
		//	try to prevent running out of version-store
		//	UNDONE: it would be nice if we could instead pass
		//	JET_bitDbVersioningOff to JetAttachDatabase, but
		//	alas, that's currently unsupported
		//
		if ( 0 == cTotal % 1000 )
			{
			Call( JetCommitTransaction( sesid, NO_GRBIT ) );
			Call( JetBeginTransaction( sesid ) );
			}

		//  save off DNT so that in case of future error,
		//  we can report the last successful DNT processed,
		//  which will make problems easier to debug
		//
		dwDNTLast = *(DWORD *)rgretcol[iretcolDNT].pvData;
		}

	//	cleanup
	//
	Call( JetCommitTransaction( sesid, NO_GRBIT ) );
	Call( JetCloseTable( sesid, tableid ) );

	(*g_pcprintf)( "\nTable '%s' successfully processed (%d total entries).", g_szDatatable, cTotal );

	LocalFree( rgretcol );
	return err;

HandleError:
	if ( NULL != rgretcol )
		LocalFree( rgretcol );

	(*g_pcprintf)( "\nLast successful DNT processed was %d (0x%x).", dwDNTLast, dwDNTLast );
	return err;
	}


// compute SD hash
//
__inline VOID ComputeSDHash(
	const BYTE *			pbSD,
	const DWORD				cbSD,
	BYTE *					pbHash,
	const DWORD				cbHash )
	{
    MD5_CTX					md5Ctx;

	//	WARNING: assumes pbHash should point to a 16-byte buffer
	//
    Assert( MD5DIGESTLEN == cbHash );

    MD5Init( &md5Ctx );
    MD5Update( &md5Ctx, pbSD, cbSD );
    MD5Final( &md5Ctx );

    memcpy( pbHash, md5Ctx.digest, MD5DIGESTLEN );
	}


//	"fix up" the SID of an SD
//
JET_ERR ErrMungeSIDOfSD(
	JET_SESID				sesid,
	JET_TABLEID				tableid,
	PSID					pSID,
	BYTE *					pbDomainSIDOld,
	BYTE *					pbDomainSIDNew,
	const DWORD				iretcolSDId,
	const DWORD				iretcolSDValue,
	JET_RETRIEVECOLUMN *	rgretcol,
	const CHAR * const		szUpdateMsg,
	BOOL *					pfRecordUpdated )
	{
	JET_ERR					err					= JET_errSuccess;
	BYTE *					pbSDValue			= (BYTE *)rgretcol[iretcolSDValue].pvData;
	const DWORD				cbSDValue			= rgretcol[iretcolSDValue].cbActual;
	BOOL					fDomainOnly			= FALSE;
	BOOL					fSameDomain			= FALSE;

	if ( NULL != pSID )
		{
		//	ensure SID is somewhere in the SD
		//
		Assert( (BYTE *)pSID > pbSDValue );
		Assert( (BYTE *)pSID + GetLengthSid( pSID ) <= pbSDValue + cbSDValue );

		//	determine if domain SID matches
		//
		Call( ErrCheckEqualDomainSID(
					(BYTE *)pSID,
					pbDomainSIDOld,
					&fDomainOnly,
					&fSameDomain ) );

		if ( fSameDomain )
			{
			//	if domain-only SID, verify length won't change
			//
			Assert( !fDomainOnly
				|| GetLengthSid( pSID ) == GetLengthSid( pbDomainSIDNew ) );

			//  replace the domain portion of the SID
			//
			Call( ErrReplaceDomainSID(
						sesid,
						tableid,
						rgretcol[iretcolSDValue].columnid,
						(BYTE *)pSID - pbSDValue,
						pbDomainSIDNew,
						( fDomainOnly ? NULL : (BYTE *)pSID ) ) );

			(*g_pcprintf)(
				"\n  SD Id %I64d (0x%I64x): replaced %s SID of %s",
				*(DWORD64 *)rgretcol[iretcolSDId].pvData,
				*(DWORD64 *)rgretcol[iretcolSDId].pvData,
				( fDomainOnly ? "Domain-only" : "Account" ),
				szUpdateMsg );

			*pfRecordUpdated = TRUE;
			}
		}

HandleError:
	return err;
	}


//	given an ACE, return the SID portion
//
PSID PSIDFromACE( ACE_HEADER * pACE )
	{
	PSID	pSID		= NULL;

	switch( pACE->AceType )
		{
		case ACCESS_ALLOWED_ACE_TYPE:
		case ACCESS_DENIED_ACE_TYPE:
		case SYSTEM_AUDIT_ACE_TYPE:
		case SYSTEM_ALARM_ACE_TYPE:
			pSID = &( ( (PKNOWN_ACE)pACE )->SidStart );
			break;

		case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
			pSID = &( ( (PKNOWN_COMPOUND_ACE)pACE )->SidStart );
			break;

		case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
		case ACCESS_DENIED_OBJECT_ACE_TYPE:
		case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
		case SYSTEM_ALARM_OBJECT_ACE_TYPE:
			pSID = RtlObjectAceSid( pACE );
			break;

		default:
			Assert( FALSE );
			break;
		}

	return pSID;
	}


//	"fix up" all the SID's of the specified ACL
//
JET_ERR ErrMungeACLOfSD(
	JET_SESID				sesid,
	JET_TABLEID				tableid,
	PACL					pACL,
	BYTE *					pbDomainSIDOld,
	BYTE *					pbDomainSIDNew,
	const DWORD				iretcolSDId,
	const DWORD				iretcolSDValue,
	JET_RETRIEVECOLUMN *	rgretcol,
	const CHAR *			szACL,
	BOOL *					pfRecordUpdated )
	{
	JET_ERR					err					= JET_errSuccess;
	DWORD					iace;
	ACE_HEADER *			pACE;
	CHAR					szUpdateMsg[32];

	if ( NULL != pACL )
		{
		//	ensure ACL is somewhere in the SD
		//
		Assert( (BYTE *)pACL > (BYTE *)rgretcol[iretcolSDValue].pvData );
		Assert( (BYTE *)pACL + pACL->AclSize <= (BYTE *)rgretcol[iretcolSDValue].pvData + rgretcol[iretcolSDValue].cbActual );

		for ( iace = 0; iace < pACL->AceCount; iace++ )
			{
			if ( GetAce( pACL, iace, (VOID **)&pACE ) )
				{
				sprintf( szUpdateMsg, "ACE %d of %s", iace, szACL );
				Call( ErrMungeSIDOfSD(
							sesid,
							tableid,
							PSIDFromACE( pACE ),
							pbDomainSIDOld,
							pbDomainSIDNew,
							iretcolSDId,
							iretcolSDValue,
							rgretcol,
							szUpdateMsg,
							pfRecordUpdated ) );
				}
			else
				{
				GotoHandleError( GetLastError() );
				}
			}
		}

HandleError:
	return err;
	}


//  "fix up" one SD
//
JET_ERR ErrMungeSD(
	JET_SESID				sesid,
	JET_TABLEID				tableid,
	BYTE *					pbDomainSIDOld,
	BYTE *					pbDomainSIDNew,
	const DWORD				iretcolSDId,
	const DWORD				iretcolSDValue,
	const JET_COLUMNID		columnidSDHash,
	JET_RETRIEVECOLUMN *	rgretcol )
	{
	JET_ERR					err;
	BYTE *					pbSDValue			= (BYTE *)rgretcol[iretcolSDValue].pvData;
	const DWORD				cbSDValue			= rgretcol[iretcolSDValue].cbActual;
	PSID					pSID				= NULL;
	PACL					pACL				= NULL;
	BOOL					fRecordUpdated		= FALSE;
	BOOL					fACLPresent;
	BOOL					fUnused;

	//  prepare a copy buffer for the record update
	//
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReplace ) )

	//	inspect the Owner SID of the SD
	//
	if ( GetSecurityDescriptorOwner( pbSDValue, &pSID, &fUnused ) )
		{
		Call( ErrMungeSIDOfSD(
					sesid,
					tableid,
					pSID,
					pbDomainSIDOld,
					pbDomainSIDNew,
					iretcolSDId,
					iretcolSDValue,
					rgretcol,
					g_szSDOwner,
					&fRecordUpdated ) );
		}
	else
		{
		GotoHandleError( GetLastError() );
		}

	//	inspect the Group SID of the SD
	//
	if ( GetSecurityDescriptorGroup( pbSDValue, &pSID, &fUnused ) )
		{
		Call( ErrMungeSIDOfSD(
					sesid,
					tableid,
					pSID,
					pbDomainSIDOld,
					pbDomainSIDNew,
					iretcolSDId,
					iretcolSDValue,
					rgretcol,
					g_szSDGroup,
					&fRecordUpdated ) );
		}
	else
		{
		GotoHandleError( GetLastError() );
		}

	//	inspect the DACL the SD
	//
	if ( GetSecurityDescriptorDacl( pbSDValue, &fACLPresent, &pACL, &fUnused ) )
		{
		if ( fACLPresent )
			{
			Call( ErrMungeACLOfSD(
						sesid,
						tableid,
						pACL,
						pbDomainSIDOld,
						pbDomainSIDNew,
						iretcolSDId,
						iretcolSDValue,
						rgretcol,
						g_szSDDACL,
						&fRecordUpdated ) );
			}
		}
	else
		{
		GotoHandleError( GetLastError() );
		}

	//	inspect the SACL the SD
	//
	if ( GetSecurityDescriptorSacl( pbSDValue, &fACLPresent, &pACL, &fUnused ) )
		{
		if ( fACLPresent )
			{
			Call( ErrMungeACLOfSD(
						sesid,
						tableid,
						pACL,
						pbDomainSIDOld,
						pbDomainSIDNew,
						iretcolSDId,
						iretcolSDValue,
						rgretcol,
						g_szSDSACL,
						&fRecordUpdated ) );
			}
		}
	else
		{
		GotoHandleError( GetLastError() );
		}

	//  actually update the record
	//
	if ( fRecordUpdated )
		{
		BYTE	pbHash[MD5DIGESTLEN];

		//	must recompute SD hash value
		//
		ComputeSDHash(
			pbSDValue,
			cbSDValue,
			pbHash,
			sizeof(pbHash) );

		Call( JetSetColumn(
					sesid,
					tableid,
					columnidSDHash,
					pbHash,
					sizeof(pbHash),
					NO_GRBIT,
					NULL ) );

		//	actually update the record
		//
		Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );
		}
	else
		{
		//	no updates, so just cancel
		//
		Call( JetPrepareUpdate( sesid, tableid, JET_prepCancel ) );
		}

HandleError:
	return err;
	}


//	"fix up" all the SD's in the SD table
//
JET_ERR ErrMungeSDTable(
	JET_SESID			sesid,
	JET_DBID			dbid,
	BYTE *				pbDomainSIDOld,
	BYTE *				pbDomainSIDNew )
	{
	JET_ERR				err;
	JET_TABLEID			tableid;
	JET_COLUMNDEF		columndef;
	JET_COLUMNID		columnidSDHash;
	const DWORD			iretcolSDId		= 0;
	const DWORD			iretcolSDValue	= 1;
	const DWORD			cretcol			= 2;
	JET_RETRIEVECOLUMN	rgretcol[cretcol];
	DWORD64				qwSDId;
	BYTE *				pbSDValueBuffer = NULL;
	const DWORD			cbSDValueMax	= 65536;
	DWORD64				qwSDIdLast		= 0;
	DWORD				cTotal			= 0;

	Call( JetOpenTable(
				sesid,
				dbid,
				g_szSDTable,
				NULL,
				0,
				JET_bitTableDenyRead|JET_bitTableSequential,
				&tableid ) );

	//	retrieve column information and initialise
	//	JET_RETRIEVECOLUMN array
	//
	memset( rgretcol, 0, sizeof(rgretcol) );
	
	pbSDValueBuffer = (BYTE *)LocalAlloc( LMEM_ZEROINIT, cbSDValueMax );
	if ( NULL == pbSDValueBuffer )
		{
		GotoHandleError( GetLastError() );
		}

	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szSDIdCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	rgretcol[iretcolSDId].columnid = columndef.columnid;
	rgretcol[iretcolSDId].pvData = &qwSDId;
	rgretcol[iretcolSDId].cbData = sizeof(qwSDId);
	rgretcol[iretcolSDId].itagSequence = 1;

	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szSDValueCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	rgretcol[iretcolSDValue].columnid = columndef.columnid;
	rgretcol[iretcolSDValue].pvData = pbSDValueBuffer;
	rgretcol[iretcolSDValue].cbData = cbSDValueMax;
	rgretcol[iretcolSDValue].itagSequence = 1;

	Call( JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szSDHashCol,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	columnidSDHash = columndef.columnid;

	(*g_pcprintf)( "\n" );
	(*g_pcprintf)( "  SD Id column: '%s' (columnid %d)\n", g_szSDIdCol, rgretcol[iretcolSDId].columnid );
	(*g_pcprintf)( "  SD Hash column: '%s' (columnid %d)\n", g_szSDHashCol, columnidSDHash );
	(*g_pcprintf)( "  SD Value column: '%s' (columnid %d)", g_szSDValueCol, rgretcol[iretcolSDValue].columnid );

	//  wrap in a transaction only because LV updates require
	//  a transaction
	//
	Call( JetBeginTransaction( sesid ) );

	(*g_pcprintf)( "\nScanning records of table '%s'... ", g_szSDTable );
	err = JetMove( sesid, tableid, JET_MoveFirst, NO_GRBIT );

	//	HACK! HACK! HACK! HACK! HACK!
	//	WARNING: There's a "feature" whereby the first record in the
	//	SD table may have a bogus SD, so must skip this if present
	//
	if ( JET_errSuccess == err )
		{
		Call( JetRetrieveColumns( sesid, tableid, rgretcol, cretcol ) );

		if ( 0x0000000f == *(DWORD *)rgretcol[iretcolSDValue].pvData )
			{
			//	this is a known bogus SD, so skip it
			//
			err = JetMove( sesid, tableid, JET_MoveNext, NO_GRBIT );
			}
		}

	//	begin scan of records in SD table
	//
	while ( JET_errNoCurrentRecord != err )
		{
		//	validate error returned by record positioning
		//
		Call( err );

		//  keep track of how many objects we've visisted
		//
		cTotal++;

		//	retrieve relevant data
		//
		Call( JetRetrieveColumns( sesid, tableid, rgretcol, cretcol ) );

		if ( rgretcol[iretcolSDValue].cbActual > 0 )
			{
			Call( ErrMungeSD(
						sesid,
						tableid,
						pbDomainSIDOld,
						pbDomainSIDNew,
						iretcolSDId,
						iretcolSDValue,
						columnidSDHash,
						rgretcol ) );

			//	every thousand updates, commit the transaction to
			//	try to prevent running out of version-store
			//	UNDONE: may still run out of version store despite
			//	breaking up the transaction -- need to handle it
			//	UNDONE: it would be nice if we could instead pass
			//	JET_bitDbVersioningOff to JetAttachDatabase, but
			//	alas, that's currently unsupported
			//
			if ( 0 == cTotal % 1000 )
				{
				Call( JetCommitTransaction( sesid, NO_GRBIT ) );
				Call( JetBeginTransaction( sesid ) );
				}
			}

		//  save off SDId so that in case of future error,
		//  we can report the last successful SDId processed,
		//  which will make problems easier to debug
		//
		qwSDIdLast = *(DWORD64 *)rgretcol[iretcolSDId].pvData;

		//	move to next record
		//
		err = JetMove( sesid, tableid, JET_MoveNext, NO_GRBIT );
		}

	//	cleanup
	//
	Call( JetCommitTransaction( sesid, NO_GRBIT ) );
	Call( JetCloseTable( sesid, tableid ) );

	(*g_pcprintf)( "\nTable '%s' successfully processed (%d total entries).", g_szSDTable, cTotal );

	LocalFree( pbSDValueBuffer );
	return err;

HandleError:
	if ( NULL != pbSDValueBuffer )
		LocalFree( pbSDValueBuffer );

	(*g_pcprintf)( "\nLast successful SD Id processed was %I64d (0x%I64x).", qwSDIdLast, qwSDIdLast );
	return err;
	}


//	flag the database as having been updated
//
JET_ERR ErrMungeHiddenTable(
	JET_SESID			sesid,
	JET_DBID			dbid )
	{
	JET_ERR				err;
	JET_TABLEID			tableid;
	JET_COLUMNDEF		columndef;
	JET_COLUMNID		columnid;
	BYTE				fSBSUpdate		= TRUE;

	Call( JetOpenTable(
				sesid,
				dbid,
				g_szHiddenTable,
				NULL,
				0,
				JET_bitTableDenyRead,
				&tableid ) );

	Call( JetBeginTransaction( sesid ) );

	memset( &columndef, 0, sizeof(JET_COLUMNDEF) );
	columndef.cbStruct = sizeof(JET_COLUMNDEF);
	columndef.coltyp = JET_coltypBit;
	Call( JetAddColumn(
				sesid,
				tableid,
				g_szSBSUpdateCol,
				&columndef,
				NULL,
				0,
				&columnid ) );

	//	don't actually need to set the column in the record
	//	(the existence of the column in the table is sufficient),
	//	but for completeness, let's set it anyway
	//
	Call( JetMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ) );
	Call( JetPrepareUpdate( sesid, tableid, JET_prepReplace ) );
	Call( JetSetColumn(
				sesid,
				tableid,
				columnid,
				&fSBSUpdate,
				sizeof(fSBSUpdate),
				NO_GRBIT,
				NULL ) );
	Call( JetUpdate( sesid, tableid, NULL, 0, NULL ) );

	(*g_pcprintf)( "\n  Added column '%s' and set to TRUE.", g_szSBSUpdateCol );

	//	cleanup
	//
	Call( JetCommitTransaction( sesid, NO_GRBIT ) );
	Call( JetCloseTable( sesid, tableid ) );

	(*g_pcprintf)( "\nTable '%s' successfully updated.", g_szHiddenTable );

HandleError:
	return err;
	}


JET_ERR ErrSBSMunge(
	const CHAR *	szSourceDb,
	const CHAR *	szDestDb,
	const WCHAR * 	wszDomainNameOld,
	const WCHAR * 	wszDomainNameNew,
	BYTE *			pbDomainSIDOld,
	BYTE *			pbDomainSIDNew,
	const DWORD		dwDNTStart )
	{
	JET_ERR			err;
	JET_SESID		sesid;
	JET_DBID		dbid;
	DWORD			cDomainComponentsOld;
	DWORD			cDomainComponentsNew;
	const DWORD		tickStart			= GetTickCount();

	(*g_pcprintf)( "\nOriginal DNS Domain Name: %S", wszDomainNameOld );
	(*g_pcprintf)( "\n     New DNS Domain Name: %S\n\n", wszDomainNameNew );

	if ( !FValidDnsDomainName( wszDomainNameOld, &cDomainComponentsOld )
		|| !FValidDnsDomainName( wszDomainNameNew, &cDomainComponentsNew )
		|| cDomainComponentsOld != cDomainComponentsNew )
		{
		GotoHandleError( ERROR_INVALID_DOMAINNAME );
		}

	if ( !IsValidSid( pbDomainSIDOld )
		|| !IsValidSid( pbDomainSIDNew )
		|| GetLengthSid( pbDomainSIDOld ) != GetLengthSid( pbDomainSIDNew ) )
		{
		GotoHandleError( ERROR_INVALID_SID );
		}

	(*g_pcprintf)( "Copying '%s' to '%s'... ", szSourceDb, szDestDb );
	if ( !CopyFile( szSourceDb, szDestDb, FALSE ) )
		{
		GotoHandleError( GetLastError() );
		}

	(*g_pcprintf)( "\nInitialising Jet... " );
	Call( JetSetSystemParameter( 0, 0, JET_paramDatabasePageSize, g_cbPage, NULL ) );
	Call( JetSetSystemParameter( 0, 0, JET_paramRecovery, FALSE, "off" ) );
	Call( JetSetSystemParameter( 0, 0, JET_paramEnableIndexChecking, FALSE, NULL ) );
	Call( JetSetSystemParameter( 0, 0, JET_paramEnableTempTableVersioning, FALSE, NULL ) );
	Call( JetSetSystemParameter( 0, 0, JET_paramMaxVerPages, 2048, NULL ) );
	Call( JetInit( 0 ) );
	Call( JetBeginSession( 0, &sesid, NULL, NULL ) );
	Call( JetAttachDatabase( sesid, szDestDb, NO_GRBIT ) );
	Call( JetOpenDatabase( sesid, szDestDb, NULL, &dbid, NO_GRBIT ) );

	//	verify that the database is upgradable
	//
	Call( ErrCheckUpgradable( sesid, dbid ) );

	//	start with the Datatable
	//
	(*g_pcprintf)( "\nOpening table '%s' of database '%s'... ", g_szDatatable, szDestDb );
	Call( ErrMungeDatatable(
				sesid,
				dbid,
				wszDomainNameOld,
				wszDomainNameNew,
				pbDomainSIDOld,
				pbDomainSIDNew,
				dwDNTStart ) );

	//	now do the SD table
	//
	(*g_pcprintf)( "\nOpening table '%s' of database '%s'... ", g_szSDTable, szDestDb );
	Call( ErrMungeSDTable( sesid, dbid, pbDomainSIDOld, pbDomainSIDNew ) );

	//	flag the database as having been updated
	//
	(*g_pcprintf)( "\nOpening table '%s' of database '%s'... ", g_szHiddenTable, szDestDb );
	Call( ErrMungeHiddenTable( sesid, dbid ) );

	//  cleanup
	//
	Call( JetCloseDatabase( sesid, dbid, NO_GRBIT ) );
	Call( JetDetachDatabase( sesid, szDestDb ) );
	Call( JetEndSession( sesid, NO_GRBIT ) );
	Call( JetTerm2( 0, JET_bitTermComplete ) );

	(*g_pcprintf)( "\n\nSuccessfully completed in %d milliseconds.\n", GetTickCount() - tickStart );

	return JET_errSuccess;

HandleError:
	//	try to shut down Jet as best as possible
	//
	(VOID)JetTerm2( 0, JET_bitTermAbrupt );

	(*g_pcprintf)( "\nFailed with error %d (0x%x) at %s@%d after %d milliseconds.\n", g_dwErr, g_dwErr, g_szFileErr, g_dwLineErr, GetTickCount() - tickStart );

	return err;
	}


//  ================================================================
DWORD SBS_OEM_DS_Configuration(
	const CHAR *	szSourceDb,				//	pathed filename to the source database
	const CHAR *	szDestDb,				//	pathed filename to the destination database
	const WCHAR *	wszDnsDomainNameOld,	//	old DNS domain name
	const WCHAR *	wszDnsDomainNameNew,	//	new DNS domain name
	BYTE *			pbDomainSIDOld,			//	old domain SID
	BYTE *			pbDomainSIDNew,			//	new domain SID
	FILE *			pfile )					//	pass NULL to suppress output, otherwise output is directed to specified file (useful for debugging)
//  ================================================================
	{
	CPRINTFNULL		g_cprintfNull;
	CPRINTFFILE		g_cprintfFile( pfile );

	if ( NULL == pfile )
		g_pcprintf = &g_cprintfNull;
	else
		g_pcprintf = &g_cprintfFile;

	return ErrSBSMunge(
				szSourceDb,
				szDestDb,
				wszDnsDomainNameOld,
				wszDnsDomainNameNew,
				pbDomainSIDOld,
				pbDomainSIDNew,
				ROOTTAG + 1 );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\schupgr\schupgr.h ===
#include <winldap.h>
#include <drs.h>
#include <dsconfig.h>

// Message header file
#include "msg.h"

// Maximum characters to search for a token. Should fit in
// the max-length token that we are interested in, currently
// defaultObjectCategory

#define MAX_TOKEN_LENGTH  25

// Max length of a line to be read or written out
#define MAX_BUFFER_SIZE   10000


#define LDIF_STRING  L"sch"
#define LDIF_SUFFIX  L".ldf"

// Logging/Printing options
#define LOG_ONLY 0
#define LOG_AND_PRT 1


// Some internal error codes
#define  UPG_ERROR_CANNOT_OPEN_FILE     1
#define  UPG_ERROR_BAD_CONFIG_DN        2
#define  UPG_ERROR_LINE_READ            3 

// Registry Keys
#define SCHEMADELETEALLOWED "Schema Delete Allowed"
#define SYSTEMONLYALLOWED   "Allow System Only Change"


// Function prototype
void LogMessage(ULONG options, DWORD msgID, WCHAR *pWArg1, WCHAR *pWArg2);
WCHAR *LdapErrToStr(DWORD LdapErr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\schupgr\util.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include "schupgr.h"

extern FILE *logfp;


// Table of Ldap mesages for error to message translation

typedef struct _LdapMsg {
    DWORD  err;
    WCHAR  *msg;
} LdapMsg;

LdapMsg LdapMsgTable[] =
{
   { LDAP_SUCCESS,                     L"Success" },
   { LDAP_OPERATIONS_ERROR,            L"Operations Error" },
   { LDAP_UNAVAILABLE_CRIT_EXTENSION,  L"Unavailable Crit Extension" },
   { LDAP_NO_SUCH_ATTRIBUTE,           L"No Such Attribute" },
   { LDAP_UNDEFINED_TYPE,              L"Undefined Type" },
   { LDAP_CONSTRAINT_VIOLATION,        L"Constraint Violation" },
   { LDAP_ATTRIBUTE_OR_VALUE_EXISTS,   L"Attribute Or Value Exists" },
   { LDAP_INVALID_SYNTAX,              L"Invalid Syntax" }, 
   { LDAP_NO_SUCH_OBJECT,              L"No Such Object" },
   { LDAP_INVALID_DN_SYNTAX,           L"Invalid DN Syntax" },
   { LDAP_INVALID_CREDENTIALS,         L"Invalid Credentials" },
   { LDAP_INSUFFICIENT_RIGHTS,         L"Insufficient Rights" },
   { LDAP_BUSY,                        L"Busy" },
   { LDAP_UNAVAILABLE,                 L"Unavailable" },
   { LDAP_UNWILLING_TO_PERFORM,        L"Unwilling To Perform" },
   { LDAP_NAMING_VIOLATION,            L"Naming Violation" },
   { LDAP_OBJECT_CLASS_VIOLATION,      L"Object Class Violation" },
   { LDAP_NOT_ALLOWED_ON_NONLEAF,      L"Not Allowed on Non-Leaf" },
   { LDAP_NOT_ALLOWED_ON_RDN,          L"Not Allowed On Rdn" },
   { LDAP_ALREADY_EXISTS,              L"Already Exists" },
   { LDAP_NO_OBJECT_CLASS_MODS,        L"No Object Class Mods" },
   { LDAP_OTHER,                       L"Other" },
   { LDAP_SERVER_DOWN,                 L"Server Down" },
   { LDAP_LOCAL_ERROR,                 L"Local error" },
   { LDAP_TIMEOUT,                     L"TimeOut" },
   { LDAP_FILTER_ERROR,                L"Filter Error" },
   { LDAP_CONNECT_ERROR,               L"Connect Error" },
   { LDAP_NO_MEMORY,                   L"No Memory" },
   { LDAP_NOT_SUPPORTED,               L"Not Supported" },
};

ULONG cNumMessages = sizeof(LdapMsgTable)/sizeof(LdapMsgTable[0]);

// Global for message for all other ldap errors (i.e., not in above table)

WCHAR *LdapUnknownErrMsg = L"Unknown Ldap Error";
  

////////////////////////////////////////////////////////////////////
//
// Routine Description:
//     Helper function to print out and log error messages
//     Takes two string arguments. The message is picked up
//     from a message file
//
// Arguments:
//     options: Log only or both log and print
//     msgID: Id of message to print
//     pArg1, pArg2: string arguments for the message string
//
// Return Values:
//    None
//
////////////////////////////////////////////////////////////////////

// Max chars in the message
#define MAX_MSG_SIZE 2000

void 
LogMessage(
    ULONG options, 
    DWORD msgID, 
    WCHAR *pWArg1, 
    WCHAR *pWArg2 
)
{
    WCHAR msgStr[MAX_MSG_SIZE];
    WCHAR *argArray[3];
    ULONG err=0;

    argArray[0] = pWArg1;
    argArray[1] = pWArg2;
    argArray[2] = NULL; // sentinel

    // Format the message
    err = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE | 
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         NULL,
                         msgID,
                         0,
                         msgStr,
                         MAX_MSG_SIZE,
                         (va_list *) &(argArray[0]));
    
    if ( err == 0 ) {
       // Heck, we cannot even format the message, just do a plain printf
       // to say something is wrong
       printf("LogMessage: Couldn't format message with Id %d\n", msgID);
       return;
    }
    

    // print to log  file
    fwprintf(logfp, L"%s", msgStr);
    fflush(logfp);

    if (options & LOG_AND_PRT) {
        // write to screen also
        wprintf(L"%s", msgStr);
    }

    return;
}

    


////////////////////////////////////////////////////////////////////
//
// Routine Decsription:
//       Converts most ldap errors to string messages
//
//
// Arguments:
//        LdapErr - input ldap error value
//
// Return Value:
//        pointer to char string with message
//
////////////////////////////////////////////////////////////////////

WCHAR *LdapErrToStr(DWORD LdapErr)
{
    ULONG i;

    // search the table of Ldap Errors
    
    for (i=0; i<cNumMessages; i++) {
        if (LdapMsgTable[i].err == LdapErr) {
           // found the error. return the pointer to the string
           return (LdapMsgTable[i].msg);
        }
    }

    // didn't find any message. Return the generic "Unknown error"
    return (LdapUnknownErrMsg);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\tapicfg\ilsng.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ilsng.c

Abstract:

    This module contains the install code for the next generation ils
    service, which is a just it's own naming context created in the
    Active Directory, along with a few special service objects.

Author:

    Brett Shirley (BrettSh)

Environment:

    User Mode.

Revision History:

    15-Mar-2000     BrettSh

        Added support for Non-Domain Naming Contexts.

    21-Jul-2000     BrettSh
        
        Moved this file and it's functionality from the ntdsutil
        directory to the new tapicfg utility.  The old source 
        location: \nt\ds\ds\src\util\ntdsutil\ilsng.c.                                    
                                                            
--*/


#include <NTDSpch.h>
#pragma hdrstop

#include <winldap.h>
#include <ntldap.h>
#include <assert.h>
#include <sddl.h>

#ifndef DimensionOf
#define DimensionOf(x) (sizeof(x)/sizeof((x)[0]))
#endif

// The Non-Domain Naming Context (NDNC) routines are in a different file, 
// and a whole different library, for two reasons:
// A) So this file can be ported to the Platform SDK as an example of how to 
//    implement NDNCs programmatically.
// B) So that the utility ntdsutil.exe, could make use of the same routines.
#include <ndnc.h>

#include "ilsng.h"

#include "print.h"

// --------------------------------------------------------------------------
//
// ILSNG/TAPI Directory constants.
//


// This should be probably moved to some much better header file?
#define TAPI_DIRECTORY_GUID L"a57ef962-0367-4a5d-a6a9-a48ea236ea12"

// old ACLs that allowed anonymous user's allowed to create rt-person/conf 
// objects, and anonymous users to view the SCPs.
//#define ILS_DYNAMIC_CONTAINER_SD   L"O:DAG:DAD:(A;;RPCCLC;;;WD)(A;;GA;;;DA)"
//#define TAPI_SERVICE_CONTAINER_SD  L"O:DAG:DAD:(A;;RPLCLORC;;;WD)(A;;GA;;;DA)"
//#define TAPI_SERVICE_OBJECTS_SD    L"O:DAG:DAD:(A;;RPRC;;;WD)(A;;GA;;;DA)"

// Beta 2 - We'll continue to allow anonymous read access, but disallow all
// anonymous write access.  Note the SCP SDs didn't need to change at all.
//#define ILS_DYNAMIC_CONTAINER_SD   L"O:DAG:DAD:(A;;RPCCLC;;;AU)(A;;RPLC;;;WD)(A;;GA;;;DA)"

// Beta 3 - No anonymous read or write access, must always use
// an authenticated user.
#define ILS_DYNAMIC_CONTAINER_SD   L"O:DAG:DAD:(A;;RPCCLC;;;AU)(A;;GA;;;DA)"
#define TAPI_SERVICE_CONTAINER_SD  L"O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;GA;;;DA)"
#define TAPI_SERVICE_OBJECTS_SD    L"O:DAG:DAD:(A;;RPRC;;;AU)(A;;GA;;;DA)"


#define DEFAULT_STR_SD   L"O:DAG:DAD:(A;;GA;;;AU)"

// --------------------------------------------------------------------------
//
// Helper Routines.
//

// These routines are not specific to ILSNG, TAPI Directories, they're just
// darn usefaul

DWORD
CreateOneObject(
    LDAP *           hldDC,
    WCHAR *          wszDN,
    WCHAR *          wszObjectClass,
    WCHAR *          wszStrSD,
    WCHAR **         pwszAttArr
    )
/*++

    
       
EXAMPLE: Calling CreateOneObject() w/ a correctly formated pwszAttArr.
    
    WCHAR *     pwszAttsAndVals[] = {
        // Note first string on each line is type, all other strings up to
        // the NULL are the values fro that type.
        L"ou", L"Dynamic", NULL,
        L"businessCategory", L"Widgets", L"Gizmos", L"Gadgets", NULL,
        NULL } ;
    CreateOneObject(hld, 
                    L"CN=Dynamic,DC=microsoft,DC=com",
                    L"organizationalUnit", 
                    L"O:DAG:DAD:A;;RPWPCRCCDCLCLOLORCWOWDSDDTDTSW;;;DA)(A;;RP;;;AU)
                    pwszAttsAndVals);
                           
--*/
{ 
#define   MemPanicChk(x)   if(x == NULL){ \
                               ulRet = LDAP_NO_MEMORY; \
                               __leave; \
                           }
    ULONG                  ulRet = LDAP_SUCCESS;

    LDAPModW **            paMod = NULL;
    ULONG                  iStr, iAtt, iVal;
    ULONG                  cAtt, cVal;
    // Some special stuff for the Security Descriptor (SD).
    ULONG                  iAttSD;
    LDAP_BERVAL            bervalSD = { 0, NULL };
    PSECURITY_DESCRIPTOR   pSD = NULL;
    ULONG                  cSD = 0;

    assert(hldDC);
    assert(wszDN);
    assert(wszObjectClass);

    __try{

        // First we'll do the optional attributes, because it makes the
        // indexing attributes work out much much better, in the end.
        // First lets count up the number of Attributes
        cAtt = 0;
        iAtt = 0;
        if(pwszAttArr != NULL){
            while(pwszAttArr[iAtt] != NULL){
                
                iAtt++;
                assert(pwszAttArr[iAtt]); // Need at least one value per attr.

                while(pwszAttArr[iAtt] != NULL){
                    // Run through all the attribute and all its values.
                    iAtt++;
                }

                // Finnished a single attribute, goto next attr
                iAtt++;
                cAtt++;
            }
        }


        // Allocate a LDAPMod pointer array for all the attribute elements
        // plus 3 extra, 1 for the NULL terminator, 1 for the objectClass,
        // and one more for the optional SD.
        paMod = (LDAPModW **) LocalAlloc(LMEM_FIXED, sizeof(LDAPModW *)
                                                          * (cAtt + 3));
        MemPanicChk(paMod);
        
        iStr = 0; // This is the index for pwszAttArr[].
        for(iAtt = 0; iAtt < cAtt; iAtt++, iStr++){

            assert(pwszAttArr[iAtt]);
            assert(pwszAttArr[iVal]);


            // Lets allocate a LDAPMod structure for this attribute.
            paMod[iAtt] = (LDAPModW *) LocalAlloc(LMEM_FIXED, sizeof(LDAPModW));
            MemPanicChk(paMod[iAtt]);
            

            // Lets set the LDAPMod structure and allocate a value
            // array for all the values + 1 for the NULL terminator.
            paMod[iAtt]->mod_op = LDAP_MOD_ADD;
            paMod[iAtt]->mod_type = pwszAttArr[iStr];
            // Lets count up the number of values for this one attr
            cVal = 0;
            iStr++; // We want to increment iStr to the first val.
            while(pwszAttArr[iStr + cVal] != NULL){
                cVal++;
            }
            paMod[iAtt]->mod_vals.modv_strvals = (WCHAR **) LocalAlloc(
                                LMEM_FIXED, sizeof(WCHAR *) * (cVal + 1));
            MemPanicChk(paMod[iAtt]->mod_vals.modv_strvals);
                                

            // Now fill in each of the values in the value array.
            for(iVal = 0; iVal < cVal; iVal++, iStr++){
                paMod[iAtt]->mod_vals.modv_strvals[iVal] = pwszAttArr[iStr];
            }
            // We want to NULL terminate the value array.
            paMod[iAtt]->mod_vals.modv_strvals[iVal] = NULL;
            assert(pwszAttArr[iStr] == NULL);
            
            // Last value should be NULL.
            assert(paMod[iAtt]->mod_vals.modv_strvals[cVal] == NULL);
        }

        // Now setup the default attributes, like objectClass and SD.
        // We do objectClass, because it is required, and we do the 
        // SD, b/c it's binary and so it's special.

        // Setup the object class, which is basically the type.
        paMod[iAtt] = (LDAPModW *) LocalAlloc(LMEM_FIXED, sizeof(LDAPModW));
        MemPanicChk(paMod[iAtt]);

        paMod[iAtt]->mod_op = LDAP_MOD_ADD;
        paMod[iAtt]->mod_type = L"objectClass";
        paMod[iAtt]->mod_vals.modv_strvals = (WCHAR **) LocalAlloc(
                                    LMEM_FIXED, sizeof(WCHAR *) * 2);
        MemPanicChk(paMod[iAtt]->mod_vals.modv_strvals);
        paMod[iAtt]->mod_vals.modv_strvals[0] = wszObjectClass;
        paMod[iAtt]->mod_vals.modv_strvals[1] = NULL;
        iAtt++;

        // Setup the optional security descriptor 
        if(wszStrSD != NULL){
            iAttSD = iAtt;
            if(!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                (wszStrSD) ? 
                    wszStrSD :
                    DEFAULT_STR_SD,
                SDDL_REVISION_1,
                &pSD,
                &cSD)){
                ulRet = GetLastError();  // Put this in ulRet, so programmer could g to
                // end of function and see the error code if he wanted.
                assert(!"Programmer supplied invalid SD string to CreateOneObject()\n");
                __leave;
            }
            assert(cSD != 0);

            paMod[iAtt] = (LDAPModW *) LocalAlloc(LMEM_FIXED, sizeof(LDAPModW));
            MemPanicChk(paMod[iAtt]);

            paMod[iAtt]->mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
            paMod[iAtt]->mod_type = L"nTSecurityDescriptor";
            paMod[iAtt]->mod_vals.modv_bvals = (BERVAL **) LocalAlloc(
                                        LMEM_FIXED, sizeof(LDAP_BERVAL *) * 2);
            MemPanicChk(paMod[iAtt]->mod_vals.modv_bvals);
            paMod[iAtt]->mod_vals.modv_bvals[0] = &bervalSD;
            paMod[iAtt]->mod_vals.modv_bvals[0]->bv_len = cSD;
            paMod[iAtt]->mod_vals.modv_bvals[0]->bv_val = (CHAR *) pSD;
            paMod[iAtt]->mod_vals.modv_bvals[1] = NULL;
            iAtt++;
        }
        
        // Need to NULL terminate the LDAPMod array.
        paMod[iAtt] = NULL;

        // Finally ...
        // Adding and object to the DS.
        ulRet = ldap_add_sW(hldDC,
                            wszDN,
                            paMod);

        if (LDAP_SUCCESS != ulRet) {
            // Let the error fall through.
        }
    } __finally {

        // Just checking that the BERVAL and STRVALs are at the same
        // address, lower our de-allocation depends on this assumption.
        assert(paMod[iAtt]->mod_vals.modv_strvals == paMod[iAtt]->mod_vals.modv_bvals);

        if(pSD){
            LocalFree(pSD);
        }
            
        iAtt = 0;
        if(paMod){
            while(paMod[iAtt]){
                if(paMod[iAtt]->mod_vals.modv_strvals){
                    // Note we can do this on the binary SD, because the
                    // LDAPMod structure is a union for modv_strvals and
                    // modv_bvals.
                    LocalFree(paMod[iAtt]->mod_vals.modv_strvals);
                }
                LocalFree(paMod[iAtt]);
                iAtt++;
            }
            LocalFree(paMod);
        }
    }

    return(ulRet);
}


WCHAR * 
CatAndAllocStrsW(
    WCHAR *        wszS1,
    WCHAR *        wszS2
    )
{
    WCHAR *        wszDst;

    wszDst = (WCHAR *) LocalAlloc(LMEM_FIXED, (wcslen(wszS1) + wcslen(wszS2) + 2) * sizeof(WCHAR));
    if(!wszDst){
        // No memory.
        return(NULL);
    }
    wcscpy(wszDst, wszS1);
    wcscat(wszDst, wszS2);

    return(wszDst);
}

ULONG
GetSystemDN(
    IN  LDAP *       hld,
    IN  WCHAR *      wszDomainDn,
    OUT WCHAR **     pwszSystemDn
    )
//
// Returns pwszSystemDn from LocalAlloc
//
{
    ULONG            ulRet = LDAP_SUCCESS;
    WCHAR *          wszRootDomainDn = NULL;

    assert(pwszPartitionsDn);                     

    *pwszSystemDn = NULL;
    
    if(wszDomainDn == NULL){
        ulRet = GetRootAttr(hld,
                            LDAP_OPATT_ROOT_DOMAIN_NAMING_CONTEXT_W,
                            &wszRootDomainDn);
        if(ulRet){
            return(ulRet);
        }
        // This is the default if no domain is supplied.
        wszDomainDn = wszRootDomainDn;
    }

    // This routine allocates using LocalAlloc, which is what we need
    if(GetWellKnownObject(hld,
                          wszDomainDn,
                          GUID_SYSTEMS_CONTAINER_W,
                          pwszSystemDn)){
        // Signal error.
        if(wszRootDomainDn) { LocalFree(wszRootDomainDn); }
        return(LDAP_NO_SUCH_ATTRIBUTE);
    }

    if(wszRootDomainDn != NULL){ LocalFree(wszRootDomainDn); }

    return(ulRet);
}

WCHAR * 
SuperCatAndAllocStrsW(
    IN      WCHAR **        pawszStrings
    )
{
    ULONG          cStrLen = 0;
    ULONG          iStr = 0;
    WCHAR *        wszRes;

    assert(pawszStrings);
    assert(pawszStrings[0]); // Whats the point.


    // Count all the strings.
    while(pawszStrings[iStr] != NULL){
        cStrLen += wcslen(pawszStrings[iStr]);
        iStr++;
    }
    cStrLen += 1; // We want a NULL char don't we! ;)
    cStrLen *= sizeof(WCHAR); // We want it in WCHARs too.

    wszRes = (WCHAR *) LocalAlloc(LMEM_FIXED, cStrLen);
    if(!wszRes){
        return(NULL);
    }

    wcscpy(wszRes, pawszStrings[0]);

    iStr = 1;
    while(pawszStrings[iStr] != NULL){
        wcscat(wszRes, pawszStrings[iStr]);
        iStr++;
    }

    return(wszRes);
}

DWORD
GetDnFromDns(
    IN      WCHAR *       wszDns,
    OUT     WCHAR **      pwszDn
    )
{
    DWORD         dwRet = ERROR_SUCCESS;
    WCHAR *       wszFinalDns = NULL;
    DS_NAME_RESULTW *  pdsNameRes = NULL;

    assert(wszDns);
    assert(pwszDn);

    *pwszDn = NULL;

    __try{ 
        wszFinalDns = (WCHAR *) LocalAlloc(LMEM_FIXED, 
                                  (wcslen(wszDns) + 3) * sizeof(WCHAR));
        if(wszFinalDns == NULL){
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }
        wcscpy(wszFinalDns, wszDns);
        wcscat(wszFinalDns, L"/");

        // the wszILSDN parameter.  DsCrackNames to the rescue.
        dwRet = DsCrackNamesW(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY,
                              DS_CANONICAL_NAME,
                              DS_FQDN_1779_NAME, 
                              1, &wszFinalDns, &pdsNameRes);
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }
        if((pdsNameRes == NULL) ||
           (pdsNameRes->cItems < 1) ||
           (pdsNameRes->rItems == NULL)){
            dwRet = ERROR_INVALID_PARAMETER;
            __leave;
        }
        if(pdsNameRes->rItems[0].status != DS_NAME_NO_ERROR){
            dwRet = pdsNameRes->rItems[0].status;
            __leave;
        }
        if(pdsNameRes->rItems[0].pName == NULL){
            dwRet = ERROR_INVALID_PARAMETER;
            assert(!"Wait how can this happen?\n");
            __leave;
        }
        // The parameter that we want is
        //    pdsNameRes->rItems[0].pName

        *pwszDn = (WCHAR *) LocalAlloc(LMEM_FIXED, 
                             (wcslen(pdsNameRes->rItems[0].pName) + 1) * 
                             sizeof(WCHAR));
        if(*pwszDn == NULL){
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        wcscpy(*pwszDn, pdsNameRes->rItems[0].pName);

    } __finally {
        if(wszFinalDns) { LocalFree(wszFinalDns); }
        if(pdsNameRes) { DsFreeNameResultW(pdsNameRes); }
    }

    return(dwRet);
}

void
PrintLdapErrMsg(
    IN      ULONG           ulMsg,
    IN      LPWSTR          szFunc,
    IN      LDAP *          hLdap,
    IN      ULONG           dwLdapErr
    )
/*++

Routine Description:

    This routine prints out a generic LDAP error with all the extended
    information.

Arguments:

    ulMsg - only TAPICFG_GENERIC_LDAP_ERROR_FUNC supports the format currently
        but other message formats could be made to work.
    szFunc - the string of the failing LDAP function
    hLdap - LDAP Handle in a state right after the last (szFunc) operation
        failed.
    dwLdapErr - LDAP error returned.

--*/
{
    WCHAR *   szLdapErr = NULL;
    DWORD     dwWin32Err = 0;
    WCHAR *   szWin32Err = NULL;
    WCHAR *   szExtendedErr = NULL;

    GetLdapErrorMessages(hLdap, dwLdapErr,
                         &szLdapErr, &dwWin32Err, &szWin32Err, &szExtendedErr);

    PrintMsg(ulMsg, szFunc, 
             dwLdapErr, szLdapErr, dwWin32Err, szWin32Err, szExtendedErr);

    FreeLdapErrorMessages(szWin32Err, szExtendedErr);

}

// --------------------------------------------------------------------------
//
// Main Helper Routines.
//

// Each of these functions, implements a major component of the ILS install
// or uninstall routines.  They are sort of helper functions, but they could 
// also be exposed as seperate functions in ntdsutil.exe if we wanted.

DWORD
ILSNG_CheckParameters(
    IN      WCHAR *        wszIlsHeadDn
    )
{
    // Then check that this parameter looks something like a DC type DN.

    if(!CheckDnsDn(wszIlsHeadDn)){
        PrintMsg(TAPICFG_BAD_DN, wszIlsHeadDn);
        return(ERROR_INVALID_PARAMETER);
    }                                   
    
    return(ERROR_SUCCESS);
}

DWORD
GetMsTapiContainerDn(
    IN      LDAP *       hld,
    IN      WCHAR *      wszDomainDn,
    IN      WCHAR **     pwszMsTapiContainerDn
    )
/*++

Routine Description:

    This gets the MS TAPI Service Connection Points (SCPs)
    container DN.

Arguments:

    hld (IN) - And LDAP binding handle.
    wszDomainDn (IN) - The domain to find the MS TAPI SCP 
        Containter in.
    pwszMsTapiContainerDn (OUT) - The result.

Return value:

    ldap error code.

--*/
{
    DWORD                dwRet;
    WCHAR *              wszSysDn = NULL;
    
    assert(pwszMsTapiContainerDn);
    
    *pwszMsTapiContainerDn = NULL;

    // ----------------------------------------
    // Get System DN.
    dwRet = GetSystemDN(hld, wszDomainDn, &wszSysDn);
    if(dwRet != ERROR_SUCCESS){
        return(dwRet);
    }

    // ----------------------------------------
    // Append the Microsoft TAPI container name.
    *pwszMsTapiContainerDn = CatAndAllocStrsW(L"CN=MicrosoftTAPI,", wszSysDn);
    if(*pwszMsTapiContainerDn == NULL){
        LocalFree(wszSysDn);
        return(LDAP_NO_MEMORY);
    }

    LocalFree(wszSysDn);
    return(LDAP_SUCCESS);
}

DWORD
FindExistingServiceObjOne(
    IN      WCHAR *        wszScpObjDn,
    IN      WCHAR *        wszTapiDirDns,
    IN      BOOL           fIsDefaultScp,
    IN      BOOL           fIsDefaultTapiDir,
    IN      PVOID          pArgs
    )
/*++

Routine Description:

    This is the helper function for ILSNG_FindExistingServiceObj(),
    this function is handed to the iterator ILSNG_EnumerateSCPs() to
    be called on to process each SCP.
              
Arguments:

    OTHER ARGS - See ILSNG_EnumerateSCPs.                                                             
    pArgs (IN) - This is the DNS name that we're looking for.

Return value:

    TRUE if a SCP matches DNS Names with the target (pArg), FALSE
    otherwise.

--*/
{
    if(wszScpObjDn == NULL){
        return(FALSE);
    }

    if(!fIsDefaultScp &&
       _wcsicmp(wszTapiDirDns, (WCHAR *) pArgs) == 0){
        return(TRUE);
    }

    return(FALSE);
}

BOOL
ILSNG_FindExistingServiceObj(
    IN      LDAP *         hldDC,
    IN      WCHAR *        wszRootDn,
    IN      WCHAR *        wszDnsName
    )
/*++

    Description:

        The goal of this function is to find any GUID Based ILSNG 
        service publication objects for an existing DNS name so we 
        don't recreate them in ILSNG_RegisterServiceObjects()
    
--*/
{

    DWORD            fRet = FALSE;
    DWORD            dwRet;
    
    // NOTE: would be more efficient to actually pass in an additional
    // filter of L"(serverDNSName=<wszDnsName>), like the
    // ILSNG_UnRegisterServiceObjects() function.  Oh well, this
    // stresses the Enumerate function in different ways, so that is
    // good.  No one will probably ever have more than a few SCPs in
    // a single domain.

    dwRet = ILSNG_EnumerateSCPs(hldDC, wszRootDn, NULL,
                                // This is the iterator function params.
                                &fRet, 
                                FindExistingServiceObjOne, 
                                (PVOID) wszDnsName);

    return(fRet);
}


DWORD
ILSNG_RegisterServiceObjects(
    IN      LDAP *         hldDC,
    IN      WCHAR *        wszILSDN,
    IN      WCHAR *        wszRegisterDomainDn,
    IN      BOOL           fForceDefault,
    IN      BOOL           fDefaultOnly
    )
{
    // Microsoft TAPI Container Obect.
    WCHAR *        wszMsTapiContainerDN = NULL;

    // Microsoft TAPI Default ILS Service object.
    WCHAR *        wszDefTapiIlsDN = NULL;
    WCHAR *        pwszDefTapiIlsAttr [] = { 
        // 1st Null is a place holder for DNS service name.
        L"serviceDNSName", NULL, NULL,
        L"serviceDNSNameType", L"SRV", NULL,
        NULL };
    WCHAR *        pwszModifyVals [2];
    LDAPModW       ModifyDefTapiIls;
    LDAPModW *     pMods[2];



    // ILS Instance Service object.
    WCHAR *        wszIlsInstanceDN = NULL;
    WCHAR *        pwszStringList[6]; // Used to constructe wszIlsInstanceDN
    WCHAR *        pwszIlsInstanceAttr [] = { 
        // 1st Null is a place holder for DNS service name.
        L"serviceDNSName", NULL, NULL, 
        L"serviceDNSNameType", L"SRV", NULL,
        L"keywords", TAPI_DIRECTORY_GUID, L"Microsoft", L"TAPI", L"ILS", NULL,
        NULL };
    
    GUID           ServiceGuid = { 0, 0, 0, 0 };
    WCHAR *        wszServiceGuid = NULL;
    DS_NAME_RESULTW *  pdsNameRes = NULL;
    DWORD          dwRet = LDAP_SUCCESS;
    WCHAR *        wszSysDN = NULL;
    
    __try {

        // Note for a couple of the ATTRs above we need the DNS name for
        // the wszILSDN parameter.  DsCrackNames to the rescue.
        dwRet = DsCrackNamesW(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY,
                              DS_FQDN_1779_NAME, DS_CANONICAL_NAME,
                              1, &wszILSDN, &pdsNameRes);
        if((dwRet != ERROR_SUCCESS) ||
           (pdsNameRes == NULL) ||
           (pdsNameRes->cItems < 1) ||
           (pdsNameRes->rItems == NULL) ||
           (pdsNameRes->rItems[0].status != DS_NAME_NO_ERROR)){
            dwRet = LDAP_NAMING_VIOLATION;
            __leave;
        }
        // The parameter that we use later in the code is
        //    pdsNameRes->rItems[0].pDomain


        // -----------------------------------------------------------------
        //
        // Create the CN=MicrosoftTAPI container
        //
        //
        
        dwRet = GetMsTapiContainerDn(hldDC, wszRegisterDomainDn, 
                                     &wszMsTapiContainerDN);
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }

        // ----------------------------------------
        // Actually create the object.
        if(dwRet = CreateOneObject(hldDC,
                                   wszMsTapiContainerDN,
                                   L"Container",
                                   TAPI_SERVICE_CONTAINER_SD,
                                   NULL)){
            if(dwRet == LDAP_ALREADY_EXISTS){
                dwRet = LDAP_SUCCESS; 
                // This is OK, continue on ...
            } else {
                // Any other error is considered fatal, so leave ...
                __leave;
            }
        }
        
        // -----------------------------------------------------------------
        //
        // Create the GUID based serviceConnectionPoint object
        //
        //
        
        // First check if one already exists.
        if(!fDefaultOnly &&
           !ILSNG_FindExistingServiceObj(hldDC,
                                         wszMsTapiContainerDN,
                                         pdsNameRes->rItems[0].pDomain)){
            // OK, so we couldn't find another service publication object
            // for this DNS name, so we'll create one.  This is the usual
            // case.  However, if someone is trying to restore the Default
            // TAPI Directory to an old DNS name this isn't the case.
        
            // Note from above ATTRs we have to fill in the serviceDNSName.
            // attributes for the pwszIlsInstanceAttr variable.
            pwszIlsInstanceAttr[1] = pdsNameRes->rItems[0].pDomain;

            // ----------------------------------------
            // Step 1: Need Guid.
            dwRet = UuidCreate(&ServiceGuid);
            if(dwRet != RPC_S_OK){
                return(dwRet);
            }

            // Step 2: Convert GUID to String.
            dwRet = UuidToStringW(&ServiceGuid, &wszServiceGuid);
            if(dwRet != RPC_S_OK){
                return(dwRet);
            }
            assert(wszServiceGuid);

            // Step 3: Put it all together.
            pwszStringList[0] = L"CN=";
            pwszStringList[1] = wszServiceGuid;
            pwszStringList[2] = L",";
            pwszStringList[3] = wszMsTapiContainerDN;
            pwszStringList[4] = NULL;
            wszIlsInstanceDN = SuperCatAndAllocStrsW(pwszStringList);
            if(wszIlsInstanceDN == NULL){
                dwRet = LDAP_NO_MEMORY;
                __leave;
            }
            RpcStringFreeW(&wszServiceGuid);
            wszServiceGuid = NULL;

            // Create the ILS Service Object.
            if(dwRet = CreateOneObject(hldDC,
                                       wszIlsInstanceDN,
                                       L"serviceConnectionPoint",
                                       TAPI_SERVICE_OBJECTS_SD,
                                       pwszIlsInstanceAttr)){
                if(dwRet != LDAP_ALREADY_EXISTS){
                    __leave;
                }
            }
        }
           
        // -----------------------------------------------------------------
        //
        // Create the CN=DefaultTAPIDirectory serviceConnectionPoint object.
        //
        //
        
        // Note from above ATTRs we have to fill in the serviceDNSName.
        // attributes for the pwszDefTAPIDirAttr variable.
        pwszDefTapiIlsAttr[1] = pdsNameRes->rItems[0].pDomain;
        
        // Create the DN for the DefaultTAPIDirectory
        wszDefTapiIlsDN = CatAndAllocStrsW(L"CN=DefaultTAPIDirectory,",
                                           wszMsTapiContainerDN);
        if(wszDefTapiIlsDN == NULL){
            return(LDAP_NO_MEMORY);
        }

        // ----------------------------------------
        // NOW Actually get around to creating the service objects
        if(dwRet = CreateOneObject(hldDC,
                                   wszDefTapiIlsDN,
                                   L"serviceConnectionPoint",
                                   TAPI_SERVICE_OBJECTS_SD,
                                   pwszDefTapiIlsAttr)){
            if(dwRet != LDAP_ALREADY_EXISTS){
                dwRet = LDAP_SUCCESS; // OH Well, continue on.
            } else {
                // OK, it already exists, so if we are supposed
                // to force the default to this NDNC, then do so.
                if(fForceDefault){
                    // Constructe Modify Args.

                    ModifyDefTapiIls.mod_op = LDAP_MOD_REPLACE;
                    ModifyDefTapiIls.mod_type = L"serviceDNSName";
                    pwszModifyVals[0] = pwszDefTapiIlsAttr[1];
                    pwszModifyVals[1] = NULL;
                    ModifyDefTapiIls.mod_vals.modv_strvals = pwszModifyVals;
                    pMods[0] = &ModifyDefTapiIls;
                    pMods[1] = NULL;
                    
                    dwRet = ldap_modify_sW(hldDC,
                                           wszDefTapiIlsDN,
                                           pMods);

                    if(dwRet != ERROR_SUCCESS){
                        // This time it is fatal.
                        __leave;
                    }
                } else {
                    dwRet = LDAP_SUCCESS; // OH Well, continue on.
                }
            }
        }

    } __finally {

        if(wszSysDN) { LocalFree(wszSysDN); }
        if(wszMsTapiContainerDN) { LocalFree(wszMsTapiContainerDN); }
        if(wszDefTapiIlsDN) { LocalFree(wszDefTapiIlsDN); }
        if(wszIlsInstanceDN) { LocalFree(wszIlsInstanceDN); }
        if(wszServiceGuid){ RpcStringFreeW(&wszServiceGuid); }
        if(pdsNameRes) { DsFreeNameResultW(pdsNameRes); }

    }

    return(dwRet);
}

DWORD
UnRegisterServiceObjectsOne(
    IN      WCHAR *        wszScpObjDn,
    IN      WCHAR *        wszTapiDirDns,
    IN      BOOL           fIsDefaultScp,
    IN      BOOL           fIsDefaultTapiDir,
    IN      PVOID          hld
    )
{
    DWORD                  dwRet;

    if(wszScpObjDn == NULL){
        return(FALSE);
    }

    dwRet = ldap_delete_sW((LDAP *) hld, wszScpObjDn);
    
    return(dwRet);
}

DWORD
ILSNG_UnRegisterServiceObjects(
    IN      LDAP *         hldDC,
    IN      WCHAR *        wszILSDN,
    IN      WCHAR *        wszRegisterDomainDn
    )
{
    DS_NAME_RESULTW *     pdsNameRes = NULL;
    DWORD                 dwRet;
    DWORD                 dwFuncErr  = LDAP_SUCCESS;
    WCHAR *               wszFilter = NULL;
    WCHAR *               wszFilterBegin = L"(serviceDNSName=";
    WCHAR *               wszFilterEnd = L")";
    WCHAR *               wszMsTapiContainerDn = NULL;

    __try {

        // Construct Root DN.
        // ----------------------------------------
        // Get the CN=MicrosoftTAPI container DN.
        
        dwRet = GetMsTapiContainerDn(hldDC, wszRegisterDomainDn, 
                                     &wszMsTapiContainerDn);
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }
        assert(wszMsTapiContainerDn);

        // Construct filter.
        // ----------------------------------------
        // Note from above ATTRs we have to fill in the serviceDNSName.
        // attributes for the pwszILSAttr and pwszDefTAPIDirAttr variables.
        // Resolve the DNS Service Name.
        dwRet = DsCrackNamesW(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY,
                              DS_FQDN_1779_NAME, DS_CANONICAL_NAME,
                              1, &wszILSDN, &pdsNameRes);
        if((dwRet != ERROR_SUCCESS) ||
           (pdsNameRes == NULL) ||
           (pdsNameRes->cItems < 1) ||
           (pdsNameRes->rItems == NULL) ||
           (pdsNameRes->rItems[0].status != DS_NAME_NO_ERROR)){
            dwRet = LDAP_NAMING_VIOLATION;
            assert(!"It's OK to assert here, because wszILSDN was gotten from cracknames in the first place!");
            __leave;
        }
        
        wszFilter = (WCHAR *) LocalAlloc(LMEM_FIXED, 
                               sizeof(WCHAR) *
                               (wcslen(pdsNameRes->rItems[0].pDomain) +
                                wcslen(wszFilterBegin) + 
                                wcslen(wszFilterEnd) + 3));
        if(!wszFilter){
            dwRet = LDAP_NO_MEMORY;
            __leave;
        }
        
        wcscpy(wszFilter, wszFilterBegin);
        wcscat(wszFilter, pdsNameRes->rItems[0].pDomain);
        wcscat(wszFilter, wszFilterEnd);

        // Iterate SCPs.
        // ----------------------------------------
        // The fucntion ILSNG_EnumerateSCPs, iterates through
        // the SCPs, calling UnRegisterServiceObjectsOne() on
        // each SCP, which then deletes the SCP.

        dwRet = ILSNG_EnumerateSCPs(hldDC, wszMsTapiContainerDn, wszFilter,
                                    // This is the iterator function params.
                                    &dwFuncErr, 
                                    UnRegisterServiceObjectsOne, 
                                    (PVOID) hldDC);

    } __finally {

        if(pdsNameRes) { DsFreeNameResultW(pdsNameRes); }
        if(wszMsTapiContainerDn) { LocalFree(wszMsTapiContainerDn); }
        if(wszFilter) { LocalFree(wszFilter); }

    }

    if(dwRet){
        return(dwRet);
    } 
    
    return(dwFuncErr);

}

DWORD
ILSNG_CreateRootTree(
    IN      LDAP *         hldDC,
    IN      WCHAR *        wszILSDN
    )
{
    DWORD          dwRet;
    WCHAR *        wszDynDN;

    // Create the dynamic ou.
    wszDynDN = CatAndAllocStrsW(L"OU=Dynamic,", wszILSDN);
    if(wszDynDN == NULL){
        return(LDAP_NO_MEMORY);
    }

    dwRet = CreateOneObject(hldDC,
                            wszDynDN,
                            L"organizationalUnit",
                            ILS_DYNAMIC_CONTAINER_SD,
                            NULL);

    LocalFree(wszDynDN);
    
    return(dwRet);
}

ULONG
GetILSNGDC(
    IN      LDAP *       hld,
    IN      WCHAR *      wszTapiDirDns,
    OUT     WCHAR **     pwszInstantiatedDc
    )
{
    ULONG                ulRet;
    WCHAR *              wszTapiDirDn = NULL;
    WCHAR *              pwszAttrFilter[2];
    LDAPMessage *        pldmResults = NULL;
    LDAPMessage *        pldmEntry = NULL;
    WCHAR **             pwszTempAttrs = NULL;
    void *               fOriginalReferrals;
    
    assert(pwszInstantiatedDc);
    *pwszInstantiatedDc = NULL;

    // First get the DN of the TAPI Directory
    ulRet = GetDnFromDns(wszTapiDirDns, &wszTapiDirDn);
    if(ulRet){
        // Since we're returning LDAP errors, this is
        // closest to an Naming Violation.
        ulRet = LDAP_NAMING_VIOLATION;
        return(ulRet);
    }

    __try {

        // Save the original referrals option.
        ulRet = ldap_get_optionW(hld, LDAP_OPT_REFERRALS, &fOriginalReferrals);
        if(ulRet != LDAP_SUCCESS){
            __leave;
        }

        ulRet = ldap_set_optionW(hld, LDAP_OPT_REFERRALS, (void *) TRUE);
        if (ulRet != LDAP_SUCCESS) {
            __leave;
        }

        // Get the msDS-MasteredBy attribute of the NC head object.
        pwszAttrFilter[0] = L"msDS-MasteredBy";
        pwszAttrFilter[1] = NULL;
        ulRet = ldap_search_sW(hld,
                               wszTapiDirDn,
                               LDAP_SCOPE_BASE,
                               L"(objectCategory=*)",
                               pwszAttrFilter,
                               0,
                               &pldmResults);
        if(ulRet != LDAP_SUCCESS){
            __leave;
        }

        pldmEntry = ldap_first_entry(hld, pldmResults);
        if(pldmEntry == NULL){
            ulRet = ldap_result2error(hld, pldmResults, FALSE);
            assert(ulRet);
            __leave;
        }

        pwszTempAttrs = ldap_get_valuesW(hld, pldmEntry, pwszAttrFilter[0]);
        if(pwszTempAttrs == NULL || pwszTempAttrs[0] == NULL){
            ulRet = LDAP_NO_RESULTS_RETURNED;
            __leave;
        }

        // pwszTempAttrs[0] is the ntdsa DN for the server hosting this NC.

        ulRet = GetServerDnsFromServerNtdsaDn(hld, 
                                              pwszTempAttrs[0],
                                              pwszInstantiatedDc);
        // ulRet will just get returned.
        // wszInstantiatedDc is LocalAlloc()'d if the function was successful.
    } __finally {
        if(wszTapiDirDn) { LocalFree(wszTapiDirDn); }
        if(pldmResults != NULL) { ldap_msgfree(pldmResults); }
        if(pwszTempAttrs) { ldap_value_freeW(pwszTempAttrs); }
        ldap_set_optionW(hld, LDAP_OPT_REFERRALS, (void *) fOriginalReferrals);
    }

    return(ulRet);
}

DWORD
ILSNG_EnumerateSCPs(
    // This is the parameters for the function.
    IN      LDAP *       hld,
    IN      WCHAR *      wszRootDn,
    IN      WCHAR *      wszExtendedFilter,
    // These are parameters for the virtual iterator function.
    OUT     DWORD *      pdwRet,           // Return Value
    IN      DWORD (__stdcall * pFunc) (),  // Function
    IN OUT  PVOID        pArgs             // Argument
    )
/*++

Routine Description:

    This is a complicated function, but _extremely useful function, that 
    basically iterates through all the service connection points (SCPs)
    in the container wszRootDn, and calls the virtual function pFunc for
    each SCP.

Arguments:

    hld (IN) - A connected ldap handle
    wszRootDn (IN) - The base of the SCP container, containing the
        various GUID based SCPs, and the single default SCP.
    wszExtendedFilter (IN) - An extra filter, so the search for
        SCPs can be narrowed down appropriately.  This will limit
        the iteration routine to only those SCPs that also match
        this filter, and the default SCP is always called.
    pdwRet (OUT) - This is a pointer to a return value for the pFunc 
        function.  The caller must allocate this DWORD, or pass NULL.
    pFunc (IN) - This is the function to be called on each SCP.
    pArgs (IN/OUT) - This is the argument passed through this function
        to pFunc.  This can be used in any way pFunc wants to, it's
        just passed through this function with no assumptions.

Return value:

    ldap error code - Note that this is the error code for trying
    to get the SCP object, and this could be success, while the
    pdwRet is and ERROR, or vice versa.
    
Comments:    

    The arguments for this function are seperated into two sets, set one
    (the first 3 arguments) control how this routine (the iterating routine)
    behaves, what computer it searched, what container it searches, and
    what special parameters it's looking for in the SCPs to be returned
    to the SCP processing function.  The second set (the last 3 arguments)
    of arguments are related to the SCP processing function.  The fourth
    argument is a pointer to a DWORD for a return value, the fifth argument
    is the processing function itself, and the final argument is the argument
    to pass to the SCP processing function.
    
    The SCP processing function must follow this general form:
        DWORD
        pFunc(
            IN      WCHAR *        wszScpObjDn,
            IN      WCHAR *        wszTapiDirDns,
            IN      BOOL           fIsDefaultScp,
            IN      BOOL           fIsDefaultTapiDir,
            IN OUT  PVOID          pArgs
        )        
            wszScpObjDn (IN) - This is the DN of the SCP object found.
                This parameter is always filled in, except on the last
                call to pFunc this parameter is NULL, signifying the
                end of all the SCPs.
            wszTapiDirDns (IN) - This is the DNS string for the given
                SCP object.
            fIsDefaultScp (IN) - This tells you if the object returned
                is the default SCP object, there is only one of these
                and if it exists, it will be returned on the first call
                to pFunc.  Generally, this is TRUE for one call to pFunc
                for a given set of SCPs.
            fIsDefaultTapiDir (IN) - This tells you if this is a SCP
                object with the same DNS name as the DNS name for the
                default SCP object.  Generally, this will be TRUE for
                two calls to pFunc for a given set of SCPs.
            pArgs (IN/OUT) - This is the argument that pFunc can use
                however it wishes.
                
    The algorithm for pFunc being called looks like this:
        If( Default SCP exists){
            pdwRet = pFunc( x, x, TRUE, TRUE, x);
        }
        while ( pSCP = GetAnotherGUIDBasedSCP() ){
            pdwRet = pFunc( x, x, FALSE, [TRUE|FALSE], x);
        }
        pdwRet = pFunc(NULL, NULL, FALSE, FALSE, x);
    However if pFunc ever returns a non-zero result, then pFunc will
    no longer be called.
                 
--*/
{

    DWORD            dwRet;
    DWORD            dwFuncRet;
                 
    WCHAR *          wszDefTapiIlsDn = NULL;

    WCHAR *          pwszAttrFilter[] = { L"serviceDNSName", NULL };
    LDAPMessage *    pldmResults = NULL;
    LDAPMessage *    pldmEntry = NULL;
    WCHAR *          wszTempDn = NULL;
    ULONG            cwcFilter = 0; // Count in chars of filter.
    WCHAR *          wszFilter = NULL;
    WCHAR *          wszFilterBegin = 
          L"(&(objectClass=serviceConnectionPoint)(keywords=";
    WCHAR *          wszFilterEnd = L")";
    BOOL             fIsDefault = FALSE;
    WCHAR **         pwszDnsName = NULL;
    WCHAR **         pwszDefaultDnsName = NULL;
    WCHAR *          wszDefaultDnsName = NULL;
    
    __try {

        // We need this, because we could (though very very unlikely, as
        // the tools are not setup to do this, have a scenario where the
        // CN=DefaultTAPIDirectory object has the dns name, but no regular
        // service publication object exists, so we need to make sure that 
        // this object isn't the default TAPI dir object.
        wszDefTapiIlsDn = CatAndAllocStrsW(L"CN=DefaultTAPIDirectory,",
                                           wszRootDn);
        if(wszDefTapiIlsDn == NULL){
            dwRet = LDAP_NO_MEMORY;
            __leave;
        }

        // Construct filter.
        // ----------------------------------------
        // Note from above ATTRs we have to fill in the serviceDNSName.
        // attributes for the pwszILSAttr and pwszDefTAPIDirAttr variables.
        // Resolve the DNS Service Name.
        
        cwcFilter = wcslen(wszFilterBegin) + wcslen(TAPI_DIRECTORY_GUID) +
            wcslen(wszFilterEnd) + wcslen(wszFilterEnd);
        if(wszExtendedFilter){
            cwcFilter += wcslen(wszExtendedFilter);
        }
        cwcFilter++; // For NULL termination.
        wszFilter = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * cwcFilter);
        if(!wszFilter){
            dwRet = LDAP_NO_MEMORY;
            __leave;
        }
        wcscpy(wszFilter, wszFilterBegin);
        wcscat(wszFilter, TAPI_DIRECTORY_GUID);
        wcscat(wszFilter, wszFilterEnd);
        if(wszExtendedFilter){
            wcscat(wszFilter, wszExtendedFilter);
        }
        wcscat(wszFilter, wszFilterEnd);
        assert(wsclen(wszFilter) == (cwcFilter - 1));
        
        // Find the Default SCP.
        // ----------------------------------------
        // First we search for the default SCP, save the name
        // for later, and call pFunc on the first SCP.
        
        dwRet = ldap_search_sW(hld,
                               wszDefTapiIlsDn,
                               LDAP_SCOPE_BASE,
                               (wszExtendedFilter) ? 
                                      wszExtendedFilter :
                                      L"(objectCategory=*)",
                               pwszAttrFilter,
                               0,
                               &pldmResults);

        if(dwRet == LDAP_NO_SUCH_OBJECT){
            dwRet = LDAP_SUCCESS; // continue on
        } else if(dwRet) {
            __leave;
        } else {

            // This is the most common case where there is a default SCP.
            pldmEntry = ldap_first_entry(hld, pldmResults);

            if(pldmEntry == NULL){
                dwRet = LDAP_SUCCESS;
            } else {

                // This is the goods, we've got a default SCP.
                pwszDefaultDnsName = ldap_get_values(hld, pldmEntry, L"serviceDNSName");
                if(pwszDefaultDnsName != NULL && pwszDefaultDnsName[0] != NULL){
                    wszDefaultDnsName = pwszDefaultDnsName[0];

                    dwFuncRet = pFunc(wszDefTapiIlsDn,
                                      wszDefaultDnsName,
                                      TRUE,
                                      TRUE,
                                      pArgs);
                    if(pdwRet){
                        *pdwRet = dwFuncRet;
                    }
                    if(dwFuncRet){
                        // Bail out early if this is ever not 0;
                        __leave;
                    }
                }   
                if(pldmResults){
                    ldap_msgfree(pldmResults);
                    pldmResults = NULL;
                }
            }
        }


        // Find all other SCPs.
        // ----------------------------------------
        // Now we find all the other SCPs, and iterate through
        // them calling pFunc
         
        dwRet = ldap_search_sW(hld,
                               wszRootDn,
                               LDAP_SCOPE_ONELEVEL,
                               wszFilter,
                               pwszAttrFilter,
                               0,
                               &pldmResults);

        if(dwRet != LDAP_SUCCESS){
            __leave;
        }

        pldmEntry = ldap_first_entry(hld, pldmResults);
        for(pldmEntry = ldap_first_entry(hld, pldmResults);
            pldmEntry; 
            pldmEntry = ldap_next_entry(hld, pldmEntry)){
            
            // Get the DN of the TAPI Directory SCP.
            wszTempDn = ldap_get_dn(hld, pldmEntry);
            if(wszTempDn == NULL){
                continue;
            }

            pwszDnsName = ldap_get_values(hld, pldmEntry, L"serviceDNSName");
            if(pwszDnsName == NULL || pwszDnsName[0] == NULL){
                continue;
            }

            // Is if the Default TAPI Directory SCP.
            if(wszDefaultDnsName &&
               0 == _wcsicmp(wszDefaultDnsName, pwszDnsName[0])){
                fIsDefault = TRUE;
            } else {
                fIsDefault = FALSE;
            }

            // Call the virtual function passed in.
            dwFuncRet = pFunc(wszTempDn, // SCP DN
                              pwszDnsName[0],
                              FALSE,
                              fIsDefault,
                              pArgs);
            if(pdwRet){
                *pdwRet = dwFuncRet;
            }
            if(dwFuncRet){
                // Bail out early if this is ever not 0;
                __leave;
            }

            ldap_memfree(wszTempDn);
            wszTempDn = NULL;

            ldap_value_free(pwszDnsName);
            pwszDnsName = NULL;
        } // End for each Service Connection Point (SCP).
        

        // Final Call
        // ----------------------------------------
        // Do one last final call to pFunc, to let the
        // function wrap up, and reset any statics.

        dwFuncRet = pFunc(NULL, NULL, FALSE, FALSE, pArgs);
        if(pdwRet){
            *pdwRet = dwFuncRet;
        }
        if(dwFuncRet){
            __leave;
        }

    } __finally {

        if(pldmResults != NULL){ ldap_msgfree(pldmResults); }
        if(wszTempDn != NULL){ ldap_memfree(wszTempDn); }
        if(pwszDnsName != NULL) { ldap_value_free(pwszDnsName);}
        if(wszDefTapiIlsDn != NULL){ LocalFree(wszDefTapiIlsDn); }
        if(wszFilter != NULL) { LocalFree(wszFilter); }
        if(pwszDefaultDnsName != NULL) { ldap_value_free(pwszDefaultDnsName); }

    }

    return(dwRet);
}


// --------------------------------------------------------------------------
//
// Main Routines.
//
//
// These two functions are the primary ILS functions that are used by
// ntdsutil.exe.
//
    

DWORD
InstallILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn,
    IN      BOOL          fForceDefault,
    IN      BOOL          fAllowReplicas
    )
/*++

Routine Description:

    This routine is the main ILSNG/TAPI Directory installation 
    routine.  This installs the TAPI Directory (wszIlsHeadDn) on the
    machine connected to by hld.  This involveds the following steps:
    A) Create an NDNC head on the machine in hld.
    B) Create a TAPI Directory OU=Dynamic folder.
    D) Register the Service Connection Points (SCPs)
        I) if fForceDefault, then force the default SCP to point
        to this TAPI Directory.
    E) If the TAPI Directory already exists and fAllowReplicas, then
        instead of steps A, B & C, just add ourselves to the replica
        set for the NDNC wszIlsHeadDn.

Arguments:

    hld (IN) - LDAP connection on which to create the TAPI Dir.
    wszIlsHeadDn (IN) - The DN of the TAPI Dir to be created.
    fForceDefault (IN) - Whether to force the Default SCP to
        be changed to this TAPI Dir if the Default SCP already
        exists.
    fAllowReplicas (IN) - Whether to allow replicas if the TAPI
        Dir already exists.
        
Return value:

    A Win32 error code.

--*/
{
    DWORD         dwRet = ERROR_SUCCESS;
    WCHAR *       wszSystemDN = NULL;
    WCHAR *       wszServerDn = NULL;
    VOID *        pvReferrals;
    WCHAR *       wszRegisterDomainDn = NULL;
    WCHAR *       wszDesc = NULL;
    OPTIONAL_VALUE valueFirst = {TRUE, 30};
    OPTIONAL_VALUE valueSecond = {TRUE, 5};

    // Validate 1st Argument - Check NCName to make sure it
    // looks like a domain name
    assert(hld);

    pvReferrals = (VOID *) FALSE; // No referrals.
    dwRet = ldap_set_option(hld, LDAP_OPT_REFERRALS, &pvReferrals);
    if(dwRet != LDAP_SUCCESS){
        PrintLdapErrMsg(TAPICFG_GENERIC_LDAP_ERROR_FUNC, 
                        L"ldap_set_option", hld, dwRet);
        return(LdapMapErrorToWin32(dwRet));
    }

    dwRet = ILSNG_CheckParameters(wszIlsHeadDn);
    if(dwRet != ERROR_SUCCESS){
        // ILSNG_CheckParameters() prints errors.
        return(dwRet);
    }

    __try{

        dwRet = GetRootAttr(hld, L"defaultNamingContext", &wszRegisterDomainDn);
        if(dwRet) {
            // This attribute is needed for proper registration of service
            // objects.
            PrintLdapErrMsg(TAPICFG_GENERIC_LDAP_ERROR_FUNC, 
                            L"", hld, dwRet);
            dwRet = LdapMapErrorToWin32(dwRet);
            __leave;
        }                        
        
        dwRet = FormatMessageW((FORMAT_MESSAGE_ALLOCATE_BUFFER
                                | FORMAT_MESSAGE_FROM_HMODULE
                                | FORMAT_MESSAGE_IGNORE_INSERTS
                                | 80),
                               NULL,
                               TAPICFG_NDNC_DESC,
                               0,
                               (LPWSTR) &wszDesc,
                               sizeof(wszDesc),
                               NULL);
        if(!dwRet){
            PrintMsg(TAPICFG_GENERIC_ERROR, GetLastError());
            __leave;
        }
        assert(wszDesc);

        dwRet = CreateNDNC(hld, wszIlsHeadDn, wszDesc);

        if(dwRet == LDAP_SUCCESS){

            // Created a New NC.

            // TAPI and ILS and ILSNG imply a minimum tree, this fills
            // out that minimum tree.
            if(dwRet = ILSNG_CreateRootTree(hld, wszIlsHeadDn)){
                // dwRet is an LDAP return value.
                PrintLdapErrMsg(TAPICFG_GENERIC_LDAP_ERROR_FUNC, 
                                L"ldap_add_sW", hld, dwRet);
                dwRet = LdapMapErrorToWin32(dwRet);
                __leave;
            }
            
            // We want to start following referrals now, so we goto the
            // Naming FSMO if appropriate.
            //
            pvReferrals = (VOID *) TRUE; 
            dwRet = ldap_set_option(hld, LDAP_OPT_REFERRALS, &pvReferrals);
            if(dwRet != LDAP_SUCCESS){
                return(LdapMapErrorToWin32(dwRet));
            }

        } else if(dwRet == LDAP_ALREADY_EXISTS){
            
            
            if(fAllowReplicas){
                // This is if we tried to add an replica and the NC already
                // existed, so what we need to do is to see if we can add 
                // ourselves as a replica for this NC.
                dwRet = LDAP_SUCCESS;

                dwRet = GetRootAttr(hld, L"dsServiceName", &wszServerDn);
                if(dwRet){
                    PrintLdapErrMsg(TAPICFG_GENERIC_LDAP_ERROR_FUNC, 
                                    L"", hld, dwRet);
                    dwRet = LdapMapErrorToWin32(dwRet);
                    __leave;
                }

                // We want to start following referrals now, so we goto the
                // Naming FSMO if appropriate.
                //
                pvReferrals = (VOID *) TRUE;
                dwRet = ldap_set_option(hld, LDAP_OPT_REFERRALS, &pvReferrals);
                if(dwRet != LDAP_SUCCESS){
                    dwRet = LdapMapErrorToWin32(dwRet);
                    __leave;
                }

                // Add this DC as a replica for the NC.
                dwRet = ModifyNDNCReplicaSet(hld, wszIlsHeadDn, wszServerDn, TRUE);
                if(dwRet == LDAP_ATTRIBUTE_OR_VALUE_EXISTS ||
                   dwRet == LDAP_SUCCESS){
                    // An error of already exists or success, is the same thing to
                    // us, because if we're already a replica of this NC, then we'll
                    // go onto register service objects.

                } else {
                    PrintLdapErrMsg(TAPICFG_GENERIC_LDAP_ERROR_FUNC, 
                                    L"ldap_modify_ext_sW", hld, dwRet);
                    dwRet = LdapMapErrorToWin32(dwRet);
                    __leave;
                }
            }

        } else if(dwRet){
            // Unknown error, bail out.
            PrintLdapErrMsg(TAPICFG_GENERIC_LDAP_ERROR_FUNC, 
                            L"ldap_add_ext_sW", hld, dwRet);
            dwRet = LdapMapErrorToWin32(dwRet);
            __leave;
        }

        // Register the service objects.
        // Code.Improvement make this function print more extensive error
        // information.  May not be needed, because this is one of the lesser
        // priveledged operations compared with the above operations.
        if(dwRet = ILSNG_RegisterServiceObjects(hld, 
                                                wszIlsHeadDn,
                                                wszRegisterDomainDn,
                                                fForceDefault,
                                                FALSE)){
            PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
            dwRet = LdapMapErrorToWin32(dwRet);
            __leave;
        }

    } __finally {

        if(wszSystemDN) { LocalFree(wszSystemDN); }
        if(wszServerDn) { LocalFree(wszServerDn); }
        if(wszDesc) { LocalFree(wszDesc); }

    }

    return(dwRet);
}



DWORD
UninstallILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn
    )
/*++

Routine Description:

    This routine deletes the ILSNG/TAPI Directory service installed 
    on the machine.  While this routine makes the assumption that the
    TAPI Dir is only installed on one machine, and no replicated, this
    is very likely to still succeed in the replicated case.  The steps
    in the TAPI Dir uninstall are:
    A) Delete the crossRef of the NDNC, thus deleted the whole NDNC.
    B) UnRegistering (i.e. deleting) the SCPs.

Arguments:

    hld (IN) - The directory of the machine on which the TAPI Dir was
        instantiated.
    wszIlsHeadDn - The DN of the TAPI Dir.

Return value:

    A Win32 error code.

--*/
{
    DWORD         dwRet;
    WCHAR *       wszDomainDn = NULL;
    WCHAR *       wszCrossRefDn = NULL;
    VOID *        pvReferrals;
    
    __try {
        dwRet = GetRootAttr(hld, L"defaultNamingContext", &wszDomainDn);
        if(dwRet){
            PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
            __leave;
        }
        assert(wszDomainDn);

        dwRet = GetCrossRefDNFromNCDN(hld,
                                      wszIlsHeadDn,
                                      &wszCrossRefDn);
        if(dwRet){
            PrintLdapErrMsg(TAPICFG_GENERIC_LDAP_ERROR_FUNC, 
                            L"LDAP Search", hld, dwRet);
            __leave;
        }
        assert(wszCrossRefDn);

        pvReferrals = (VOID *) TRUE;
        dwRet = ldap_set_option(hld, LDAP_OPT_REFERRALS, &pvReferrals);
        if(dwRet != LDAP_SUCCESS){
            PrintLdapErrMsg(TAPICFG_GENERIC_LDAP_ERROR_FUNC, 
                            L"ldap_set_option", hld, dwRet);
            __leave;
        }

        dwRet = ldap_delete_sW(hld, wszCrossRefDn);
        if(dwRet){
            PrintLdapErrMsg(TAPICFG_GENERIC_LDAP_ERROR_FUNC, 
                            L"ldap_delete_sW", hld, dwRet);
            // NOTE: It might be a better idea to not leave, and just try
            // to clean up the service objects for this TAPI Dir.
            __leave;
        }

        dwRet = ILSNG_UnRegisterServiceObjects(hld, wszIlsHeadDn, wszDomainDn);
        if(dwRet){
            PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
            __leave;
        }

    } __finally {
        if(wszDomainDn) { LocalFree(wszDomainDn); }
        if(wszCrossRefDn) { LocalFree(wszCrossRefDn); }
    }

    return(LdapMapErrorToWin32(dwRet));
}

typedef struct _ListInArgs {
    LDAP *     hld;
    BOOL       fDefaultOnly;
} ListInArgs;

DWORD
ListILSNGOne(
    IN      WCHAR *      wszScpObjDn,
    IN      WCHAR *      wszTapiDirDns,
    IN      BOOL         fIsDefaultScp,
    IN      BOOL         fIsDefaultTapiDir,
    IN      PVOID        pArgs
    )
/*++

Routine Description:

    This routine is the partner to the ListILSNG() function, but is
    called through the ILSNG_EnumerateSCPs() function.  This routine 
    prints out some info about one SCP.

Arguments:

    wszScpObjDn (IN) - This is the DN of the SCP.
    wszTapiDirDns (IN) - This is the DNS name of the TAPI Dir for this SCP.
    fIsDefaultScp (IN) - Tells if this is the Default SCP object.
        Generally, this will be TRUE only in one call for a set of SCPs.
    fIsDefaultTapiDir - Tells if this is the default TAPI Dir.  Generally,
        this will be TRUE for two calls for a set of SCPs.
    pArgs (IN) - This is a boolean on whether to print out only the
        default TAPI Dir, or print out all of the TAPI Dirs.

Return value:

    always returns ERROR_SUCCESS.

--*/
{
    static BOOL  fFirstRun = TRUE;
    static BOOL  fPrintedDefaultScp = FALSE;
    LDAP *       hld = ((ListInArgs *) pArgs)->hld;
    BOOL         fDefaultOnly = ((ListInArgs *) pArgs)->fDefaultOnly;
    WCHAR *      wszInstantiatedDc = NULL;
    ULONG        ulRet;
    
    if(wszScpObjDn == NULL){
        fFirstRun = TRUE;
        fPrintedDefaultScp = FALSE;
        return(ERROR_SUCCESS);
    }

    assert(fIsDefaultScp && !fIsDefaultTapiDir);

    if(fFirstRun && !fIsDefaultScp){
        PrintMsg(TAPICFG_SHOW_NO_DEFAULT_SCP);
    }
    if(fIsDefaultScp){

        assert(fFirstRun);
        fPrintedDefaultScp = TRUE;
        ulRet = GetILSNGDC(hld, wszTapiDirDns, &wszInstantiatedDc);
        if(ulRet){
            PrintMsg(TAPICFG_SHOW_PRINT_DEFAULT_SCP_NO_SERVER, wszTapiDirDns);
        } else {
            PrintMsg(TAPICFG_SHOW_PRINT_DEFAULT_SCP, wszTapiDirDns,
                     wszInstantiatedDc);
            LocalFree(wszInstantiatedDc);
            wszInstantiatedDc = NULL;
        }
    }

    // On subsequent runs, we want to know we've run once.
    fFirstRun = FALSE;

    if(fDefaultOnly){
        // We've either printed out the default SCP or printed
        // that there are no default SCPs, so return.
        return(ERROR_SUCCESS);
    }

    assert(fIsDefaultTapiDir && !fPrintedDefaultScp);
    if(fIsDefaultTapiDir){
        // We don't want to print the default Tapi Dir twice
        // that'd be once for it's regular SCP and once for
        // it's default SCP.
        return(ERROR_SUCCESS);
    }

    ulRet = GetILSNGDC(hld, wszTapiDirDns, &wszInstantiatedDc);
    if(ulRet){
        PrintMsg(TAPICFG_SHOW_PRINT_SCP_NO_SERVER, wszTapiDirDns);
    } else {
        PrintMsg(TAPICFG_SHOW_PRINT_SCP, wszTapiDirDns,
                 wszInstantiatedDc);
        LocalFree(wszInstantiatedDc);
        wszInstantiatedDc = NULL;
    }

    return(ERROR_SUCCESS);
}

DWORD
ListILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszDomainDn,
    IN      BOOL          fDefaultOnly
    )
/*++

Routine Description:

    This is a function that simply prints out all the TAPI Directories,
    as identified by thier SCPs.  This uses a helper function ListILSNGOne
    to print out each SCP.

Arguments:

    hld (IN) - An LDAP binding to use.
    wszDomainDn (IN) - The Domain to enumerate the SCPs out of.
    fDefaultOnly (IN) - Whether to print out all the SCPs or just
        the default one.

Return value:

    A Win32 error code.

--*/
{
    DWORD                 dwRet = ERROR_SUCCESS;
    WCHAR *               wszMsTapiContainerDn = NULL;
    ListInArgs            Args = { hld, fDefaultOnly };

    assert(hld);

    dwRet = GetMsTapiContainerDn(hld, wszDomainDn, 
                                 &wszMsTapiContainerDn);
    if(dwRet != ERROR_SUCCESS){
        PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
        return(LdapMapErrorToWin32(dwRet));
    }

    PrintMsg(TAPICFG_SHOW_NOW_ENUMERATING);

    // Note: That this is slightly inefficient in the case where
    // fDefaultOnly = TRUE, but what this lacks in efficency it
    // more than makes up in beauty of code reuse.
    dwRet = ILSNG_EnumerateSCPs(hld, wszMsTapiContainerDn, NULL,
                                // Iterator Function Params.
                                NULL,  // Return of ListILSNGOne
                                ListILSNGOne,  // Function to Call
                                (PVOID) &Args); // Args to provide

    if(dwRet == LDAP_NO_SUCH_OBJECT){
        PrintMsg(TAPICFG_SHOW_NO_SCP);
        dwRet = LDAP_SUCCESS;
    } else if (dwRet){
        PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
    }
    LocalFree(wszMsTapiContainerDn);

    return(LdapMapErrorToWin32(dwRet));
}

DWORD
ReregisterILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn,
    IN      WCHAR *       wszDomainDn,
    IN      BOOL          fForceDefault,
    IN      BOOL          fDefaultOnly
    )
/*++

Routine Description:

    This routine re-registers the Default TAPI Directory SCPs to point
    to the TAPI Dir specified (wszIlsHeadDn).  This will force the 
    Default SCP to point at wszIlsHeadDn, if it doesn't already exist.

Arguments:

    hld (IN) - An LDAP binding to use.
    wszIlsHeadDn (IN) - The DN of the TAPI Dir to reregister.  This gets
        turned into a DNS name for registration purposes.
    wszDomainDn (IN) - This is the domain in which to register the Default
        SCPs.
    fForceDefault (IN) - Whether or not to modify the existing default SCP
        if it exists
    fDefaultOnly - This is for whether to do only the Default SCPs, or
        all SCPs.

Return value:

    ldap error code.

--*/
{
    DWORD         dwRet;

    dwRet = ILSNG_RegisterServiceObjects(hld, 
                                         wszIlsHeadDn,
                                         wszDomainDn,
                                         fForceDefault,
                                         fDefaultOnly);
    if(dwRet){
        PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
    }

    return(LdapMapErrorToWin32(dwRet));
}


DWORD
DeregisterILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn,
    IN      WCHAR *       wszDomainDn
    )
/*++

Routine Description:

    This routine de-registers the Default TAPI Directory SCPs to point
    to the TAPI Dir specified (wszIlsHeadDn).

Arguments:

    hld (IN) - An LDAP binding to use.
    wszIlsHeadDn (IN) - The DN of the TAPI Dir to reregister.  This gets
        turned into a DNS name for registration purposes.
    wszDomainDn (IN) - This is the domain in which to register the Default
        SCPs.
        

Return value:

    ldap error code.

--*/
{
    DWORD         dwRet;
    
    dwRet = ILSNG_UnRegisterServiceObjects(hld, wszIlsHeadDn, wszDomainDn);
    if(dwRet){
        PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
    }

    return(LdapMapErrorToWin32(dwRet));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\tapicfg\print.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    print.c

ABSTRACT:

DETAILS:

CREATED:

    1999 May 6  JeffParh
        Lifted from netdiag\results.c.

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <assert.h>

static WCHAR s_szBuffer[4096];
static WCHAR s_szFormat[4096];
static WCHAR s_szSpaces[] = 
    L"                                                                                               ";

#ifndef DimensionOf
#define DimensionOf(x) (sizeof(x)/sizeof((x)[0]))
#endif

void PrintMessageSz(LPCWSTR pszMessage);

void
PrintMessage(
    IN  ULONG   uMessageID,
    IN  ...
    )

/*++

Routine Description:

Print a message, where a printf-style format string comes from a resource file

Arguments:

    uMessageID - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    va_list args;
    
    DWORD dwRet;

    va_start(args, uMessageID);
    
    dwRet = LoadStringW(NULL, uMessageID, s_szFormat, DimensionOf(s_szFormat));
    
    nBuf = vswprintf(s_szBuffer, s_szFormat, args);
    assert(nBuf < DimensionOf(s_szBuffer));
    
    va_end(args);
    
    PrintMessageSz(s_szBuffer);
} /* PrintMessageID */

void
PrintMessageMultiLine(
    IN  LPWSTR   pszMessage,
    IN  BOOL     bTrailingLineReturn
    )
/*++

Routine Description:

Take a multi-line buffer such as
line\nline\nline\n\0
and call PrintMessageSz on each line

Arguments:

    pszMessage - 

Return Value:

--*/

{
    LPWSTR start, end;
    WCHAR wchSave;

    start = end = pszMessage;
    while (1) {
        while ( (*end != L'\n') && (*end != L'\0') ) {
            end++;
        }

        if (*end == L'\0') {
            // Line ends prematurely, give it a nl
            if(bTrailingLineReturn){
                *end++ = L'\n';
                *end = L'\0';
            }
            PrintMessageSz(start);
            break;
        }

        // Line has newline at end
        end++;
        if (*end == L'\0') {
            // Is the last line
            PrintMessageSz(start);
            break;
        }

        // Next line follows
        // Simulate line termination temporarily
        wchSave = *end;
        *end = L'\0';
        PrintMessageSz(start);
        *end = wchSave;

        start = end;
    }
} /* PrintMessageMultiLine */

void
formatMsgHelp(
    IN  DWORD   dwWidth,
    IN  DWORD   dwMessageCode,
    IN  va_list *vaArgList
    )

/*++

Routine Description:

Print a message where the format comes from a message file. The message in the
message file does not use printf-style formatting. Use %1, %2, etc for each
argument. Use %<arg>!printf-format! for non string inserts.

Note that this routine also forces each line to be the current indention width.
Also, each line is printed at the right indentation.

Arguments:

    dwWidth - 
    dwMessageCode - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    
    // Format message will store a multi-line message in the buffer
    nBuf = FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE | (FORMAT_MESSAGE_MAX_WIDTH_MASK & dwWidth),
        0,
        dwMessageCode,
        0,
        s_szBuffer,
        DimensionOf(s_szBuffer),
        vaArgList );
    if (nBuf == 0) {
        nBuf = wsprintf( (LPTSTR) s_szBuffer, (LPCTSTR) L"Message 0x%x not found.\n",
                         dwMessageCode );
        assert(!"There is a message constant being used in the code"
               "that isn't in the message file dcdiag\\common\\msg.mc"
               "Take a stack trace and send to owner of dcdiag.");
    }
    assert(nBuf < DimensionOf(s_szBuffer));
} /* PrintMsgHelp */

void
PrintMsg(
    IN  DWORD   dwMessageCode,
    IN  ...
    )

/*++

Routine Description:

Wrapper around PrintMsgHelp with width restrictions.
This is the usual routine to use.

Arguments:

    dwMessageCode - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    DWORD width = 80; 
    va_list args;
    
    va_start(args, dwMessageCode);
    formatMsgHelp( width, dwMessageCode, &args );
    va_end(args);
    
    PrintMessageMultiLine( s_szBuffer, TRUE);

} /* PrintMsg */

void
PrintMessageSz(
    IN  LPCWSTR pszMessage
    )

/*++

Routine Description:

Print a single indented line from a buffer to the output stream

Arguments:

    pszMessage - 

Return Value:

--*/

{
    wprintf(L"%s", pszMessage);
    fflush(stdout);
} /* PrintMessageSz */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\tapicfg\ilsng.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ndnc.h

Abstract:

    This module defines the main helping functions for TAPI
    dynamic directories (aka ILSNG).

Author:

    Brett Shirley (BrettSh) 20-Feb-2000

Revision History:

    21-Jul-2000     BrettSh
        
        Moved this file and it's functionality from the ntdsutil
        directory to the new tapicfg utility.  The old source 
        location: \nt\ds\ds\src\util\ntdsutil\ilsng.h.                                    
                                    
--*/
#ifdef __cplusplus
extern "C" {
#endif

// ----------------------------------
// Common Utility Functions

ULONG
GetRootAttr(
    IN      LDAP *       hld,
    IN      WCHAR *      wszAttr,
    OUT     WCHAR **     pwszOut
    );

DWORD
GetDnFromDns(
    IN      WCHAR *       wszDns,
    OUT     WCHAR **      pwszDn
    );

DWORD
ILSNG_EnumerateSCPs(
    IN      LDAP *       hld,
    IN      WCHAR *      wszRootDn,
    IN      WCHAR *      wszExtendedFilter,
    OUT     DWORD *      pdwRet,                         // Return Value
    IN      DWORD (__stdcall * pFunc) (),  // Function
    IN OUT  PVOID        pArgs                           // Argument
    );

// ----------------------------------
// Main Worker Functions.

DWORD
InstallILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn,
    IN      BOOL          fForceDefault,
    IN      BOOL          fAllowReplicas
    );

DWORD
UninstallILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn
    );

DWORD
ListILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszDomainDn,
    IN      BOOL          fDefaultOnly
    );

DWORD
ReregisterILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn,
    IN      WCHAR *       wszDomainDn,
    IN      BOOL          fForceDefault,
    IN      BOOL          fDefaultOnly
    );

DWORD
DeregisterILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn,
    IN      WCHAR *       wszDomainDn
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\sdcheck\main.c ===
/*++

Copyright (c) 1987-1999 Microsoft Corporation

Module Name:

    sdcheck - main.c

Abstract:

    This program verifies and dumps security descriptors (SDs) of
    objects in the active directory.

Author:

    Dave Straube (davestr) 1/22/98

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windows.h>
#include <winldap.h>
#include <ntldap.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>             // alloca()
#include <rpc.h>                // RPC defines
#include <rpcdce.h>             // RPC_AUTH_IDENTITY_HANDLE
#include <sddl.h>               // ConvertSidToStringSid
#include <ntdsapi.h>            // DS APIs
#include <permit.h>             // DS_GENERIC_MAPPING
#include <checkacl.h>           // CheckAclInheritance()

#include <ntdsa.h>
#include <objids.h>             // IT_NC_HEAD

//
// Typedefs
//

typedef struct ClassCache
{
    struct ClassCache   *pNext;
    GUID                guid;
    CHAR                name[1];
} ClassCache;

typedef struct SdHistory
{
    DWORD               cTime;
    SYSTEMTIME          rTime[5];
} SdHistory;

typedef struct MetaData
{
    SYSTEMTIME          stLastOriginatingWrite;
    DWORD               dwVersion;
    UUID                uuidInvocation;
    CHAR                *pszInvocation;
} MetaData;

typedef struct ClassInfo
{   DWORD               cClasses;
    CHAR                **rClasses;
    DWORD               cAuxClasses;
    CHAR                **rAuxClasses;
} ClassInfo;

typedef struct DumpObject
{
    CHAR                *name;          // name of object
    DWORD               cbSD;           // SD byte count
    SECURITY_DESCRIPTOR *pSD;           // SD itself
    ClassInfo           classInfo;      // object class(es)
    SdHistory           history;        // SD propagator history
    MetaData            metaData;       // repl metadata for SD property
    DWORD               instanceType;   // instance type of the object
} DumpObject;

//
// Globals
//

UUID        gNullUuid = { 0 };              // for comparisons
CHAR        *gpszServer = NULL;             // required arg
CHAR        *gpszObject = NULL;             // required arg
CHAR        *gpszDomain = NULL;             // optional arg - creds
CHAR        *gpszUser = NULL;               // optional arg - creds
CHAR        *gpszPassword = NULL;           // optional arg - creds
CHAR        gpszNullPassword[] = { 0 };     // for RPC_AUTH_IDENTITY_HANDLE
HANDLE      ghDS = NULL;                    // DsBind handle
LDAP        *gldap = NULL;                  // LDAP handle
DWORD       cObjects = 0;                   // count of objects to root of NC
DumpObject  *rObjects = NULL;               // array of objects to root of NC
BOOL        gfDumpOne = FALSE;              // optional arg
BOOL        gfDumpAll = FALSE;              // optional arg
BOOL        gfVerbose = FALSE;              // optional arg
ClassCache  *gClassCache = NULL;            // class name <==> GUID cache

//
// Private (de)alloc routines
//

void *
MyAlloc(
    DWORD cBytes
    )
{
    void *p;

    if ( p = LocalAlloc(LPTR, cBytes) )
        return(p);

    printf("*** Error: Failed to allocate %d bytes\n", cBytes);
    exit(1);
    return NULL;
}

void
MyFree(
    VOID *p
    )
{
    if ( p )
        LocalFree(p);
}

//
// Cleanup globals routine
//

void
CleanupGlobals()
{
    DWORD       i, j;
    ClassCache  *p;

    if ( gldap ) ldap_unbind(gldap);
    if ( ghDS ) DsUnBindA(&ghDS);

    for ( i = 0; i < cObjects; i++ )
    {
        MyFree(rObjects[i].name);
        MyFree(rObjects[i].pSD);
        MyFree(rObjects[i].metaData.pszInvocation);
        for ( j = 0; j < rObjects[i].classInfo.cClasses; j++ )
            MyFree(rObjects[i].classInfo.rClasses[j]);
        MyFree(rObjects[i].classInfo.rClasses);
        if (rObjects[i].classInfo.cAuxClasses) {
            for ( j = 0; j < rObjects[i].classInfo.cAuxClasses; j++ )
                MyFree(rObjects[i].classInfo.rAuxClasses[j]);
            MyFree(rObjects[i].classInfo.rAuxClasses);
        }
    }

    while ( gClassCache )
    {
        p = gClassCache->pNext;
        MyFree(gClassCache);
        gClassCache = p;
    }
}

//
// Add a class name/guid pair to the cache.
//

void
AddClassToCache(
    GUID    *pGuid,
    CHAR    *name
    )
{
    ClassCache  *p, *pTmp;

    for ( p = gClassCache; NULL != p; p = p->pNext )
    {
        if ( !_stricmp(p->name, name) )
        {
            return;
        }
    }

    p = (ClassCache *) MyAlloc(sizeof(ClassCache) + strlen(name));
    p->guid = *pGuid;
    strcpy(p->name, name);
    p->pNext = gClassCache;
    gClassCache = p;
}

//
// Map a class name to a GUID.
//

GUID *
ClassNameToGuid(
    CHAR    *name
    )
{
    PLDAPMessage            ldap_message = NULL;
    PLDAPMessage            entry = NULL;
    CHAR                    *attrs[2];
    PSTR                    *values = NULL;
    DWORD                   dwErr;
    DWORD                   i, cVals;
    ClassCache              *p;
    CHAR                    *schemaNC;
    CHAR                    filter[1024];
    PLDAP_BERVAL            *sd_value = NULL;

    for ( p = gClassCache; NULL != p; p = p->pNext )
    {
        if ( !_stricmp(p->name, name) )
        {
            return(&p->guid);
        }
    }

    // OK - Go get it the hard way.

    attrs[0] = "schemaNamingContext";
    attrs[1] = NULL;

    dwErr = ldap_search_ext_sA(gldap,
                               "",
                               LDAP_SCOPE_BASE,
                               "(objectClass=*)",
                               attrs,
                               0,
                               NULL,
                               NULL,
                               NULL,
                               10000,
                               &ldap_message);

    if ( LDAP_SUCCESS != dwErr )
    {
        printf("*** Error: Read of schemaNamingContext failed with 0x%x\n",
               dwErr);
        ldap_msgfree(ldap_message);
        return(NULL);
    }

    if (    !(entry = ldap_first_entry(gldap, ldap_message))
         || !(values = ldap_get_valuesA(gldap, entry, attrs[0]))
         || !(cVals = ldap_count_valuesA(values))
         || !(sd_value = ldap_get_values_lenA(gldap, ldap_message, attrs[0])) )
    {
        printf("*** Error: No values returned for schemaNamingContext\n");
        ldap_msgfree(ldap_message);
        return(NULL);
    }

    schemaNC = (CHAR *) MyAlloc((*sd_value)->bv_len + 1);
    memset(schemaNC, 0, (*sd_value)->bv_len + 1);
    memcpy(schemaNC, (BYTE *) (*sd_value)->bv_val, (*sd_value)->bv_len);
    ldap_value_free_len(sd_value);
    ldap_value_freeA(values);
    ldap_msgfree(ldap_message);
    sd_value = NULL;
    values = NULL;
    ldap_message = NULL;

    // Now go find the right classSchema object.

    attrs[0] = "schemaIDGUID";
    attrs[1] = NULL;
    sprintf(filter,
            "(&(objectClass=classSchema)(ldapDisplayName=%s))",
            name);

    dwErr = ldap_search_ext_sA(gldap,
                               schemaNC,
                               LDAP_SCOPE_SUBTREE,
                               filter,
                               attrs,
                               0,
                               NULL,
                               NULL,
                               NULL,
                               10000,
                               &ldap_message);
    MyFree(schemaNC);

    if ( LDAP_SUCCESS != dwErr )
    {
        printf("*** Error: Read of schema ID GUID for %s failed with 0x%x\n",
               name, dwErr);
        ldap_msgfree(ldap_message);
        return(NULL);
    }

    if (    !(entry = ldap_first_entry(gldap, ldap_message))
         || !(values = ldap_get_valuesA(gldap, entry, attrs[0]))
         || !(cVals = ldap_count_valuesA(values))
         || !(sd_value = ldap_get_values_lenA(gldap, ldap_message, attrs[0])) )
    {
        printf("*** Error: No values returned for schema ID GUID for %s\n",
               name);
        ldap_msgfree(ldap_message);
        return(NULL);
    }

    AddClassToCache((GUID *) (*sd_value)->bv_val, name);
    ldap_value_free_len(sd_value);
    ldap_value_freeA(values);
    ldap_msgfree(ldap_message);
    return(&gClassCache->guid);
}

//
// Convert SYSTEMTIME from GMT to local time.
//

void
GmtSystemTimeToLocalSystemTime(
    SYSTEMTIME  *psTime
    )
{
    TIME_ZONE_INFORMATION   tz;
    SYSTEMTIME              localTime;
    DWORD                   dwErr;

    dwErr = GetTimeZoneInformation(&tz);

    if (    (TIME_ZONE_ID_INVALID != dwErr)
         && (TIME_ZONE_ID_UNKNOWN != dwErr) )
    {
        if ( SystemTimeToTzSpecificLocalTime(&tz, psTime, &localTime) )
        {
            *psTime = localTime;
            return;
        }
    }

    printf("*** Error: Couldn't convert time from GMT to local\n");
}

//
// Convert generalized time to SYSTEMTIME.
//

void
GeneralizedTimeToSystemTime(
    CHAR        *pszTime,               // IN
    BOOL        fConvertToLocalTime,    // IN
    SYSTEMTIME  *psTime                 // OUT
    )
{
    ULONG       cb;
    CHAR        buff[10];

    memset(psTime, 0, sizeof(SYSTEMTIME));

    // year field
    cb=4;
    strncpy(buff, pszTime, cb);
    buff[cb] = L'\0';
    psTime->wYear = (USHORT) atoi(buff);
    pszTime += cb;

    // month field
    cb=2;
    strncpy(buff, pszTime, cb);
    buff[cb] = L'\0';
    psTime->wMonth = (USHORT) atoi(buff);
    pszTime += cb;

    // day of month field
    cb=2;
    strncpy(buff, pszTime, cb);
    buff[cb] = L'\0';
    psTime->wDay = (USHORT) atoi(buff);
    pszTime += cb;

    // hours
    cb=2;
    strncpy(buff, pszTime, cb);
    buff[cb] = L'\0';
    psTime->wHour = (USHORT) atoi(buff);
    pszTime += cb;

    // minutes
    cb=2;
    strncpy(buff, pszTime, cb);
    buff[cb] = L'\0';
    psTime->wMinute = (USHORT) atoi(buff);
    pszTime += cb;

    // seconds
    cb=2;
    strncpy(buff, pszTime, cb);
    buff[cb] = L'\0';
    psTime->wSecond = (USHORT) atoi(buff);

    if ( fConvertToLocalTime )
        GmtSystemTimeToLocalSystemTime(psTime);
}

//
// Lookup a schema GUID in the DS via DsMapSchemaGuids.  Always
// returns valid data, though we may just end up sprintf-ing the input.
//

void
LookupGuid(
    GUID    *pg,            // IN
    CHAR    **ppName,       // OUT
    CHAR    **ppLabel,      // OUT
    BOOL    *pfIsClass      // OUT
    )
{
    static CHAR         name[1024];
    static CHAR         label[1024];
    DWORD               dwErr;
    DS_SCHEMA_GUID_MAPA *pMap;
    BOOL                fLame = FALSE;
    DWORD               i;

    *pfIsClass = FALSE;
    *ppName = name;
    *ppLabel = label;

    dwErr = DsMapSchemaGuidsA(ghDS, 1, pg, &pMap);

    if ( dwErr )
    {
        fLame = TRUE;
    }
    else
    {
        switch ( pMap->guidType )
        {
        case DS_SCHEMA_GUID_ATTR:
            strcpy(label, "Attr"); break;
        case DS_SCHEMA_GUID_ATTR_SET:
            strcpy(label, "Attr set"); break;
        case DS_SCHEMA_GUID_CLASS:
            strcpy(label, "Class"); *pfIsClass = TRUE; break;
        case DS_SCHEMA_GUID_CONTROL_RIGHT:
            strcpy(label, "Control right"); break;
        default:
            fLame = TRUE; break;
        }

        if ( !pMap->pName )
        {
            fLame = TRUE;
        }
        else
        {
            strcpy(name, pMap->pName);

            if ( *pfIsClass )
            {
                AddClassToCache(pg, pMap->pName);
            }
        }
    }

    if ( fLame )
    {
        *pfIsClass = FALSE;
        strcpy(label, "???");
        sprintf(name,
                "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                pg->Data1,
                pg->Data2,
                pg->Data3,
                pg->Data4[0],
                pg->Data4[1],
                pg->Data4[2],
                pg->Data4[3],
                pg->Data4[4],
                pg->Data4[5],
                pg->Data4[6],
                pg->Data4[7]);
        printf("*** Warning: Unable to map schema GUID %s - analysis may be compromised\n", name);
    }

    if ( !dwErr )
        DsFreeSchemaGuidMapA(pMap);
}

//
// Map an object SID to a text representation.  Always returns valid
// data, though we may just end up sprintf-ing the input.
//

CHAR *
LookupSid(
    PSID    pSID        // IN
    )
{
    static CHAR     retVal[2048];
    SID_NAME_USE    snu;
    CHAR            user[64];
    CHAR            domain[64];
    DWORD           cUser = sizeof(user);
    DWORD           cDomain = sizeof(domain);
    CHAR            *pszTmp;
    DWORD           i;

    if ( !pSID )
    {
        strcpy(retVal, "<NULL>");
        return(retVal);
    }
    else if ( !RtlValidSid(pSID) )
    {
        strcpy(retVal, "Not an RtlValidSid()");
        return(retVal);
    }
    else if ( LookupAccountSid(NULL, pSID, user, &cUser,
                               domain, &cDomain, &snu) )
    {
        if ( cDomain )
        {
            strcpy(retVal, domain);
            strcat(retVal, "\\");
            strcat(retVal, user);
        }
        else
        {
            strcpy(retVal, user);
        }

        strcat(retVal, " ");
    }
    else
    {
        retVal[0] = L'\0';
    }

    // Always concatenate S-xxx form of SID for reference.

    if ( ConvertSidToStringSidA(pSID, &pszTmp) )
    {
        strcat(retVal, pszTmp);
        LocalFree(pszTmp);
    }

    if ( L'\0' != retVal[0] )
    {
        // Already have symbolic name, S-xxx form, or both - done.
        return(retVal);
    }

    // Dump binary as a last resort.

    for ( i = 0; i < RtlLengthSid(pSID); i++ )
    {
        sprintf(&retVal[2*i], "%02x", ((CHAR *) pSID)[i]);
    }

    retVal[2*i] = '\0';
    return(retVal);
}



//
// Get an object's classes from the directory.  Note that these class
// names are the LDAP display names which in turn are the same names
// as those returned bu DsMapSchemaGuid - at least when the GUID
// represents a class or attribute.
//

void
ReadClasses(
    DumpObject          *pdo        // IN
    )
{
    CHAR                    *pDN = pdo->name;
    PLDAPMessage            ldap_message = NULL;
    PLDAPMessage            entry = NULL;
    CHAR                    *attrs[4];
    PSTR                    *values = NULL;
    DWORD                   dwErr;
    DWORD                   i, cVals;

    dwErr = 1;

    _try
    {
        attrs[0] = "objectClass";
        attrs[1] = "instanceType";
        attrs[2] = "msDS-Auxiliary-Classes";
        attrs[3] = NULL;

        dwErr = ldap_search_ext_sA(gldap,
                                   pDN,
                                   LDAP_SCOPE_BASE,
                                   "(objectClass=*)",
                                   attrs,
                                   0,
                                   NULL,
                                   NULL,
                                   NULL,
                                   10000,
                                   &ldap_message);

        if ( LDAP_SUCCESS != dwErr )
        {
            printf("*** Error: Read of objectClass on %s failed with 0x%x\n",
                   pDN, dwErr);
            _leave;
        }

        if (    !(entry = ldap_first_entry(gldap, ldap_message))
             || !(values = ldap_get_valuesA(gldap, entry, attrs[0]))
             || !(cVals = ldap_count_valuesA(values)) )
        {
            printf("*** Error: No values returned for objectClass on %s\n",
                   pDN);
            _leave;
        }

        pdo->classInfo.rClasses =
                (CHAR **) MyAlloc(cVals * sizeof(CHAR *));

        for ( i = 0; i < cVals; i++ )
        {
            pdo->classInfo.rClasses[i] =
                            (CHAR *) MyAlloc(strlen(values[i]) + 1);
            strcpy(pdo->classInfo.rClasses[i], values[i]);
            pdo->classInfo.cClasses += 1;
        }
        if ( values ) {
            ldap_value_freeA(values);
            values = NULL;
        }

        if (    !(values = ldap_get_valuesA(gldap, entry, attrs[1]))
             || !(cVals = ldap_count_valuesA(values)) )
        {
            printf("*** Error: No values returned for instanceType on %s\n",
                   pDN);
            _leave;
        }
        pdo->instanceType = atol(values[0]);
    
        // Get aux classes (if any)
        if (values = ldap_get_valuesA(gldap, entry, attrs[2])) {
            // we got some aux classes
            cVals = ldap_count_valuesA(values);
            pdo->classInfo.cAuxClasses = cVals;
            pdo->classInfo.rAuxClasses = MyAlloc(cVals * sizeof(CHAR *));
            for ( i = 0; i < cVals; i++ )
            {
                pdo->classInfo.rAuxClasses[i] =
                                (CHAR *) MyAlloc(strlen(values[i]) + 1);
                strcpy(pdo->classInfo.rAuxClasses[i], values[i]);
            }
            ldap_value_freeA(values);
            values = NULL;
        }
    }
    _finally
    {
        if ( values )
            ldap_value_freeA(values);

        if ( ldap_message )
            ldap_msgfree(ldap_message);
    }
}

//
// Read on object's SD propagation history from the directory.
//

void
ReadSdHistory(
    DumpObject  *pdo        // IN
    )
{
    CHAR                    *pDN = pdo->name;
    SdHistory               *pHistory = &pdo->history;
    PLDAPMessage            ldap_message = NULL;
    PLDAPMessage            entry = NULL;
    CHAR                    *attrs[2];
    PSTR                    *values = NULL;
    DWORD                   dwErr;
    DWORD                   i, cVals;

    dwErr = 1;
    memset(pHistory, 0, sizeof(SdHistory));

    _try
    {
        attrs[0] = "dSCorePropagationData";
        attrs[1] = NULL;

        dwErr = ldap_search_ext_sA(gldap,
                                   pDN,
                                   LDAP_SCOPE_BASE,
                                   "(objectClass=*)",
                                   attrs,
                                   0,
                                   NULL,
                                   NULL,
                                   NULL,
                                   10000,
                                   &ldap_message);

        if ( LDAP_SUCCESS != dwErr )
        {
            printf("*** Error: Read of dSCorePropagationData on %s failed with 0x%x\n",
                   pDN, dwErr);
            _leave;
        }

        if (    !(entry = ldap_first_entry(gldap, ldap_message))
             || !(values = ldap_get_valuesA(gldap, entry, attrs[0]))
             || !(cVals = ldap_count_valuesA(values)) )
        {
            printf("*** Warning: No values returned for dSCorePropagationData on %s\n",
                   pDN);
            _leave;
        }

        for ( i = 0; i < cVals; i++ )
        {
            // Don't convert last value to local time as it
            // is the flags field - not a real time.

            GeneralizedTimeToSystemTime(values[i],
                                        (i != (cVals - 1)),
                                        &pHistory->rTime[i]);
            pHistory->cTime += 1;
        }
    }
    _finally
    {
        if ( values )
            ldap_value_freeA(values);

        if ( ldap_message )
            ldap_msgfree(ldap_message);
    }
}

//
// Read an objects security descriptor from the directory.
//

void
ReadSD(
    DumpObject  *pdo        // IN
    )
{
    CHAR                    *pDN = pdo->name;
    SECURITY_DESCRIPTOR     **ppSD = &pdo->pSD;
    PLDAPMessage            ldap_message = NULL;
    PLDAPMessage            entry = NULL;
    CHAR                    *attrs[2];
    PSTR                    *values = NULL;
    PLDAP_BERVAL            *sd_value = NULL;
    SECURITY_INFORMATION    seInfo =   DACL_SECURITY_INFORMATION
                                     | GROUP_SECURITY_INFORMATION
                                     | OWNER_SECURITY_INFORMATION
                                     | SACL_SECURITY_INFORMATION;
    BYTE                    berValue[2*sizeof(ULONG)];
    LDAPControlA            seInfoControl = { LDAP_SERVER_SD_FLAGS_OID,
                                              { 5,
                                                (PCHAR) berValue },
                                              TRUE };
    PLDAPControlA           serverControls[2] = { &seInfoControl, NULL };
    DWORD                   dwErr;
    DWORD                   cRetry = 0;

    *ppSD = NULL;
    dwErr = 1;

    // initialize the ber val
    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE) (seInfo & 0xF);

    _try
    {

RetryReadSD:

        if ( cRetry )
        {
            seInfo &= ~SACL_SECURITY_INFORMATION;
            berValue[4] = (BYTE) (seInfo & 0xF);
            printf("*** Warning: Retrying read w/o SACL_SECURITY_INFORMATION set\n");
        }

        attrs[0] = "nTSecurityDescriptor";
        attrs[1] = NULL;

        dwErr = ldap_search_ext_sA(gldap,
                                   pDN,
                                   LDAP_SCOPE_BASE,
                                   "(objectClass=*)",
                                   attrs,
                                   0,
                                   serverControls,
                                   NULL,
                                   NULL,
                                   10000,
                                   &ldap_message);

        if ( LDAP_SUCCESS != dwErr )
        {
            printf("*** Error: Read of nTSecurityDescriptor on %s failed with 0x%x\n",
                   pDN, dwErr);
            _leave;
        }

        if (    !(entry = ldap_first_entry(gldap, ldap_message))
             || !(values = ldap_get_valuesA(gldap, entry, attrs[0]))
             || !(sd_value = ldap_get_values_lenA(gldap, ldap_message, attrs[0])) )
        {
            printf("*** Error: No values returned for nTSecurityDescriptor on %s\n",
                   pDN);

            if ( 0 == cRetry++ )
            {
                goto RetryReadSD;
            }

            _leave;
        }

        *ppSD = (SECURITY_DESCRIPTOR *) MyAlloc((*sd_value)->bv_len);

        if ( !*ppSD )
        {
            printf("Memory allocation error\n");
            _leave;
        }

        memcpy(*ppSD, (BYTE *) (*sd_value)->bv_val, (*sd_value)->bv_len);
        pdo->cbSD = (*sd_value)->bv_len;
    }
    _finally
    {
        if ( sd_value )
            ldap_value_free_len(sd_value);

        if ( values )
            ldap_value_freeA(values);

        if ( ldap_message )
            ldap_msgfree(ldap_message);
    }
}

void
CheckAcls()
{
    DWORD   i, j;
    DWORD   iClassName;
    CHAR    *pClassName;
    DWORD   dwLastError;
    DWORD   iChild;
    DWORD   iParent;
    GUID    **pClassGuids;
    DWORD   cClassGuids;

    if ( cObjects < 2 )
        return;

    // Process parent down to leaf.

    for ( i = (cObjects-1); i > 0; i-- )
    {
        iParent = i;
        iChild = i-1;

        printf("\nChecking ACL inheritance ...\n");
        printf("\tParent: %d - %s\n", iParent, rObjects[iParent].name);
        printf("\tChild:  %d - %s\n", iChild, rObjects[iChild].name);

        if ( !rObjects[iParent].pSD )
        {
            printf("*** Error: Skipping because no ACL for parent\n");
            continue;
        }

        if ( !rObjects[iChild].pSD )
        {
            printf("*** Error: Skipping because no ACL for child\n");
            continue;
        }

        if (rObjects[iChild].instanceType & IT_NC_HEAD) {
            printf("*** Skipping because child is an NC head\n");
            continue;
        }

        // get the list of class guids
        cClassGuids = rObjects[iChild].classInfo.cAuxClasses + 1;
        pClassGuids = (GUID**) MyAlloc(cClassGuids * sizeof(GUID*));
        // First, the structural class
        iClassName = rObjects[iChild].classInfo.cClasses - 1;
        pClassName = rObjects[iChild].classInfo.rClasses[iClassName];
        pClassGuids[0] = ClassNameToGuid(pClassName);
        // Then, aux classes (if any)
        for (j = 0; j < rObjects[iChild].classInfo.cAuxClasses; j++) {
            pClassName = rObjects[iChild].classInfo.rAuxClasses[j];
            pClassGuids[j+1] = ClassNameToGuid(pClassName);
        }

        if ( AclErrorNone != CheckAclInheritance(
                                    rObjects[iParent].pSD,
                                    rObjects[iChild].pSD,
                                    pClassGuids,
                                    cClassGuids,
                                    printf,             // print function ptr
                                    TRUE,               // fContinueOnError
                                    gfVerbose,          // fVerbose
                                    &dwLastError) )
        {
            // Nothing to do as errors have been dumped to screen.
        }
        else
        {
            printf("*** OK\n");
        }
        MyFree(pClassGuids);
    }
}

//
// Map invocation ID to name.
//

void
InvocationIdToName(
    DumpObject      *pdo
    )
{
    static CHAR pszConfigNC[2048] = { 0 };     // config NC buffer
    static CHAR pszFilter[4096] = { 0 };       // invocation ID search filter
    static CHAR pszServer[4096] = { 0 };       // server object DN
    DWORD       dwErr;
    CHAR        *attrs[2] = { NULL, NULL };
    LDAPMessage *ldap_message = NULL, *entry;
    PSTR        *values = NULL;
    DWORD       i, cBytes, cVals;
    DWORD       depth;
    CHAR        *pszRoot;
    CHAR        *pszFormat;
    BYTE        *rb;
    CHAR        *psz;

    pdo->metaData.pszInvocation = NULL;

    // See if we've translated it once before.

    for ( i = 0; i < cObjects; i++ )
    {
        if (    !memcmp(&rObjects[i].metaData.uuidInvocation,
                        &pdo->metaData.uuidInvocation,
                        sizeof(GUID))
             && rObjects[i].metaData.pszInvocation )
        {
            cBytes = strlen(rObjects[i].metaData.pszInvocation) + 1;

            if ( pdo->metaData.pszInvocation = (CHAR *) MyAlloc(cBytes) )
            {
                strcpy(pdo->metaData.pszInvocation,
                       rObjects[i].metaData.pszInvocation);
            }

            return;
        }
    }

    for ( i = 0; i < 3; i++ )
    {
        if ( 0 == i )
        {
            // First pass to read config container.
            if ( pszConfigNC[0] )
                continue;
            attrs[0] = "configurationNamingContext";
            pszRoot = "";
            depth = LDAP_SCOPE_BASE;
            strcpy(pszFilter, "(objectClass=*)");
            pszFormat = "Read of configurationNamingContext";
        }
        else if ( 1 == i )
        {
            // Second pass to find NTDS-DSA object.
            attrs[0] = "distinguishedName";
            pszRoot = pszConfigNC;
            depth = LDAP_SCOPE_SUBTREE;
            rb = (BYTE *) &pdo->metaData.uuidInvocation;
            sprintf(
                pszFilter,
                "(&(objectCategory=ntdsDsa)(invocationId=\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x))",
                rb[0],  rb[1],  rb[2],  rb[3],
                rb[4],  rb[5],  rb[6],  rb[7],
                rb[8],  rb[9],  rb[10], rb[11],
                rb[12], rb[13], rb[14], rb[15]);
            pszFormat = "Search by invocationID";
        }
        else
        {
            // Third pass to read dnsHostName off server.
            attrs[0] = "dnsHostName";
            pszRoot = pszServer;
            depth = LDAP_SCOPE_BASE;
            strcpy(pszFilter, "(objectClass=*)");
            pszFormat = "Read of dnsHostName";
        }

        if ( LDAP_SUCCESS != (dwErr = ldap_search_sA(
                                            gldap,
                                            pszRoot,
                                            depth,
                                            pszFilter,
                                            attrs,
                                            0,
                                            &ldap_message)) )
        {
            printf("*** Warning: %s failed with 0x%x\n", pszFormat, dwErr);
            goto Bail;
        }

        if (    !(entry = ldap_first_entry(gldap, ldap_message))
             || !(values = ldap_get_valuesA(gldap, entry, attrs[0]))
             || !(cVals = ldap_count_valuesA(values)) )
        {
            printf("*** Warning: %s failed with 0x%x\n",
                   pszFormat, LDAP_NO_RESULTS_RETURNED);
            goto Bail;
        }

        if ( 0 == i )
        {
            strcpy(pszConfigNC, values[0]);
        }
        else if ( 1 == i )
        {
            if ( psz = strchr(values[0], (int) ',') )
            {
                strcpy(pszServer, ++psz);
            }
            else
            {
                goto Bail;
            }
        }
        else
        {
            cBytes = strlen(values[0]) + 1;

            if ( pdo->metaData.pszInvocation = (CHAR *) MyAlloc(cBytes) )
            {
                strcpy(pdo->metaData.pszInvocation, values[0]);
            }
        }

        ldap_value_freeA(values);
        values = NULL;
        ldap_msgfree(ldap_message);
        ldap_message = NULL;
    }

Bail:

    if ( values )
        ldap_value_freeA(values);

    if ( ldap_message )
        ldap_msgfree(ldap_message);
}

//
// Read the replication metadata for the SD property.
//

void
ReadMeta(
    DumpObject  *pdo        // IN
    )
{
    CHAR                    *pDN = pdo->name;
    MetaData                *pmd = &pdo->metaData;
    WCHAR                   *pwszDN;
    DWORD                   dwErr;
    DS_REPL_OBJ_META_DATA   *pInfo;
    DWORD                   i;
    GUID                    *pg;
    SYSTEMTIME              sTime;

    memset(pmd, 0, sizeof(MetaData));
    
    pwszDN = (WCHAR *) malloc(sizeof(WCHAR) * (strlen(pDN) + 1));
    if (pwszDN == NULL) {
        printf("Error: unable to malloc %d bytes\n", sizeof(WCHAR) * (strlen(pDN) + 1));
        return;
    }
    
    mbstowcs(pwszDN, pDN, strlen(pDN) + 1);
    dwErr = DsReplicaGetInfoW(ghDS, DS_REPL_INFO_METADATA_FOR_OBJ,
                              pwszDN, NULL, &pInfo);
    free(pwszDN);

    if ( dwErr )
    {
        printf("Error: DsReplicaGetInfoW ==> 0x%x for %s\n",
               dwErr, pDN);
        return;
    }

    for ( i = 0; i < pInfo->cNumEntries; i++ )
    {
        if ( !_wcsicmp(pInfo->rgMetaData[i].pszAttributeName,
                       L"ntSecurityDescriptor") )
        {
            pmd->dwVersion = pInfo->rgMetaData[i].dwVersion;
            memcpy(&pmd->uuidInvocation,
                   &pInfo->rgMetaData[i].uuidLastOriginatingDsaInvocationID,
                   sizeof(UUID));
            FileTimeToSystemTime(
                   &pInfo->rgMetaData[i].ftimeLastOriginatingChange,
                   &pmd->stLastOriginatingWrite);
            GmtSystemTimeToLocalSystemTime(&pmd->stLastOriginatingWrite);
            DsReplicaFreeInfo(DS_REPL_INFO_METADATA_FOR_OBJ, (PVOID) pInfo);
            InvocationIdToName(pdo);
            return;
        }
    }

    DsReplicaFreeInfo(DS_REPL_INFO_METADATA_FOR_OBJ, (PVOID) pInfo);
    printf("*** Error: %s has no metadata for ntSecurityDescriptor\n", pDN);
}

//
// indentation routine for pretty-printing ACL dump.
//

void Indent(
    DWORD   n       // IN
    )
{
    int i = (int) (2 * n);

    while ( i-- > 0 )
        printf(" ");
}

//
// Grind through all objects and dump/analyse as indicated by args.
//

void
ProcessObjects(
    )
{
    DWORD       i;
    int         j;
    SdHistory   history;
    SYSTEMTIME  *pst;
    GUID        *pg;
    FILETIME    ft;
    UCHAR       *rFlags;
    LONGLONG    dsTime, tempTime;
    DWORD       cTime;
    SYSTEMTIME  *rTime;

    for ( i = 0; i < cObjects; i++ )
    {
        ReadMeta(&rObjects[i]);
        ReadSdHistory(&rObjects[i]);
        ReadSD(&rObjects[i]);
        ReadClasses(&rObjects[i]);
    }

    for ( i = 0; i < cObjects; i++ )
    {
        // Object name

        printf("\n");
        Indent(i);
        printf("Object:   %s\n", rObjects[i].name);

        // Object's class(es)

        if ( rObjects[i].classInfo.cClasses )
        {
            Indent(i);
            printf("Classes: ");

            for ( j = 0; j < (int) rObjects[i].classInfo.cClasses; j++ )
            {
                printf(" %s", rObjects[i].classInfo.rClasses[j]);
            }
            printf("\n");
        }

        // SD size

        if ( rObjects[i].cbSD )
        {
            Indent(i);
            printf("SD:       %d bytes\n", rObjects[i].cbSD);
        }

        // Meta data

        if ( memcmp(&gNullUuid,
                    &rObjects[i].metaData.uuidInvocation,
                    sizeof(UUID)) )
        {
            pst = &rObjects[i].metaData.stLastOriginatingWrite;
            Indent(i);
            printf("Metadata: ");
            printf("%02d/%02d/%02d %02d:%02d:%02d @ ",
                   pst->wMonth, pst->wDay, pst->wYear,
                   pst->wHour, pst->wMinute, pst->wSecond);
            if ( rObjects[i].metaData.pszInvocation )
            {
                printf("%s", rObjects[i].metaData.pszInvocation);
            }
            else
            {
                pg = &rObjects[i].metaData.uuidInvocation;
                printf("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                       pg->Data1,
                       pg->Data2,
                       pg->Data3,
                       pg->Data4[0],
                       pg->Data4[1],
                       pg->Data4[2],
                       pg->Data4[3],
                       pg->Data4[4],
                       pg->Data4[5],
                       pg->Data4[6],
                       pg->Data4[7]);
            }
            printf(" ver: %d\n", rObjects[i].metaData.dwVersion);
        }

        // SD history

        cTime = rObjects[i].history.cTime;
        rTime = rObjects[i].history.rTime;

        if ( 0 != cTime )
        {
            if ( 1 == cTime )
            {
                Indent(i);
                printf("History:  Invalid single element SD history\n");
            }
            else
            {
                // See private\ds\src\dsamain\dblayer\dbprop.c:DBAddSDPropTime
                // for an explanation of how the SD propagator log works.

                SystemTimeToFileTime(&rTime[cTime-1], &ft);
                dsTime = (LONGLONG) ft.dwLowDateTime;
                tempTime = (LONGLONG) ft.dwHighDateTime;
                dsTime |= (tempTime << 32);
                dsTime = dsTime / (10*1000*1000L);
                rFlags = (UCHAR *) &dsTime;

                Indent(i);
                printf("History:  ");
                for ( j = cTime-2; j >= 0; j-- )
                {
                    if ( j != (int) cTime-2 )
                    {
                        Indent(i);
                        printf("          ");
                    }

                    printf("%02d/%02d/%02d %02d:%02d:%02d flags(0x%x)",
                           rTime[j].wMonth, rTime[j].wDay, rTime[j].wYear,
                           rTime[j].wHour, rTime[j].wMinute, rTime[j].wSecond,
                          rFlags[j]);
                    if ( rFlags[j] & 0x1 ) printf(" SD propagation");
                    if ( rFlags[j] & 0x2 ) printf(" Ancestry propagation");
                    if ( rFlags[j] & 0x4 ) printf(" propagate to leaves");
                    printf("\n");
                }
            }
        }
    }

    // Always check ACLs.

    CheckAcls();

    // Dump SDs if requested.

    for ( i = 0; i < cObjects; i++ )
    {
        if (    (    ((0 == i) && gfDumpOne)
                  || gfDumpAll)
             && (rObjects[i].pSD) )
        {
            printf("\n\nSD for %s\n", rObjects[i].name);
            DumpSD(rObjects[i].pSD, printf, LookupGuid, LookupSid);
        }
    }
}

//
// Find the object specified and all its parents up to the NC root.
// N.B. Does not handle non-domain NCs correctly.
//

DWORD
FindObjects()
{
    DWORD           dwErr = 0;
    DS_NAME_RESULTA *pObject = NULL;
    DS_NAME_RESULTA *pDomain = NULL;
    CHAR            *pszTmp = NULL;
    DWORD           i, j, cChar;
    DWORD           cPartsObject;
    DWORD           cPartsDomain;

    __try
    {
        // First crack input name and make sure it exists.

        dwErr = DsCrackNamesA(  ghDS,
                                DS_NAME_NO_FLAGS,
                                DS_UNKNOWN_NAME,
                                DS_FQDN_1779_NAME,
                                1,
                                &gpszObject,
                                &pObject);

        if ( dwErr )
        {
            printf("DsCrackNamesA(%s) returned 0x%x\n", gpszObject, dwErr);
            __leave;
        }

        if ( pObject->rItems[0].status )
        {
            printf("DsCrackNamesA(%s) returned object error 0x%x\n",
                   gpszObject, pObject->rItems[0].status);
            dwErr = 1;
            __leave;
        }

        // Get DN of containing domain.

        pszTmp = (CHAR *) MyAlloc( strlen(pObject->rItems[0].pDomain) + 2);
        strcpy(pszTmp, pObject->rItems[0].pDomain);
        strcat(pszTmp, "/");

        dwErr = DsCrackNamesA(  ghDS,
                                DS_NAME_NO_FLAGS,
                                DS_CANONICAL_NAME,
                                DS_FQDN_1779_NAME,
                                1,
                                &pszTmp,
                                &pDomain);

        if ( dwErr || !pDomain)
        {
            printf("DsCrackNamesA(%s) returned 0x%x\n", pszTmp, dwErr);
            __leave;
        }

        if ( pDomain->rItems[0].status )
        {
            printf("DsCrackNamesA(%s) returned object error 0x%x\n",
                   pszTmp, pDomain->rItems[0].status);
            dwErr = 1;
            __leave;
        }

        printf("Input:  %s\n", gpszObject);
        printf("Object: %s\n", pObject->rItems[0].pName);
        printf("Domain: %s\n", pObject->rItems[0].pDomain);
        printf("Domain: %s\n", pDomain->rItems[0].pName);
        printf("Server: %s\n\n", gpszServer);

        // Process everything up to the domain root.
        // Don't handle escaping or anything - just work with commas.

        cPartsObject = 1;
        cChar = strlen(pObject->rItems[0].pName);
        for ( i = 0; i < cChar; i++ )
            if ( ',' == pObject->rItems[0].pName[i] )
                cPartsObject++;

        cPartsDomain = 1;
        cChar = strlen(pDomain->rItems[0].pName);
        for ( i = 0; i < cChar; i++ )
            if ( ',' == pDomain->rItems[0].pName[i] )
                cPartsDomain++;

        cObjects = cPartsObject - cPartsDomain + 1;
        rObjects = (DumpObject *) MyAlloc( cObjects * sizeof(DumpObject));
        memset(rObjects, 0, cObjects * sizeof(DumpObject));
        rObjects[0].name = (CHAR *) MyAlloc(
                                        strlen(pObject->rItems[0].pName) + 1);
        strcpy(rObjects[0].name, pObject->rItems[0].pName);

        for ( i = 1; i < cObjects; i++ )
        {
            rObjects[i].name = (CHAR *) MyAlloc(
                                            strlen(rObjects[i-1].name) + 1);
            strcpy(rObjects[i].name, strchr(rObjects[i-1].name, ',') + 1);
        }
    }
    __finally
    {
        if ( pObject ) DsFreeNameResultA(pObject);
        if ( pDomain ) DsFreeNameResultA(pDomain);
    }

    return(dwErr);
}

//
// Parse command line arguments.
//

void GetArgs(
    int     argc,
    char    **argv
    )
{
    char *arg;

    if ( argc < 3 )
    {
        goto Usage;
    }

    gpszServer = argv[1];
    gpszObject = argv[2];

    while ( --argc > 2 )
    {
        arg = argv[argc];

        if ( !_strnicmp(arg, "-domain:", 8) )
        {
            gpszDomain = &arg[8];
        }
        else if ( !_strnicmp(arg, "-user:", 6) )
        {
            gpszUser = &arg[6];
        }
        else if ( !_strnicmp(arg, "-pwd:", 5) )
        {
            if ( 5 == strlen(arg) )
                gpszPassword = gpszNullPassword;
            else
                gpszPassword = &arg[5];
        }
        else if ( !_stricmp(arg, "-dumpSD") )
        {
            gfDumpOne = TRUE;
        }
        else if ( !_stricmp(arg, "-dumpAll") )
        {
            gfDumpAll = TRUE;
        }
        else if ( !_stricmp(arg, "-debug") )
        {
            gfVerbose = TRUE;
        }
        else
        {
            goto Usage;
        }
    }

    if (    !gpszServer
         || !gpszObject )
    {
Usage:
        printf("\nUsage: %s ServerName ObjectName [options]\n",
               argv[0]);
        printf("\t options:\n");
        printf("\t\t-dumpSD               - dumps first SD              \n");
        printf("\t\t-dumpAll              - dumps all SDs               \n");
        printf("\t\t-debug                - verbose debug output        \n");
        printf("\t\t-domain:DomainName    - for specifying credentials  \n");
        printf("\t\t-user:UserName        - for specifying credentials  \n");
        printf("\t\t-pwd:Password         - for specifying credentials  \n");
        exit(1);
    }
}

void
__cdecl
main(
    int     argc,
    char    **argv
    )
{
    ULONG                   version = 3;
    SEC_WINNT_AUTH_IDENTITY creds;
    DWORD                   dwErr;
    HANDLE                  hToken = NULL;
    TOKEN_PRIVILEGES        tp, tpPrevious;
    DWORD                   tpSize;

    __try
    {
        GetArgs(argc, argv);

        printf("\n%s\nSecurity Descriptor Check Utility - build(%d)\n\n",
               VER_PRODUCTNAME_STR,
               VER_PRODUCTBUILD);

        // Adjust privileges so we can read SACL and such.

        if ( !OpenProcessToken(GetCurrentProcess(),
                               TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
                               &hToken) )
        {
            dwErr = GetLastError();
            printf("*** Error: OpenProcessTokenError ==>0x%x - continuing\n",
                   dwErr);
            printf("           This may prevent reading of the SACL\n");
        }
        else
        {
            tp.PrivilegeCount = 1;
            tp.Privileges[0].Luid.HighPart = 0;
            tp.Privileges[0].Luid.LowPart = SE_SECURITY_PRIVILEGE;
            tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            if ( !AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tpPrevious),
                                        &tpPrevious, &tpSize) )
            {
                dwErr = GetLastError();
                printf("*** Error: AdjustTokenPrivileges ==> 0x%x - continuing\n",
                       dwErr);
                printf("           This may prevent reading of the SACL\n");
            }

            CloseHandle(hToken);
        }

    	if ( !(gldap = ldap_openA(gpszServer, LDAP_PORT)) )
        {
            printf("Failed to open connection to %s\n", gpszServer);
            __leave;
        }

        ldap_set_option(gldap, LDAP_OPT_VERSION, &version);

        memset(&creds, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));
        creds.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

        if ( gpszDomain )
        {
            creds.Domain = gpszDomain;
            creds.DomainLength = strlen(gpszDomain);
        }

        if ( gpszUser )
        {
            creds.User = gpszUser;
            creds.UserLength = strlen(gpszUser);
        }

        if ( gpszPassword )
        {
            creds.Password = gpszPassword;
            creds.PasswordLength = strlen(gpszPassword);
        }

        dwErr = ldap_bind_sA(gldap, NULL, (CHAR *) &creds, LDAP_AUTH_SSPI);

        if ( LDAP_SUCCESS != dwErr )
        {
            printf("ldap_bind_sA error 0x%x\n", dwErr);
            __leave;
        }

        dwErr = DsBindWithCredA(gpszServer, NULL, &creds, &ghDS);

        if ( dwErr )
        {
            printf("DsBindWIthCredA error 0x%x\n", dwErr);
            __leave;
        }

        // We've got all the handles we want - do the real work.

        if ( !FindObjects() )
            ProcessObjects();
    }
    __finally
    {
        CleanupGlobals();
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\tapicfg\print.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    print.h

Abstract:

    This module tells us about the print library from print.c

Author:

    Brett Shirley (BrettSh) 25-Jul-2000

Revision History:

--*/
#ifdef __cplusplus
extern "C" {
#endif

void     PrintMsg(DWORD dwMessageCode, ...);

#ifdef __cplusplus
}
#endif

#include "msg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\tlog\main.c ===
#include <NTDSpch.h>
#include "tlog.h"

#include <overflow.h>

CRITICAL_SECTION csLogFile;
BOOL    fCSInit = FALSE;

BOOL 
WINAPI
DllEntry( 
   IN HINSTANCE hDll, 
   IN DWORD dwReason, 
   IN LPVOID lpvReserved 
   )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:

        if ( !InitializeCriticalSectionAndSpinCount(&csLogFile, 400) ) {
            fReturn = FALSE;
        } else {
            fCSInit = TRUE;
        }

        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH:
        DsCloseLogFile( );
        if ( fCSInit ) {
            DeleteCriticalSection(&csLogFile);
            fCSInit = FALSE;
        }
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break ;
    }

    return (fReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\tapicfg\main.c ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    tapicfg/main.c

ABSTRACT:

    Stand alone application for administering TAPI directories.  This
    file is primarily the parser for the command line utility, the 
    operations themselves are abstracted out into functions in ilsng.c

DETAILS:

CREATED:

    07/20/2000    Brett Shirley (brettsh)

REVISION HISTORY:


--*/

#include <NTDSpch.h>
#pragma hdrstop
     
#include <winldap.h>
#include <ilsng.h>
#include <assert.h>
#include <locale.h>

#include <ndnc.h>

#include "print.h"

#define DS_CON_LIB_CRT_VERSION
#include "dsconlib.h"
          
// ---------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------

       
// ---------------------------------------------------------------------
// Forward declarations 
// ---------------------------------------------------------------------

// Command Functions          
DWORD    Help(void);
DWORD    Install(WCHAR * wszServerName, WCHAR * wszPartitionDns, BOOL fForceDefault);
DWORD    Remove(WCHAR * wszPartitionDns, WCHAR * wszServerName);
DWORD    Show(WCHAR * wszDomainDns, BOOL fDefaultOnly);
DWORD    MakeDefault(WCHAR * wszPartitionDns, WCHAR * wszDomainDns);
DWORD    PublishSCP(WCHAR * wszPartitionDns, WCHAR * wszDomainDns, BOOL fForceDefault);
DWORD    RemoveSCP(WCHAR * wszPartitionDns, WCHAR * wszDomainDns);
// Helper functions
WCHAR *  wcsistr(WCHAR * wszStr, WCHAR * wszTarget);

// ---------------------------------------------------------------------
// Main Function
// ---------------------------------------------------------------------

INT __cdecl 
wmain (
    INT                argc,
    LPWSTR *           argv,
    LPWSTR *           envp
    )
/*++

Routine Description:

    This is the main, this is where it all starts up, and is the 
    first level of the parsing that happens for the tapicfg.exe 
    utility.

Arguments:

    argc (IN) - Number of arguments in argv.
    argv (IN) - The arguments from the command line.
    envp (IN) - The environmental variables from the shell.

Return value:

    INT - 0, success, otherwise error code.  This allows the program
    to be used in scripting.

--*/
{
    ULONG              i, dwRet;
    
    // The optional command line parameters
    WCHAR *            wszPartitionDns = NULL;
    WCHAR *            wszServerName = NULL;
    WCHAR *            wszDomainDns = NULL;
    BOOL               fForceDefault = FALSE;
    BOOL               fDefaultOnly = FALSE;

    // Sets the locale properly and initializes DsConLib
    DsConLibInit();

    //
    // Parse the options
    //

    if(argc < 2){
        // There is no command, lets help them out.
        PrintMsg(TAPICFG_HELP_HELP_YOURSELF);
        return(ERROR_INVALID_PARAMETER);
    }

    for(i = 2; i < (ULONG) argc; i++){

        // Determine what optional command line parameter it is.
        if(_wcsicmp(argv[i], L"/forcedefault") == 0){

            fForceDefault = TRUE;

        } else if (_wcsicmp(argv[i], L"/defaultonly") == 0) {

            fDefaultOnly = TRUE;

        } else if (wcsistr(argv[i], L"/directory:")) {

            wszPartitionDns = wcschr(argv[i], L':');
            if(wszPartitionDns == NULL ||
               wszPartitionDns[1] == L'\0'){
                wszPartitionDns = NULL;

                PrintMsg(TAPICFG_CANT_PARSE_DIRECTORY);
                PrintMsg(TAPICFG_BLANK_LINE);
                PrintMsg(TAPICFG_HELP_HELP_YOURSELF);
                return(ERROR_INVALID_PARAMETER);
            }
            wszPartitionDns++;

        } else if (wcsistr(argv[i], L"/server:")) {
            wszServerName = wcschr(argv[i], L':');
            if(wszServerName == NULL ||
               wszServerName[1] == L'\0'){
                wszServerName = NULL;

                PrintMsg(TAPICFG_CANT_PARSE_SERVER);
                PrintMsg(TAPICFG_BLANK_LINE);
                PrintMsg(TAPICFG_HELP_HELP_YOURSELF);
                return(ERROR_INVALID_PARAMETER);
            }
            wszServerName++;

        } else if (wcsistr(argv[i], L"/domain:")) {
            wszDomainDns = wcschr(argv[i], L':');
            if(wszDomainDns == NULL ||
               wszDomainDns[1] == L'\0'){
                wszDomainDns = NULL;
                
                PrintMsg(TAPICFG_CANT_PARSE_DOMAIN);
                PrintMsg(TAPICFG_BLANK_LINE);
                PrintMsg(TAPICFG_HELP_HELP_YOURSELF);
                return(ERROR_INVALID_PARAMETER);
            }
            wszDomainDns++;

        } else {

            PrintMsg(TAPICFG_CANT_PARSE_COMMAND_LINE);
            PrintMsg(TAPICFG_BLANK_LINE);
            PrintMsg(TAPICFG_HELP_HELP_YOURSELF);
            return(ERROR_INVALID_PARAMETER);

        } // End if/else kind of optional parameter.

    } // End for parse each optional parameter.

#if DBG
wprintf(L"Done with parser - %ws %ws Partition:%ws: Server:%ws: Domain:%ws:\n",
        (fForceDefault)? L"ForceDefault": L"!ForceDefault",
        (fDefaultOnly)? L"DefaultOnly": L"!DefaultOnly",
        (wszPartitionDns)? wszPartitionDns: L" ",
        (wszServerName)? wszServerName : L" ",
        (wszDomainDns)? wszDomainDns : L" ");
#endif

    //
    // Parse and call the command
    //

    assert(argv[1]);
    if (_wcsicmp(argv[1], L"install") == 0){

        dwRet = Install(wszServerName, wszPartitionDns, fForceDefault);

    } else if (_wcsicmp(argv[1], L"remove") == 0) {

        dwRet = Remove(wszPartitionDns, wszServerName);

    } else if (_wcsicmp(argv[1], L"show") == 0) {

        dwRet = Show(wszDomainDns, fDefaultOnly);

    } else if (_wcsicmp(argv[1], L"makedefault") == 0) {

        dwRet = MakeDefault(wszPartitionDns, wszDomainDns);

    } else if (_wcsicmp(argv[1], L"publishscp") == 0) {

        dwRet = PublishSCP(wszPartitionDns, wszDomainDns, fForceDefault);
    
    } else if (_wcsicmp(argv[1], L"removescp") == 0) {

        dwRet = RemoveSCP(wszPartitionDns, wszDomainDns);
    
    } else if (_wcsicmp(argv[1], L"help") == 0 ||
               _wcsicmp(argv[1], L"?") == 0 ||
               _wcsicmp(argv[1], L"/?") == 0 ||
               _wcsicmp(argv[1], L"-?") == 0){

        dwRet = Help();

    } else {

        PrintMsg(TAPICFG_BAD_COMMAND, argv[1]);
        PrintMsg(TAPICFG_BLANK_LINE);
        PrintMsg(TAPICFG_HELP_HELP_YOURSELF);
        dwRet = ERROR_INVALID_PARAMETER;

    }

    return(dwRet);
} /* wmain  */

// ---------------------------------------------------------------------
// Other/Helper Functions
// ---------------------------------------------------------------------

DWORD
GetCommonParams(
    OPTIONAL  IN      WCHAR *    wszTarget,
    OPTIONAL  OUT     LDAP **    phld,
    OPTIONAL  OUT     WCHAR **   pwszDefaultDomainDn,
    OPTIONAL  IN      WCHAR *    wszDnsIn,
    OPTIONAL  OUT     WCHAR **   pwszDnOut
    )
/*++

Routine Description:

    This is a hack of a routine that basically just collescs a whole 
    bunch of generic parsing routines that I needed.  This is called
    with all parameters being optional.

Arguments:

    Note: although all the arguments are optional, you may not specify
    NULL for all arguments.  You must specify one of these complete 
    sets of data (either all vars on the line or none on the line):
	phld & wszTarget
        pwszDefaultDomainDn & phld (& implicitly wszTarget)
        pwszDnOut & wszDnsIn 

    wszTarget (IN) - This is the string of the server to bind to, can
        be string of a domain, a server, or NULL (connect to local server).
    phld (OUT) - This is the handle gained from the bind to wszTarget.
    pwszDefaultDomainDn - If this is specified, then the caller, wants
        the default domain of the server bound to in phld.
    wszDnsIn (IN) - If the caller provids this, then they're looking to
        get the associated DN for this DNS name.
    pwszDnOut (OUT) - This is the DN cracked from the wszDnsIn.

Return value:

    an Win32 error code if any of the conversions failed.

--*/
{
    DWORD              dwRet = ERROR_SUCCESS;
    DWORD              dwLdapErr = LDAP_SUCCESS;
    WCHAR *            wszTemp = NULL;

    // Make sure they specified at least one out param.
    assert(phld || pwszDefaultDomainDn || pwszDnOut);
    // Give a certain output make sure they also have the associated
    // proper inputs.
    assert(phld && !pwszTarget);
    assert(pwszDefaultDomainDn && !phld);
    assert(pwszDnOut && !wszDnsIn);

   
    //
    // First NULL out all out params
    //

    if(phld){
        *phld = NULL;
    }
    if(pwszDefaultDomainDn){
        *pwszDefaultDomainDn = NULL;
    }
    if(pwszDnOut){
        *pwszDnOut = NULL;
    }
    
    //
    // One by One try to fill the out params.
    //

    __try{

        // LDAP Binding.
        //

        if(wszDnsIn &&
           (wszDnsIn[0] == L'D' || wszDnsIn[0] == L'd') &&
           (wszDnsIn[1] == L'C' || wszDnsIn[1] == L'c') && 
           wszDnsIn[2] == L'='){
           // Dns name should not start with DN, probably made mistake,
           // and specified DN instead of Dns NC name.
           PrintMsg(TAPICFG_BAD_DNS, wszDnsIn, ERROR_INVALID_PARAMETER);
        }
        if(pwszDnOut && wszDnsIn){
            dwRet = GetDnFromDns(wszDnsIn, pwszDnOut);
            if(dwRet){
                PrintMsg(TAPICFG_BAD_DNS, wszDnsIn, dwRet);
                __leave;
            }
            assert(pwszDnOut);
        }

        if(phld){
            // This will either bind to the domain, or to the local server if 
            // the parameter is NULL.  Either way, this is what we want.
            *phld = GetNdncLdapBinding(wszTarget, &dwLdapErr, FALSE, NULL);
            if (dwLdapErr) {

                wszTemp = ldap_err2string(dwLdapErr);
                dwRet = LdapMapErrorToWin32(dwLdapErr);

                if(wszTemp && wszTemp[0] != L'\0'){
                    if(wszTarget){       
                        PrintMsg(TAPICFG_LDAP_CONNECT_FAILURE, wszTarget, wszTemp);
                    } else {
                        PrintMsg(TAPICFG_LDAP_CONNECT_FAILURE_SERVERLESS, wszTemp);
                    }
                } else {
                    if(wszTarget){       
                        PrintMsg(TAPICFG_LDAP_CONNECT_FAILURE_SANS_ERR_STR, wszTarget, 
                                 dwRet, dwLdapErr);
                    } else {
                        PrintMsg(TAPICFG_LDAP_CONNECT_FAILURE_SERVERLESS_SANS_ERR_STR,
                                 dwRet, dwLdapErr);
                    }
                }
                __leave;
            }
            assert(*phld);
        }

        if(pwszDefaultDomainDn && *phld){
            dwLdapErr = GetRootAttr(*phld, L"defaultNamingContext", pwszDefaultDomainDn);
            if(dwLdapErr){
                PrintMsg(TAPICFG_LDAP_ERROR_DEF_DOM, ldap_err2string(dwLdapErr));
                dwRet = LdapMapErrorToWin32(dwLdapErr);
                __leave;
            }
            assert(*pwszDefaultDomainDn);
        }

    } __finally {
        if(dwRet){
            // There were errors clean up anything that may need to be.
            if(pwszDnOut && *pwszDnOut){ 
                LocalFree(*pwszDnOut);
                *pwszDnOut = NULL;
            }
            if(pwszDefaultDomainDn && *pwszDefaultDomainDn){ 
                LocalFree(*pwszDefaultDomainDn);
                *pwszDefaultDomainDn = NULL;
            }
            if(phld && *phld){
                ldap_unbind(*phld);
                *phld = NULL;
            }
        }
    }
        
    return(dwRet);
}


void
FreeCommonParams(
    IN      LDAP *     hld,
    IN      WCHAR *    wszIn1,
    IN      WCHAR *    wszIn2
    )
{
/*++

Routine Description:

    Associated free routine for GetCommonParams().  Pretty self explanatory.

--*/
    if(hld) { ldap_unbind(hld); }
    if(wszIn1) { LocalFree(wszIn1); }
    if(wszIn2) { LocalFree(wszIn2); }
}

// ---------------------------------------------------------------------
// Command Functions
// ---------------------------------------------------------------------

DWORD
Help(void)
/*++

Routine Description:

    This command/function simply prints out help for the tapicfg.exe

Return value:

    Win 32 error, always success though. ;)

--*/
{
    PrintMsg(TAPICFG_HELP_DESCRIPTION);
    PrintMsg(TAPICFG_BLANK_LINE);
    PrintMsg(TAPICFG_HELP_SYNTAX);
    PrintMsg(TAPICFG_BLANK_LINE);
    PrintMsg(TAPICFG_HELP_PARAMETERS_HEADER);
    PrintMsg(TAPICFG_BLANK_LINE);
    

    PrintMsg(TAPICFG_HELP_CMD_INSTALL);
    PrintMsg(TAPICFG_BLANK_LINE);
    
    PrintMsg(TAPICFG_HELP_CMD_REMOVE);
    PrintMsg(TAPICFG_BLANK_LINE);
    
    PrintMsg(TAPICFG_HELP_CMD_SHOW);
    PrintMsg(TAPICFG_BLANK_LINE);
    
    PrintMsg(TAPICFG_HELP_CMD_MAKEDEFAULT);
    PrintMsg(TAPICFG_BLANK_LINE);
    
    PrintMsg(TAPICFG_HELP_CMD_PUBLISHSCP);
    PrintMsg(TAPICFG_BLANK_LINE);
    
    PrintMsg(TAPICFG_HELP_CMD_REMOVESCP);
    PrintMsg(TAPICFG_BLANK_LINE);
    
    PrintMsg(TAPICFG_HELP_REMARKS);
    PrintMsg(TAPICFG_BLANK_LINE);

    return(ERROR_SUCCESS);
} // End PrintHelpScreen()

DWORD
Install(
    IN     WCHAR *     wszServerName,
    IN     WCHAR *     wszPartitionDns,
    IN     BOOL        fForceDefault
    )
/*++

Routine Description:

    This command/function continues parsing of the parameters so that
    InstallISLNG() can handle them well.

Arguments:

    wszServerName (IN) - Server name to install the TAPI Dir on.
    wszPartitionDns (IN) - DNS name of the TAPI Dir to install.
    fForceDefault (IN) - Whether to overwrite an existing Default SCP
        object with this TAPI Dir for the Default TAPI Dir.

Return value:

    A Win32 error.

--*/
{
    DWORD              dwRet = ERROR_SUCCESS;
    WCHAR *            wszPartitionDn = NULL;
    LDAP *             hld = NULL;

    //
    // Validate and Convert Arguments
    // 

    if(!wszPartitionDns){
        PrintMsg(TAPICFG_PARAM_ERROR_NO_PARTITION_NAME);
        return(ERROR_INVALID_PARAMETER);
    }

    dwRet = GetCommonParams(wszServerName, &hld, NULL, 
                            wszPartitionDns, &wszPartitionDn);
    if(dwRet){
        // GetCommomParams() already printed error.
        return(dwRet);
    }

    //
    // Call guts of command
    //

    dwRet = InstallILSNG(hld, wszPartitionDn, fForceDefault, FALSE);
    if(dwRet == ERROR_SUCCESS){
        PrintMsg(TAPICFG_SUCCESS);
    }

    FreeCommonParams(hld, wszPartitionDn, NULL);

    return(dwRet);
}

DWORD
Remove(
    IN      WCHAR *     wszPartitionDns,
    IN      WCHAR *     wszServerName
    )
/*++

Routine Description:

    This removes the TAPI Directory service from the machine on which
    it's installed.

Arguments:

    wszPartitionDns (IN) - The TAPI Directory to obliterate.

Return value:

    A Win32 error.

--*/
{
    DWORD       dwRet = ERROR_SUCCESS;
    LDAP *      hld = NULL;
    WCHAR *     wszPartitionDn = NULL;

    //
    // Validate and Convert Arguments
    // 

    if(!wszPartitionDns){
        PrintMsg(TAPICFG_PARAM_ERROR_NO_PARTITION_NAME);
        return(ERROR_INVALID_PARAMETER);
    }

    dwRet = GetCommonParams((wszServerName) ? wszServerName : wszPartitionDns, &hld, NULL, 
                            wszPartitionDns, &wszPartitionDn);
    if(dwRet){
        // GetCommonParams() already printed errors.
        if (wszServerName == NULL) {
            PrintMsg(TAPICFG_TRY_SERVER_OPTION, wszPartitionDns);
        }

        return(dwRet);
    }
    
    //
    // Call guts of command
    //

    assert(wszPartitionDn);

    dwRet = UninstallILSNG(hld, wszPartitionDn);
    dwRet = LdapMapErrorToWin32(dwRet);
    if(dwRet == ERROR_SUCCESS){
        PrintMsg(TAPICFG_SUCCESS);
    }

    FreeCommonParams(hld, wszPartitionDn, NULL);
    
    return(dwRet);
}

DWORD
Show(
    IN      WCHAR *      wszDomainDns,
    IN      BOOL         fDefaultOnly
    )
/*++

Routine Description:

    This routine prints out all the TAPI Directory as specified by thier
    SCPs.  This also specifies which one is the default TAPI Dir.

Arguments:

    wszDomainDns (IN) - The Domain to list the SCPs of.
    fDefaultOnly (IN) - Whether to only print the default SCP.

Return value:

    A Win32 error.
    
--*/
{
    DWORD        dwRet = ERROR_SUCCESS;
    LDAP *       hld = NULL;
    WCHAR *      wszDomainDn = NULL;
    
    //
    // Validate and Convert Arguments
    // 

    dwRet = GetCommonParams(wszDomainDns, &hld, 
                            (wszDomainDns) ? NULL : &wszDomainDn,
                            wszDomainDns, 
                            (wszDomainDns) ? &wszDomainDn : NULL);
    if(dwRet){
        // GetCommonParams() already printed errors.
        return(dwRet);
    }

    //
    // Call guts of command
    //

    assert(wszDomainDn);
    assert(hld);

    dwRet = ListILSNG(hld, wszDomainDn, fDefaultOnly);
    dwRet = LdapMapErrorToWin32(dwRet);
    if(dwRet == ERROR_SUCCESS){
        PrintMsg(TAPICFG_SUCCESS);
    }

    FreeCommonParams(hld, wszDomainDn, NULL);

    return(dwRet);
}

DWORD
MakeDefault(
    IN      WCHAR *       wszPartitionDns,
    IN      WCHAR *       wszDomainDns
    )
/*++

Routine Description:

    To force the Default SCP to point to the TAPI Directory specified 
    (wszPartitionDns).

Arguments:

    wszPartitionDns (IN) - The TAPI Directory name to be pointed at.
    wszDomainDns (IN) - The Domain in which to register the Default TAPI
        Directory SCP.

Return value:

    A Win32 error.                        
                      
--*/
{
    DWORD                 dwRet = ERROR_SUCCESS;
    LDAP *                hld = NULL;
    WCHAR *               wszPartitionDn = NULL;
    WCHAR *               wszDomainDn = NULL;

    //
    // Validate and Convert Arguments
    // 

    if(!wszPartitionDns){
        PrintMsg(TAPICFG_PARAM_ERROR_NO_PARTITION_NAME);
        return(ERROR_INVALID_PARAMETER);
    }

    if(wszDomainDns){
        dwRet = GetDnFromDns(wszDomainDns, &wszDomainDn);
        if(dwRet){
            PrintMsg(TAPICFG_BAD_DNS, wszDomainDns, dwRet);
            return(dwRet);
        }
        dwRet = GetCommonParams(wszDomainDns, &hld, NULL, 
                                wszPartitionDns, &wszPartitionDn);
    } else {
        dwRet = GetCommonParams(NULL, &hld, &wszDomainDn, 
                                wszPartitionDns, &wszPartitionDn);
    }

    if(dwRet){
        if(wszDomainDn) { LocalFree(wszDomainDn); }
        // GetCommonParams() already printed errors.
        return(dwRet);
    }

    //
    // Call guts of command
    //
                     
    assert(hld);
    assert(wszPartitionDn);
    assert(wszDomainDn);
    
    dwRet = ReregisterILSNG(hld, wszPartitionDn, wszDomainDn, TRUE, TRUE);
    dwRet = LdapMapErrorToWin32(dwRet);
    if(dwRet == ERROR_SUCCESS){
        PrintMsg(TAPICFG_SUCCESS);
    }

    FreeCommonParams(hld, wszDomainDn, wszPartitionDn);
                
    return(dwRet);
}

DWORD
PublishSCP(
    IN      WCHAR *       wszPartitionDns,
    IN      WCHAR *       wszDomainDns,
    IN      BOOL          fForceDefault
    )
/*++

Routine Description:

    To publish the SCPs for this TAPI Directory (wszPartitionDns) in the
    supplied domain (wszDomainDns).

Arguments:

    wszPartitionDns (IN) - The TAPI Directory name to be pointed at.
    wszDomainDns (IN) - The Domain in which to register the Default TAPI
        Directory SCP.
    fForceDefault (IN) - Whether to overwrite an existing Default SCP
        object with this TAPI Dir for the Default TAPI Dir.

Return value:

    A Win32 error.                        
                      
--*/
{
    DWORD                 dwRet = ERROR_SUCCESS;
    LDAP *                hld = NULL;
    WCHAR *               wszPartitionDn = NULL;
    WCHAR *               wszDomainDn = NULL;

    //
    // Validate and Convert Arguments
    // 

    if(!wszPartitionDns){
        PrintMsg(TAPICFG_PARAM_ERROR_NO_PARTITION_NAME);
        return(ERROR_INVALID_PARAMETER);
    }

    if(wszDomainDns){
        dwRet = GetDnFromDns(wszDomainDns, &wszDomainDn);
        if(dwRet){
            PrintMsg(TAPICFG_BAD_DNS, wszDomainDns, dwRet);
            return(dwRet);
        }
        dwRet = GetCommonParams(wszDomainDns, &hld, NULL, 
                                wszPartitionDns, &wszPartitionDn);
    } else {
        dwRet = GetCommonParams(NULL, &hld, &wszDomainDn, 
                                wszPartitionDns, &wszPartitionDn);
    }

    if(dwRet){
        // GetCommonParams() already printed errors.
        FreeCommonParams(hld, wszDomainDn, wszPartitionDn);
        return(dwRet);
    }

    //
    // Call guts of command
    //
                     
    assert(hld);
    assert(wszPartitionDn);
    assert(wszDomainDn);
    
    dwRet = ReregisterILSNG(hld, wszPartitionDn, wszDomainDn, fForceDefault, FALSE);
    dwRet = LdapMapErrorToWin32(dwRet);
    if(dwRet == ERROR_SUCCESS){
        PrintMsg(TAPICFG_SUCCESS);
    }

    FreeCommonParams(hld, wszDomainDn, wszPartitionDn);
                
    return(dwRet);
}

DWORD
RemoveSCP(
    IN      WCHAR *       wszPartitionDns,
    IN      WCHAR *       wszDomainDns
    )
/*++

Routine Description:

    To remove the SCPs for this TAPI Directory (wszPartitionDns) in the
    supplied domain (wszDomainDns)

Arguments:

    wszPartitionDns (IN) - The TAPI Directory name to be pointed at.
    wszDomainDns (IN) - The Domain in which to register the Default TAPI
        Directory SCP.

Return value:

    A Win32 error.                        
                      
--*/
{
    DWORD                 dwRet = ERROR_SUCCESS;
    LDAP *                hld = NULL;
    WCHAR *               wszPartitionDn = NULL;
    WCHAR *               wszDomainDn = NULL;

    //
    // Validate and Convert Arguments
    // 

    if(!wszPartitionDns){
        PrintMsg(TAPICFG_PARAM_ERROR_NO_PARTITION_NAME);
        return(ERROR_INVALID_PARAMETER);
    }

    if(wszDomainDns){
        dwRet = GetDnFromDns(wszDomainDns, &wszDomainDn);
        if(dwRet){
            PrintMsg(TAPICFG_BAD_DNS, wszDomainDns, dwRet);
            return(dwRet);
        }
        dwRet = GetCommonParams(wszDomainDns, &hld, NULL, 
                                wszPartitionDns, &wszPartitionDn);
    } else {
        dwRet = GetCommonParams(NULL, &hld, &wszDomainDn, 
                                wszPartitionDns, &wszPartitionDn);
    }

    if(dwRet){
        // GetCommonParams() already printed errors.
        FreeCommonParams(hld, wszDomainDn, wszPartitionDn);
        return(dwRet);
    }
    
    //
    // Call guts of command
    //
                     
    assert(hld);
    assert(wszPartitionDn);
    assert(wszDomainDn);
    
    dwRet = DeregisterILSNG(hld, wszPartitionDn, wszDomainDn);
    dwRet = LdapMapErrorToWin32(dwRet);
    if(dwRet == ERROR_SUCCESS){
        PrintMsg(TAPICFG_SUCCESS);
    }

    FreeCommonParams(hld, wszDomainDn, wszPartitionDn);
                
    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\xmlschema\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\tlog\tlog.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    tlog.h

Abstract:

    Main header file for the logging routine.

--*/

#ifndef _TLOG_H_
#define _TLOG_H_

//
// from dscommon\filelog.c
//

VOID
DsPrintRoutineV(
    IN DWORD Flags,
    IN LPSTR Format,
    va_list arglist
    );

BOOL
DsOpenLogFile(
    IN PCHAR FilePrefix,
    IN PCHAR MiddleName, 
    IN BOOL fCheckDSLOGMarker
    );

VOID
DsCloseLogFile(
    VOID
    );

extern CRITICAL_SECTION csLogFile;

#endif // _TLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\tlog\tlog.c ===
/*++

   Copyright (c) 1998 Microsoft Corporation. All rights reserved.

MODULE NAME:

    tlog.c

ABSTRACT:

    File logging routines. A lot of them copied unshamefully from
    netlogon.

--*/

#include <NTDSpch.h>
#include <dststlog.h>
#include "tlog.h"

BOOL fileOpened = FALSE;

BOOL
PrintLog(
    IN DWORD    Flags,
    IN LPSTR    Format,
    ...
    )
{

    va_list arglist;

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &csLogFile );

    if ( !fileOpened ) {
        fileOpened = DsOpenLogFile("ds", NULL, TRUE);
    }

    //
    // Simply change arguments to va_list form and call DsPrintRoutineV
    //

    va_start(arglist, Format);

    DsPrintRoutineV( Flags, Format, arglist );

    va_end(arglist);

    LeaveCriticalSection( &csLogFile );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\xmlschema\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by XMLSchema.rc
//
#define IDS_PROJNAME                    100
#define IDR_SCHEMADOC                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\xmlschema\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( XMLSchema )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( XMLSchema ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\xmlschema\schemadoc.h ===
// SchemaDoc.h : Declaration of the CSchemaDoc

#ifndef __SCHEMADOC_H_
#define __SCHEMADOC_H_

#include "resource.h"       // main symbols

#define INDENT_DSML_DIR_ENTRY		1
#define INDENT_DSML_OBJECT_ENTRY	2
#define INDENT_DSML_ATTR_ENTRY		3
#define INDENT_DSML_ATTR_VALUE		4
#define MAX_INDENT                  5   // This must be larger that max indent value

/////////////////////////////////////////////////////////////////////////////
// CSchemaDoc
//class ATL_NO_VTABLE CSchemaDoc : 
class  CSchemaDoc : public ISchemaDoc,
	public CComObjectRoot,
//	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSchemaDoc, &CLSID_SchemaDoc>,
	public ISupportErrorInfo,
//	public IDispatchImpl<ISchemaDoc, &IID_ISchemaDoc, &LIBID_XMLSCHEMALib>,
	public IADsExtension
{
public:
	CSchemaDoc();
	~CSchemaDoc();

DECLARE_REGISTRY_RESOURCEID(IDR_SCHEMADOC)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSchemaDoc)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISchemaDoc)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IADsExtension)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo); 
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
							 LCID lcid, DISPID* rgdispid);
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,	LCID lcid, WORD wFlags,
					  DISPPARAMS* pdispparams, VARIANT* pvarResult,
					  EXCEPINFO* pexcepinfo, UINT* puArgErr);

// IADsExtension
	STDMETHOD(Operate)(ULONG dwCode, VARIANT varData1, VARIANT varData2, VARIANT varData3)
	{
		HRESULT hr = S_OK;

		switch (dwCode) 
		{

			case ADS_EXT_INITCREDENTIALS:
				  // For debugging purpose you can prompt a dialog box
				  // MessageBox(NULL, "INITCRED", "ADsExt", MB_OK);
				  if (V_VT(&varData1) == VT_BSTR &&
					  varData1.bstrVal != NULL )
				  {					  
					   m_sUserName = V_BSTR(&varData1);
				  }
				  else
				  {
					  m_sUserName.Empty();
				  }

				  m_dwFlag = 0;

				  if ( V_VT(&varData3) == VT_I4 )
				  {
					  m_dwFlag = V_I4(&varData3);
				  }
				  break;
 
			default:
				  hr = E_FAIL;
				  break;
		}        

        return hr;
	}

	STDMETHOD(PrivateGetIDsOfNames)(REFIID riid, OLECHAR ** rgszNames, unsigned int cNames, LCID lcid, DISPID  * rgdispid)
	{
		
		if (rgdispid == NULL)
		{
			return E_POINTER;
		}
		return  DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
	}

 

	STDMETHOD(PrivateInvoke)(DISPID dispidMember, REFIID riid, LCID lcid,
							 WORD wFlags, DISPPARAMS * pdispparams,
							 VARIANT * pvarResult, EXCEPINFO * pexcepinfo,
							 UINT * puArgErr)
	{
		 return DispInvoke((ISchemaDoc*)this, m_pTypeInfo, dispidMember, wFlags, 
							pdispparams, pvarResult, pexcepinfo, puArgErr);
	}

	
// ISchemaDoc
public:
	STDMETHOD(SetPath_and_ID)(BSTR bstrPath, BSTR bstrName, BSTR bstrPassword);

	STDMETHOD(CreateXMLDoc)(BSTR bstrOutputFile, BSTR bstrFilter);

protected:
	HRESULT CloseXML();
	HRESULT CopyComments();
	HRESULT DisplayContainedIns(IDirectorySearch* pSearch);
	HRESULT DisplayMultiAttribute(IDirectorySearch* pSearch, LPWSTR pAttr,
								  ADS_SEARCH_HANDLE hSearch);
	HRESULT DisplayXMLAttribute(IDirectorySearch* pSearch, LPWSTR pAttr,
								ADS_SEARCH_HANDLE hSearch);

	HRESULT OpenXML(BSTR bstrFile);
	HRESULT SaveAsXMLSchema(LPWSTR szFilter);
	HRESULT WriteLine(HANDLE hFile, LPCSTR pszBuff, UINT nIndent=0);
	HRESULT Write(HANDLE hFile, LPCSTR pszBuff, UINT nIndent=0);

protected:
	CComBSTR	 m_bstrLastCN;
	ITypeInfo   *m_pTypeInfo;
	HANDLE		 m_hFile;
	HANDLE		 m_hTempFile;
	CComBSTR	 m_sDirPath;  // The path to the LDAP directory
	CComBSTR	 m_sPassword; // Used for binding to the LDAP directory
	CComBSTR	 m_sUserName; // Used for binding to the LDAP directory
	DWORD		 m_dwFlag;    // for re-authentication
};

#endif //__SCHEMADOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\xmlschema\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1F2C8C4D_7FC6_48EB_A2B8_58F9E5019E35__INCLUDED_)
#define AFX_STDAFX_H__1F2C8C4D_7FC6_48EB_A2B8_58F9E5019E35__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "activeds.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1F2C8C4D_7FC6_48EB_A2B8_58F9E5019E35__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\xmlschema\xmlschema.cpp ===
// XMLSchema.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f XMLSchemaps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "XMLSchema.h"

#include "XMLSchema_i.c"
#include "SchemaDoc.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SchemaDoc, CSchemaDoc)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_XMLSCHEMALib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\xmlschema\schemadoc.cpp ===
// SchemaDoc.cpp : Implementation of CSchemaDoc
#include "stdafx.h"
#include "sddl.h"		// Security Descriptor Definition Language info
#include "XMLSchema.h"
#include "SchemaDoc.h"

/////////////////////////////////////////////////////////////////////////////
// CSchemaDoc

// Constructor/Destructor
CSchemaDoc::CSchemaDoc()
{
	HRESULT hr;
	ITypeLib   *pITypeLib;
	m_pTypeInfo = NULL;

	m_dwFlag = 0;
	m_hFile = NULL;
	m_hTempFile = NULL;

	hr = LoadRegTypeLib(LIBID_XMLSCHEMALib, 1, 0, 
                        PRIMARYLANGID(GetSystemDefaultLCID()), &pITypeLib);

	if ( SUCCEEDED(hr) )
	{
		hr   = pITypeLib->GetTypeInfoOfGuid(IID_ISchemaDoc, &m_pTypeInfo);
	}
	pITypeLib->Release();
}

CSchemaDoc::~CSchemaDoc()
{
	if ( m_pTypeInfo )
	{
		m_pTypeInfo->Release();
	}
	CloseXML();
}

/////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP CSchemaDoc::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISchemaDoc
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//////////////////////////////////////////////////// 
// Delegating IDispatch Methods to the aggregator
//////////////////////////////////////////////////////
STDMETHODIMP CSchemaDoc::GetTypeInfoCount(UINT* pctinfo)
{
   IDispatch*	pDisp;
   HRESULT		hr;

   hr = OuterQueryInterface( IID_IDispatch, (void**) &pDisp );

   if ( SUCCEEDED(hr) )
   {
	   hr = pDisp->GetTypeInfoCount( pctinfo );
	   pDisp->Release();
   }   
   return hr;
}


STDMETHODIMP CSchemaDoc::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{
   IDispatch* pDisp;
   HRESULT    hr;

   hr = OuterQueryInterface( IID_IDispatch, (void**) &pDisp );

   if ( SUCCEEDED(hr) )
   {
	   hr = pDisp->GetTypeInfo( itinfo, lcid, pptinfo );
	   pDisp->Release();
   }
   return hr;
}

STDMETHODIMP CSchemaDoc::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
									   LCID lcid, DISPID* rgdispid)
{
   IDispatch *pDisp;
   HRESULT    hr;

   hr = OuterQueryInterface( IID_IDispatch, (void**) &pDisp );

   if ( SUCCEEDED(hr) )
   {
	   hr = pDisp->GetIDsOfNames( riid, rgszNames, cNames, lcid, rgdispid);
	   pDisp->Release();
   }
   return hr;
}

STDMETHODIMP CSchemaDoc::Invoke(DISPID dispidMember, REFIID riid,
								LCID lcid, WORD wFlags, DISPPARAMS* pdispparams,
								VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
								UINT* puArgErr)
{
   IDispatch *pDisp;
   HRESULT    hr;

   hr = OuterQueryInterface( IID_IDispatch, (void**) &pDisp );

   if ( SUCCEEDED(hr) )
   {
	   hr = pDisp->Invoke( dispidMember, riid, lcid, wFlags, pdispparams, pvarResult,
		                   pexcepinfo, puArgErr);
	   pDisp->Release();
   }
   return hr;
}

///////////////////////////////////////////////////////////////////////////////
// End delegating IDispatch Methods
///////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------
// This is the entry point for this component.  It opens the output file and
// has the requested schema components stored there.
// ---------------------------------------------------------------------------
STDMETHODIMP CSchemaDoc::CreateXMLDoc(BSTR bstrOutputFile, BSTR bstrFilter)
{
	HRESULT hr = S_OK;

	hr = OpenXML(bstrOutputFile);

	if (hr == S_OK)
	{
		hr = SaveAsXMLSchema(bstrFilter);

		if (hr == S_OK)
			CopyComments();
	}
	CloseXML();
	return hr;
} // CreateXMLDoc

// ---------------------------------------------------------------------------
// This method opens the output and temp file.  The temporary file is used to
// temporarily store the comment data.
// ---------------------------------------------------------------------------
HRESULT CSchemaDoc::OpenXML(BSTR bstrFile)
{
	HRESULT hr = S_OK;

	OFSTRUCT	of;
	HANDLE		hFile;
	TCHAR		szFilename[MAX_PATH];

	of.cBytes = sizeof(of);
	sprintf(szFilename, "%S", bstrFile);
	hFile = (HANDLE)OpenFile(szFilename, &of, OF_READWRITE);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}
    else  // The file was successfully opened
    {
		m_hFile = hFile;
		GetTempFileName(".", "XML", 0, szFilename);

    	hFile = CreateFile(szFilename, GENERIC_READ | GENERIC_WRITE,
	    				   0, NULL, CREATE_ALWAYS,
                           FILE_FLAG_DELETE_ON_CLOSE, NULL);

		if (hFile == INVALID_HANDLE_VALUE)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
		else
			m_hTempFile = hFile;

		// Move to the end of the file
		SetFilePointer(m_hFile, 0, 0, FILE_END);
    }
	return hr;
} // OpenXML

HRESULT CSchemaDoc::CloseXML()
{
	if ( m_hFile )
	{
        CloseHandle(m_hFile);
		m_hFile = NULL;
	}
	if ( m_hTempFile )
	{
        CloseHandle(m_hTempFile);
		m_hTempFile = NULL;
	}
	return S_OK;
} // CloseXML

HRESULT CSchemaDoc::WriteLine(HANDLE hFile, LPCSTR pszBuff, UINT nIndent)
{
	HRESULT hr;

	hr = Write(hFile, pszBuff, nIndent);

	if (SUCCEEDED(hr))
		hr = Write(hFile, "\r\n");

	return hr;
} // WriteLine

HRESULT CSchemaDoc::Write(HANDLE hFile, LPCSTR pszBuff, UINT nIndent)
{
	HRESULT hr = S_OK;

	if (hFile != NULL ) 
	{
		BOOL	bNoFileError = TRUE;
		DWORD	dwBytesWritten;

        if (nIndent)
        {
            char szBuf[MAX_INDENT];

            if (nIndent >= MAX_INDENT)
                nIndent = MAX_INDENT -1;

            strnset(szBuf, ' ', nIndent);
            bNoFileError = WriteFile(hFile, szBuf, nIndent, &dwBytesWritten, NULL);
        }
        if (bNoFileError)
            bNoFileError = WriteFile(hFile, pszBuff, strlen(pszBuff),
									&dwBytesWritten, NULL);

        if (bNoFileError == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
	}
    else
        hr = E_INVALIDARG;

	return hr;
} // Write

// ---------------------------------------------------------------------------
// This function displays the names of classes that the specified attribute is
// is used by.
//
// INPUTS:
//   pSearch - a pointer to the IDirectorySearch interface pointer
//
// OUTPUTS: None
//
// RETURN: the HRESULT from the request.
// ---------------------------------------------------------------------------
HRESULT CSchemaDoc::DisplayContainedIns(IDirectorySearch* pSearch)
{
	ADS_SEARCH_COLUMN	col;
	HRESULT				hr;
	ADS_SEARCH_HANDLE	hSearch;
	LPWSTR				pAttr[] = { L"CN" };
	LPWSTR				pszFilter= NULL;
	char				szBuf[2000];
	WCHAR				wBuf[2000];

	swprintf(wBuf, L"(&(|(systemMustContain=%s)(MustContain=%s)(systemMayContain=%s)(MayContain=%s))(objectCategory=classSchema))",
			 m_bstrLastCN, m_bstrLastCN, m_bstrLastCN, m_bstrLastCN);
	pszFilter = wBuf;

	hr = pSearch->ExecuteSearch(pszFilter, pAttr, 1, &hSearch);

	if (SUCCEEDED(hr))
		hr = pSearch->GetFirstRow( hSearch );

	// Read the information for each returned class
	while (SUCCEEDED(hr) && hr != S_ADS_NOMORE_ROWS)
	{
		hr = pSearch->GetColumn(hSearch, L"cn", &col);

		if (SUCCEEDED(hr))  // Display the next contained in class
		{
			Write(m_hFile, "<sd:comment-containedIn>", INDENT_DSML_ATTR_ENTRY);
			sprintf(szBuf, "%.2000S", col.pADsValues->CaseIgnoreString);
			Write(m_hFile, szBuf);
			WriteLine(m_hFile, "</sd:comment-containedIn>");
		}
		hr = pSearch->GetNextRow(hSearch);
	}
	return hr;
} // DisplayContainedIns

// ---------------------------------------------------------------------------
// This function displays an attribute that was retrieved during an LDAP
// search.  It will convert the value to a displayable form based on its type.
// This function will only display single-valued attributes.
//
// INPUTS:
//   pSearch - a pointer to the IDirectorySearch interface pointer
//   pAttr   - the name of the attribute to display.
//   hSearch - a handle to the last search results.
//
// OUTPUTS: None
//
// RETURN: the HRESULT from the request.
// ---------------------------------------------------------------------------
HRESULT CSchemaDoc::DisplayXMLAttribute(IDirectorySearch* pSearch, LPWSTR pAttr,
										ADS_SEARCH_HANDLE hSearch)
{
	ADS_SEARCH_COLUMN	col;
	HRESULT				hr;
	char				szAttr[2000];


	// Write the beginning XML tag
	if (wcscmp(pAttr, L"searchFlags") == 0)
		pAttr = L"IsIndexed";

    sprintf(szAttr, "%.2000S", pAttr);
	strcat(szAttr, ">");

	Write(m_hFile, "<sd:",INDENT_DSML_ATTR_ENTRY);
	Write(m_hFile, szAttr);

	hr = pSearch->GetColumn(hSearch, pAttr, &col);

	if (SUCCEEDED(hr))
	{
		// Get the IsIndexed value from the search flags
		if (wcscmp(pAttr, L"searchFlags") == 0)
		{
			col.pADsValues->dwType = ADSTYPE_BOOLEAN;
			col.pADsValues->Integer &= 1;
		}

		CComBSTR				bstrDesc;
		DWORD					i;
		unsigned char*			puChar;
		PISECURITY_DESCRIPTOR	pSD;
		LPTSTR					pszDesc;
      	char	                szBuf[2000];

		switch(col.pADsValues->dwType)
		{
			case ADSTYPE_BOOLEAN:
				if (col.pADsValues->Boolean == TRUE)
					Write(m_hFile, "True");
				else
					Write(m_hFile, "False");
				break;

			case ADSTYPE_INTEGER:
				sprintf(szBuf, "%d", col.pADsValues->Integer);
				hr = Write(m_hFile, szBuf);
				break;

			case ADSTYPE_NT_SECURITY_DESCRIPTOR:
				pSD = (PISECURITY_DESCRIPTOR)col.pADsValues->SecurityDescriptor.lpValue;

				if (ConvertSecurityDescriptorToStringSecurityDescriptor(pSD,
						SDDL_REVISION_1, GROUP_SECURITY_INFORMATION | 
						OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION |
						SACL_SECURITY_INFORMATION, &pszDesc, NULL ))
				{
					Write(m_hFile, pszDesc);
					LocalFree(pszDesc);
				}
				else
					Write(m_hFile, "Security descriptor");
				break;

			case ADSTYPE_OCTET_STRING:
				puChar = (unsigned char*)col.pADsValues->OctetString.lpValue;

				for (i = 0; i < col.pADsValues->OctetString.dwLength; ++i)
				{
					sprintf(&szBuf[i*2], "%02X", puChar[i]);
				}
				hr = Write(m_hFile, szBuf);
				break;

			default:
                sprintf(szBuf, "%.2000S", col.pADsValues->CaseIgnoreString);

                // Update the temp file and save the value of the
				// LDAPDisplayName for later use
				if (wcscmp(pAttr, L"LDAPDisplayName") == 0)
				{
					Write(m_hTempFile, "<sd:LDAPDisplayName>",INDENT_DSML_ATTR_ENTRY);
					Write(m_hTempFile, szBuf);
					WriteLine(m_hTempFile, "</sd:LDAPDisplayName>");

					m_bstrLastCN = col.pADsValues->CaseIgnoreString;
				}
                sprintf(szBuf, "%.2000S", col.pADsValues->CaseIgnoreString);
				hr = Write(m_hFile, szBuf);
		}
		pSearch->FreeColumn(&col);
	}
	// Write the termination XML tag
	Write(m_hFile, "</sd:");
	WriteLine(m_hFile, szAttr);

	return hr;
} // DisplayXMLAttribute

// ---------------------------------------------------------------------------
// This function displays a multi-valued attribute that was retrieved during
// an LDAP search.  It is assumed that the value is a string.
//
// INPUTS:
//   pSearch - a pointer to the IDirectorySearch interface pointer
//   pAttr   - the name of the attribute to display.
//   hSearch - a handle to the last search results.
//
// OUTPUTS: None
//
// RETURN: the HRESULT from the request.
// ---------------------------------------------------------------------------
HRESULT CSchemaDoc::DisplayMultiAttribute(IDirectorySearch* pSearch, LPWSTR pAttr,
									  ADS_SEARCH_HANDLE hSearch)
{
	ADS_SEARCH_COLUMN	col;
	HRESULT				hr;
	char				szBuf[2000];

	hr = pSearch->GetColumn(hSearch, pAttr, &col);

	if (SUCCEEDED(hr))
	{
    	DWORD i;

		for( i=0; i < col.dwNumValues; i++ )
		{
			Write(m_hFile, "<sd:AttrCommonName>", INDENT_DSML_ATTR_VALUE);
			sprintf(szBuf, "%.2000S", col.pADsValues[i].CaseIgnoreString);
			Write(m_hFile, szBuf);
			WriteLine(m_hFile, "</sd:AttrCommonName>");
		}
	}
	return hr;
} // DisplayMultiAttribute

// ---------------------------------------------------------------------------
// This function is responsible for writing the class and attribute data to
// the output file.  It first displays all the class information that matches
// the filter.  Then all of the attribute information.  The filter is assumed
// to be a prefix for the class and attribute's LDAP Display Name.
//
// INPUTS:
//   szFilter - the prefix of the classes and attributes to search for.
//
// OUTPUTS: None
//
// RETURN: the HRESULT from the request.
// ---------------------------------------------------------------------------
HRESULT CSchemaDoc::SaveAsXMLSchema(LPWSTR szFilter)
{
	// Class properties
	LPWSTR pAttrs[] = { L"CN",							// 0
		                L"DefaultObjectCategory",		// 1
						L"ObjectCategory",				// 2
						L"GovernsID",					// 3
						L"SchemaIDGUID",				// 4
						L"SubClassOf",					// 5
						L"InstanceType",				// 6
						L"DefaultSecurityDescriptor",	// 7
						L"NTSecurityDescriptor",		// 8
						L"LDAPDisplayName",				// 9
						L"AuxiliaryClass",				//10
						L"PossSuperiors",				//11
						L"RDNAttID",					//12
						L"SystemMustContain",			//13
						L"MustContain",					//14
						L"SystemMayContain",			//15
						L"MayContain"					//16
	};

	// Attribute properties
	LPWSTR pAttrs1[] = {L"CN",							// 0
						L"LDAPDisplayName",				// 1
						L"AttributeID",					// 2
		                L"AttributeSyntax",				// 3
						L"OMSyntax",					// 4
						L"AttributeSecurityGUID",		// 5
						L"SchemaIDGUID",				// 6
						L"RangeLower",					// 7
						L"RangeUpper",					// 8
						L"IsSingleValued",				// 9
						L"IsEphemeral",					//10
						L"IsMemberOfPartialAttributeSet",	//11
						L"searchFlags",					//12
						L"NTSecurityDescriptor",		//13
						L"LinkID"						//14
	};

	CComBSTR					bstrFilter;
	CComBSTR					bstrPath;
	DWORD						dwNum = sizeof(pAttrs) / sizeof(LPWSTR);
	DWORD						dwPrefInfo=2;
	HRESULT						hr;
	ADS_SEARCH_HANDLE			hSearch=NULL;
	DWORD						i;
	CComPtr<IADs>				pADs = NULL;
	CComPtr<IADsObjectOptions>	pOpt = NULL;
	ADS_SEARCHPREF_INFO			prefInfo[2];
	CComPtr<IDirectorySearch>	pSearch     = NULL;
	LPWSTR						pszFilter   = NULL;
	LPWSTR						pszPassword = NULL;
	LPWSTR						pszUserName = NULL;
	CComVariant                 varServer, var;

	// Get the user Name
	if ( m_sUserName.Length() )
	{
		pszUserName = m_sUserName;
	}
	// Get Password
	if ( m_sPassword.Length() )
	{
		pszPassword = m_sPassword;
	}
	hr = ADsOpenObject(m_sDirPath, pszUserName, pszPassword, m_dwFlag,
					   IID_IADs, (void**) &pADs);

	// Get the IDirectorySearch interface pointer
	if (SUCCEEDED(hr))
		hr = ADsOpenObject(m_sDirPath, pszUserName, pszPassword, m_dwFlag, IID_IDirectorySearch,
					  (void**) &pSearch);

	if (SUCCEEDED(hr))
	{
		// Page Size
		prefInfo[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
		prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
		prefInfo[0].vValue.Integer = 100;

		// Scope - make sure a valid scope
		prefInfo[1].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
		prefInfo[1].vValue.dwType = ADSTYPE_INTEGER;
		prefInfo[1].vValue.Integer = ADS_SCOPE_ONELEVEL;
		
		hr = pSearch->SetSearchPreference( prefInfo, dwPrefInfo);
	}

	if (SUCCEEDED(hr))
	{
		// Was a filter entered?
		if ((szFilter == NULL) || (wcslen(szFilter) == 0))
		{
			pszFilter = L"(objectCategory=classSchema)";  // Use the default
		}
		else // Build the filter to search for classes
		{
			bstrFilter = L"(&(ldapDisplayName=";

			bstrFilter.Append(szFilter);
			bstrFilter.Append(L"*)(objectCategory=classSchema))");
			pszFilter = bstrFilter;
		}
	}
	//---------------------------------------------------
	// Retrieve the information for the desired classes
	//---------------------------------------------------
	if (SUCCEEDED(hr))
		hr = pSearch->ExecuteSearch(pszFilter, pAttrs, dwNum, &hSearch);

	if (SUCCEEDED(hr))
		hr = pSearch->GetFirstRow( hSearch );

	// Read the information for each returned class
	while( SUCCEEDED(hr) && hr != S_ADS_NOMORE_ROWS )
	{
		// Display the class header tag
		WriteLine(m_hFile, "<sd:Class>",INDENT_DSML_OBJECT_ENTRY);
		WriteLine(m_hTempFile, "<sd:Class>",INDENT_DSML_OBJECT_ENTRY);
		DisplayXMLAttribute(pSearch, pAttrs[0], hSearch);

  		for (i = 1; i < 13; ++i)
			DisplayXMLAttribute(pSearch, pAttrs[i], hSearch);

		// Display "Must Contain" attributes
		WriteLine(m_hFile, "<sd:MustContain>",INDENT_DSML_ATTR_ENTRY);
		DisplayMultiAttribute(pSearch, pAttrs[13], hSearch);
		DisplayMultiAttribute(pSearch, pAttrs[14], hSearch);
		WriteLine(m_hFile, "</sd:MustContain>",INDENT_DSML_ATTR_ENTRY);

		// Display "May Contain" attributes
		WriteLine(m_hFile, "<sd:MayContain>",INDENT_DSML_ATTR_ENTRY);
		DisplayMultiAttribute(pSearch, pAttrs[15], hSearch);
		DisplayMultiAttribute(pSearch, pAttrs[16], hSearch);
		WriteLine(m_hFile, "</sd:MayContain>",INDENT_DSML_ATTR_ENTRY);

		// Display the comments
		WriteLine(m_hTempFile, "<sd:comment-updatePrivelege>Fill in.</sd:comment-updatePrivelege>",
				  INDENT_DSML_ATTR_ENTRY);
		WriteLine(m_hTempFile, "<sd:comment-updateFrequency>Fill in.</sd:comment-updateFrequency>",
				  INDENT_DSML_ATTR_ENTRY);
		WriteLine(m_hTempFile, "<sd:comment-usage>Fill in.</sd:comment-usage>",
				  INDENT_DSML_ATTR_ENTRY);

		// Display the class trailer tag
		WriteLine(m_hFile, "</sd:Class>",INDENT_DSML_OBJECT_ENTRY);
		WriteLine(m_hTempFile, "</sd:Class>",INDENT_DSML_OBJECT_ENTRY);
		hr = pSearch->GetNextRow(hSearch);
	}
	if (SUCCEEDED(hr))
	{
		//---------------------------------------------------------------
		// Retrieve the information for the desired attributes
		//----------------------------------------------------------------
		dwNum = sizeof(pAttrs1) / sizeof(LPWSTR);

		bstrFilter = L"(&(ldapDisplayName=";
		bstrFilter.Append(szFilter);
		bstrFilter.Append(L"*)(!objectCategory=classSchema))");
		pszFilter = bstrFilter;

		hr = pSearch->ExecuteSearch(pszFilter, pAttrs1, dwNum, &hSearch);
	}

	if (SUCCEEDED(hr))
		hr = pSearch->GetFirstRow( hSearch );

	// Read the information for each returned class
	while( SUCCEEDED(hr) && hr != S_ADS_NOMORE_ROWS )
	{
		// Display the attribute header tag
		WriteLine(m_hFile, "<sd:Attribute>",INDENT_DSML_OBJECT_ENTRY);
		WriteLine(m_hTempFile, "<sd:Attribute>",INDENT_DSML_OBJECT_ENTRY);
		DisplayXMLAttribute(pSearch, pAttrs1[0], hSearch);
		DisplayXMLAttribute(pSearch, pAttrs1[1], hSearch);

		// Display the comments
		WriteLine(m_hTempFile, "<sd:comment-sizeInBytes>Fill in.</sd:comment-sizeInBytes>",
				  INDENT_DSML_ATTR_ENTRY);
		DisplayContainedIns(pSearch);
		WriteLine(m_hTempFile, "<sd:comment-updatePrivelege>Fill in.</sd:comment-updatePrivelege>",
				  INDENT_DSML_ATTR_ENTRY);
		WriteLine(m_hTempFile, "<sd:comment-updateFrequency>Fill in.</sd:comment-updateFrequency>",
				  INDENT_DSML_ATTR_ENTRY);
		WriteLine(m_hTempFile, "<sd:comment-usage>Fill in.</sd:comment-usage>",
				  INDENT_DSML_ATTR_ENTRY);

		for (i = 2; i < dwNum; ++i)
			DisplayXMLAttribute(pSearch, pAttrs1[i], hSearch);

		// Display the attribute trailer tag
		WriteLine(m_hFile, "</sd:Attribute>",INDENT_DSML_OBJECT_ENTRY);
		WriteLine(m_hTempFile, "</sd:Attribute>",INDENT_DSML_OBJECT_ENTRY);
		hr = pSearch->GetNextRow(hSearch);
	}
	return S_OK;
} // SaveAsDSMLSchema

// ---------------------------------------------------------------------------
// This method copies the comments for each class and 
// ---------------------------------------------------------------------------
HRESULT CSchemaDoc::CopyComments()
{
	BOOL	bNoFileError;
    HRESULT hr = S_OK;
	DWORD	dwBytesRead;
	DWORD	dwBytesWritten;
    UCHAR   uBuff[2000];

    hr = SetFilePointer(m_hTempFile, 0, 0, FILE_BEGIN);
	WriteLine(m_hFile, "<sd:Comments>",INDENT_DSML_DIR_ENTRY);

	do
    {
        bNoFileError = ReadFile(m_hTempFile, uBuff, sizeof(uBuff), &dwBytesRead, NULL);

        if (bNoFileError)
            bNoFileError = WriteFile(m_hFile,  uBuff, dwBytesRead, &dwBytesWritten, NULL);
    }
    while (bNoFileError && (dwBytesRead == sizeof(uBuff)));

	if (bNoFileError == FALSE)
		hr = HRESULT_FROM_WIN32(GetLastError());

	WriteLine(m_hFile, "</sd:Comments>",INDENT_DSML_DIR_ENTRY);
    return hr;
} // CopyComments

// ---------------------------------------------------------------------------
// This method is used to set the LDAP path, username, and password for the
// search that will be performed.
// ---------------------------------------------------------------------------
STDMETHODIMP CSchemaDoc::SetPath_and_ID(BSTR bstrPath, BSTR bstrName, BSTR bstrPassword)
{
	m_sDirPath = bstrPath;
	m_sUserName = bstrName;
	m_sPassword = bstrPassword;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\xmlschema\xmlschema_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Tue Jan 11 17:35:31 2000
 */
/* Compiler settings for D:\SRC\XMLSchema\XMLSchema.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "XMLSchema.h"

#define TYPE_FORMAT_STRING_SIZE   37                                
#define PROC_FORMAT_STRING_SIZE   75                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ISchemaDoc, ver. 0.0,
   GUID={0xB1104680,0x42A2,0x4C84,{0x85,0x85,0x4B,0x2E,0x2A,0xB8,0x64,0x19}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISchemaDoc_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISchemaDoc_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    34
    };

static const MIDL_SERVER_INFO ISchemaDoc_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISchemaDoc_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISchemaDoc_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISchemaDoc_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(9) _ISchemaDocProxyVtbl = 
{
    &ISchemaDoc_ProxyInfo,
    &IID_ISchemaDoc,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISchemaDoc::CreateXMLDoc */ ,
    (void *)-1 /* ISchemaDoc::SetPath_and_ID */
};


static const PRPC_STUB_FUNCTION ISchemaDoc_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISchemaDocStubVtbl =
{
    &IID_ISchemaDoc,
    &ISchemaDoc_ServerInfo,
    9,
    &ISchemaDoc_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x5030118, /* MIDL Version 5.3.280 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure CreateXMLDoc */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter bstrOutputFile */

/* 16 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 18 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 20 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Parameter bstrFilter */

/* 22 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 24 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 26 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Return value */

/* 28 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 30 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 32 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetPath_and_ID */

/* 34 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 36 */	NdrFcLong( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 42 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 44 */	NdrFcShort( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0x8 ),	/* 8 */
/* 48 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter bstrPath */

/* 50 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 52 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 54 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Parameter bstrName */

/* 56 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 58 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 60 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Parameter bstrPassword */

/* 62 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 64 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 66 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Return value */

/* 68 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 70 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 72 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xc ),	/* Offset= 12 (16) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 16 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (6) */
/* 22 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 24 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 26 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x4 ),	/* 4 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _XMLSchema_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ISchemaDocProxyVtbl,
    0
};

const CInterfaceStubVtbl * _XMLSchema_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ISchemaDocStubVtbl,
    0
};

PCInterfaceName const _XMLSchema_InterfaceNamesList[] = 
{
    "ISchemaDoc",
    0
};

const IID *  _XMLSchema_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _XMLSchema_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _XMLSchema, pIID, n)

int __stdcall _XMLSchema_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_XMLSchema_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo XMLSchema_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _XMLSchema_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _XMLSchema_StubVtblList,
    (const PCInterfaceName * ) & _XMLSchema_InterfaceNamesList,
    (const IID ** ) & _XMLSchema_BaseIIDList,
    & _XMLSchema_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Tue Jan 11 17:35:31 2000
 */
/* Compiler settings for D:\SRC\XMLSchema\XMLSchema.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "XMLSchema.h"

#define TYPE_FORMAT_STRING_SIZE   39                                
#define PROC_FORMAT_STRING_SIZE   95                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ISchemaDoc, ver. 0.0,
   GUID={0xB1104680,0x42A2,0x4C84,{0x85,0x85,0x4B,0x2E,0x2A,0xB8,0x64,0x19}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISchemaDoc_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISchemaDoc_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    44
    };

static const MIDL_SERVER_INFO ISchemaDoc_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISchemaDoc_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISchemaDoc_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISchemaDoc_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(9) _ISchemaDocProxyVtbl = 
{
    &ISchemaDoc_ProxyInfo,
    &IID_ISchemaDoc,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISchemaDoc::CreateXMLDoc */ ,
    (void *)-1 /* ISchemaDoc::SetPath_and_ID */
};


static const PRPC_STUB_FUNCTION ISchemaDoc_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISchemaDocStubVtbl =
{
    &IID_ISchemaDoc,
    &ISchemaDoc_ServerInfo,
    9,
    &ISchemaDoc_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x5030118, /* MIDL Version 5.3.280 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure CreateXMLDoc */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 16 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x2 ),	/* 2 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrOutputFile */

/* 26 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 30 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrFilter */

/* 32 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 36 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Return value */

/* 38 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 40 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 42 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetPath_and_ID */

/* 44 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 46 */	NdrFcLong( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
/* 52 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x8 ),	/* 8 */
/* 58 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 60 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
/* 64 */	NdrFcShort( 0x3 ),	/* 3 */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrPath */

/* 70 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 72 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 74 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrName */

/* 76 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 78 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 80 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrPassword */

/* 82 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 84 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 86 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Return value */

/* 88 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 90 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 92 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xe ),	/* Offset= 14 (18) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 18 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 20 */	NdrFcShort( 0x8 ),	/* 8 */
/* 22 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (6) */
/* 24 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 26 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 28 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */
/* 32 */	NdrFcShort( 0x8 ),	/* 8 */
/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (2) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _XMLSchema_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ISchemaDocProxyVtbl,
    0
};

const CInterfaceStubVtbl * _XMLSchema_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ISchemaDocStubVtbl,
    0
};

PCInterfaceName const _XMLSchema_InterfaceNamesList[] = 
{
    "ISchemaDoc",
    0
};

const IID *  _XMLSchema_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _XMLSchema_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _XMLSchema, pIID, n)

int __stdcall _XMLSchema_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_XMLSchema_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo XMLSchema_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _XMLSchema_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _XMLSchema_StubVtblList,
    (const PCInterfaceName * ) & _XMLSchema_InterfaceNamesList,
    (const IID ** ) & _XMLSchema_BaseIIDList,
    & _XMLSchema_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\xmlschema\xmlschema_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Tue Jan 11 17:35:31 2000
 */
/* Compiler settings for D:\SRC\XMLSchema\XMLSchema.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISchemaDoc,0xB1104680,0x42A2,0x4C84,0x85,0x85,0x4B,0x2E,0x2A,0xB8,0x64,0x19);


MIDL_DEFINE_GUID(IID, LIBID_XMLSCHEMALib,0x4B990568,0x2DFE,0x4F1C,0xAF,0x61,0x4E,0xB7,0x10,0xFA,0x79,0x56);


MIDL_DEFINE_GUID(CLSID, CLSID_SchemaDoc,0x06A0D83D,0x711D,0x4114,0xB9,0x32,0xFD,0x36,0xA1,0xD7,0xF0,0x80);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Tue Jan 11 17:35:31 2000
 */
/* Compiler settings for D:\SRC\XMLSchema\XMLSchema.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISchemaDoc,0xB1104680,0x42A2,0x4C84,0x85,0x85,0x4B,0x2E,0x2A,0xB8,0x64,0x19);


MIDL_DEFINE_GUID(IID, LIBID_XMLSCHEMALib,0x4B990568,0x2DFE,0x4F1C,0xAF,0x61,0x4E,0xB7,0x10,0xFA,0x79,0x56);


MIDL_DEFINE_GUID(CLSID, CLSID_SchemaDoc,0x06A0D83D,0x711D,0x4114,0xB9,0x32,0xFD,0x36,0xA1,0xD7,0xF0,0x80);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\xmlschema\xmlschema.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Tue Jan 11 17:35:31 2000
 */
/* Compiler settings for D:\SRC\XMLSchema\XMLSchema.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __XMLSchema_h__
#define __XMLSchema_h__

/* Forward Declarations */ 

#ifndef __ISchemaDoc_FWD_DEFINED__
#define __ISchemaDoc_FWD_DEFINED__
typedef interface ISchemaDoc ISchemaDoc;
#endif 	/* __ISchemaDoc_FWD_DEFINED__ */


#ifndef __SchemaDoc_FWD_DEFINED__
#define __SchemaDoc_FWD_DEFINED__

#ifdef __cplusplus
typedef class SchemaDoc SchemaDoc;
#else
typedef struct SchemaDoc SchemaDoc;
#endif /* __cplusplus */

#endif 	/* __SchemaDoc_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ISchemaDoc_INTERFACE_DEFINED__
#define __ISchemaDoc_INTERFACE_DEFINED__

/* interface ISchemaDoc */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISchemaDoc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1104680-42A2-4C84-8585-4B2E2AB86419")
    ISchemaDoc : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateXMLDoc( 
            /* [in] */ BSTR bstrOutputFile,
            /* [in] */ BSTR bstrFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPath_and_ID( 
            /* [in] */ BSTR bstrPath,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaDocVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISchemaDoc __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISchemaDoc __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISchemaDoc __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISchemaDoc __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISchemaDoc __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISchemaDoc __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISchemaDoc __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateXMLDoc )( 
            ISchemaDoc __RPC_FAR * This,
            /* [in] */ BSTR bstrOutputFile,
            /* [in] */ BSTR bstrFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPath_and_ID )( 
            ISchemaDoc __RPC_FAR * This,
            /* [in] */ BSTR bstrPath,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrPassword);
        
        END_INTERFACE
    } ISchemaDocVtbl;

    interface ISchemaDoc
    {
        CONST_VTBL struct ISchemaDocVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaDoc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISchemaDoc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISchemaDoc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISchemaDoc_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISchemaDoc_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISchemaDoc_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISchemaDoc_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISchemaDoc_CreateXMLDoc(This,bstrOutputFile,bstrFilter)	\
    (This)->lpVtbl -> CreateXMLDoc(This,bstrOutputFile,bstrFilter)

#define ISchemaDoc_SetPath_and_ID(This,bstrPath,bstrName,bstrPassword)	\
    (This)->lpVtbl -> SetPath_and_ID(This,bstrPath,bstrName,bstrPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISchemaDoc_CreateXMLDoc_Proxy( 
    ISchemaDoc __RPC_FAR * This,
    /* [in] */ BSTR bstrOutputFile,
    /* [in] */ BSTR bstrFilter);


void __RPC_STUB ISchemaDoc_CreateXMLDoc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISchemaDoc_SetPath_and_ID_Proxy( 
    ISchemaDoc __RPC_FAR * This,
    /* [in] */ BSTR bstrPath,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword);


void __RPC_STUB ISchemaDoc_SetPath_and_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISchemaDoc_INTERFACE_DEFINED__ */



#ifndef __XMLSCHEMALib_LIBRARY_DEFINED__
#define __XMLSCHEMALib_LIBRARY_DEFINED__

/* library XMLSCHEMALib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_XMLSCHEMALib;

EXTERN_C const CLSID CLSID_SchemaDoc;

#ifdef __cplusplus

class DECLSPEC_UUID("06A0D83D-711D-4114-B932-FD36A1D7F080")
SchemaDoc;
#endif
#endif /* __XMLSCHEMALib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\x_list\obj_dump.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

   xList Library - obj_dump.c

Abstract:

   This provides a little library for dumping random objects or dumping
   singular attributes in an object.

Author:

    Brett Shirley (BrettSh)

Environment:

    repadmin.exe and ldp.exe

Notes:

Revision History:

    Brett Shirley   BrettSh     Aug 1st, 2002
        Created file.

--*/

#include <ntdspch.h>

//
// We'll need to include a lot of things here to get thier definitions 
// for these dumping routines.
//
#include <ntdsa.h>      // SYNTAX_INTEGER, and other stuff.
#include <objids.h>     // IT_NC_HEAD, and many other flags ...
#include <ntldap.h>     // SrvControl OID constants ...
#include <sddl.h>       // ConvertSidToStringSid()
#include <lmaccess.h>   // UF_ type flags for userAccountControl attr
#include <ntsam.h>      // GROUP_TYPE flags for groupType attr


// This library's main header files.
#include "x_list.h"
#include "x_list_p.h"
// Debugging setup
#define FILENO                          FILENO_UTIL_XLIST_OBJDUMP

//
// Global constants
//
#define DWORD_STR_SZ    (11)


// ------------------------------------------------------------------------
//
//      Table maps types
//
// ------------------------------------------------------------------------

typedef struct _FLAG_MAP_TABLE {
    DWORD               dwFlagValue;
    WCHAR *             szFlagString;
} FLAG_MAP_TABLE;
#define FLAG_MAP(flag)  { flag, L#flag },
// For enums we need a number to string mapping just like flags
#define ENUM_MAP_TABLE  FLAG_MAP_TABLE
#define ENUM_MAP        FLAG_MAP

FLAG_MAP_TABLE EmptyFlagsTable [] = {
    { 0, NULL }
};

typedef struct _OBJ_TO_FLAG_MAP_TABLE {
    WCHAR *             szObjClass;
    FLAG_MAP_TABLE *    pFlagTbl;
} OBJ_TO_FLAG_MAP_TABLE;
#define OBJ_TO_FLAG_MAP( objcls, tbl )      { objcls, tbl },

typedef struct _GUID_MAP_TABLE {
    GUID *              pGuid;
    WCHAR *             szFlagString;
} GUID_MAP_TABLE;
//#define GUID_MAP(guid)    { guid, L#guid }, 
#define GUID_MAP(guid, guidstr)    { (GUID *) guid, guidstr },


// ------------------------------------------------------------------------
//
//      Table maps (map a type to a string)
//
// ------------------------------------------------------------------------


// -------------------------------------------------------------
// instanceType attribute

// -------------------------------------------------------------
// from ds/ds/src/inc/objids.h
FLAG_MAP_TABLE instanceTypeTable [] = {
    FLAG_MAP(DS_INSTANCETYPE_IS_NC_HEAD)        // aka IT_NC_HEAD
    FLAG_MAP(IT_UNINSTANT)
    FLAG_MAP(IT_WRITE)                          // aka DS_INSTANCETYPE_NC_IS_WRITEABLE (don't use this, because every object has bit 4 set and it isn't an NC)
    FLAG_MAP(IT_NC_ABOVE)
    FLAG_MAP(DS_INSTANCETYPE_NC_COMING)         // aka IT_NC_COMING
    FLAG_MAP(DS_INSTANCETYPE_NC_GOING)          // aka IT_NC_GOING
    { 0, NULL },
};

ENUM_MAP_TABLE behaviourVersionTable [] = { 
    ENUM_MAP( DS_BEHAVIOR_WIN2000 )
    ENUM_MAP( DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS )
    ENUM_MAP( DS_BEHAVIOR_WIN2003 )
    { 0, NULL },
};

// -------------------------------------------------------------
// systemFlags attribute

// -------------------------------------------------------------
// from public/internal/ds/inc/ntdsadef.h

#define GENERIC_SYS_FLAGS           FLAG_MAP( FLAG_DISALLOW_DELETE ) \
                                    FLAG_MAP( FLAG_CONFIG_ALLOW_RENAME ) \
                                    FLAG_MAP( FLAG_CONFIG_ALLOW_MOVE ) \
                                    FLAG_MAP( FLAG_CONFIG_ALLOW_LIMITED_MOVE ) \
                                    FLAG_MAP( FLAG_DOMAIN_DISALLOW_RENAME ) \
                                    FLAG_MAP( FLAG_DOMAIN_DISALLOW_MOVE ) \
                                    FLAG_MAP( FLAG_DISALLOW_MOVE_ON_DELETE )

// Class schema object's systemFlags attribute
FLAG_MAP_TABLE SchemaClassSysFlagsTable [] = {
    // Schema systemFlags 
    FLAG_MAP( FLAG_SCHEMA_BASE_OBJECT )
    // Generic set of systemFlags
    GENERIC_SYS_FLAGS
    { 0, NULL },
};

// Attribute schema object's systemFlags attribute
FLAG_MAP_TABLE SchemaAttrSysFlagsTable [] = {
    // Schema systemFlags 
    FLAG_MAP( FLAG_ATTR_NOT_REPLICATED )
    FLAG_MAP( FLAG_ATTR_REQ_PARTIAL_SET_MEMBER )
    FLAG_MAP( FLAG_ATTR_IS_CONSTRUCTED )
    FLAG_MAP( FLAG_ATTR_IS_OPERATIONAL )
    FLAG_MAP( FLAG_SCHEMA_BASE_OBJECT )
    FLAG_MAP( FLAG_ATTR_IS_RDN )
    // Generic set of systemFlags
    GENERIC_SYS_FLAGS
    { 0, NULL },
};

// crossRef object's systemFlags attribute
FLAG_MAP_TABLE CrossRefSysFlagsTable [] = {
    // CrossRef systemFlags
    FLAG_MAP( FLAG_CR_NTDS_NC )
    FLAG_MAP( FLAG_CR_NTDS_DOMAIN )
    FLAG_MAP( FLAG_CR_NTDS_NOT_GC_REPLICATED )
    // Generic set of systemflags
    GENERIC_SYS_FLAGS
    { 0, NULL },
};

// Generic objects with a systemFlags attribute
FLAG_MAP_TABLE GenericSysFlagsTable [] = {
    // Generic set of system flags
    GENERIC_SYS_FLAGS
    { 0, NULL },
};

// Master table for systemFlags attributes.
OBJ_TO_FLAG_MAP_TABLE SystemFlagsTable [] = {
    OBJ_TO_FLAG_MAP( L"crossRef",           CrossRefSysFlagsTable )
    OBJ_TO_FLAG_MAP( L"classSchema",        SchemaClassSysFlagsTable  )
    OBJ_TO_FLAG_MAP( L"attributeSchema",    SchemaAttrSysFlagsTable   )
    { NULL, GenericSysFlagsTable }
};

// -------------------------------------------------------------
// wellKnownObjects attribute
// -------------------------------------------------------------
// from public\sdk\inc\ntdsapi.h

GUID_MAP_TABLE WellKnownObjects [] = {
    GUID_MAP( GUID_USERS_CONTAINER_BYTE , GUID_USERS_CONTAINER_W )
    // FUTURE-2002/08/16-BrettSh Be nice to make guids turn into the strings
    // for thier constants.  Need to complete table and a mapGuid function.
};

// -------------------------------------------------------------
// Options attribute
// -------------------------------------------------------------
// from public\sdk\inc\ntdsapi.h

// NTDS Settings (nTDSDSA) object's Options attribute
FLAG_MAP_TABLE DsaSettingsOptionsTable [] = {
    FLAG_MAP( NTDSDSA_OPT_IS_GC )
    FLAG_MAP( NTDSDSA_OPT_DISABLE_INBOUND_REPL )
    FLAG_MAP( NTDSDSA_OPT_DISABLE_OUTBOUND_REPL )
    FLAG_MAP( NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE )
    { 0, NULL },
};

// NTDS Site Settings object's Options attribute
FLAG_MAP_TABLE SiteSettingsOptionsTable [] = {
    FLAG_MAP( NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED )
    FLAG_MAP( NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED )
    FLAG_MAP( NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED )
    FLAG_MAP( NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED )
    FLAG_MAP( NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED )
    FLAG_MAP( NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED )
    FLAG_MAP( NTDSSETTINGS_OPT_FORCE_KCC_WHISTLER_BEHAVIOR )
    FLAG_MAP( NTDSSETTINGS_OPT_FORCE_KCC_W2K_ELECTION )
    FLAG_MAP( NTDSSETTINGS_OPT_IS_RAND_BH_SELECTION_DISABLED )
    FLAG_MAP( NTDSSETTINGS_OPT_IS_SCHEDULE_HASHING_ENABLED )
    FLAG_MAP( NTDSSETTINGS_OPT_IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED )
    { 0, NULL },
};

FLAG_MAP_TABLE NtdsConnObjOptionsTable [] = {
    FLAG_MAP( NTDSCONN_OPT_IS_GENERATED )
    FLAG_MAP( NTDSCONN_OPT_TWOWAY_SYNC )
    FLAG_MAP( NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT )
    FLAG_MAP( NTDSCONN_OPT_USE_NOTIFY )
    FLAG_MAP( NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION )
    FLAG_MAP( NTDSCONN_OPT_USER_OWNED_SCHEDULE )
    { 0, NULL },
};


FLAG_MAP_TABLE InterSiteTransportObjOptionsTable [] = {
    FLAG_MAP( NTDSTRANSPORT_OPT_IGNORE_SCHEDULES )
    FLAG_MAP( NTDSTRANSPORT_OPT_BRIDGES_REQUIRED )
    { 0, NULL },
};

FLAG_MAP_TABLE SiteConnectionObjOptionsTable [] = {
    FLAG_MAP( NTDSSITECONN_OPT_USE_NOTIFY )
    FLAG_MAP( NTDSSITECONN_OPT_TWOWAY_SYNC )
    FLAG_MAP( NTDSSITECONN_OPT_DISABLE_COMPRESSION )
    { 0, NULL },
};

FLAG_MAP_TABLE SiteLinkObjOptionsTable [] = {
    FLAG_MAP( NTDSSITELINK_OPT_USE_NOTIFY )
    FLAG_MAP( NTDSSITELINK_OPT_TWOWAY_SYNC )
    FLAG_MAP( NTDSSITELINK_OPT_DISABLE_COMPRESSION )
    { 0, NULL },
};

// Master table for options attributes.
OBJ_TO_FLAG_MAP_TABLE OptionsFlagsTable [] = {
    OBJ_TO_FLAG_MAP( L"ntDSSiteSettings",   SiteSettingsOptionsTable    )
    OBJ_TO_FLAG_MAP( L"nTDSDSA",            DsaSettingsOptionsTable     )
    OBJ_TO_FLAG_MAP( L"nTDSConnection",     NtdsConnObjOptionsTable     )
    OBJ_TO_FLAG_MAP( L"interSiteTransport", InterSiteTransportObjOptionsTable )
    OBJ_TO_FLAG_MAP( L"siteConnection",     SiteConnectionObjOptionsTable )
    OBJ_TO_FLAG_MAP( L"siteLink",           SiteLinkObjOptionsTable     )
    { NULL, EmptyFlagsTable } // Must have a valid table 
};


// -------------------------------------------------------------
// userAccountControl attribute
// -------------------------------------------------------------
// from public\sdk\inc\lmaccess.h

FLAG_MAP_TABLE UserAccountControlFlags [] = {
    FLAG_MAP( UF_SCRIPT )
    FLAG_MAP( UF_ACCOUNTDISABLE )
    FLAG_MAP( UF_HOMEDIR_REQUIRED )
    FLAG_MAP( UF_LOCKOUT )
    FLAG_MAP( UF_PASSWD_NOTREQD )
    FLAG_MAP( UF_PASSWD_CANT_CHANGE )
    FLAG_MAP( UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED )
    FLAG_MAP( UF_TEMP_DUPLICATE_ACCOUNT )
    FLAG_MAP( UF_NORMAL_ACCOUNT )
    FLAG_MAP( UF_INTERDOMAIN_TRUST_ACCOUNT )
    FLAG_MAP( UF_WORKSTATION_TRUST_ACCOUNT )
    FLAG_MAP( UF_SERVER_TRUST_ACCOUNT )
    FLAG_MAP( UF_DONT_EXPIRE_PASSWD )
    FLAG_MAP( UF_MNS_LOGON_ACCOUNT )
    FLAG_MAP( UF_SMARTCARD_REQUIRED )
    FLAG_MAP( UF_TRUSTED_FOR_DELEGATION )
    FLAG_MAP( UF_NOT_DELEGATED )
    FLAG_MAP( UF_USE_DES_KEY_ONLY )
    FLAG_MAP( UF_DONT_REQUIRE_PREAUTH )
    FLAG_MAP( UF_PASSWORD_EXPIRED )
    FLAG_MAP( UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION )
    { 0, NULL }
};

// FUTURE-2002/08/19-BrettSh - It might be interesting to enahance the
// mapFlags mechanism to handle shortcut defines like these:
// #define UF_MACHINE_ACCOUNT_MASK  ( UF_INTERDOMAIN_TRUST_ACCOUNT | \
//                                   UF_WORKSTATION_TRUST_ACCOUNT | \
//                                   UF_SERVER_TRUST_ACCOUNT )
// #define UF_ACCOUNT_TYPE_MASK         ( \
//                     UF_TEMP_DUPLICATE_ACCOUNT | \
//                     UF_NORMAL_ACCOUNT | \
//                     UF_INTERDOMAIN_TRUST_ACCOUNT | \
//                     UF_WORKSTATION_TRUST_ACCOUNT | \
//                    UF_SERVER_TRUST_ACCOUNT \
//                 )


// -------------------------------------------------------------
// groupType attribute
// -------------------------------------------------------------
// from public\sdk\inc\ntsam.h

FLAG_MAP_TABLE GroupTypeFlags [] = {
    FLAG_MAP( GROUP_TYPE_BUILTIN_LOCAL_GROUP )
    FLAG_MAP( GROUP_TYPE_ACCOUNT_GROUP )
    FLAG_MAP( GROUP_TYPE_RESOURCE_GROUP )
    FLAG_MAP( GROUP_TYPE_UNIVERSAL_GROUP )
    FLAG_MAP( GROUP_TYPE_APP_BASIC_GROUP )
    FLAG_MAP( GROUP_TYPE_APP_QUERY_GROUP )
    FLAG_MAP( GROUP_TYPE_SECURITY_ENABLED )
    { 0, NULL }
};


// ------------------------------------------------------------------------
//
//      mapping functions types
//
// ------------------------------------------------------------------------

typedef ULONG (ATTR_MAP_FUNC)(
    WCHAR * szAttr, 
    WCHAR ** aszzObjClasses, 
    PBYTE  pbValue, 
    DWORD cbValue, 
    OBJ_DUMP_OPTIONS * pObjDumpOptions,
    void * pTblData, 
    WCHAR ** pszDispValue);


/*++

    "mapping functions"

Routine Description:

    This isn't a function header for just one routine this is THE function header
    for all the "mapping functions" below (like mapFlagsValue or mapSid).  The 
    function name is surounded in a macro, so that if we ever need to add an 
    argument, we'll have no trouble doing that.
    
    The types of each of these arguments is spelled out in ATTR_MAP_FUNC just
    above.
    
    Every function is supposed to behave the same, and is accessed through
    the Master Attribute table map below.  Basically the function takes several
    in parameters and constructs and allocates a string in pszDispValues that
    will print out a friendly readable format for the value.
    
    For attributes that may have a contextually specific attribute decoding, 
    depending on say the object's objectclass, can use the pTblData to store
    another sub-table that they might wish to pass along with the decoding of
    that attribute.  See mapVariableFlagsValue for an example of this.
    
Arguments:

    szAttr              - The name of the attribute to dump.
    aszzObjClasses (IN) - The objectClass of the object this attribute came from.
    pbValue (IN)        - The attribute value as purely returned by LDAP.
    cbValue (IN)        - Length of buffer pointed to by pbValue
    pObjDumpOptions (IN) - Dump options as specified by the user.
    pTblData (IN)       - Extra data from the Master Attribute Table map
    pszDispValue (OUT)  - LocalAlloc'd friendly display string.

Return Value:

    How normal error conditions should be returned:
        return( xListSetNoMem() );
        return( xListSetBadParam() );
        return( xListSetReason( XLIST_ERR_ODUMP_UNMAPPABLE_BLOB ) );

    Some special reason codes that can be returned and will be turned into a 
    friendly localized string:
        return( xListSetReason( XLIST_ERR_ODUMP_NEVER ) );
        return( xListSetReason( XLIST_ERR_ODUMP_NONE  ) );

--*/
#define ATTR_MAP_FUNC_DECL(func)        ULONG func(WCHAR * szAttr, WCHAR ** aszzObjClasses, PBYTE pbValue, DWORD cbValue, OBJ_DUMP_OPTIONS * pObjDumpOptions, void * pTblData, WCHAR ** pszDispValue)



// ------------------------------------------------------------------------
//
//      actual mapping functions
//
// ------------------------------------------------------------------------

// -------------------------------------------------------------
// Generic processing functions
// -------------------------------------------------------------

ATTR_MAP_FUNC_DECL(mapFlagsValue)
{
    #define MAP_FLAG_SEPERATOR      L" | "
    #define MAP_FLAG_HDR            L"0x%X = ( "
    #define MAP_FLAG_HDR_LEFT_OVERS L"0x%X = ( 0x%X"
    #define MAP_FLAG_TAIL           L" )"
    FLAG_MAP_TABLE *    aFlagsTbl = (FLAG_MAP_TABLE *) pTblData;
    DWORD               cbDispValue = 0;
    DWORD               dwRet, dwFlags, dwLeftFlags;
    ULONG               i;
    HRESULT             hr;
#if DBG
    DWORD               dwExclusive = 0;
#endif
    
    Assert(pbValue);

    // Get value
    dwFlags = atoi((CHAR *)pbValue);
    dwLeftFlags = dwFlags;

    // Count size of friendly string.
    for (i = 0; aFlagsTbl[i].szFlagString; i++) {
#if DBG
        // This just tests a flag isn't in a flag table twice ...
        Assert(!(dwExclusive & aFlagsTbl[i].dwFlagValue));
        dwExclusive |= aFlagsTbl[i].dwFlagValue;
#endif
        if (aFlagsTbl[i].dwFlagValue == (aFlagsTbl[i].dwFlagValue & dwFlags)) {
            cbDispValue += ((wcslen(MAP_FLAG_SEPERATOR) + wcslen(aFlagsTbl[i].szFlagString)) * sizeof(WCHAR));
            dwLeftFlags &= ~aFlagsTbl[i].dwFlagValue;
        }
    }
    // Worst possible case.                                    ( 16 is for DWORD in hex * 2 )
    cbDispValue += ((wcslen(MAP_FLAG_HDR_LEFT_OVERS) + wcslen(MAP_FLAG_TAIL) + 16 + 1) * sizeof(WCHAR));

    //Assert(dwLeftFlags == 0);

    // Alloc return value.
    *pszDispValue = LocalAlloc(LMEM_FIXED, cbDispValue);
    if (*pszDispValue == NULL) {
        return(xListSetNoMem());
    }

    // Construct the friendly string.
    if (dwLeftFlags) {
        hr = StringCbPrintf(*pszDispValue, cbDispValue, MAP_FLAG_HDR_LEFT_OVERS , dwFlags, dwLeftFlags);
        Assert(SUCCEEDED(hr));
        if (dwFlags != dwLeftFlags) { // means there are some constants to do.
            hr = StringCbCat(*pszDispValue, cbDispValue, MAP_FLAG_SEPERATOR);
            Assert(SUCCEEDED(hr));
        }
    } else {
        hr = StringCbPrintf(*pszDispValue, cbDispValue, MAP_FLAG_HDR, dwFlags);
        Assert(SUCCEEDED(hr));
    }
    dwLeftFlags = FALSE; // Now we use this var to mean we're on the first constant.
    for (i = 0; aFlagsTbl[i].szFlagString; i++) {
        if (aFlagsTbl[i].dwFlagValue == (aFlagsTbl[i].dwFlagValue & dwFlags)) {
            if (dwLeftFlags != FALSE) {
                hr = StringCbCat(*pszDispValue, cbDispValue, MAP_FLAG_SEPERATOR);
                Assert(SUCCEEDED(hr));
            }
            dwLeftFlags = TRUE;
            hr = StringCbCat(*pszDispValue, cbDispValue, aFlagsTbl[i].szFlagString);
            Assert(SUCCEEDED(hr));
        }
    }
    hr = StringCbCat(*pszDispValue, cbDispValue, MAP_FLAG_TAIL);
    Assert(SUCCEEDED(hr));

    return(0);
}

ATTR_MAP_FUNC_DECL(mapEnumValue)
{
    #define MAP_CONST_STR           L"%d = ( %ws )"
    #define MAP_UNKNOWN             L"%d"
    ENUM_MAP_TABLE *    aEnumTbl = (ENUM_MAP_TABLE *) pTblData;
    DWORD               cbDispValue = 0;
    DWORD               dwConst;
    ULONG               i;
    HRESULT             hr;
    
    Assert(pbValue);

    // Get value
    dwConst = atoi((CHAR *)pbValue);
                                
    // Count size of friendly string.
    for (i = 0; aEnumTbl[i].szFlagString; i++) {
        if (aEnumTbl[i].dwFlagValue == dwConst) {
            break;
        }
    }
    if (aEnumTbl[i].szFlagString) {
        cbDispValue += ((wcslen(MAP_CONST_STR) + wcslen(aEnumTbl[i].szFlagString) + 11) * sizeof(WCHAR));
    } else {
        cbDispValue += ((wcslen(MAP_UNKNOWN) + 11) * sizeof(WCHAR));
    }
    *pszDispValue = LocalAlloc(LMEM_FIXED, cbDispValue);
    if (*pszDispValue == NULL) {
        return(xListSetNoMem());
    }

    if (aEnumTbl[i].szFlagString) {
        hr = StringCbPrintf(*pszDispValue, cbDispValue, MAP_CONST_STR, dwConst, aEnumTbl[i].szFlagString);
    } else {
        hr = StringCbPrintf(*pszDispValue, cbDispValue, MAP_UNKNOWN, dwConst);
    }
    Assert(SUCCEEDED(hr));

    return(0);
    #undef MAP_CONST_STR
    #undef MAP_UNKNOWN
}


ATTR_MAP_FUNC_DECL(mapVariableFlagsValue)
// Some attributes have variable flag meanings, depending on objectClass it's on.
// pTblData should be a pointer to OBJ_TO_FLAG_MAP_TABLE
{
    ULONG i, j;
    OBJ_TO_FLAG_MAP_TABLE * pTbl = (OBJ_TO_FLAG_MAP_TABLE *) pTblData;

    if (aszzObjClasses) {
        for (i = 0; aszzObjClasses[i] != NULL; i++) {
            for (j = 0; pTbl[j].szObjClass; j++) {
                if (0 == _wcsicmp(aszzObjClasses[i], pTbl[j].szObjClass)) {
                    // Found our target ...
                    break;
                }
            }
            if (pTbl[j].szObjClass != NULL) {
                // Found our target in the inner loop ...
                break;
            }
        }
    } else {
        // Get to end to get the default flag map table ...
        for (j = 0; pTbl[j].szObjClass; j++){
            ; // Do nothing ...
        }
    }

    return(mapFlagsValue(szAttr, aszzObjClasses, 
                         pbValue, cbValue, 
                         pObjDumpOptions, pTbl[j].pFlagTbl, 
                         pszDispValue));
}

ATTR_MAP_FUNC_DECL(mapGuidValue)
{
    DWORD err;
    WCHAR * szGuid = NULL;

    err = UuidToStringW((GUID*)pbValue, &szGuid);
    if(err != RPC_S_OK || 
       szGuid == NULL){  
        xListEnsureNull(szGuid);
        err = xListSetBadParamE(err);
    } else {
        xListQuickStrCopy(*pszDispValue, szGuid, err, ;);
    }
    RpcStringFree( &szGuid );
    return(err);
}

DWORD
mapSystemTimeHelper(
    SYSTEMTIME * pSysTime,
    WCHAR **     pszDispValue
    )
// Maps system time structure into a nice string.
// Returns: an xList Return Code.
{
    SYSTEMTIME localTime;
    TIME_ZONE_INFORMATION tz;
    BOOL bstatus;
    DWORD err;
    DWORD cbDispValue;
    HRESULT hr;
    WCHAR szTimeTemplate[] = L"%02d/%02d/%d %02d:%02d:%02d %s %s";

    err = GetTimeZoneInformation(&tz);
    if ( err == TIME_ZONE_ID_INVALID ||
         err == TIME_ZONE_ID_UNKNOWN ){
        Assert(!"Does this happen?");
        return(xListSetBadParam());
    }
    bstatus = SystemTimeToTzSpecificLocalTime(&tz,
                                              pSysTime,
                                              &localTime);
    if (!bstatus) {
        // default to UNC
        StringCbPrintf(tz.StandardName, sizeof(tz.StandardName), L"UNC");
        StringCbPrintf(tz.DaylightName, sizeof(tz.DaylightName), L"");
        localTime.wMonth  = pSysTime->wMonth;
        localTime.wDay    = pSysTime->wDay;
        localTime.wYear   = pSysTime->wYear;
        localTime.wHour   = pSysTime->wHour;
        localTime.wMinute = pSysTime->wMinute;
        localTime.wSecond = pSysTime->wSecond;
    }

    cbDispValue = wcslen(szTimeTemplate) + wcslen(tz.StandardName) + wcslen(tz.DaylightName);
    cbDispValue += CCH_MAX_ULONG_SZ * 6; // little over allocated
    cbDispValue *= sizeof(WCHAR);
    *pszDispValue = LocalAlloc(LPTR, cbDispValue);
    if (*pszDispValue == NULL) {
        return(xListSetNoMem());
    }
    hr = StringCbPrintf(*pszDispValue, cbDispValue,
                   szTimeTemplate, 
                   localTime.wMonth,
                   localTime.wDay,
                   localTime.wYear,
                   localTime.wHour,
                   localTime.wMinute,
                   localTime.wSecond,
                   tz.StandardName,
                   tz.DaylightName);
    Assert(SUCCEEDED(hr));

    return(0);
}

ATTR_MAP_FUNC_DECL(mapGeneralizedTime)
{
    SYSTEMTIME sysTime;
    DWORD err;
                                
    if (0 == _stricmp(pbValue, "16010101000001.0Z")) {
        // Not 100% sure this means never?  May depend on the
        // attribute ...???  If so we'll need to special case
        // this for different types of attributes.
        return(XLIST_ERR_ODUMP_NEVER); 
    }

    err = GeneralizedTimeToSystemTimeA((CHAR *)pbValue, &sysTime);
    if (err) {
        Assert(!"Does this ever really happen?");
        return(xListSetBadParamE(err));
    }

    err = mapSystemTimeHelper(&sysTime, pszDispValue);
    // sets an xList Return Code
    Assert(err == 0 || pszDispValue != NULL);

    return(err);
}



ATTR_MAP_FUNC_DECL(mapDSTime)
{
    SYSTEMTIME sysTime;
    DWORD err;

    err = DSTimeToSystemTime(pbValue, &sysTime);
    if (err != ERROR_SUCCESS) {
        return(xListSetBadParamE(err));
    }

    err = mapSystemTimeHelper(&sysTime, pszDispValue);
    // sets an xList Return Code
    return(err);
}


ATTR_MAP_FUNC_DECL(mapDuration)
{
    //   a value of -9223372036854775808 is never ... 
    __int64     lTemp;
    ULONG       cbLen;  
    DWORD       err;

    lTemp = _atoi64 (pbValue);

    if (lTemp > 0x8000000000000000){
        lTemp = lTemp * -1;
        lTemp = lTemp / 10000000;		
        cbLen = 40; // enough for maximum duration.
        *pszDispValue = LocalAlloc(LMEM_FIXED, cbLen);
        if (*pszDispValue == NULL) {
            return(xListSetNoMem());
        }
        err = StringCbPrintf(*pszDispValue, cbLen, L"%ld", lTemp);
        Assert(SUCCEEDED(err));
    } else {
        return(XLIST_ERR_ODUMP_NONE);
    }

    return(0);
}

ATTR_MAP_FUNC_DECL(mapSid)
{
    DWORD dwRet;

    // FUTURE-2002/08/16-BrettSh - Could make a much better SID function, and do
    // things like get the domain if availabe, or map the well know sids
    // to things like "BUILTIN\Administrator", etc ...
    dwRet = ConvertSidToStringSid(pbValue, pszDispValue);
    if (dwRet == 0 || *pszDispValue == NULL) {
        // Failure
        dwRet = GetLastError();
        xListEnsureError(dwRet);
        xListSetBadParamE(dwRet);
    } else {
        dwRet = ERROR_SUCCESS; // success
    }

    return(dwRet);
}

ATTR_MAP_FUNC_DECL(mapPartialAttributeSet)
{
    #define szHeader        L"{ dwVersion = %lu; dwFlag = %lu; V1.cAttrs = %lu, V1.rgPartialAttr = "
    #define szHeaderLong    L"{ dwVersion = %lu;\n\tdwFlag = %lu;\n\tV1.cAttrs = %lu,\n\tV1.rgPartialAttr = "
    #define szEntry         L" %X,"
    #define szEntryLong     L"\n\t\t%X"
    #define szFooter        L" };"
    ULONG i, cTemp;
    WCHAR * szBuffTemp;
    PARTIAL_ATTR_VECTOR *pPAS = (PARTIAL_ATTR_VECTOR*) pbValue;

    if (cbValue < sizeof(PARTIAL_ATTR_VECTOR)) {
        return(xListSetReason(XLIST_ERR_ODUMP_UNMAPPABLE_BLOB));
    } else if (pPAS->dwVersion != 1) {
        return(xListSetReason(XLIST_ERR_ODUMP_UNMAPPABLE_BLOB));
    } else {
        cbValue = pPAS->V1.cAttrs;
        cbValue *= (DWORD_STR_SZ + wcslen(szEntryLong));
        cbValue += (wcslen(szHeaderLong) + wcslen(szFooter));
        cbValue *= sizeof(WCHAR);

        *pszDispValue = LocalAlloc(LMEM_FIXED, cbValue);
        if (*pszDispValue == NULL) {
            return(xListSetNoMem());
        }
        szBuffTemp = *pszDispValue;

        cTemp = StringCbPrintf(szBuffTemp, cbValue, 
                           (pObjDumpOptions->dwFlags & OBJ_DUMP_VAL_LONG_BLOB_OUTPUT) ? 
                                szHeaderLong: szHeader,
                           pPAS->dwVersion, pPAS->dwReserved1, pPAS->V1.cAttrs);
        Assert(SUCCEEDED(cTemp));

        cTemp = wcslen(szBuffTemp);
        cbValue -= cTemp * sizeof(WCHAR);
        szBuffTemp = &(szBuffTemp[cTemp]);

        for (i = 0; i < pPAS->V1.cAttrs; i++) {
            cTemp = StringCbPrintf(szBuffTemp, cbValue, 
                               (pObjDumpOptions->dwFlags & OBJ_DUMP_VAL_LONG_BLOB_OUTPUT) ? 
                                    szEntryLong: szEntry, pPAS->V1.rgPartialAttr[i]);
            Assert(SUCCEEDED(cTemp));

            cTemp = wcslen(szBuffTemp);
            cbValue -= cTemp * sizeof(WCHAR);
            szBuffTemp = &(szBuffTemp[cTemp]);
        }

        cTemp = StringCbPrintf(szBuffTemp, cbValue, szFooter);
        Assert(SUCCEEDED(cTemp));

        cTemp = wcslen(szBuffTemp);
        cbValue -= cTemp * sizeof(WCHAR);
        szBuffTemp = &(szBuffTemp[cTemp]);

    }

    #undef szHeader
    #undef szHeaderLong
    #undef szEntry
    #undef szEntryLong
    #undef szFooter
    return(0);
}

//
// ntdsa\src\samcache.c
//
typedef struct _GROUP_CACHE_V1 {

    //
    // SIDs are placed in SidStart in the following order
    //
    DWORD accountCount;
    DWORD accountSidHistoryCount;
    DWORD universalCount;
    DWORD universalSidHistoryCount;
    BYTE  SidStart[1];
    
}GROUP_CACHE_V1;

typedef struct {

    DWORD Version;
    union {
        GROUP_CACHE_V1 V1;
    };

}GROUP_CACHE_BLOB;


ATTR_MAP_FUNC_DECL(mapMsDsCachedMembership)
{
#define szHeader        L"{ accountCount = %d; accountSidHistoryCount = %d; universalCount = %d; universalSidHistoryCount = %d; "
#define szHeaderLong    L"{ accountCount = %d;\n\taccountSidHistoryCount = %d;\n\tuniversalCount = %d;\n\tuniversalSidHistoryCount = %d;"
#define szEntry         L" %ws[%d] = %ws;"
#define szEntryLong     L"\n\t%ws[%d] = %ws;"
#define szFooter        L" };"
#define szFooterLong    L"\n\t};"
    ULONG i, cSids, cbSize, cchTemp;
    GROUP_CACHE_BLOB *pBlob = (GROUP_CACHE_BLOB*)pbValue;
    UCHAR *pTemp;
    WCHAR * szOutBuf;
    WCHAR * szBuffLeft;
    DWORD   cbBuffLeft;
    WCHAR * szTempStrSid;
    DWORD dwRet = ERROR_SUCCESS;
    
    // Assert this is a version we understand
    Assert(pBlob->Version == 1);
    if (1 != pBlob->Version) {
        return(xListSetReason(XLIST_ERR_ODUMP_UNMAPPABLE_BLOB));
    }

    __try {

        pTemp = (&pBlob->V1.SidStart[0]);

        cSids = pBlob->V1.accountCount + pBlob->V1.accountSidHistoryCount + pBlob->V1.universalCount + pBlob->V1.universalSidHistoryCount;
        cbSize = wcslen(L"universalSidHistory") + 10 + 128; // 128 should be enough for a max length SID
        cbSize *= cSids;
        cbSize += wcslen(szHeaderLong) + (4 * DWORD_STR_SZ) + wcslen(szFooter); 
        cbSize *= sizeof(WCHAR);
        
        szOutBuf = LocalAlloc(LMEM_FIXED, cbSize);
        if (szOutBuf == NULL) {
            dwRet = xListSetNoMem();
            __leave;
        }
        szBuffLeft = szOutBuf;
        cbBuffLeft = cbSize;
        

        dwRet = StringCbPrintf(szBuffLeft, cbBuffLeft, 
                       (pObjDumpOptions->dwFlags & OBJ_DUMP_VAL_LONG_BLOB_OUTPUT) ? 
                            szHeaderLong: szHeader, 
                       pBlob->V1.accountCount,
                       pBlob->V1.accountSidHistoryCount,
                       pBlob->V1.universalCount,
                       pBlob->V1.universalSidHistoryCount );
        Assert(SUCCEEDED(dwRet));
        dwRet = 0;
        
        cchTemp = wcslen(szBuffLeft);
        cbBuffLeft -= (cchTemp * 2);
        szBuffLeft = &(szBuffLeft[cchTemp]);

        // Extract the account memberships
        if (pBlob->V1.accountCount > 0) {

            for (i = 0; i < pBlob->V1.accountCount; i++) {
                ULONG  size = RtlLengthSid((PSID)pTemp);
                Assert(size > 0);

                dwRet = ConvertSidToStringSid(pTemp, &szTempStrSid);
                if (dwRet == 0 || *pszDispValue == NULL) {
                    // Failure
                    dwRet = GetLastError();
                    xListEnsureError(dwRet);
                    __leave;
                }

                dwRet = StringCbPrintf(szBuffLeft, cbBuffLeft, 
                               (pObjDumpOptions->dwFlags & OBJ_DUMP_VAL_LONG_BLOB_OUTPUT) ? 
                                    szEntryLong : szEntry, 
                               L"account", i, szTempStrSid);
                Assert(SUCCEEDED(dwRet));
                dwRet = 0;
                LocalFree(szTempStrSid);
                szTempStrSid = NULL;

                cchTemp = wcslen(szBuffLeft);
                cbBuffLeft -= (cchTemp * 2);
                szBuffLeft = &(szBuffLeft[cchTemp]);

                pTemp += size;
            }
        }

        // Extract the account sid histories
        if (pBlob->V1.accountSidHistoryCount > 0) {

            for (i = 0; i < pBlob->V1.accountSidHistoryCount; i++) {
                ULONG  size = RtlLengthSid((PSID)pTemp);
                Assert(RtlValidSid((PSID)pTemp));
                Assert(size > 0);

                dwRet = ConvertSidToStringSid(pTemp, &szTempStrSid);
                if (dwRet == 0 || *pszDispValue == NULL) {
                    // Failure
                    dwRet = GetLastError();
                    xListEnsureError(dwRet);
                    __leave;
                }

                dwRet = StringCbPrintf(szBuffLeft, cbBuffLeft, 
                               (pObjDumpOptions->dwFlags & OBJ_DUMP_VAL_LONG_BLOB_OUTPUT) ? 
                                    szEntryLong : szEntry, 
                               L"accountSidHistory", i, szTempStrSid);
                Assert(SUCCEEDED(dwRet));
                dwRet = 0;
                LocalFree(szTempStrSid);
                szTempStrSid = NULL;

                cchTemp = wcslen(szBuffLeft);
                cbBuffLeft -= (cchTemp * 2);
                szBuffLeft = &(szBuffLeft[cchTemp]);

                pTemp += size;
            }
        }


        // Extract the universals
        if (pBlob->V1.universalCount > 0) {
            
            for (i = 0; i < pBlob->V1.universalCount; i++) {
                ULONG  size = RtlLengthSid((PSID)pTemp);

                dwRet = ConvertSidToStringSid(pTemp, &szTempStrSid);
                if (dwRet == 0 || *pszDispValue == NULL) {
                    // Failure
                    dwRet = GetLastError();
                    xListEnsureError(dwRet);
                    __leave;
                }

                dwRet = StringCbPrintf(szBuffLeft, cbBuffLeft,
                               (pObjDumpOptions->dwFlags & OBJ_DUMP_VAL_LONG_BLOB_OUTPUT) ? 
                                    szEntryLong : szEntry, 
                               L"universal", i, szTempStrSid);
                Assert(SUCCEEDED(dwRet));
                dwRet = 0;
                LocalFree(szTempStrSid);
                szTempStrSid = NULL;

                cchTemp = wcslen(szBuffLeft);
                cbBuffLeft -= (cchTemp * 2);
                szBuffLeft = &(szBuffLeft[cchTemp]);
                
                pTemp += size;
            }
        }

        // Extract the account sid histories
        if (pBlob->V1.universalSidHistoryCount) {
            
            for (i = 0; i < pBlob->V1.universalSidHistoryCount; i++) {
                ULONG  size = RtlLengthSid((PSID)pTemp);
                Assert(RtlValidSid((PSID)pTemp));
                Assert(size > 0);
                
                dwRet = ConvertSidToStringSid(pTemp, &szTempStrSid);
                if (dwRet == 0 || *pszDispValue == NULL) {
                    // Failure
                    dwRet = GetLastError();
                    xListEnsureError(dwRet);
                    __leave;
                }

                dwRet = StringCbPrintf(szBuffLeft, cbBuffLeft,
                               (pObjDumpOptions->dwFlags & OBJ_DUMP_VAL_LONG_BLOB_OUTPUT) ? 
                                    szEntryLong : szEntry, 
                               L"universalSidHistory", i, szTempStrSid);
                Assert(SUCCEEDED(dwRet));
                dwRet = 0;
                LocalFree(szTempStrSid);
                szTempStrSid = NULL;

                cchTemp = wcslen(szBuffLeft);
                cbBuffLeft -= (cchTemp * 2);
                szBuffLeft = &(szBuffLeft[cchTemp]);
                
                pTemp += size;
            }
        }

        dwRet = StringCbPrintf(szBuffLeft, cbBuffLeft,             
                       (pObjDumpOptions->dwFlags & OBJ_DUMP_VAL_LONG_BLOB_OUTPUT) ? 
                            szFooterLong : szFooter);
        Assert(SUCCEEDED(dwRet));
        dwRet = 0;
        cchTemp = wcslen(szBuffLeft);
        cbBuffLeft -= (cchTemp * 2);
        szBuffLeft = &(szBuffLeft[cchTemp]);

    } __finally {

        if (szTempStrSid) {
            LocalFree(szTempStrSid);
        }

        if (dwRet == ERROR_SUCCESS) {
            *pszDispValue = szOutBuf;
        } else {
            if (szOutBuf) {
                LocalFree(szOutBuf);
            }
        }
    }

    #undef szHeader
    #undef szHeaderLong
    #undef szEntry
    #undef szEntryLong
    #undef szFooter
    #undef szFooterLong
    return(dwRet);
}

//
// Taken from "ds\ds\src\sam\server\samsrvp.h"
//
typedef struct _SAMP_SITE_AFFINITY {

    GUID SiteGuid;
    LARGE_INTEGER TimeStamp;

} SAMP_SITE_AFFINITY, *PSAMP_SITE_AFFINITY;



ATTR_MAP_FUNC_DECL(mapMsDsSiteAffinity)
{
    #define szStructString  L"{ SiteGuid = %ws; TimeStamp = %ws}"
    SAMP_SITE_AFFINITY *psa = (SAMP_SITE_AFFINITY *) pbValue;
    DWORD dwRet = ERROR_SUCCESS;
    WCHAR * szGuid = NULL, * szTimeStamp = NULL;
    DWORD err, cbSize;
    SYSTEMTIME sysTime;

    if(sizeof(SAMP_SITE_AFFINITY) > cbValue){
        return(xListSetReason(XLIST_ERR_ODUMP_UNMAPPABLE_BLOB));
    }

    // FUTURE-2002/10/11-BrettSh - Be very cool if we had a generic friendly
    // name GUID cache, so we could just look up this site guid and turn it
    // into the site name.

    psa->TimeStamp;

    __try {

        err = UuidToStringW(&(psa->SiteGuid), &szGuid);
        if(err != RPC_S_OK || 
           szGuid == NULL){  
            xListEnsureNull(szGuid);
            err = xListSetBadParamE(err);
            __leave;
        }
        Assert(szGuid);

        err = DSTimeToSystemTime(pbValue, &sysTime);
        if (err != ERROR_SUCCESS) {
            err = xListSetBadParamE(err);
            __leave;
        }

        err = mapSystemTimeHelper(&sysTime, &szTimeStamp);
        if (err) {
            // sets an xList Return Code
            __leave;
        }
        Assert(szTimeStamp);

        cbSize = wcslen(szGuid) + wcslen(szTimeStamp) + wcslen(szStructString);
        cbSize *= sizeof(WCHAR);
        *pszDispValue = LocalAlloc(LMEM_FIXED, cbSize);
        if (*pszDispValue == NULL) {
            err = xListSetNoMem();
            __leave;
        }

        err = StringCbPrintf(*pszDispValue, cbSize, szStructString, szGuid, szTimeStamp);
        Assert(SUCCEEDED(err));
        err = 0;


    } __finally {
        
        if(szGuid) { RpcStringFree( &szGuid ); }
        if(szTimeStamp) { LocalFree(szTimeStamp); }

    }

    return(err);
}



// -------------------------------------------------------------
// Default processing functions (for unknown types)
// -------------------------------------------------------------

ATTR_MAP_FUNC_DECL(mapUnknownBlob)
{
    DWORD err;

    *pszDispValue = LocalAlloc(LMEM_FIXED, MakeLdapBinaryStringSizeCch(cbValue) * sizeof(WCHAR));
    if (*pszDispValue == NULL) {
        return(xListSetNoMem());
    }

    err = MakeLdapBinaryStringCb(*pszDispValue, 
                                 MakeLdapBinaryStringSizeCch(cbValue) * sizeof(WCHAR),
                                 pbValue, 
                                 cbValue);
    Assert(err == 0);

    return(0);

}

ATTR_MAP_FUNC_DECL(mapDefault)
{
    WCHAR * pszUnicode = NULL;
    int nReturn = 0;
    int i;
    BOOL bPrintable = TRUE;

    // Allocate memory for the Unicode String
    pszUnicode = LocalAlloc(LMEM_FIXED, ((cbValue + 2) * sizeof(WCHAR)));
    if (pszUnicode == NULL) {
        return(xListSetNoMem());
    }

    SetLastError(0);
    nReturn = LdapUTF8ToUnicode((PSTR)pbValue,
                                cbValue,
                                pszUnicode,
                                cbValue + 1);
    if (GetLastError()) {
        Assert(!"This means buffer wasn't big enough?  WHy?");
        bPrintable = FALSE;
    } else {
        
        // NULL terminate buffer
        pszUnicode[nReturn] = '\0';

        for (i = 0; i < (int) nReturn; i++) {
            if (pszUnicode[i] < 0x20) {
                bPrintable = FALSE;
                break;
            }
        }
    }

    
    if (bPrintable) {

        *pszDispValue = pszUnicode;

    } else {

        LocalFree(pszUnicode); // Abort attempt at string conversion.
        // Are we printing out unknown blobs?
        if ( pObjDumpOptions->dwFlags & OBJ_DUMP_VAL_DUMP_UNKNOWN_BLOBS &&
             (pObjDumpOptions->aszNonFriendlyBlobs == NULL ||
              IsInNullList(szAttr, pObjDumpOptions->aszNonFriendlyBlobs)) ) {
            return(mapUnknownBlob(szAttr, aszzObjClasses, pbValue, cbValue, pObjDumpOptions, pTblData, pszDispValue));
        }
        
        return(XLIST_ERR_ODUMP_UNMAPPABLE_BLOB);
    }

    return(0);
}


// ------------------------------------------------------------------------
//
//      master attribute table stuff
//
// ------------------------------------------------------------------------

// -------------------------------------------------------------
// Master attribute table mapper type
// -------------------------------------------------------------
typedef struct _ATTR_MAP_TABLE {
    DWORD               dwFlags;
    WCHAR *             szAttr;
    ATTR_MAP_FUNC *     pFunc;
    void *              pvTblData;
} ATTR_MAP_TABLE;

// Quick #defines for different types of attributes
#define ATTR_MAP(attr, pfunc, data)   { 0, attr, pfunc, data },
#define BLOB_MAP(attr, pfunc, data)   { OBJ_DUMP_VAL_FRIENDLY_KNOWN_BLOBS, attr, pfunc, data },
#define PRIV_MAP(attr, pfunc, data)   { OBJ_DUMP_PRIVATE_BLOBS, attr, pfunc, data },

// -------------------------------------------------------------
// Master attribute table map
// -------------------------------------------------------------
ATTR_MAP_TABLE  AttrMap [] = {
    
    //
    // DS and Sam attributes
    //

    // Simple flag mapping type attributes
    ATTR_MAP(  L"userAccountControl",       mapFlagsValue,          UserAccountControlFlags )
    ATTR_MAP(  L"groupType",                mapFlagsValue,          GroupTypeFlags          )
    ATTR_MAP(  L"instanceType",             mapFlagsValue,          instanceTypeTable       )
    // Not quite as simple flag mapping type attributes
    ATTR_MAP(  L"systemFlags",              mapVariableFlagsValue,  SystemFlagsTable        )
    ATTR_MAP(  L"options",                  mapVariableFlagsValue,  OptionsFlagsTable       )

    // Guid type attributes
    ATTR_MAP(  L"objectGuid",               mapGuidValue,           NULL                 )
    ATTR_MAP(  L"invocationId",             mapGuidValue,           NULL                 )
    ATTR_MAP(  L"attributeSecurityGUID",    mapGuidValue,           NULL                 )
    ATTR_MAP(  L"schemaIDGUID",             mapGuidValue,           NULL                 )
    ATTR_MAP(  L"serverClassID",            mapGuidValue,           NULL                 )

    // Generalized time attributes
    ATTR_MAP(  L"whenChanged",              mapGeneralizedTime,     NULL            )
    ATTR_MAP(  L"whenCreated",              mapGeneralizedTime,     NULL            )
    ATTR_MAP(  L"dsCorePropagationData",    mapGeneralizedTime,     NULL            )
    ATTR_MAP(  L"msDS-Entry-Time-To-Die",   mapGeneralizedTime,     NULL            )
    ATTR_MAP(  L"schemaUpdate",             mapGeneralizedTime,     NULL            )
    ATTR_MAP(  L"modifyTimeStamp",          mapGeneralizedTime,     NULL            )
    ATTR_MAP(  L"createTimeStamp",          mapGeneralizedTime,     NULL            )
    ATTR_MAP(  L"currentTime",              mapGeneralizedTime,     NULL            )

    // DSTime attributes
    ATTR_MAP(  L"accountExpires",           mapDSTime,              NULL            )
    ATTR_MAP(  L"badPasswordTime",          mapDSTime,              NULL            )
    ATTR_MAP(  L"creationTime",             mapDSTime,              NULL            )
    ATTR_MAP(  L"lastLogon",                mapDSTime,              NULL            )
    ATTR_MAP(  L"lastLogoff",               mapDSTime,              NULL            )
    ATTR_MAP(  L"lastLogonTimestamp",       mapDSTime,              NULL            )
    ATTR_MAP(  L"pwdLastSet",               mapDSTime,              NULL            )
    ATTR_MAP(  L"msDS-Cached-Membership-Time-Stamp", mapDSTime,     NULL            )

    // i64 Duration attributes
    ATTR_MAP(  L"lockoutDuration",          mapDuration,            NULL            )
    ATTR_MAP(  L"lockoutObservationWindow", mapDuration,            NULL            )
    ATTR_MAP(  L"forceLogoff",              mapDuration,            NULL            )
    ATTR_MAP(  L"minPwdAge",                mapDuration,            NULL            )
    ATTR_MAP(  L"maxPwdAge",                mapDuration,            NULL            )
    ATTR_MAP(  L"lockoutDuration",          mapDuration,            NULL            )

    // Sid attributes
    ATTR_MAP(  L"objectSid",                mapSid,                 NULL            )
    ATTR_MAP(  L"sidHistory",               mapSid,                 NULL            ) 
    ATTR_MAP(  L"tokenGroups",              mapSid,                 NULL            )
    ATTR_MAP(  L"tokenGroupsGlobalAndUniversal", mapSid,            NULL            )
    ATTR_MAP(  L"tokenGroupsNoGCAcceptable",mapSid,                 NULL            )

    // the behaviour version attributes
    ATTR_MAP(  L"msDS-Behavior-Version",    mapEnumValue,           behaviourVersionTable )
    ATTR_MAP(  L"domainFunctionality",      mapEnumValue,           behaviourVersionTable )
    ATTR_MAP(  L"forestFunctionality",      mapEnumValue,           behaviourVersionTable )
    ATTR_MAP(  L"domainControllerFunctionality", mapEnumValue,      behaviourVersionTable )

    // Various DS blobs ...
    BLOB_MAP(  L"partialAttributeSet",      mapPartialAttributeSet, NULL            )
    BLOB_MAP(  L"msDS-Cached-Membership",   mapMsDsCachedMembership,NULL            )
    BLOB_MAP(  L"msDS-Site-Affinity",       mapMsDsSiteAffinity,    NULL            )

    //
    // Exchange attributes
    //
    ATTR_MAP(  L"msExchMailboxGuid",        mapGuidValue,           NULL            )

    // FUTURE-2002/08/16-BrettSh - Attributes that might also be interesting
    // to dump in a friendly blob format:
    //    partialAttributeSet, schedule, repsFrom, repsTo, replUpToDateVector,
    //    dnsRecord, etc ...  



    // Must be last entry, this NULL catches all left over attributes, and 
    // iMapDefaultEntry below relies on this as the last entry.
    ATTR_MAP(  NULL,                        mapDefault,          NULL                )
};

ULONG iMapDefaultEntry = sizeof(AttrMap) / sizeof(AttrMap[0]) - 1;


// -------------------------------------------------------------------------------------
//
//      Public Functions
//
// -------------------------------------------------------------------------------------

void
ObjDumpOptionsFree(
    OBJ_DUMP_OPTIONS ** ppDispOptions
    )
{
    OBJ_DUMP_OPTIONS * pDispOptions;

    Assert(ppDispOptions && *ppDispOptions);

    pDispOptions = *ppDispOptions;
    *ppDispOptions = NULL;

    if (pDispOptions) {
        
        if (pDispOptions->aszDispAttrs) {
            LocalFree(pDispOptions->aszDispAttrs);
        }
        if (pDispOptions->aszFriendlyBlobs) {
            LocalFree(pDispOptions->aszFriendlyBlobs);
        }
        if (pDispOptions->aszNonFriendlyBlobs) {
            LocalFree(pDispOptions->aszNonFriendlyBlobs);
        }

        LocalFree(pDispOptions);
    }

}


LDAPControlW DeletedObjControl = {  LDAP_SERVER_SHOW_DELETED_OID_W, 
                                    { 0, NULL },
                                    TRUE };

LDAPControlW ExtendedDnControl = {  LDAP_SERVER_EXTENDED_DN_OID_W,
                                    { 0, NULL },
                                    TRUE };

                                    // Since there is very little interest in sending very many controls, we'll
// just always allocate enough room for all the controls we could possibly 
// need.  Technically the maximum controls is one less than this number.  
#define XLIST_MAX_CONTROLS    (2 + 1)


DWORD
AddToControls(
    LDAPControlW *** papControls,
    LDAPControlW *  pControlToAdd
    )
// Little function that adds one of the two controls we care about to our controls array.
{
    ULONG i;
    if (papControls == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }
    if (*papControls == NULL) {
        *papControls = LocalAlloc(LPTR, sizeof(LDAPControlW *) * XLIST_MAX_CONTROLS); // Max of 2 controls ...
        if (*papControls == NULL) {
            return(GetLastError());
        }
    }
    for (i = 0; (*papControls)[i]; i++) {
        ; // just getting to end ...
    }
    Assert( i < XLIST_MAX_CONTROLS);
    
    (*papControls)[i] = pControlToAdd;

    return(0);
}

DWORD
ConsumeObjDumpOptions(
    int *       pArgc,
    LPWSTR *    Argv,
    DWORD       dwDefaultFlags,
    OBJ_DUMP_OPTIONS ** ppObjDumpOptions
    )
/*++

Routine Description:

    This takes some command line arguments and consumes them from
    the command line arguments and sets up the ObjDumpOptions ...

Arguments:

    pArgc - number of command line arguments
    Argv - command line arguments array
    dwDefaultFlags - Any default flags the user wishes
    ppObjDumpOptions - pointer to pointer to a OBJ_DUMP_OPTIONS
        Gets allocated can be freed with ObjDumpOptionsFree()

Return Value:

    xList Return Code

--*/
{
    DWORD dwRet = 0;
    int   iArg;
    BOOL  fConsume;
    WCHAR * szAttTemp;
    
    OBJ_DUMP_OPTIONS * pObjDumpOptions;

    pObjDumpOptions = LocalAlloc(LPTR, sizeof(OBJ_DUMP_OPTIONS));  // zero init'd
    if (pObjDumpOptions == NULL) {
        return(xListSetNoMem());
    }

    // Approximate command line options of the two commands that use this.
    //  /showattr       /long /nofriendlyblob /nolongblob /dumpallblob
    //  /showchanges    /long /friendlyblob   /longblob   /dumpallblob
    //  ldp just sets up it's own options.
    
    // Set default disp options
    pObjDumpOptions->dwFlags = dwDefaultFlags;

    for (iArg = 0; iArg < *pArgc; ) {

        // Assume we recognize the argument
        fConsume = TRUE; 
                                                         
        // Figure out which argument this is ....
        if (wcsequal(Argv[ iArg ], L"/long")) {
            set(pObjDumpOptions->dwFlags, OBJ_DUMP_ATTR_LONG_OUTPUT);
        } else if (wcsequal(Argv[iArg], L"/nolong")) {
            unset(pObjDumpOptions->dwFlags, OBJ_DUMP_ATTR_LONG_OUTPUT);

        } else if (wcsequal(Argv[iArg], L"/longblob")) {
            set(pObjDumpOptions->dwFlags, OBJ_DUMP_VAL_LONG_BLOB_OUTPUT);
        } else if (wcsequal(Argv[iArg], L"/nolongblob")) {
            unset(pObjDumpOptions->dwFlags, OBJ_DUMP_VAL_LONG_BLOB_OUTPUT);
        
        } else if (wcsequal(Argv[iArg], L"/allvalues")) {
            set(pObjDumpOptions->dwFlags, OBJ_DUMP_ATTR_SHOW_ALL_VALUES);

        } else if (wcsprefix(Argv[iArg], L"/atts") ||
                   wcsprefix(Argv[iArg], L"/attrs") ) {
            szAttTemp = wcschr(Argv[iArg], L':');
            if (szAttTemp != NULL) {
                szAttTemp++; // want one char past the
                 dwRet = ConvertAttList(szAttTemp, 
                                        &pObjDumpOptions->aszDispAttrs);
                 if (dwRet) {
                     break;
                 }
            } else {
                dwRet = xListSetBadParamE(dwRet);
                break;
            }

        } else if (wcsequal(Argv[iArg], L"/nofriendlyblob")) {
            unset(pObjDumpOptions->dwFlags, OBJ_DUMP_VAL_FRIENDLY_KNOWN_BLOBS);
        } else if (wcsprefix(Argv[iArg], L"/friendlyblob")) {
            set(pObjDumpOptions->dwFlags, OBJ_DUMP_VAL_FRIENDLY_KNOWN_BLOBS);
            szAttTemp = wcschr(Argv[iArg], L':');
            if (szAttTemp != NULL) {
                // This means they want only some attrs listed friendly.
                szAttTemp++; // want one char past the
                 dwRet = ConvertAttList(szAttTemp, 
                                        &pObjDumpOptions->aszFriendlyBlobs);
                 if (dwRet) {
                     dwRet = xListSetBadParamE(dwRet);
                     break;
                 }
            }
        
        } else if (wcsequal(Argv[iArg], L"/nodumpallblob")) { 
            unset(pObjDumpOptions->dwFlags, OBJ_DUMP_VAL_DUMP_UNKNOWN_BLOBS);
        } else if (wcsprefix(Argv[iArg], L"/dumpallblob")) { 
            set(pObjDumpOptions->dwFlags, OBJ_DUMP_VAL_DUMP_UNKNOWN_BLOBS);
            szAttTemp = wcschr(Argv[iArg], L':');
            if (szAttTemp != NULL) {
                // This means they want only some attrs listed friendly.
                szAttTemp++; // want one char past the
                 dwRet = ConvertAttList(szAttTemp, 
                                        &pObjDumpOptions->aszNonFriendlyBlobs);
                 if (dwRet) {
                     dwRet = xListSetBadParamE(dwRet);
                     break;
                 }
            }

        } else if (wcsequal(Argv[iArg], L"/extended")) {
            // Get Extended DN syntax ...
            dwRet = AddToControls(&(pObjDumpOptions->apControls), &ExtendedDnControl);
            if (dwRet) {
                dwRet = xListSetBadParamE(dwRet);
                break;
            }

        } else if (wcsequal(Argv[iArg], L"/deleted")) {
            // Get Deleted objects ...
            dwRet = AddToControls(&(pObjDumpOptions->apControls), &DeletedObjControl);
            if (dwRet) {
                dwRet = xListSetBadParamE(dwRet);
                break;
            }

        } else {
            // Hmmm, didn't recognize this argument, don't consume it.
            iArg++;
            fConsume = FALSE;
        }

        if (dwRet) {
            // bail on consuming arguments if there was an error
            xListSetArg(Argv[iArg]);
            break;
        }

        if (fConsume) {
            ConsumeArg(iArg, pArgc, Argv);
        }

    }

    if (dwRet == 0) {
        Assert(pObjDumpOptions != NULL);
        *ppObjDumpOptions = pObjDumpOptions;
    }
    return(dwRet);
}


DWORD
ValueToString(
    WCHAR *         szAttr,
    WCHAR **        aszzObjClasses,

    PBYTE           pbValue,
    DWORD           cbValue,

    OBJ_DUMP_OPTIONS * pObjDumpOptions,
    WCHAR **        pszDispValue
    )
/*++

Routine Description:

    The heart of the object dumping routines, this takes an attribute
    type, objectClass it came off of, pointer to the value, length of
    the value, some dump options and turns it into a nice user friendly
    string.

Arguments:

    szAttr - attribute type LDAP display name (such as "name", "systemFlags" )
    aszzObjClasses - NULL terminated array of objectClasses that apply to
        the object this value came off of (such as "domainDns", "user", "crossRef" )
    pbValue - actual value to stringify
    cbValue - length of provided value
    pObjDumpOptions - the ObjDump options created by ConsumeObjDumpOptions()
    pszDispValue - the out param, a LocalAlloc'd wchar string

Return Value:

    xList Return Code

--*/
{
    ULONG i;
    DWORD dwRet;

    if (szAttr == NULL || pszDispValue == NULL || pObjDumpOptions == NULL) {
        Assert(!"Invalid parameter");
        return(xListSetBadParam());
    }

    for (i=0; AttrMap[i].szAttr; i++) {
        if (0 == _wcsicmp(szAttr, AttrMap[i].szAttr)) {
            break;
        }
    }             
    Assert(i < sizeof(AttrMap)/sizeof(AttrMap[0]));

    if ( (AttrMap[i].dwFlags & OBJ_DUMP_VAL_FRIENDLY_KNOWN_BLOBS) &&
         !(pObjDumpOptions->dwFlags & OBJ_DUMP_VAL_FRIENDLY_KNOWN_BLOBS) ) {
        i = iMapDefaultEntry; // Use default mapper routine
    }

    if ( (AttrMap[i].dwFlags & OBJ_DUMP_PRIVATE_BLOBS) &&
         !(pObjDumpOptions->dwFlags & OBJ_DUMP_PRIVATE_BLOBS) ) {
        i = iMapDefaultEntry; // Use default mapping routine
    }
    
    dwRet = AttrMap[i].pFunc(szAttr, 
                             aszzObjClasses, 
                             pbValue, 
                             cbValue, 
                             pObjDumpOptions, 
                             AttrMap[i].pvTblData, 
                             pszDispValue);

    // This assert may be a little heavy and have to be removed.
    Assert(dwRet == 0 ||
           dwRet == XLIST_ERR_ODUMP_UNMAPPABLE_BLOB ||
           dwRet == XLIST_ERR_ODUMP_NEVER ||
           dwRet == XLIST_ERR_ODUMP_NONE ); 
    
    return(dwRet);
}


void
ObjDumpValue(
    LPWSTR   szAttr,
    LPWSTR * aszzObjClasses,
    void   (*pfPrinter)(ULONG, WCHAR *, void *),
    PBYTE    pbValue,
    DWORD    cbValue,
    OBJ_DUMP_OPTIONS * pObjDumpOptions
    )
/*++

Routine Description:

    This dumps a single value using the supplied pfPrinter function.
    
    The printing function must be able to handle
            constant                    ( string arg ,  void * arg  )            
           ----------                     ----------    ----------
        XLIST_PRT_STR                   ( szFriendlyStr,    NULL    )
        XLIST_ERR_ODUMP_UNMAPPABLE_BLOB (   NULL,    ptr to sizeof blob ulong )
        XLIST_ERR_ODUMP_NEVER           (   NULL,           NULL    )
        XLIST_ERR_ODUMP_NONE            (   NULL,           NULL    )

Arguments:

    szAttr - attribute type LDAP display name (such as "name", "systemFlags" )
    aszzObjClasses - NULL terminated array of objectClasses that apply to
        the object this value came off of (such as "domainDns", "user", "crossRef" )
    pfPrinter - The printing function.
    pbValue - actual value to stringify
    cbValue - length of provided value
    pObjDumpOptions - the ObjDump options created by ConsumeObjDumpOptions()


--*/
{
    DWORD xListRet;
    WCHAR * szValue;

    Assert(NULL == wcschr(szAttr, L';')); // We expect a true attr, not a ranged attr.

    xListRet = ValueToString(szAttr, aszzObjClasses, pbValue, cbValue, pObjDumpOptions, &szValue);
    if (xListRet == 0) {

        Assert(szValue);
        pfPrinter(XLIST_PRT_STR, szValue, NULL);
        LocalFree(szValue);

    } else {
        // process error ... can be just a status we want to print
        switch (xListReason(xListRet)) {
        case XLIST_ERR_ODUMP_UNMAPPABLE_BLOB:
            pfPrinter(XLIST_ERR_ODUMP_UNMAPPABLE_BLOB, NULL, &cbValue);
            break;

        case XLIST_ERR_ODUMP_NEVER:
        case XLIST_ERR_ODUMP_NONE:
            pfPrinter(XLIST_ERR_ODUMP_NEVER, NULL, NULL);
            break;

        default:
            Assert(!"uncaught error");
        }
        xListClearErrors();
    }

}

DWORD
LdapGetNextRange(
    LDAP *              hLdap,
    WCHAR *             szObject,
    WCHAR *             szTrueAttr,
    LDAPControlW **     apControls,
    ULONG               ulNextStart, 
    WCHAR **            pszRangedAttr,
    struct berval ***   pppBerVal
    )
/*++

Routine Description:

    This gets the next range in a ranged attribute.

Arguments:

    hLdap - LDAP handle
    szObject - object that has the ranged attribute
    szTrueAttr - real name of the attribute so "member;=0-1499" is like
        the ranged attribute, so the true attribute would be just "member"
    apControls - any controls to use in our searches ...
    ulNextStart - Next range to get ..., like 1500 
    pszRangedAttr [OUT] - this is the ranged attribute values we get back 
        for this attribute like "member;=1500-2999"
    pppBerVal [OUT] - This is the array of ber vals given by LDAP

Return Value:

    xList Return Code

--*/
{
    BerElement *pBer = NULL;
    DWORD       dwRet = 0;
    WCHAR **    aszAttrs = NULL;
    XLIST_LDAP_SEARCH_STATE * pSearch = NULL;
    ULONG       cbSize;
    DWORD       dwLdapErr = 0;
    DWORD       dwLdapExtErr = 0;

    Assert(hLdap && szObject && szTrueAttr && ulNextStart); // in params
    Assert(pszRangedAttr && pppBerVal); // out params
    xListEnsureNull(*pppBerVal);
    xListEnsureNull(*pszRangedAttr);
    Assert(NULL == wcschr(szTrueAttr, L';')); // We expect the szTrueAttr.

    __try{

        //
        // Construct the complicated "member;1500-*" attribute syntax ...
        //
        aszAttrs = LocalAlloc(LPTR, 2 * sizeof(WCHAR *));
        if (aszAttrs == NULL) {
            dwRet = xListSetWin32Error(GetLastError());
            __leave;
        }
        cbSize = wcslen(L"%ws;range=%d-*") + wcslen(szTrueAttr) + 2 * CCH_MAX_ULONG_SZ;
        cbSize *= sizeof(WCHAR);
        aszAttrs[0] = LocalAlloc(LPTR, cbSize);
        if (aszAttrs[0] == NULL) {
            dwRet = xListSetWin32Error(GetLastError());
            __leave;
        }
        dwRet = StringCbPrintf(aszAttrs[0], cbSize, L"%ws;range=%d-*", szTrueAttr, ulNextStart);
        Assert(SUCCEEDED(dwRet));
        aszAttrs[1] = NULL;

        //
        // Do the actual search
        //             
        dwRet = LdapSearchFirstWithControls(hLdap, 
                                            szObject, 
                                            LDAP_SCOPE_BASE, 
                                            L"(objectClass=*)", 
                                            aszAttrs, 
                                            apControls,
                                            &pSearch);
        if (dwRet ||
            !LdapSearchHasEntry(pSearch)) {

            xListGetError(dwRet, NULL, NULL, NULL, &dwLdapErr, NULL, &dwLdapExtErr, NULL, NULL);
            if (dwLdapErr == LDAP_OPERATIONS_ERROR &&
                dwLdapExtErr == ERROR_DS_CANT_RETRIEVE_ATTS) {
                //
                // This is the error that we've traditionally gotten from the DS
                // when we ask for a range of an attribute, where the AD doesn't 
                // have that range of values. How can this happen?
                //
                // Well, if between getting packets someone deleted enough values
                // to make it non-sensical to ask for the range we just asked for.
                // in this case, we'll feign no error.
                //
                xListClearErrors();
                dwRet = 0; // Success!  Yeah!
            }
            __leave;
        }

        for (*pszRangedAttr = ldap_first_attributeW(hLdap, pSearch->pCurEntry, &pBer);
             *pszRangedAttr != NULL;
             *pszRangedAttr = ldap_next_attributeW(hLdap, pSearch->pCurEntry, pBer)){
            if (wcsprefix(*pszRangedAttr, szTrueAttr)) {
                break;
            }
        }
        if (*pszRangedAttr == NULL) {
            // Doh!  We're stuck ...
            dwRet = xListSetLdapError(LdapGetLastError(), hLdap);
            __leave;
        }

        *pppBerVal = ldap_get_values_lenW(hLdap, pSearch->pCurEntry, *pszRangedAttr);
        if (*pppBerVal == NULL) {
            dwRet = xListSetLdapError(LdapGetLastError(), hLdap);
            __leave;
        }

    } __finally {

        if (aszAttrs) {
            if (aszAttrs[0]) {
                LocalFree(aszAttrs[0]);
            }
            LocalFree(aszAttrs);
        }

        if (pSearch) {
            LdapSearchFree(&pSearch);
        }

        if (dwRet) {
            // Scrub out parameters ...
            if (*pppBerVal){
                ldap_value_free_len(*pppBerVal);
                *pppBerVal = NULL;
            }
            if (*pszRangedAttr) {
                ldap_memfreeW(*pszRangedAttr);
                *pszRangedAttr = NULL;
            }
        } else {
            // ensure out parameters
            Assert(*pppBerVal && *pszRangedAttr);
        }

    }

    return(dwRet);
}

DWORD
ObjDumpRangedValues(
    LDAP *              hLdap,
    WCHAR *             szObject,
    LPWSTR              szRangedAttr,
    LPWSTR *            aszzObjClasses,
    void              (*pfPrinter)(ULONG, WCHAR *, void *),
    struct berval **    ppBerVal,
    DWORD               cValuesToPrint,
    OBJ_DUMP_OPTIONS *  pObjDumpOptions
    )
/*++

Routine Description:

    This dumps all the values for a ranged attribute up to cValuesToPrint.

    The printing function must be able to handle these 3 parameters in
    this order:
    
            constant                    ( string arg ,  void * arg  )            
           ----------                     ----------    ----------
        XLIST_PRT_OBJ_DUMP_ATTR_AND_COUNT
                                        ( szAttributeName,  ptr to count of values )
        XLIST_PRT_OBJ_DUMP_ATTR_AND_COUNT_RANGED
                                        ( szAttributeName,  ptr to count of values )

          AND everything that ObjDumpValues() or ObjDumpValue() might want 
          to use ... which currently is:
          
        XLIST_ERR_ODUMP_UNMAPPABLE_BLOB (   NULL,    ptr to sizeof blob ulong )
        XLIST_ERR_ODUMP_NEVER           (   NULL,           NULL    )
        XLIST_ERR_ODUMP_NONE            (   NULL,           NULL    )
        

Arguments:

    hLdap - LDAP handle
    szObject - object that has the ranged attribute
    szRangedAttr - this is the ranged attribute like "member;=1500-2999"
    aszzObjClasses - NULL terminated array of objectClasses that apply to
        the object this value came off of (such as "domainDns", "user", "crossRef" )
    pfPrinter - the printing function
    ppBerVal - The array of BERVALs to dump.
    cValuesToPrint - How many values to print before bailing.
    pObjDumpOptions - ObjDump options.

Return Value:

    xList Return Code

--*/
{
    DWORD   cValues;
    WCHAR * szTrueAttr = NULL;
    DWORD   dwRet = 0;
    WCHAR * szTemp;
    ULONG   ulStart;
    ULONG   ulEnd;
    BOOL    fFreeVals = FALSE; 
    
    // Note on (fFreeVals) the first run we print out what is in the 
    // passed in values, so we don't want to free that szRangedAttr
    // and ppBerVal

    __try {

        //
        // First get the true attribute name from the ranged syntax.
        //
        if (dwRet = ParseTrueAttr(szRangedAttr, &szTrueAttr)){
            dwRet = xListSetBadParam();
            __leave;
        }

        do {

            Assert(szRangedAttr && ppBerVal);

            //
            // Get number of values to dump.
            //
            cValues = ldap_count_values_len( ppBerVal );
            if (!cValues) {
                // Don't see how this could happen ... is this success or failure?
                Assert(!"What does this mean?");
                dwRet = 0; // if we've got no more values, we'll assume this is success.
                break;
            }

            //
            // Parse the ranges we're dumping...
            //
            if (dwRet = ParseRanges(szRangedAttr, &ulStart, &ulEnd)) {
                Assert(!"Hmmm, if we asked for a ranged attribute, is it possible we got back non-ranged?");
                dwRet = xListSetBadParam();
                break;
            }

            //
            // Print the attribute header (like "12> member: ").
            //
            if (ulEnd == 0) {
                // When ulEnd == 0, we're at the end of our ranged values ...
                pfPrinter(XLIST_PRT_OBJ_DUMP_ATTR_AND_COUNT, szTrueAttr, &cValues );
            } else {
                // More values to come after we dump these values ...
                pfPrinter(XLIST_PRT_OBJ_DUMP_ATTR_AND_COUNT_RANGED, szTrueAttr, &cValues );
            }

            //
            // Now, dump all the values
            //
            ObjDumpValues(szTrueAttr, aszzObjClasses, pfPrinter, ppBerVal, cValues, pObjDumpOptions);

            if (fFreeVals) {
                ldap_value_free_len(ppBerVal);
                ldap_memfreeW(szRangedAttr);
            }
            ppBerVal = NULL;
            szRangedAttr = NULL;
            // Any ppBerVal or szRangedAttr from here on must have been 
            // allocated by LdapGetNextRange().
            fFreeVals = TRUE; 

            if (ulEnd == 0) {
                //
                // Successfully got all values!!!
                //
                dwRet = 0;
                break;
            }

            //
            // Get next range of values (form <ulEnd+1> to *)
            //
            dwRet = LdapGetNextRange(hLdap, 
                                     szObject, 
                                     szTrueAttr, 
                                     pObjDumpOptions->apControls, 
                                     ulEnd+1, 
                                     &szRangedAttr, 
                                     &ppBerVal);

        } while ( dwRet == 0 && ppBerVal && szRangedAttr );

        // ... what to do if we've got an error ... I guess just return it ...

    } __finally {
        if (szTrueAttr) {
            LocalFree(szTrueAttr);
        }

        if (fFreeVals && ppBerVal) {
            Assert(!"Not convinced there is a valid case for this.");
            ldap_value_free_len(ppBerVal);
            ppBerVal = NULL;
        }

        if (fFreeVals && szRangedAttr) {
            Assert(!"Not convinced there is a valid case for this.");
            ldap_memfreeW(szRangedAttr);
            szRangedAttr = NULL;
        }

    }

    return(dwRet);
}


// ------------------------------------------------------
// Primary Dumping functions
// ------------------------------------------------------
// Used by /getchanges and /showattr in repadmin


void
ObjDumpValues(
    LPWSTR              szAttr,
    LPWSTR *            aszzObjClasses,
    void              (*pfPrinter)(ULONG, WCHAR *, void *),
    struct berval **    ppBerVal,
    DWORD               cValuesToPrint,
    OBJ_DUMP_OPTIONS *  pObjDumpOptions
    )
/*++

Routine Description:

    This dumps a set number of values from a single attribute using the
    pfPrinter function.
    
    The printing function must be able to handle
            constant                    ( string arg ,  void * arg  )            
           ----------                     ----------    ----------
        XLIST_PRT_STR                   ( szFriendlyStr,    NULL    )
        
        (AND everything that ObjDumpValue() might want to use)

Arguments:

    szAttr - attribute type LDAP display name (such as "name", "systemFlags" )
    aszzObjClasses - NULL terminated array of objectClasses that apply to
        the object this value came off of (such as "domainDns", "user", "crossRef" )
    pfPrinter - The printing function.
    ppBerVal - array of BERVALs to dump.
    cValuesToPrint - How many of the values we want to print before giving up.
    pObjDumpOptions - ObjDump options ...

--*/
{
    ULONG i;
    
    ObjDumpValue( szAttr, aszzObjClasses, pfPrinter, ppBerVal[0]->bv_val, ppBerVal[0]->bv_len, pObjDumpOptions );
    for( i = 1; i < cValuesToPrint; i++ ) {
        if (pObjDumpOptions->dwFlags & OBJ_DUMP_ATTR_LONG_OUTPUT) {
            pfPrinter(XLIST_PRT_STR, L";\n          ", NULL);
        } else {
            pfPrinter(XLIST_PRT_STR, L"; ", NULL);
        }           
        ObjDumpValue( szAttr, aszzObjClasses, pfPrinter, ppBerVal[i]->bv_val, ppBerVal[i]->bv_len, pObjDumpOptions );
    }
}

DWORD
ObjDump( // was display entries or something
    LDAP *              hLdap,
    void                (*pfPrinter)(ULONG, WCHAR *, void *),
    LDAPMessage *       pLdapEntry,
    DWORD               iEntry, 
    OBJ_DUMP_OPTIONS *  pObjDumpOptions
    )
/*++

Routine Description:

    This dumps a set number of values from a single attribute using the
    pfPrinter function.
    
    The printing function must be able to handle these 3 parameters in
    this order:
            constant                    ( string arg ,  void * arg  )            
           ----------                     ----------    ----------
        XLIST_PRT_STR                   ( szFriendlyStr,    NULL    )
        XLIST_PRT_OBJ_DUMP_DN           (  szObjectDn,      NULL    )
        XLIST_PRT_OBJ_DUMP_ATTR_AND_COUNT
                                        ( szAttributeName,  ptr to count of values )
        XLIST_PRT_OBJ_DUMP_ATTR_AND_COUNT_RANGED
                                        ( szAttributeName,  ptr to count of values )
        XLIST_PRT_OBJ_DUMP_MORE_VALUES  (   NULL,           NULL    )

          AND everything that ObjDumpValues() or ObjDumpValue() or
          ObjDumpRangedValues() might want to use ... which currently is:
          
        XLIST_ERR_ODUMP_UNMAPPABLE_BLOB (   NULL,    ptr to sizeof blob ulong )
        XLIST_ERR_ODUMP_NEVER           (   NULL,           NULL    )
        XLIST_ERR_ODUMP_NONE            (   NULL,           NULL    )
        
        
          (And basically all the XLIST_PRT_OBJ_DUMP_* constants)


Arguments:

    hLdap - LDAP Handle
    pfPrinter - The printing function.
    pLdapEntry - An LDAP entry with all the attributes the user expects dumped.
    iEntry - ???
    pObjDumpOptions - Constructed ObjDump options, use ConsumeObjDumpOptions()
        to construct.

Return Value:

    xList Return Code

--*/
{
    #define MAX_ULONG  0xFFFFFFFF                           
    BerElement *pBer = NULL;
    PWSTR attr;
    LPWSTR szTrueDn, p2;
    DWORD dwSrcOp, bucket;
    PWSTR pszLdapDN;
    WCHAR * szRanged;
    WCHAR ** aszzObjClass = NULL;
    ULONG cMaxDispValues;
    DWORD dwRet = 0;

    // We normally will only dump 20 values, unless user wants all values.
    cMaxDispValues = (pObjDumpOptions->dwFlags & OBJ_DUMP_ATTR_SHOW_ALL_VALUES) ? MAX_ULONG : 20;
        
    __try {

        pszLdapDN = ldap_get_dnW(hLdap, pLdapEntry);
        if (pszLdapDN == NULL) {
            dwRet = xListSetLdapError(LdapGetLastError(), hLdap);
            __leave;
        }

        // Parse extended dn (fyi guid and sid in here if we need it)
        szTrueDn = wcsstr( pszLdapDN, L">;" );
        if (szTrueDn) {
            szTrueDn += 2;
            p2 = wcsstr( szTrueDn, L">;" );
            if (p2) {
                szTrueDn = p2 + 2;
            }
        } else {
            szTrueDn = pszLdapDN;
        }
        pfPrinter(XLIST_PRT_OBJ_DUMP_DN, pszLdapDN, NULL);

        // get objectClass:
        aszzObjClass = ldap_get_valuesW(hLdap, pLdapEntry, L"objectClass");
        // if aszzObjClass is NULL, that's OK, we could be dealing with the RootDSE

        // List attributes in object
        for (attr = ldap_first_attributeW(hLdap, pLdapEntry, &pBer);
             attr != NULL;
             attr = ldap_next_attributeW(hLdap, pLdapEntry, pBer))
        {
            struct berval **ppBerVal = NULL;
            DWORD cValues, i;

            if (pObjDumpOptions->aszDispAttrs != NULL &&
                !IsInNullList(attr, pObjDumpOptions->aszDispAttrs)) {
                // Skip this attribute ...
                continue;
            }

            ppBerVal = ldap_get_values_lenW(hLdap, pLdapEntry, attr);
            if (ppBerVal == NULL) {
                goto loop_end;
            }
            cValues = ldap_count_values_len( ppBerVal );
            if (!cValues) {
                goto loop_end;
            }

            szRanged = wcschr(attr, L';');
            if (szRanged && (cMaxDispValues == MAX_ULONG)) {
                // Darn!  We've got a ranged attribute returned and the user wants
                // to see all the values ...

                ObjDumpRangedValues( hLdap, 
                                     szTrueDn,
                                     attr, 
                                     aszzObjClass, 
                                     pfPrinter, 
                                     ppBerVal, 
                                     cMaxDispValues, 
                                     pObjDumpOptions );

            } else {

                // Print attr and count ...
                if (szRanged) {
                    *szRanged = L'\0'; // NULL out ranged count ...
                    pfPrinter(XLIST_PRT_OBJ_DUMP_ATTR_AND_COUNT_RANGED, attr, &cValues );
                    *szRanged = L';'; // just in case replace original char
                } else {
                    pfPrinter(XLIST_PRT_OBJ_DUMP_ATTR_AND_COUNT, attr, &cValues );
                }

                // Main value printing routine.
                ObjDumpValues( attr, 
                               aszzObjClass, 
                               pfPrinter, 
                               ppBerVal, 
                               min(cValues, cMaxDispValues), 
                               pObjDumpOptions );

                if ( cValues > cMaxDispValues ) {
                    pfPrinter(XLIST_PRT_OBJ_DUMP_MORE_VALUES, NULL, NULL);
                } 

            }

            pfPrinter(XLIST_PRT_STR, L"\n", NULL);
            

        loop_end:
            ldap_value_free_len(ppBerVal);
        }

    } __finally {
        if (pszLdapDN)
            ldap_memfreeW(pszLdapDN);
        if (aszzObjClass) {
            ldap_value_freeW(aszzObjClass);
        }
    }

    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\x_list\dc_list.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

   xList Library - dc_list.c

Abstract:

   This provides a little library for enumerating lists of DCs, and resolving
   various other x_list things.

Author:

    Brett Shirley (BrettSh)

Environment:

    repadmin.exe, but could be used by dcdiag too.

Notes:

Revision History:

    Brett Shirley   BrettSh     July 9th, 2002
        Created file.

--*/

#include <ntdspch.h>

#include <windns.h>     // DnsValidateName() uses dnsapi.lib
#include <ntdsa.h>      // DSNAME type only defined in here, need it for the parsedn.lib functions.
#include <dsutil.h>     // fNullUuid() uses dscommon.lib
            
            
// This library's main header files.
#include "x_list.h"
#include "x_list_p.h"

#define FILENO                          FILENO_UTIL_XLIST_DCLIST

//
// Global constants
//

WCHAR * pszDsaAttrs [] = {
    // DN is for free.
    L"objectGuid", 
    L"name",
    NULL 
};

WCHAR * pszServerAttrs [] = {
    // DN is for free.
    L"objectGuid", 
    L"name",
    L"dNSHostName",
    NULL 
};

DWORD
xListGetGuidDnsName (
    UUID *      pDsaGuid,
    WCHAR **    pszGuidDns
    )
/*++

Routine Description:

    This routine makes the GuidDNSName out of the RootDomain and Guid.

Arguments:

    pDsaGuid - (IN) The Guid of the server.
    pszGuidDns - (OUT) LocalAlloc'd GUID DNS name

Return Value:

    Win32 Error.

--*/
{
    LPWSTR    pszStringizedGuid = NULL;
    DWORD     dwRet;

    Assert(pszGuidDns);
    if (gszHomeRootDomainDns == NULL) {
        Assert(!"Code inconsistency, this function to only be called when we've got a home server");
        return(ERROR_INVALID_PARAMETER);
    }

    __try {

        dwRet = UuidToStringW (pDsaGuid, &pszStringizedGuid);
        if(dwRet != RPC_S_OK){
            Assert(dwRet == RPC_S_OUT_OF_MEMORY && "Ahhh programmer problem, UuidToString() inaccurately reports in"
                       " MSDN that it will only return one of two error codes, but apparently"
                       " it will return a 3rd.  Someone should figure out what to do about"
                       " this.");
            __leave;

        } 
        Assert(pszStringizedGuid);

        dwRet = MakeString2(L"%s._msdcs.%s", 
                            pszStringizedGuid, 
                            gszHomeRootDomainDns, 
                            pszGuidDns);
        if (dwRet) {
            __leave;
        }

    } __finally {

        if (pszStringizedGuid != NULL) RpcStringFreeW (&pszStringizedGuid);
        if (dwRet) {
            xListEnsureNull(*pszGuidDns);
        }

    }

    Assert(dwRet || *pszGuidDns);
    return dwRet;
}


                
DWORD
xListDsaEntryToDns(
    LDAP *         hLdap,
    LDAPMessage *  pDsaEntry,
    WCHAR **       pszDsaDns
    )
/*++

Routine Description:

    Takes a LDAPMessage pointing to a DSA ("NTDS Settings") object and grabs
    the objectGuid attribute off it, and turns it into the GUID based DNS name.

Arguments:

    hLdap
    pDsaEntry (IN) - Valid LDAPMessage pointing to the DSA object, must have
        asked for the objectGuid attribute in the original search.
    pszDsaDns (OUT) - The GUID Based DNS address.

Return Value:

    xList Return Code

--*/
{
    DWORD    dwRet;
    struct berval ** ppbvObjectGuid = NULL;

    Assert(hLdap && pDsaEntry && pszDsaDns);
    *pszDsaDns = NULL;

    ppbvObjectGuid = ldap_get_values_lenW (hLdap, pDsaEntry, L"objectGUID");
    if (ppbvObjectGuid == NULL ||
        ppbvObjectGuid[0] == NULL) {
        dwRet = LdapGetLastError();
        xListEnsureError(dwRet);
        return(dwRet);
    }
    Assert(ppbvObjectGuid[0]->bv_len == sizeof(GUID));

    dwRet = xListGetGuidDnsName((GUID *) ppbvObjectGuid[0]->bv_val,
                                pszDsaDns);
    if (dwRet) {
        ldap_value_free_len(ppbvObjectGuid);
        xListEnsureNull(*pszDsaDns);
        return(dwRet);
    }

    Assert(*pszDsaDns && (dwRet == ERROR_SUCCESS));
    return(dwRet);
}


DWORD
ServerToDsaSearch(
    XLIST_LDAP_SEARCH_STATE *  pServerSearch,
    XLIST_LDAP_SEARCH_STATE ** ppDsaSearch
    )
/*++

Routine Description:

    This is kind of a strange function, it's just an optimization.  It takes an already
    started search state and walks the (server) objects until it finds an DSA (aka
    "nTDSDSA" aka "NTDS Settings") object below a server object.  Then it quits and 
    returns the search state pointing at the DSA object.

Arguments:

    pServerSearch (IN) - Started server object search.  This should be a search state
        with a filter for (objectCategory=Server) based under the base Sites DN or
        a specific site's DN.
    ppDsaSearch (OUT) - the allocated search state to the DSA object.  On success we
        will allocate this, Caller's responsibility to free it using LdapSearchFree().
        See LdapSearchFirst() for better understanding of the search state we pass back.

Return Value:

    xList Return Code

--*/
{
    DWORD      dwRet = ERROR_SUCCESS;
    WCHAR *    szServerObjDn = NULL;

    Assert(pServerSearch);
    Assert(ppDsaSearch);

    *ppDsaSearch = NULL;

    __try{

        while (dwRet == 0 &&
               LdapSearchHasEntry(pServerSearch)) {

            // Unfortunately, it's possible to have several server objects
            // and only one of them represent a real DSA object.  This will
            // be the one with the DSA object below it.

            szServerObjDn = ldap_get_dnW(pServerSearch->hLdap, 
                                         pServerSearch->pCurEntry);
            if (szServerObjDn == NULL) {
                ; // push on even though this failed ... this probably means
                // we'll soon fail with an out of memory error.

            } else {

                dwRet = LdapSearchFirst(pServerSearch->hLdap, 
                                        szServerObjDn,
                                        LDAP_SCOPE_ONELEVEL,
                                        L"(objectCategory=nTDSDSA)",
                                        pszDsaAttrs,
                                        ppDsaSearch);
                if (dwRet == ERROR_SUCCESS &&
                    LdapSearchHasEntry(*ppDsaSearch)) {

                    //
                    // Success!
                    //
                    __leave;

                } else {
                    // Either real error, or no DSA object under it (quasi-success
                    // as far as LdapSearchFirst() is concerned), either way
                    // we'll push on to the next server object.
                    if (dwRet) {
                        dwRet = xListClearErrorsInternal(CLEAR_ALL);
                    } else {
                        LdapSearchFree(ppDsaSearch);
                    }
                    Assert(szServerObjDn);
                    ldap_memfreeW(szServerObjDn);
                    szServerObjDn = NULL;
                    dwRet = xListEnsureCleanErrorState(dwRet);
                    xListEnsureNull(*ppDsaSearch);
                }

            }

            dwRet = LdapSearchNext(pServerSearch);
        
        } 

        if (dwRet) {
            dwRet = xListClearErrorsInternal(CLEAR_ALL);
        }
        // Caller is responsible for freeing pServerSearch.
    
    } __finally {

        if (szServerObjDn) { ldap_memfreeW(szServerObjDn); }
        Assert(*ppDsaSearch == NULL || (*ppDsaSearch)->pCurEntry);

    }

    dwRet = xListEnsureCleanErrorState(dwRet);
    return(dwRet);
}

DWORD
ResolveDcNameObjs(
    LDAP *    hLdap,
    WCHAR *   szDcName,
    XLIST_LDAP_SEARCH_STATE ** ppServerObj,
    XLIST_LDAP_SEARCH_STATE ** ppDsaObj
    )
/*++

Routine Description:

    This is actually the heart of ResolveDcName*(), this routine returns
    both a valid DSA Obj and Server Obj xlist ldap search state on success,
    and NULLs on error.

Arguments:

    hLdap
    szDcName (IN) - The unknown format of the DC_NAME, the only thing we're 
        guaranteed is that the szDcName is not a NULL or dot (NULL_DC_NAME()) 
        DC_NAME.
    ppServerObj (OUT) - The xlist ldap search state, with (*ppServerObj)->pCurEntry
        pointing to the LDAPMessage of the server object on success.
    ppDsaObj (OUT) - The xlist ldap search state, with (*ppDsaObj)->pCurEntry
        pointing to the LDAPMessage of the DSA object on success.

Return Value:

    xList Return Code.

--*/
{
    #define DSA_MATCH_DN_FILTER             L"(&(objectCategory=nTDSDSA)(distinguishedName=%ws))"
    #define DSA_MATCH_DN_OR_GUID_FILTER     L"(&(objectCategory=nTDSDSA)(|(objectGuid=%ws)(distinguishedName=%ws)))"
    #define SERVER_MATCH_OBJ_OR_DNS_FILTER  L"(&(objectCategory=server)(|(name=%ws)(dNSHostName=%ws)))"
    XLIST_LDAP_SEARCH_STATE * pServerObj = NULL;
    XLIST_LDAP_SEARCH_STATE * pDsaObj = NULL;
    WCHAR *     szSiteBaseDn = NULL;
    WCHAR *     szFilter = NULL;
    WCHAR *     szDsaObjDn = NULL;
    WCHAR *     szServerObjDn = NULL;
    WCHAR *     szTrimmedDn = NULL;
    DWORD       dwRet;
    GUID        GuidName = { 0 };
    WCHAR       szLdapGuidBlob [MakeLdapBinaryStringSizeCch(sizeof(GUID))];
    WCHAR       wcTemp;

    Assert(hLdap);
    Assert(!NULL_DC_NAME(szDcName));
    Assert(ppServerObj && ppDsaObj);

    // NULL out parameters
    *ppServerObj = NULL;
    *ppDsaObj = NULL;

    __try {

        // Need the base sites dn - ex: CN=Sites,CN=Configuration,DC=ntdev,...
        dwRet = xListGetBaseSitesDn(hLdap, &szSiteBaseDn);
        if (dwRet) {
            // Sets and returns xList error state.
            __leave;
        }

        // 
        // 1) First we'll try for a DSA object
        //

        dwRet = ERROR_INVALID_PARAMETER;
        if (wcslen(szDcName) > 35) {
            // Try turning the GUID DNS name into a pure GUID string and convert it ...
            wcTemp = szDcName[36];
            szDcName[36] = L'\0';
            dwRet = UuidFromStringW(szDcName, &GuidName);
            szDcName[36] = wcTemp;
        }
        if (!dwRet) {
            Assert(!fNullUuid(&GuidName));
            dwRet = MakeLdapBinaryStringCb(szLdapGuidBlob, 
                                           sizeof(szLdapGuidBlob), 
                                           &GuidName,
                                           sizeof(GUID));
            if (dwRet) {
                dwRet = xListSetWin32Error(dwRet);
                Assert(!"Hmmm, should never fail");
                __leave;
            }

            dwRet = MakeString2(DSA_MATCH_DN_OR_GUID_FILTER, szLdapGuidBlob, szDcName, &szFilter);
            if (dwRet) {
                dwRet = xListSetWin32Error(dwRet);
                xListEnsureNull(szFilter);
                __leave;
            }
        } else {
            dwRet = MakeString2(DSA_MATCH_DN_FILTER, szDcName, NULL, &szFilter);
            if (dwRet) {
                dwRet = xListSetWin32Error(dwRet);
                xListEnsureNull(szFilter);
                __leave;
            }
        }
        Assert(szFilter);

        dwRet = LdapSearchFirst(hLdap, 
                                szSiteBaseDn, 
                                LDAP_SCOPE_SUBTREE, 
                                szFilter, 
                                pszDsaAttrs, 
                                &pDsaObj);
        if (dwRet == ERROR_SUCCESS &&
            LdapSearchHasEntry(pDsaObj)) {

            // Cool, matched ... try for the pServerObj now ...

            // Trim DN by 1, to get server object DN.
            szDsaObjDn = ldap_get_dnW(hLdap, pDsaObj->pCurEntry);
            if (szDsaObjDn == NULL) {
                dwRet = xListSetLdapError(LdapGetLastError(), hLdap);
                xListEnsureError(dwRet);
                __leave;
            }
            szTrimmedDn = TrimStringDnBy(szDsaObjDn, 1);
            if (szTrimmedDn == NULL || szTrimmedDn[0] == L'\0') {
                dwRet = xListSetWin32Error(GetLastError());
                xListEnsureError(dwRet);
                __leave;
            }

            dwRet = LdapSearchFirst(hLdap,
                                    szTrimmedDn,
                                    LDAP_SCOPE_BASE,
                                    L"(objectCategory=*)",
                                    pszServerAttrs,
                                    &pServerObj);

            if (dwRet == LDAP_SUCCESS &&
                LdapSearchHasEntry(pServerObj)) {

                //
                //  Success!!!
                //
                __leave;
            } else {
                // This must be one of two relatively rare cases, either the server
                // went down between these two searches, or the object was removed
                // between the two searches.
                if (dwRet == LDAP_SUCCESS) {
                    // LdapSearchFirst sets and returns xList error state if
                    // it wasn't just a missing object.
                    dwRet = xListSetWin32Error(ERROR_DS_CANT_FIND_DSA_OBJ);
                }
                xListEnsureError(dwRet);
                // We just bail, because continuing with the other searches is
                // very unlikely 
                __leave; 
            }

        } else {
            // Well if we couldn't find the DSA object, it's no big deal, because the
            // user may have specified some other form of the servers name, like the
            // DNS name.  
            //          .... we'll just clear the errors and continue on.
            //
            LdapSearchFree(&pDsaObj);
            dwRet = xListClearErrorsInternal(CLEAR_ALL);
            dwRet = xListEnsureCleanErrorState(dwRet);
        }

        //
        // 2) Second, try for a server object.
        //
        xListFree(szFilter);
        szFilter = NULL;
        dwRet = MakeString2(SERVER_MATCH_OBJ_OR_DNS_FILTER, szDcName, szDcName, &szFilter);
        if (dwRet) {
            dwRet = xListSetWin32Error(dwRet);
            __leave;
        }
        Assert(szFilter);

        dwRet = LdapSearchFirst(hLdap, 
                                szSiteBaseDn, 
                                LDAP_SCOPE_SUBTREE, 
                                szFilter, 
                                pszServerAttrs, 
                                &pServerObj);
        if ( dwRet ||
             !LdapSearchHasEntry(pServerObj)) {

            if (dwRet == 0) {
                // This is a quasi-success, but this function treats a quasi success
                // as failure.
                dwRet = xListSetWin32Error(ERROR_DS_CANT_FIND_DSA_OBJ);
                dwRet = xListSetReason(XLIST_ERR_CANT_RESOLVE_DC_NAME);
            }
            xListEnsureError(dwRet);
            __leave;
        }

        // This is kind of an interesting function, it takes a search of server
        // objects and starts walking through the entries, until it searches 
        // and finds a DSA object below one of them.
        dwRet = ServerToDsaSearch(pServerObj, &pDsaObj);
        Assert(dwRet == ERROR_SUCCESS);
        if (dwRet == ERROR_SUCCESS && 
            LdapSearchHasEntry(pDsaObj)) {
            
            //
            // Success
            //
            Assert(pServerObj->pCurEntry);
            __leave;

        } else {
            // ServerToDsaSearch() sets and returns XList error state.
            if (dwRet == 0) {
                // Hmmm, this means our search was successful in that there was no
                // error talking to the server, but unsuccessful in that we didn't
                // find any server objects that qualified for our search. Not 
                // finding a server though is fatal in this function.
                dwRet = xListSetWin32Error(ERROR_DS_CANT_FIND_DSA_OBJ);
                dwRet = xListSetReason(XLIST_ERR_CANT_RESOLVE_DC_NAME);
            }
        }

        xListEnsureError(dwRet);

        // FUTURE-2002/07/07-BrettSh In the future we could add the ability to
        // search for the NetBios name, but for now we'll fail.  This would require
        // a binding to a GC, because the NetBios name is on the DC Server Account
        // Object, and so far we've managed to constrain all searches to the Config
        // container.  Also generally the NetBios name is the same as the RDN of
        // the server object, so we probably caught the server in the above searches.

    } __finally {

        if ( szSiteBaseDn ) { xListFree(szSiteBaseDn); szSiteBaseDn = NULL; }
        if ( szFilter ) { xListFree(szFilter); szFilter = NULL; }
        if ( szDsaObjDn ) { ldap_memfreeW(szDsaObjDn); szDsaObjDn = NULL; }
        if ( szServerObjDn ) { ldap_memfreeW(szServerObjDn); szServerObjDn = NULL; }
        if ( szTrimmedDn ) { LocalFree(szTrimmedDn); szTrimmedDn = NULL;}

        if (dwRet) {
            // Error condition
            if (pServerObj) { LdapSearchFree(&pServerObj); }
            if (pDsaObj) { LdapSearchFree(&pDsaObj); }
        }

    }

    // Are both expected out params present, if they aren't we should have
    // an error.
    if (pServerObj == NULL ||
        pDsaObj == NULL) {
        xListEnsureError(dwRet);
    }

    // If successful assign out params.
    if (dwRet == 0) {
        *ppDsaObj = pDsaObj;
        *ppServerObj = pServerObj;
    }

    return(dwRet);
}
                                            
DWORD
xListServerEntryToDns(
    LDAP *         hLdap,
    LDAPMessage *  pServerEntry,
    LDAPMessage *  pDsaEntry,
    WCHAR **       pszDsaDns
    )
/*++

Routine Description:

    This routine takes a LDAPMessage entry pointing to a Server object, and it
    tries to retrieve the dNSHostName off of the object.

Arguments:

    hLdap -
    pServerEntry (IN) - LDAPMessage pointing to the server object.
    pszDsaDns (OUT) - The DNS name off the server object.

Return Value:

    xList Return Code.

--*/
{
    DWORD     dwRet = ERROR_SUCCESS;
    WCHAR **  pszDnsName;

    Assert(pszDsaDns);
    *pszDsaDns = NULL;

    pszDnsName = ldap_get_valuesW(hLdap, pServerEntry, L"dNSHostName");
    if (pszDnsName == NULL ||
        pszDnsName[0] == NULL) {
        // Ahhh, Bollocks!  Apparently, the dNSHostName is set by the DC after
        // reboot, not when the object is created, so ... lets fail back to the
        // constructing the less pretty GUID based name.
        return(xListDsaEntryToDns(hLdap, pDsaEntry, pszDsaDns));
    }
    xListQuickStrCopy(*pszDsaDns, pszDnsName[0], dwRet, return(dwRet));
    ldap_value_freeW(pszDnsName);

    Assert(!dwRet);
    return(dwRet);
}

DWORD
ResolveDcNameToDsaGuid(
    LDAP *    hLdap,
    WCHAR *   szDcName,
    GUID *    pDsaGuid
    )
/*++

Routine Description:

    This routine takes a szDcName, and tries to turn it into a DSA guid.  In the
    case the passed in szDcName string is a string GUID, we cheat and just convert 
    it and return it without any searches to make sure it's a real DSA guid.

Arguments:

    hLdap -
    szDcName (IN) - DC_NAME syntax, so a GUID, or DNS name, or DN, or //
    pDsaGuid (IN/OUT) - pointer to a sizeof(GUID) buffer for us to store
        the GUID in.

Return Value:

    xList Return Code.

--*/
{
    XLIST_LDAP_SEARCH_STATE *   pServerObj;
    XLIST_LDAP_SEARCH_STATE *   pDsaObj;
    struct berval **            ppbvObjectGuid = NULL;
    DWORD                       dwRet = ERROR_SUCCESS;

    Assert(pDsaGuid);

    memset(pDsaGuid, 0, sizeof(GUID)); // NULL out parameter

    if (NULL_DC_NAME(szDcName)) {
        // This doesn't make much sense...
        return(xListSetReason(XLIST_ERR_CANT_RESOLVE_DC_NAME));
    }
    
    dwRet = UuidFromStringW(szDcName, pDsaGuid);
    if (dwRet == RPC_S_OK) {
        // 
        // Success, the cheap way.
        //
        Assert(!fNullUuid(pDsaGuid));
        return(0);
    } else {
        memset(pDsaGuid, 0, sizeof(GUID)); // for sanity's sake.
    }

    dwRet = xListGetHomeServer(&hLdap);
    if (dwRet) {
        return(dwRet);
    }
    Assert(hLdap);

    __try {

        dwRet = ResolveDcNameObjs(hLdap, szDcName, &pServerObj, &pDsaObj);
        if (dwRet) {
            __leave;
        }
        Assert(LdapSearchHasEntry(pServerObj) && LdapSearchHasEntry(pDsaObj));

        ppbvObjectGuid = ldap_get_values_lenW(hLdap, pDsaObj->pCurEntry, L"objectGuid");
        if (ppbvObjectGuid == NULL ||
            ppbvObjectGuid[0] == NULL ||
            ppbvObjectGuid[0]->bv_len != sizeof(GUID)) {
            Assert(ppbvObjectGuid == NULL || ppbvObjectGuid[0] == NULL && 
                   "Really? The ->bv_len != sizeof(GUID) check failed!?!");
            dwRet = xListSetLdapError(LdapGetLastError(), hLdap);
            __leave;
        }
        memcpy(pDsaGuid, ppbvObjectGuid[0]->bv_val, sizeof(GUID));
        if (fNullUuid(pDsaGuid)) {
            Assert(!"Huh!");
            dwRet = xListSetReason(XLIST_ERR_CANT_RESOLVE_DC_NAME);
            xListSetArg(szDcName);
            __leave;
        }

    } __finally {
        if (pServerObj) { LdapSearchFree(&pServerObj); }
        if (pDsaObj) { LdapSearchFree(&pDsaObj); }
    }

    return(dwRet);
}

DWORD
ResolveDcNameToDns(
    LDAP *    hLdap,
    WCHAR *   szDcName, 
    WCHAR **  pszDsaDns
    )
/*++

Routine Description:

    This is used to resolve a DC_NAME format when a pDcList->eKind == eDcName, and 
    not some more complicated DC_LIST format.  We however don't know if the szDcName
    is a GUID, a RDN, a DNS Name, NetBios, or DN.

Arguments:

    hLdap -
    szDcName (IN) - The string DC_NAME format.
    pszDsaDns (OUT) - The DNS of the DSA specified by the szDcName.
                                                                       
Return Value:

    xList Return Code.

--*/
{
    LDAP * hLdapTemp;
    DWORD dwRet = ERROR_SUCCESS;
    GUID  GuidName = { 0 };
    XLIST_LDAP_SEARCH_STATE * pServerObj;
    XLIST_LDAP_SEARCH_STATE * pDsaObj;

    // We can expect 5 kinds of labels for a single DSA to come into this 
    // function.  DNS, NetBios, DSA Guid, DSA DN, and "." or NULL

    Assert(szDcName);
    Assert(hLdap == NULL || !NULL_DC_NAME(szDcName));

    //
    // 1) "Connectable" DNS or NetBios
    // 
    // Catch the case where we have a connectable DNS or NetBios here.
    //
    // NOTE: This is just an optimization, so that in the case we're provided DNS or NetBios
    // that we can connect to, we just connect and move on without getting involved in large
    // queries.

    if ( !NULL_DC_NAME(szDcName) && // non-null DC_NAME
         ( (ERROR_SUCCESS == (dwRet = DnsValidateName(szDcName, DnsNameHostnameFull))) ||
           (DNS_ERROR_NON_RFC_NAME == dwRet)) && // is DNS name or non-RFC DNS name
         ( dwRet = UuidFromStringW(szDcName, &GuidName) ) // not a GUID (GUIDs look like DNS names)
        ) {
        
        // Hey, maybe this a normal DNS or NetBios name, lets just try to connect to it.

        dwRet = xListConnect(szDcName, &hLdapTemp);
        if (dwRet == ERROR_SUCCESS && 
            hLdapTemp != NULL) {

            //
            // Success, just unbind and return this DNS Name.
            //
            if (gszHomeServer == NULL) {
                // If we don't have a home server yet, we'll pick the first one we connected to.
                xListQuickStrCopy(gszHomeServer, szDcName, dwRet, return(dwRet));
            }
            ldap_unbind(hLdapTemp);
            xListQuickStrCopy(*pszDsaDns, szDcName, dwRet, return(dwRet));
            Assert(!dwRet && *pszDsaDns);
            return(dwRet);
        }
        xListEnsureNull(hLdapTemp);
        
        // We couldn't connect to the szDcName, so lets fail through and search for it.
    } 

    // Clean errors if there were any.
    dwRet = xListClearErrorsInternal(CLEAR_ALL);
    dwRet = xListEnsureCleanErrorState(dwRet);

    //
    // 2) Non-connectable name.
    //
    // Note this still could be a DNS name, but server was down, or DNS registrations
    // are wacked, or this could be GUID, DSA DN, etc...
    //

    // But, before we can figure out what the user specified we need to get an
    // LDAP server in the enterprise to talk to.  If the user didn't give us an
    // LDAP to use, use the "home server", this function will also locate a home
    // server if necessary.
    if (hLdap == NULL) {

        dwRet = xListGetHomeServer(&hLdap);
        if (dwRet != ERROR_SUCCESS) {
            // We're out of luck here, if we can't get anyone in the AD to talk to.
            // xListGetHomeServer should've set a proper xList Return Code.
            return(dwRet);
        }
    }

    Assert(hLdap);

    //
    // 3) "NULL" DC_NAME
    //
    // User specified a nothing (NULL), "", or a ".", this means the user wants
    // us to find locate the server for them.  So we'll use the home server that
    // we just located.
    //
    if ( NULL_DC_NAME(szDcName) ) {

        Assert(gszHomeServer);
        
        // This means the user didn't specify any server, so use the
        // home server we located.
        xListQuickStrCopy(*pszDsaDns, gszHomeServer, dwRet, return(dwRet));
        return(ERROR_SUCCESS);

    }

    //
    // 4) Non-connectable, non-"null" DC_NAME
    //
    // User did specify something, but we don't know if it's a DN, or/a GUID or
    // DMS. or what, so we're going to do a little search.  All we know is it's
    // NOT a "." or NULL.

    __try {

        dwRet = ResolveDcNameObjs(hLdap, szDcName, &pServerObj, &pDsaObj);
        if (dwRet) {
            __leave;
        }
        Assert(LdapSearchHasEntry(pServerObj) && LdapSearchHasEntry(pDsaObj));

        dwRet = xListServerEntryToDns(hLdap, pServerObj->pCurEntry, pDsaObj->pCurEntry, pszDsaDns);
        if (dwRet) {

            xListEnsureNull(*pszDsaDns);
            __leave;
        }

        //
        // FUTURE-2002/07/07-BrettSh Optionally we could use the GUID DNS name off
        // of pDsaObj, or we could even return multiple names w/ spaces inbetween,
        // so we get maximum failover.  We could at least fail over to GUID DNS
        // name if we can't pull the dNSHostName off the Server Object?

    } __finally {
        if (pServerObj) { LdapSearchFree(&pServerObj); }
        if (pDsaObj) { LdapSearchFree(&pDsaObj); }
    }

    if (*pszDsaDns == NULL) {
        xListEnsureError(dwRet);
    }
    return(dwRet);
}


void
DcListFree(
    PDC_LIST * ppDcList
    )

/*++

Routine Description:

    Use this to free a pDcList pointer allocated by DcListParse().

Arguments:
    
    ppDcList - Pointer to the pointer to the DC_LIST struct.  We set the
        pointer to NULL for you, to avoid accidents.

--*/

{
    PDC_LIST pDcList;

    Assert(ppDcList && *ppDcList);
    
    // Null out user's DC_LIST blob
    pDcList = *ppDcList;
    *ppDcList = NULL;

    // Now try to free it.
    if (pDcList) {
        if (pDcList->szSpecifier) {
            xListFree(pDcList->szSpecifier);
        }
        if (pDcList->pSearch) {
            LdapSearchFree(&(pDcList->pSearch));
        }
        LocalFree(pDcList);
    }
    
}
    

DWORD
DcListParse(
    WCHAR *    szQuery,
    PDC_LIST * ppDcList
    )
/*++

Routine Description:

    This parses the szQuery which should be a DC_LIST syntax.
    
    NOTE: This function is not internationalizeable, it'd be nice if it was though,
    but it isn't currently.  Work would need to be done to put each of the specifiers
    in it's own string constant.

Arguments:

    szQuery (IN) - The DC_LIST syntax query.
    ppDcList (OUT) - Our allocated DC_LIST structure to be provided
        to DcListGetFirst()/DcListGetNext() to enumerate the DCs via
        DNS.  Note free this structure with DcListFree();

Return Value:

    xList Return Code

--*/
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    PDC_LIST pDcList = NULL;
    WCHAR * szTemp;

    xListAPIEnterValidation();
    Assert(ppDcList);
    xListEnsureNull(*ppDcList);
    
    __try{

        pDcList = LocalAlloc(LPTR, sizeof(DC_LIST)); // zero init'd
        if (pDcList == NULL) {
            dwRet = GetLastError();
            Assert(dwRet);
            __leave;
        }

        pDcList->cDcs = 0;

        if (szQuery == NULL || szQuery[0] == L'\0') {
            // blank is treated as a dot.
            szQuery = L".";
        }
        
        if (szTemp = GetDelimiter(szQuery, L':')) {

            //
            // Conversion list of some sort, but which kind?
            //
            if(wcsistr(szQuery, L"site:")){
                pDcList->eKind = eSite;
                xListQuickStrCopy(pDcList->szSpecifier, szTemp, dwRet, __leave);
                dwRet = ERROR_SUCCESS;

            } else if (wcsistr(szQuery, L"gc:")) {
                pDcList->eKind = eGc;
                pDcList->szSpecifier = NULL;
                dwRet = ERROR_SUCCESS;

            } else if (wcsistr(szQuery, L"fsmo_dnm:")) {
                pDcList->eKind = eFsmoDnm;
                xListQuickStrCopy(pDcList->szSpecifier, szTemp, dwRet, __leave);
                dwRet = ERROR_SUCCESS;
            } else if (wcsistr(szQuery, L"fsmo_schema:")) {
                pDcList->eKind = eFsmoSchema;
                xListQuickStrCopy(pDcList->szSpecifier, szTemp, dwRet, __leave);
                dwRet = ERROR_SUCCESS;
            } else if (wcsistr(szQuery, L"fsmo_im:")) {
                pDcList->eKind = eFsmoIm;
                xListQuickStrCopy(pDcList->szSpecifier, szTemp, dwRet, __leave);
                dwRet = ERROR_SUCCESS;
            } else if (wcsistr(szQuery, L"fsmo_pdc:")) {
                pDcList->eKind = eFsmoPdc;
                xListQuickStrCopy(pDcList->szSpecifier, szTemp, dwRet, __leave);
                dwRet = ERROR_SUCCESS;
            } else if (wcsistr(szQuery, L"fsmo_rid:")) {
                pDcList->eKind = eFsmoRid;
                xListQuickStrCopy(pDcList->szSpecifier, szTemp, dwRet, __leave);
                dwRet = ERROR_SUCCESS;

            } else if (wcsistr(szQuery, L"fsmo_istg:")) {
                pDcList->eKind = eIstg;
                xListQuickStrCopy(pDcList->szSpecifier, szTemp, dwRet, __leave);
                dwRet = ERROR_SUCCESS;

            }

        } else if(szTemp = GetDelimiter(szQuery, L'*')){

            //
            // Wildcard list.
            //
            pDcList->eKind = eWildcard;
            xListQuickStrCopy(pDcList->szSpecifier, szQuery, dwRet, __leave);
            dwRet = ERROR_SUCCESS;

        } else {

            //
            // The normal case, of a single DC (DNS, GUID, DN, ?)
            //
            pDcList->eKind = eDcName;
            xListQuickStrCopy(pDcList->szSpecifier, szQuery, dwRet, __leave);
            dwRet = ERROR_SUCCESS;

        }

    } __finally {
        if (dwRet != ERROR_SUCCESS) {
            // Turn the normal error into an xList Return Code.
            dwRet = xListSetWin32Error(dwRet);
            dwRet = xListSetReason(XLIST_ERR_PARSE_FAILURE);
            DcListFree(&pDcList);
        }
    }

    *ppDcList = pDcList;
    xListAPIExitValidation(dwRet);
    Assert(dwRet || *ppDcList);
    return(dwRet);
}

enum {
    eNoList = 0,
    eDcList = 1,
    eSiteList = 2,
    eNcList = 3,
} xListType;

DWORD
DcListGetFirst(
    PDC_LIST    pDcList, 
    WCHAR **    pszDsaDns
    )
/*++

Routine Description:

    This takes a DC_LIST structure (allocated and initialized by DcListParse())
    and gets the first DC (via DNS) specified in the pDcList structure.

Arguments:

    pDcList (IN) - DC_LIST structure returned by DcListParse()
    pszDsaDns (OUT) - A DNS name of the server, it may be the Guid Base DNS name
        or the dNSHostName attribute off the server object currently.

Return Value:

    xList Return Code.

--*/
{
    #define WILDCARD_SEARCH_FILTER          L"(&(objectCategory=server)(|(name=%ws)(dNSHostName=%ws)))"
    DWORD       dwRet = ERROR_INVALID_FUNCTION;
    LDAP *      hLdap;
    LDAP *      hFsmoLdap;
    BOOL        bFreeBaseDn = FALSE;
    BOOL        bFreeFilter = FALSE;
    WCHAR *     szBaseDn = NULL; 
    WCHAR *     szFilter = NULL;
    ULONG       eFsmoType = 0;
    WCHAR *     szFsmoDns = NULL;

    XLIST_LDAP_SEARCH_STATE *  pDsaSearch = NULL;

    xListAPIEnterValidation();

    if (pDcList == NULL ||
        pszDsaDns == NULL) {
        Assert(!"Programmer error ...");
        return(ERROR_INVALID_PARAMETER);
    }
    xListEnsureNull(*pszDsaDns);

    __try{

        // 
        // Phase 0 - get home server if needed.
        //
        if (pDcList->eKind != eDcName) {
            dwRet = xListGetHomeServer(&hLdap);
            if (dwRet) {
                __leave;
            }
            Assert(hLdap);
        }

        //
        // Phase I - resolve simple DC_LISTs and setup
        //           search params (szBaseDn & szFilter)
        //
        switch (pDcList->eKind) {
        case eDcName:

            dwRet = ResolveDcNameToDns(NULL, pDcList->szSpecifier, pszDsaDns); // Do we need to pass an hLdap?
            if (dwRet) {
                xListSetArg(pDcList->szSpecifier);
                __leave;
            }
            break;

        case eWildcard:

            dwRet = xListGetBaseSitesDn(hLdap, &szBaseDn);
            if (dwRet) {
                __leave;
            }
            bFreeBaseDn = TRUE;
            dwRet = MakeString2(WILDCARD_SEARCH_FILTER, 
                                pDcList->szSpecifier, 
                                pDcList->szSpecifier, 
                                &szFilter);
            if (dwRet) {
                __leave;
            }
            bFreeFilter = TRUE;
            Assert(szBaseDn && szFilter);
            break;

        case eGc:

            dwRet = xListGetBaseSitesDn(hLdap, &szBaseDn);
            if (dwRet) {
                __leave;
            }
            bFreeBaseDn = TRUE;
            // This magic filter will return only DSA objects with the 1 bit
            // set in thier options attribute (i.e. GCs)
            szFilter = L"(&(objectCategory=nTDSDSA)(options:1.2.840.113556.1.4.803:=1))";
            Assert(szBaseDn && szFilter);
            break;

        case eSite:
        case eIstg: // note eIstg doesn't use the szFilter set for eSite.

            dwRet = ResolveSiteNameToDn(hLdap, pDcList->szSpecifier, &szBaseDn);
            if (dwRet) {
                __leave;
            }
            bFreeBaseDn = TRUE;
            szFilter = L"(objectCategory=nTDSDSA)"; // only used by eKind == eSite
            eFsmoType = E_ISTG;                     // only used by eKind == eIstg
            Assert(szBaseDn && szFilter);
            break;

        case eFsmoIm:
        case eFsmoPdc:
        case eFsmoRid:

            Assert(ghHomeLdap);

            // We expect the pDcList->szSpecifer to be the NC, otherwise we'll use the
            // default domain of the home server.
            
            // FUTURE-2002/07/08-BrettSh pDcList->szSpecifier should be resolved w/ 
            // usually NcList semantics, so "config:", "domain:", "ntdev.microsoft.com"
            // could be specified.

            if (NULL_DC_NAME(pDcList->szSpecifier)) {
                pDcList->szSpecifier = gszHomeDomainDn;
            }

            if (pDcList->eKind == eFsmoIm) {
                szBaseDn = pDcList->szSpecifier;
                eFsmoType = E_IM;

            } else if (pDcList->eKind == eFsmoPdc) {
                szBaseDn = pDcList->szSpecifier;
                eFsmoType = E_PDC;

            } else if (pDcList->eKind == eFsmoRid) {
                szBaseDn = pDcList->szSpecifier;
                eFsmoType = E_RID;

            }
            break;

        case eFsmoDnm:
        case eFsmoSchema:
            
            Assert(ghHomeLdap && gszHomePartitionsDn && gszHomeSchemaDn);

            if (pDcList->eKind == eFsmoDnm) {
                szBaseDn = gszHomePartitionsDn;
                eFsmoType = E_DNM;

            } else if (pDcList->eKind == eFsmoSchema) {
                szBaseDn = gszHomeSchemaDn;
                eFsmoType = E_SCHEMA;

            }
            break;

        default:
            Assert(!"Code inconsistency ... no DcList type should be unhandled here");
            break;
        }
        
        // 
        // Phase II - Begin search... 
        //
        switch (pDcList->eKind) {
        
        case eGc:
        case eSite:

            Assert(szBaseDn && szFilter);
            dwRet = LdapSearchFirst(hLdap,
                                           szBaseDn, 
                                           LDAP_SCOPE_SUBTREE, 
                                           szFilter,
                                           pszDsaAttrs,
                                           &(pDcList->pSearch));
            if (dwRet == ERROR_SUCCESS && 
                LdapSearchHasEntry(pDcList->pSearch)) {

                // Yeah we got our first DSA object, we use it to get the GUID based DNS name
                // because it's convienent.
                dwRet = xListDsaEntryToDns(hLdap, pDcList->pSearch->pCurEntry, pszDsaDns);
                if (dwRet) {
                    __leave;
                }

                break;
                
            }

            break;

        case eWildcard:

            Assert(szBaseDn && szFilter);
            dwRet = LdapSearchFirst(hLdap,      
                                           szBaseDn, 
                                           LDAP_SCOPE_SUBTREE, 
                                           szFilter,
                                           pszServerAttrs,
                                           &(pDcList->pSearch));

            if (dwRet == ERROR_SUCCESS &&
                LdapSearchHasEntry(pDcList->pSearch)) {

                // This is kind of an interesting function, it takes a search of server
                // objects and starts walking through the entries, until it searches 
                // and finds a DSA object below one of them.
                dwRet = ServerToDsaSearch(pDcList->pSearch, &pDsaSearch);
                Assert(dwRet == ERROR_SUCCESS);
                if (dwRet == ERROR_SUCCESS &&
                    LdapSearchHasEntry(pDsaSearch)) {

                    Assert(LdapSearchHasEntry(pDcList->pSearch));

                    dwRet = xListServerEntryToDns(hLdap,
                                                  pDcList->pSearch->pCurEntry, 
                                                  pDsaSearch->pCurEntry,
                                                  pszDsaDns);
                    LdapSearchFree(&pDsaSearch);

                    if (dwRet) {
                        __leave;
                    }

                    //
                    // Success.
                    //

                } else {
                    // failure or quasi-success ... 
                    // On DcListGetFirst() we'll force quasi-succes to failure, 
                    // because presumeably the user wanted at last one server.
                    if (pDsaSearch) {
                        LdapSearchFree(&pDsaSearch);
                    }
                    if (dwRet == 0) {
                        dwRet = xListSetWin32Error(ERROR_DS_CANT_FIND_DSA_OBJ);
                    }
                    dwRet = xListSetReason(XLIST_ERR_CANT_RESOLVE_DC_NAME);
                    xListSetArg(pDcList->szSpecifier);
                }

            } else {

                //
                // failure or quasi-success from LdapSearchFirst()
                //
                // On DcListGetFirst() we'll force quasi-succes to failure, because 
                // presumeably the user/caller wanted at last one server.

                if (dwRet == 0) {
                    dwRet = xListSetWin32Error(ERROR_DS_CANT_FIND_DSA_OBJ);
                    dwRet = xListSetReason(XLIST_ERR_CANT_RESOLVE_DC_NAME);
                    xListSetArg(pDcList->szSpecifier);
                }
                __leave;
            }
            break;

        case eIstg:
        case eFsmoIm:
        case eFsmoPdc:
        case eFsmoRid:
        case eFsmoDnm:
        case eFsmoSchema:
            
            // At this point all FSMO's can be treated the same, even the quasi-fsmo ISTG role
            Assert(eFsmoType && szBaseDn);
            
            hFsmoLdap = GetFsmoLdapBinding(gszHomeServer, eFsmoType, szBaseDn, (void*) TRUE, gpCreds, &dwRet);
            if (hFsmoLdap) {
                // BTW, we're not supposed to free szFsmoDns, when we get in this way!
                dwRet = ldap_get_optionW(hFsmoLdap, LDAP_OPT_HOST_NAME, &szFsmoDns);
                if(dwRet || szFsmoDns == NULL){
                    dwRet = xListSetLdapError(dwRet, hFsmoLdap);
                    dwRet = xListSetReason(XLIST_ERR_CANT_GET_FSMO);
                    xListEnsureError(dwRet);
                    ldap_unbind(hFsmoLdap);
                    __leave;
                }
                xListQuickStrCopy(*pszDsaDns, szFsmoDns, dwRet, __leave);
                ldap_unbind(hFsmoLdap); // Freeing the LDAP *, fress szFsmoDns, BTW
                
            } else {
                // Be nice to set a better LDAP error state here.
                dwRet = xListSetWin32Error(ERROR_DS_COULDNT_CONTACT_FSMO); 
                dwRet = xListSetReason(XLIST_ERR_CANT_GET_FSMO);
                xListSetArg(szBaseDn);
                __leave;
            }
            break;

        default:
            Assert(pDcList->eKind == eDcName);
            break;
        }

        Assert(dwRet == ERROR_SUCCESS);
        Assert(*pszDsaDns);

    } __finally {
        
        if (pDsaSearch)  { LdapSearchFree(&pDsaSearch); }
        if (bFreeBaseDn) { xListFree(szBaseDn); }
        if (bFreeFilter) { xListFree(szFilter); }
        if (dwRet) {
            xListEnsureNull(*pszDsaDns);
        }
    }

    if (dwRet == 0 && *pszDsaDns) {
        (pDcList->cDcs)++; // Up the DCs returned counter
    }
        
    xListAPIExitValidation(dwRet);

    return(dwRet);
}

                                          

DWORD
DcListGetNext(
    PDC_LIST    pDcList, 
    WCHAR **    pszDsaDns
    )
/*++

Routine Description:

    This takes a DC_LIST structure (allocated and initialized by DcListParse()
    _and modified_ by DcListGetFirst()) and gets the next DC (via DNS) specified 
    in the pDcList structure.

Arguments:

    pDcList (IN) - DC_LIST structure returned by DcListParse() and that had
        DcListGetFirst() called on it.  If you didn't the pDcList isn't completely
        initialized for us.
    pszDsaDns (OUT) - A DNS name of the server, it may be the Guid Base DNS name
        or the dNSHostName attribute off the server object currently.

Return Value:

    xList Return Code.

--*/
{
    DWORD dwRet = ERROR_INVALID_FUNCTION;
    XLIST_LDAP_SEARCH_STATE * pDsaSearch = NULL;

    xListAPIEnterValidation();
    Assert(pDcList && pszDsaDns);
    xListEnsureNull(*pszDsaDns);

    if (DcListIsSingleType(pDcList)){
        return(ERROR_SUCCESS);
    }

    if (pDcList->eKind == eNoKind ||
        pDcList->pSearch == NULL) {
        Assert(!"programmer malfunction!");
        return(xListSetWin32Error(ERROR_INVALID_PARAMETER));
    }

    switch (pDcList->eKind) {
    
    case eWildcard:
        
        if (pDcList->pSearch == NULL) {
            Assert(!"Code inconsistency");
            break;
        }
        
        dwRet = LdapSearchNext(pDcList->pSearch);

        if (dwRet == ERROR_SUCCESS &&
            LdapSearchHasEntry(pDcList->pSearch)) {

            // This is kind of an interesting function, it takes a search of server
            // objects and starts walking through the entries, until it searches 
            // and finds a DSA object below one of them.
            dwRet = ServerToDsaSearch(pDcList->pSearch, &pDsaSearch);
            if (dwRet == ERROR_SUCCESS &&
                LdapSearchHasEntry(pDsaSearch)) {

                dwRet = xListServerEntryToDns(pDcList->pSearch->hLdap,
                                              pDcList->pSearch->pCurEntry, 
                                              pDsaSearch->pCurEntry,
                                              pszDsaDns);

                LdapSearchFree(&pDsaSearch);

                if (dwRet) {          
                    break;
                }

                //
                // Success!
                // 

            } else {

                if (pDsaSearch) {
                    LdapSearchFree(&pDsaSearch);
                }

                if (dwRet) {
                    xListEnsureError(dwRet)
                    break;
                }

                // ServerToDsaSearch() doesn't set errors for naturally finishing
                // a Server Object Search (quasi-success) ... so we're fine, that's
                // all the servers we wanted to see.

            }

        }
        break;

    case eGc: // from this point eGc is the same as eSite
    case eSite:
        
        if (pDcList->pSearch == NULL) {
            Assert(!"Code inconsistency");
            break;
        }

        dwRet = LdapSearchNext(pDcList->pSearch);

        if (dwRet == ERROR_SUCCESS &&
            LdapSearchHasEntry(pDcList->pSearch)) {

            // Yeah we got our next DSA object.
            dwRet = xListDsaEntryToDns(pDcList->pSearch->hLdap, 
                                       pDcList->pSearch->pCurEntry, 
                                       pszDsaDns);
            Assert(dwRet || *pszDsaDns);
            break;

        } else {
            // Note: if pDcList->pSearch->pCurEntry == NULL, then
            // just the end of the result set.
            break;
        }
        break;

    default:
        Assert(!"Code inconsistency, should be un-handled types.");
        break;
    }
        
    if (dwRet == 0 && *pszDsaDns) {
        (pDcList->cDcs)++; // Up the number of DCs returned counter.
    }

    xListAPIExitValidation(dwRet);
    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\x_list\site_list.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

   xList Library - x_list_err.c

Abstract:

   This file has some extra utility functions for allocating, copying, 
   trimming DNs, etc.

Author:

    Brett Shirley (BrettSh)

Environment:

    repadmin.exe, but could be used by dcdiag too.

Notes:

Revision History:

    Brett Shirley   BrettSh     July 9th, 2002
        Created file.

--*/

#include <ntdspch.h>

// This library's main header files.
#include "x_list.h"
#include "x_list_p.h"
#define FILENO    FILENO_UTIL_XLIST_SITELIST

//          
// LDAP Argument for no attributes.
//
WCHAR * pszNoAttrs [] = {
    L"1.1",
    NULL
};
                

DWORD
xListGetBaseSitesDn(
    LDAP *    hLdap, 
    WCHAR **  pszBaseSitesDn
    )
/*++

Routine Description:

    This will get base sites DN, from the perspective of the server
    specified by the hLdap.

Arguments:

    hLdap (IN) - Server LDAP handle to get the base sites DN of.
    pszBaseSitesDn (OUT) - String of the base sites DN. NOTE:
        must use xListFree() to free it, because the function will
        return the cached sites DN if hLdap == ghHomeLdap.

Return Value:

    xList Reason

--*/
{
    DWORD dwRet;
    WCHAR * szConfigDn = NULL;
    ULONG cbBaseSitesDn;

    Assert(pszBaseSitesDn);
    *pszBaseSitesDn = NULL;

    if (hLdap == NULL) {
        dwRet = xListGetHomeServer(&hLdap);
        if (dwRet) {
            xListEnsureNull(hLdap);
            return(dwRet);
        }
    }
    Assert(hLdap);

    if (hLdap == ghHomeLdap) {
        // If the LDAP handle matches the home server's LDAP handle,
        // then we're in luck, return the cached site DN.
        *pszBaseSitesDn = gszHomeBaseSitesDn;
        return(ERROR_SUCCESS);
    }

    __try {

        //
        dwRet = GetRootAttr(hLdap, L"configurationNamingContext", &szConfigDn);
        if(dwRet){
            dwRet = xListSetLdapError(dwRet, hLdap);
            __leave;
        }

        // Get the base sites DN.
        cbBaseSitesDn = sizeof(WCHAR) *(wcslen(SITES_RDN) + wcslen(szConfigDn) + 1);
        *pszBaseSitesDn = LocalAlloc(LMEM_FIXED, cbBaseSitesDn);
        if(*pszBaseSitesDn == NULL){
            dwRet = xListSetWin32Error(GetLastError());
            __leave;
        }
        dwRet = HRESULT_CODE(StringCbCopyW(*pszBaseSitesDn, cbBaseSitesDn, SITES_RDN));
        if (dwRet) {
            dwRet = xListSetWin32Error(GetLastError());
            Assert(!"Never should happen");
            __leave;
        }
        dwRet = HRESULT_CODE(StringCbCatW(*pszBaseSitesDn, cbBaseSitesDn, szConfigDn));
        if (dwRet) {
            dwRet = xListSetWin32Error(GetLastError());
            Assert(!"Never should happen");
            __leave;
        }

    } __finally {
        if (szConfigDn) { LocalFree(szConfigDn); }
        if (dwRet && *pszBaseSitesDn) {
            xListFree(*pszBaseSitesDn);
            *pszBaseSitesDn = NULL;
        }
    }

    xListEnsureError(dwRet);
    return(dwRet);
}

DWORD
xListGetHomeSiteDn(
    WCHAR **  pszHomeSiteDn
    )
/*++

Routine Description:

    This gets the DN of the home site for the original home DC we connected to.

Arguments:

    pszHomeSiteDn (OUT) - DN of the home server's site.  Use xListFree() to free.

Return Value:

    xList Reason

--*/
{
    DWORD     dwRet;
    LDAP *    hLdap = NULL;
    
    dwRet = xListGetHomeServer(&hLdap);
    if (dwRet) {
        xListEnsureNull(hLdap);
        return(dwRet);
    }
    
    Assert(gszHomeSiteDn);
    *pszHomeSiteDn = gszHomeSiteDn;
    return(dwRet);
}


DWORD
ResolveSiteNameToDn(
    LDAP *      hLdap, 
    WCHAR *     szSiteName,
    WCHAR **    pszSiteDn
    )
/*++

Routine Description:

    This takes a SITE_NAME string and gets the FQDN of the site object.

Arguments:

    hLdap (IN) - Bound LDAP handle
    szSiteName (IN) - Site (RDN) name (such as Red-Bldg40)
    pszSiteDn (OUT) - DN of the site we're interested in.

Return Value:

    xList Reason

--*/
{
    #define   GET_SITE_FILTER    L"(&(objectCategory=site)(name=%ws))"
    DWORD    dwRet;
    XLIST_LDAP_SEARCH_STATE * pSearch = NULL;
    WCHAR *  szBaseDn = NULL;
    WCHAR *  szFilter = NULL;
    WCHAR *  szTempDn = NULL;
    
    Assert(pszSiteDn);
    Assert(hLdap);
    *pszSiteDn = NULL;

    __try{
        
        if (NULL_SITE_NAME(szSiteName)) {
            //
            // In the case of a NULL or L"." site name, we'll just use
            // our home site.
            //
            dwRet = xListGetHomeSiteDn(pszSiteDn);
            Assert(dwRet || *pszSiteDn);
            __leave;
        }

        dwRet = xListGetBaseSitesDn(hLdap, &szBaseDn);
        if (dwRet) {
            __leave;
        }

        dwRet = MakeString2(GET_SITE_FILTER, szSiteName, NULL, &szFilter);
        if (dwRet) {
            dwRet = xListSetWin32Error(dwRet);
            __leave;
        }

        dwRet = LdapSearchFirst(hLdap, 
                                szBaseDn,
                                LDAP_SCOPE_ONELEVEL,
                                szFilter,
                                pszNoAttrs, // we get dn for free.
                                &pSearch);

        if (dwRet == ERROR_SUCCESS &&
            pSearch &&
            pSearch->pCurEntry){

            szTempDn = ldap_get_dnW(hLdap, pSearch->pCurEntry);
            if (szTempDn) {
                xListQuickStrCopy(*pszSiteDn, szTempDn, dwRet, __leave);
            } else {
                dwRet = xListSetLdapError(LdapGetLastError(), hLdap);
                xListEnsureError(dwRet);
            }

        } else {
            if (dwRet == 0) {
                dwRet = xListSetWin32Error(ERROR_DS_NO_SUCH_OBJECT);
            }
            xListEnsureError(dwRet);
        }

    } __finally {
        if (szBaseDn) { xListFree(szBaseDn); }
        if (szFilter) { xListFree(szFilter); }
        if (szTempDn) { ldap_memfreeW(szTempDn); }
        if (pSearch)  { LdapSearchFree(&pSearch); }
    }

    if (dwRet) {
        xListEnsureNull(*pszSiteDn);
        dwRet = xListSetReason(XLIST_ERR_CANT_RESOLVE_SITE_NAME); // Set intelligent error.
        xListSetArg(szSiteName);
    }

    Assert(dwRet || *pszSiteDn);
    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\x_list\util.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

   xList Library - x_list_err.c

Abstract:

   This file has some extra utility functions for allocating, copying, 
   trimming DNs, etc.

Author:

    Brett Shirley (BrettSh)

Environment:

    repadmin.exe, but could be used by dcdiag too.

Notes:

Revision History:

    Brett Shirley   BrettSh     July 9th, 2002
        Created file.

--*/

#include <ntdspch.h>

#include <dsrole.h>     // DsRoleGetPrimaryDomainInformation() uses netapi32.lib
#include <dsgetdc.h>    // DsGetDcName() uses netapi32.lib
#include <lm.h>         // NetApiBufferFree() uses netapi32.lib
#include <ntdsa.h>      // DSNAME type only defined in here, need it for the parsedn.lib functions.
//#include "ndnc.h"       // GetFsmoLdapBinding(), wcsistr(), and others ...

// This library's main header files.
#include "x_list.h"
#include "x_list_p.h"
#define FILENO    FILENO_UTIL_XLIST_UTIL


//
// Constants
//
#define PARTITIONS_RDN                  L"CN=Partitions,"
#define DEFAULT_PAGED_SEARCH_PAGE_SIZE  (1000) 


PDSNAME
AllocDSName(
    LPWSTR            pszStringDn
    )
/*++

Routine Description:

    This routine makes a DSNAME structure for the string passed in.

Arguments:

    pszStringDn (IN) - String DN.

Return Value:

    pointer to the allocated and initialized DSNAME structure

--*/
{
    PDSNAME            pDsname;
    DWORD            dwLen, dwBytes;

    if (pszStringDn == NULL)
    return NULL;

    dwLen = wcslen (pszStringDn);
    dwBytes = DSNameSizeFromLen (dwLen);

    pDsname = (DSNAME *) LocalAlloc (LMEM_FIXED, dwBytes);
    if (pDsname == NULL) {
        return(NULL);
    }

    pDsname->NameLen = dwLen;
    pDsname->structLen = dwBytes;
    pDsname->SidLen = 0;
    //    memcpy(pDsname->Guid, &gNullUuid, sizeof(GUID));
    memset(&(pDsname->Guid), 0, sizeof(GUID));
    StringCbCopyW(pDsname->StringName, dwBytes, pszStringDn);

    return pDsname;
}

WCHAR *
TrimStringDnBy(
    IN  LPWSTR                      pszInDn,
    IN  ULONG                       ulTrimBy
    )
/*++

Routine Description:

    This routine simply takes a DN as a string, and trims off the number
    of DN parts as specified by ulTrimBy.

Arguments:

    pszInDn - The DN to trim.
    ulTrimBy - Number of parts to trim off the front of the DN.

Return Value:
    
    Returns NULL if there was an error, otherwise a pointer to the new DN.

Note:

    Free the result using LocalFree().

--*/
{
    PDSNAME                         pdsnameOrigDn = NULL;
    PDSNAME                         pdsnameTrimmed = NULL;
    LPWSTR                          pszOutDn;
    ULONG                           cbOutDn;

    Assert(ulTrimBy > 0);
    Assert(ulTrimBy < 50); // insanity check

    // Setup two pdsname structs, for orig & trimmed DNs.
    pdsnameOrigDn = AllocDSName(pszInDn);
    if(pdsnameOrigDn == NULL){
        return(NULL);
    }
    pdsnameTrimmed = (PDSNAME) LocalAlloc(LMEM_FIXED, pdsnameOrigDn->structLen);
    if(pdsnameTrimmed == NULL){
        LocalFree(pdsnameOrigDn);
        return(NULL);
    }

    // Trim the DN.
    TrimDSNameBy(pdsnameOrigDn, ulTrimBy, pdsnameTrimmed);

    // Allocate the result and return it.  We could put this back 
    // where the original is, but then callers would have to be changed
    // to expect this.
    Assert(wcslen(pdsnameTrimmed->StringName) <= wcslen(pszInDn));
    cbOutDn = sizeof(WCHAR) * (wcslen(pdsnameTrimmed->StringName) + 2);
    pszOutDn = LocalAlloc(LMEM_FIXED, cbOutDn);
    if(pszOutDn == NULL){
        LocalFree(pdsnameTrimmed);
        LocalFree(pdsnameOrigDn);
        return(NULL);
    }
    StringCbCopyW(pszOutDn, cbOutDn, pdsnameTrimmed->StringName);

    // Free temporary memory and return result
    LocalFree(pdsnameOrigDn);
    LocalFree(pdsnameTrimmed);
    return(pszOutDn);
}

DWORD
LocateServer(
    LPWSTR     szDomainDn, // maybe NULL domain should mean GC?
    WCHAR **   pszServerDns
    )

/*++

Routine Description:

    Locate a DC that holds the given domain.

    This routine runs before pDsInfo is allocated.  We don't know who our
    home server is. We can only use knowledge from the Locator.

Arguments:

    pszDomainDn - DNS or NetBios of Domain
    pszServerDns - DNS name of server. Allocated using LocalAlloc. Caller must
    free.

Return Value:

    Win32 Error                 

--*/

{
    DWORD status;
    LPWSTR szServer = NULL;
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;

    // Get active domain controller information
    status = DsGetDcName(NULL, // computer name
                         szDomainDn, // domain name
                         NULL, // domain guid,
                         NULL, // site name,
                         DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED | DS_IS_DNS_NAME | DS_RETURN_DNS_NAME,
                         &pDcInfo );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    QuickStrCopy(szServer, pDcInfo->DomainControllerName + 2, status, goto cleanup);
    Assert(szServer);

cleanup:

    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
    }

    Assert(status || szServer);
    *pszServerDns = szServer;
    return status;
}


DWORD
MakeString2(
    WCHAR *    szFormat,
    WCHAR *    szStr1,
    WCHAR *    szStr2,
    WCHAR **   pszOut
    )
/*++

Routine Description:

    Takes a string format specifier with one or two "%ws" parts, and
    it puts these 3 strings all together.

Arguments:

    szFormat (IN) - The format specifier
    szStr1 (IN) - String one to "sprintf" into the szFormat
    szStr2 (IN) - [OPTIONAL] String two to sprintf into the szFormat
    pszOut (OUT) - LocalAlloc()'d result.

Return Value:

    Win32 Error.

--*/
{
    DWORD  dwRet = ERROR_SUCCESS;
    DWORD  cbOut;
    HRESULT hr;

    Assert(szFormat && szStr1 && pszOut);

    cbOut = wcslen(szFormat) + wcslen(szStr1) + ((szStr2) ? wcslen(szStr2) : 0) + 1;
    cbOut *= sizeof(WCHAR);

    *pszOut = LocalAlloc(LMEM_FIXED, cbOut);
    if (*pszOut == NULL) {
        dwRet = GetLastError();
        xListEnsureWin32Error(dwRet);
        return(dwRet);
    }

    if (szStr2) {
        dwRet = HRESULT_CODE(StringCchPrintfW(*pszOut,
                                 cbOut,
                                 szFormat,
                                 szStr1,
                                 szStr2));
    } else {
        dwRet = HRESULT_CODE(StringCchPrintfW(*pszOut,
                                 cbOut,
                                 szFormat,
                                 szStr1));
    }
    Assert(dwRet == ERROR_SUCCESS)
    return(dwRet);
}

WCHAR
HexMyDigit(
    ULONG  nibble
    )
/*++

Routine Description:

    This takes nibble and turns it into a hex char.

Arguments:

    nibble - 0 to 15 in lowerest 4 bits.

Return Value:

    Hex character
    
--*/
{
    WCHAR ret;
    Assert(!(~0xF & nibble));
    nibble &= 0xF;
    if (nibble < 0xa) {
        ret = L'0' + (WCHAR) nibble;
    } else {
        ret = L'A' + (WCHAR) (nibble - 0xa);
    }
    return(ret);
}

DWORD
MakeLdapBinaryStringCb(     
    WCHAR * szBuffer, 
    ULONG   cbBuffer, 
    void *  pBlobIn,
    ULONG   cbBlob
    )

/*++

Routine Description:

    This takes a binary blob such as (in hex) "0x4f523d..." and 
    turns it into the form "/4f/52/3d..." because this is the form
    that will allow LDAP to accept as a search parameter on a binary
    attribute.

Arguments:

    szBuffer (IN/OUT) - Should be MakeLdapBinaryStringSizeCch() WCHARs long.
    cbBuffer (IN) - Just in case.
    pBlobIn (IN) - The binary blob to convert.
    cbBlob (IN) - Length of the binary blob to convert.

Return Value:

    Win32 Error.

--*/
{
    ULONG  iBlob, iBuffer;
    char * pBlob;

    Assert(szBuffer && pBlobIn);
    
    pBlob = (char *) pBlobIn;

    if (cbBuffer < (MakeLdapBinaryStringSizeCch(cbBlob) * sizeof(WCHAR))) {
        Assert(!"Bad programmer");
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    for (iBlob = 0, iBuffer = 0; iBlob < cbBlob; iBlob++) {
        szBuffer[iBuffer++] = L'\\';
        szBuffer[iBuffer++] = HexMyDigit( (0xF0 & pBlob[iBlob]) >> 4 );
        szBuffer[iBuffer++] = HexMyDigit( (0x0F & pBlob[iBlob]) );
    }
    Assert(iBuffer < (cbBuffer/sizeof(WCHAR)));
    szBuffer[iBuffer] = L'\0';

    return(ERROR_SUCCESS);
}


WCHAR *
GetDelimiter(
    WCHAR *   szString,
    WCHAR     wcTarget
    )
// 
/*++

Routine Description:

    Basically like wcsichr() except it will skip escaped delimiters,
    such as "\:" (escaped ":"), and it will give back a pointer to 
    the string immediately after the delimiter instead of the first
    occurance of the delimiter.

Arguments:

    szString (IN) - szString to search
    wcTarget (IN) - the delimiter to search form.

Return Value:

    Pointer to the character one char past the delimiter, otherwise NULL.

--*/
{
    ULONG i;

    Assert(szString);
    if (szString == NULL) {
        return(NULL);
    }

    for (i = 0; szString[i] != L'\0'; i++) {
        if (szString[i] == wcTarget) {
            if (i > 0 &&
                szString[i-1] == L'\\') {
                // this delimeter  is escaped, treat as part of previous string.
                continue; 
            }

            return(&(szString[i+1]));
        }
    }
    
    return(NULL);
}




DWORD
ConvertAttList(
    LPWSTR      pszAttList,
    PWCHAR **   paszAttList
    )
/*++

Routine Description:

    Converts a comma delimitted list of attribute names into a NULL terminated
    array of attribute names suitable to be passed to one of the ldap_* functions.

Arguments:

    pszAttList - The comma delimitted list of attribute names.
    paszAttList - Gives back the NULL terminated array of strings.

Return Value:

    Returns Win32

--*/
{
    DWORD    i;
    DWORD    dwAttCount;
    DWORD    cbSize;
    PWCHAR   *ppAttListArray;
    PWCHAR   ptr;

    Assert(paszAttList);
    *paszAttList = NULL; // Assume all atts first ...
    if (pszAttList == NULL) {
        return(ERROR_SUCCESS);
    }

    // Count the comma's to get an idea of how many attributes we have.
    // Ignore any leading comma's.  There shouldn't be any, but you never
    // know.

    if (pszAttList[0] == L',') {
        while (pszAttList[0] == L',') {
            pszAttList++;
        }
    }

    // Check to see if there is anything besides commas.
    if (pszAttList[0] == L'\0') {
        // there are no att names here.
        return(ERROR_SUCCESS);
    }

    // Start the main count of commas.
    for (i = 0, dwAttCount = 1; pszAttList[i] != L'\0'; i++) {
        if (pszAttList[i] == L',') {
            dwAttCount++;
            // skip any following adjacent commas.
            while (pszAttList[i] == L',') {
                i++;
            }
            if (pszAttList[i] == L'\0') {
                break;
            }
        }
    }
    // See if there was a trailing comma.
    if (pszAttList[i-1] == L',') {
        dwAttCount--;
    }

#define ARRAY_PART_SIZE(c)   ( (c + 1) * sizeof(PWCHAR) )
    // This rest of this function would be destructive to the att list passed in, 
    // so we need to make a copy of this (pszAttList, plus we need an array of
    // pointers  to each substring with an extra element for the NULL termination.
    cbSize = ARRAY_PART_SIZE(dwAttCount);
    cbSize += (sizeof(WCHAR) * (1 + wcslen(pszAttList)));
    ppAttListArray = (PWCHAR *)LocalAlloc(LMEM_FIXED, cbSize);
    if (!ppAttListArray) {
        // no memory.
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    ptr = (WCHAR *) ( ((BYTE *)ppAttListArray) + ARRAY_PART_SIZE(dwAttCount) );
    if(StringCbCopyW(ptr, cbSize - ARRAY_PART_SIZE(dwAttCount),  pszAttList)){
        Assert(!"We didn't calculate the memory requirements right!");
        return(ERROR_DS_CODE_INCONSISTENCY);
    }
    pszAttList = ptr; // Now pszAttList is a string at the end of the LocalAlloc()'d blob.
#undef ARRAY_PART_SIZE

    // Now begin filling in the array.
    // fill in the first element.
    if (pszAttList[0] != L'\0') {
        ppAttListArray[0] = pszAttList;
    } else {
        ppAttListArray[0] = NULL;
    }

    // Start the main loop.
    for (i = 0, dwAttCount = 1; pszAttList[i] != L'\0'; i++) {
        if (pszAttList[i] == L',') {
            // Null terminate this attribute name.
            pszAttList[i++] = L'\0';
            if (pszAttList[i] == L'\0') {
                break;
            }

            // skip any following adjacent commas.
            while (pszAttList[i] == L',') {
                i++;
            }
            // If we aren't at the end insert this pointer into the list.
            if (pszAttList[i] == L'\0') {
                break;
            }
            ppAttListArray[dwAttCount++] = &pszAttList[i];
        }
    }
    ppAttListArray[dwAttCount] = NULL;

    *paszAttList = ppAttListArray;
    
    return(ERROR_SUCCESS);
}
         
void
ConsumeArg(
    int         iArg,
    int *       pArgc,
    LPWSTR *    Argv
    )
// This simple function eats the specified argument.
{
    memmove(&(Argv[iArg]), &(Argv[iArg+1]),
            sizeof(*Argv)*(*pArgc-(iArg+1)));
    --(*pArgc);
}

BOOL
IsInNullList(
    WCHAR *  szTarget,
    WCHAR ** aszList
    )
// Searches NULL terminated list of strings for a string matching szTarget
{
    ULONG i;
    Assert(szTarget);
    if (aszList == NULL) {
        return(FALSE);
    }
    for (i = 0; aszList[i]; i++) {
        if (wcsequal(szTarget, aszList[i])) {
            return(TRUE);
        }
    }
    return(FALSE);
}

DWORD
GeneralizedTimeToSystemTimeA(
    LPSTR IN szTime,
    PSYSTEMTIME OUT psysTime
    )
/*++
Function   : GeneralizedTimeStringToValue
Description: converts Generalized time string to equiv DWORD value
Parameters : szTime: G time string
             pdwTime: returned value
Return     : Success or failure
Remarks    : none.
--*/
{
   DWORD status = ERROR_SUCCESS;
   ULONG       cb;
   ULONG       len;

    //
    // param sanity
    //
    if (!szTime || !psysTime)
    {
       return STATUS_INVALID_PARAMETER;
    }


    // Intialize pLastChar to point to last character in the string
    // We will use this to keep track so that we don't reference
    // beyond the string

    len = strlen(szTime);

    if( len < 15 || szTime[14] != '.')
    {
       return STATUS_INVALID_PARAMETER;
    }

    // initialize
    memset(psysTime, 0, sizeof(SYSTEMTIME));

    // Set up and convert all time fields

    // year field
    cb=4;
    psysTime->wYear = (USHORT)MemAtoi((LPBYTE)szTime, cb) ;
    szTime += cb;
    // month field
    psysTime->wMonth = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    // day of month field
    psysTime->wDay = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    // hours
    psysTime->wHour = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    // minutes
    psysTime->wMinute = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));
    szTime += cb;

    // seconds
    psysTime->wSecond = (USHORT)MemAtoi((LPBYTE)szTime, (cb=2));

    return status;

}

//
// MemAtoi - takes a pointer to a non null terminated string representing
// an ascii number  and a character count and returns an integer
//
int MemAtoi(BYTE *pb, ULONG cb)
{
#if (1)
    int res = 0;
    int fNeg = FALSE;

    if (*pb == '-') {
        fNeg = TRUE;
        pb++;
    }
    while (cb--) {
        res *= 10;
        res += *pb - '0';
        pb++;
    }
    return (fNeg ? -res : res);
#else
    char ach[20];
    if (cb >= 20)
        return(INT_MAX);
    memcpy(ach, pb, cb);
    ach[cb] = 0;

    return atoi(ach);
#endif
}


DSTimeToSystemTime(
    LPSTR IN szTime,
    PSYSTEMTIME OUT psysTime)
/*++
Function   : DSTimeStringToValue
Description: converts UTC time string to equiv DWORD value
Parameters : szTime: G time string
             pdwTime: returned value
Return     : Success or failure
Remarks    : none.
--*/
{
   ULONGLONG   ull;
   FILETIME    filetime;
   BOOL        ok;

   ull = _atoi64 (szTime);

   filetime.dwLowDateTime  = (DWORD) (ull & 0xFFFFFFFF);
   filetime.dwHighDateTime = (DWORD) (ull >> 32);

   // Convert FILETIME to SYSTEMTIME,
   if (!FileTimeToSystemTime(&filetime, psysTime)) {
       return !ERROR_SUCCESS;
   }

   return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\x_list\obj_list.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

   xList Library - obj_list.c

Abstract:

   This provides a little library for enumerating lists of objects and 
   returning thier DNs or a set of thier attributes.

Author:

    Brett Shirley (BrettSh)

Environment:

    repadmin.exe, but could be used by dcdiag too.

Notes:

Revision History:

    Brett Shirley   BrettSh     Aug 1st, 2002
        Created file.

--*/

#include <ntdspch.h>

// This library's main header files.
#include "x_list.h"
#include "x_list_p.h"
// Debugging setup
#define FILENO                          FILENO_UTIL_XLIST_OBJLIST

//
// Global constants
//

// This is a global constant that tells LDAP to not return any attributes.
// Very helpful if you just want DNs and no attributes.
WCHAR * aszNullAttrs [] = { L"1.1", NULL };
                 

void
ObjListFree(
    POBJ_LIST * ppObjList
    )

/*++

Routine Description:

    Frees and allocated OBJ_LIST stucture, whether allocated by 
    ConsumeObjListOptions() or ObjListParse()

Arguments:
    
    ppObjList - Pointer to the pointer to the OBJ_LIST struct.  We set the
        pointer to NULL for you, to avoid accidents.

--*/
{
    POBJ_LIST pObjList;

    Assert(ppObjList && *ppObjList);
    
    // Null out user's OBJ_LIST blob
    pObjList = *ppObjList;
    *ppObjList = NULL;

    // Now try to free it.
    if (pObjList) {

        // We don't free pObjList->aszAttrs as the client created it.
        pObjList->aszAttrs = aszNullAttrs; // equivalent of NULLing.
        pObjList->szUserSrchFilter = NULL; // user allocated.

        if (pObjList->szSpecifier) {
            xListFree(pObjList->szSpecifier);
            pObjList->szSpecifier = NULL;
        }
        
        if (pObjList->pSearch) {
            LdapSearchFree(&(pObjList->pSearch));
        }

        LocalFree(pObjList);
    }
    
}
    

DWORD    
ConsumeObjListOptions(
    int *       pArgc,
    LPWSTR *    Argv,
    OBJ_LIST ** ppObjList
    )

/*++

Routine Description:

    This takes the command line parameters and consumes any ObjList()
    feels belong to it.  These options are:
        /filter:<ldap_filter> 
        /base 
        /subtree
        /onelevel
    And are the options required to specify a generic LDAP search on
    the command line.  Also the Base DN will be needed, but ObjListParse()
    will be provided that as szObjList.

    NOTE: This function is not internationalizeable, it'd be nice if it was though,
    but it isn't currently.  Work would need to be done to put each of the specifiers
    in it's own string constant.

Arguments:
    
    pArgc - Pointer to the number of arguments, we decrement this for you
        if we consume any arguments
    Argv - Array of arguments.
    ppObjList - Pointer to the pointer to the OBJ_LIST struct.  We set the
        pointer to NULL for you, and if there are valid search options on
        the command line we allocate it for you.  We won't if there are
        no search options.
        
Return Value:    

    xList Return Code
        
--*/

{
    int     iArg;
    WCHAR * szFilter = NULL;
    BOOL    fScopeSet = FALSE;
    ULONG   eScope;
    OBJ_LIST * pObjList = NULL;
    BOOL    fConsume;
    DWORD   dwRet;

    Assert(ppObjList);
    xListEnsureNull(*ppObjList);

    for (iArg = 0; iArg < *pArgc; ) {

        // Assume we recognize the argument
        fConsume = TRUE; 
        
        if (wcsprefix(Argv[iArg], L"/filter:")) {
            szFilter = wcschr(Argv[iArg], L':');
            if (szFilter != NULL) {
                szFilter++; // want one char past the delimeter
            } else {
                fConsume = FALSE; // weird /filter w/ no :?
            }
        } else if (wcsequal(Argv[iArg], L"/base")) {
            fScopeSet = TRUE;
            eScope = LDAP_SCOPE_BASE; // default, don't need to set.

        } else if (wcsequal(Argv[iArg], L"/subtree")) {
            fScopeSet = TRUE;
            eScope = LDAP_SCOPE_SUBTREE;
        
        } else if (wcsequal(Argv[iArg], L"/onelevel")) {
            fScopeSet = TRUE;
            eScope = LDAP_SCOPE_ONELEVEL;

        } else {
            fConsume = FALSE;
        }

        if (fConsume) {
            // We've used this arg.
            ConsumeArg(iArg, pArgc, Argv);
        } else {
            // Didn't understand this arg, so ignore it ...
            iArg++;
        }
    }

    if (fScopeSet || szFilter != NULL){
        // the user specified some part of the search params ... so lets 
        // allocate and init our pObjList object.
        if (szFilter == NULL &&
            eScope == LDAP_SCOPE_BASE) {
            // Hmmm, user forgot filter, but it's only a base search so 
            // lets try to help the user out and just get any object.
            szFilter = L"(objectCategory=*)";
        } else if (szFilter == NULL) {
            Assert(eScope == LDAP_SCOPE_SUBTREE || eScope == LDAP_SCOPE_ONELEVEL);
            // Hmmm, this is a little too promiscous, error will be printed.
            // User will have to manually specify the objCat = * if they
            // really want to do this.
            return(xListSetBadParam());
        }
        pObjList = LocalAlloc(LPTR, sizeof(OBJ_LIST)); // zero init'd
        if (pObjList == NULL) {
            return(xListSetNoMem());
        }
        pObjList->szUserSrchFilter = szFilter;
        pObjList->eUserSrchScope = eScope;
        *ppObjList = pObjList;
    }

    return(ERROR_SUCCESS);
}

DWORD
ObjListParse(
    LDAP *      hLdap,
    WCHAR *     szObjList,
    WCHAR **    aszAttrList,
    LDAPControlW ** apControls,
    POBJ_LIST * ppObjList
    )
/*++

Routine Description:

    This parses the szObjList which should be a OBJ_LIST syntax.
    
    This function may or may not take an already allocated ppObjList, depending
    on whether ConsumeObjListOptions() has allocated it already.
                                             
    NOTE: This function is not internationalizeable, it'd be nice if it was though,
    but it isn't currently.  Work would need to be done to put each of the specifiers
    in it's own string constant.

Arguments:

    hLdap - 
    szObjList - OBJ_LIST syntax string.
    aszAttrList - client allocated NULL terminated array of strings for
        the attributes that the caller wants retrieved.  Use aszNullAttrs
        if the caller just wants DNs.
    apControls - client allocated NULL terminated array  of controls that
        the caller wants us to use.
    ppObjList - the OBJ_LIST context block.  Free with ObjListFree().

Return Value:

    xList Return Code

--*/
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    POBJ_LIST pObjList = NULL;
    WCHAR * szTemp;
    ULONG cAttrs;

    xListAPIEnterValidation();
    Assert(hLdap && szObjList && ppObjList)

    if (*ppObjList) {
        // 
        // This means the user specified his own search to try.
        //
        pObjList = *ppObjList;
        if (pObjList->szUserSrchFilter == NULL ||
            (pObjList->eUserSrchScope != LDAP_SCOPE_BASE &&
             pObjList->eUserSrchScope != LDAP_SCOPE_SUBTREE &&
             pObjList->eUserSrchScope != LDAP_SCOPE_ONELEVEL)) {
            Assert(!"User error?  Programmer error?");
            return(xListSetBadParam());
        }
    } else {
        pObjList = LocalAlloc(LPTR, sizeof(OBJ_LIST)); // zero init'd
        if (pObjList == NULL) {
            return(xListSetNoMem());
        }
    }
    
    __try{

        Assert(pObjList);

        if (*ppObjList != pObjList) {
            // We didn't have a pre specified user search, so specify base scope
            pObjList->eUserSrchScope = LDAP_SCOPE_BASE;
        }

        //
        // This actually parses the OBJ_LIST argument itself.
        //
        if (szTemp = GetDelimiter(szObjList, L':')){

            if (wcsprefix(szObjList, L"ncobj:")) {

                //
                // One of the easy NC Heads to resolve, pull off root DSE
                //
                if (wcsprefix(szTemp, L"config:")) {
                    dwRet = GetRootAttr(hLdap, L"configurationNamingContext", &(pObjList->szSpecifier));
                    if (dwRet) {
                        dwRet = xListSetLdapError(dwRet, hLdap);
                        __leave;
                    }
                } else if (wcsprefix(szTemp, L"schema:")) {
                    dwRet = GetRootAttr(hLdap, L"schemaNamingContext", &(pObjList->szSpecifier));
                    if (dwRet) {
                        dwRet = xListSetLdapError(dwRet, hLdap);
                        __leave;
                    }
                } else if (wcsprefix(szTemp, L"domain:") ||
                           wcsequal(szTemp, L".")) {
                    dwRet = GetRootAttr(hLdap, L"defaultNamingContext", &(pObjList->szSpecifier));
                    if (dwRet) {
                        dwRet = xListSetLdapError(dwRet, hLdap);
                        __leave;
                    }
                } else {
                    dwRet = xListSetBadParam();
                    __leave;
                }
            } else if (wcsequal(szObjList, L"dsaobj:.") ||
                       wcsequal(szObjList, L"dsaobj:") ) {

                // 
                // Our own DSA object ... easy.
                // 
                dwRet = GetRootAttr(hLdap, L"dsServiceName", &(pObjList->szSpecifier));
                if (dwRet) {
                    dwRet = xListSetLdapError(dwRet, hLdap);
                    __leave;
                }

            } else {
                dwRet = xListSetBadParam();
                __leave;
            }

        } else {
            
            //
            // This should mean they provided thier own base DN
            //
            if(szObjList[0] == L'.' && szObjList[1] == L'\0'){
                pObjList->szSpecifier = NULL; // search the RootDSE
            } else {
                xListQuickStrCopy(pObjList->szSpecifier, szObjList, dwRet, __leave);
            }

        }

        // Save the LDAP * for later
        pObjList->hLdap = hLdap;
 
        // Deal with the list of attributes to retrieve.
        if (aszAttrList != NULL &&
            aszAttrList[0] != NULL &&
            aszAttrList[1] == NULL &&
            0 == wcscmp(L"1.1", aszAttrList[0])) {
            // If user specified L"1.1", only then we want to return DNs only.
            pObjList->fDnOnly = TRUE;
        } else if (NULL != aszAttrList) {

            for (cAttrs = 0; aszAttrList[cAttrs]; cAttrs++) {
                ; // just counting ...
            }
            cAttrs += !IsInNullList(L"objectClass", aszAttrList);
            cAttrs += !IsInNullList(L"objectGuid", aszAttrList);
            cAttrs++; // One extra for NULL

            pObjList->aszAttrs = LocalAlloc(LMEM_FIXED, cAttrs * sizeof(WCHAR *));
            if (pObjList->aszAttrs == NULL) {
                dwRet = xListSetNoMem();
                __leave;
            }

            for (cAttrs = 0; aszAttrList[cAttrs]; cAttrs++) {
                pObjList->aszAttrs[cAttrs] = aszAttrList[cAttrs];
            }
            if (!IsInNullList(L"objectClass", aszAttrList)) {
                pObjList->aszAttrs[cAttrs++] = L"objectClass";
            }
            if (!IsInNullList(L"objectGuid", aszAttrList)) {
                pObjList->aszAttrs[cAttrs++] = L"objectGuid";
            }
            pObjList->aszAttrs[cAttrs] = NULL;
        }

        // Deal with the controls the user wants us to use.
        if (apControls) {
            pObjList->apControls = apControls;
        }

        dwRet = 0;

    } __finally {
        if (dwRet != ERROR_SUCCESS) {
            // Turn the normal error into an xList Return Code.
            dwRet = xListSetWin32Error(dwRet);
            dwRet = xListSetReason(XLIST_ERR_PARSE_FAILURE);
            if (*ppObjList != pObjList) {
                // We allocated this.
                ObjListFree(&pObjList);
            }
        }
    }

    *ppObjList = pObjList;
    xListAPIExitValidation(dwRet);
    Assert(dwRet || *ppObjList);
    return(dwRet);
}

DWORD
ObjListGetFirst(
    POBJ_LIST   pObjList, 
    BOOL        fDn,
    void **     ppObjObj
    )
/*++

Routine Description:

    Please use ObjListGetFirstDn() or ObjListGetFirstEntry() functions.

    This gets the first entry or DN for the clients OBJ_LIST structure.
    
Arguments:

    pObjList - the OBJ_LIST context block.
    fDn - Just get DN only.
    ppObjObj - This is a pointer to an Entry or a LocalAlloc()'d DN 
        depending on what variant the client is calling.

Return Value:

    xList Return Code.

--*/
{
    DWORD       dwRet = ERROR_INVALID_FUNCTION;
    WCHAR *     szTempDn = NULL;

    xListAPIEnterValidation();

    if (pObjList == NULL ||
        ppObjObj == NULL) {
        Assert(!"Programmer error ...");
        return(xListSetBadParam());
    }
    xListEnsureNull(*ppObjObj);

    if (pObjList->fDnOnly != fDn) {
        Assert(!"Can't mix variants of ObjListGetXxxx()");
        return(xListSetBadParam());
    }

    if (fDn) {
        xListEnsureNull(pObjList->aszAttrs);
        pObjList->aszAttrs = aszNullAttrs;
    }
    
    //
    // No matter what, this function will always retrieve the 
    // objectClass and the objectGuid.
    //

    __try{

        dwRet = LdapSearchFirstWithControls(pObjList->hLdap,
                                            pObjList->szSpecifier,
                                            pObjList->eUserSrchScope,
                                            pObjList->szUserSrchFilter ? 
                                                pObjList->szUserSrchFilter :
                                                L"(objectCategory=*)",
                                            pObjList->aszAttrs, 
                                            pObjList->apControls,
                                            &(pObjList->pSearch));
        if (dwRet == ERROR_SUCCESS &&
            LdapSearchHasEntry(pObjList->pSearch)) {

            if (fDn) {
                szTempDn = ldap_get_dnW(pObjList->hLdap, pObjList->pSearch->pCurEntry);
                xListQuickStrCopy((WCHAR*)*ppObjObj, szTempDn, dwRet, __leave);
            } else {
                *ppObjObj = (void *) pObjList->pSearch->pCurEntry;
            }
        } else {
            if (dwRet == ERROR_SUCCESS) {
                // If the LdapSearchXxxxXxxx() doesn't return results its
                // still considered an error on our first search.
                dwRet = xListSetWin32Error(ERROR_DS_NO_SUCH_OBJECT);
            }
            dwRet = xListSetReason(XLIST_ERR_NO_SUCH_OBJ);
            if(pObjList->szSpecifier){
                xListSetArg(pObjList->szSpecifier);
            } else {
                xListSetArg(L"RootDSE");
            }
            __leave;
        }

        Assert(dwRet == ERROR_SUCCESS);
        Assert(*ppObjObj);

    } __finally {
        
        if (szTempDn) { ldap_memfreeW(szTempDn); }

    }

    if (dwRet == 0 && *ppObjObj) {
        pObjList->cObjs = 1;
    } else {
        xListEnsureNull(*ppObjObj);
    }

    xListAPIExitValidation(dwRet);

    return(dwRet);
}

                                          

DWORD
ObjListGetNext(
    POBJ_LIST    pObjList, 
    BOOL         fDn,
    void **      ppObjObj
    )
/*++

Routine Description:

    Please use ObjListGetNextDn() or ObjListGetNextEntry() functions.

    This gets the next entry or DN for the clients OBJ_LIST structure.
    
Arguments:

    pObjList - the OBJ_LIST context block.
    fDn - Just get DN only.
    ppObjObj - This is a pointer to an Entry or a LocalAlloc()'d DN 
        depending on what variant the client is calling.

Return Value:

    xList Return Code.

--*/
{
    DWORD dwRet = ERROR_INVALID_FUNCTION;
    XLIST_LDAP_SEARCH_STATE * pDsaSearch = NULL;
    WCHAR * szTempDn = NULL;

    xListAPIEnterValidation();
    Assert(pObjList && ppObjObj);
    xListEnsureNull(*ppObjObj);

    *ppObjObj = NULL;
    
    if (pObjList->fDnOnly != fDn) {
        Assert(!"Can't mix variants of ObjListGetXxxx()");
        return(xListSetBadParam());
    }
    
    if (pObjList->pSearch == NULL) {
        Assert(!"programmer malfunction!");
        return(xListSetBadParam());
    }

    __try{

        dwRet = LdapSearchNext(pObjList->pSearch);
        if (dwRet == ERROR_SUCCESS &&
            LdapSearchHasEntry(pObjList->pSearch)) {

            if (fDn) {
                szTempDn = ldap_get_dnW(pObjList->hLdap, pObjList->pSearch->pCurEntry);
                xListQuickStrCopy((WCHAR*)*ppObjObj, szTempDn, dwRet, __leave);
            } else {
                *ppObjObj = (void *) pObjList->pSearch->pCurEntry;
            }
        } else {
            // Either an error or end of result set, so return either way.
            __leave;
        }

    } __finally {
        
        if (szTempDn) {
            ldap_memfreeW(szTempDn);
        }
        if (dwRet) {
            xListEnsureNull(*ppObjObj);
        }
    }

    if (dwRet == 0 && *ppObjObj) {
        (pObjList->cObjs)++;
    } else {
        xListEnsureNull(*ppObjObj);
    }

    xListAPIExitValidation(dwRet);
    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\x_list\x_list_err.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

   xList Library - x_list_err.c

Abstract:

   This file encapsulates the error handling, setting, clearing, functions
   for the x_list library.

Author:

    Brett Shirley (BrettSh)

Environment:

    repadmin.exe, but could be used by dcdiag too.

Notes:

Revision History:

    Brett Shirley   BrettSh     July 9th, 2002
        Created file.

--*/

#include <ntdspch.h>

// This library's main header files.
#include "x_list.h"
#include "x_list_p.h"
#define FILENO    FILENO_UTIL_XLIST_ERR

// --------------------------------------------------------------
// Global Error State
// --------------------------------------------------------------

typedef struct _XLIST_ERROR_STATE {
    DWORD   dwDSID;
    DWORD   dwReturn; // = XLIST_LDAP_ERROR | XLIST_WIN32_ERROR | XLIST_ERROR
    WCHAR * szReasonArg;
    
    // Win 32 Error State
    DWORD   dwWin32Err;
    
    // LDAP Error State
    DWORD   dwLdapErr;
    WCHAR * szLdapErr;
    DWORD   dwLdapExtErr;
    WCHAR * szLdapExtErr;
    WCHAR * szExtendedErr; // ??

} XLIST_ERROR_STATE;

XLIST_ERROR_STATE gError = { 0 }; // The actual global that holds our error state.

// --------------------------------------------------------------
// Private helper functions
// --------------------------------------------------------------

void
xListAPIEnterValidation(void)
/*++

Routine Description:

    This routine validates the state of the xList library upon entry of
    one of the public interface routines.

--*/
{
    if( gError.dwReturn != 0 ||
        gError.dwLdapErr != LDAP_SUCCESS ||
        gError.dwWin32Err != ERROR_SUCCESS ){
        Assert(!"Caller, calling a call without clearing the error state!");
    }
}

void
xListAPIExitValidation(
    DWORD   dwRet
    )
/*++

Routine Description:

    This routine validates the state of the xList library and the return
    value upon exit of the public interface routines.

Arguments:

    dwRet (IN) - The return code the public function (such a DcListGetNext())

--*/
{
    
    Assert(dwRet == gError.dwReturn);

    if (dwRet) {
        if ( (!(dwRet & XLIST_LDAP_ERROR) && !(dwRet & XLIST_WIN32_ERROR)) ||
             (!(gError.dwWin32Err) && !(gError.dwLdapErr))
             ) {
            
            // add specific values that can be returned w/o LDAP/Win32 errors.
            if (xListReason(dwRet) != XLIST_ERR_CANT_RESOLVE_DC_NAME) {
                Assert(!"We should always set a win32 or ldap error.");
            }

        }
        if (!xListReason(dwRet)) {
            Assert(!"We should always return an XLIST reason.");
        }
        if ( xListReason(dwRet) > XLIST_ERR_LAST ) {
            Assert(!"Unknown reason!!!");
        }
    }
}

DWORD
xListSetError(
    DWORD   dwReturn,
    DWORD   dwWin32Err,
    DWORD   dwLdapErr,
    LDAP *  hLdap,
    DWORD   dwDSID
    )
/*++

Routine Description:

    This sets the global error state and returns the xList reason code that
    most xList routines deal with.

Arguments:

    dwReturn (IN) - xList Reason code.
    dwWin32Err (IN) - a Win32 error code
    dwLdapErr (IN) - an LDAP error.
    hLdap (IN) - the active LDAP handle in the case of an LDAP handle,
        to get the extended error info.
    dwDSID - DSID of the error being set.

Return Value:

    returns the full xList return value = (dwReason | error_type(LDAP | WIN32))

--*/
{
    Assert(dwReturn || dwWin32Err || dwLdapErr);
    Assert(! (gError.dwReturn && (dwWin32Err || dwLdapErr)) );

    gError.dwDSID = dwDSID; // do we want to track two DSIDs?

    if ( xListReason(dwReturn) &&
         (xListReason(gError.dwReturn) == XLIST_ERR_NO_ERROR) ) {
        // Set an XLIST error if we've got one to set and there is
        // none set already.  I.e. we don't have one set already.
        gError.dwReturn |= xListReason(dwReturn);
    }

    if (dwWin32Err) {

        gError.dwReturn |= XLIST_WIN32_ERROR;
        gError.dwWin32Err = dwWin32Err;

    }
    if (dwLdapErr || hLdap) {
        
        gError.dwReturn |= XLIST_LDAP_ERROR;

        if (hLdap == NULL ||
            dwLdapErr == LDAP_SUCCESS) {
            
            Assert(hLdap == NULL && dwLdapErr == LDAP_NO_MEMORY && "Hmmm, why are we "
                   "missing an error or an LDAP handle and we're not out of memory?");
            gError.dwLdapErr = LDAP_NO_MEMORY;

        } else {

            // Normal LDAP error, try to get any extended error info too.
            gError.dwLdapErr = dwLdapErr;
            if (hLdap) {
                GetLdapErrorMessages(hLdap, 
                                     gError.dwLdapErr,
                                     &gError.szLdapErr,
                                     &gError.dwLdapExtErr,
                                     &gError.szLdapExtErr,
                                     &gError.szExtendedErr);

            }
        }
    }

    // xListSetError() should never be called with no errors to set.  The #define
    // function xListEnsureError() does this, but it's goal is to make sure an error
    // is set.
    if (gError.dwReturn == 0) {
        
        Assert(!"Code inconsistency, this should never be set if we don't have an error.");

        gError.dwReturn = XLIST_WIN32_ERROR;
        gError.dwWin32Err = ERROR_DS_CODE_INCONSISTENCY;
    }
    
    return(gError.dwReturn);
}

void
xListSetArg(
    WCHAR * szArg
    )
{
    DWORD dwRet;
    QuickStrCopy(gError.szReasonArg, szArg, dwRet, return;);
}

DWORD
xListClearErrorsInternal(
    DWORD   dwXListMask
    )
/*++

Routine Description:

    This clears the xList's internal error state.

Arguments:

    DWORD - Type of errors to clear (CLEAR_REASON | CLEAR_WIN32 | CLEAR_LDAP)

Return Value:

    New full xList return error code.

--*/
{
    gError.dwDSID = 0;
    
    if (dwXListMask & CLEAR_WIN32) {
        gError.dwReturn &= ~XLIST_WIN32_ERROR;
        gError.dwWin32Err = ERROR_SUCCESS;
    }

    if (dwXListMask & CLEAR_LDAP) {
        gError.dwReturn &= ~XLIST_LDAP_ERROR;
        gError.dwLdapErr = LDAP_SUCCESS;
        FreeLdapErrorMessages(gError.szLdapExtErr, gError.szExtendedErr);
        gError.szLdapExtErr = NULL;
        gError.szExtendedErr = NULL;
    }

    if (xListReason(dwXListMask)) {
        gError.dwReturn &= ~XLIST_REASON_MASK;
        LocalFree(gError.szReasonArg);
        gError.szReasonArg = NULL;
    }
    xListEnsureNull(gError.szReasonArg);
    Assert(gError.dwReturn == 0);
    gError.dwReturn = 0; // Just to be sure.

    return(gError.dwReturn);
}


DWORD
xListEnsureCleanErrorState(
    DWORD  dwRet
    )
/*++

Routine Description:

    Just verifies that we have a clean error state and cleans it
    if nescessary.

Arguments:

    dwRet - the xList return code.

Return Value:

    dwRet - the new xList return code.

--*/
{
    Assert(dwRet == 0);
    Assert(gError.dwReturn == 0 &&
           gError.dwWin32Err == ERROR_SUCCESS &&
           gError.dwLdapErr == LDAP_SUCCESS);
    
    xListClearErrorsInternal(CLEAR_ALL);
    
    return(ERROR_SUCCESS);
}

// --------------------------------------------------------------
// xList public error API
// --------------------------------------------------------------

void
xListClearErrors(
    void
    )
/*++

Routine Description:

    This cleans the error state of the xList library.  This function should be called
    between any two xList API calls that return a non-zero error code.

--*/
{
    xListClearErrorsInternal(CLEAR_ALL);
}

void
xListGetError(
    DWORD       dwXListReturnCode,
    DWORD *     pdwReason,
    WCHAR **    pszReasonArg, 
    
    DWORD *     pdwWin32Err,
    
    DWORD *     pdwLdapErr,
    WCHAR **    pszLdapErr,
    DWORD *     pdwLdapExtErr,
    WCHAR **    pszLdapExtErr,
    WCHAR **    pszExtendedErr

    )
/*++

Routine Description:

    This returns the error state from the xList library.

Arguments:

    dwXListReason (IN) - The value handed to the user by the previous xList API.
    pdwReason (OUT) - xList Reason Code - see XLIST_ERR_*
    pdwWin32Err (OUT) - Causing Win32 Error if there was one.
    pdwLdapErr (OUT) - Causing LDAP Error if there was one.
    pszReasonArg (OUT) - The argument that goes with the *pdwReason.

NOTES:

    None of these pointer type variables can be used after xListClearErrors() has
    been called!

--*/
{
    #define ConditionalSet(pVal, Val)    if(pVal) { *pVal = Val; }
    
    Assert(dwXListReturnCode == gError.dwReturn);

    // xList
    ConditionalSet(pdwReason, xListReason(gError.dwReturn));
    ConditionalSet(pszReasonArg, gError.szReasonArg);
    
    // Win32
    ConditionalSet(pdwWin32Err, gError.dwWin32Err);
    
    // Ldap
    ConditionalSet(pdwLdapErr, gError.dwLdapErr);
    ConditionalSet(pszLdapErr, gError.szLdapErr);
    ConditionalSet(pdwLdapExtErr, gError.dwLdapExtErr);
    ConditionalSet(pszLdapExtErr, gError.szLdapExtErr);
    ConditionalSet(pszExtendedErr, gError.szExtendedErr);
    
    #undef ConditionalSet
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\x_list\x_list_p.h ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

   xList Library - dc_list.c

Abstract:

   This provides a little library for enumerating lists of DCs, and resolving
   various other x_list things.

Author:

    Brett Shirley (BrettSh)

Environment:

    repadmin.exe, but could be used by dcdiag too.

Notes:

Revision History:

    Brett Shirley   BrettSh     July 9th, 2002
        Created file.

--*/

// Include files all files need.
#include <debug.h>      // Our Assert() facility.
#include <fileno.h>     // More for our Assert() facility.
#include <strsafe.h>    // safe string copy routines.

#include "ndnc.h"       // GetRootAttr(), GetFsmoLdapBinding(), wcsistr(), and others ...

                      
// 
// Some library wide variables.
//
extern WCHAR *  gszHomeServer;
extern LDAP *   ghHomeLdap;
// Cached but not referenced outside of x_list_ldap.c
//extern WCHAR *  gszHomeDsaDn;
//extern WCHAR *  gszHomeServerDns;
//extern WCHAR *  gszHomeConfigDn;
extern WCHAR *  gszHomeSchemaDn;
extern WCHAR *  gszHomeDomainDn;
extern WCHAR *  gszHomeRootDomainDn;
extern WCHAR *  gszHomeBaseSitesDn;
extern WCHAR *  gszHomeRootDomainDns;
extern WCHAR *  gszHomeSiteDn;
extern WCHAR *  gszHomePartitionsDn;
                       
// NOTE: To set this Creds parameter for the xList library, simply set globals in
// your executeable (like repadmin.exe) by these names.  Either way the executeable
// will need to have these globals defined to link to this .lib
extern SEC_WINNT_AUTH_IDENTITY_W * gpCreds;
// FUTURE-2002/02/07-BrettSh Some day we may wish for more library isolation, 
// and use some sort of xListSetGlobals() type func, to set these parameters in
// just the local library.  For now less copies of global security info is good.



// ----------------------------------------------
// private SITE_LIST routines
// ----------------------------------------------
DWORD xListGetHomeSiteDn(WCHAR ** pszHomeSiteDn);
DWORD xListGetBaseSitesDn(LDAP * hLdap, WCHAR ** pszBaseSitesDn);
DWORD ResolveSiteNameToDn(LDAP * hLdap, WCHAR * szSiteName, WCHAR ** pszSiteDn);



// ----------------------------------------------
// xList utility functions,
// ----------------------------------------------

//
// xList LDAP search routines
//
#define  LdapSearchFirst(hLdap, szBaseDn, ulScope, szFilter, aszAttrs, ppSearch)    LdapSearchFirstWithControls(hLdap, szBaseDn, ulScope, szFilter, aszAttrs, NULL, ppSearch)
DWORD    LdapSearchFirstWithControls(LDAP * hLdap, WCHAR * szBaseDn, ULONG ulScope, WCHAR * szFilter, WCHAR ** aszAttrs, LDAPControlW ** apControls, XLIST_LDAP_SEARCH_STATE ** ppSearch);
DWORD    LdapSearchNext(XLIST_LDAP_SEARCH_STATE * pSearch);
void     LdapSearchFree(XLIST_LDAP_SEARCH_STATE ** ppSearch);
#define  LdapSearchHasEntry(pSearch)     (((pSearch) != NULL) && ((pSearch)->pCurEntry != NULL))
DWORD    LdapGetAttr(LDAP * hLdap, WCHAR * szDn, WCHAR * szAttr, WCHAR ** pszValue);

//
// xList LDAP Home Server utilitiy routines.
//
DWORD xListConnect(WCHAR * szServer, LDAP ** phLdap);
DWORD xListConnectHomeServer(WCHAR * szHomeServer, LDAP ** phLdap);
DWORD xListGetHomeServer(LDAP ** phLdap);
DWORD xListGetGuidDnsName(UUID * pDsaGuid, WCHAR ** pszGuidDns);



// ----------------------------------------------
// Simple utility functions.
// ----------------------------------------------

//
// String and DN manipulation routines.  Don't set xList Reason
//
WCHAR *  TrimStringDnBy(LPWSTR pszInDn, ULONG ulTrimBy);
DWORD    MakeString2(WCHAR * szFormat, WCHAR * szStr1, WCHAR * szStr2, WCHAR ** pszOut);
DWORD    MakeLdapBinaryStringCb(WCHAR * szBuffer, ULONG cbBuffer, void * pBlobIn, ULONG cbBlob);
WCHAR *  GetDelimiter(WCHAR * szString, WCHAR wcTarget);
#define  MakeLdapBinaryStringSizeCch(cbSize)   (3 * cbSize + 1)
DWORD    LocateServer(LPWSTR szDomainDn, WCHAR ** pszServerDns);
DWORD    GeneralizedTimeToSystemTimeA(LPSTR IN szTime, PSYSTEMTIME OUT psysTime);
int      MemAtoi(BYTE *pb, ULONG cb);
DSTimeToSystemTime(LPSTR IN szTime, PSYSTEMTIME OUT psysTime);
DWORD    ParseRanges(WCHAR * szRangedAttr, ULONG * pulStart, ULONG * pulEnd);


// ----------------------------------------------
// Error handling functions.
// ----------------------------------------------

//
// Masks for the different parts of gError.dwReturn and the xList Return code.
//
// defined in x_list.h

#define  CLEAR_REASON    XLIST_REASON_MASK
#define  CLEAR_WIN32     XLIST_LDAP_ERROR
#define  CLEAR_LDAP      XLIST_WIN32_ERROR
#define  CLEAR_ALL       (CLEAR_WIN32 | CLEAR_LDAP | CLEAR_REASON)

//
// Private error management functions
//
void     xListAPIEnterValidation(void);
void     xListAPIExitValidation(DWORD dwRet);
DWORD    xListEnsureCleanErrorState(DWORD  dwRet);
// defined in x_list.h
//#define  xListReason(dwRet)           ((dwRet) & XLIST_REASON_MASK)

//
// error setting/clearing functions
//
#define  xListSetLdapError(dwLdapErr, hLdap)    xListSetError(0, 0, dwLdapErr, hLdap, DSID(FILENO, __LINE__))
#define  xListSetWin32Error(dwWin32Err)         xListSetError(0, dwWin32Err, 0, NULL, DSID(FILENO, __LINE__))
#define  xListSetReason(eReason)                xListSetError(eReason, 0, 0, NULL, DSID(FILENO, __LINE__))
#define  xListSetBadParam()                     xListSetError(XLIST_ERR_BAD_PARAM, ERROR_INVALID_PARAMETER, 0, NULL, DSID(FILENO, __LINE__))
#define  xListSetBadParamE(err)                 xListSetError(XLIST_ERR_BAD_PARAM, err, 0, NULL, DSID(FILENO, __LINE__))
#define  xListSetNoMem()                        xListSetError(XLIST_ERR_NO_MEMORY, ERROR_NOT_ENOUGH_MEMORY, 0, NULL, DSID(FILENO, __LINE__))
void     xListSetArg(WCHAR * szArg);
DWORD    xListSetError(DWORD dwXListErr, DWORD dwWin32Err, DWORD dwLdapErr, LDAP * hLdap, DWORD dwDSID);
DWORD    xListClearErrorsInternal(DWORD dwXListMask);

//
// some quasi-functions ...
//
#define  xListEnsureWin32Error(err) if ((err) == ERROR_SUCCESS) { \
                                        err = ERROR_DS_CODE_INCONSISTENCY; \
                                    }
#define  xListEnsureError(err)      if (!((err) & XLIST_LDAP_ERROR) && \
                                        !((err) & XLIST_WIN32_ERROR) ) { \
                                        err = xListSetReason(0); \
                                    }
#define  xListEnsureNull(ptr)       if ((ptr) != NULL){ \
                                        Assert(!"Error, code inconsistency, expected NULL ptr (will cause mem leak)"); \
                                        (ptr) = NULL; \
                                    }



// ----------------------------------------------
// Globally required constants.
// ----------------------------------------------
#define     SITES_RDN                       L"CN=Sites,"
// This is a max size of a DWORD printed in decimal.
#define     CCH_MAX_ULONG_SZ                (12)


// ----------------------------------------------
// Globally required constants.
// ----------------------------------------------

//
// Quasi functions ...
//
#define   NULL_DC_NAME(x)     ( ((x) == NULL) || ((x)[0] == L'\0') || (((x)[0] == L'.') && ((x)[1] == L'\0')) )
#define   NULL_SITE_NAME(x)   NULL_DC_NAME(x)

#define  xListQuickStrCopy(szCopy, szOrig, dwRet, FailAction)  \
                QuickStrCopy(szCopy, szOrig, dwRet, dwRet = xListSetWin32Error(dwRet); FailAction)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\x_list\x_list_ldap.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

   xList Library - x_list_err.c

Abstract:

   This file has some extra utility functions for allocating, copying, 
   trimming DNs, etc.

Author:

    Brett Shirley (BrettSh)

Environment:

    repadmin.exe, but could be used by dcdiag too.

Notes:

Revision History:

    Brett Shirley   BrettSh     July 9th, 2002
        Created file.

--*/

#include <ntdspch.h>

#include <dsrole.h>     // DsRoleGetPrimaryDomainInformation() uses netapi32.lib
#include <dsgetdc.h>    // DsGetDcName() uses netapi32.lib
#include <lm.h>         // NetApiBufferFree() uses netapi32.lib
#include <ntdsa.h>      // DSNAME type only defined in here, need it for the parsedn.lib functions.

// This library's main header files.
#include "x_list.h"
#include "x_list_p.h"
#define FILENO    FILENO_UTIL_XLIST_UTIL


//
// Constants
//
#define PARTITIONS_RDN                  L"CN=Partitions,"
#define DEFAULT_PAGED_SEARCH_PAGE_SIZE  (1000) 



//
// Global parameters
//                                    


//
// Global variables for the home server routines.
//
WCHAR *  gszHomeServer = NULL; // We set this variable if the client provides a hint home server.

// FUTURE-2002/07/21-BrettSh - It'd be an excellent idea to put all these cached
// values into a single structure, so they could all be just part of the x_list_ldap
// module, and easy to manage as one global XLISTCACHE or XLISTHOMESERVERCACHE state.
LDAP *   ghHomeLdap = NULL;
WCHAR *  gszHomeDsaDn = NULL;
WCHAR *  gszHomeServerDns = NULL;
WCHAR *  gszHomeConfigDn = NULL;
WCHAR *  gszHomeSchemaDn = NULL;
WCHAR *  gszHomeDomainDn = NULL;
WCHAR *  gszHomeRootDomainDn = NULL;

WCHAR *  gszHomeBaseSitesDn = NULL;
WCHAR *  gszHomeRootDomainDns = NULL;
WCHAR *  gszHomeSiteDn = NULL;
WCHAR *  gszHomePartitionsDn = NULL;


// ----------------------------------------------
// xList LDAP search routines
// ----------------------------------------------

DWORD
LdapSearchFirstWithControls(
    LDAP *                           hLdap,
    WCHAR *                          szBaseDn,
    ULONG                            ulScope,
    WCHAR *                          szFilter,
    WCHAR **                         aszAttrs,
    LDAPControlW **                  apControls,
    XLIST_LDAP_SEARCH_STATE **       ppSearch
    )
/*++

Routine Description:

    This is xList's primary search routine.  This gives the caller a pointer
    to an XLIST_LDAP_SEARCH_STATE, and an error reason.  On a perfect search
    the routine will leave the caller positioned on the LDAP object of interest
    in (*ppSearch)->pCurEntry field.  This routine has 3 functional return 
    states.  
    
    (SUCCESS) - dwRet = 0
                *ppSearch = non-NULL
                (*ppSearch)->pCurEntry = posititoned LDAPMessage
    (QUASI-SUCCESS)
                dwRet = 0
                *ppSearch = non-NULL
                (*ppSearch)->pCurEntry = NULL
    (FAILURE) - dwRet = <ERROR>
                *ppSearch = NULL
                
    It's important to understand the quasi-success case, this is the case,
    where we had no trouble talking to the server, or performing the LDAP
    search, but this search didn't return any results.

Arguments:

    hLdap (IN) - bound ldap handle
    szBaseDn (IN) - DN to root the LDAP search at
    ulScope (IN) - LDAP_SCOPE_* constant
    szFilter (IN) - LDAP Filter to use.
    aszAttrs (IN) - LDAP Attributes to return.
    ppSearch (IN) - Allocated search state, use LdapSearchFree() to free,
            when the caller wants to free.
        pCurEntry - This member of the ppSearch parameter will be positioned
            on an LDAPMessage entry of the object the caller was looking for.
            
        NOTE: other params in (*ppSearch)->xxxx
        hLdap - Cache of the LDAP * passed in, don't ldap_unbind() this 
            handle until done using the LdapSearchXxxx() APIs on this
            search state.
        pLdapSearch - This is the ldap_search_init_page() returned value,
            don't mess with, it's internal to the LdapSearchXxxx() API.
        pCurResult - The result set returned by ldap_get_next_page_s(),
            like pLdapSearch this is interal to the LdapSearchXxxx() API.

Return Value:

    dwRet - XList Return Code

--*/
{
    ULONG                      ulTotalEstimate = 0;
    DWORD                      dwRet = ERROR_SUCCESS;
    DWORD                      dwLdapErr;

    Assert(ppSearch);

    __try{

        *ppSearch = LocalAlloc(LPTR, sizeof(XLIST_LDAP_SEARCH_STATE));
        if (*ppSearch == NULL) {
            dwRet = xListSetWin32Error(GetLastError());
            __leave;
        }
        Assert((*ppSearch)->pCurEntry == NULL); // LPTR constant is suppose zero init the mem.
        (*ppSearch)->hLdap = hLdap;

        (*ppSearch)->pLdapSearch = ldap_search_init_page((*ppSearch)->hLdap,
                                            szBaseDn,
                                            ulScope,
                                            szFilter,
                                            aszAttrs,
                                            FALSE,
                                            apControls,    // ServerControls
                                            NULL,    // ClientControls
                                            0,       // PageTimeLimit
                                            0,       // TotalSizeLimit
                                            NULL);   // sort key

        if((*ppSearch)->pLdapSearch == NULL){
            dwRet = xListSetLdapError(LdapGetLastError(), hLdap);
            __leave;
        }

        dwLdapErr = ldap_get_next_page_s((*ppSearch)->hLdap,
                                         (*ppSearch)->pLdapSearch,
                                         0,
                                         DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                         &ulTotalEstimate,
                                         &((*ppSearch)->pCurResult) );
        if(dwLdapErr != LDAP_SUCCESS){
            dwRet = xListSetLdapError(dwLdapErr, hLdap);
            __leave;
        }

        if (dwLdapErr != LDAP_SUCCESS) {
            if(dwLdapErr != LDAP_NO_RESULTS_RETURNED){
                dwRet = xListSetLdapError(dwLdapErr, hLdap);
                __leave;
            }

            //
            // Quasi-Success
            //
            Assert((*ppSearch)->pCurEntry == NULL);
            dwRet = xListEnsureCleanErrorState(dwRet);
            __leave;

        }

        (*ppSearch)->pCurEntry = ldap_first_entry ((*ppSearch)->hLdap, (*ppSearch)->pCurResult);
        if ((*ppSearch)->pCurEntry != NULL) {

            //
            // Success.
            //
            dwRet = xListEnsureCleanErrorState(dwRet);

        } else {
            
            dwLdapErr = LdapGetLastError();

            if (dwLdapErr) {
                dwRet = xListSetLdapError(dwLdapErr, hLdap);
                __leave;
            }

            // NOTE: dwLdapErr may be zero if there was no matching results.
            //
            // Another Quasi-Success
            // 
            dwRet = xListEnsureCleanErrorState(dwRet);
        
        }

    } finally {
        if (dwRet) {
            LdapSearchFree(ppSearch);
        }
    }

    Assert(dwRet || ppSearch);
    return(dwRet);

}

DWORD
LdapSearchNext(
    XLIST_LDAP_SEARCH_STATE *            pSearch
    )
/*++

Routine Description:

    This is xList's primary search routine.  This gives the caller a pointer
    to an XLIST_LDAP_SEARCH_STATE, and an error reason.  On a perfect search
    the routine will leave the caller positioned on the LDAP object of interest
    in (*ppSearch)->pCurEntry field.  This routine basically has the same 3 
    functional return states as LdapSearchFirst().
    
    (SUCCESS) - dwRet = 0
                pSearch->pCurEntry = posititoned LDAPMessage
    (QUASI-SUCCESS)
                dwRet = 0
                pSearch->pCurEntry = NULL
    (FAILURE) - dwRet = <ERROR>
                pSearch->pCurEntry = NULL
                
    It's important to understand the quasi-success case, this is the case,
    where we had no trouble talking to the server, or performing the LDAP
    search, but there were no more results to return.

Arguments:

    pSearch (IN) - Current search state.  Use LdapSearchFree() to free.
        pCurEntry - This member of the ppSearch parameter will be positioned
            on an LDAPMessage entry of the object the caller was looking for.

Return Value:

    dwRet - XList Reason

--*/
{
    ULONG                      ulTotalEstimate = 0;
    DWORD                      dwRet = ERROR_SUCCESS;
    DWORD                      dwLdapErr;

    Assert(pSearch);

    if (pSearch->pLdapSearch == NULL ||
        pSearch->pCurResult == NULL ||
        pSearch->pCurEntry == NULL) {
        Assert(!"Bad Programmer, should've had an error or NULL pCurEntry from previous call"
               "to LdapSearchFirst/Next() to prevent this.");
        dwRet = xListSetReason(0);
        return(1);
    }

    __try{

        pSearch->pCurEntry = ldap_next_entry (pSearch->hLdap, pSearch->pCurEntry);
        if (pSearch->pCurEntry == NULL) {

            // We'll need to make sure that XxxNext() returns a NULL pCurEntry
            // and no error when we're at the end of a result set ...

            ldap_msgfree(pSearch->pCurResult);
            pSearch->pCurResult = NULL;

            dwLdapErr = ldap_get_next_page_s(pSearch->hLdap,
                                             pSearch->pLdapSearch,
                                             0,
                                             DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                             &ulTotalEstimate,
                                             &(pSearch->pCurResult));
            if (dwLdapErr != LDAP_SUCCESS ||
                pSearch->pCurResult == NULL) {

                Assert(dwLdapErr);

                if (dwLdapErr == LDAP_NO_RESULTS_RETURNED) {
                    //
                    // Quasi-success.
                    //
                    dwRet = xListEnsureCleanErrorState(dwRet);;
                    __leave;
                }

                dwRet = xListSetLdapError(dwLdapErr, pSearch->hLdap);
                __leave;

            } else {

                pSearch->pCurEntry = ldap_first_entry (pSearch->hLdap, pSearch->pCurResult);
                if (pSearch->pCurEntry == NULL) {

                    Assert(!"Think this should ever happen, that we got a new page"
                           " and it had no results.");

                    //
                    // Quasi-success.
                    //
                    dwRet = xListEnsureCleanErrorState(dwRet);;
                    __leave;
                }

                //
                // Success.
                //
                // pCurEntry should be my man, sanity check.
                Assert(pSearch->pCurEntry);
                dwRet = xListEnsureCleanErrorState(dwRet);;
            }
        } 

    } finally {
        // Client is responsible for cleaning up this search state.
        if (dwRet) {
            Assert(pSearch->pCurEntry == NULL);
        }
    }

    return(dwRet);
}

void
LdapSearchFree(
    XLIST_LDAP_SEARCH_STATE **      ppSearch
    )
/*++

Routine Description:

    This frees the ldap search state allocated by LdapSearchFirst().

Arguments:

    ppSearch - A pointer to the pointer to the memory to free.  We then
        set the caller's variable to NULL for his or her own safety. :)

--*/
{
    Assert(ppSearch && *ppSearch);
    if (ppSearch) {
        if (*ppSearch) {

            (*ppSearch)->pCurEntry = NULL;
            if ((*ppSearch)->pCurResult) {
                ldap_msgfree ((*ppSearch)->pCurResult);
                (*ppSearch)->pCurResult = NULL; // safety NULL.
            }
            if ((*ppSearch)->pLdapSearch){
                ldap_search_abandon_page((*ppSearch)->hLdap, (*ppSearch)->pLdapSearch);
                (*ppSearch)->pLdapSearch = NULL;
            }
            (*ppSearch)->hLdap = NULL; // Caller frees the LDAP * they passed us.

            LocalFree(*ppSearch);
            *ppSearch = NULL;
        }
    }
}

// ----------------------------------------------
// xList utility functions,
// ----------------------------------------------

void
xListFree(
    void *     pv
    )
/*++

Routine Description:

    This is the free routine for most XList library allocated data.  This
    routine must be used, because sometimes these routines will return
    cached data, and we would like to avoid freeing those items.

Arguments:

    pv (IN) - memory to free.

--*/
{
    Assert(pv);
    
    if (pv == gszHomeServer ||
        pv == gszHomeDsaDn ||
        pv == gszHomeServerDns ||
        pv == gszHomeConfigDn ||
        pv == gszHomeSchemaDn ||
        pv == gszHomeDomainDn ||
        pv == gszHomeRootDomainDn ||
        pv == gszHomeBaseSitesDn ||
        pv == gszHomeRootDomainDns ||
        pv == gszHomeSiteDn ||
        pv == gszHomePartitionsDn 
        ) {
        // We don't free global cached variables ...
        return;
    }
    LocalFree(pv);
}

DWORD
xListConnect(
    WCHAR *     szServer,
    LDAP **     phLdap
    )
/*++

Routine Description:

    This connects the szServer via LDAP and hands back the LDAP connection.

Arguments:

    szServer (IN) - DNS name of server to connect to.
    phLdap (OUT) - LDAP handle return value.

Return Value:

    xList Return Code.

--*/
{
    DWORD       dwRet;
    ULONG       ulOptions = 0;

    Assert(phLdap);
    *phLdap = NULL;

    *phLdap = ldap_initW(szServer, 389);
    if (*phLdap == NULL) {
        dwRet = xListSetLdapError(LdapGetLastError(), NULL);
        dwRet = xListSetReason(XLIST_ERR_CANT_CONTACT_DC);
        xListSetArg(szServer);
        return(dwRet);
    }

    // Most likely we got a single server name, and that's what we want to
    // resolve ...
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW(*phLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    dwRet = ldap_bind_sW(*phLdap,
                         NULL,
                         (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                         LDAP_AUTH_SSPI);

    if (dwRet != LDAP_SUCCESS) {
        dwRet = xListSetLdapError(dwRet, *phLdap);
        dwRet = xListSetReason(XLIST_ERR_CANT_CONTACT_DC);
        xListSetArg(szServer);
        ldap_unbind(*phLdap);
        *phLdap = NULL;
        return(dwRet);
    }


    Assert(*phLdap);
    return(xListEnsureCleanErrorState(dwRet));
}
       
#define xListFreeGlobal(x)   if (x) { LocalFree(x); (x) = NULL; }

void
xListClearHomeServerGlobals(
    void
    )
/*++

Routine Description:

    This cleans all the memory allocated by doing an xListConnectHomeServer()
    with the possible exception of gszHomeServer.
    
--*/
{
    xListFreeGlobal(gszHomeDsaDn);
    xListFreeGlobal(gszHomeServerDns);
    xListFreeGlobal(gszHomeConfigDn);
    xListFreeGlobal(gszHomeSchemaDn);
    xListFreeGlobal(gszHomeDomainDn);
    xListFreeGlobal(gszHomeRootDomainDn);
    xListFreeGlobal(gszHomeBaseSitesDn);
    xListFreeGlobal(gszHomeRootDomainDns);
    xListFreeGlobal(gszHomeSiteDn);
    xListFreeGlobal(gszHomePartitionsDn);

    // Note: Don't free gszHomeServer ... it has slightly different semantics
    if (ghHomeLdap) { 
        ldap_unbind(ghHomeLdap);
        ghHomeLdap = NULL;
    }

}

DWORD
xListConnectHomeServer(
    WCHAR *     szHomeServer,
    LDAP **     phLdap
    )
/*++

Routine Description:

    This connects the xList library to a home server, and caches all the wonderful
    global variables we want to have cached.

Arguments:

    szHomeServer - DNS to the home server.
    phLdap - Return value for the LDAP handle.

Return Value:

    xList Return Code.

--*/
{
    #define HomeCacheAttr(szAttr, szCache)      dwRet = GetRootAttr(*phLdap, (szAttr), (szCache)); \
                                                if (dwRet) { \
                                                    dwRet = xListSetLdapError(dwRet, *phLdap); \
                                                    __leave; \
                                                }
    DWORD       dwRet;
    ULONG       cbTempDn;
    BOOL        bHomeServerAllocated = FALSE;

    Assert(phLdap);
    Assert(ghHomeLdap == NULL); // changing home servers is unsupported
    Assert(gszHomeDsaDn == NULL); // called function w/o properly clearing cache.

    dwRet = xListConnect(szHomeServer, phLdap);
    if (dwRet) {
        xListEnsureNull(*phLdap);
        return(dwRet);
    }
    Assert(*phLdap);

    __try{

        //
        // Now we start caching like crazy ...
        //
        
        ghHomeLdap = *phLdap;

        // User might've set a hint ...
        if (gszHomeServer == NULL) {
            bHomeServerAllocated = TRUE;
            xListQuickStrCopy(gszHomeServer, szHomeServer, dwRet, __leave);
        }

        // FUTURE-2002/07/21-BrettSh EXTREMELY, inefficient, we should totally
        // put the list of home cache attrs in pszAttrs list passed to the
        // ldap search against the rootDSE, then pull each attribute out
        // individually.
        HomeCacheAttr(L"dsServiceName", &gszHomeDsaDn);
        HomeCacheAttr(L"dnsHostName", &gszHomeServerDns);
        HomeCacheAttr(L"configurationNamingContext", &gszHomeConfigDn);
        HomeCacheAttr(L"schemaNamingContext", &gszHomeSchemaDn);
        HomeCacheAttr(L"defaultNamingContext", &gszHomeDomainDn);
        HomeCacheAttr(L"rootDomainNamingContext", &gszHomeRootDomainDn);

        // That was the easy stuff, now for the derived DNs.
        
        // Get the base sites DN.
        cbTempDn = sizeof(WCHAR) *(wcslen(SITES_RDN) + wcslen(gszHomeConfigDn) + 1);
        gszHomeBaseSitesDn = LocalAlloc(LMEM_FIXED, cbTempDn);
        if(gszHomeBaseSitesDn == NULL){
            dwRet = xListSetWin32Error(GetLastError());
            __leave;
        }
        dwRet = HRESULT_CODE(StringCbCopyW(gszHomeBaseSitesDn, cbTempDn, SITES_RDN));
        if (dwRet) {
            Assert(!"Never should happen");
            dwRet = xListSetWin32Error(dwRet);
            __leave;
        }
        dwRet = HRESULT_CODE(StringCbCatW(gszHomeBaseSitesDn, cbTempDn, gszHomeConfigDn));
        if (dwRet) {
            Assert(!"Never should happen");
            dwRet = xListSetWin32Error(dwRet);
            __leave;
        }

        // Get the root domains dns name.
        dwRet = GetDnsFromDn(gszHomeRootDomainDn, &gszHomeRootDomainDns);
        if (dwRet) {
            dwRet = xListSetWin32Error(dwRet);
            __leave;
        }
        Assert(gszHomeRootDomainDns);

        // Get the home site (which equals dsServiceName - 3 RDNs)
        gszHomeSiteDn = TrimStringDnBy(gszHomeDsaDn, 3);
        if (gszHomeSiteDn == NULL) {
            dwRet = xListSetWin32Error(GetLastError());
            __leave;
        }

        cbTempDn = sizeof(WCHAR) * (1 + wcslen(PARTITIONS_RDN) + wcslen(gszHomeConfigDn));
        gszHomePartitionsDn = LocalAlloc(LMEM_FIXED, cbTempDn);
        if (gszHomePartitionsDn == NULL) {
            dwRet = xListSetWin32Error(GetLastError());
            __leave;
        }
        dwRet = HRESULT_CODE(StringCbCopyW(gszHomePartitionsDn, cbTempDn, PARTITIONS_RDN));
        if (dwRet) {
            Assert(!"Never should happen");
            dwRet = xListSetWin32Error(dwRet);
            __leave;
        }
        dwRet = HRESULT_CODE(StringCbCatW(gszHomePartitionsDn, cbTempDn, gszHomeConfigDn));
        if (dwRet) {
            Assert(!"Never should happen");
            dwRet = xListSetWin32Error(dwRet);
            __leave;
        }

        //
        // success, all globals cached!
        //

    } __finally {

        if (dwRet) {
            xListClearHomeServerGlobals();
            // Note: Don't free gszHomeServer if we allocated before this function.
            if (bHomeServerAllocated) {
                xListFreeGlobal(gszHomeServer);
            }
            xListEnsureError(dwRet);
            *phLdap = NULL;
        } else {
            // It's I think good enough to test the first and last things
            // that should've been set.
            Assert(ghHomeLdap && gszHomeServer && gszHomePartitionsDn);
            Assert(*phLdap);
        }

    }

    return(dwRet);
}
    
DWORD
xListCleanLib(void)
/*++

Routine Description:

    This cleans all memory allocated by this library and unbinds from
    the home server.... make sure the caller is done calling all xList
    Library functions before calling this routine.

bReturn Value:

    0

--*/
{
    // Just need a place to check compiled constraints ... this gets called once.
    Assert(XLIST_ERR_LAST < XLIST_PRT_BASE);

    xListClearErrors();
    xListClearHomeServerGlobals();
    xListFreeGlobal(gszHomeServer);
    return(ERROR_SUCCESS);
}


DWORD
xListSetHomeServer(
    WCHAR *   szServer
    )
/*++

Routine Description:

    We don't try to actually connect here just set gszHomeServer, so we 
    know the user set a hint if we ever need to call xListGetHomeServer().

Arguments:

    szServer - Client hint.
    
Return Value:

    Could have an allocation faliure.

--*/
{
    DWORD  dwRet = ERROR_SUCCESS;
    xListQuickStrCopy(gszHomeServer, szServer, dwRet, return(dwRet));
    return(dwRet);
}


      
DWORD
xListGetHomeServer(
    LDAP ** phLdap
    )
/*++

Routine Description:

    This gets the Home Server LDAP handle, if the handle has already been connected
    and cached it returns very quickly.

Arguments:

    phLdap - The LDAP handle to return it in.

Return Value:

    xList Error Code.

--*/
{
    DWORD  dwRet = ERROR_SUCCESS;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC * pDomInfo = NULL;
    WCHAR * szServerDns = NULL;

    Assert(phLdap);
    *phLdap = NULL;

    if (ghHomeLdap) {
        // Previously called xListGetHomeServer()
        Assert(gszHomeServer); // xListGetHomeServer() should've set this on the previous run.
        *phLdap = ghHomeLdap;
        return(ERROR_SUCCESS);
    }

    if (gszHomeServer) {
        // client set a hint ... use it.
        dwRet = xListConnectHomeServer(gszHomeServer, phLdap);

        if (dwRet) {
            dwRet = xListSetReason(XLIST_ERR_CANT_CONTACT_DC);
            xListSetArg(gszHomeServer);
        }
        Assert(phLdap || dwRet);
        return(dwRet);
    }
    __try{

        dwRet = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (void *)&pDomInfo);
        if (dwRet || pDomInfo == NULL) {
            dwRet = xListSetWin32Error(dwRet);
            __leave;
        }

        if (pDomInfo->MachineRole == DsRole_RolePrimaryDomainController ||
            pDomInfo->MachineRole == DsRole_RoleBackupDomainController) {

            // We're a DC lets make ourselves our home server ...

            dwRet = xListConnectHomeServer(L"localhost", phLdap);
            if (dwRet == ERROR_SUCCESS) {
                __leave;
            }

         } else if (pDomInfo->MachineRole != DsRole_RoleStandaloneServer &&
                   pDomInfo->MachineRole != DsRole_RoleStandaloneWorkstation) {

            // We're not a DC, but at least we're joined to a domain, lets use that 
            // to locate a home server in our domain ...
            if (pDomInfo->DomainNameDns) {

                dwRet = LocateServer(pDomInfo->DomainNameDns, &szServerDns);
                if (dwRet == ERROR_SUCCESS) {

                    dwRet = xListConnectHomeServer(szServerDns, phLdap);
                    if (dwRet == ERROR_SUCCESS) {
                        __leave; // Success.
                    } else {
                        __leave; // Failure
                    }
                } // else fall through and try the flat name

            }

            // We prefer DNS name above, but it may be NULL or DNS could be messed
            // up, so we'll fail to the NetBios name if necessary.
            if (pDomInfo->DomainNameFlat) {

                dwRet = LocateServer(pDomInfo->DomainNameFlat, &szServerDns);
                if (dwRet == ERROR_SUCCESS) {

                    dwRet = xListConnectHomeServer(szServerDns, phLdap);
                    if (dwRet == ERROR_SUCCESS) {
                        __leave;
                    } else {
                        __leave;
                    }
                }
            }

            // We should have an Win32 error from one of the LocateServer calls or
            // have already bailed ...
            dwRet = xListSetWin32Error(dwRet);
            xListEnsureError(dwRet);

            // FUTURE-2002/07/01-BrettSh I think if (pDomInfo->Flags & 
            // DSROLE_PRIMARY_DOMAIN_GUID_PRESENT) is true, then we can use
            // pDomInfo->DomainGuid to try to locate the domain name by GUID.
            // This I believe is used to overcome some ?transient? domain 
            // rename issues.

        } else {

            // There is nothing we can do to try to guess a good server ... :P
            // Caller should print error, and suggest they use the /s:<HomeServer> 
            // to set a home server.
            dwRet = xListSetWin32Error(ERROR_DS_CANT_FIND_DSA_OBJ);

        }

    } __finally {

        if (pDomInfo) DsRoleFreeMemory(pDomInfo);
        if (szServerDns) { xListFree(szServerDns); }
    
    }

    if (dwRet) {
        dwRet = xListSetReason(XLIST_ERR_CANT_LOCATE_HOME_DC);
    }

    return(dwRet);
}


DWORD
ParseTrueAttr(
    WCHAR *  szRangedAttr,
    WCHAR ** pszTrueAttr
    )
/*++

Routine Description:

    This routine takes a ranged attribute such as "member:range=0-1499" and
    return's the true attribute "member" in xListFree()able memory.

Arguments:

    szRangedAttr (IN) - Ranged attribute such as "member:0-1500"
    pszTrueAttr (OUT) - Gets allocated, free with xListFree().

Return Value:

    ERROR_INVALID_PARAMETER | ERROR_SUCCESS | ERROR_NOT_ENOUGH_MEMORY

--*/
{
    WCHAR * szTemp;
    DWORD dwRet = ERROR_SUCCESS;

    Assert(pszTrueAttr);
    *pszTrueAttr = NULL;

    szTemp = wcschr(szRangedAttr, L';');
    Assert(szTemp); // Huh?  We were lied to, this is not a ranged attr.
    if (szTemp) {
        *szTemp = L'\0'; // NULL out ranged count ...
        __try {
            xListQuickStrCopy(*pszTrueAttr, szRangedAttr, dwRet, __leave);
        } __finally {
            *szTemp = L';'; // just in case replace original char
        }
    } else {
        Assert(!"We should never give a non-ranged attribute to this function.");
        return(ERROR_INVALID_PARAMETER);
    }
    Assert(*pszTrueAttr || dwRet);

    return(dwRet);
}

DWORD
ParseRanges(
    WCHAR *  szRangedAttr,
    ULONG *  pulStart, 
    ULONG *  pulEnd
    )
/*++

Routine Description:

    This routine takes a ranged attribute such as "member;range=1500-2999"
    return's the ranges off the attribute, such as 1500 and 2999 for the 
    first and last value numbers for this set of ranged values for the 
    member attribute.  When you've exhausted a range *pulEnd will be zero.

Arguments:

    szRangedAttr (IN) - Ranged attribute such as "member;0-1500"
    pulStart (OUT)    - The start of the range.
    pulEnd (OUT)      - The end of the range.  Zero means no more values.

Return Value:

    ERROR_INVALID_PARAMETER | ERROR_SUCCESS

--*/
{
    WCHAR *  szTemp;


    szTemp = wcschr(szRangedAttr, L';');

    if (szTemp) {

        szTemp = wcschr(szTemp, L'=');
        if (szTemp == NULL) {
            Assert(!"Huh?  Malformed ranged attribute?");
            return(ERROR_INVALID_PARAMETER);
        }

        *pulStart = wcstol(szTemp+1, &szTemp, 10);
        if (szTemp == NULL) {
            Assert(!"Huh?  Malformed ranged attribute?");
            return(ERROR_INVALID_PARAMETER);
        }
        Assert(*szTemp = L'-');

        *pulEnd = wcstol(szTemp+1, &szTemp, 10);
        if (szTemp == NULL) {
            Assert(!"Huh?  Malformed ranged attribute?");
            return(ERROR_INVALID_PARAMETER);
        }
        Assert(((*szTemp == L'\0') || (*szTemp == L'*')) && "Huh?  Malformed ranged attribute?");
    } else {
        return(ERROR_INVALID_PARAMETER);
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\eximport\ifsglobals.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ifsurtl.h

Abstract:

    This module defines all EXIFS shared routines exported to user-mode.

Author:

    Ramesh Chinta      [Ramesh Chinta]      17-Jan-2000

Revision History:

--*/

#ifndef _IFSBLOBALS_H_
#define _IFSGLOBALS_H_

#ifdef  __cplusplus
extern  "C" {
#endif

#define DD_MAX_NAME 50
#define DD_MAX_PREFIX 10

class IFSURTL_EXPORT CIfsGlobals {

/*
    This class will loads different globals based on whether it is Local store
    or store to call into the right driver
*/

public:
    // members
    // device name
    CHAR m_szIFSDeviceName[DD_MAX_NAME+1];

    // device name length
    LONG m_lDeviceNameLength;

    // FS device name
    WCHAR m_wszFSDeviceName[DD_MAX_NAME +1];

    // User mode shadow dev name
    WCHAR m_wszUMShadowDevName[DD_MAX_NAME + 1];

    // Shadow mode Dev Name Len
    LONG m_lUMShadowDevNameLength;

    // User mode dev name
    WCHAR m_wszUMDevName[DD_MAX_NAME+1];

    // Public MDB share
    WCHAR m_wszPublicMDBShare[DD_MAX_NAME+1];

    // Mini Redirector Prefix
    WCHAR m_wszExifsMiniRdrPrefix[DD_MAX_PREFIX+1];
    
    // Mini Redirector Prefix
    LONG m_lExifsMiniRdrPrefixLen;

    // Mini Redirector Prefix Absolute Length
    LONG m_lExifsMiniRdrPrefixAbsLen;

    // Mini Redirector Prefix
    WCHAR m_wszExifsMiniRdrPrefixPrivate[DD_MAX_PREFIX+1];

    // UMR net root name
    WCHAR m_wszExUMRNetRootName[DD_MAX_NAME+1];   

	CHAR  m_szDrvKeyName[MAX_PATH+1];

	CHAR  m_szDrvLetterValueName[MAX_PATH+1];

	CHAR  m_szPbDeviceValueName[MAX_PATH+1];
    
    // Constructor
    CIfsGlobals(void)
    {

        // Device name
        m_szIFSDeviceName[0] = '\0';

        // device name length
        m_lDeviceNameLength = 0;

        // FS device name
        m_wszFSDeviceName[0] = L'\0';

        // User mode shadow dev name
        m_wszUMShadowDevName[0] = L'\0';

        // UM shadow DevName Length
        m_lUMShadowDevNameLength = 0;

        // User mode dev name
        m_wszUMDevName[0] = L'\0';

        // Public MDB share
        m_wszPublicMDBShare[0] = L'\0';

        // MiniRdr Pefix
        m_wszExifsMiniRdrPrefix[0] = L'\0';

        // MiniRdr Pefix
        m_wszExifsMiniRdrPrefixPrivate[0] = L'\0';

        // MiniRdr Prefix Len
        m_lExifsMiniRdrPrefixLen = 0;

        // MiniRdr Absolute Prefix Len
        m_lExifsMiniRdrPrefixAbsLen = 0;
        
        // UMR net root name
        m_wszExUMRNetRootName[0] = L'\0'; 
		
		// Driver Key name
		m_szDrvKeyName[0] = '\0';

		// Driver Value name
		m_szDrvLetterValueName[0] = '\0';

		// Driver Value Root
		m_szPbDeviceValueName[0] = '\0';

    }

    // Destructor
    ~CIfsGlobals(){};

    //methods
    // Load the right version of the globals
    void Load(void);

    // Unload the globals
    void Unload(void);

};

#ifdef  __cplusplus
}
#endif
        
#endif   // _IFSGLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\eximport\ifserr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1998  Microsoft Corp. All rights reserved.

Module Name:

    ifserr.h

Abstract:

    Constant definitions for the Exchange IFS driver error code values

Author:

    Rajeev Rajan 06-11-1998

Revision History:

Notice:

    DO NOT MODIFY; IFSERR.H IS NOT A SOURCE FILE. MAKE CHANGES TO
    IFSERR.MC INSTEAD.
    If you add an error code that will be logged in the NT event log
    make sure you include the line below at the end of the error text:
    %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.


--*/

#ifndef _IFSERR_
#define _IFSERR_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

// LanguageNames=(FrenchStandard=0x040c:msg00002)	

// Used from kernel mode. Do NOT use %1 for insertion strings since
// the I/O manager automatically inserts the driver/device name as 
// the first string.

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4
#define FACILITY_EXIFS_ERROR_CODE        0xFAD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EXSTATUS_DRIVER_LOADED
//
// MessageText:
//
//  The Exchange IFS driver loaded successfully.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define EXSTATUS_DRIVER_LOADED           ((NTSTATUS)0x6FAD2400L)

//
// MessageId: EXSTATUS_DRIVER_UNLOADED
//
// MessageText:
//
//  The Exchange IFS driver unloaded successfully.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define EXSTATUS_DRIVER_UNLOADED         ((NTSTATUS)0x6FAD2401L)

//
// MessageId: EXSTATUS_UNDERLYING_OPEN_FAILED
//
// MessageText:
//
//  Exchange IFS driver failed to open the underlying file %2. It failed with NTSTATUS %3.
//
#define EXSTATUS_UNDERLYING_OPEN_FAILED  ((NTSTATUS)0xEFAD2500L)

//
// MessageId: EXSTATUS_ROOT_NOT_INITIALIZED
//
// MessageText:
//
//  Exchange IFS driver received an I/O on an uninitialized root or failed to enter root.
//
#define EXSTATUS_ROOT_NOT_INITIALIZED    ((NTSTATUS)0xEFAD2501L)

//
// MessageId: EXSTATUS_INVALID_IO
//
// MessageText:
//
//  Exchange IFS driver received an I/O on a file that is not a data file. I/O is invalid.
//
#define EXSTATUS_INVALID_IO              ((NTSTATUS)0xEFAD2502L)

//
// MessageId: EXSTATUS_SCATTERLIST_READ_FAILED
//
// MessageText:
//
//  Exchange IFS driver failed to read scatter list data in the FCB.
//
#define EXSTATUS_SCATTERLIST_READ_FAILED ((NTSTATUS)0xEFAD2503L)

//
// MessageId: EXSTATUS_ROOT_SHARELOCK_FAILED
//
// MessageText:
//
//  Exchange IFS driver failed to get a share lock on the root.
//
#define EXSTATUS_ROOT_SHARELOCK_FAILED   ((NTSTATUS)0xEFAD2504L)

//
// MessageId: EXSTATUS_VNET_ROOT_ALREADY_EXISTS
//
// MessageText:
//
//  Exchange IFS driver failed to create a VNET_ROOT because one already exists.
//
#define EXSTATUS_VNET_ROOT_ALREADY_EXISTS ((NTSTATUS)0xEFAD2505L)

//
// MessageId: EXSTATUS_ROOTOPEN_NOT_EXCLUSIVE
//
// MessageText:
//
//  Attempt to create an Exchange IFS root without exclusive access.
//
#define EXSTATUS_ROOTOPEN_NOT_EXCLUSIVE  ((NTSTATUS)0xEFAD2506L)

//
// MessageId: EXSTATUS_READONLY_NO_SCATTERLIST
//
// MessageText:
//
//  Attempt to create a read-only Exchange IFS handle with no scatter-list.
//
#define EXSTATUS_READONLY_NO_SCATTERLIST ((NTSTATUS)0xEFAD2507L)

//
// MessageId: EXSTATUS_ROOT_ABANDONED
//
// MessageText:
//
//  Attempt to create an Exchange IFS handle in an abandoned root aka store.
//
#define EXSTATUS_ROOT_ABANDONED          ((NTSTATUS)0xEFAD2508L)

//
// MessageId: EXSTATUS_ROOT_NEEDS_SPACE
//
// MessageText:
//
//  An IFS root needs a space grant.
//
#define EXSTATUS_ROOT_NEEDS_SPACE        ((NTSTATUS)0xEFAD2509L)

//
// MessageId: EXSTATUS_TOO_MANY_SPACEREQS
//
// MessageText:
//
//  Too many SPACEREQs have been pended to an IFS root.
//
#define EXSTATUS_TOO_MANY_SPACEREQS      ((NTSTATUS)0xEFAD2510L)

//
// MessageId: EXSTATUS_NO_SUCH_FILE
//
// MessageText:
//
//  An open has been attempted on a filename that does not exist.
//
#define EXSTATUS_NO_SUCH_FILE            ((NTSTATUS)0xAFAD2511L)

//
// MessageId: EXSTATUS_RANDOM_FAILURE
//
// MessageText:
//
//  An IFS operation has been randomly failed.
//
#define EXSTATUS_RANDOM_FAILURE          ((NTSTATUS)0xEFAD2512L)

//
// MessageId: EXSTATUS_FILE_DOUBLE_COMMIT
//
// MessageText:
//
//  An attempt has been made to double-commit an IFS file.
//
#define EXSTATUS_FILE_DOUBLE_COMMIT      ((NTSTATUS)0xEFAD2513L)

//
// MessageId: EXSTATUS_INSTANCE_ID_MISMATCH
//
// MessageText:
//
//  An attempt has been made to commit an IFS file from one root into another or an attempt
//  has been made to open an IFS file in the wrong root.
//
#define EXSTATUS_INSTANCE_ID_MISMATCH    ((NTSTATUS)0xEFAD2514L)

//
// MessageId: EXSTATUS_SPACE_UNCOMMITTED
//
// MessageText:
//
//  An attempt has been made to commit an IFS file from one root into another.
//
#define EXSTATUS_SPACE_UNCOMMITTED       ((NTSTATUS)0xEFAD2515L)

//
// MessageId: EXSTATUS_INVALID_CHECKSUM
//
// MessageText:
//
//  An attempt has been made to open an IFS file with an EA that has an invalid checksum.
//
#define EXSTATUS_INVALID_CHECKSUM        ((NTSTATUS)0xEFAD2516L)

//
// MessageId: EXSTATUS_OPEN_DEADLINE_EXPIRED
//
// MessageText:
//
//  An attempt has been made to open an IFS file with an EA whose open deadline has expired.
//
#define EXSTATUS_OPEN_DEADLINE_EXPIRED   ((NTSTATUS)0xEFAD2517L)

//
// MessageId: EXSTATUS_FSRTL_MDL_READ_FAILED
//
// MessageText:
//
//  A MDL read on an IFS file failed because the underlying file failed a MDL read.
//
#define EXSTATUS_FSRTL_MDL_READ_FAILED   ((NTSTATUS)0xEFAD2518L)

//
// MessageId: EXSTATUS_FILE_ALREADY_EXISTS
//
// MessageText:
//
//  An attempt has been made to create an IFS file that already exists.
//
#define EXSTATUS_FILE_ALREADY_EXISTS     ((NTSTATUS)0xAFAD2519L)

//
// MessageId: EXSTATUS_DIRECTORY_HAS_EA
//
// MessageText:
//
//  An attempt has been made to create a directory with an EA.
//
#define EXSTATUS_DIRECTORY_HAS_EA        ((NTSTATUS)0xAFAD2520L)

//
// MessageId: EXSTATUS_STALE_HANDLE
//
// MessageText:
//
//  An I/O operation has been attempted on a stale handle. The InstanceID of the handle does
//  not match the NetRoot InstanceID.
//
#define EXSTATUS_STALE_HANDLE            ((NTSTATUS)0xEFAD2521L)

//
// MessageId: EXSTATUS_PRIVILEGED_HANDLE
//
// MessageText:
//
//  The IFS handle is privileged. The Exchange IFS driver will handle operations on a privileged handle
//  with special semantics.
//
#define EXSTATUS_PRIVILEGED_HANDLE       ((NTSTATUS)0x6FAD2522L)

#endif /* _IFSERR_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\export\eseback2.h ===
/*
 *	ESEBACK2.H
 *	
 *	Contains declarations of additional definitions and interfaces
 *	for the ESE server apps.
 */
#ifndef	_ESEBACK2_
#define	_ESEBACK2_

//
//	Useful types.
//
typedef	long ERR;
typedef	long HRESULT;

#include "jet.h"
#include "esebcli2.h"

#define	ESEBACK_API __stdcall
#define	ESEBACK_CALLBACK __stdcall

#ifdef	__cplusplus
extern "C" {
#endif

#define IN
#define OUT


//  Server API for backup and restore

#ifndef ESE_REGISTER_BACKUP
#define ESE_REGISTER_BACKUP 			0x00000001
#endif

#ifndef ESE_REGISTER_ONLINE_RESTORE
#define ESE_REGISTER_ONLINE_RESTORE 	0x00000002
#endif

#ifndef ESE_REGISTER_OFFLINE_RESTORE
#define ESE_REGISTER_OFFLINE_RESTORE 	0x00000004
#endif

#ifndef ESE_REGISTER_SNAPSHOT_BACKUP
#define ESE_REGISTER_SNAPSHOT_BACKUP 	0x00000010
#endif

// this flag will determin that the HrESEGetNodes() 
// will be solved at ESEBACK2 level (return the list of Exchange
// server from DS) not at server level using callback functions
#ifndef ESE_REGISTER_EXCHANGE_SERVER
#define ESE_REGISTER_EXCHANGE_SERVER 	0x00000100
#endif



HRESULT ESEBACK_API HrESEBackupRestoreRegister(
	IN  WCHAR *  			wszDisplayName,
	IN  unsigned long		fFlags,
	IN  WCHAR *  			wszEndpointAnnotation,
	IN  WCHAR *  			wszCallbackDll);

HRESULT ESEBACK_API HrESEBackupRestoreUnregister( void );


//  Server API for restore/recover

HRESULT ESEBACK_API HrESERecoverAfterRestore ( 
	IN	WCHAR *			wszRestoreLogPath,
	IN	WCHAR *			wszCheckpointFilePath,
	IN	WCHAR *			wszLogFilePath,
	IN	WCHAR * 		wszTargetInstanceName);

HRESULT ESEBACK_API HrESERecoverAfterRestore2 ( 
		WCHAR *			wszRestoreLogPath,
		WCHAR *			wszCheckpointFilePath,
		WCHAR *			wszLogFilePath,
		WCHAR * 		wszTargetInstanceCheckpointFilePath,
		WCHAR * 		wszTargetInstanceLogPath
		);

typedef struct _ESEBACK_CONTEXT
	{
	unsigned long 		cbSize;
	WCHAR *  			wszServerName;
	void *  			pvApplicationData;
	
	} ESEBACK_CONTEXT, * PESEBACK_CONTEXT;

//	callback function definitions for backup and restore

typedef void (ESEBACK_CALLBACK *PfnESECBFree)( 
	IN  void *				pv );


typedef ERR (ESEBACK_CALLBACK *PfnErrESECBGetDatabasesInfo)(
	IN  PESEBACK_CONTEXT			pBackupContext,
	OUT unsigned long 				* pcInfo,
	OUT INSTANCE_BACKUP_INFO	   	** prgInfo,
	IN 	unsigned long	 			fReserved
	);

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBFreeDatabasesInfo)(
	IN  PESEBACK_CONTEXT			pBackupContext,
	IN	unsigned long 				cInfo,
	IN	INSTANCE_BACKUP_INFO *		rgInfo
	);


//	callback function definitions for backup

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBPrepareInstanceForBackup)( 
	IN  PESEBACK_CONTEXT	pBackupContext,
	IN  JET_INSTANCE 		ulInstanceId,
	IN  void *				pvReserved);

#define BACKUP_DONE_FLAG_ABORT		ESE_BACKUP_INSTANCE_END_ERROR
#define BACKUP_DONE_FLAG_NORMAL 	ESE_BACKUP_INSTANCE_END_SUCCESS
				
typedef ERR (ESEBACK_CALLBACK *PfnErrESECBDoneWithInstanceForBackup)(
	IN  PESEBACK_CONTEXT	pBackupContext,
	IN  JET_INSTANCE 		ulInstanceId,
	IN  unsigned long		fComplete,
	IN  void *				pvReserved );
				
typedef ERR (ESEBACK_CALLBACK *PfnErrESECBGetDependencyInfo)(
	IN  PESEBACK_CONTEXT	pBackupContext,
	IN  JET_INSTANCE 		ulInstanceId,
	OUT void **				pvInfo,
	OUT unsigned long *		pcbInfo,
	OUT WCHAR ** 			pwszAnnotations,
	IN  void *				pvReserved );




//	callback function definitions for restore

#define RESTORE_OPEN_REOPEN 	0x0001L
#define RESTORE_OPEN_GET_PATH 	0x0002L

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBRestoreOpen)(
	IN  PESEBACK_CONTEXT	pRestoreContext,
	IN  unsigned long		fFlags,
	IN  WCHAR *				wszSrcInstanceName,
	OUT WCHAR **			pwszRestorePath,
	IN  void *				pvReserved );

#define RESTORE_CLOSE_FLAG_NORMAL 						0x0001L
#define RESTORE_CLOSE_FLAG_ABORT						0x0002L
#define RESTORE_CLOSE_FLAG_RPC							0x0004L
#define RESTORE_CLOSE_FLAG_COMPLETE_CALLED 				0x0008L

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBRestoreClose)(
	IN  PESEBACK_CONTEXT	pRestoreContext,
	IN 	unsigned long		fFlags,
	IN  void *				pvReserved );

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBRestoreGetDestination)(
	IN  PESEBACK_CONTEXT	pRestoreContext,
	IN  WCHAR *				wszDatabaseDisplayName,
	IN  GUID				guidDatabase,
	IN  WCHAR *				wszDatabaseFileNameS,
	IN  WCHAR *				wszDatabaseSLVFileNameS,
	OUT WCHAR **			pwszDatabaseFileNameD,
	OUT WCHAR **			pwszDatabaseSLVFileNameD,
	IN  void *				pvReserved );

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBRestoreComplete)(
	IN  PESEBACK_CONTEXT	pRestoreContext,
	IN  WCHAR *				wszRestorePath,
	IN 	unsigned long		fFlags,
	IN  void *				pvReserved );

// calback functions for nodes tree

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBGetNodes)(
	IN  PESEBACK_CONTEXT	pContext,
	OUT PBACKUP_NODE_TREE *	ppBackupNodeTree,
	IN  void *				pvReserved );

typedef VOID (ESEBACK_CALLBACK *PfnESECBFreeNodes)(
	IN  PBACKUP_NODE_TREE 	pBackupNodeTree );

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBGetIcons)(
	IN  PESEBACK_CONTEXT		pContext,
	OUT ESE_ICON_DESCRIPTION *	pDisplayIcon,
	OUT ESE_ICON_DESCRIPTION *	pAnnotationIcon,
	IN  void *				pvReserved );

#ifdef	__cplusplus
}
#endif
#endif	// _ESEBACK2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\eximport\ifsurtl.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ifsurtl.h

Abstract:

    This module defines all EXIFS shared routines exported to user-mode.

Author:

    Rajeev Rajan      [RajeevR]      2-June-1999
	Rohan  Phillips   [Rohanp]       23-June-1999 - Added provider functions

Revision History:

--*/

#ifndef _IFSURTL_H_
#define _IFSURTL_H_

#ifdef  __cplusplus
extern  "C" {
#endif

#ifdef  _IFSURTL_IMPLEMENTATION_
#ifndef IFSURTL_EXPORT
#define IFSURTL_EXPORT   __declspec( dllexport )
#endif
#else
#ifndef IFSURTL_EXPORT
#define IFSURTL_EXPORT   __declspec( dllimport )
#endif
#endif

#ifndef IFSURTL_CALLTYPE
#define IFSURTL_CALLTYPE __stdcall
#endif

///////////////////////////////////////////////////////////////////////////////
//
//  Callback for IFS functions
//
///////////////////////////////////////////////////////////////////////////////

typedef void (WINAPI *PFN_IFSCALLBACK)(PVOID);

///////////////////////////////////////////////////////////////////////////////
//
//  Following are the structures / definitions for the large buffer package
//
///////////////////////////////////////////////////////////////////////////////

#define IFS_LARGE_BUFFER_SIGNATURE              (ULONG) 'fubL'
#define IFS_CURSOR_SIGNATURE                    (ULONG) 'rsrC'

#define IFS_LARGE_BUFFER_SHARED_VIEWSIZE        (256*1024)

//
//  An IFS_LARGE_BUFFER object encapsulates a temp file containing
//  data that can be passed around and used like a buffer. Typically,
//  a producer would make one of these objects and stream in large
//  amounts of data. A consumer would read different chunks of the
//  data. The object will maintain a single mapping/view of the first
//  256K of the file. 
//
//  Consumers will need to access data using IFS_CURSORS that specify 
//  the <offset,len> pair for the span of data they are interested in. 
//  In the most common case, this should lie in the first 256K region,
//  which would yield the default view. If it is beyond this region,
//  views will be mapped/unmapped on demand.
//
typedef struct _IFS_LARGE_BUFFER {
    //
    //  Signature
    //
    ULONG   m_Signature;
    
    //
    //  Handle
    //
    HANDLE  m_FileContext1;

    //
    //  FileObject
    //
    PVOID   m_FileContext2;

    //
    //  FileMapping context for first 256K or filesize
    //    
    HANDLE  m_MappingContext;

    //
    //  Process context (optional)
    //
    PVOID   m_ProcessContext;
    
    //
    //  Memory pointer for first 256K or filesize
    //
    PBYTE   m_MemoryPtr;

    //
    //  Ref count - the lower WORD will count cursor refs
    //  the higher WORD will count object refs
    //
    ULONG   m_ReferenceCount;
    
    //
    //  Is this a reference or a live object ?
    //  If this is a reference, the fields above are NULL and
    //  the m_TempFileName should be used to make a new object !
    //
    BOOL    m_IsThisAReference;
    
    //
    //  Current ValidDataLength
    //
    LARGE_INTEGER m_ValidDataLength;
    
    //
    //  Name of temp file - we will use fixed
    //  names so we can make simplyfying assumptions
    //  about the filename len !
    //
    WCHAR    m_TempFileName    [MAX_PATH+1];
    
} IFS_LARGE_BUFFER,*PIFS_LARGE_BUFFER;

#define IsScatterListLarge( s )     FlagOn((s)->Flags, IFS_SLIST_FLAGS_LARGE_BUFFER)

#define EXIFS_EA_LEN_LARGE_SCATTER_LIST                                     \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_SCATTER_LIST) +                                \
        LongAlign(sizeof(SCATTER_LIST) + sizeof(IFS_LARGE_BUFFER) ))

#define EXIFS_EA_VALUE_LEN_LARGE_SCATTER_LIST                               \
        LongAlign(sizeof(SCATTER_LIST) + sizeof(IFS_LARGE_BUFFER) )

//
//  An IFS_CURSOR object provides a view into a large buffer.
//  Usage is as follows:
//  + Call IfsStartCursor() to init a cursor and get a pointer
//  + Use the pointer to read/write data via IfsConsumeCursor()
//  + Call IfsFinishCursor() to close the cursor
//
//  NOTE: Cursor usage will bump ref counts on the LARGE_BUFFER
//  object. If the LARGE_BUFFER object passed in is NOT live it
//  will instantiate one from the reference !
//
typedef struct _IFS_CURSOR {
    //
    //  Signature
    //
    ULONG               m_Signature;
    
    //
    //  Owning large buffer object
    //
    PIFS_LARGE_BUFFER   m_pLargeBuffer;

    //
    //  Current Offset to start of data
    //
    LARGE_INTEGER       m_Offset;

    //
    //  Current Span of data
    //
    ULONG               m_Length;

    //
    //  Append mode - if TRUE client can cursor beyond EOF
    //
    BOOL                m_AppendMode;
    
    //
    //  Is this a shared view
    //
    BOOL                m_IsViewShared;

    //
    //  Did we open the buffer
    //
    HANDLE              m_OwnBufferOpen;

    //
    //  Did we attach to the large buffer process
    //
    BOOL                m_AttachedToProcess;

    //
    //  The following fields are relevant only if the view is not shared.
    //  The first 256K view is shared via the mapping in the large buffer object.
    //  Cursors that extend beyond 256K make their own mapping - See Below.
    //

    //
    //  FileMapping context for this cursor
    //    
    HANDLE  m_MappingContext;
    
    //
    //  Memory pointer for this cursor
    //
    PBYTE   m_MemoryPtr;
    
} IFS_CURSOR,*PIFS_CURSOR;

//
//  Returns a pointer to data that can be used to
//  read/write. The pointer is valid only for the length
//  requested !
//  NOTE: If AppendMode is TRUE, cursors will be allowed
//  beyond EOF. This should be used by clients that wish
//  to append data to the large buffer.
//
PBYTE
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsGetFirstCursor(
        IN PIFS_LARGE_BUFFER pLargeBuffer,
        IN PIFS_CURSOR       pCursor,
        IN ULONG             StartOffsetHigh,
        IN ULONG             StartOffsetLow,
        IN ULONG             StartLength,
        IN BOOL              fAppendMode
        );

//
//  Consume bytes within current cursor
//  returns next pointer at which to read/write data !
//
//  NOTE: If all the data in the cursor is consumed, returns NULL
//
PBYTE
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsConsumeCursor(
        IN PIFS_CURSOR      pCursor,
        IN ULONG            Length
        );
        
//
//  Returns a pointer to data that can be used to
//  read/write. The pointer is valid only for the length
//  requested relative to the current cursor !
//
//  NOTE: This call advances the cursor in the large buffer
//
PBYTE
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsGetNextCursor(
        IN PIFS_CURSOR       pCursor,
        IN ULONG             NextLength
        );
        
//
//  Should be called for every matching GetFirstCursor() call.
//
VOID
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsFinishCursor(
        IN PIFS_CURSOR  pCursor
        );

//
//  Should be called to truncate the large buffer's valid data length
//
VOID
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsTruncateLargeBuffer(
        IN PIFS_LARGE_BUFFER pLargeBuffer,
        IN PLARGE_INTEGER    pSizeToTruncate
        );

//
//  Rules for passing around IFS_LARGE_BUFFERs:
//  1. These objects should be passed around by reference. eg passing
//     between user & kernel or between kernel and the namecache.
//  2. Use IfsCopyBufferByReference() to create a reference.
//  3. If a reference exists, there should always be a live object whose
//     lifetime encapsulates the reference. This allows the consumer of the
//     reference to make a *real* copy using the reference.
//  4. A reference can be converted into a live object. It is the responsibility
//     of the module that does this conversion to close the live object.
//  5. Example: When EA is checked in to the namecache during CLOSE,
//     it will be passed in as a reference. During checkin, the namecache should
//     call IfsOpenBufferToReference() to hold on to the buffer. Thus,
//     when the namecache blob is finalized, it needs to call IfsCloseBuffer()
//     to close the large buffer !
//
        
//
//  IN:  pLargeBuffer should be allocated by caller of the function
//  IN:  Len of the buffer required - zero if len is not known apriori
//
//  NOTE: Object needs to be closed via IfsCloseBuffer()
//
//  USAGE: Should be used when caller needs to instantiate a large buffer
//
NTSTATUS
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCreateNewBuffer( 
        IN PIFS_LARGE_BUFFER pLargeBuffer, 
        IN DWORD             dwSizeHigh,
        IN DWORD             dwSizeLow,
        IN PVOID             ProcessContext     // optional
        );

//
//  IN:  pLargeBuffer should be allocated by caller of the function
//  IN:  Len of the buffer required - zero if len is not known apriori
//
//  NOTE: Object needs to be closed via IfsCloseBuffer()
//
//  USAGE: Should be used when caller needs to instantiate a large buffer
//
NTSTATUS
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCreateNewBufferEx( 
        IN PIFS_LARGE_BUFFER pLargeBuffer, 
        IN DWORD             dwSizeHigh,
        IN DWORD             dwSizeLow,
        IN PVOID             ProcessContext,    // optional
        IN PUNICODE_STRING   FilePath           // optional
        );

//
//  IN: pSrcLargeBuffer points to a live large buffer object
//  IN OUT: pDstLargeBuffer is initialized as a reference to the Src
//
//  USAGE: Should be used to pass large buffers between user/kernel
//
VOID
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCopyBufferToReference(
        IN PIFS_LARGE_BUFFER pSrcLargeBuffer,
        IN OUT PIFS_LARGE_BUFFER pDstLargeBuffer
        );

//
//  IN: pSrcLargeBuffer points to a large buffer object (or reference)
//  IN OUT: pDstLargeBuffer will be initialized as a live object based on
//          the reference passed in
//
//  USAGE: Should be used to pass large buffers between user/kernel
//
NTSTATUS
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCopyReferenceToBuffer(
        IN PIFS_LARGE_BUFFER pSrcLargeBuffer,
        IN PVOID ProcessContext,    // optional
        IN OUT PIFS_LARGE_BUFFER pDstLargeBuffer
        );

//
//  IN:  pLargeBuffer points to a large buffer object (or reference)
//
//  NOTE: Object needs to be closed via IfsCloseBuffer()
//        OpenBuffer will always assume that the buffer len is fixed !
//
//  USAGE: Should be used when caller needs to convert a reference to a
//         live object. If the object is already live, this will bump
//         a reference on the object !
//
NTSTATUS
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsOpenBufferToReference(
        IN PIFS_LARGE_BUFFER pLargeBuffer
        );

//
//  IN:  pLargeBuffer coming in points to a live large buffer
//  OUT: pLargeBuffer going out points to a NEW live large buffer
//       The functions does a (deep) copy of the buffer data.
//
//  NOTE: Since the incoming object is live, it is closed and a
//        new object is instantiated in its place. Thus, IfsCloseBuffer()
//        needs to be called as usual on this !
//
NTSTATUS
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCopyBufferToNewBuffer(
        IN OUT PIFS_LARGE_BUFFER pLargeBuffer
        );
        
//
//  IN: Object should have been initialized by IfsCreateNewBuffer() or 
//  IfsOpenBufferToReference() or IfsCopyReferenceToBuffer()
//
VOID
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCloseBuffer(
        IN PIFS_LARGE_BUFFER pLargeBuffer
        );

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsInitializeProvider(DWORD OsType);

DWORD
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCloseProvider(void);

HANDLE
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCreateFileProv(WCHAR * FileName, DWORD DesiredAccess, DWORD ShareMode, PVOID
			  lpSecurityAttributes, DWORD CreateDisposition, DWORD FlagsAndAttributes,
			  PVOID EaBuffer, DWORD EaBufferSize);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsInitializeRoot(HANDLE hFileHandle, WCHAR * szRootName, WCHAR * SlvFileName, DWORD InstanceId, 
				  DWORD AllocationUnit, DWORD FileFlags);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsSpaceGrantRoot(HANDLE hFileHandle, WCHAR * szRootName, PSCATTER_LIST pSList, size_t cbListSize);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsSetEndOfFileRoot(HANDLE hFileHandle, WCHAR * szRootName, LONGLONG EndOfFile);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsSpaceRequestRoot(HANDLE hFileHandle, WCHAR * szRootName, PFN_IFSCALLBACK pfnIfsCallBack,
					PVOID pContext, PVOID Ov);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsQueryEaFile(HANDLE hFileHandle, WCHAR * szFileName, WCHAR * NetRootName, PVOID EaBufferIn, DWORD EaBufferInSize, 
			   PVOID EaBufferOut, DWORD EaBufferOutSize, DWORD * RequiredLength);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsSetEaFile(HANDLE hFileHandle, WCHAR * szFileName, PVOID EaBufferIn, DWORD EaBufferInSize);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsTerminateRoot(HANDLE hFileHandle, WCHAR *szRootName, ULONG Mode);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsGetOverlappedResult(HANDLE hFileHandle, PVOID Ov, DWORD * BytesReturned, BOOL Wait);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsReadFile(HANDLE hFileHandle, BYTE * InputBuffer, DWORD BytesToRead, PFN_IFSCALLBACK IfsCallBack,
			PVOID Overlapped);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsWriteFile(HANDLE hFileHandle, BYTE * InputBuffer, DWORD BytesToWrite, PFN_IFSCALLBACK IfsCallBack,
			 PVOID Overlapped);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsDeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInputBuffer, DWORD cbInBufferSize, 
				   LPVOID lpOutBuffer, DWORD cbOutBufferSize, LPDWORD lpBytesReturned, PVOID Overlapped);


BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsExpungName(HANDLE hFileHandle, WCHAR * szRootName, WCHAR * szFileName, ULONG cbPath);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsDirChangeReport(HANDLE hFileHandle, WCHAR * szRootName, ULONG ulFilterMatch,
				   ULONG ulAction, PWSTR pwszPath, ULONG cbPath);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsQueryRootStats(HANDLE hFileHandle, WCHAR * szRootName, PVOID Buffer, DWORD BuffSize);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsRegisterUmrThread(HANDLE hFileHandle, PFN_IFSCALLBACK pfnIfsCallBack);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsUmrEnableNetRoot(HANDLE hFileHandle, WCHAR * szRootName, DWORD * InstanceId);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsUmrDisableNetRoot(HANDLE hFileHandle, WCHAR * szRootName);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsStopUmrEngine(HANDLE hFileHandle, WCHAR * szRootName);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsStartUmrEngine(HANDLE hFileHandle, WCHAR * szRootName);


BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCloseHandle(HANDLE hFileHandle);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsSetRootMap(HANDLE hFileHandle, WCHAR * szRootName, PSCATTER_LIST pSList, size_t cbListSize);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsResetRootMap(HANDLE hFileHandle, WCHAR * szRootName);


NTSTATUS
IFSURTL_EXPORT
NTAPI
IfsNtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );



NTSTATUS
IFSURTL_EXPORT
NTAPI
IfsNtQueryEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    );



VOID
IFSURTL_EXPORT
NTAPI
IfsRtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );



LONG
IFSURTL_EXPORT
NTAPI
IfsRtlCompareUnicodeString(
    PUNICODE_STRING String1,
    PUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );
    

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsFlushHandle(HANDLE hFileHandle, 
               WCHAR * szFileName, 
               WCHAR * NetRootName, 
               PVOID EaBufferIn, 
               DWORD EaBufferInSize
               );

#ifdef  __cplusplus
}
#endif
        
#endif   // _IFSURTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\export\esebcli2.h ===
/*
 *	ESEBCLI2.H
 *
 *	Microsoft Exchange
 *	Copyright (C) 1986-1996, Microsoft Corporation
 *	
 *	Contains declarations of additional definitions and interfaces
 *	for the ESE Online Backup Client APIs.
 */
#ifndef	_ESEBCLI2_
#define	_ESEBCLI2_

#include <stdio.h>
#include <time.h>

#include "esebkmsg.h" // included for the definition of errors


//	Common types
typedef	long ERR;
typedef void *HCCX;					// client context handle

#ifdef MIDL_PASS

#define RPC_STRING 		[unique, string] WCHAR *
#define RPC_SIZE(X)		[size_is(X)]

#else // ! MIDL_PASS


#include <objbase.h>
#include <initguid.h>
#include <mapiguid.h>

typedef	long HRESULT;
#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#else
typedef wchar_t WCHAR;
#endif

#define RPC_STRING WCHAR *
#define RPC_SIZE(X)		

#define IN
#define OUT

#endif // MIDL_PASS


#define	ESEBACK_API __stdcall

#ifdef	__cplusplus
extern "C" {
#endif


typedef struct _ESE_ICON_DESCRIPTION
	{
	unsigned long 										ulSize;
	RPC_SIZE(ulSize) char * 							pvData;	
	} ESE_ICON_DESCRIPTION;


#define DATABASE_MOUNTED 	0x00000010

typedef struct _DATABASE_BACKUP_INFO
	{
	RPC_STRING 											wszDatabaseDisplayName;

	unsigned long 										cwDatabaseStreams;
	RPC_SIZE(cwDatabaseStreams)  WCHAR * 				wszDatabaseStreams;
	
	GUID  												guidDatabase;
	unsigned long  										ulIconIndexDatabase;
	unsigned long 										fDatabaseFlags;
	
	} DATABASE_BACKUP_INFO;
	
typedef struct _INSTANCE_BACKUP_INFO
	{
	__int64 											hInstanceId;
	RPC_STRING							 				wszInstanceName;
	unsigned long 										ulIconIndexInstance;
	
	unsigned long 										cDatabase;
	RPC_SIZE(cDatabase) DATABASE_BACKUP_INFO * 			rgDatabase;
	
	unsigned long					 					cIconDescription;
	RPC_SIZE(cIconDescription) ESE_ICON_DESCRIPTION * 	rgIconDescription;
	
	} INSTANCE_BACKUP_INFO;
	
//
//	Type of backup passed into HrESEBackupSetup()
//

#define	BACKUP_TYPE_FULL					0x01
#define	BACKUP_TYPE_LOGS_ONLY				0x02
#define BACKUP_TYPE_FULL_WITH_ALL_LOGS		0x03
#define BACKUP_TYPE_SNAPSHOT				0x04


typedef struct _ESE_REGISTERED_INFO
	{
	RPC_STRING							 				wszDisplayName;
	RPC_STRING							 				wszEndpointAnnotation;
	unsigned long 										fFlags;
	ESE_ICON_DESCRIPTION 								iconDescription;	
	} ESE_REGISTERED_INFO;


#define ESE_REGISTER_BACKUP 			0x00000001
#define ESE_REGISTER_ONLINE_RESTORE 	0x00000002
#define ESE_REGISTER_OFFLINE_RESTORE 	0x00000004

#define ESE_REGISTER_SNAPSHOT_BACKUP 	0x00000010


HRESULT ESEBACK_API HrESEBackupRestoreGetRegistered(
	IN  WCHAR *  					wszServerName,
	IN  WCHAR *  					wszDisplayName,
	IN 	unsigned long  				fFlags,
	OUT unsigned long * 			pcRegisteredInfo,
	OUT ESE_REGISTERED_INFO ** 		paRegisteredInfo
	);
	
void ESEBACK_API ESEBackupRestoreFreeRegisteredInfo(
	IN 	unsigned long 			cRegisteredInfo,
	IN  ESE_REGISTERED_INFO * 	aRegisteredInfo);

HRESULT ESEBACK_API HrESEBackupPrepare(
	IN  WCHAR *  		wszBackupServer,
	IN  WCHAR *  		wszBackupAnnotation,
	OUT unsigned long *				pcInstanceInfo,
	OUT INSTANCE_BACKUP_INFO ** 	paInstanceInfo,
	OUT HCCX * 			phccxBackupContext
	);

HRESULT ESEBACK_API HrESEBackupSetup(
	IN  HCCX 			hccxBackupContext,
	IN  __int64 		hInstanceId,
	IN  unsigned long 	btBackupType
	);

HRESULT ESEBACK_API HrESEBackupTruncateLogs(
	IN  HCCX 			hccxBackupContext
	);
	
HRESULT ESEBACK_API HrESEBackupGetDependencyInfo(
	IN  HCCX 			hccxBackupContext,
	OUT WCHAR **		pwszInfo,
	OUT unsigned long * pcwInfo,
	OUT WCHAR **		pwszAnnotation
	);
	
HRESULT ESEBACK_API HrESEBackupOpenFile (
	IN  HCCX 			hccxBackupContext,
	IN  WCHAR *			wszFileName,
	IN  unsigned long 	cbReadHintSize,
	IN  unsigned long 	cSections,
	OUT void **			rghFile,
	OUT __int64 *		rgliSectionSize
	);

HRESULT ESEBACK_API HrESEBackupReadFile(
	IN 	HCCX 			hccxBackupContext,
	IN 	void * 			hFile,
	IN 	void * 			pvBuffer,
	IN 	unsigned long 	cbBuffer,
	OUT unsigned long *	pcbRead
	);

HRESULT ESEBACK_API HrESEBackupCloseFile(
	IN  HCCX 			hccxBackupContext,
	IN 	void * 			hFile
	);

HRESULT ESEBACK_API HrESEBackupGetLogAndPatchFiles(
	IN  HCCX 			hccxBackupContext,
	IN  WCHAR **		pwszFiles
	);

HRESULT ESEBACK_API HrESEBackupGetTruncateLogFiles(
	IN  HCCX 			hccxBackupContext,
	IN  WCHAR **		pwszFiles
	);

void ESEBACK_API ESEBackupFreeInstanceInfo(
	IN unsigned long 				cInstanceInfo,
	IN INSTANCE_BACKUP_INFO * 		aInstanceInfo
	);

void ESEBACK_API ESEBackupFree(
	IN  void *			pvBuffer
	);

#define ESE_BACKUP_INSTANCE_END_ERROR		0x00000000
#define ESE_BACKUP_INSTANCE_END_SUCCESS		0x00000001

HRESULT ESEBACK_API HrESEBackupInstanceEnd(
	IN  HCCX 			hccxBackupContext,
	IN  unsigned long 	fFlags
	);

HRESULT ESEBACK_API HrESEBackupEnd(
	IN  HCCX 			hccxBackupContext
	);
	
//	Restore client APIs

typedef enum
	{
	recoverInvalid 		= 0,
	recoverNotStarted 	= 1,
	recoverStarted 		= 2,
	recoverEnded 		= 3,
	recoverStatusMax
	}
	RECOVER_STATUS;


typedef struct _RESTORE_ENVIRONMENT
	{
	WCHAR * 		m_wszRestoreLogPath;
	
	WCHAR * 		m_wszSrcInstanceName;

	unsigned long 	m_cDatabases;
	WCHAR ** 		m_wszDatabaseDisplayName;
	GUID * 			m_rguidDatabase;

	WCHAR * 		m_wszRestoreInstanceSystemPath;	
	WCHAR * 		m_wszRestoreInstanceLogPath;	
	WCHAR * 		m_wszTargetInstanceName;	
	
	WCHAR ** 		m_wszDatabaseStreamsS;	
	WCHAR ** 		m_wszDatabaseStreamsD;	
	
	unsigned long 	m_ulGenLow;
	unsigned long 	m_ulGenHigh;
	WCHAR *	 		m_wszLogBaseName;	

	time_t 			m_timeLastRestore;

	RECOVER_STATUS 	m_statusLastRecover;
	HRESULT 		m_hrLastRecover;	
	time_t 			m_timeLastRecover;

	WCHAR * 		m_wszAnnotation;	
	
	} RESTORE_ENVIRONMENT;

HRESULT ESEBACK_API HrESERestoreLoadEnvironment(
	IN	WCHAR *				wszServerName,
	IN	WCHAR *				wszRestoreLogPath,
	OUT RESTORE_ENVIRONMENT ** 	ppRestoreEnvironment);

void ESEBACK_API ESERestoreFreeEnvironment(
	IN  RESTORE_ENVIRONMENT * 	pRestoreEnvironment);
	

HRESULT ESEBACK_API HrESERestoreOpen(
	IN  WCHAR *					wszServerName,
	IN  WCHAR *					wszServiceAnnotation,
	IN  WCHAR *		 			wszSrcInstanceName,
	IN  WCHAR * 				wszRestoreLogPath,
	OUT HCCX *					phccxRestoreContext);

HRESULT ESEBACK_API HrESERestoreReopen(
	IN  WCHAR *					wszServerName,
	IN  WCHAR *					wszServiceAnnotation,
	IN  WCHAR *		 			wszRestoreLogPath,
	OUT HCCX *					phccxRestoreContext);
	

void ESEBACK_API ESERestoreFree( IN void *pvBuffer );


#define RESTORE_CLOSE_ABORT		0x1
#define RESTORE_CLOSE_NORMAL	0x0

HRESULT ESEBACK_API HrESERestoreClose(
	IN  HCCX 					hccxRestoreContext,
	IN  unsigned long 			fRestoreAbort);

HRESULT ESEBACK_API HrESERestoreAddDatabase(
	IN  HCCX 					hccxRestoreContext,
	IN  WCHAR *					wszDatabaseDisplayName,
	IN  GUID					guidDatabase,
	IN  WCHAR *		 			wszDatabaseStreamsS,
	OUT WCHAR **	 			pwszDatabaseStreamsD);

HRESULT ESEBACK_API HrESERestoreGetEnvironment(
	IN  HCCX 					hccxRestoreContext,
	OUT RESTORE_ENVIRONMENT ** 	ppRestoreEnvironment);

HRESULT ESEBACK_API HrESERestoreSaveEnvironment(
	IN  HCCX 					hccxRestoreContext);


#define ESE_RESTORE_COMPLETE_ATTACH_DBS			0x00000001
#define ESE_RESTORE_COMPLETE_START_SERVICE		ESE_RESTORE_COMPLETE_ATTACH_DBS

#define ESE_RESTORE_COMPLETE_NOWAIT				0x00010000
#define ESE_RESTORE_KEEP_LOG_FILES				0x00020000


HRESULT ESEBACK_API HrESERestoreComplete(
	IN  HCCX 					hccxRestoreContext,
	IN  WCHAR *					wszRestoreInstanceSystemPath,	
	IN  WCHAR *					wszRestoreInstanceLogPath,	
	IN  WCHAR *					wszTargetInstanceName,	
	IN  unsigned long 			fFlags);

HRESULT ESEBACK_API HrESERestoreAddDatabaseNS(
	IN  HCCX 					hccxRestoreContext,
	IN  WCHAR *					wszDatabaseDisplayName,
	IN  GUID					guidDatabase,
	IN  WCHAR *		 			wszDatabaseStreamsS,
	IN  WCHAR *	 				wszDatabaseStreamsD);
	

HRESULT ESEBACK_API HrESERestoreOpenFile (
	IN  HCCX 			hccxRestoreContext,
	IN  WCHAR *			wszFileName,
	IN  unsigned long 	cSections,
	OUT void **			rghFile
	);

HRESULT ESEBACK_API HrESERestoreWriteFile(
	IN 	HCCX 			hccxRestoreContext,
	IN 	void * 			hFile,
	IN 	void * 			pvBuffer,
	IN 	unsigned long 	cbBuffer
	);

HRESULT ESEBACK_API HrESERestoreCloseFile(
	IN  HCCX 			hccxRestoreContext,
	IN 	void * 			hFile
	);

/* function used to find the computers to be queried for backup/restore */
/* MAD like behaviour */
#define BACKUP_NODE_TYPE_MACHINE 		0x00000001
#define BACKUP_NODE_TYPE_ANNOTATION 	0x00000010
#define BACKUP_NODE_TYPE_DISPLAY	 	0x00000100

typedef struct _BACKUP_NODE_TREE
	{
	RPC_STRING 				wszName;
	unsigned long 			fFlags;
	ESE_ICON_DESCRIPTION	iconDescription;
	
	struct _BACKUP_NODE_TREE * 	pNextNode;
	struct _BACKUP_NODE_TREE * 	pChildNode;

} BACKUP_NODE_TREE, * PBACKUP_NODE_TREE;


HRESULT ESEBACK_API HrESEBackupRestoreGetNodes(
	IN  WCHAR * 				wszComputerName,
	OUT PBACKUP_NODE_TREE * 	ppBackupNodeTree);

void ESEBACK_API ESEBackupRestoreFreeNodes(
	IN PBACKUP_NODE_TREE  	pBackupNodeTree);



// Specific errors that can be returned by callback functions

// Database to be restored is in use
#define hrFromCB_DatabaseInUse 							hrCBDatabaseInUse

// Database not found
#define hrFromCB_DatabaseNotFound 						hrCBDatabaseNotFound

// Display name for the database not found
#define hrFromCB_DatabaseDisplayNameNotFound 			hrCBDatabaseDisplayNameNotFound

// Requested path for restore log files not provided
#define hrFromCB_RestorePathNotProvided 				hrCBRestorePathNotProvided

// Instance to backup not found
#define hrFromCB_InstanceNotFound 						hrCBInstanceNotFound

// Database can not be overwritten by a restore
#define hrFromCB_DatabaseCantBeOverwritten 				hrCBDatabaseCantBeOverwritten

// snapshot API

HRESULT ESEBACK_API HrESESnapshotStart( 		
										IN  HCCX 					hccxBackupContext,
										IN  WCHAR *		 			wszDatabases,
										IN  unsigned long 			fFlags );
										

HRESULT ESEBACK_API HrESESnapshotStop(	IN  HCCX 						hccxBackupContext,
										IN  unsigned long 				fFlags );

#ifdef	__cplusplus
}
#endif

#endif	// _EDBBCLI2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\eximport\exifs.h ===
/*++

Copyright (c) 1989 - 1998 Microsoft Corporation

Module Name:

    exifs.h

Abstract:

    This header exports all symbols and definitions shared between
    user-mode clients of the Exchange IFS driver and the driver itself.

Notes:

    This module has been built and tested only in UNICODE environment

Author:

    Rajeev Rajan      [RajeevR]      2-Feb-1998

Revision History:

    Mike Purtell      [MikePurt]     21-Jul-1998
	     Additions for NSM (Name Space Mapping)

	Ramesh Chinta     [Rameshc]      01-Jan-2000
	     Separate version of IFS for Local Store

--*/

#ifndef _EXIFS_H_
#define _EXIFS_H_


// These globals define LOCAL STORE version of the strings
#define LSIFS_DEVICE_NAME_A "LocalStoreIfsDevice"
// The following constant defines the length of the above name.
#define LSIFS_DEVICE_NAME_A_LENGTH (20)
// The following constant defines the path in the ob namespace
#define DD_LSIFS_FS_DEVICE_NAME_U               L"\\Device\\LocalStoreDevice"
#define DD_LSIFS_USERMODE_SHADOW_DEV_NAME_U     L"\\??\\LocalStoreIfs"
#define DD_LSIFS_USERMODE_DEV_NAME_U            L"\\\\.\\LocalStoreIfs"
#define DD_PUBLIC_MDB_SHARE_LSIFS               L"\\??\\WebStorage"



#ifdef LOCALSTORE
#define EXIFS_DEVICE_NAME_A LSIFS_DEVICE_NAME_A

// The following constant defines the length of the above name.
#define EXIFS_DEVICE_NAME_A_LENGTH LSIFS_DEVICE_NAME_A_LENGTH

// The following constant defines the path in the ob namespace
#define DD_EXIFS_FS_DEVICE_NAME_U DD_LSIFS_FS_DEVICE_NAME_U
#else  // PLATINUM
// Device name for this driver
#define EXIFS_DEVICE_NAME_A "ExchangeIfsDevice"

// The following constant defines the length of the above name.
#define EXIFS_DEVICE_NAME_A_LENGTH (18)

// The following constant defines the path in the ob namespace
#define DD_EXIFS_FS_DEVICE_NAME_U L"\\Device\\ExchangeIfsDevice"
#endif // PLATINUM

#ifndef EXIFS_DEVICE_NAME
#define EXIFS_DEVICE_NAME

//
//  The Devicename string required to access the exchange IFS device 
//  from User-Mode. Clients should use DD_EXIFS_USERMODE_DEV_NAME_U.
//
//  WARNING The next two strings must be kept in sync. Change one and you must 
//  change the other. These strings have been chosen such that they are 
//  unlikely to coincide with names of other drivers.
//
//  NOTE: These definitions MUST be synced with <ifsuser.h>
//
#ifdef LOCALSTORE
#define DD_EXIFS_USERMODE_SHADOW_DEV_NAME_U     DD_LSIFS_USERMODE_SHADOW_DEV_NAME_U
#define DD_EXIFS_USERMODE_DEV_NAME_U            DD_LSIFS_USERMODE_DEV_NAME_U
#else  // PLATINUM
#define DD_EXIFS_USERMODE_SHADOW_DEV_NAME_U     L"\\??\\ExchangeIfs"
#define DD_EXIFS_USERMODE_DEV_NAME_U            L"\\\\.\\ExchangeIfs"
#endif // PLATINUM
#define DD_EXIFS_USERMODE_WIN9X_DRIVER_NAME     "M:\EA"

//
//  Prefix needed before <store-name>\<root-name>
//
#define DD_EXIFS_MINIRDR_PREFIX                 L"\\;E:"
#define DD_EXIFS_MINIRDR_PREFIX_LEN             (sizeof(DD_EXIFS_MINIRDR_PREFIX)-2)

#define DD_EXIFS_MINIRDR_PREFIX_PRIVATE         L"\\;F:"
#define DD_EXIFS_MINIRDR_PREFIX_SPECIAL         L"\\;G:"

#endif // EXIFS_DEVICE_NAME



#define RDBSS_DRIVER_LOAD_STRING L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Rdbss"
#define STRING_MISC_POOLTAG      ('Strg')

#ifdef LOCALSTORE
#define DD_PUBLIC_MDB_SHARE             DD_PUBLIC_MDB_SHARE_LSIFS
#else  // PLATINUM
#define DD_PUBLIC_MDB_SHARE             L"\\??\\BackOfficeStorage"
#endif // PLATINUM

#define DD_MDB_SHARE_PREFIX             L"\\??\\"

#define SYSTEM_PARAMETERS L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion"

#define IFS_DEFAULT_TEMP_DIR   L"\\??\\C:\\temp\\"
#define IFS_TEMP_DIR_PREFIX    L"\\??\\"
#define IFS_TEMP_DIR_POSTFIX   L"\\"


//
// BEGIN WARNING WARNING WARNING WARNING
//  The following are from the ddk include files and cannot be changed

#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014 // from ddk\inc\ntddk.h
#define METHOD_BUFFERED 0
#define FILE_ANY_ACCESS 0

// END WARNING WARNING WARNING WARNING

#define IOCTL_EXIFS_BASE FILE_DEVICE_NETWORK_FILE_SYSTEM

//
//  This is a reserved net root name for use by the global UMR.
//
#define DD_EXUMR_NETROOT_NAME     L"\\UMR\\CONTROL"
#define DD_EXUMR_ROOT_DIR         DD_EXIFS_MINIRDR_PREFIX \
								  DD_EXUMR_NETROOT_NAME \
								  L"\\$ROOT_DIR"

#define _EXIFS_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_EXIFS_BASE, request, method, access)

//
//  Signatures of structs
//

#define SCATTER_LIST_SIGNATURE              (ULONG) 'rtcS'
#define IOCTL_INITROOT_IN_SIGNATURE         (ULONG) 'Itri'
#define IOCTL_SPACEGRANT_IN_SIGNATURE       (ULONG) 'Icps'
#define IOCTL_TERMROOT_IN_SIGNATURE         (ULONG) 'Itrt'
#define IOCTL_QUERYROOT_OUT_SIGNATURE       (ULONG) 'Otrq'
#define IOCTL_QUERYSTATS_IN_SIGNATURE       (ULONG) 'IyrQ'
#define IOCTL_QUERYSTATS_OUT_SIGNATURE      (ULONG) 'OyrQ'
#define IOCTL_SETENDOFFILE_IN_SIGNATURE     (ULONG) 'IfoE'
#define IOCTL_ENABLE_UMR_ROOT_IN_SIGNATURE  (ULONG) 'rmUE'
#define IOCTL_DIR_CHNG_REPORT_IN_SIGNATURE  (ULONG) 'CriD'
#define IOCTL_EXPUNGE_NAME_IN_SIGNATURE     (ULONG) 'ExNi'
#define IOCTL_EXPUNGE_NAME_OUT_SIGNATURE    (ULONG) 'ExNo'
#define IOCTL_EXIFS_UMRX_ENABLE_NET_ROOT_OUT_SIGNATURE  (ULONG) 'banE'

//
//  Data Str shared between user-mode clients like the exchange store
//  and Exchange IFS driver.
//

#define MAX_FRAGMENTS       (ULONG) 8

//
//  This limits the size that the scatter list portion of an EA can be.
//  896 entires will take 896*16=>14336 bytes.
//  In a 16K request buffer, this leaves about 2k for the other portion of
//    the EA of which the filename is the only other variable component.
//

#define MAX_TOTAL_SLIST_FRAGMENTS    (ULONG) 896

//
//  If MAX_CONSTANT_ALLOCATIONS have been made in a file, IFS will increase 
//  the allocation assuming that future constant requests will be made.
//
#define MAX_CONSTANT_ALLOCATIONS     (1024*4)

//
//  A SCATTER_LIST_ENTRY represents a single fragment in a scatter list.
//  All offsets are with respect to the underlying NTFS file for a given
//  root. If this file is opened with FILE_FLAG_NO_BUFFERING, the
//  following assertions must hold:
//
//  1. offsets must be integer multiples of the volume's sector size
//  2. lengths must be integer multiples of the volume's sector size
//
//  Checked builds of the driver will ASSERT if these do not hold
//
//  NOTE: Since the Offset is a multiple of the sector size which is
//  typically 512, the least significant 8 bits are unused. These bits
//  can be used for specifying flags on SLE state eg dirty/committed.
//  CAUTION: Any use of these bits should be transparent to IFS clients !
//
typedef struct _SCATTER_LIST_ENTRY_ 
{
    //
    //  64-bit offset to fragment data
    //
    LARGE_INTEGER   Offset;

    //
    //  length of fragment data
    //
    ULONG           Length;

    //
    //  reserved
    //
    ULONG           ulReserved;

} SCATTER_LIST_ENTRY, *PSCATTER_LIST_ENTRY;

//
//  Bit masks for SLE properties
//
#define RX_SLE_STATE_DIRTY      0x00000001

#define RX_SLE_STATE_MASK       0xFFFFFFFFFFFFFF00

#define RX_LONGLONG(x)          (x).QuadPart
#define RX_MASKED_LONGLONG(x)   ((x).QuadPart & RX_SLE_STATE_MASK)

//
//  SCATTER_LIST represents the scatter list. The array of fragments,          
//  sle, should in most cases be enough to describe data for a single 
//  IFS file. In extreme cases (eg very large messages), the overflow 
//  list should be used. This will ensure good page locality in the 
//  most common case, since this data is stored in the FCB extension.
//
//  If NumFragments is <= MAX_FRAGMENTS, overflow should be NULL.
//  If NumFragments is > MAX_FRAGMENTS, overflow should be non-NULL and
//  should "point" to (NumFragments - MAX_FRAGMENTS) number of
//  SCATTER_LIST_ENTRY's.
//
//  NOTE: Apps need to set OverflowOffset (relative to start
//  of struct) of the overflow fragments. The IFS uses it to point
//  to a list of overflow fragments in kernel space.
//
typedef struct _SCATTER_LIST_
{
    //
    //  signature for this struct
    //
    ULONG           Signature;

    //
    //  number of fragments in scatter list
    //
    ULONG           NumFragments;

    //
    //  TotalBytes ie. valid byte range
    //  NB: used only when scatter-list is available
    //  at create time. should *not* be used for GetFileSize()..
    //
    LARGE_INTEGER   TotalBytes;

    //
    //  array of scatter-list-entries
    //
    SCATTER_LIST_ENTRY sle[MAX_FRAGMENTS];

    //
    //  ptr to overflow list
    //

    //
    //  ptr to overflow list
    //
    union {
        struct {
            //
            //  offset to overflow frags
            //
            ULONG       OverflowOffset;

            //
            //  len of overflow data
            //
            ULONG       OverflowLen;
        };  // user-mode representation

        union {
            //
            //  list of overflow frags
            //
            LIST_ENTRY  OverflowListHead;

            //
            //  pointer to object containing overflow frags
            //
            PVOID       OverflowFragments;
        };  //  kernel-mode representation
    };

	//
	//  Flags for properties of the scatter-list
	//
	ULONG       Flags;

} SCATTER_LIST, *PSCATTER_LIST;

#define     IFS_SLIST_FLAGS_LARGE_BUFFER        0x00000001

//
//  Linked list of scatter-list entries
//
typedef struct _SCATTER_LIST_NODE {
    //
    //  Scatter-List entry
    //
    SCATTER_LIST_ENTRY      Block;

    //
    //  Doubly linked list of blocks
    //
    LIST_ENTRY              NextBlock;

} SCATTER_LIST_NODE, *PSCATTER_LIST_NODE;

#define SCATTER_LIST_CONTAINING_RECORD( x )     CONTAINING_RECORD( x, SCATTER_LIST_NODE, NextBlock )

//
//  IFS file extended attributes -
//  NtQueryEaFile() will return the extended attributes
//  for an IFS file. Currently, the following extended attributes
//  are supported (in order) - 
//
//  1. "FileName"       - WCHAR  : name of IFS file (NULL terminated)
//  2. "Commit"         - NTSTATUS: STATUS_SUCCESS if committed
//  3. "InstanceID"     - ULONG  : NET_ROOT ID for validation
//  4. "Checksum"       - ULONG  : checksum for FILE_FULL_EA_INFORMATION
//  5. "OpenDeadline"   - ULONG  : time for which ScatterList is valid
//  6. "Properties"     - ULONG  : persisted message properties
//  7. "ScatterList"    -        : scatter list for an IFS file
//
//  IFS will return values for all attributes in one call.
//  Each of the EA values will be QWORD Aligned.
//  If the Buffer supplied is not big enough, IFS will
//  return STATUS_BUFFER_OVERFLOW.
//
//  NOTE: The "Commit" EA is not actually stored. Callers of
//  NtQueryEaFile() can ask for this EA in the EaList param.
//  QUERYING FOR THIS EA IS AN IMPLICIT REQUEST TO COMMIT
//  RESERVED BYTES FOR THIS IFS HANDLE.....!
//
//  NtQueryEa() can (optionally) pass in a value for the "Properties" EA
//
//  NtCreateFile() notes:
//  This API will use all EAs except the "FileName". Semantics:
//  "Commit" - STATUS_SUCESSS => Bytes are committed, dont reuse on close.
//  "InstanceID" - used to validate handles belonging to a particular
//      instance of a root.
//  "Checksum" - validate checksum on EA list.
//  "OpenDeadline" - validate time deadline on scatter-list. If the
//      time deadline has expired, owner of root may reuse this list.
//  "Properties" - is set in the FCB extension
//  "ScatterList" - describes pages for file being created.

#define EXIFS_EA_NAME_COMMIT            "Commit"
#define EXIFS_EA_NAME_INSTANCE_ID       "InstanceID"
#define EXIFS_EA_NAME_CHECKSUM          "Checksum"
#define EXIFS_EA_NAME_OPEN_DEADLINE     "OpenDeadline"
#define EXIFS_EA_NAME_PROPERTIES        "Properties"
#define EXIFS_EA_NAME_FILENAME          "FileName"
#define EXIFS_EA_NAME_SCATTER_LIST      "ScatterList"
#define EXIFS_MAX_EAS                   7
#define EXIFS_CHECKSUM_SEED             0xFEEDFEED

#define EXIFS_INVALID_INSTANCE_ID       0xFFFFFFFF

#ifndef LongAlign
#define LongAlign(Ptr) (                \
    ((((ULONG_PTR)(Ptr)) + 3) & 0xfffffffc) \
    )
#endif

#define EXIFS_EA_LEN_COMMIT                                                 \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_COMMIT) + sizeof(ULONG))            

#define EXIFS_EA_LEN_INSTANCE_ID                                            \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_INSTANCE_ID) + sizeof(ULONG))            

#define EXIFS_EA_LEN_CHECKSUM                                               \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_CHECKSUM) + sizeof(ULONG))          

#define EXIFS_EA_LEN_OPEN_DEADLINE                                          \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_OPEN_DEADLINE) + sizeof(ULONG))     

#define EXIFS_EA_LEN_PROPERTIES                                             \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_PROPERTIES) + sizeof(ULONG))     

#define EXIFS_EA_LEN_FILENAME(len)                                          \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_FILENAME) + LongAlign(len))         

#define EXIFS_EA_LEN_SCATTER_LIST(n)                                        \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_SCATTER_LIST) +                                \
        LongAlign(sizeof(SCATTER_LIST) +                                    \
        ((n)>MAX_FRAGMENTS?(n)-MAX_FRAGMENTS:0)*sizeof(SCATTER_LIST_ENTRY)))

#define EXIFS_GET_EA_LEN_COMMIT                                             \
        LongAlign(FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0] ) +      \
        sizeof(EXIFS_EA_NAME_COMMIT))            

#define EXIFS_GET_EA_LEN_INSTANCE_ID                                        \
        LongAlign(FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0] ) +      \
        sizeof(EXIFS_EA_NAME_INSTANCE_ID))            

#define EXIFS_GET_EA_LEN_PROPERTIES                                         \
        LongAlign(FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0] ) +      \
        sizeof(EXIFS_EA_NAME_PROPERTIES))            

//
//  IOCTL codes supported by Exchange IFS Device.
//

#define IOCTL_CODE_INITIALIZE_ROOT      100
#define IOCTL_CODE_SPACEGRANT_ROOT      101
#define IOCTL_CODE_SPACEREQ_ROOT        102
#define IOCTL_CODE_TERMINATE_ROOT       103
#define IOCTL_CODE_QUERYSTATS_ROOT      104
#define IOCTL_CODE_SETENDOFFILE_ROOT    105
#define IOCTL_CODE_DIR_CHNG_REPORT      106
#define IOCTL_CODE_INITDRIVE		    107
#define IOCTL_CODE_EXPUNGE_NAME         108
#define IOCTL_CODE_SETMAP_ROOT          109
#define IOCTL_CODE_RESETMAP_ROOT        110

//
//  WIN32 IOCTL codes
//
#define IOCTL_CODE_UMRX_PACKET           150
#define IOCTL_CODE_UMRX_TEARDOWN         151
#define IOCTL_CODE_UMRX_STARTUP          152
#define IOCTL_CODE_UMRX_ENABLE_NET_ROOT  153
#define IOCTL_CODE_UMRX_DISABLE_NET_ROOT 154


//suspend and resume IOCTLS
#define IOCTL_EXIFS_SETMAP_ROOT     _EXIFS_CONTROL_CODE(IOCTL_CODE_SETMAP_ROOT, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_EXIFS_RESETMAP_ROOT   _EXIFS_CONTROL_CODE(IOCTL_CODE_RESETMAP_ROOT, METHOD_NEITHER, FILE_ANY_ACCESS)

//
//  Semantics for using an IFS root:
//  1. App gets a handle (exclusive) to the root via 
//     CreateFile(\Device\ExchangeIfsDevice\{NodeName}\{RootName}).
//     This handle should be opened for overlapped I/O.
//
//  2. App calls overlapped DeviceIoControl() with INITIALIZE_ROOT IOCTL.
//
//  3. This will succeed or fail synchronously. If DeviceIoControl()
//     returns TRUE, it succeeded. If it returns FALSE, GetLastError() or
//     the NTSTATUS from NtDeviceIoControl() is the error code.
//     NOTE: If this IOCTL has NOT been made on a root successfully,
//     no I/O on this root will succeed.
//
//  3. At this point, the IFS root has no space grants.
//     It is expected that the app will make one or more SPACEGRANT_ROOT
//     IOCTLs to grant space on this root. Each of these IOCTLs will finish
//     synchronously and return semantics are similar to INITIALIZE_ROOT.
//
//  4. An app should also pend an async SPACEREQ_ROOT IOCTL. Usually, this
//     will return with ERROR_IO_PENDING. If this later completes with
//     NTSTATUS == EXSTATUS_ROOT_NEEDS_SPACE, the app should make a space
//     grant (SPACEGRANT_ROOT) and pend another SPACEREQ_ROOT. This will 
//     happen if IFS runs out of free space blocks on this root. If the IOCTL
//     completes with STATUS_SUCCESS, app should NOT pend another IOCTL.
//
//  5. App calls overlapped DeviceIoControl() with TERMINATE_ROOT IOCTL.
//     This will complete any async pended IOCTLs. After this call, the root 
//     starts shutting down. This IOCTL will complete synchronously.
//     NOTE: Once terminated, a root cannot be initialized again.
//
//  6. App closes handle to root. Note: Handle to root needs to be kept
//     open across life of root. Once the root handle is closed, the IFS
//     root has no free space. All of the free space allocated to the 
//     root before TERMINATE needs to be reclaimed by the app.
//     The app can now re-create this root starting at step1.
//
//  7. If the app with an exclusive handle to a root dies, the root will
//     be marked 'bad' and new I/Os (including IOCTLs) to this root will
//     fail. Over time, outstanding handles on this root will go away and
//     eventually the root will die. At this point, an app can re-create
//     the root starting at step 1.
//

//
//  IOCTL to initialize a net root. This results in creating an entry
//  in the RootMapTable. There is one entry in this table for every
//  secondary NTFS file managed by the IFS driver.
//  NOTE: IFS will attempt to get an exclusive handle to the underlying
//  file. This ensures that all operations on the underlying file are
//  done through IFS.
//
//  Following is the IOCTL definition and associated structs.
//
#define IOCTL_EXIFS_INITIALIZE_ROOT     _EXIFS_CONTROL_CODE(IOCTL_CODE_INITIALIZE_ROOT, METHOD_NEITHER, FILE_ANY_ACCESS)

//
//  InBuffer struct
//
typedef struct _IOCTL_INITROOT_IN
{
    //
    //  Signature for this struct
    //
    ULONG           Signature;

    //
    //  Underlying Ntfs filename for this root.
    //  Length is the size in bytes of the name.
    //  Offset should be from the start of this struct.
    //
    USHORT          NtfsFileNameLength;
    USHORT          NtfsFileNameOffset;

    //
    //  Flags to control access to Ntfs file
    //
    ULONG           NtfsFlags;

    //
    //  Allocation unit for this root. Min is 4K
    //
    ULONG           AllocationUnit;

    //
    //  root InstanceID
    //
    ULONG           InstanceID;
    
} IOCTL_INITROOT_IN, *PIOCTL_INITROOT_IN;

typedef struct _IOCTL_INITROOT_IN_EX
{
	IOCTL_INITROOT_IN InitRoot;
	WCHAR			RootName[MAX_PATH];
}IOCTL_INITROOT_IN_EX, *PIOCTL_INITROOT_IN_EX;


//
//  IOCTL to grant space to an initialized net root. 
//  Following is the IOCTL definition and associated structs.
//
#define IOCTL_EXIFS_SPACEGRANT_ROOT     _EXIFS_CONTROL_CODE(IOCTL_CODE_SPACEGRANT_ROOT, METHOD_NEITHER, FILE_ANY_ACCESS)

//
//  Free space is granted in chunks. The root owner decides
//  what the maximum chunk size is.
//
#define MAX_EXIFS_FREEBLOCK_SIZE        0x100000

//
//  Default chunk size
//
#define EXIFS_DEFAULT_CHUNK_SIZE        0x40000

//
//  MAXIMUM file size allowed by IFS
//
#define EXIFS_MAXIMUM_FILESIZE          0x7FFFFFFF

//
//  InBuffer struct
//
typedef struct _IOCTL_SPACEGRANT_IN
{
    //
    //  Signature for this struct
    //
    ULONG           Signature;

    //
    //  Scatter-list of free space - must be last
    //
    SCATTER_LIST    FreeSpaceList;


} IOCTL_SPACEGRANT_IN, *PIOCTL_SPACEGRANT_IN;

typedef struct _IOCTL_SPACEGRANT_IN_EX
{
    //
    //  Signature for this struct
    //
    ULONG           Signature;


	WCHAR			RootName[MAX_PATH];

    SCATTER_LIST    *W9xFreeSpaceList;

} IOCTL_SPACEGRANT_IN_EX, *PIOCTL_SPACEGRANT_IN_EX;

//
//  IOCTL to allow IFS to request space on an initialized net root.
//  Following is the IOCTL definition and associated structs.
//
#define IOCTL_EXIFS_SPACEREQ_ROOT     _EXIFS_CONTROL_CODE(IOCTL_CODE_SPACEREQ_ROOT, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct _IOCTL_SPACEREQ_ROOT_IN
{
	WCHAR RootName[MAX_PATH];
}IOCTL_SPACEREQ_ROOT_IN, *PIOCTL_SPACEREQ_ROOT_IN;

//
//  IOCTL to terminate a net root. This results in deleting an entry
//  in the RootMapTable. There is one entry in this table for every
//  secondary NTFS file managed by the IFS driver. Following is the IOCTL
//  definition and associated structs.
//
#define IOCTL_EXIFS_TERMINATE_ROOT      _EXIFS_CONTROL_CODE(IOCTL_CODE_TERMINATE_ROOT, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  InBuffer struct
//
typedef struct _IOCTL_TERMROOT_IN
{
    //
    //  Signature for this struct
    //
    ULONG           Signature;

    //
    //  Mode of shutdown
    //
    ULONG           Mode;

} IOCTL_TERMROOT_IN, *PIOCTL_TERMROOT_IN;

typedef struct _IOCTL_TERMROOT_IN_EX
{
	IOCTL_TERMROOT_IN	TermRoot;
	WCHAR			RootName[MAX_PATH];
} IOCTL_TERMROOT_IN_EX, *PIOCTL_TERMROOT_IN_EX;

#if 0
//
//  IOCTL to query a net root for current free space. Currently, NYI.
//  The goal for this is to allow app to retrieve fragmented free lists
//  in order to defrag.
//  Following is the IOCTL definition and associated structs.
//
#define IOCTL_EXIFS_QUERY_ROOT      _EXIFS_CONTROL_CODE(IOCTL_CODE_QUERY_ROOT, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  OutBuffer struct
//
typedef struct _IOCTL_QUERYROOT_OUT
{
    //
    //  Signature for this struct
    //
    ULONG           Signature;

    //
    //  Return code
    //
    NTSTATUS        IoctlStatus;

    //
    //  Free space list for this root
    //
    SCATTER_LIST    FreeSpaceList;

} IOCTL_QUERYROOT_OUT, *PIOCTL_QUERYROOT_OUT;
#endif

//
//  IOCTL to query stats for a net root.
//
#define IOCTL_EXIFS_QUERYSTATS_ROOT     _EXIFS_CONTROL_CODE(IOCTL_CODE_QUERYSTATS_ROOT, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_QUERYSTATS_FILENAME       L"\\$PERFMON$"

//
//  Statistics for a net root
//
typedef struct _EXIFS_NETROOT_STATS {
    //
    //  Number of Creates
    //
    ULONG           NumberOfCreates;

    //
    //  Number of Opens
    //
    ULONG           NumberOfOpens;

    //
    //  Number of Collapsed Opens
    //
    ULONG           NumberOfCollapsedOpens;

    //
    //  Number of IRP Reads
    //
    ULONG           NumberOfIrpReads;

    //
    //  Number of MDL Reads
    //
    ULONG           NumberOfMdlReads;
    
    //
    //  Number of Writes
    //
    ULONG           NumberOfWrites;

    //
    //  Number of Close
    //
    ULONG           NumberOfClose;

    //
    //  Number of FCB close
    //
    ULONG           NumberOfFCBClose;

    //
    //  Total Bytes Read
    //
    LARGE_INTEGER   TotalBytesRead;

    //
    //  Total Bytes Written
    //
    LARGE_INTEGER   TotalBytesWritten;

    //
    //  Reserved Bytes ie on primary free list
    //
    LARGE_INTEGER   ReservedBytes;
    
    //
    //  Orphaned Bytes ie on secondary free list
    //  Total Available Bytes = ReservedBytes + OrphanedBytes
    //
    LARGE_INTEGER   OrphanedBytes;

} EXIFS_NETROOT_STATS, *PEXIFS_NETROOT_STATS;

//
//  Cheap stats do not cause locks to be acquired. 
//  Other modes may need locks.
//
#define     EXIFS_QUERYSTATS_CHEAP      1
#define     EXIFS_QUERYSTATS_MEDIUM     2
#define     EXIFS_QUERYSTATS_ALL        3

//
//  InBuffer struct
//
typedef struct _IOCTL_QUERYSTATS_IN
{
    //
    //  Signature for this struct
    //
    ULONG               Signature;

    //
    //  Granularity of stats
    //
    ULONG               Granularity;

	WCHAR			RootName[MAX_PATH];

} IOCTL_QUERYSTATS_IN, *PIOCTL_QUERYSTATS_IN;

//
//  OutBuffer struct
//
typedef struct _IOCTL_QUERYSTATS_OUT
{
    //
    //  Signature for this struct
    //
    ULONG               Signature;

    //
    //  Return code
    //
    NTSTATUS            IoctlStatus;

    //
    //  Stats data
    //
    EXIFS_NETROOT_STATS RootStats;


} IOCTL_QUERYSTATS_OUT, *PIOCTL_QUERYSTATS_OUT;

//
//  IOCTL to set end of file (truncate or extend) for root underlying file.
//  It is callers responsibility to zero extended length when extending.
//
#define IOCTL_EXIFS_SETENDOFFILE_ROOT       _EXIFS_CONTROL_CODE(IOCTL_CODE_SETENDOFFILE_ROOT, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  InBuffer struct
//
typedef struct _IOCTL_SETENDOFFILE_IN
{
    //
    //  Signature for this struct
    //
    ULONG               Signature;

    //
    //  New EOF
    //
    LARGE_INTEGER       EndOfFile;

} IOCTL_SETENDOFFILE_IN, *PIOCTL_SETENDOFFILE_IN;

typedef struct _IOCTL_SETENDOFFILE_IN_EX
{

	IOCTL_SETENDOFFILE_IN	SetEndOfFile;
	WCHAR			RootName[MAX_PATH];

} IOCTL_SETENDOFFILE_IN_EX, *PIOCTL_SETENDOFFILE_IN_EX;

//
// IOCTL to send down reports about changes in directories that exifs.sys doesn't
//    know about.
//
#define IOCTL_EXIFS_DIR_CHNG_REPORT _EXIFS_CONTROL_CODE(IOCTL_CODE_DIR_CHNG_REPORT, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  InBuffer struct
//
typedef struct _IOCTL_DIR_CHNG_REPORT_IN
{
    //
    //  Signature for this struct
    //
    ULONG               Signature;

	//
	//  Action
	//
	ULONG               ulAction;

	//
	//  FilterMatch
	//
	ULONG               ulFilterMatch;
	
	//
	//  Path length (bytes)
	//
    ULONG               cbPath;

	//
	//  Path (unicode)
	//
    WCHAR               rgwchPath[1];

} IOCTL_DIR_CHNG_REPORT_IN, *PIOCTL_DIR_CHNG_REPORT_IN;

//
// IOCTL to send request to close and unlock namespace
//
#define IOCTL_EXIFS_EXPUNGE_NAME    _EXIFS_CONTROL_CODE( IOCTL_CODE_EXPUNGE_NAME, METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// InBuffer struct
//
typedef struct _IOCTL_EXPUNGE_NAME_IN
{
    //
    // Signature for this struct
    //
    ULONG       Signature;

    //
	//  Path length (bytes)
	//
    ULONG       cbPath;

	//
	//  Path (unicode)
	//
    WCHAR       rgwchPath[ 1 ];

}   IOCTL_EXPUNGE_NAME_IN, *PIOCTL_EXPUNGE_NAME_IN;

//
// OutBuffer struct
//
typedef struct _IOCTL_EXPUNGE_NAME_OUT
{
    //
    // Signature for this struct
    //
    ULONG       Signature;

    //
    // Status of operation
    //
    NTSTATUS    Status;
    
}   IOCTL_EXPUNGE_NAME_OUT, *PIOCTL_EXPUNGE_NAME_OUT;

//
//  IOCTLs for UMR piece -
//  1. UMRX_PACKET IOCTLs will be pended for WORK requests/responses. These
//     need to be pended on the Root\WIN32ROOT\$ namespace. The net root
//     needs to have been initialized already.
//
//  2. TEARDOWN IOCTL will be sent when the UMR engine on the root needs to
//     be shutdown. This should be done before the root is terminated.
//     NOTE: process shutdown is auto-detected by the UMR engine.
//
//  3. STARTUP IOCTL will allow worker threads to queue up on the UMRX's KQUEUE
//     It complements the TEARDOWN IOCTL
//
//  4. ENABLE_NET_ROOT IOCTL allows win32 usermode requests to be made from the
//     netroot that this ioctl is being done on.
//  
//  5. DISABLE_NET_ROOT IOCTL disallows win32 usermode requests to be made form the
//     newroot that this ioctl is done on.  Once the call to DeviceIoControl() returns
//     there will be no more user mode requests made on that net root.
//

#define IOCTL_EXIFS_UMRX_PACKET           _EXIFS_CONTROL_CODE(IOCTL_CODE_UMRX_PACKET, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EXIFS_UMRX_TEARDOWN         _EXIFS_CONTROL_CODE(IOCTL_CODE_UMRX_TEARDOWN, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EXIFS_UMRX_STARTUP          _EXIFS_CONTROL_CODE(IOCTL_CODE_UMRX_STARTUP, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  When enabling NetRoot's we get the current version number the netroot has squirreled away from when Jet initialized it !
//
#define IOCTL_EXIFS_UMRX_ENABLE_NET_ROOT  _EXIFS_CONTROL_CODE(IOCTL_CODE_UMRX_ENABLE_NET_ROOT, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct  _IOCTL_EXIFS_UMRX_ENABLE_NET_ROOT_OUT
{
    //
    //  Signature for this structre !
    //
    ULONG           Signature ;
    //
    //  Version of the netroot that should, be put in future open requests !
    //
    ULONG           InstanceId ;
    //
    //  Pointer to the netroot that should be put in future open responses !
    //
    ULONG           NetRootPointer ;
    //
    // Save jets allocation size
    //
    ULONG			AllocationUnit;
}   IOCTL_EXIFS_UMRX_ENABLE_NET_ROOT_OUT, *PIOCTL_EXIFS_UMRX_ENABLE_NET_ROOT_OUT ;


#define IOCTL_EXIFS_UMRX_DISABLE_NET_ROOT _EXIFS_CONTROL_CODE(IOCTL_CODE_UMRX_DISABLE_NET_ROOT, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  IMPORTANT NOTE : 
//
//  IOCTL_WIN32_FILENAME is EXACTLY 8 characters long because we will OVERWRITE 
//  it in the filenames that we put in the FCB.  We will replace the 'IN32ROOT' 
//  portion with the hexadecimal version id coming off of the netroot for the 
//  particular file.
//  Why ? Because this will cause dead FCB's to not hurt users across MDB Start/Stops
//
#define IOCTL_WIN32_FILENAME_START  L"\\W" 
#define IOCTL_WIN32_FILENAME        L"\\WIN32ROOT"
#define WIN32_PREFIX_LEN            (sizeof(IOCTL_WIN32_FILENAME)-sizeof(WCHAR))
#define WIN32_DIGIT_LEN             (sizeof(IOCTL_WIN32_FILENAME) - sizeof(IOCTL_WIN32_FILENAME_START))
#define IOCTL_WIN32_UMRX_NAME       L"\\WIN32ROOT\\$"
#define UMRX_PREFIX_LEN             (sizeof(IOCTL_WIN32_UMRX_NAME)-2)

#define IFSWIN32SIGNATURE	'WIN3'
#define IFSJETSIGNATURE		'AJET'

typedef struct _IFS_CREATE_RESPONSE_
{
	DWORD		Signature;
	NTSTATUS	Status;
	ULONG		EaLength;
	HANDLE      hResponseContext;
	PWSTR		pEaSysBuffer;
	PWSTR		Win32Name;
}IFS_CREATE_RESPONSE, *PIFS_CREATE_RESPONSE;

#define IOCTL_EXIFS_REGISTER_UMR		200

typedef struct _SETEA_INFORMATION_
{
	PVOID	EaBuffer;
	ULONG   EaLength;
	WCHAR	FcbName[MAX_PATH * sizeof(WCHAR)];
}IOCTL_SETEA_INFORMATION_IN, *PIOCTL_SETEA_INFORMATION_IN;

#define IOCTL_CODE_SET_EA			900
#define IOCTL_EXIFS_SET_EA   _EXIFS_CONTROL_CODE(IOCTL_CODE_SET_EA, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _GETEA_INFORMATION_
{
	PVOID	EaBuffer;
	ULONG   EaLength;
	WCHAR	FcbName[MAX_PATH];
}IOCTL_GETEA_INFORMATION_IN, *PIOCTL_GETEA_INFORMATION_IN;

#define IOCTL_CODE_QUERY_EA			1000
#define IOCTL_EXIFS_QUERY_EA   _EXIFS_CONTROL_CODE(IOCTL_CODE_QUERY_EA, METHOD_BUFFERED, FILE_ANY_ACCESS)


#endif // _EXIFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\eximport\ifsuser.h ===
/*++

Copyright (c) 1989 - 1998 Microsoft Corporation

Module Name:

    ifsuser.h

Abstract:

    Ifsuser is a static lib that wraps a bunch of user-mode code
    needed for using the IFS. It is not necessary to use the APIs
    in this lib for availing the IFS functionality. However, using
    it will isolate clients from changes to IFS headers / data str.

    Applications that do not want to use NtXXX APIs should include
    this header file.

    Applications that directly use NtXXX APIs only need <exifs.h>
    
Author:

    Rajeev Rajan      [RajeevR]      7-Apr-1998

Revision History:

--*/

#ifndef _IFSUSER_H_
#define _IFSUSER_H_

#ifdef	__cplusplus	
extern	"C"	{
#endif

#ifndef EXIFS_DEVICE_NAME
#define EXIFS_DEVICE_NAME

//////////////////////////////////////////////////////////////////////////////
//  The Devicename string required to access the exchange IFS device 
//	from User-Mode. Clients should use DD_EXIFS_USERMODE_DEV_NAME_U.
//////////////////////////////////////////////////////////////////////////////

// Local store Device names
#define DD_LSIFS_USERMODE_SHADOW_DEV_NAME_U	    L"\\??\\LocalStoreIfs"
#define DD_LSIFS_USERMODE_DEV_NAME_U            L"\\\\.\\LocalStoreIfs"

//
//  WARNING The next two strings must be kept in sync. Change one and you must 
//	change the other. These strings have been chosen such that they are 
//	unlikely to coincide with names of other drivers.
//
//   NOTE: These definitions MUST be synced with <exifs.h>
//
#define DD_EXIFS_USERMODE_SHADOW_DEV_NAME_U	    L"\\??\\ExchangeIfs"
#define DD_EXIFS_USERMODE_DEV_NAME_U			L"\\\\.\\ExchangeIfs"

//
//	Prefix needed before <store-name>\<root-name>
//
#define DD_EXIFS_MINIRDR_PREFIX			        L"\\;E:"

#endif // EXIFS_DEVICE_NAME

//
//	Bit flags for PR_DOTSTUFF_STATE
//
//      DOTSTUFF_STATE_HAS_BEEN_SCANNED - Has the content been scanned?
//      DOTSTUFF_STATE_NEEDS_STUFFING   - If it has been scanned does
//          it need to be dot stuffed?
#define DOTSTUFF_STATE_HAS_BEEN_SCANNED         0x1
#define DOTSTUFF_STATE_NEEDS_STUFFING           0x2

//////////////////////////////////////////////////////////////////////////////
//  LIST OF FUNCTIONS EXPORTED
//
//  INBOUND =>
//  ==========
//  1. IfsInitializeWrapper() :initializes a seed eg GUID for unique filenames.
//  2. IfsTerminateWrapper()  :cleanup if necessary.
// *3. IfsCreateNewFileW()    :given store prefix, return a HANDLE that can be
//                             used for storing data in that store.
//  4. IfsCacheInsertFile()   :given an EA, insert filename in FH cache.
//  4. IfsMarshallHandle()    :given an IFS handle, will return context that
//                             will aid in manifesting a new HANDLE in a 
//                             different process.
// *5. IfsUnMarshallHandle()  :given context from previous function, this will
//                             manifest a new HANDLE in current process.
//                             
//  OUTBOUND =>
//  ===========
// *1. IfsCacheCreateFile()   :given an EA, get a file handle from the FH cache.
//                             if the file handle is not in FH cache, it will be
//                             created and inserted in FH cache.
// *2. IfsCreateFile()        :given an EA, merely create a file handle -
//                             no FH cache insert/search.
// *3. IfsCreateFileRelative():given an EA, merely create a file handle -
//                             no FH cache insert/search - relative open
//
//  *NOTE: Functions with an asterisk next to them return file HANDLES.
//  It is expected that the caller will close these handles at an appropriate time !
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  INBOUND functions
//////////////////////////////////////////////////////////////////////////////

//
//  This function sets up a seed GUID to aid generation of unique names !
//

BOOL __fastcall
IfsInitializeWrapper();

//
//  This function cleans up any state setup in Init()
//

VOID __fastcall
IfsTerminateWrapper();

//
//  Create a new IFS handle given a store prefix -
//  The handle is opened for read/write. Caller should close 
//  handle after use. Closing the handle without committing the
//  bytes (via NtQueryEa) will cause the bytes to be reused by IFS.
//
//  NB: A fully qualified IFS filename is of the form:
//  "\\??\\ExchangeIfs\\;E:\\<store-name>\\<root-name>\\<filename>"
//  Typically, <store-name> is a constant for the machine, 
//             <root-name> is a function of a given MDB store and
//             <filename> is a specific message in the store
//
//  This functions expects the StorePrefix to be <store-name>\\<root-name>.
//  The function will generate a unique <filename>
//

DWORD __fastcall
IfsCreateNewFileW(
    IN      LPWSTR   StorePrefix,
    IN      DWORD    FlagsOverride,
    IN OUT  PHANDLE  phFile
    );

#ifdef _USE_FHCACHE_

//
//  Protocols should call this function to get an FIO_CONTEXT for
//  an inbound message. This replaces IfsCreateNewFileW() as the
//  preferred method of using the IFS/File Handle Cache.
//
FIO_CONTEXT*
IfsCreateInboundMessageFile(
    IN      LPWSTR  StorePrefix,
    IN      DWORD   FlagsOverride,
    IN      BOOL    fScanForDots = TRUE
);

FIO_CONTEXT*
IfsCreateInboundMessageFileEx(
    IN      LPWSTR  StorePrefix,
    IN      DWORD   FlagsOverride,
    IN      BOOL    fScanForDots = TRUE,
    IN      BOOL    fStoredWithTerminatingDot = FALSE
);

//
//  Given an FH cache FIO_CONTEXT and IFS EAs, insert file handle in
//  FH cache using filename !
//

BOOL
IfsCacheInsertFile(
    IN      FIO_CONTEXT* pContext,
    IN      PVOID        EaBuffer,
    IN      DWORD        EaLength,
    IN	    BOOL	     fKeepReference    
    );

//
//  Given an FH cache FIO_CONTEXT and IFS EAs, insert file handle in
//  FH cache using filename !
//  BINLIN - Caller of this function must ensure that EaBuffer has DotStuff state embedded!
//  This can be achieved by calling IfsMarshallStoreEA() and marshall the returned EA
//  buffer back to IIS, and use this EA buffer in IfsCacheInsertFileEx().
//

BOOL
IfsCacheInsertFileEx(
    IN      FIO_CONTEXT* pContext,
	IN		LPWSTR		 StorePrefix,
    IN      PVOID        EaBuffer,
    IN      DWORD        EaLength,
    IN	    BOOL	     fKeepReference    
    );

BOOL IfsCacheWriteFile(
    IN  PFIO_CONTEXT    pfioContext,
    IN  LPCVOID         lpBuffer,
    IN  DWORD           BytesToWrite,
    IN  FH_OVERLAPPED * lpo
    );

BOOL IfsCacheReadFile(
    IN  PFIO_CONTEXT    pfioContext,
    IN  LPCVOID         lpBuffer,
    IN  DWORD           BytesToRead,
    IN  FH_OVERLAPPED * lpo
    );   

DWORD IfsCacheGetFileSizeFromContext(
                        IN      FIO_CONTEXT*    pContext,
                        OUT     DWORD*                  pcbFileSizeHigh
                        );   

void IfsReleaseCacheContext( PFIO_CONTEXT    pContext );
    
#endif

//
//  Given an IFS handle, return context to be used by IfsUnMarshallHandle()
//  in order to manifest a handle in another process !
//  
//  fUseEA should be used to decide whether marshalling is done via EAs
//  or DuplicateHandle(). This function expects a buffer and buffer size.
//  If the function return ERROR_SUCCESS, *pcbContext == size of data
//  If the function returns ERROR_MORE_DATA, *pcbContext == size
//  expected. Caller should allocate this size and make the request again !
//

DWORD
IfsMarshallHandle(
    IN      HANDLE  hFile,              //  IFS file handle
    IN      BOOL    fUseEA,             //  If TRUE, use EA to marshall
    IN      HANDLE  hTargetProcess,     //  Handle to target process - optional
    IN OUT  PVOID   pbContext,          //  ptr to buffer for context
    IN OUT  PDWORD  pcbContext          //  IN - sizeof pbContext OUT - real size
    );

#ifdef _USE_FHCACHE_
//
//  This replaces IfsMarshallHandle() as the preferred way of marhalling
//  handles. The FIO_CONTEXT contains the IFS handle.
//
DWORD
IfsMarshallHandleEx(
    IN      FIO_CONTEXT*    pContext,   //  FH cache FIO_CONTEXT
    IN      BOOL    fUseEA,             //  If TRUE, use EA to marshall
    IN      HANDLE  hTargetProcess,     //  Handle to target process - optional
    IN OUT  PVOID   pbContext,          //  ptr to buffer for context
    IN OUT  PDWORD  pcbContext          //  IN - sizeof pbContext OUT - real size
    );
#endif

//
//  Give a context from IfsMarshallHandle(), return a handle usable in
//  current process !
//
//  Called in Store process only !
//  The HANDLE this returns will refer to an EA that has the DOT Stuff State embedded !
//

DWORD
IfsUnMarshallHandle(
    IN      LPWSTR  StorePrefix,
    IN      PVOID   pbContext,
    IN      DWORD   cbContext,
    IN OUT  PHANDLE phFile,
    OUT     PULONG  pulDotStuffState = NULL
    );
    
//////////////////////////////////////////////////////////////////////////////
//  OUTBOUND functions
//////////////////////////////////////////////////////////////////////////////

#ifdef _USE_FHCACHE_

//
//  Given an opaque EaBuffer and EaLength, return an FIO_CONTEXT from the 
//  File Handle Cache. Typically, used on outbound.
//

FIO_CONTEXT*
IfsCacheCreateFile(
    IN      LPWSTR  StorePrefix,
    IN      PVOID   EaBuffer,
    IN      DWORD   EaLength,
    IN      BOOL    fAsyncContext
    );
    
//
//  Given an opaque EaBuffer and EaLength, return an FIO_CONTEXT from the 
//  File Handle Cache. Typically, used on outbound.
//  This replaces IfsCacheCreateFile() as the preferred way to do outbound.
//  BINLIN - Caller of this function must ensure that EaBuffer has DotStuff state embedded.
//  This can be achieved by calling IfsMarshallStoreEA() and marshall the returned EA
//  buffer back to IIS, and use this EA buffer in IfsCacheInsertFileEx().
//

FIO_CONTEXT*
IfsCacheCreateFileEx(
    IN      LPWSTR  StorePrefix,
    IN      PVOID   EaBuffer,
    IN      DWORD   EaLength,
    IN      BOOL    fAsyncContext,
    IN      BOOL    fWantItStuffed
    );

#endif

//
//  Create an IFS handle given an EaBuffer and EaLength -
//  The handle is opened for read-only. EaBuffer can be freed
//  after this call. Caller should close handle after use.
//
//  NB: EaBuffer should have been obtained from a "trusted source"
//  ie. ESE or IFS.
//

DWORD
IfsCreateFileRelative(
    IN      HANDLE   hRoot,
    IN      PVOID    EaBuffer,
    IN      DWORD    EaLength,
    IN OUT  PHANDLE  phFile
    );

//
//  Create an IFS handle given an EaBuffer and EaLength -
//  The handle is opened for read-only. EaBuffer can be freed
//  after this call. Caller should close handle after use.
//
//  NB: EaBuffer should have been obtained from a "trusted source"
//  ie. ESE or IFS.
//

DWORD
IfsCreateFile(
	IN		LPWSTR	 StorePrefix,
    IN      PVOID    EaBuffer,
    IN      DWORD    EaLength,
    IN OUT  PHANDLE  phFile
    );


DWORD
IfsCreateFileEx(
	IN		LPWSTR	 StorePrefix,
	IN      PVOID    EaBuffer,
	IN      DWORD    EaLength,
	IN OUT  PHANDLE  phFile,
	IN      BOOL     fUniqueFileName,
	IN      DWORD    desiredAccess
	);

DWORD
IfsCreateFileEx2(
	IN		LPWSTR	 StorePrefix,
	IN      PVOID    EaBuffer,
	IN      DWORD    EaLength,
	IN OUT  PHANDLE  phFile,
	IN      BOOL     fUniqueFileName,
	IN      DWORD    desiredAccess,
	IN      DWORD    shareAccess,
	IN      DWORD    createDisposition  // see NT DDK
	);

#ifdef _USE_FHCACHE_
//
//  BINLIN - This function embeds the DotStuff state property into the real EA and
//  return the ptr to the new EA buffer.  Used only during outbound and before marshalling
//  EA back to IIS for TransmitFile(), normally in the Store process.
//  Here is the call sequence:
//  1) IIS request outbound message from Store
//  2) Store driver calls EcGetProp() on PR_DOTSTUFF_STATE to get DotStuff state property
//  3) Store driver calls EcGetFileHandleProp() to get real EA.
//  4) IF EA is returned, Store driver calls IfsMarshallStoreEA() and obtain a new EA buffer
//     in pbMarshallEA, and marshall that to IIS.
//  5) IF HANDLE is returned, Store driver may call IfsMarshallHandle() to obtain EA.
//     It then MUST CALL IfsMarshallStoreEA() to obtain new EA buffer pbMarshallEA.
//  In general, if EA is obtained from Store or through IfsMarshallHandle(), the returned
//  EA is not marshall-able until Store driver calls this function with DotStuff state to
//  obtain a new EA buffer.  Only marshall this new EA buffer to IIS, not the EA returned from Store!!!
//
//  General rule of marshalling EA with DotStuff state - EA buffer marshall back and forth
//  between IIS/Store always contain DotStuff state!
//  
//  NOTE:
//  1) Passing in 0 (or use default) for DotStuff state if one doesn't exist/available.
//  2) Caller must allocate memory for pbMarshallEA, and must be at least *pcbEA+sizeof(ulDotStuffState).
//  3) It's ok to pass in same buffer ptr for pbStoreEA and pbMarshallEA, as long as 2) is true.
//
DWORD
IfsMarshallStoreEA(
    IN      PVOID   pbStoreEA,          //  ptr to buffer for EA returned from Store
    IN OUT  PDWORD  pcbEA,              //  IN - sizeof pbStoreEA OUT - sizeof pbMarshallEA
    OUT     PVOID   pbMarshallEA,       //  ptr to buffer for new EA ready for marshall
    IN      ULONG   ulDotStuffState = 0 //  Dotstuff state combined into pbMarshallEA with pbStoreEA
    );
#endif

//////////////////////////////////////////////////////////////////////////////
//  UTILITY functions - not meant to be used by clients of ifsuser.lib
//////////////////////////////////////////////////////////////////////////////

//
//  Get filename from handle
//

DWORD
IfsGetFilenameFromHandle(
    IN      HANDLE  hFile,
    IN OUT  LPSTR   lpstrFilename
    );
    
//
//  Get filename from EA
//

VOID
IfsGetFilenameFromEaW(
    IN      PVOID 	EaBuffer,
    IN OUT	LPWSTR*	ppwstrFilename
    );
    
//
//  Open a file with no EA
//

DWORD
IfsOpenFileNoEa(
	IN      LPWSTR lpwstrName,
    IN  OUT PHANDLE  phFile
    );

#ifdef NT_INCLUDED
//
//  This is the function used by the I/O manager to check EA buffer
//  validity. This can be used to debug EA_LIST_INCONSISTENT errors.
//

DWORD
CheckEaBufferValidity(
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    OUT PULONG ErrorOffset
    );
#endif

#ifdef	__cplusplus	
}
#endif

#endif // _IFSUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\dht\dht.cxx ===
#include <dht.hxx>

namespace DHT {

};  //  namespace DHT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\export\jetbcli.h ===
/*
 *	EDBBCLI.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1986-1996, Microsoft Corporation
 *	
 *	Contains declarations of additional definitions and interfaces
 *	for the Exchange Online Backup Client APIs.
 */

#ifndef	_EDBBCLI_
#define	_EDBBCLI_
#ifdef	__cplusplus
extern "C" {
#endif

#ifdef	MIDL_PASS
#define	RPC_STRING [string]
#else
#define	RPC_STRING
#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#else
typedef wchar_t WCHAR;
#endif
#endif

#define	EDBBACK_MDB_SERVER	"Exchange MDB Database"
#define	EDBBACK_DS_SERVER	"Exchange DS Database"

#define	EDBBACK_API __stdcall

//
//	Useful types.
//

//	UNDONE: HRESULT should be DWORD (unsigned)

//typedef	DWORD HRESULT;
#ifndef	MIDL_PASS
typedef	LONG HRESULT;
#endif

typedef	LONG ERR;

typedef	LONG C;
typedef TCHAR BFT;

//
//	Type of backup passed into HrBackupPrepare()
//

#define	BACKUP_TYPE_FULL			0x01
#define	BACKUP_TYPE_LOGS_ONLY		0x02

//
//	Set the current log number to this value to disable incremental or
//	differential backup.
//
#define	BACKUP_DISABLE_INCREMENTAL	0xffffffff

//
//	Backup/Restore file types
//
//
//	Please note that these file types are binary values, even though they are text (or wchar) typed.
//
//	The code in the backup API's rely on the fact that values 0-256 in 8 bit ascii map to the values 0-256 in unicode.
//

//
//	If the BFT_DIRECTORY bit is set on the backup file type, it indicates that the path specified is a directory,
//	otherwise it is a file name.
//

#define	BFT_DIRECTORY			0x80

//
//	If the BFT_DATABASE bit is set on the backup file type, it indicates that the file goes into the database directory.
//

#define BFT_DATABASE_DIRECTORY	0x40

//
//	If the BFT_LOG bit is set on the backup file type, it indicates that the file goes into the log	directory.
//

#define	BFT_LOG_DIRECTORY		0x20

//
//	Database logs.
//

#define	BFT_LOG						(BFT)(TEXT('\x01') | BFT_LOG_DIRECTORY)
#define	BFT_LOG_DIR					(BFT)(TEXT('\x02') | BFT_DIRECTORY)

//
//	Checkpoint file.
//

#define	BFT_CHECKPOINT_DIR			(BFT)(TEXT('\x03') | BFT_DIRECTORY)

//
//	Database types.
//
#define	BFT_MDB_PRIVATE_DATABASE	(BFT)(TEXT('\x05') | BFT_DATABASE_DIRECTORY)
#define	BFT_MDB_PUBLIC_DATABASE		(BFT)(TEXT('\x06') | BFT_DATABASE_DIRECTORY)
#define	BFT_DSA_DATABASE			(BFT)(TEXT('\x07') | BFT_DATABASE_DIRECTORY)

//
//	JET patch files
//
//
//	

#define	BFT_PATCH_FILE				(BFT)(TEXT('\x08') | BFT_LOG_DIRECTORY)

//
//	Catch all for unknown file types.
//

#define	BFT_UNKNOWN					(BFT)(TEXT('\x0f'))

#include <edbmsg.h>

typedef void *HBC;

typedef struct tagEDB_RSTMAPA
{
	RPC_STRING char		*szDatabaseName;
	RPC_STRING char		*szNewDatabaseName;
} EDB_RSTMAPA, *PEDB_RSTMAPA;			/* restore map */

//	required for Exchange unicode support.
//	UNDONE: NYI
#define	UNICODE_RSTMAP

typedef struct tagEDB_RSTMAPW {
	RPC_STRING WCHAR *wszDatabaseName;
	RPC_STRING WCHAR *wszNewDatabaseName;
} EDB_RSTMAPW, *PEDB_RSTMAPW;

#ifdef UNICODE
#define EDB_RSTMAP EDB_RSTMAPW
#define PEDB_RSTMAP PEDB_RSTMAPW
#else
#define EDB_RSTMAP EDB_RSTMAPA
#define PEDB_RSTMAP PEDB_RSTMAPA
#endif


ERR
EDBBACK_API
HrBackupPrepareA(
	IN char * szBackupServer,
	IN char * szBackupAnnotation,
	IN unsigned long grbit,
	IN unsigned long btBackupType,
	OUT HBC *hbcBackupContext
	);

ERR
EDBBACK_API
HrBackupPrepareW(
	IN WCHAR * wszBackupServer,
	IN WCHAR * wszBackupAnnotation,
	IN unsigned long grbit,
	IN unsigned long btBackupType,
	OUT HBC *hbcBackupContext
	);

#ifdef	UNICODE
#define	HrBackupPrepare HrBackupPrepareW
#else
#define	HrBackupPrepare HrBackupPrepareA
#endif


ERR
EDBBACK_API
HrBackupGetDatabaseNamesA(
	IN HBC pvBackupContext,
	OUT LPSTR *ppszAttachmentInformation,
	OUT LPDWORD pcbSize
	);

ERR
EDBBACK_API
HrBackupGetDatabaseNamesW(
	IN HBC pvBackupContext,
	OUT LPWSTR *ppszAttachmentInformation,
	OUT LPDWORD pcbSize
	);

#ifdef	UNICODE
#define	HrBackupGetDatabaseNames HrBackupGetDatabaseNamesW
#else
#define	HrBackupGetDatabaseNames HrBackupGetDatabaseNamesA
#endif

ERR
EDBBACK_API
HrBackupOpenFileW(
	IN HBC pvBackupContext,
	IN WCHAR * wszAttachmentName,
	IN DWORD cbReadHintSize,
	OUT LARGE_INTEGER *pliFileSize
	);

ERR
EDBBACK_API
HrBackupOpenFileA(
	IN HBC pvBackupContext,
	IN char * szAttachmentName,
	IN DWORD cbReadHintSize,
	OUT LARGE_INTEGER *pliFileSize
	);

#ifdef	UNICODE
#define	HrBackupOpenFile HrBackupOpenFileW
#else
#define HrBackupOpenFile HrBackupOpenFileA
#endif


ERR
EDBBACK_API
HrBackupRead(
	IN HBC pvBackupContext,
	IN PVOID pvBuffer,
	IN DWORD cbBuffer,
	OUT PDWORD pcbRead
	);

ERR
EDBBACK_API
HrBackupClose(
	IN HBC pvBackupContext
	);

ERR
EDBBACK_API
HrBackupGetBackupLogsA(
	IN HBC pvBackupContext,
	IN LPSTR *szBackupLogFile,
	IN PDWORD pcbSize
	);

ERR
EDBBACK_API
HrBackupGetBackupLogsW(
	IN HBC pvBackupContext,
	IN LPWSTR *szBackupLogFile,
	IN PDWORD pcbSize
	);

#ifdef	UNICODE
#define	HrBackupGetBackupLogs HrBackupGetBackupLogsW
#else
#define	HrBackupGetBackupLogs HrBackupGetBackupLogsA
#endif

ERR
EDBBACK_API
HrBackupTruncateLogs(
	IN HBC pvBackupContext
	);


ERR
EDBBACK_API
HrBackupEnd(
	IN HBC pvBackupContext
	);


VOID
EDBBACK_API
BackupFree(
	IN PVOID pvBuffer
	);


ERR
EDBBACK_API
HrRestoreGetDatabaseLocationsA(
	IN HBC hbcBackupContext,
	OUT LPSTR *ppszDatabaseLocationList,
	OUT LPDWORD pcbSize
	);

ERR
EDBBACK_API
HrRestoreGetDatabaseLocationsW(
	IN HBC pvBackupContext,
	OUT LPWSTR *ppszDatabaseLocationList,
	OUT LPDWORD pcbSize
	);

#ifdef	UNICODE
#define	HrRestoreGetDatabaseLocations HrRestoreGetDatabaseLocationsW
#else
#define	HrRestoreGetDatabaseLocations HrRestoreGetDatabaseLocationsA
#endif

ERR
EDBBACK_API
HrRestorePrepareA(
	char * szServerName,
	char * szServiceAnnotation,
	HBC *phbcBackupContext
	);

ERR
EDBBACK_API
HrRestorePrepareW(
	WCHAR * szServerName,
	WCHAR * szServiceAnnotation,
	HBC *phbcBackupContext
	);

#ifdef	UNICODE
#define	HrRestorePrepare HrRestorePrepareW
#else
#define	HrRestorePrepare HrRestorePrepareA
#endif

//
//	HrRestoreRegister will register a restore
//	operation.  It will interlock all subsequent
//	restore operations, and will prevent the restore target
//	from starting until the call to HrRestoreRegisterComplete.
//

ERR
EDBBACK_API
HrRestoreRegisterA(
	IN HBC hbcRestoreContext,
	IN char * szCheckpointFilePath,
	IN char * szLogPath,
	IN EDB_RSTMAPA rgrstmap[],
	IN C crstmap,
	IN char * szBackupLogPath,
	IN ULONG genLow,
	IN ULONG genHigh
	);

ERR
EDBBACK_API
HrRestoreRegisterW(
	IN HBC hbcRestoreContext,
	IN WCHAR * wszCheckpointFilePath,
	IN WCHAR * wszLogPath,
	IN EDB_RSTMAPW rgrstmap[],
	IN C crstmap,
	IN WCHAR * wszBackupLogPath,
	IN ULONG genLow,
	IN ULONG genHigh
	);

#ifdef	UNICODE
#define	HrRestoreRegister HrRestoreRegisterW
#else
#define	HrRestoreRegister HrRestoreRegisterA
#endif

//
//	HrRestoreRegisterComplete will complete a restore
//	operation.  It will allow further subsequent
//	restore operations, and will allow the restore target
//	to start if hrRestoreState is success.
//
//	If hrRestoreState is NOT hrNone, this will
//	prevent the restore target from restarting.
//

ERR
EDBBACK_API
HrRestoreRegisterComplete(
	HBC hbcRestoreContext,
	ERR hrRestoreState
	);

ERR
EDBBACK_API
HrRestoreEnd(
	HBC hbcRestoreContext
	);

ERR
EDBBACK_API
HrSetCurrentBackupLogW(
	WCHAR *wszServerName,
	WCHAR * wszBackupAnnotation,
	DWORD dwCurrentLog
	);

ERR
EDBBACK_API
HrSetCurrentBackupLogA(
	CHAR * szServerName,
	CHAR * szBackupAnnotation,
	DWORD dwCurrentLog
	);

#ifdef	UNICODE
#define	HrSetCurrentBackupLog HrSetCurrentBackupLogW
#else
#define	HrSetCurrentBackupLog HrSetCurrentBackupLogA
#endif

#ifdef	__cplusplus
}
#endif

#endif	// _EDBBCLI_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\export\jetback.h ===
/*
 *	EDBBACK.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1992-1995, Microsoft Corporation
 *	
 *	Contains declarations of additional definitions and interfaces
 *	for the Exchange Online backup Server APIs.
 */

#ifndef	_MDBBACK_
#define	_MDBBACK_

//
//	Useful types.
//

typedef	LONG ERR;

//	UNDONE: HRESULT should be DWORD (unsigned)

//typedef	DWORD HRESULT;
typedef	LONG HRESULT;


#define	EDBBACK_API __stdcall

#ifdef	__cplusplus
extern "C" {
#endif

#define	BACKUP_WITH_UUID

ERR
EDBBACK_API
HrBackupRegisterW(
    UUID *puuidService,
    WCHAR * wszEndpointAnnotation
    );
ERR
EDBBACK_API
HrBackupRegisterA(
    UUID *puuidService,
    char * szEndpointAnnotation
    );

#ifdef	UNICODE
#define	HrBackupRegister HrBackupRegisterW
#else
#define	HrBackupRegister HrBackupRegisterA
#endif

ERR
EDBBACK_API
HrBackupUnregister(
    );

ERR
EDBBACK_API
ErrRestoreRegisterW(
	WCHAR * wszEndpointAnnotation,
	WCHAR * wszRestoreDll,
	char * szPerformRestore,
	char * szQueryDatabaseLocations
	);

ERR
EDBBACK_API
ErrRestoreRegisterA(
	char * szEndpointAnnotation,
	char * szRestoreDll,
	char * szPerformRestore,
	char * szQueryDatabaseLocations
	);

#ifdef	UNICODE
#define	ErrRestoreRegister ErrRestoreRegisterW
#else
#define	ErrRestoreRegister ErrRestoreRegisterA
#endif

ERR
EDBBACK_API
ErrRestoreUnregisterW(
	WCHAR * szEndpointAnnotation
	);

ERR
EDBBACK_API
ErrRestoreUnregisterA(
	char * szEndpointAnnotation
	);

#ifdef	UNICODE
#define	ErrRestoreUnregister ErrRestoreUnregisterW
#else
#define	ErrRestoreUnregister ErrRestoreUnregisterA
#endif

ERR
EDBBACK_API
ErrRecoverAfterRestoreW(
	WCHAR * szParametersRoot,
	WCHAR * wszAnnotation
	);

ERR
EDBBACK_API
ErrRecoverAfterRestoreA(
	char * szParametersRoot,
	char * szAnnotation
	);

#ifdef	UNICODE
#define	ErrRecoverAfterRestore ErrRecoverAfterRestoreW
#else
#define	ErrRecoverAfterRestore ErrRecoverAfterRestoreA
#endif



#ifdef	__cplusplus
}
#endif

#endif	// _MDBBACK_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\export\esebkmsg.h ===
/*
 *	ESEBKMSG.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1986-1996, Microsoft Corporation
 *	
 *	Contains declarations of additional properties and interfaces
 *	offered by Microsoft Exchange Information Store
 */

#ifndef _ESEBKMSG_
#define _ESEBKMSG_

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x0
#define FACILITY_EDB                     0x800
#define FACILITY_CALLBACK                0x7FE
#define FACILITY_BACKUP                  0x7FF


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: GENERAL_CATEGORY
//
// MessageText:
//
//  General
//
#define GENERAL_CATEGORY                 0x00000001L

//
// MessageId: ESEBACK2_CAT_RECOVER_ASYNC
//
// MessageText:
//
//  Recovery
//
#define ESEBACK2_CAT_RECOVER_ASYNC       0x00000002L

//
// MessageId: ESEBACK2_CAT_BACKUP
//
// MessageText:
//
//  Backup
//
#define ESEBACK2_CAT_BACKUP              0x00000003L

//
// MessageId: ESEBACK2_CAT_RESTORE
//
// MessageText:
//
//  Restore
//
#define ESEBACK2_CAT_RESTORE             0x00000004L

//
// MessageId: ESEBACK2_CAT_CALLBACK
//
// MessageText:
//
//  Callback
//
#define ESEBACK2_CAT_CALLBACK            0x00000005L

//
// MessageId: ESEBACK2_CAT_MAX
//
// MessageText:
//
//  <EOF>
//
#define ESEBACK2_CAT_MAX                 0x00000006L

//
//	SUCCESS
//
//
// MessageId: hrNone
//
// MessageText:
//
//  The operation was successful
//
#define hrNone                           ((HRESULT)0x00000000L)

//
//	ERRORS
//
//
// MessageId: hrNyi
//
// MessageText:
//
//  The function is not yet implemented.
//
#define hrNyi                            ((HRESULT)0xC0000001L)

//
//	ERRORS FROM CALLBACK CALLS
//
//
// MessageId: hrCBDatabaseInUse
//
// MessageText:
//
//  Database is in use.
//
#define hrCBDatabaseInUse                ((HRESULT)0xC7FE1F41L)

//
// MessageId: hrCBDatabaseNotFound
//
// MessageText:
//
//  Database not found.
//
#define hrCBDatabaseNotFound             ((HRESULT)0xC7FE1F42L)

//
// MessageId: hrCBDatabaseDisplayNameNotFound
//
// MessageText:
//
//  Display Name for database not found.
//
#define hrCBDatabaseDisplayNameNotFound  ((HRESULT)0xC7FE1F43L)

//
// MessageId: hrCBRestorePathNotProvided
//
// MessageText:
//
//  Restore path not provided.
//
#define hrCBRestorePathNotProvided       ((HRESULT)0xC7FE1F44L)

//
// MessageId: hrCBInstanceNotFound
//
// MessageText:
//
//  Instance not found
//
#define hrCBInstanceNotFound             ((HRESULT)0xC7FE1F45L)

//
// MessageId: hrCBDatabaseCantBeOverwritten
//
// MessageText:
//
//  Database can not be overwritten by a restore.
//
#define hrCBDatabaseCantBeOverwritten    ((HRESULT)0xC7FE1F46L)

//
//	Backup errors
//
//
// MessageId: hrInvalidParam
//
// MessageText:
//
//  The parameter is not valid.
//
#define hrInvalidParam                   ((HRESULT)0xC7FF07D1L)

//
// MessageId: hrError
//
// MessageText:
//
//  An internal error has occurred.
//
#define hrError                          ((HRESULT)0xC7FF07D2L)

//
// MessageId: hrInvalidHandle
//
// MessageText:
//
//  The handle is not valid.
//
#define hrInvalidHandle                  ((HRESULT)0xC7FF07D3L)

//
// MessageId: hrRestoreInProgress
//
// MessageText:
//
//  The Restore process is already in progress.
//
#define hrRestoreInProgress              ((HRESULT)0xC7FF07D4L)

//
// MessageId: hrAlreadyOpen
//
// MessageText:
//
//  The file specified is already open.
//
#define hrAlreadyOpen                    ((HRESULT)0xC7FF07D5L)

//
// MessageId: hrInvalidRecips
//
// MessageText:
//
//  The recipients are invalid.
//
#define hrInvalidRecips                  ((HRESULT)0xC7FF07D6L)

//
// MessageId: hrCouldNotConnect
//
// MessageText:
//
//  Unable to perform the operation. Either you can not connect to the specified server 
//  or the service you are trying to connect to is not running.
//
#define hrCouldNotConnect                ((HRESULT)0xC7FF07D7L)

//
// MessageId: hrRestoreMapExists
//
// MessageText:
//
//  A restore map already exists for the specified component.  You can only specify
//  a restore map when performing a full restore.
//
#define hrRestoreMapExists               ((HRESULT)0xC7FF07D8L)

//
// MessageId: hrIncrementalBackupDisabled
//
// MessageText:
//
//  Another application has modified the specified Microsoft Exchange database such that any
//  subsequent backups will fail. You must perform a full backup to fix this problem.
//
#define hrIncrementalBackupDisabled      ((HRESULT)0xC7FF07D9L)

//
// MessageId: hrLogFileNotFound
//
// MessageText:
//
//  Unable to perform an incremental backup because a required Microsoft Exchange database log file could not be found.
//
#define hrLogFileNotFound                ((HRESULT)0xC7FF07DAL)

//
// MessageId: hrCircularLogging
//
// MessageText:
//
//  The Microsoft Exchange component specified is configured to use circular database logs.
//  It cannot be backed up without a full backup.
//
#define hrCircularLogging                ((HRESULT)0xC7FF07DBL)

//
// MessageId: hrNoFullRestore
//
// MessageText:
//
//  The databases have not been restored to this machine. You cannot restore an incremental backup
//  until a full backup has been restored.
//
#define hrNoFullRestore                  ((HRESULT)0xC7FF07DCL)

//
// MessageId: hrCommunicationError
//
// MessageText:
//
//  A communications error occurred while attempting to perform a local backup.
//
#define hrCommunicationError             ((HRESULT)0xC7FF07DDL)

//
// MessageId: hrFullBackupNotTaken
//
// MessageText:
//
//  You must perform a full backup before you can perform an incremental backup.
//
#define hrFullBackupNotTaken             ((HRESULT)0xC7FF07DEL)

//
// MessageId: hrSnapshotNotSupported
//
// MessageText:
//
//  Snapshot backup not supported by server.
//
#define hrSnapshotNotSupported           ((HRESULT)0xC7FF07DFL)

//
// MessageId: hrFailedToConvertWszFnameToSzFName
//
// MessageText:
//
//  Wide char name provided can't be converted to char name.
//
#define hrFailedToConvertWszFnameToSzFName ((HRESULT)0xC7FF0BB8L)

//
// MessageId: hrOpenRestoreEnvFailed
//
// MessageText:
//
//  The restore environment information isn't found.
//
#define hrOpenRestoreEnvFailed           ((HRESULT)0xC7FF0BB9L)

//
// MessageId: hrBadDatabaseName
//
// MessageText:
//
//  Database name provided is invalid.
//
#define hrBadDatabaseName                ((HRESULT)0xC7FF0BBAL)

//
// MessageId: hrBadTargetDatabaseName
//
// MessageText:
//
//  Destination database name provided is invalid.
//
#define hrBadTargetDatabaseName          ((HRESULT)0xC7FF0BBBL)

//
// MessageId: hrRestoreEnvWriteFailed
//
// MessageText:
//
//  Error writing restore environment information.
//
#define hrRestoreEnvWriteFailed          ((HRESULT)0xC7FF0BBCL)

//
// MessageId: hrBadRestoreLogFilePath
//
// MessageText:
//
//  The path provided for restore log files is invalid.
//
#define hrBadRestoreLogFilePath          ((HRESULT)0xC7FF0BBDL)

//
// MessageId: hrLoadCallbackFunctionFailed
//
// MessageText:
//
//  Error loading callback function.
//
#define hrLoadCallbackFunctionFailed     ((HRESULT)0xC7FF0BBEL)

//
// MessageId: hrLoadBackupCallbackDllFailed
//
// MessageText:
//
//  Error loading DLL for backup callbacks.
//
#define hrLoadBackupCallbackDllFailed    ((HRESULT)0xC7FF0BBFL)

//
// MessageId: hrLoadRestoreCallbackDllFailed
//
// MessageText:
//
//  Error loading DLL for restore callbacks.
//
#define hrLoadRestoreCallbackDllFailed   ((HRESULT)0xC7FF0BC0L)

//
// MessageId: hrWrnNoCallbackFunction
//
// MessageText:
//
//  Callback function not provided.
//
#define hrWrnNoCallbackFunction          ((HRESULT)0x87FF0BC1L)

//
// MessageId: hrBadFilePath
//
// MessageText:
//
//  File path provided is invalid.
//
#define hrBadFilePath                    ((HRESULT)0xC7FF0BC2L)

//
// MessageId: hrRestoreEnvCorrupted
//
// MessageText:
//
//  Restore environment information corrupted.
//
#define hrRestoreEnvCorrupted            ((HRESULT)0xC7FF0BC3L)

//
// MessageId: hrBadCSectionParameter
//
// MessageText:
//
//  Invalid parameter for number of file sections.
//
#define hrBadCSectionParameter           ((HRESULT)0xC7FF0BC4L)

//
// MessageId: hrBadFileNameToBackup
//
// MessageText:
//
//  Backup file name provided is invalid.
//
#define hrBadFileNameToBackup            ((HRESULT)0xC7FF0BC5L)

//
// MessageId: hrRestoreEnvUpdateFailed
//
// MessageText:
//
//  Error updating restore environment information.
//
#define hrRestoreEnvUpdateFailed         ((HRESULT)0x87FF0BC6L)

//
// MessageId: hrInvalidDestinationNameReturnedByServer
//
// MessageText:
//
//  Destination name returned by server is invalid.
//
#define hrInvalidDestinationNameReturnedByServer ((HRESULT)0xC7FF0BC7L)

//
// MessageId: hrLoadCallbackDllFailed
//
// MessageText:
//
//  Error loading DLL for callbacks.
//
#define hrLoadCallbackDllFailed          ((HRESULT)0xC7FF0BC8L)

//
// MessageId: hrAlreadyRegistered
//
// MessageText:
//
//  Already registered for backup and/or restore.
//
#define hrAlreadyRegistered              ((HRESULT)0xC7FF0BC9L)

//
// MessageId: hrLoadResourceFailed
//
// MessageText:
//
//  Error loading a resource.
//
#define hrLoadResourceFailed             ((HRESULT)0xC7FF0BCAL)

//
// MessageId: hrErrorNoCallbackFunction
//
// MessageText:
//
//  Callback function not provided.
//
#define hrErrorNoCallbackFunction        ((HRESULT)0xC7FF0BCBL)

//
// MessageId: hrLogBaseNameMismatch
//
// MessageText:
//
//  The log file base name does not match the one from previous logs.
//
#define hrLogBaseNameMismatch            ((HRESULT)0xC7FF0BCCL)

//
// MessageId: hrDestinationDatabaseInUse
//
// MessageText:
//
//  The database destination to restore to is in use.
//
#define hrDestinationDatabaseInUse       ((HRESULT)0xC7FF0BCDL)

//
// MessageId: hrRestoreEnvSharingViolation
//
// MessageText:
//
//  The restore environment is used by an other process.
//
#define hrRestoreEnvSharingViolation     ((HRESULT)0xC7FF0BCEL)

//
// MessageId: hrCallbackBackupInfoError
//
// MessageText:
//
//  The backup information returned by the server callback is invalid.
//
#define hrCallbackBackupInfoError        ((HRESULT)0xC7FF0BCFL)

//
// MessageId: hrInvalidCallSequence
//
// MessageText:
//
//  Functions called in an invalid sequence.
//
#define hrInvalidCallSequence            ((HRESULT)0xC7FF0FA4L)

//
// MessageId: hrRestoreAtFileLevel
//
// MessageText:
//
//  Restoring must be done by restoring the file.
//
#define hrRestoreAtFileLevel             ((HRESULT)0xC7FF0FA5L)

//
// MessageId: hrErrorFromESECall
//
// MessageText:
//
//  Error returned from an ESE function call (%d).
//
#define hrErrorFromESECall               ((HRESULT)0xC7FF1004L)

//
// MessageId: hrErrorFromCallbackCall
//
// MessageText:
//
//  Error returned from a callback function call (0x%X).
//
#define hrErrorFromCallbackCall          ((HRESULT)0xC7FF1005L)

#define	hrAlreadyListening	((HRESULT)RPC_S_ALREADY_LISTENING)
//
//	ERRORS
//
//
// SYSTEM errors
//
//
// MessageId: hrFileClose
//
// MessageText:
//
//  Unable to close the DOS file
//
#define hrFileClose                      ((HRESULT)0xC8000066L)

//
// MessageId: hrOutOfThreads
//
// MessageText:
//
//  Unable to start a thread because there are none available.
//
#define hrOutOfThreads                   ((HRESULT)0xC8000067L)

//
// MessageId: hrTooManyIO
//
// MessageText:
//
//  The system is busy because there are too many I/Os.
//
#define hrTooManyIO                      ((HRESULT)0xC8000069L)

//
//	BUFFER MANAGER errors
//
//
// MessageId: hrBFNotSynchronous
//
// MessageText:
//
//  The buffer page has been evicted.
//
#define hrBFNotSynchronous               ((HRESULT)0x880000C8L)

//
// MessageId: hrBFPageNotFound
//
// MessageText:
//
//  Unable to find the page.
//
#define hrBFPageNotFound                 ((HRESULT)0x880000C9L)

//
// MessageId: hrBFInUse
//
// MessageText:
//
//  Unable to abandon the buffer.
//
#define hrBFInUse                        ((HRESULT)0xC80000CAL)

//
//	DIRECTORY MANAGER errors
//
//
// MessageId: hrPMRecDeleted
//
// MessageText:
//
//  The record has been deleted.
//
#define hrPMRecDeleted                   ((HRESULT)0xC800012EL)

//
// MessageId: hrRemainingVersions
//
// MessageText:
//
//  There is idle work remaining.
//
#define hrRemainingVersions              ((HRESULT)0x88000141L)

//
//	RECORD MANAGER errors
//
//
// MessageId: hrFLDKeyTooBig
//
// MessageText:
//
//  The key was truncated because it is more than 255 bytes.
//
#define hrFLDKeyTooBig                   ((HRESULT)0x88000190L)

//
// MessageId: hrFLDTooManySegments
//
// MessageText:
//
//  There are too many key segments.
//
#define hrFLDTooManySegments             ((HRESULT)0xC8000191L)

//
// MessageId: hrFLDNullKey
//
// MessageText:
//
//  The key is NULL.
//
#define hrFLDNullKey                     ((HRESULT)0x88000192L)

//
//	LOGGING/RECOVERY errors
//
//
// MessageId: hrLogFileCorrupt
//
// MessageText:
//
//  The log file is damaged.
//
#define hrLogFileCorrupt                 ((HRESULT)0xC80001F5L)

//
// MessageId: hrNoBackupDirectory
//
// MessageText:
//
//  No backup directory was given.
//
#define hrNoBackupDirectory              ((HRESULT)0xC80001F7L)

//
// MessageId: hrBackupDirectoryNotEmpty
//
// MessageText:
//
//  The backup directory is not empty.
//
#define hrBackupDirectoryNotEmpty        ((HRESULT)0xC80001F8L)

//
// MessageId: hrBackupInProgress
//
// MessageText:
//
//  Backup is already active.
//
#define hrBackupInProgress               ((HRESULT)0xC80001F9L)

//
// MessageId: hrMissingPreviousLogFile
//
// MessageText:
//
//  A log file for the checkpoint is missing.
//
#define hrMissingPreviousLogFile         ((HRESULT)0xC80001FDL)

//
// MessageId: hrLogWriteFail
//
// MessageText:
//
//  Unable to write to the log file.
//
#define hrLogWriteFail                   ((HRESULT)0xC80001FEL)

//
// MessageId: hrBadLogVersion
//
// MessageText:
//
//  The version of the log file is not compatible with the version of the Microsoft Exchange Server database (EDB).
//
#define hrBadLogVersion                  ((HRESULT)0xC8000202L)

//
// MessageId: hrInvalidLogSequence
//
// MessageText:
//
//  The time stamp in the next log does not match what was expected.
//
#define hrInvalidLogSequence             ((HRESULT)0xC8000203L)

//
// MessageId: hrLoggingDisabled
//
// MessageText:
//
//  The log is not active.
//
#define hrLoggingDisabled                ((HRESULT)0xC8000204L)

//
// MessageId: hrLogBufferTooSmall
//
// MessageText:
//
//  The log buffer is too small to be recovered.
//
#define hrLogBufferTooSmall              ((HRESULT)0xC8000205L)

//
// MessageId: hrLogSequenceEnd
//
// MessageText:
//
//  The maximum number of log files has been exceeded.
//
#define hrLogSequenceEnd                 ((HRESULT)0xC8000207L)

//
// MessageId: hrNoBackup
//
// MessageText:
//
//  There is no backup in progress.
//
#define hrNoBackup                       ((HRESULT)0xC8000208L)

//
// MessageId: hrInvalidBackupSequence
//
// MessageText:
//
//  The backup call is out of sequence.
//
#define hrInvalidBackupSequence          ((HRESULT)0xC8000209L)

//
// MessageId: hrBackupNotAllowedYet
//
// MessageText:
//
//  Unable to perform a backup now.
//
#define hrBackupNotAllowedYet            ((HRESULT)0xC800020BL)

//
// MessageId: hrDeleteBackupFileFail
//
// MessageText:
//
//  Unable to delete the backup file.
//
#define hrDeleteBackupFileFail           ((HRESULT)0xC800020CL)

//
// MessageId: hrMakeBackupDirectoryFail
//
// MessageText:
//
//  Unable to make a backup temporary directory.
//
#define hrMakeBackupDirectoryFail        ((HRESULT)0xC800020DL)

//
// MessageId: hrInvalidBackup
//
// MessageText:
//
//  An incremental backup cannot be performed when circular logging is enabled.
//
#define hrInvalidBackup                  ((HRESULT)0xC800020EL)

//
// MessageId: hrRecoveredWithErrors
//
// MessageText:
//
//  Errors were encountered during the repair process.
//
#define hrRecoveredWithErrors            ((HRESULT)0xC800020FL)

//
// MessageId: hrMissingLogFile
//
// MessageText:
//
//  The current log file is missing.
//
#define hrMissingLogFile                 ((HRESULT)0xC8000210L)

//
// MessageId: hrLogDiskFull
//
// MessageText:
//
//  The log disk is full.
//
#define hrLogDiskFull                    ((HRESULT)0xC8000211L)

//
// MessageId: hrBadLogSignature
//
// MessageText:
//
//  A log file is damaged.
//
#define hrBadLogSignature                ((HRESULT)0xC8000212L)

//
// MessageId: hrBadDbSignature
//
// MessageText:
//
//  A database file is damaged.
//
#define hrBadDbSignature                 ((HRESULT)0xC8000213L)

//
// MessageId: hrBadCheckpointSignature
//
// MessageText:
//
//  A checkpoint file is damaged.
//
#define hrBadCheckpointSignature         ((HRESULT)0xC8000214L)

//
// MessageId: hrCheckpointCorrupt
//
// MessageText:
//
//  A checkpoint file either could not be found or is damaged.
//
#define hrCheckpointCorrupt              ((HRESULT)0xC8000215L)

//
// MessageId: hrDatabaseInconsistent
//
// MessageText:
//
//  The database is damaged.
//
#define hrDatabaseInconsistent           ((HRESULT)0xC8000226L)

//
// MessageId: hrConsistentTimeMismatch
//
// MessageText:
//
//  There is a mismatch in the database's last consistent time.
//
#define hrConsistentTimeMismatch         ((HRESULT)0xC8000227L)

//
// MessageId: hrPatchFileMismatch
//
// MessageText:
//
//  The patch file is not generated from this backup.
//
#define hrPatchFileMismatch              ((HRESULT)0xC8000228L)

//
// MessageId: hrRestoreLogTooLow
//
// MessageText:
//
//  The starting log number is too low for the restore.
//
#define hrRestoreLogTooLow               ((HRESULT)0xC8000229L)

//
// MessageId: hrRestoreLogTooHigh
//
// MessageText:
//
//  The starting log number is too high for the restore.
//
#define hrRestoreLogTooHigh              ((HRESULT)0xC800022AL)

//
// MessageId: hrGivenLogFileHasBadSignature
//
// MessageText:
//
//  The log file downloaded from the tape is damaged.
//
#define hrGivenLogFileHasBadSignature    ((HRESULT)0xC800022BL)

//
// MessageId: hrGivenLogFileIsNotContiguous
//
// MessageText:
//
//  Unable to find a mandatory log file after the tape was downloaded.
//
#define hrGivenLogFileIsNotContiguous    ((HRESULT)0xC800022CL)

//
// MessageId: hrMissingRestoreLogFiles
//
// MessageText:
//
//  The data is not fully restored because some log files are missing.
//
#define hrMissingRestoreLogFiles         ((HRESULT)0xC800022DL)

//
// MessageId: hrExistingLogFileHasBadSignature
//
// MessageText:
//
//  The log file in the log file path is damaged.
//
#define hrExistingLogFileHasBadSignature ((HRESULT)0x8800022EL)

//
// MessageId: hrExistingLogFileIsNotContiguous
//
// MessageText:
//
//  Unable to find a mandatory log file in the log file path.
//
#define hrExistingLogFileIsNotContiguous ((HRESULT)0x8800022FL)

//
// MessageId: hrMissingFullBackup
//
// MessageText:
//
//  The database missed a previous full backup before the incremental backup.
//
#define hrMissingFullBackup              ((HRESULT)0xC8000230L)

//
// MessageId: hrBadBackupDatabaseSize
//
// MessageText:
//
//  The backup database size must be a multiple of 4K (4096 bytes).
//
#define hrBadBackupDatabaseSize          ((HRESULT)0xC8000231L)

//
// MessageId: hrMissingBackupFiles
//
// MessageText:
//
//  Some log or patch files are missing.
//
#define hrMissingBackupFiles             ((HRESULT)0xC8000232L)

//
// MessageId: hrTermInProgress
//
// MessageText:
//
//  The database is being shut down.
//
#define hrTermInProgress                 ((HRESULT)0xC80003E8L)

//
// MessageId: hrFeatureNotAvailable
//
// MessageText:
//
//  The feature is not available.
//
#define hrFeatureNotAvailable            ((HRESULT)0xC80003E9L)

//
// MessageId: hrInvalidName
//
// MessageText:
//
//  The name is not valid.
//
#define hrInvalidName                    ((HRESULT)0xC80003EAL)

//
// MessageId: hrInvalidParameter
//
// MessageText:
//
//  The parameter is not valid.
//
#define hrInvalidParameter               ((HRESULT)0xC80003EBL)

//
// MessageId: hrColumnNull
//
// MessageText:
//
//  The value of the column is null.
//
#define hrColumnNull                     ((HRESULT)0x880003ECL)

//
// MessageId: hrBufferTruncated
//
// MessageText:
//
//  The buffer is too small for data.
//
#define hrBufferTruncated                ((HRESULT)0x880003EEL)

//
// MessageId: hrDatabaseAttached
//
// MessageText:
//
//  The database is already attached.
//
#define hrDatabaseAttached               ((HRESULT)0x880003EFL)

//
// MessageId: hrInvalidDatabaseId
//
// MessageText:
//
//  The database ID is not valid.
//
#define hrInvalidDatabaseId              ((HRESULT)0xC80003F2L)

//
// MessageId: hrOutOfMemory
//
// MessageText:
//
//  The computer is out of memory.
//
#define hrOutOfMemory                    ((HRESULT)0xC80003F3L)

//
// MessageId: hrOutOfDatabaseSpace
//
// MessageText:
//
//  The database has reached the maximum size of 16 GB.
//
#define hrOutOfDatabaseSpace             ((HRESULT)0xC80003F4L)

//
// MessageId: hrOutOfCursors
//
// MessageText:
//
//  Out of table cursors.
//
#define hrOutOfCursors                   ((HRESULT)0xC80003F5L)

//
// MessageId: hrOutOfBuffers
//
// MessageText:
//
//  Out of database page buffers.
//
#define hrOutOfBuffers                   ((HRESULT)0xC80003F6L)

//
// MessageId: hrTooManyIndexes
//
// MessageText:
//
//  There are too many indexes.
//
#define hrTooManyIndexes                 ((HRESULT)0xC80003F7L)

//
// MessageId: hrTooManyKeys
//
// MessageText:
//
//  There are too many columns in an index.
//
#define hrTooManyKeys                    ((HRESULT)0xC80003F8L)

//
// MessageId: hrRecordDeleted
//
// MessageText:
//
//  The record has been deleted.
//
#define hrRecordDeleted                  ((HRESULT)0xC80003F9L)

//
// MessageId: hrReadVerifyFailure
//
// MessageText:
//
//  A read verification error occurred.
//
#define hrReadVerifyFailure              ((HRESULT)0xC80003FAL)

//
// MessageId: hrOutOfFileHandles
//
// MessageText:
//
//  Out of file handles.
//
#define hrOutOfFileHandles               ((HRESULT)0xC80003FCL)

//
// MessageId: hrDiskIO
//
// MessageText:
//
//  A disk I/O error occurred.
//
#define hrDiskIO                         ((HRESULT)0xC80003FEL)

//
// MessageId: hrInvalidPath
//
// MessageText:
//
//  The path to the file is not valid.
//
#define hrInvalidPath                    ((HRESULT)0xC80003FFL)

//
// MessageId: hrRecordTooBig
//
// MessageText:
//
//  The record has exceeded the maximum size.
//
#define hrRecordTooBig                   ((HRESULT)0xC8000402L)

//
// MessageId: hrTooManyOpenDatabases
//
// MessageText:
//
//  There are too many open databases.
//
#define hrTooManyOpenDatabases           ((HRESULT)0xC8000403L)

//
// MessageId: hrInvalidDatabase
//
// MessageText:
//
//  The file is not a database file.
//
#define hrInvalidDatabase                ((HRESULT)0xC8000404L)

//
// MessageId: hrNotInitialized
//
// MessageText:
//
//  The database was not yet called.
//
#define hrNotInitialized                 ((HRESULT)0xC8000405L)

//
// MessageId: hrAlreadyInitialized
//
// MessageText:
//
//  The database was already called.
//
#define hrAlreadyInitialized             ((HRESULT)0xC8000406L)

//
// MessageId: hrFileAccessDenied
//
// MessageText:
//
//  Unable to access the file.
//
#define hrFileAccessDenied               ((HRESULT)0xC8000408L)

//
// MessageId: hrBufferTooSmall
//
// MessageText:
//
//  The buffer is too small.
//
#define hrBufferTooSmall                 ((HRESULT)0xC800040EL)

//
// MessageId: hrSeekNotEqual
//
// MessageText:
//
//  Either SeekLE or SeekGE did not find an exact match.
//
#define hrSeekNotEqual                   ((HRESULT)0x8800040FL)

//
// MessageId: hrTooManyColumns
//
// MessageText:
//
//  There are too many columns defined.
//
#define hrTooManyColumns                 ((HRESULT)0xC8000410L)

//
// MessageId: hrContainerNotEmpty
//
// MessageText:
//
//  The container is not empty.
//
#define hrContainerNotEmpty              ((HRESULT)0xC8000413L)

//
// MessageId: hrInvalidFilename
//
// MessageText:
//
//  The filename is not valid.
//
#define hrInvalidFilename                ((HRESULT)0xC8000414L)

//
// MessageId: hrInvalidBookmark
//
// MessageText:
//
//  The bookmark is not valid.
//
#define hrInvalidBookmark                ((HRESULT)0xC8000415L)

//
// MessageId: hrColumnInUse
//
// MessageText:
//
//  The column is used in an index.
//
#define hrColumnInUse                    ((HRESULT)0xC8000416L)

//
// MessageId: hrInvalidBufferSize
//
// MessageText:
//
//  The data buffer does not match the column size.
//
#define hrInvalidBufferSize              ((HRESULT)0xC8000417L)

//
// MessageId: hrColumnNotUpdatable
//
// MessageText:
//
//  Unable to set the column value.
//
#define hrColumnNotUpdatable             ((HRESULT)0xC8000418L)

//
// MessageId: hrIndexInUse
//
// MessageText:
//
//  The index is in use.
//
#define hrIndexInUse                     ((HRESULT)0xC800041BL)

//
// MessageId: hrNullKeyDisallowed
//
// MessageText:
//
//  Null keys are not allowed on an index.
//
#define hrNullKeyDisallowed              ((HRESULT)0xC800041DL)

//
// MessageId: hrNotInTransaction
//
// MessageText:
//
//  The operation must be within a transaction.
//
#define hrNotInTransaction               ((HRESULT)0xC800041EL)

//
// MessageId: hrNoIdleActivity
//
// MessageText:
//
//  No idle activity occured.
//
#define hrNoIdleActivity                 ((HRESULT)0x88000422L)

//
// MessageId: hrTooManyActiveUsers
//
// MessageText:
//
//  There are too many active database users.
//
#define hrTooManyActiveUsers             ((HRESULT)0xC8000423L)

//
// MessageId: hrInvalidCountry
//
// MessageText:
//
//  The country code is either not known or is not valid.
//
#define hrInvalidCountry                 ((HRESULT)0xC8000425L)

//
// MessageId: hrInvalidLanguageId
//
// MessageText:
//
//  The language ID is either not known or is not valid.
//
#define hrInvalidLanguageId              ((HRESULT)0xC8000426L)

//
// MessageId: hrInvalidCodePage
//
// MessageText:
//
//  The code page is either not known or is not valid.
//
#define hrInvalidCodePage                ((HRESULT)0xC8000427L)

//
// MessageId: hrNoWriteLock
//
// MessageText:
//
//  There is no write lock at transaction level 0.
//
#define hrNoWriteLock                    ((HRESULT)0x8800042BL)

//
// MessageId: hrColumnSetNull
//
// MessageText:
//
//  The column value is set to null.
//
#define hrColumnSetNull                  ((HRESULT)0x8800042CL)

//
// MessageId: hrVersionStoreOutOfMemory
//
// MessageText:
//
//   lMaxVerPages exceeded (XJET only)
//
#define hrVersionStoreOutOfMemory        ((HRESULT)0xC800042DL)

//
// MessageId: hrCurrencyStackOutOfMemory
//
// MessageText:
//
//  Out of cursors.
//
#define hrCurrencyStackOutOfMemory       ((HRESULT)0xC800042EL)

//
// MessageId: hrOutOfSessions
//
// MessageText:
//
//  Out of sessions.
//
#define hrOutOfSessions                  ((HRESULT)0xC800044DL)

//
// MessageId: hrWriteConflict
//
// MessageText:
//
//  The write lock failed due to an outstanding write lock.
//
#define hrWriteConflict                  ((HRESULT)0xC800044EL)

//
// MessageId: hrTransTooDeep
//
// MessageText:
//
//  The transactions are nested too deeply.
//
#define hrTransTooDeep                   ((HRESULT)0xC800044FL)

//
// MessageId: hrInvalidSesid
//
// MessageText:
//
//  The session handle is not valid.
//
#define hrInvalidSesid                   ((HRESULT)0xC8000450L)

//
// MessageId: hrSessionWriteConflict
//
// MessageText:
//
//  Another session has a private version of the page.
//
#define hrSessionWriteConflict           ((HRESULT)0xC8000453L)

//
// MessageId: hrInTransaction
//
// MessageText:
//
//  The operation is not allowed within a transaction.
//
#define hrInTransaction                  ((HRESULT)0xC8000454L)

//
// MessageId: hrDatabaseDuplicate
//
// MessageText:
//
//  The database already exists.
//
#define hrDatabaseDuplicate              ((HRESULT)0xC80004B1L)

//
// MessageId: hrDatabaseInUse
//
// MessageText:
//
//  The database is in use.
//
#define hrDatabaseInUse                  ((HRESULT)0xC80004B2L)

//
// MessageId: hrDatabaseNotFound
//
// MessageText:
//
//  The database is not mounted or does not exist.
//
#define hrDatabaseNotFound               ((HRESULT)0xC80004B3L)

//
// MessageId: hrDatabaseInvalidName
//
// MessageText:
//
//  The database name is not valid.
//
#define hrDatabaseInvalidName            ((HRESULT)0xC80004B4L)

//
// MessageId: hrDatabaseInvalidPages
//
// MessageText:
//
//  The number of pages is not valid.
//
#define hrDatabaseInvalidPages           ((HRESULT)0xC80004B5L)

//
// MessageId: hrDatabaseCorrupted
//
// MessageText:
//
//  The database file is either damaged or cannot be found.
//
#define hrDatabaseCorrupted              ((HRESULT)0xC80004B6L)

//
// MessageId: hrDatabaseLocked
//
// MessageText:
//
//  The database is locked.
//
#define hrDatabaseLocked                 ((HRESULT)0xC80004B7L)

//
// MessageId: hrTableEmpty
//
// MessageText:
//
//  An empty table was opened.
//
#define hrTableEmpty                     ((HRESULT)0x88000515L)

//
// MessageId: hrTableLocked
//
// MessageText:
//
//  The table is locked.
//
#define hrTableLocked                    ((HRESULT)0xC8000516L)

//
// MessageId: hrTableDuplicate
//
// MessageText:
//
//  The table already exists.
//
#define hrTableDuplicate                 ((HRESULT)0xC8000517L)

//
// MessageId: hrTableInUse
//
// MessageText:
//
//  Unable to lock the table because it is already in use.
//
#define hrTableInUse                     ((HRESULT)0xC8000518L)

//
// MessageId: hrObjectNotFound
//
// MessageText:
//
//  The table or object does not exist.
//
#define hrObjectNotFound                 ((HRESULT)0xC8000519L)

//
// MessageId: hrCannotRename
//
// MessageText:
//
//  Unable to rename the temporary file.
//
#define hrCannotRename                   ((HRESULT)0xC800051AL)

//
// MessageId: hrDensityInvalid
//
// MessageText:
//
//  The file/index density is not valid.
//
#define hrDensityInvalid                 ((HRESULT)0xC800051BL)

//
// MessageId: hrTableNotEmpty
//
// MessageText:
//
//  Unable to define the clustered index.
//
#define hrTableNotEmpty                  ((HRESULT)0xC800051CL)

//
// MessageId: hrInvalidTableId
//
// MessageText:
//
//  The table ID is not valid.
//
#define hrInvalidTableId                 ((HRESULT)0xC800051EL)

//
// MessageId: hrTooManyOpenTables
//
// MessageText:
//
//  Unable to open any more tables.
//
#define hrTooManyOpenTables              ((HRESULT)0xC800051FL)

//
// MessageId: hrIllegalOperation
//
// MessageText:
//
//  The operation is not supported on tables.
//
#define hrIllegalOperation               ((HRESULT)0xC8000520L)

//
// MessageId: hrObjectDuplicate
//
// MessageText:
//
//  The table or object name is already being used.
//
#define hrObjectDuplicate                ((HRESULT)0xC8000522L)

//
// MessageId: hrInvalidObject
//
// MessageText:
//
//  The object is not valid for operation.
//
#define hrInvalidObject                  ((HRESULT)0xC8000524L)

//
// MessageId: hrIndexCantBuild
//
// MessageText:
//
//  Unable to build a clustered index.
//
#define hrIndexCantBuild                 ((HRESULT)0xC8000579L)

//
// MessageId: hrIndexHasPrimary
//
// MessageText:
//
//  The primary index is already defined.
//
#define hrIndexHasPrimary                ((HRESULT)0xC800057AL)

//
// MessageId: hrIndexDuplicate
//
// MessageText:
//
//  The index is already defined.
//
#define hrIndexDuplicate                 ((HRESULT)0xC800057BL)

//
// MessageId: hrIndexNotFound
//
// MessageText:
//
//  The index does not exist.
//
#define hrIndexNotFound                  ((HRESULT)0xC800057CL)

//
// MessageId: hrIndexMustStay
//
// MessageText:
//
//  Unable to delete a clustered index.
//
#define hrIndexMustStay                  ((HRESULT)0xC800057DL)

//
// MessageId: hrIndexInvalidDef
//
// MessageText:
//
//  The index definition is illegal.
//
#define hrIndexInvalidDef                ((HRESULT)0xC800057EL)

//
// MessageId: hrIndexHasClustered
//
// MessageText:
//
//  The clustered index is already defined.
//
#define hrIndexHasClustered              ((HRESULT)0xC8000580L)

//
// MessageId: hrCreateIndexFailed
//
// MessageText:
//
//  Unable to create the index because an error occurred while creating a table.
//
#define hrCreateIndexFailed              ((HRESULT)0x88000581L)

//
// MessageId: hrTooManyOpenIndexes
//
// MessageText:
//
//  Out of index description blocks.
//
#define hrTooManyOpenIndexes             ((HRESULT)0xC8000582L)

//
// MessageId: hrColumnLong
//
// MessageText:
//
//  The column value is too long.
//
#define hrColumnLong                     ((HRESULT)0xC80005DDL)

//
// MessageId: hrColumnDoesNotFit
//
// MessageText:
//
//  The field will not fit in the record.
//
#define hrColumnDoesNotFit               ((HRESULT)0xC80005DFL)

//
// MessageId: hrNullInvalid
//
// MessageText:
//
//  The value cannot be null.
//
#define hrNullInvalid                    ((HRESULT)0xC80005E0L)

//
// MessageId: hrColumnIndexed
//
// MessageText:
//
//  Unable to delete because the column is indexed.
//
#define hrColumnIndexed                  ((HRESULT)0xC80005E1L)

//
// MessageId: hrColumnTooBig
//
// MessageText:
//
//  The length of the field exceeds the maximum length of 255 bytes.
//
#define hrColumnTooBig                   ((HRESULT)0xC80005E2L)

//
// MessageId: hrColumnNotFound
//
// MessageText:
//
//  Unable to find the column.
//
#define hrColumnNotFound                 ((HRESULT)0xC80005E3L)

//
// MessageId: hrColumnDuplicate
//
// MessageText:
//
//  The field is already defined.
//
#define hrColumnDuplicate                ((HRESULT)0xC80005E4L)

//
// MessageId: hrColumn2ndSysMaint
//
// MessageText:
//
//  Only one auto-increment or version column is allowed per table.
//
#define hrColumn2ndSysMaint              ((HRESULT)0xC80005E6L)

//
// MessageId: hrInvalidColumnType
//
// MessageText:
//
//  The column data type is not valid.
//
#define hrInvalidColumnType              ((HRESULT)0xC80005E7L)

//
// MessageId: hrColumnMaxTruncated
//
// MessageText:
//
//  The column was truncated because it exceeded the maximum length of 255 bytes.
//
#define hrColumnMaxTruncated             ((HRESULT)0x880005E8L)

//
// MessageId: hrColumnCannotIndex
//
// MessageText:
//
//  Unable to index a long value column.
//
#define hrColumnCannotIndex              ((HRESULT)0xC80005E9L)

//
// MessageId: hrTaggedNotNULL
//
// MessageText:
//
//  Tagged columns cannot be null.
//
#define hrTaggedNotNULL                  ((HRESULT)0xC80005EAL)

//
// MessageId: hrNoCurrentIndex
//
// MessageText:
//
//  The entry is not valid without a current index.
//
#define hrNoCurrentIndex                 ((HRESULT)0xC80005EBL)

//
// MessageId: hrKeyIsMade
//
// MessageText:
//
//  The key is completely made.
//
#define hrKeyIsMade                      ((HRESULT)0xC80005ECL)

//
// MessageId: hrBadColumnId
//
// MessageText:
//
//  The column ID is not correct.
//
#define hrBadColumnId                    ((HRESULT)0xC80005EDL)

//
// MessageId: hrBadItagSequence
//
// MessageText:
//
//  There is a bad instance identifier for a multivalued column.
//
#define hrBadItagSequence                ((HRESULT)0xC80005EEL)

//
// MessageId: hrCannotBeTagged
//
// MessageText:
//
//  AutoIncrement and Version cannot be multivalued.
//
#define hrCannotBeTagged                 ((HRESULT)0xC80005F1L)

//
// MessageId: hrRecordNotFound
//
// MessageText:
//
//  Unable to find the key.
//
#define hrRecordNotFound                 ((HRESULT)0xC8000641L)

//
// MessageId: hrNoCurrentRecord
//
// MessageText:
//
//  The currency is not on a record.
//
#define hrNoCurrentRecord                ((HRESULT)0xC8000643L)

//
// MessageId: hrRecordClusteredChanged
//
// MessageText:
//
//  A clustered key cannot be changed.
//
#define hrRecordClusteredChanged         ((HRESULT)0xC8000644L)

//
// MessageId: hrKeyDuplicate
//
// MessageText:
//
//  The key already exists.
//
#define hrKeyDuplicate                   ((HRESULT)0xC8000645L)

//
// MessageId: hrAlreadyPrepared
//
// MessageText:
//
//  The current entry has already been copied or cleared.
//
#define hrAlreadyPrepared                ((HRESULT)0xC8000647L)

//
// MessageId: hrKeyNotMade
//
// MessageText:
//
//  No key was made.
//
#define hrKeyNotMade                     ((HRESULT)0xC8000648L)

//
// MessageId: hrUpdateNotPrepared
//
// MessageText:
//
//  Update was not prepared.
//
#define hrUpdateNotPrepared              ((HRESULT)0xC8000649L)

//
// MessageId: hrwrnDataHasChanged
//
// MessageText:
//
//  Data has changed.
//
#define hrwrnDataHasChanged              ((HRESULT)0x8800064AL)

//
// MessageId: hrerrDataHasChanged
//
// MessageText:
//
//  The operation was abandoned because data has changed.
//
#define hrerrDataHasChanged              ((HRESULT)0xC800064BL)

//
// MessageId: hrKeyChanged
//
// MessageText:
//
//  Moved to a new key.
//
#define hrKeyChanged                     ((HRESULT)0x88000652L)

//
// MessageId: hrTooManySorts
//
// MessageText:
//
//  There are too many sort processes.
//
#define hrTooManySorts                   ((HRESULT)0xC80006A5L)

//
// MessageId: hrInvalidOnSort
//
// MessageText:
//
//  An operation that is not valid occurred in the sort.
//
#define hrInvalidOnSort                  ((HRESULT)0xC80006A6L)

//
// MessageId: hrTempFileOpenError
//
// MessageText:
//
//  Unable to open the temporary file.
//
#define hrTempFileOpenError              ((HRESULT)0xC800070BL)

//
// MessageId: hrTooManyAttachedDatabases
//
// MessageText:
//
//  There are too many databases open.
//
#define hrTooManyAttachedDatabases       ((HRESULT)0xC800070DL)

//
// MessageId: hrDiskFull
//
// MessageText:
//
//  The disk is full.
//
#define hrDiskFull                       ((HRESULT)0xC8000710L)

//
// MessageId: hrPermissionDenied
//
// MessageText:
//
//  Permission is denied.
//
#define hrPermissionDenied               ((HRESULT)0xC8000711L)

//
// MessageId: hrFileNotFound
//
// MessageText:
//
//  Unable to find the file.
//
#define hrFileNotFound                   ((HRESULT)0xC8000713L)

//
// MessageId: hrFileOpenReadOnly
//
// MessageText:
//
//  The database file is read only.
//
#define hrFileOpenReadOnly               ((HRESULT)0x88000715L)

//
// MessageId: hrAfterInitialization
//
// MessageText:
//
//  Unable to restore after initialization.
//
#define hrAfterInitialization            ((HRESULT)0xC800073AL)

//
// MessageId: hrLogCorrupted
//
// MessageText:
//
//  The database log files are damaged.
//
#define hrLogCorrupted                   ((HRESULT)0xC800073CL)

//
// MessageId: hrInvalidOperation
//
// MessageText:
//
//  The operation is not valid.
//
#define hrInvalidOperation               ((HRESULT)0xC8000772L)

//
// MessageId: hrAccessDenied
//
// MessageText:
//
//  Access is denied.
//
#define hrAccessDenied                   ((HRESULT)0xC8000773L)

//
// MessageId: hrBadRestoreTargetInstance
//
// MessageText:
//
//  Target Instance specified for restore is not found or log files don't match the backup set logs.
//
#define hrBadRestoreTargetInstance       ((HRESULT)0xC8000774L)

//
// MessageId: hrRunningInstanceIsUsingPath
//
// MessageText:
//
//  Directory contains log files that are in use by a running database. Chose a temporary location.
//
#define hrRunningInstanceIsUsingPath     ((HRESULT)0xC8000775L)

//
//	EVENTLOG
//
//
// MessageId: RESTORE_COMPLETE_START_ID
//
// MessageText:
//
//  %1 (%2) Restore started from directory %3.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define RESTORE_COMPLETE_START_ID        ((HRESULT)0xC8000385L)

//
// MessageId: RESTORE_COMPLETE_STOP_ID
//
// MessageText:
//
//  %1 (%2) Restore from directory %3 ended successfully.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define RESTORE_COMPLETE_STOP_ID         ((HRESULT)0xC8000386L)

//
// MessageId: RESTORE_COMPLETE_ERROR_ID
//
// MessageText:
//
//  %1 (%2) Restore from directory %3 ended with error (%4).
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define RESTORE_COMPLETE_ERROR_ID        ((HRESULT)0xC8000387L)

//
// MessageId: BACKUP_NOT_TRUNCATE_DB_UNMOUNTED_ID
//
// MessageText:
//
//  %1 (%2) Unable to purge transaction logs because at least one database (%3) is off-line.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define BACKUP_NOT_TRUNCATE_DB_UNMOUNTED_ID ((HRESULT)0xC80003B7L)

//
// MessageId: CALLBACK_ERROR_ID
//
// MessageText:
//
//  %1 (%2) Callback function call %3 ended with error %4 %5.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define CALLBACK_ERROR_ID                ((HRESULT)0xC8000388L)

//
// MessageId: BACKUP_RESTORE_REGISTER_ID
//
// MessageText:
//
//  %1 (%2) Server registered: %3 / %4 (callback DLL %5, flags %6).
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define BACKUP_RESTORE_REGISTER_ID       ((HRESULT)0xC8000389L)

//
// MessageId: BACKUP_RESTORE_UNREGISTER_ID
//
// MessageText:
//
//  %1 (%2) Server unregistered: %3 / %4.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define BACKUP_RESTORE_UNREGISTER_ID     ((HRESULT)0xC800038AL)

#endif	// _ESEBKMSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\export\jet.h ===
#if _MSC_VER > 1000
#pragma once
#endif

#define eseVersion 0x5600
//	HISTORY:
//		0x5500	- ESE97 (Exchange 5.5)
//		0x5580	- ESENT97 (W2k)
//		0x5600	- ESENT98 (Whistler)
//		0x6000	- ESE98 (Exchange 2000)


#if !defined(_JET_INCLUDED)
#define _JET_INCLUDED

#ifdef	__cplusplus
extern "C" {
#endif

#define JET_cbPage	4096			//	UNDONE: Remove when no more components reference this.

#if defined(_M_AMD64) || defined(_M_IA64)
#include <pshpack8.h>
#else
#include <pshpack4.h>
#endif


#pragma warning(push)
#pragma warning(disable: 4201)		//	nonstandard extension used : nameless struct/union


#define JET_API     __stdcall
#define JET_NODSAPI __stdcall

#ifdef _WIN64
    typedef unsigned __int64 JET_API_PTR;
#else
    typedef unsigned long JET_API_PTR;
#endif


typedef long JET_ERR;

typedef JET_API_PTR JET_HANDLE;	/* backup file handle */
typedef JET_API_PTR JET_INSTANCE;	/* Instance Identifier */
typedef JET_API_PTR JET_SESID;  	/* Session Identifier */
typedef JET_API_PTR JET_TABLEID;	/* Table Identifier */
typedef JET_API_PTR JET_LS;		/* Local Storage */

typedef unsigned long JET_COLUMNID;	/* Column Identifier */

typedef struct tagJET_INDEXID
	{
	unsigned long	cbStruct;
	unsigned char	rgbIndexId[sizeof(JET_API_PTR)+sizeof(unsigned long)+sizeof(unsigned long)];
	} JET_INDEXID;

typedef unsigned long JET_DBID;   	/* Database Identifier */
typedef unsigned long JET_OBJTYP;	/* Object Type */
typedef unsigned long JET_COLTYP;	/* Column Type */
typedef unsigned long JET_GRBIT;  	/* Group of Bits */

typedef unsigned long JET_SNP;		/* Status Notification Process */
typedef unsigned long JET_SNT;		/* Status Notification Type */
typedef unsigned long JET_SNC;		/* Status Notification Code */
typedef double JET_DATESERIAL;		/* JET_coltypDateTime format */
typedef unsigned long JET_DLLID;      /* ID of DLL for hook functions */
typedef unsigned long JET_CBTYP;	/* Callback Types */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void *pv);

/*	required for Exchange to make RSTMAP RPC capable
/**/
#ifdef	MIDL_PASS
#define	xRPC_STRING [string]
#else
#define	xRPC_STRING
#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#else
typedef wchar_t WCHAR;
#endif
#endif

typedef struct
	{
	xRPC_STRING char		*szDatabaseName;
	xRPC_STRING char		*szNewDatabaseName;
	} JET_RSTMAP;			/* restore map */

/*	required for Exchange unicode support
/**/
#define	UNICODE_RSTMAP

typedef struct tagJET_RSTMAPW {
	xRPC_STRING WCHAR *wszDatabaseName;
	xRPC_STRING WCHAR *wszNewDatabaseName;
	} JET_RSTMAPW, *PJET_RSTMAPW;


//	For edbutil convert only.

typedef struct tagCONVERT
	{
	char					*szOldDll;
	union
		{
		unsigned long		fFlags;
		struct
			{
			unsigned long	fSchemaChangesOnly:1;
			};
		};
	} JET_CONVERT;

typedef enum
	{

	//	Database operations

	opDBUTILConsistency,
	opDBUTILDumpData,
	opDBUTILDumpMetaData,
	opDBUTILDumpPage,
	opDBUTILDumpNode,
	opDBUTILDumpSpace,
 	opDBUTILSetHeaderState,
	opDBUTILDumpHeader,
	opDBUTILDumpLogfile,
	opDBUTILDumpLogfileTrackNode,
	opDBUTILDumpCheckpoint,
	opDBUTILEDBDump,
	opDBUTILEDBRepair,
	opDBUTILMunge,
	opDBUTILEDBScrub,
	opDBUTILSLVMove,
	opDBUTILDBConvertRecords,
	opDBUTILDBDefragment,
	opDBUTILDumpExchangeSLVInfo,
	opDBUTILDumpUnicodeFixupTable,
	} DBUTIL_OP;

typedef enum
	{
	opEDBDumpTables,
	opEDBDumpIndexes,
	opEDBDumpColumns,
	opEDBDumpCallbacks,
	opEDBDumpPage,
	} EDBDUMP_OP;

typedef struct tagDBUTIL
	{
	unsigned long	cbStruct;

	JET_SESID	sesid;
	JET_DBID	dbid;
	JET_TABLEID	tableid;

	DBUTIL_OP	op;
	EDBDUMP_OP	edbdump;
	JET_GRBIT	grbitOptions;

	char		*szDatabase;
	char		*szSLV;
	char		*szBackup;
	char		*szTable;
	char		*szIndex;
	char		*szIntegPrefix;

	long	pgno;
	long	iline;

	long	lGeneration;
	long	isec;
	long	ib;

	long	cRetry;

	void *		pfnCallback;
	void *		pvCallback;

	} JET_DBUTIL;

#define JET_bitDBUtilOptionAllNodes				0x00000001
#define JET_bitDBUtilOptionKeyStats				0x00000002
#define JET_bitDBUtilOptionPageDump				0x00000004
#define JET_bitDBUtilOptionDumpVerbose			0x10000000	// DEBUG only
#define JET_bitDBUtilOptionCheckBTree			0x20000000	// DEBUG only
#define JET_bitDBUtilOptionStats				0x00000008

#define JET_bitDBUtilOptionVerbose				0x00000010
#define JET_bitDBUtilOptionIgnoreErrors			0x00000020
#define JET_bitDBUtilOptionVerify				0x00000040
#define JET_bitDBUtilOptionReportErrors			0x00000080
#define JET_bitDBUtilOptionDontRepair			0x00000100
#define JET_bitDBUtilOptionRepairAll			0x00000200
#define JET_bitDBUtilOptionRepairIndexes		0x00000400
#define JET_bitDBUtilOptionDontBuildIndexes		0x00000800



//	Online defragmentation options
#define JET_bitDefragmentBatchStart				0x00000001
#define JET_bitDefragmentBatchStop				0x00000002
#define JET_bitDefragmentTest					0x00000004	/* run internal tests (non-RTM builds only) */
#define JET_bitDefragmentSLVBatchStart			0x00000008
#define JET_bitDefragmentSLVBatchStop			0x00000010
#define JET_bitDefragmentScrubSLV				0x00000020	/* syncronously zero free pages in the streaming file */
#define JET_bitDefragmentAvailSpaceTreesOnly	0x00000040	/* only defrag AvailExt trees */

	/* Callback-function types */

#define	JET_cbtypNull							0x00000000
#define JET_cbtypFinalize						0x00000001	/* a finalizable column has gone to zero */
#define JET_cbtypBeforeInsert					0x00000002	/* about to insert a record */
#define JET_cbtypAfterInsert					0x00000004	/* finished inserting a record */
#define JET_cbtypBeforeReplace					0x00000008	/* about to modify a record */
#define JET_cbtypAfterReplace					0x00000010	/* finished modifying a record */
#define JET_cbtypBeforeDelete					0x00000020	/* about to delete a record */
#define JET_cbtypAfterDelete					0x00000040	/* finished deleting the record */
#define JET_cbtypUserDefinedDefaultValue		0x00000080	/* calculating a user-defined default */
#define JET_cbtypOnlineDefragCompleted			0x00000100	/* a call to JetDefragment2 has completed */
#define JET_cbtypFreeCursorLS					0x00000200	/* the Local Storage associated with a cursor must be freed */
#define JET_cbtypFreeTableLS					0x00000400	/* the Local Storage associated with a table must be freed */
#define JET_cbtypDTCQueryPreparedTransaction	0x00001000	/* recovery is attempting to resolve a PreparedToCommit transaction */
#define JET_cbtypOnlineDefragProgress			0x00002000	/* online defragmentation has made progress */

	/* Callback-function prototype */

typedef JET_ERR (__stdcall *JET_CALLBACK)(
	JET_SESID 		sesid,
	JET_DBID 		dbid,
	JET_TABLEID 	tableid,
	JET_CBTYP 		cbtyp,
	void *			pvArg1,
	void *			pvArg2,
	void *			pvContext,
	JET_API_PTR		ulUnused );

	/*	Session information bits */

#define JET_bitCIMCommitted					 	0x00000001
#define JET_bitCIMDirty	 					 	0x00000002
#define JET_bitAggregateTransaction		  		0x00000008

	/* Status Notification Structures */

typedef struct				/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cunitDone;	/* Number of units of work completed */
	unsigned long	cunitTotal;	/* Total number of units of work */
	} JET_SNPROG;

typedef struct				/* Status Notification Message */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_SNC  		snc;	  	/* Status Notification Code */
	unsigned long	ul;			/* Numeric identifier */
	char	 		sz[256];  	/* Identifier */
	} JET_SNMSG;


typedef struct
	{
	unsigned long			cbStruct;

	unsigned long			cbFilesizeLow;			//	file's current size (low DWORD)
	unsigned long			cbFilesizeHigh;			//	file's current size (high DWORD)

	unsigned long			cbFreeSpaceRequiredLow;	//	estimate of free disk space required for in-place upgrade (low DWORD)
	unsigned long			cbFreeSpaceRequiredHigh;//	estimate of free disk space required for in-place upgrade (high DWORD)

	unsigned long			csecToUpgrade;			//	estimate of time required, in seconds, for upgrade

	union
		{
		unsigned long		ulFlags;
		struct
			{
			unsigned long	fUpgradable:1;
			unsigned long	fAlreadyUpgraded:1;
			};
		};
	} JET_DBINFOUPGRADE;


typedef struct
	{
	unsigned long		cbStruct;
	JET_OBJTYP			objtyp;
	JET_DATESERIAL		dtCreate;	//  XXX -- to be deleted
	JET_DATESERIAL		dtUpdate;	//  XXX -- to be deleted
	JET_GRBIT			grbit;
	unsigned long		flags;
	unsigned long		cRecord;
	unsigned long		cPage;
	} JET_OBJECTINFO;

	/* The following flags appear in the grbit field above */

#define JET_bitTableInfoUpdatable	0x00000001
#define JET_bitTableInfoBookmark	0x00000002
#define JET_bitTableInfoRollback	0x00000004
#define JET_bitTableSequential		0x00008000

	/* The following flags occur in the flags field above */

#define JET_bitObjectSystem			0x80000000	// Internal use only
#define JET_bitObjectTableFixedDDL	0x40000000	// Table's DDL is fixed
#define JET_bitObjectTableTemplate	0x20000000	// Table's DDL is inheritable (implies FixedDDL)
#define JET_bitObjectTableDerived	0x10000000	// Table's DDL is inherited from a template table
#define JET_bitObjectSystemDynamic	(JET_bitObjectSystem|0x08000000)	//	Internal use only (dynamic system objects)
#define JET_bitObjectTableNoFixedVarColumnsInDerivedTables	0x04000000	//	used in conjunction with JET_bitObjectTableTemplate
																		//	to disallow fixed/var columns in derived tables (so that
																		//	fixed/var columns may be added to the template in the future)


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidcontainername;
	JET_COLUMNID	columnidobjectname;
	JET_COLUMNID	columnidobjtyp;
	JET_COLUMNID	columniddtCreate;	//  XXX -- to be deleted
	JET_COLUMNID	columniddtUpdate;	//  XXX -- to be deleted
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidflags;
	JET_COLUMNID	columnidcRecord;	/* Level 2 info */
	JET_COLUMNID	columnidcPage;		/* Level 2 info */
	} JET_OBJECTLIST;

#define cObjectInfoCols 9

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidPresentationOrder;
	JET_COLUMNID	columnidcolumnname;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidcbMax;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidDefault;
	JET_COLUMNID	columnidBaseTableName;
	JET_COLUMNID	columnidBaseColumnName;
	JET_COLUMNID	columnidDefinitionName;
	} JET_COLUMNLIST;

#define cColumnInfoCols 14

typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wCollate;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT		grbit;
	} JET_COLUMNDEF;


typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wFiller;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT		grbit;
	char			szBaseTableName[256];
	char			szBaseColumnName[256];
	} JET_COLUMNBASE;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidindexname;
	JET_COLUMNID	columnidgrbitIndex;
	JET_COLUMNID	columnidcKey;
	JET_COLUMNID	columnidcEntry;
	JET_COLUMNID	columnidcPage;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidgrbitColumn;
	JET_COLUMNID	columnidcolumnname;
	JET_COLUMNID	columnidLCMapFlags;
	} JET_INDEXLIST;


#define cIndexInfoCols 15

typedef struct tag_JET_COLUMNCREATE
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char			*szColumnName;			// column name
	JET_COLTYP		coltyp;					// column type
	unsigned long	cbMax;					// the maximum length of this column (only relevant for binary and text columns)
	JET_GRBIT		grbit;					// column options
	void			*pvDefault;				// default value (NULL if none)
	unsigned long	cbDefault;				// length of default value
	unsigned long	cp;						// code page (for text columns only)
	JET_COLUMNID	columnid;				// returned column id
	JET_ERR			err;					// returned error code
	} JET_COLUMNCREATE;

//  This is the information needed to create a column with a user-defined default. It should be passed in using
//  the pvDefault and cbDefault in a JET_COLUMNCREATE structure
typedef struct tag_JET_USERDEFINEDDEFAULT
	{
	char * szCallback;
	unsigned char * pbUserData;
	unsigned long cbUserData;
	char * szDependantColumns;
	} JET_USERDEFINEDDEFAULT;

typedef struct tagJET_INDEXCREATEOLD		// [4/15/97]: to be phased out eventually (laurionb)
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char			*szIndexName;			// index name
	char			*szKey;					// index key
	unsigned long	cbKey;					// length of key
	JET_GRBIT		grbit;					// index options
	unsigned long	ulDensity;				// index density
	JET_ERR			err;					// returned error code
	} JET_INDEXCREATEOLD;


typedef struct tagJET_CONDITIONALCOLUMN
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char 			*szColumnName;			// column that we are conditionally indexed on
	JET_GRBIT		grbit;					// conditional column options
	} JET_CONDITIONALCOLUMN;


typedef struct tagJET_UNICODEINDEX
	{
	unsigned long	lcid;
	unsigned long	dwMapFlags;
	} JET_UNICODEINDEX;

typedef struct tagJET_TUPLELIMITS
	{
	unsigned long	chLengthMin;
	unsigned long	chLengthMax;
	unsigned long	chToIndexMax;
	} JET_TUPLELIMITS;

typedef struct tagJET_INDEXCREATE
	{
	unsigned long			cbStruct;				// size of this structure (for future expansion)
	char					*szIndexName;			// index name
	char					*szKey;					// index key
	unsigned long			cbKey;					// length of key
	JET_GRBIT				grbit;					// index options
	unsigned long			ulDensity;				// index density

	union
		{
		unsigned long		lcid;					// lcid for the index (if JET_bitIndexUnicode NOT specified)
		JET_UNICODEINDEX	*pidxunicode;			// pointer to JET_UNICODEINDEX struct (if JET_bitIndexUnicode specified)
		};

	union
		{
		unsigned long		cbVarSegMac;			// maximum length of variable length columns in index key (if JET_bitIndexTupleLimits specified)
		JET_TUPLELIMITS		*ptuplelimits;			// pointer to JET_TUPLELIMITS struct (if JET_bitIndexTupleLimits specified)
		};

	JET_CONDITIONALCOLUMN	*rgconditionalcolumn;	// pointer to conditional column structure
	unsigned long			cConditionalColumn;		// number of conditional columns
	JET_ERR					err;					// returned error code
	} JET_INDEXCREATE;


typedef struct tagJET_TABLECREATE
	{
	unsigned long		cbStruct;				// size of this structure (for future expansion)
	char				*szTableName;			// name of table to create.
	char				*szTemplateTableName;	// name of table from which to inherit base DDL
	unsigned long		ulPages;				// initial pages to allocate for table.
	unsigned long		ulDensity;				// table density.
	JET_COLUMNCREATE	*rgcolumncreate;		// array of column creation info
	unsigned long		cColumns;				// number of columns to create
	JET_INDEXCREATE		*rgindexcreate;			// array of index creation info
	unsigned long		cIndexes;				// number of indexes to create
	JET_GRBIT			grbit;
	JET_TABLEID			tableid;				// returned tableid.
	unsigned long		cCreated;				// count of objects created (columns+table+indexes).
	} JET_TABLECREATE;

typedef struct tagJET_TABLECREATE2
	{
	unsigned long		cbStruct;				// size of this structure (for future expansion)
	char				*szTableName;			// name of table to create.
	char				*szTemplateTableName;	// name of table from which to inherit base DDL
	unsigned long		ulPages;				// initial pages to allocate for table.
	unsigned long		ulDensity;				// table density.
	JET_COLUMNCREATE	*rgcolumncreate;		// array of column creation info
	unsigned long		cColumns;				// number of columns to create
	JET_INDEXCREATE		*rgindexcreate;			// array of index creation info
	unsigned long		cIndexes;				// number of indexes to create
	char				*szCallback;			// callback to use for this table
	JET_CBTYP			cbtyp;					// when the callback should be called
	JET_GRBIT			grbit;
	JET_TABLEID			tableid;				// returned tableid.
	unsigned long		cCreated;				// count of objects created (columns+table+indexes+callbacks).
	} JET_TABLECREATE2;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	JET_COLUMNID	columnidNextTagged;
	} JET_RETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	} JET_SETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	centriesLT;
	unsigned long	centriesInRange;
	unsigned long	centriesTotal;
	} JET_RECPOS;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidBookmark;
	} JET_RECORDLIST;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	JET_GRBIT		grbit;
	} JET_INDEXRANGE;

//  for database DDL conversion

typedef enum
	{
	opDDLConvNull,
	opDDLConvAddCallback,
	opDDLConvChangeColumn,
	opDDLConvAddConditionalColumnsToAllIndexes,
	opDDLConvAddColumnCallback,
	opDDLConvIncreaseMaxColumnSize,
	opDDLConvChangeIndexDensity,
	opDDLConvMax
	} JET_OPDDLCONV;

typedef struct tagDDLADDCALLBACK
	{
	char		*szTable;
	char		*szCallback;
	JET_CBTYP	cbtyp;
	} JET_DDLADDCALLBACK;

typedef struct tagDDLCHANGECOLUMN
	{
	char		*szTable;
	char		*szColumn;
	JET_COLTYP	coltypNew;
	JET_GRBIT	grbitNew;
	} JET_DDLCHANGECOLUMN;

typedef struct tagDDLMAXCOLUMNSIZE
	{
	char			*szTable;
	char			*szColumn;
	unsigned long	cbMax;
	} JET_DDLMAXCOLUMNSIZE;

typedef struct tagDDLADDCONDITIONALCOLUMNSTOALLINDEXES
	{
	char					* szTable;					// name of table to convert
	JET_CONDITIONALCOLUMN 	* rgconditionalcolumn;		// pointer to conditional column structure
	unsigned long			cConditionalColumn;			// number of conditional columns
	} JET_DDLADDCONDITIONALCOLUMNSTOALLINDEXES;

typedef struct tagDDLADDCOLUMCALLBACK
	{
	char			*szTable;
	char			*szColumn;
	char			*szCallback;
	void			*pvCallbackData;
	unsigned long	cbCallbackData;
	} JET_DDLADDCOLUMNCALLBACK;

typedef struct tagDDLINDEXDENSITY
	{
	char			*szTable;
	char			*szIndex;		//	pass NULL to change density of primary index
	unsigned long	ulDensity;
	} JET_DDLINDEXDENSITY;



//	The caller need to setup JET_OLP with a signal wait for the signal to be set.

typedef struct {
	void	*pvReserved1;		// internally use
	void	*pvReserved2;
	unsigned long cbActual;		// the actual number of bytes read through this IO
	JET_HANDLE	hSig;			// a manual reset signal to wait for the IO to complete.
	JET_ERR		err;				// Err code for this assync IO.
	} JET_OLP;


#include <pshpack1.h>
#define JET_MAX_COMPUTERNAME_LENGTH 15

typedef struct	{
	char		bSeconds;				//	0 - 60
	char		bMinutes;				//	0 - 60
	char		bHours;					//	0 - 24
	char		bDay;					//	1 - 31
	char		bMonth;					//	0 - 11
	char		bYear;					//	current year - 1900
	char		bFiller1;
	char		bFiller2;
	} JET_LOGTIME;

typedef struct
	{
	unsigned short	ib;				// must be the last so that lgpos can
	unsigned short	isec;			// index of disksec starting logsec
	long 			lGeneration;	// generation of logsec
	} JET_LGPOS;					// be casted to TIME.

typedef struct
	{
	unsigned long	ulRandom;			//	a random number
	JET_LOGTIME		logtimeCreate;		//	time db created, in logtime format
	char			szComputerName[ JET_MAX_COMPUTERNAME_LENGTH + 1 ];	// where db is created
	} JET_SIGNATURE;

typedef struct
	{
	JET_LGPOS		lgposMark;			//	id for this backup
	JET_LOGTIME		logtimeMark;
	unsigned long	genLow;
	unsigned long	genHigh;
	} JET_BKINFO;

#include <poppack.h>

typedef struct {
	unsigned long	ulVersion;		//	version of DAE the db created (see ulDAEVersion)
	unsigned long	ulUpdate;			//	used to track incremental database format updates that
										//	are backward-compatible (see ulDAEUpdate)
	JET_SIGNATURE	signDb;			//	(28 bytes) signature of the db (incl. creation time).
	unsigned long	dbstate;		//	consistent/inconsistent state

	JET_LGPOS		lgposConsistent;	//	null if in inconsistent state
	JET_LOGTIME		logtimeConsistent;	// null if in inconsistent state

	JET_LOGTIME		logtimeAttach;	//	Last attach time.
	JET_LGPOS		lgposAttach;

	JET_LOGTIME		logtimeDetach;	//	Last detach time.
 	JET_LGPOS		lgposDetach;

	JET_SIGNATURE	signLog;		//	(28 bytes) log signature for this attachments

	JET_BKINFO		bkinfoFullPrev;	//	Last successful full backup.

	JET_BKINFO		bkinfoIncPrev;	//	Last successful Incremental backup.
									//	Reset when bkinfoFullPrev is set
	JET_BKINFO		bkinfoFullCur;	//	current backup. Succeed if a
									//	corresponding pat file generated.
	unsigned long	fShadowingDisabled;
	unsigned long	fUpgradeDb;

	//	NT version information. This is needed to decide if an index need
	//	be recreated due to sort table changes.

	unsigned long	dwMajorVersion;		/*	OS version info								*/
	unsigned long	dwMinorVersion;
	unsigned long	dwBuildNumber;
	long			lSPNumber;

	unsigned long	cbPageSize;			//	database page size (0 = 4k pages)

	} JET_DBINFOMISC;


typedef struct {

	unsigned long	cpageOwned;		//	number of owned pages in the streaming file
	unsigned long	cpageAvail;		//	number of available pages in the streaming file (subset of cpageOwned)

	} JET_STREAMINGFILESPACEINFO;



//typedef struct
//	{
//	unsigned long	cDiscont;
//	unsigned long	cUnfixedMessyPage;
//	unsigned long	centriesLT;
//	unsigned long	centriesTotal;
//	unsigned long	cpgCompactFreed;
//	} JET_OLCSTAT;

/************************************************************************/
/*************************     JET CONSTANTS	 ************************/
/************************************************************************/

#define	JET_instanceNil				(~(JET_INSTANCE)0)
#define	JET_sesidNil				(~(JET_SESID)0)
#define JET_tableidNil				(~(JET_TABLEID)0)
#define JET_columnidNil				(~(JET_COLUMNID)0)


	/* Max size of a bookmark */

#define JET_cbBookmarkMost			256

	/* Max length of a object/column/index/property name */

#define JET_cbNameMost				64

	/* Max length of a "name.name.name..." construct */

#define JET_cbFullNameMost			255

	/* Max size of long-value (LongBinary or LongText) column chunk */

//	#define JET_cbColumnLVChunkMost		( JET_cbPage - 82 ) to the following:
//	Get cbPage from GetSystemParameter.
// 	changed JET_cbColumnLVChunkMOst reference to cbPage - JET_cbColumnLVPageOverhead

#define JET_cbColumnLVPageOverhead	82
#define JET_cbColumnLVChunkMost		( 4096 - 82 ) // This def will be removed after other components change not to use this def
#define JET_cbColumnLVChunkMost_OLD	4035

	/* Max size of long-value (LongBinary or LongText) column default value */

#define JET_cbLVDefaultValueMost	255

	/* Max size of non-long-value column data */

#define JET_cbColumnMost			255

	/* Max size of a sort/index key */

#define JET_cbKeyMost				255
#define JET_cbLimitKeyMost			256				//	maximum key size when key is formed using a Limit grbit (eg. JET_bitStrLimit)
#define JET_cbPrimaryKeyMost		255
#define JET_cbSecondaryKeyMost		255
#define JET_cbKeyMost_OLD			255

	/* Max number of components in a sort/index key */

#define JET_ccolKeyMost				12

//	maximum number of columns
#define JET_ccolMost				0x0000fee0
#define JET_ccolFixedMost			0x0000007f
#define JET_ccolVarMost				0x00000080
#define JET_ccolTaggedMost			( JET_ccolMost - 0x000000ff )

//  event logging level (only on and off for now - will add more in the future)
#define JET_EventLoggingDisable		0
#define JET_EventLoggingLevelMax	100

//	system paramters
//
//	location parameters
//
#define JET_paramSystemPath						0	//	path to check point file [".\\"]
#define JET_paramTempPath						1	//	path to the temporary database [".\\"]
#define JET_paramLogFilePath 					2	//	path to the log file directory [".\\"]
#define JET_paramBaseName						3	//	base name for all DBMS object names ["edb"]
#define JET_paramEventSource					4	//	language independent process descriptor string [""]

//	performance parameters
//
#define JET_paramMaxSessions					5	//	maximum number of sessions [16]
#define JET_paramMaxOpenTables  				6	//	maximum number of open directories [300]
													//  	need 1 for each open table index,
													//  	plus 1 for each open table with no indexes,
													//  	plus 1 for each table with long column data,
													//  	plus a few more.
													//		for 4.1, 1/3 for regular table, 2/3 for index
#define JET_paramPreferredMaxOpenTables			7	//	preferred maximum number of open directories [300]
#define JET_paramMaxCursors						8	//	maximum number of open cursors [1024]
#define JET_paramMaxVerPages					9	//	maximum version store size in 16kByte units [64]
#define JET_paramPreferredVerPages				63	//	preferred version store size in 16kByte units [64 * 0.9]
#define JET_paramGlobalMinVerPages				81	//	minimum version store size for all instances in 16kByte units [64]
#define JET_paramVersionStoreTaskQueueMax		105	//	maximum number of tasks in the task queue before start dropping the tasks [32]
#define JET_paramMaxTemporaryTables				10	//	maximum concurrent open temporary table/index creation [20]
#define JET_paramLogFileSize					11	//	log file size in kBytes [5120]
#define JET_paramLogBuffers						12	//	log buffers in 512 bytes [80]
#define JET_paramWaitLogFlush					13	//	log flush wait time in milliseconds [0] DEFUNCT
#define JET_paramLogCheckpointPeriod			14	//	checkpoint period in 512 bytes [1024] DEFUNCT
#define JET_paramLogWaitingUserMax				15	//	maximum sessions waiting log flush [3] DEFUNCT
#define JET_paramCommitDefault					16	//	default grbit for JetCommitTransaction [0]
#define JET_paramCircularLog					17	//	boolean flag for circular logging [0]
#define JET_paramDbExtensionSize				18	//	database extension size in pages [256] DEFUNCT
#define JET_paramPageTempDBMin					19  //	minimum size temporary database in pages [0] DEFUNCT
#define JET_paramPageFragment					20	//	maximum disk extent considered fragment in pages [8] DEFUNCT
#define JET_paramPageReadAheadMax				21	//	maximum read-ahead in pages [20] DEFUNCT

//  cache performance parameters
//
#define JET_paramBatchIOBufferMax				22	//	maximum batch I/O buffers in pages [64] DEFUNCT
#define JET_paramCacheSize						41	//	current cache size in pages [512]
#define JET_paramCacheSizeMin					60	//	minimum cache size in pages [64]
#define JET_paramCacheSizeMax					23	//	maximum cache size in pages [512]
#define JET_paramCheckpointDepthMax				24	//	maximum checkpoint depth in bytes [20MB]
#define JET_paramLRUKCorrInterval				25  //	time (usec) under which page accesses are correlated [128000], it was 10000
#define JET_paramLRUKHistoryMax					26  //	maximum LRUK history records [1024] (proportional to cache size max) DEFUNCT
#define JET_paramLRUKPolicy						27  //	K-ness of LRUK page eviction algorithm (1...2) [2]
#define JET_paramLRUKTimeout					28  //	time (sec) after which cached pages are always evictable [100]
#define JET_paramLRUKTrxCorrInterval			29  //	Not Used: time (usec) under which page accesses by the same transaction are correlated [5000000] DEFUNCT
#define JET_paramOutstandingIOMax				30	//	maximum outstanding I/Os [64] DEFUNCT
#define JET_paramStartFlushThreshold			31	//	evictable pages at which to start a flush [100] (proportional to CacheSizeMax)
#define JET_paramStopFlushThreshold				32	//	evictable pages at which to stop a flush [400] (proportional to CacheSizeMax)
#define JET_paramTableClassName					33  //	table stats class name (class #, string)
#define JET_paramIdleFlushTime					106 //  time interval (msec) over which all dirty pages should be written to disk after idle conditions are detected.  [0]
#define JET_paramVAReserve						109 //  amount of address space (bytes) to reserve from use by the cache [0]

//	debug only parameters
//
#define JET_paramRecovery						34	//	enable recovery [-1]
#define JET_paramOnLineCompact					35	//	enable online defrag [TRUE by default]
#define JET_paramEnableOnlineDefrag				35	//	enable online defrag [TRUE by default]
#define JET_paramAssertAction					36	//	action on assert
#define	JET_paramPrintFunction					37	//	synched print function [NULL]
#define JET_paramTransactionLevel				38	//	transaction level of session
#define JET_paramRFS2IOsPermitted				39  //	#IOs permitted to succeed [-1 = all]
#define JET_paramRFS2AllocsPermitted			40  //	#allocs permitted to success [-1 = all]
//												41	//	JET_paramCacheSize defined above
#define JET_paramCacheRequests					42  //	#cache requests (Read Only)
#define JET_paramCacheHits						43  //	#cache hits (Read Only)

//	Application specific parameter
//
#define JET_paramCheckFormatWhenOpenFail		44	//	JetInit may return JET_errDatabaseXXXformat instead of database corrupt when it is set
#define JET_paramEnableTempTableVersioning		46	//	Enable versioning of temp tables (TRUE by default)
#define JET_paramIgnoreLogVersion				47	//	Do not check the log version
#define JET_paramDeleteOldLogs					48	//	Delete the log files if the version is old, after deleting may make database non-recoverable
#define JET_paramEventSourceKey					49	//	Event source registration key value
#define JET_paramNoInformationEvent				50	//	Disable logging information event [ FALSE by default ]
#define JET_paramEventLoggingLevel				51	//	Set the type of information that goes to event log [ eventLoggingLevelMax by default ]
#define JET_paramDeleteOutOfRangeLogs			52	//	Delete the log files that are not matching (generation wise) during soft recovery [false]
#define JET_paramAccessDeniedRetryPeriod		53	//	Number of milliseconds to retry when about to fail with AccessDenied [10000 milliseconds]

//	Index-checking parameters
//
//	Different versions of windows normalize unicode text in different ways. That means indexes built under one version of Windows may
//	not work on other versions. Windows server 2003 Beta 3 introduced an API which can be used to determine the version of unicode normalization
//	that the OS currently provides. Indexes built in server 2003 are flagged with the version of unicode normalization that they were
//	built with (older indexes have no version information). Most unicode normalization changes consist of adding new characters -- codepoints
//	which were previously undefined are defined and normalize differently. Thus, if binary data is stored in a unicode column it will normalize
//	differently as new codepoints are defined.
//
//	As of Windows Server 2003 RC1 Jet tracks unicode index entries that contain undefined codepoints. These can be used to fixup an index when the
//	set of defined unicode characters changes.
//
//	These parameters control what happens when Jet attaches to a database that was last used under a different build of the OS (the OS version
//	is stamped in the database header).
//
//	If JET_paramEnableIndexChecking is TRUE JetAttachDatabase() will delete indexes if JET_bitDbDeleteCorruptIndexes or return an error if
//	the grbit was not specified and there are indexes which need deletion. If it is set to FALSE then JetAttachDatabase() will succeed, even
//	if there are potentially corrupt indexes.
//
//	If JET_paramEnableIndexCleanup is set, the internal fixup table will be used to fixup index entries. This may not fixup all index corruptions
//	but will be transparent to the application.
//

#define JET_paramEnableIndexChecking			45  //	Enable checking OS version for indexes (FALSE by default)
#define JET_paramEnableIndexCleanup				54  //	Enable cleanup of out-of-date index entries (TRUE by default)

//												60	//	JET_paramCacheSizeMin defined above
#define JET_paramLogFileFailoverPath			61	//	path to use if the log file disk should fail [none]
#define JET_paramEnableImprovedSeekShortcut		62  //	check to see if we are seeking for the record we are currently on [false]
//												63	//	JET_paramPreferredVerPages defined above
#define JET_paramDatabasePageSize				64	//	set database page size
#define JET_paramDisableCallbacks				65	//	turn off callback resolution (for defrag/repair)
#define JET_paramDisablePerfmon					107 //  disable perfmon support for this process [FALSE]
#define JET_paramAbortRetryFailCallback			108 //  I/O error callback (JET_ABORTRETRYFAILCALLBACK) [NULL]

//  Backup performance parameters
//
#define JET_paramBackupChunkSize				66  //	backup read size in pages [16]
#define JET_paramBackupOutstandingReads			67	//	backup maximum reads outstanding [8]

#define JET_paramSLVProviderEnable				68  //	Enable SLV Provider [0]
#define JET_paramLogFileCreateAsynch			69	//	prepares next log file while logging to the current one to smooth response time [true]
#define JET_paramErrorToString					70  //	turns a JET_err into a string (taken from the comment in jet.h)
#define JET_paramZeroDatabaseDuringBackup		71	//	Overwrite deleted records/LVs during backup [false]
#define JET_paramUnicodeIndexDefault			72	//	default LCMapString() lcid and flags to use for CreateIndex() and unique multi-values check
													//		(pass JET_UNICODEINDEX structure for lParam)
#define JET_paramRuntimeCallback				73	//	pointer to runtime-only callback function
#define JET_paramSLVDefragFreeThreshold	 		74	//	chunks whose free % is > this will be allocated from
#define JET_paramSLVDefragMoveThreshold			75  //	chunks whose free % is > this will be relocated
#define JET_paramEnableSortedRetrieveColumns	76	//	internally sort (in a dynamically allocated parallel array) JET_RETRIEVECOLUMN structures passed to JetRetrieveColumns()
#define JET_paramCleanupMismatchedLogFiles		77	//	instead of erroring out after a successful recovery with JET_errLogFileSizeMismatchDatabasesConsistent, ESE will silently delete the old log files and checkpoint file and continue operations
#define JET_paramRecordUpgradeDirtyLevel		78	//	how aggresively should pages with their record format converted be flushed (0-3) [1]
#define JET_paramRecoveryCurrentLogfile			79	//	which generation is currently being replayed (JetGetSystemParameter only)
#define JET_paramReplayingReplicatedLogfiles	80	//	if a logfile doesn't exist, wait for it to be created
//												81	//	JET_paramGlobalMinVerPages defined above
#define JET_paramOSSnapshotTimeout				82	//	timeout for the freeze period in msec [1000 * 20]
#define JET_paramUnicodeIndexLibrary			83	//	alternate library used for Unicode-index sorting (contains Win32 calls LCMapStringW and CompareStringW; also contains versioning API GetLCMapStringWVer)

#define JET_paramExceptionAction				98	//	what to do with exceptions generated within JET
#define JET_paramEventLogCache					99  //	number of bytes of eventlog records to cache if service is not available [0]
#define JET_paramCreatePathIfNotExist			100	//	create system/temp/log/log-failover paths if they do not exist
#define JET_paramPageHintCacheSize				101 //	maximum size of the fast page latch hint cache in bytes [256kb]
#define JET_paramOneDatabasePerSession			102	//	allow just one open user database per session [false]
#define JET_paramMaxDatabasesPerInstance		103	//	maximum number of databases per instance [6]
#define JET_paramMaxInstances					104	//	maximum number of instances per process [1 for ESENT, 16 for Exchange]
//												105	//	JET_paramVersionStoreTaskQueueMax
//												106 //	JET_paramIdleFlushTime
//												107	//	JET_paramDisablePerfmon
//												108	//	JET_paramAbortRetryFailCallback
//												109	//	JET_paramVAReserve

#define JET_paramIndexTuplesLengthMin			110	//	for tuple indexes, minimum length of a tuple [3]
#define JET_paramIndexTuplesLengthMax			111	//	for tuple indexes, maximum length of a tuple [10]
#define JET_paramIndexTuplesToIndexMax			112	//	for tuple indexes, maximum number of characters in a given string to index [32767]

#define JET_paramAlternateDatabaseRecoveryPath	113	//	recovery-only - search for dirty-shutdown databases in specified location only


//	for backward compatibility
//
#define JET_paramSysDbPath_OLD				0	/* path to the system database (defunct) ["<base name>.<base ext>"] */
#define JET_paramSystemPath_OLD				0	/* path to check point file ["."] */
#define JET_paramTempPath_OLD				1	/* path to the temporary database ["."] */
#define JET_paramMaxBuffers_OLD				8	/* maximum page cache size in pages [512] */
#define JET_paramMaxSessions_OLD			9	/* maximum number of sessions [128] */
#define JET_paramMaxOpenTables_OLD			10	/* maximum number of open tables [300] */
#define JET_paramPreferredMaxOpenTables_OLD	59	/* prefered maximum number of open tables [300] */
#define JET_paramMaxVerPages_OLD			11	/* maximum version store size in 16KB buckets [64] */
#define JET_paramMaxCursors_OLD				12	/* maximum number of open cursors [1024] */
#define JET_paramLogFilePath_OLD			13	/* path to the log file directory ["."] */
#define JET_paramMaxOpenTableIndexes_OLD 	14	/* maximum open table indexes [300] */
#define JET_paramMaxTemporaryTables_OLD		15	/* maximum concurrent JetCreateIndex [20] */
#define JET_paramLogBuffers_OLD				16	/* maximum log buffers in 512 bytes [21] */
#define JET_paramLogFileSize_OLD			17	/* maximum log file size in kBytes [5120] */
#define JET_paramBfThrshldLowPrcnt_OLD		19	/* low percentage clean buffer flush start [20] */
#define JET_paramBfThrshldHighPrcnt_OLD		20	/* high percentage clean buffer flush stop [80] */
#define JET_paramWaitLogFlush_OLD			21	/* log flush wait time in milliseconds [15] */
#define JET_paramLogCheckpointPeriod_OLD	23	/* checkpoint period in 512 bytes [1024] */
#define JET_paramLogWaitingUserMax_OLD		24	/* maximum sessions waiting log flush [3] */
#define JET_paramRecovery_OLD				30	/* Switch for log on/off */
#define JET_paramSessionInfo_OLD			33	/* per session information [0] */
#define JET_paramPageFragment_OLD			34	/* maximum disk extent considered fragment in pages [8] */
#define JET_paramMaxOpenDatabases_OLD		36	/* maximum number of open databases [100] */
#define JET_paramBufBatchIOMax_OLD			41	/* maximum batch IO in pages [64] */
#define JET_paramPageReadAheadMax_OLD		42	/* maximum read-ahead IO in pages [20] */
#define JET_paramAsynchIOMax_OLD			43	/* maximum asynchronous IO in pages [64] */
#define JET_paramEventSource_OLD			45	/* language independant process descriptor string [""] */
#define JET_paramDbExtensionSize_OLD		48	/* database extension size in pages [16] */
#define JET_paramCommitDefault_OLD			50	/* default grbit for JetCommitTransaction [0] */
#define	JET_paramBufLogGenAgeThreshold_OLD	51	/* age threshold in log files [2] */
#define	JET_paramCircularLog_OLD			52	/* boolean flag for circular logging [0] */
#define JET_paramPageTempDBMin_OLD			53  /* minimum size temporary database in pages [0] */
#define JET_paramBaseName_OLD				56  /* base name for all DBMS object names ["edb"] */
#define JET_paramBaseExtension_OLD	  		57  /* base extension for all DBMS object names ["edb"] */
#define JET_paramTableClassName_OLD			58  /* table stats class name (class #, string) */



	/* Flags for JetInit2 */

#define	JET_bitReplayReplicatedLogFiles		0x00000001
//#define JET_bitCreateSFSVolumeIfNotExist	0x00000002
// IGNORE_MISSING_ATTACH, ignoring hanging asserts for missing databases during recovery
#define JET_bitReplayIgnoreMissingDB		0x00000004 /* ignore missing databases */

	/* Flags for JetTerm2 */

#define JET_bitTermComplete				0x00000001
#define JET_bitTermAbrupt				0x00000002
#define JET_bitTermStopBackup			0x00000004

	/* Flags for JetIdle */

#define JET_bitIdleFlushBuffers			0x00000001
#define JET_bitIdleCompact				0x00000002
#define JET_bitIdleStatus				0x00000004
#define JET_bitIdleVersionStoreTest		0x00000008 /* INTERNAL USE ONLY. call version store consistency check */

	/* Flags for JetEndSession */

#define JET_bitForceSessionClosed		0x00000001

	/* Flags for JetAttach/OpenDatabase */

#define JET_bitDbReadOnly				0x00000001
#define JET_bitDbExclusive				0x00000002 /* multiple opens allowed */
#define JET_bitDbSingleExclusive		0x00000002 /* NOT CURRENTLY IMPLEMENTED - currently maps to JET_bitDbExclusive */
#define JET_bitDbDeleteCorruptIndexes	0x00000010 /* delete indexes possibly corrupted by NT version upgrade */
#define JET_bitDbRebuildCorruptIndexes	0x00000020 /* NOT CURRENTLY IMPLEMENTED - recreate indexes possibly corrupted by NT version upgrade */
#define JET_bitDbDeleteUnicodeIndexes	0x00000400 /* delete all indexes with unicode columns */
#define JET_bitDbUpgrade				0x00000200 /* */

	/* Flags for JetDetachDatabase2 */

#define JET_bitForceDetach			  		0x00000001
#define JET_bitForceCloseAndDetach			(0x00000002 | JET_bitForceDetach)

	/* Flags for JetCreateDatabase */

#define JET_bitDbRecoveryOff 			0x00000008 /* disable logging/recovery for this database */
#define JET_bitDbVersioningOff			0x00000040 /* INTERNAL USE ONLY */
#define JET_bitDbShadowingOff			0x00000080 /* disable catalog shadowing */
#define JET_bitDbCreateStreamingFile	0x00000100 /* create streaming file with same name as db */
#define JET_bitDbOverwriteExisting		0x00000200 /* overwrite existing database with same name */

	/* Flags for JetBackup */

#define JET_bitBackupIncremental		0x00000001
#define JET_bitKeepOldLogs				0x00000002
#define JET_bitBackupAtomic				0x00000004
#define JET_bitBackupFullWithAllLogs	0x00000008
#define JET_bitBackupSnapshot			0x00000010

	/* Database types */

#define JET_dbidNil			((JET_DBID) 0xFFFFFFFF)
#define JET_dbidNoValid		((JET_DBID) 0xFFFFFFFE) /* used as a flag to indicate that there is no valid dbid */


	/* Flags for JetCreateTableColumnIndex */
#define JET_bitTableCreateFixedDDL			0x00000001	/* DDL is fixed */
#define JET_bitTableCreateTemplateTable		0x00000002	/* DDL is inheritable (implies FixedDDL) */
#define JET_bitTableCreateNoFixedVarColumnsInDerivedTables	0x00000004
														//	used in conjunction with JET_bitTableCreateTemplateTable
														//	to disallow fixed/var columns in derived tables (so that
														//	fixed/var columns may be added to the template in the future)
#define JET_bitTableCreateSystemTable		0x80000000	/*  INTERNAL USE ONLY */


	/* Flags for JetAddColumn, JetGetColumnInfo, JetOpenTempTable */

#define JET_bitColumnFixed				0x00000001
#define JET_bitColumnTagged				0x00000002
#define JET_bitColumnNotNULL			0x00000004
#define JET_bitColumnVersion			0x00000008
#define JET_bitColumnAutoincrement		0x00000010
#define JET_bitColumnUpdatable			0x00000020 /* JetGetColumnInfo only */
#define JET_bitColumnTTKey				0x00000040 /* JetOpenTempTable only */
#define JET_bitColumnTTDescending		0x00000080 /* JetOpenTempTable only */
#define JET_bitColumnMultiValued		0x00000400
#define JET_bitColumnEscrowUpdate		0x00000800 /* escrow updated */
#define JET_bitColumnUnversioned		0x00001000 /* for add column only - add column unversioned */
#define JET_bitColumnMaybeNull			0x00002000 /* for retrieve column info of outer join where no match from the inner table */
#define JET_bitColumnFinalize			0x00004000 /* this is a finalizable column (issue callback if escrow value equals 0) */
#define JET_bitColumnUserDefinedDefault	0x00008000 /* default value from a user-provided callback */
#define JET_bitColumnRenameConvertToPrimaryIndexPlaceholder	0x00010000	//	FOR JetRenameColumn() ONLY: rename and convert to primary index placeholder (ie. no longer part of primary index ecxept as a placeholder)
#define JET_bitColumnDeleteOnZero		0x00020000 /* this is a finalizable column (delete record if escrow value equals 0) */

//	flags for JetDeleteColumn
#define JET_bitDeleteColumnIgnoreTemplateColumns	0x00000001	//	for derived tables, don't bother looking in template columns


	/* Flags for JetSetCurrentIndex */

#define JET_bitMoveFirst				0x00000000
#define JET_bitMoveBeforeFirst 			0x00000001	// unsupported -- DO NOT USE
#define JET_bitNoMove					0x00000002

	/* Flags for JetMakeKey */

#define JET_bitNewKey					0x00000001
#define JET_bitStrLimit 				0x00000002
#define JET_bitSubStrLimit				0x00000004
#define JET_bitNormalizedKey 			0x00000008
#define JET_bitKeyDataZeroLength		0x00000010
#define JET_bitKeyOverridePrimaryIndexPlaceholder	0x00000020

#define JET_maskLimitOptions			0x00000f00
#define JET_bitFullColumnStartLimit		0x00000100
#define JET_bitFullColumnEndLimit		0x00000200
#define JET_bitPartialColumnStartLimit	0x00000400
#define JET_bitPartialColumnEndLimit	0x00000800

	/* Flags for ErrDispSetIndexRange */

#define JET_bitRangeInclusive			0x00000001
#define JET_bitRangeUpperLimit			0x00000002
#define JET_bitRangeInstantDuration		0x00000004
#define JET_bitRangeRemove				0x00000008

	/* Flags for JetGetLock */

#define JET_bitReadLock					0x00000001
#define JET_bitWriteLock				0x00000002

	/* Constants for JetMove */

#define JET_MoveFirst					(0x80000000)
#define JET_MovePrevious				(-1)
#define JET_MoveNext					(+1)
#define JET_MoveLast					(0x7fffffff)

	/* Flags for JetMove */

#define JET_bitMoveKeyNE				0x00000001

	/* Flags for JetSeek */

#define JET_bitSeekEQ					0x00000001
#define JET_bitSeekLT					0x00000002
#define JET_bitSeekLE					0x00000004
#define JET_bitSeekGE					0x00000008
#define JET_bitSeekGT		 			0x00000010
#define JET_bitSetIndexRange			0x00000020
#define JET_bitCheckUniqueness			0x00000040	//	to be used with JET_bitSeekEQ only, returns JET_wrnUniqueKey if seek lands on a key which has no dupes

	//	Flags for JetGotoSecondaryIndexBookmark
#define JET_bitBookmarkPermitVirtualCurrency	0x00000001	//	place cursor on relative position in index if specified bookmark no longer exists

	/* Flags for JET_CONDITIONALCOLUMN */
#define JET_bitIndexColumnMustBeNull	0x00000001
#define JET_bitIndexColumnMustBeNonNull	0x00000002

	/* Flags for JET_INDEXRANGE */
#define JET_bitRecordInIndex			0x00000001
#define JET_bitRecordNotInIndex			0x00000002

	/* Flags for JetCreateIndex */

#define JET_bitIndexUnique				0x00000001
#define JET_bitIndexPrimary				0x00000002
#define JET_bitIndexDisallowNull		0x00000004
#define JET_bitIndexIgnoreNull			0x00000008
#define JET_bitIndexClustered40			0x00000010	/*	for backward compatibility */
#define JET_bitIndexIgnoreAnyNull		0x00000020
#define JET_bitIndexIgnoreFirstNull		0x00000040
#define JET_bitIndexLazyFlush			0x00000080
#define JET_bitIndexEmpty				0x00000100	// don't attempt to build index, because all entries would evaluate to NULL (MUST also specify JET_bitIgnoreAnyNull)
#define JET_bitIndexUnversioned			0x00000200
#define JET_bitIndexSortNullsHigh		0x00000400	// NULL sorts after data for all columns in the index
#define JET_bitIndexUnicode				0x00000800	// LCID field of JET_INDEXCREATE actually points to a JET_UNICODEINDEX struct to allow user-defined LCMapString() flags
#define JET_bitIndexTuples				0x00001000	// index on substring tuples (text columns only)
#define JET_bitIndexTupleLimits			0x00002000	// cbVarSegMac field of JET_INDEXCREATE actually points to a JET_TUPLELIMITS struct to allow custom tuple index limits (implies JET_bitIndexTuples)

// UNDONE: Remove the following:
// #define JET_bitIndexClustered			JET_bitIndexPrimary	primary index is the clustered index
// #define JET_bitIndexEmptyTable			0x40000000

	/* Flags for index key definition */

#define JET_bitKeyAscending				0x00000000
#define JET_bitKeyDescending			0x00000001

	/* Flags for JetOpenTable */

#define JET_bitTableDenyWrite		0x00000001
#define JET_bitTableDenyRead		0x00000002
#define JET_bitTableReadOnly		0x00000004
#define JET_bitTableUpdatable		0x00000008
#define JET_bitTablePermitDDL		0x00000010	/*  override table flagged as FixedDDL (must be used with DenyRead) */
#define JET_bitTableNoCache			0x00000020	/*	don't cache the pages for this table */
#define JET_bitTablePreread			0x00000040	/*	assume the table is probably not in the buffer cache */
#define JET_bitTableDelete			0x10000000	/*  INTERNAL USE ONLY */
#define JET_bitTableCreate			0x20000000	/*	INTERNAL USE ONLY */

#define JET_bitTableClassMask		0x000F0000	/*  table stats class mask  */
#define JET_bitTableClassNone		0x00000000  /*  table belongs to no stats class (default)  */
#define JET_bitTableClass1			0x00010000  /*  table belongs to stats class 1  */
#define JET_bitTableClass2			0x00020000  /*  table belongs to stats class 2  */
#define JET_bitTableClass3			0x00030000  /*  table belongs to stats class 3  */
#define JET_bitTableClass4			0x00040000  /*  table belongs to stats class 4  */
#define JET_bitTableClass5			0x00050000  /*  table belongs to stats class 5  */
#define JET_bitTableClass6			0x00060000  /*  table belongs to stats class 6  */
#define JET_bitTableClass7			0x00070000  /*  table belongs to stats class 7  */
#define JET_bitTableClass8			0x00080000  /*  table belongs to stats class 8  */
#define JET_bitTableClass9			0x00090000  /*  table belongs to stats class 9  */
#define JET_bitTableClass10			0x000A0000  /*  table belongs to stats class 10  */
#define JET_bitTableClass11			0x000B0000  /*  table belongs to stats class 11  */
#define JET_bitTableClass12			0x000C0000  /*  table belongs to stats class 12  */
#define JET_bitTableClass13			0x000D0000  /*  table belongs to stats class 13  */
#define JET_bitTableClass14			0x000E0000  /*  table belongs to stats class 14  */
#define JET_bitTableClass15			0x000F0000  /*  table belongs to stats class 15  */

#define JET_bitLSReset				0x00000001	/*	reset LS value */
#define JET_bitLSCursor				0x00000002	/*	set/retrieve LS of table cursor */
#define JET_bitLSTable				0x00000004	/*	set/retrieve LS of table */

#define JET_LSNil					(~(JET_LS)0)

	/* Flags for JetOpenTempTable and ErrIsamOpenTempTable */

#define JET_bitTTIndexed			0x00000001	/* Allow seek */
#define JET_bitTTUnique 			0x00000002	/* Remove duplicates */
#define JET_bitTTUpdatable			0x00000004	/* Allow updates */
#define JET_bitTTScrollable			0x00000008	/* Allow backwards scrolling */
#define JET_bitTTSortNullsHigh		0x00000010	/* NULL sorts after data for all columns in the index */
#define JET_bitTTForceMaterialization		0x00000020						/* Forces temp. table to be materialized into a btree (allows for duplicate detection) */
#define JET_bitTTErrorOnDuplicateInsertion	JET_bitTTForceMaterialization	/* Error always returned when duplicate is inserted (instead of dupe being silently removed) */
#define JET_bitTTForwardOnly		0x00000040	/* Prevents temp. table from being materialized into a btree (and enables duplicate keys) */

	/* Flags for JetSetColumn */

#define JET_bitSetAppendLV					0x00000001
#define JET_bitSetOverwriteLV				0x00000004 /* overwrite JET_coltypLong* byte range */
#define JET_bitSetSizeLV					0x00000008 /* set JET_coltypLong* size */
#define JET_bitSetZeroLength				0x00000020
#define JET_bitSetSeparateLV 				0x00000040 /* force LV separation */
#define JET_bitSetUniqueMultiValues			0x00000080 /* prevent duplicate multi-values */
#define JET_bitSetUniqueNormalizedMultiValues	0x00000100 /* prevent duplicate multi-values, normalizing all data before performing comparisons */
#define JET_bitSetRevertToDefaultValue		0x00000200 /* if setting last tagged instance to NULL, revert to default value instead if one exists */
#define JET_bitSetIntrinsicLV				0x00000400 /* store whole LV in record without bursting or return an error */

#define JET_bitSetSLVDataNotRecoverable		0x00001000 /* SLV data is not recoverable */
#define JET_bitSetSLVFromSLVInfo			0x00002000 /*  internal use only  */

	/* Flags for JetSetColumn when the SLV Provider is enabled  */

#define JET_bitSetSLVFromSLVFile			0x00004000 /* set SLV from an SLV File handle */
#define JET_bitSetSLVFromSLVEA				0x00008000 /* set SLV from an SLV EA list */

	/*	Set column parameter structure for JetSetColumns */

typedef struct {
	JET_COLUMNID			columnid;
	const void 				*pvData;
	unsigned long 			cbData;
	JET_GRBIT				grbit;
	unsigned long			ibLongValue;
	unsigned long			itagSequence;
	JET_ERR					err;
} JET_SETCOLUMN;

typedef struct {
	unsigned long	paramid;
	JET_API_PTR		lParam;
	const char		*sz;
	JET_ERR			err;
} JET_SETSYSPARAM;

	/* Options for JetPrepareUpdate */

#define JET_prepInsert						0
#define JET_prepReplace 					2
#define JET_prepCancel						3
#define JET_prepReplaceNoLock				4
#define JET_prepInsertCopy					5
#define JET_prepInsertCopyWithoutSLVColumns	6	//	same as InsertCopy, except that SLV columns are nullified instead of copied in the new record */
#define JET_prepInsertCopyDeleteOriginal	7	//	used for updating a record in the primary key; avoids the delete/insert process */
#define JET_prepReadOnlyCopy				8	//	copy record into copy buffer for read-only purposes

	//	Flags for JetUpdate
#define JET_bitUpdateCheckESE97Compatibility	0x00000001	//	check whether record fix if represented in ESE97 database format

	/* Flags for JetEscrowUpdate */
#define JET_bitEscrowNoRollback				0x0001

	/* Flags for JetRetrieveColumn */

#define JET_bitRetrieveCopy					0x00000001
#define JET_bitRetrieveFromIndex			0x00000002
#define JET_bitRetrieveFromPrimaryBookmark	0x00000004
#define JET_bitRetrieveTag					0x00000008
#define JET_bitRetrieveNull					0x00000010	/*	for columnid 0 only */
#define JET_bitRetrieveIgnoreDefault		0x00000020	/*	for columnid 0 only */
#define JET_bitRetrieveLongId				0x00000040
#define JET_bitRetrieveLongValueRefCount	0x00000080	/*  for testing use only */
#define JET_bitRetrieveSLVAsSLVInfo			0x00000100  /*  internal use only  */

	/* Flags for JetRetrieveColumn when the SLV Provider is enabled  */

#define JET_bitRetrieveSLVAsSLVFile			0x00000200 /* retrieve SLV as an SLV File handle */
#define JET_bitRetrieveSLVAsSLVEA			0x00000400 /* retrieve SLV as an SLV EA list */

	/* Retrieve column parameter structure for JetRetrieveColumns */

typedef struct {
	JET_COLUMNID		columnid;
	void 				*pvData;
	unsigned long 		cbData;
	unsigned long 		cbActual;
	JET_GRBIT			grbit;
	unsigned long		ibLongValue;
	unsigned long		itagSequence;
	JET_COLUMNID		columnidNextTagged;
	JET_ERR				err;
} JET_RETRIEVECOLUMN;


typedef struct
	{
	JET_COLUMNID			columnid;
	unsigned short			cMultiValues;

	union
		{
		unsigned short		usFlags;
		struct
			{
			unsigned short	fLongValue:1;			//	is column LongText/Binary?
			unsigned short	fDefaultValue:1;		//	was a default value retrieved?
			unsigned short	fNullOverride:1;		//	was there an explicit null to override a default value?
			unsigned short	fDerived:1;				//	was column derived from template table?
			};
		};
	} JET_RETRIEVEMULTIVALUECOUNT;


	/* Flags for JetEnumerateColumns */

#define JET_bitEnumerateCopy				JET_bitRetrieveCopy
#define JET_bitEnumerateIgnoreDefault		JET_bitRetrieveIgnoreDefault
#define JET_bitEnumerateLocal				0x00010000
#define JET_bitEnumeratePresenceOnly		0x00020000
#define JET_bitEnumerateTaggedOnly			0x00040000
#define JET_bitEnumerateCompressOutput		0x00080000

	/* Parameter structures for JetEnumerateColumns */

typedef struct {
	JET_COLUMNID			columnid;
	unsigned long			ctagSequence;
	unsigned long*			rgtagSequence;
} JET_ENUMCOLUMNID;

typedef struct {
	unsigned long			itagSequence;
	JET_ERR					err;
	unsigned long			cbData;
	void*					pvData;
} JET_ENUMCOLUMNVALUE;

typedef struct {
	JET_COLUMNID			columnid;
	JET_ERR					err;
	union {
		struct { /* err != JET_wrnColumnSingleValue */
			unsigned long			cEnumColumnValue;
			JET_ENUMCOLUMNVALUE*	rgEnumColumnValue;
		};
		struct { /* err == JET_wrnColumnSingleValue */
			unsigned long			cbData;
			void*					pvData;
		};
	};
} JET_ENUMCOLUMN;

	/* Realloc callback for JetEnumerateColumns */

typedef void* (JET_API *JET_PFNREALLOC)( void* pvContext, void* pv, unsigned long cb );


#pragma warning(pop)


	/* Flags for JetBeginTransaction2 */

#define JET_bitTransactionReadOnly		0x00000001	/* transaction will not modify the database */
#define JET_bitDistributedTransaction	0x00000002	/* transaction will require two-phase commit */

	/* Flags for JetCommitTransaction */

#define	JET_bitCommitLazyFlush		0x00000001	/* lazy flush log buffers. */
#define JET_bitWaitLastLevel0Commit	0x00000002	/* wait for last level 0 commit record flushed */
#define JET_bitWaitAllLevel0Commit	0x00000008	/* wait for all level 0 commits to be flushed */
#define JET_bitCommitFlush_OLD		0x00000001	/* commit and flush page buffers. */
#define JET_bitCommitLazyFlush_OLD	0x00000004	/* lazy flush log buffers. */
#define JET_bitWaitLastLevel0Commit_OLD	0x00000010	/* wait for last level 0 commit record flushed */

	/* Flags for JetRollback */

#define JET_bitRollbackAll			0x00000001

	/* Info parameter for JetGetDatabaseInfo */

#define JET_DbInfoFilename			0
#define JET_DbInfoConnect			1
#define JET_DbInfoCountry			2
#define JET_DbInfoLCID				3
#define JET_DbInfoLangid			3		// OBSOLETE: use JET_DbInfoLCID instead
#define JET_DbInfoCp				4
#define JET_DbInfoCollate			5
#define JET_DbInfoOptions			6
#define JET_DbInfoTransactions		7
#define JET_DbInfoVersion			8
#define JET_DbInfoIsam				9
#define JET_DbInfoFilesize			10
#define JET_DbInfoSpaceOwned		11
#define JET_DbInfoSpaceAvailable	12
#define JET_DbInfoUpgrade			13
#define JET_DbInfoMisc				14
#define JET_DbInfoDBInUse			15
#define JET_DbInfoHasSLVFile		16
#define JET_DbInfoPageSize			17

	/* Dbstates from JetGetDatabaseFileInfo */

#define JET_dbstateJustCreated		1
#define JET_dbstateDirtyShutdown	2
#define JET_dbstateInconsistent		JET_dbstateDirtyShutdown
#define JET_dbstateCleanShutdown	3
#define JET_dbstateConsistent		JET_dbstateCleanShutdown
#define JET_dbstateBeingConverted	4
#define JET_dbstateForceDetach		5

	/* Column data types */

#define JET_coltypNil				0
#define JET_coltypBit				1      /* True or False, Never NULL */
#define JET_coltypUnsignedByte		2      /* 1-byte integer, unsigned */
#define JET_coltypShort 			3      /* 2-byte integer, signed */
#define JET_coltypLong				4      /* 4-byte integer, signed */
#define JET_coltypCurrency			5      /* 8 byte integer, signed */
#define JET_coltypIEEESingle		6      /* 4-byte IEEE single precision */
#define JET_coltypIEEEDouble		7      /* 8-byte IEEE double precision */
#define JET_coltypDateTime			8      /* Integral date, fractional time */
#define JET_coltypBinary			9      /* Binary data, < 255 bytes */
#define JET_coltypText				10     /* ANSI text, case insensitive, < 255 bytes */
#define JET_coltypLongBinary		11     /* Binary data, long value */
#define JET_coltypLongText			12     /* ANSI text, long value */
#define JET_coltypSLV				13     /* SLV's */
#define JET_coltypMax				14		/* the number of column types  */
											/* used for validity tests and */
											/* array declarations.		   */

	/* Info levels for JetGetObjectInfo */

#define JET_ObjInfo					0U
#define JET_ObjInfoListNoStats		1U
#define JET_ObjInfoList 			2U
#define JET_ObjInfoSysTabCursor 	3U
#define JET_ObjInfoListACM			4U /* Blocked by JetGetObjectInfo */
#define JET_ObjInfoNoStats			5U
#define JET_ObjInfoSysTabReadOnly	6U
#define JET_ObjInfoRulesLoaded		7U
#define JET_ObjInfoMax				8U

	/* Info levels for JetGetTableInfo */

#define JET_TblInfo				0U
#define JET_TblInfoName			1U
#define JET_TblInfoDbid			2U
#define JET_TblInfoMostMany  	3U
#define JET_TblInfoRvt			4U
#define JET_TblInfoOLC			5U
#define JET_TblInfoResetOLC 	6U
#define JET_TblInfoSpaceUsage	7U
#define JET_TblInfoDumpTable	8U
#define JET_TblInfoSpaceAlloc	9U
#define JET_TblInfoSpaceOwned	10U					// OwnExt
#define JET_TblInfoSpaceAvailable		11U			// AvailExt
#define JET_TblInfoTemplateTableName	12U

	/* Info levels for JetGetIndexInfo and JetGetTableIndexInfo */

#define JET_IdxInfo					0U
#define JET_IdxInfoList 			1U
#define JET_IdxInfoSysTabCursor 	2U
#define JET_IdxInfoOLC				3U
#define JET_IdxInfoResetOLC			4U
#define JET_IdxInfoSpaceAlloc		5U
#define JET_IdxInfoLCID				6U
#define JET_IdxInfoLangid			6U		//	OBSOLETE: use JET_IdxInfoLCID instead
#define JET_IdxInfoCount			7U
#define JET_IdxInfoVarSegMac		8U
#define JET_IdxInfoIndexId			9U

	/* Info levels for JetGetColumnInfo and JetGetTableColumnInfo */

#define JET_ColInfo					0U
#define JET_ColInfoList 			1U
#define JET_ColInfoSysTabCursor 	3U
#define JET_ColInfoBase 			4U
#define JET_ColInfoListCompact 		5U
#define JET_ColInfoByColid			6U
#define JET_ColInfoListSortColumnid 7U		//	same as JET_ColInfoList except PresentationOrder is set to columnid
											//	to force sorting by columnid


	/* Engine Object Types */

#define JET_objtypNil				0
#define JET_objtypTable 			1
#define JET_objtypDb				2
#define JET_objtypContainer			3
#define JET_objtypLongRoot			9	/*  INTERNAL USE ONLY */

	/* Compact Options */

#define JET_bitCompactStats				0x00000020	/* Dump off-line compaction stats (only when progress meter also specified) */
#define JET_bitCompactRepair			0x00000040	/* Don't preread and ignore duplicate keys */
#define JET_bitCompactSLVCopy			0x00000080  /* Recreate SLV file, do not reuse the existing one */

	/* Status Notification Processes */

#define JET_snpRepair					2
#define JET_snpCompact					4
#define JET_snpRestore					8
#define JET_snpBackup					9
#define JET_snpUpgrade					10
#define JET_snpScrub					11
#define JET_snpUpgradeRecordFormat		12


	/* Status Notification Types */

#define JET_sntBegin			5	/* callback for beginning of operation */
#define JET_sntRequirements		7	/* callback for returning operation requirements */
#define JET_sntProgress 		0	/* callback for progress */
#define JET_sntComplete 		6	/* callback for completion of operation */
#define JET_sntFail				3	/* callback for failure during progress */

	/* Exception action */

#define JET_ExceptionMsgBox		0x0001		/* Display message box on exception */
#define JET_ExceptionNone		0x0002		/* Do nothing on exceptions */

	/* AssertAction */

#define JET_AssertExit			0x0000		/* Exit the application */
#define JET_AssertBreak 		0x0001		/* Break to debugger */
#define JET_AssertMsgBox		0x0002		/* Display message box */
#define JET_AssertStop			0x0004		/* Alert and stop */


	//	Online defragmentation options
#define JET_OnlineDefragDisable			0x0000		//	disable online defrag
#define JET_OnlineDefragAllOBSOLETE		0x0001		//	enable online defrag for everything (must be 1 for backward compatibility)
#define JET_OnlineDefragDatabases		0x0002		//	enable online defrag of databases
#define JET_OnlineDefragSpaceTrees		0x0004		//	enable online defrag of space trees
#define JET_OnlineDefragStreamingFiles	0x0008		//	enable online defrag of streaming files
#define JET_OnlineDefragAll				0xffff		//	enable online defrag for everything


	/* Counter flags */			// For XJET only, not for JET97

#define ctAccessPage			1
#define ctLatchConflict			2
#define ctSplitRetry			3
#define ctNeighborPageScanned	4
#define ctSplits				5

/**********************************************************************/
/***********************     ERROR CODES     **************************/
/**********************************************************************/

/* SUCCESS */

#define JET_errSuccess						 0    /* Successful Operation */

/* ERRORS */

#define JET_wrnNyi							-1    /* Function Not Yet Implemented */

/*	SYSTEM errors
/**/
#define JET_errRfsFailure			   		-100  /* Resource Failure Simulator failure */
#define JET_errRfsNotArmed					-101  /* Resource Failure Simulator not initialized */
#define JET_errFileClose					-102  /* Could not close file */
#define JET_errOutOfThreads					-103  /* Could not start thread */
#define JET_errTooManyIO		  			-105  /* System busy due to too many IOs */
#define JET_errTaskDropped					-106  /* A requested async task could not be executed */
#define JET_errInternalError				-107  /* Fatal internal error */

//	BUFFER MANAGER errors
//
#define wrnBFCacheMiss						 200  /*  ese97,esent only:  page latch caused a cache miss  */
#define errBFPageNotCached					-201  /*  page is not cached  */
#define errBFLatchConflict					-202  /*  page latch conflict  */
#define errBFPageCached						-203  /*  page is cached  */
#define wrnBFPageFlushPending				 204  /*  page is currently being written  */
#define wrnBFPageFault						 205  /*  page latch caused a page fault  */
#define wrnBFBadLatchHint					 206  /*  page latch hint was incorrect  */

#define errBFIPageEvicted					-250  /*  ese97,esent only:  page evicted from the cache  */
#define errBFIPageCached					-251  /*  ese97,esent only:  page already cached  */
#define errBFIOutOfOLPs						-252  /*  ese97,esent only:  out of OLPs  */
#define errBFIOutOfBatchIOBuffers			-253  /*  ese97,esent only:  out of Batch I/O Buffers  */
#define errBFINoBufferAvailable				-254  /*  no buffer available for immediate use  */
#define JET_errDatabaseBufferDependenciesCorrupted	-255	/* Buffer dependencies improperly set. Recovery failure */
#define errBFIRemainingDependencies			-256  /*  dependencies remain on this buffer  */
#define errBFIPageFlushPending				-257  /*  page is currently being written  */
#define errBFIPageNotEvicted				-258  /*  the page could not be evicted from the cache  */
#define errBFIPageFlushed					-259  /*  page write initiated  */
#define errBFIPageFaultPending				-260  /*  page is currently being read  */
#define errBFIPageNotVerified				-261  /*  page data has not been verified  */
#define errBFIDependentPurged				-262  /*  page cannot be flushed due to purged dependencies  */

//  VERSION STORE errors
//
#define wrnVERRCEMoved						 275  /*  RCE was moved instead of being cleaned */

/*	DIRECTORY MANAGER errors
/**/
#define errPMOutOfPageSpace					-300  /* Out of page space */
#define errPMItagTooBig 		  			-301  /* Itag too big */					//  XXX -- to be deleted
#define errPMRecDeleted 		  			-302  /* Record deleted */					//  XXX -- to be deleted
#define errPMTagsUsedUp 		  			-303  /* Tags used up */					//  XXX -- to be deleted
#define wrnBMConflict			  			 304  /* conflict in BM Clean up */
#define errDIRNoShortCircuit	  			-305  /* No Short Circuit Avail */
#define errDIRCannotSplit		  			-306  /* Cannot horizontally split FDP */
#define errDIRTop				  			-307  /* Cannot go up */
#define errDIRFDP							 308  /* On an FDP Node */
#define errDIRNotSynchronous				-309  /* May have left critical section */
#define wrnDIREmptyPage						 310  /* Moved through empty page */
#define errSPConflict						-311  /* Device extent being extended */
#define wrnNDFoundLess						 312  /* Found Less */
#define wrnNDFoundGreater					 313  /* Found Greater */
#define wrnNDNotFoundInPage					 314  /* for smart refresh */
#define errNDNotFound						-312  /* Not found */
#define errNDOutSonRange					-314  /* Son out of range */
#define errNDOutItemRange					-315  /* Item out of range */
#define errNDGreaterThanAllItems 			-316  /* Greater than all items */
#define errNDLastItemNode					-317  /* Last node of item list */
#define errNDFirstItemNode					-318  /* First node of item list */
#define wrnNDDuplicateItem					 319  /* Duplicated Item */
#define errNDNoItem							-320  /* Item not there */
#define JET_wrnRemainingVersions 			 321  /* The version store is still active */
#define JET_errPreviousVersion				-322  /* Version already existed. Recovery failure */
#define JET_errPageBoundary					-323  /* Reached Page Boundary */
#define JET_errKeyBoundary		  			-324  /* Reached Key Boundary */
#define errDIRInPageFather  				-325  /* sridFather in page to free */
#define	errBMMaxKeyInPage					-326  /* used by OLC to avoid cleanup of parent pages */
#define	JET_errBadPageLink					-327  /* Database corrupted */
#define	JET_errBadBookmark					-328  /* Bookmark has no corresponding address in database */
#define wrnBMCleanNullOp					 329  // BMClean returns this on encountering a page
												  // deleted MaxKeyInPage [but there was no conflict]
#define errBTOperNone						-330  // Split with no accompanying
												  // insert/replace
#define errSPOutOfAvailExtCacheSpace		-331  // unable to make update to AvailExt tree since
												  // in-cursor space cache is depleted
#define errSPOutOfOwnExtCacheSpace			-332  // unable to make update to OwnExt tree since
												  // in-cursor space cache is depleted
#define	wrnBTMultipageOLC					 333  // needs multipage OLC operation
#define JET_errNTSystemCallFailed 			-334  /* A call to the operating system failed */
#define wrnBTShallowTree					 335  // BTree is only one or two levels deeps
#define errBTMergeNotSynchronous			-336  // Multiple threads attempting to perform merge/split on same page (likely OLD vs. RCEClean)
#define wrnSPReservedPages					 337  // space manager reserved pages for future space tree splits
#define	JET_errBadParentPageLink			-338  /* Database corrupted */
#define wrnSPBuildAvailExtCache				 339  // AvailExt tree is sufficiently large that it should be cached
#define JET_errSPAvailExtCacheOutOfSync		-340  // AvailExt cache doesn't match btree
#define JET_errSPAvailExtCorrupted			-341  // AvailExt space tree is corrupt
#define JET_errSPAvailExtCacheOutOfMemory	-342  // Out of memory allocating an AvailExt cache node
#define JET_errSPOwnExtCorrupted			-343  // OwnExt space tree is corrupt
#define JET_errDbTimeCorrupted				-344  // Dbtime on current page is greater than global database dbtime
#define JET_wrnUniqueKey					 345  // seek on non-unique index yielded a unique key

/*	RECORD MANAGER errors
/**/
#define wrnFLDKeyTooBig 					 400  /* Key too big (truncated it) */
#define errFLDTooManySegments				-401  /* Too many key segments */
#define wrnFLDNullKey						 402  /* Key is entirely NULL */
#define wrnFLDOutOfKeys 					 403  /* No more keys to extract */
#define wrnFLDNullSeg						 404  /* Null segment in key */
#define wrnFLDNotPresentInIndex				 405
#define JET_wrnSeparateLongValue			 406  /* Column is a separated long-value */
#define wrnRECLongField 					 407  /* Long value */
#define JET_wrnRecordFoundGreater			JET_wrnSeekNotEqual
#define JET_wrnRecordFoundLess    			JET_wrnSeekNotEqual
#define JET_errColumnIllegalNull  			JET_errNullInvalid
#define wrnFLDNullFirstSeg		   			 408  /* Null first segment in key */
#define JET_errKeyTooBig					-408  /* Key is too large */
#define wrnRECUserDefinedDefault			 409  /* User-defined default value */
#define wrnRECSeparatedLV 					 410  /* LV stored in LV tree */
#define wrnRECIntrinsicLV 					 411  /* LV stored in the record */
#define wrnRECSeparatedSLV					 412  /* SLV stored as a separated LV */
#define wrnRECIntrinsicSLV					 413  /* SLV stored as an intrinsic LV */
#define wrnFLDIndexUpdated					 414	// index update performed
#define wrnFLDOutOfTuples					 415	// no more tuples for current string

/*	LOGGING/RECOVERY errors
/**/
#define JET_errInvalidLoggedOperation		-500  /* Logged operation cannot be redone */
#define JET_errLogFileCorrupt		  		-501  /* Log file is corrupt */
#define errLGNoMoreRecords					-502  /* Last log record read */
#define JET_errNoBackupDirectory 			-503  /* No backup directory given */
#define JET_errBackupDirectoryNotEmpty 		-504  /* The backup directory is not emtpy */
#define JET_errBackupInProgress 			-505  /* Backup is active already */
#define JET_errRestoreInProgress			-506  /* Restore in progress */
#define JET_errMissingPreviousLogFile		-509  /* Missing the log file for check point */
#define JET_errLogWriteFail					-510  /* Failure writing to log file */
#define JET_errLogDisabledDueToRecoveryFailure	-511 /* Try to log something after recovery faild */
#define JET_errCannotLogDuringRecoveryRedo	-512	/* Try to log something during recovery redo */
#define JET_errLogGenerationMismatch		-513  /* Name of logfile does not match internal generation number */
#define JET_errBadLogVersion  	  			-514  /* Version of log file is not compatible with Jet version */
#define JET_errInvalidLogSequence  			-515  /* Timestamp in next log does not match expected */
#define JET_errLoggingDisabled 				-516  /* Log is not active */
#define JET_errLogBufferTooSmall			-517  /* Log buffer is too small for recovery */
#define errLGNotSynchronous					-518  /* retry to LGLogRec */
#define JET_errLogSequenceEnd				-519  /* Maximum log file number exceeded */
#define JET_errNoBackup						-520  /* No backup in progress */
#define	JET_errInvalidBackupSequence		-521  /* Backup call out of sequence */
#define JET_errBackupNotAllowedYet			-523  /* Cannot do backup now */
#define JET_errDeleteBackupFileFail	   		-524  /* Could not delete backup file */
#define JET_errMakeBackupDirectoryFail 		-525  /* Could not make backup temp directory */
#define JET_errInvalidBackup		 		-526  /* Cannot perform incremental backup when circular logging enabled */
#define JET_errRecoveredWithErrors			-527  /* Restored with errors */
#define JET_errMissingLogFile				-528  /* Current log file missing */
#define JET_errLogDiskFull					-529  /* Log disk full */
#define JET_errBadLogSignature				-530  /* Bad signature for a log file */
#define JET_errBadDbSignature				-531  /* Bad signature for a db file */
#define JET_errBadCheckpointSignature		-532  /* Bad signature for a checkpoint file */
#define	JET_errCheckpointCorrupt			-533  /* Checkpoint file not found or corrupt */
#define	JET_errMissingPatchPage				-534  /* Patch file page not found during recovery */
#define	JET_errBadPatchPage					-535  /* Patch file page is not valid */
#define JET_errRedoAbruptEnded				-536  /* Redo abruptly ended due to sudden failure in reading logs from log file */
#define JET_errBadSLVSignature				-537  /* Signature in SLV file does not agree with database */
#define JET_errPatchFileMissing				-538  /* Hard restore detected that patch file is missing from backup set */
#define JET_errDatabaseLogSetMismatch		-539  /* Database does not belong with the current set of log files */
#define JET_errDatabaseStreamingFileMismatch	-540 /* Database and streaming file do not match each other */
#define JET_errLogFileSizeMismatch			-541  /* actual log file size does not match JET_paramLogFileSize */
#define JET_errCheckpointFileNotFound		-542  /* Could not locate checkpoint file */
#define JET_errRequiredLogFilesMissing		-543  /* The required log files for recovery is missing. */
#define JET_errSoftRecoveryOnBackupDatabase	-544  /* Soft recovery is intended on a backup database. Restore should be used instead */
#define JET_errLogFileSizeMismatchDatabasesConsistent	-545  /* databases have been recovered, but the log file size used during recovery does not match JET_paramLogFileSize */
#define JET_errLogSectorSizeMismatch		-546  /* the log file sector size does not match the current volume's sector size */
#define JET_errLogSectorSizeMismatchDatabasesConsistent	-547  /* databases have been recovered, but the log file sector size (used during recovery) does not match the current volume's sector size */
#define JET_errLogSequenceEndDatabasesConsistent		-548 /* databases have been recovered, but all possible log generations in the current sequence are used; delete all log files and the checkpoint file and backup the databases before continuing */

#define JET_errStreamingDataNotLogged		-549  /* Illegal attempt to replay a streaming file operation where the data wasn't logged. Probably caused by an attempt to roll-forward with circular logging enabled */

#define JET_errDatabaseDirtyShutdown		-550  /* Database was not shutdown cleanly. Recovery must first be run to properly complete database operations for the previous shutdown. */
#define JET_errDatabaseInconsistent			JET_errDatabaseDirtyShutdown	/* OBSOLETE */
#define JET_errConsistentTimeMismatch		-551  /* Database last consistent time unmatched */
#define JET_errDatabasePatchFileMismatch	-552  /* Patch file is not generated from this backup */
#define JET_errEndingRestoreLogTooLow		-553  /* The starting log number too low for the restore */
#define JET_errStartingRestoreLogTooHigh	-554  /* The starting log number too high for the restore */
#define JET_errGivenLogFileHasBadSignature	-555  /* Restore log file has bad signature */
#define JET_errGivenLogFileIsNotContiguous	-556  /* Restore log file is not contiguous */
#define JET_errMissingRestoreLogFiles		-557  /* Some restore log files are missing */
#define JET_wrnExistingLogFileHasBadSignature	558  /* Existing log file has bad signature */
#define JET_wrnExistingLogFileIsNotContiguous	559  /* Existing log file is not contiguous */
#define JET_errMissingFullBackup			-560  /* The database miss a previous full backup befor incremental backup */
#define JET_errBadBackupDatabaseSize		-561  /* The backup database size is not in 4k */
#define JET_errDatabaseAlreadyUpgraded		-562  /* Attempted to upgrade a database that is already current */
#define JET_errDatabaseIncompleteUpgrade	-563  /* Attempted to use a database which was only partially converted to the current format -- must restore from backup */
#define JET_wrnSkipThisRecord				 564  /* INTERNAL ERROR */
#define JET_errMissingCurrentLogFiles		-565  /* Some current log files are missing for continous restore */

#define JET_errDbTimeTooOld						-566  /* dbtime on page smaller than dbtimeBefore in record */
#define JET_errDbTimeTooNew						-567  /* dbtime on page in advence of the dbtimeBefore in record */
#define wrnCleanedUpMismatchedFiles				 568  /* INTERNAL WARNING: indicates that the redo function cleaned up logs/checkpoint because of a size mismatch (see JET_paramCleanupMismatchedLogFiles) */
#define JET_errMissingFileToBackup				-569  /* Some log or patch files are missing during backup */

#define JET_errLogTornWriteDuringHardRestore	-570	/* torn-write was detected in a backup set during hard restore */
#define JET_errLogTornWriteDuringHardRecovery	-571	/* torn-write was detected during hard recovery (log was not part of a backup set) */
#define JET_errLogCorruptDuringHardRestore		-573	/* corruption was detected in a backup set during hard restore */
#define JET_errLogCorruptDuringHardRecovery	 	-574	/* corruption was detected during hard recovery (log was not part of a backup set) */

#define JET_errMustDisableLoggingForDbUpgrade	-575	/* Cannot have logging enabled while attempting to upgrade db */
#define errLGRecordDataInaccessible				-576	/* an incomplete log record was created because all the data to be logged was not accessible */

#define JET_errBadRestoreTargetInstance			-577	/* TargetInstance specified for restore is not found or log files don't match */
#define JET_wrnTargetInstanceRunning			 578	/* TargetInstance specified for restore is running */

#define	JET_errDatabasesNotFromSameSnapshot		-580	/* Databases to be restored are not from the same shadow copy backup */
#define	JET_errSoftRecoveryOnSnapshot			-581	/* Soft recovery on a database from a shadow copy backup set */

#define JET_wrnDatabaseRepaired					 595	/* Database corruption has been repaired */

#define JET_errUnicodeTranslationBufferTooSmall	-601	/* Unicode translation buffer too small */
#define JET_errUnicodeTranslationFail			-602	/* Unicode normalization failed */
#define JET_errUnicodeNormalizationNotSupported	-603	/* OS does not provide support for Unicode normalisation (and no normalisation callback was specified) */

#define JET_errExistingLogFileHasBadSignature	-610	/* Existing log file has bad signature */
#define JET_errExistingLogFileIsNotContiguous	-611	/* Existing log file is not contiguous */

#define JET_errLogReadVerifyFailure			-612  /* Checksum error in log file during backup */
#define JET_errSLVReadVerifyFailure			-613  /* Checksum error in SLV file during backup */

#define JET_errCheckpointDepthTooDeep		-614	//	too many outstanding generations between checkpoint and current generation

#define JET_errRestoreOfNonBackupDatabase	-615	//	hard recovery attempted on a database that wasn't a backup database

#define	errBackupAbortByCaller				-800  /* INTERNAL ERROR: Backup was aborted by client or RPC connection with client failed */
#define	JET_errBackupAbortByServer			-801  /* Backup was aborted by server by calling JetTerm with JET_bitTermStopBackup or by calling JetStopBackup */

#define JET_errInvalidGrbit					-900  /* Invalid parameter */

#define JET_errTermInProgress		  		-1000 /* Termination in progress */
#define JET_errFeatureNotAvailable			-1001 /* API not supported */
#define JET_errInvalidName					-1002 /* Invalid name */
#define JET_errInvalidParameter 			-1003 /* Invalid API parameter */
#define JET_wrnColumnNull					 1004 /* Column is NULL-valued */
#define JET_wrnBufferTruncated				 1006 /* Buffer too small for data */
#define JET_wrnDatabaseAttached 			 1007 /* Database is already attached */
#define JET_errDatabaseFileReadOnly			-1008 /* Tried to attach a read-only database file for read/write operations */
#define JET_wrnSortOverflow					 1009 /* Sort does not fit in memory */
#define JET_errInvalidDatabaseId			-1010 /* Invalid database id */
#define JET_errOutOfMemory					-1011 /* Out of Memory */
#define JET_errOutOfDatabaseSpace 			-1012 /* Maximum database size reached */
#define JET_errOutOfCursors					-1013 /* Out of table cursors */
#define JET_errOutOfBuffers					-1014 /* Out of database page buffers */
#define JET_errTooManyIndexes				-1015 /* Too many indexes */
#define JET_errTooManyKeys					-1016 /* Too many columns in an index */
#define JET_errRecordDeleted				-1017 /* Record has been deleted */
#define JET_errReadVerifyFailure			-1018 /* Checksum error on a database page */
#define JET_errPageNotInitialized			-1019 /* Blank database page */
#define JET_errOutOfFileHandles	 			-1020 /* Out of file handles */
#define JET_errDiskIO						-1022 /* Disk IO error */
#define JET_errInvalidPath					-1023 /* Invalid file path */
#define JET_errInvalidSystemPath			-1024 /* Invalid system path */
#define JET_errInvalidLogDirectory			-1025 /* Invalid log directory */
#define JET_errRecordTooBig					-1026 /* Record larger than maximum size */
#define JET_errTooManyOpenDatabases			-1027 /* Too many open databases */
#define JET_errInvalidDatabase				-1028 /* Not a database file */
#define JET_errNotInitialized				-1029 /* Database engine not initialized */
#define JET_errAlreadyInitialized			-1030 /* Database engine already initialized */
#define JET_errInitInProgress				-1031 /* Database engine is being initialized */
#define JET_errFileAccessDenied 			-1032 /* Cannot access file, the file is locked or in use */
#define JET_errQueryNotSupported			-1034 /* Query support unavailable */				//  XXX -- to be deleted
#define JET_errSQLLinkNotSupported			-1035 /* SQL Link support unavailable */			//  XXX -- to be deleted
#define JET_errBufferTooSmall				-1038 /* Buffer is too small */
#define JET_wrnSeekNotEqual					 1039 /* Exact match not found during seek */
#define JET_errTooManyColumns				-1040 /* Too many columns defined */
#define JET_errContainerNotEmpty			-1043 /* Container is not empty */
#define JET_errInvalidFilename				-1044 /* Filename is invalid */
#define JET_errInvalidBookmark				-1045 /* Invalid bookmark */
#define JET_errColumnInUse					-1046 /* Column used in an index */
#define JET_errInvalidBufferSize			-1047 /* Data buffer doesn't match column size */
#define JET_errColumnNotUpdatable			-1048 /* Cannot set column value */
#define JET_errIndexInUse					-1051 /* Index is in use */
#define JET_errLinkNotSupported 			-1052 /* Link support unavailable */
#define JET_errNullKeyDisallowed			-1053 /* Null keys are disallowed on index */
#define JET_errNotInTransaction 			-1054 /* Operation must be within a transaction */
#define JET_wrnNoErrorInfo					 1055 /* No extended error information */
#define JET_wrnNoIdleActivity		 		 1058 /* No idle activity occured */
#define JET_errTooManyActiveUsers			-1059 /* Too many active database users */
#define JET_errInvalidCountry				-1061 /* Invalid or unknown country code */
#define JET_errInvalidLanguageId			-1062 /* Invalid or unknown language id */
#define JET_errInvalidCodePage				-1063 /* Invalid or unknown code page */
#define JET_errInvalidLCMapStringFlags		-1064 /* Invalid flags for LCMapString() */
#define JET_errVersionStoreEntryTooBig		-1065 /* Attempted to create a version store entry (RCE) larger than a version bucket */
#define JET_errVersionStoreOutOfMemoryAndCleanupTimedOut	-1066 /* Version store out of memory (and cleanup attempt failed to complete) */
#define JET_wrnNoWriteLock					 1067 /* No write lock at transaction level 0 */
#define JET_wrnColumnSetNull		   		 1068 /* Column set to NULL-value */
#define JET_errVersionStoreOutOfMemory		-1069 /* Version store out of memory (cleanup already attempted) */
#define JET_errCurrencyStackOutOfMemory		-1070 /* UNUSED: lCSRPerfFUCB * g_lCursorsMax exceeded (XJET only) */
#define JET_errCannotIndex		 	  		-1071 /* Cannot index escrow column or SLV column */
#define JET_errRecordNotDeleted				-1072 /* Record has not been deleted */
#define JET_errTooManyMempoolEntries		-1073 /* Too many mempool entries requested */
#define JET_errOutOfObjectIDs				-1074 /* Out of btree ObjectIDs (perform offline defrag to reclaim freed/unused ObjectIds) */
#define JET_errOutOfLongValueIDs			-1075 /* Long-value ID counter has reached maximum value. (perform offline defrag to reclaim free/unused LongValueIDs) */
#define JET_errOutOfAutoincrementValues		-1076 /* Auto-increment counter has reached maximum value (offline defrag WILL NOT be able to reclaim free/unused Auto-increment values). */
#define JET_errOutOfDbtimeValues			-1077 /* Dbtime counter has reached maximum value (perform offline defrag to reclaim free/unused Dbtime values) */
#define JET_errOutOfSequentialIndexValues	-1078 /* Sequential index counter has reached maximum value (perform offline defrag to reclaim free/unused SequentialIndex values) */

#define JET_errRunningInOneInstanceMode		-1080 /* Multi-instance call with single-instance mode enabled */
#define JET_errRunningInMultiInstanceMode	-1081 /* Single-instance call with multi-instance mode enabled */
#define JET_errSystemParamsAlreadySet		-1082 /* Global system parameters have already been set */

#define JET_errSystemPathInUse				-1083 /* System path already used by another database instance */
#define JET_errLogFilePathInUse				-1084 /* Logfile path already used by another database instance */
#define JET_errTempPathInUse				-1085 /* Temp path already used by another database instance */
#define JET_errInstanceNameInUse			-1086 /* Instance Name already in use */

#define JET_errInstanceUnavailable			-1090 /* This instance cannot be used because it encountered a fatal error */
#define JET_errDatabaseUnavailable			-1091 /* This database cannot be used because it encountered a fatal error */
#define JET_errInstanceUnavailableDueToFatalLogDiskFull	-1092 /* This instance cannot be used because it encountered a log-disk-full error performing an operation (likely transaction rollback) that could not tolerate failure */

#define JET_errOutOfSessions  				-1101 /* Out of sessions */
#define JET_errWriteConflict				-1102 /* Write lock failed due to outstanding write lock */
#define JET_errTransTooDeep					-1103 /* Transactions nested too deeply */
#define JET_errInvalidSesid					-1104 /* Invalid session handle */
#define JET_errWriteConflictPrimaryIndex	-1105 /* Update attempted on uncommitted primary index */
#define JET_errInTransaction				-1108 /* Operation not allowed within a transaction */
#define JET_errRollbackRequired				-1109 /* Must rollback current transaction -- cannot commit or begin a new one */
#define JET_errTransReadOnly				-1110 /* Read-only transaction tried to modify the database */
#define JET_errSessionWriteConflict			-1111 /* Attempt to replace the same record by two diffrerent cursors in the same session */

#define JET_errRecordTooBigForBackwardCompatibility				-1112 /* record would be too big if represented in a database format from a previous version of Jet */
#define JET_errCannotMaterializeForwardOnlySort					-1113 /* The temp table could not be created due to parameters that conflict with JET_bitTTForwardOnly */

#define JET_errMustCommitDistributedTransactionToLevel0			-1150 /* Attempted to PrepareToCommit a distributed transaction to non-zero level */
#define JET_errDistributedTransactionAlreadyPreparedToCommit	-1151 /* Attempted a write-operation after a distributed transaction has called PrepareToCommit */
#define JET_errNotInDistributedTransaction						-1152 /* Attempted to PrepareToCommit a non-distributed transaction */
#define JET_errDistributedTransactionNotYetPreparedToCommit		-1153 /* Attempted to commit a distributed transaction, but PrepareToCommit has not yet been called */
#define JET_errCannotNestDistributedTransactions				-1154 /* Attempted to begin a distributed transaction when not at level 0 */
#define JET_errDTCMissingCallback								-1160 /* Attempted to begin a distributed transaction but no callback for DTC coordination was specified on initialisation */
#define JET_errDTCMissingCallbackOnRecovery						-1161 /* Attempted to recover a distributed transaction but no callback for DTC coordination was specified on initialisation */
#define JET_errDTCCallbackUnexpectedError						-1162 /* Unexpected error code returned from DTC callback */
#define JET_wrnDTCCommitTransaction								 1163 /* Warning code DTC callback should return if the specified transaction is to be committed */
#define JET_wrnDTCRollbackTransaction							 1164 /* Warning code DTC callback should return if the specified transaction is to be rolled back */

#define JET_errDatabaseDuplicate			-1201 /* Database already exists */
#define JET_errDatabaseInUse				-1202 /* Database in use */
#define JET_errDatabaseNotFound 			-1203 /* No such database */
#define JET_errDatabaseInvalidName			-1204 /* Invalid database name */
#define JET_errDatabaseInvalidPages			-1205 /* Invalid number of pages */
#define JET_errDatabaseCorrupted			-1206 /* Non database file or corrupted db */
#define JET_errDatabaseLocked				-1207 /* Database exclusively locked */
#define	JET_errCannotDisableVersioning		-1208 /* Cannot disable versioning for this database */
#define JET_errInvalidDatabaseVersion		-1209 /* Database engine is incompatible with database */

/*	The following error code are for NT clients only. It will return such error during
 *	JetInit if JET_paramCheckFormatWhenOpenFail is set.
 */
#define JET_errDatabase200Format			-1210 /* The database is in an older (200) format */
#define JET_errDatabase400Format			-1211 /* The database is in an older (400) format */
#define JET_errDatabase500Format			-1212 /* The database is in an older (500) format */

#define JET_errPageSizeMismatch				-1213 /* The database page size does not match the engine */
#define JET_errTooManyInstances				-1214 /* Cannot start any more database instances */
#define JET_errDatabaseSharingViolation		-1215 /* A different database instance is using this database */
#define JET_errAttachedDatabaseMismatch		-1216 /* An outstanding database attachment has been detected at the start or end of recovery, but database is missing or does not match attachment info */
#define JET_errDatabaseInvalidPath			-1217 /* Specified path to database file is illegal */
#define JET_errDatabaseIdInUse				-1218 /* A database is being assigned an id already in use */
#define JET_errForceDetachNotAllowed 		-1219 /* Force Detach allowed only after normal detach errored out */
#define JET_errCatalogCorrupted				-1220 /* Corruption detected in catalog */
#define JET_errPartiallyAttachedDB			-1221 /* Database is partially attached. Cannot complete attach operation */
#define JET_errDatabaseSignInUse			-1222 /* Database with same signature in use */
#define errSkippedDbHeaderUpdate			-1223 /* some db header weren't update becase there were during detach */

#define JET_wrnTableEmpty			 		 1301 /* Opened an empty table */
#define JET_errTableLocked					-1302 /* Table is exclusively locked */
#define JET_errTableDuplicate				-1303 /* Table already exists */
#define JET_errTableInUse					-1304 /* Table is in use, cannot lock */
#define JET_errObjectNotFound				-1305 /* No such table or object */
#define JET_errDensityInvalid				-1307 /* Bad file/index density */
#define JET_errTableNotEmpty				-1308 /* Table is not empty */
#define JET_errInvalidTableId				-1310 /* Invalid table id */
#define JET_errTooManyOpenTables			-1311 /* Cannot open any more tables (cleanup already attempted) */
#define JET_errIllegalOperation 			-1312 /* Oper. not supported on table */
#define JET_errTooManyOpenTablesAndCleanupTimedOut	-1313 /* Cannot open any more tables (cleanup attempt failed to complete) */
#define JET_errObjectDuplicate				-1314 /* Table or object name in use */
#define JET_errInvalidObject				-1316 /* Object is invalid for operation */
#define JET_errCannotDeleteTempTable		-1317 /* Use CloseTable instead of DeleteTable to delete temp table */
#define JET_errCannotDeleteSystemTable		-1318 /* Illegal attempt to delete a system table */
#define JET_errCannotDeleteTemplateTable	-1319 /* Illegal attempt to delete a template table */
#define	errFCBTooManyOpen					-1320 /* Cannot open any more FCB's (cleanup not yet attempted) */
#define	errFCBAboveThreshold				-1321 /* Can only allocate FCB above preferred threshold (cleanup not yet attempted) */
#define JET_errExclusiveTableLockRequired	-1322 /* Must have exclusive lock on table. */
#define JET_errFixedDDL						-1323 /* DDL operations prohibited on this table */
#define JET_errFixedInheritedDDL			-1324 /* On a derived table, DDL operations are prohibited on inherited portion of DDL */
#define JET_errCannotNestDDL				-1325 /* Nesting of hierarchical DDL is not currently supported. */
#define JET_errDDLNotInheritable			-1326 /* Tried to inherit DDL from a table not marked as a template table. */
#define JET_wrnTableInUseBySystem			 1327 /* System cleanup has a cursor open on the table */
#define JET_errInvalidSettings				-1328 /* System parameters were set improperly */
#define JET_errClientRequestToStopJetService			-1329	/* Client has requested stop service */
#define JET_errCannotAddFixedVarColumnToDerivedTable	-1330	/* Template table was created with NoFixedVarColumnsInDerivedTables */
#define errFCBExists						-1331 /* Tried to create an FCB that already exists */
#define errFCBUnusable						-1332 /* Placeholder to mark an FCB that must be purged as unusable */
#define wrnCATNoMoreRecords					 1333 /* Attempted to navigate past the end of the catalog */

#define JET_errIndexCantBuild				-1401 /* Index build failed */
#define JET_errIndexHasPrimary				-1402 /* Primary index already defined */
#define JET_errIndexDuplicate				-1403 /* Index is already defined */
#define JET_errIndexNotFound				-1404 /* No such index */
#define JET_errIndexMustStay				-1405 /* Cannot delete clustered index */
#define JET_errIndexInvalidDef				-1406 /* Illegal index definition */
#define JET_errInvalidCreateIndex	 		-1409 /* Invalid create index description */
#define JET_errTooManyOpenIndexes			-1410 /* Out of index description blocks */
#define JET_errMultiValuedIndexViolation	-1411 /* Non-unique inter-record index keys generated for a multivalued index */
#define JET_errIndexBuildCorrupted			-1412 /* Failed to build a secondary index that properly reflects primary index */
#define JET_errPrimaryIndexCorrupted		-1413 /* Primary index is corrupt. The database must be defragmented */
#define JET_errSecondaryIndexCorrupted		-1414 /* Secondary index is corrupt. The database must be defragmented */
#define JET_wrnCorruptIndexDeleted			 1415 /* Out of date index removed */
#define JET_errInvalidIndexId				-1416 /* Illegal index id */

#define JET_errIndexTuplesSecondaryIndexOnly		-1430	//	tuple index can only be on a secondary index
#define JET_errIndexTuplesOneColumnOnly				-1431	//	tuple index may only have one column in the index
#define JET_errIndexTuplesNonUniqueOnly				-1432	//	tuple index must be a non-unique index
#define JET_errIndexTuplesTextColumnsOnly			-1433	//	tuple index must be on a text column
#define JET_errIndexTuplesVarSegMacNotAllowed		-1434	//	tuple index does not allow setting cbVarSegMac
#define JET_errIndexTuplesInvalidLimits				-1435	//	invalid min/max tuple length or max characters to index specified
#define JET_errIndexTuplesCannotRetrieveFromIndex	-1436	//	cannot call RetrieveColumn() with RetrieveFromIndex on a tuple index
#define JET_errIndexTuplesKeyTooSmall				-1437	//	specified key does not meet minimum tuple length

#define JET_errColumnLong					-1501 /* Column value is long */
#define JET_errColumnNoChunk				-1502 /* No such chunk in long value */
#define JET_errColumnDoesNotFit 			-1503 /* Field will not fit in record */
#define JET_errNullInvalid					-1504 /* Null not valid */
#define JET_errColumnIndexed				-1505 /* Column indexed, cannot delete */
#define JET_errColumnTooBig					-1506 /* Field length is greater than maximum */
#define JET_errColumnNotFound				-1507 /* No such column */
#define JET_errColumnDuplicate				-1508 /* Field is already defined */
#define JET_errMultiValuedColumnMustBeTagged	-1509 /* Attempted to create a multi-valued column, but column was not Tagged */
#define JET_errColumnRedundant				-1510 /* Second autoincrement or version column */
#define JET_errInvalidColumnType			-1511 /* Invalid column data type */
#define JET_wrnColumnMaxTruncated	 		 1512 /* Max length too big, truncated */
#define JET_errTaggedNotNULL				-1514 /* No non-NULL tagged columns */
#define JET_errNoCurrentIndex				-1515 /* Invalid w/o a current index */
#define JET_errKeyIsMade					-1516 /* The key is completely made */
#define JET_errBadColumnId					-1517 /* Column Id Incorrect */
#define JET_errBadItagSequence				-1518 /* Bad itagSequence for tagged column */
#define JET_errColumnInRelationship			-1519 /* Cannot delete, column participates in relationship */
#define JET_wrnCopyLongValue				 1520 /* Single instance column bursted */
#define JET_errCannotBeTagged				-1521 /* AutoIncrement and Version cannot be tagged */
#define wrnLVNoLongValues					 1522 /* Table does not have a long value tree */
#define JET_wrnTaggedColumnsRemaining		 1523 /* RetrieveTaggedColumnList ran out of copy buffer before retrieving all tagged columns */
#define JET_errDefaultValueTooBig			-1524 /* Default value exceeds maximum size */
#define JET_errMultiValuedDuplicate			-1525 /* Duplicate detected on a unique multi-valued column */
#define JET_errLVCorrupted					-1526 /* Corruption encountered in long-value tree */
#define wrnLVNoMoreData						 1527 /* Reached end of LV data */
#define JET_errMultiValuedDuplicateAfterTruncation	-1528 /* Duplicate detected on a unique multi-valued column after data was normalized, and normalizing truncated the data before comparison */
#define JET_errDerivedColumnCorruption		-1529 /* Invalid column in derived table */
#define JET_errInvalidPlaceholderColumn		-1530 /* Tried to convert column to a primary index placeholder, but column doesn't meet necessary criteria */
#define JET_wrnColumnSkipped				 1531 /* Column value(s) not returned because the corresponding column id or itagSequence requested for enumeration was null */
#define JET_wrnColumnNotLocal				 1532 /* Column value(s) not returned because they could not be reconstructed from the data at hand */
#define JET_wrnColumnMoreTags				 1533 /* Column values exist that were not requested for enumeration */
#define JET_wrnColumnTruncated				 1534 /* Column value truncated at the requested size limit during enumeration */
#define JET_wrnColumnPresent				 1535 /* Column values exist but were not returned by request */
#define JET_wrnColumnSingleValue			 1536 /* Column value returned in JET_COLUMNENUM as a result of JET_bitEnumerateCompressOutput */

#define JET_errRecordNotFound				-1601 /* The key was not found */
#define JET_errRecordNoCopy					-1602 /* No working buffer */
#define JET_errNoCurrentRecord				-1603 /* Currency not on a record */
#define JET_errRecordPrimaryChanged			-1604 /* Primary key may not change */
#define JET_errKeyDuplicate					-1605 /* Illegal duplicate key */
#define JET_errAlreadyPrepared				-1607 /* Attempted to update record when record update was already in progress */
#define JET_errKeyNotMade					-1608 /* No call to JetMakeKey */
#define JET_errUpdateNotPrepared			-1609 /* No call to JetPrepareUpdate */
#define JET_wrnDataHasChanged		 		 1610 /* Data has changed */
#define JET_errDataHasChanged				-1611 /* Data has changed, operation aborted */
#define JET_wrnKeyChanged			 		 1618 /* Moved to new key */
#define JET_errLanguageNotSupported			-1619 /* WindowsNT installation does not support language */

#define JET_errTooManySorts					-1701 /* Too many sort processes */
#define JET_errInvalidOnSort				-1702 /* Invalid operation on Sort */
#define JET_errTempFileOpenError			-1803 /* Temp file could not be opened */
#define JET_errTooManyAttachedDatabases 	-1805 /* Too many open databases */
#define JET_errDiskFull 					-1808 /* No space left on disk */
#define JET_errPermissionDenied 			-1809 /* Permission denied */
#define JET_errFileNotFound					-1811 /* File not found */
#define JET_errFileInvalidType				-1812 /* Invalid file type */
#define JET_wrnFileOpenReadOnly				 1813 /* Database file is read only */
#define JET_errAfterInitialization			-1850 /* Cannot Restore after init. */
#define JET_errLogCorrupted					-1852 /* Logs could not be interpreted */
#define JET_errInvalidOperation 			-1906 /* Invalid operation */
#define JET_errAccessDenied					-1907 /* Access denied */
#define JET_wrnIdleFull						 1908 /* Idle registry full */
#define JET_errTooManySplits				-1909 /* Infinite split */
#define	JET_errSessionSharingViolation		-1910 /* Multiple threads are using the same session */
#define JET_errEntryPointNotFound			-1911 /* An entry point in a DLL we require could not be found */
#define	JET_errSessionContextAlreadySet		-1912 /* Specified session already has a session context set */
#define JET_errSessionContextNotSetByThisThread	-1913 /* Tried to reset session context, but current thread did not orignally set the session context */
#define JET_errSessionInUse					-1914 /* Tried to terminate session in use */

#define JET_errRecordFormatConversionFailed	-1915 /* Internal error during dynamic record format conversion */
#define JET_errOneDatabasePerSession		-1916 /* Just one open user database per session is allowed (JET_paramOneDatabasePerSession) */
#define JET_errRollbackError				-1917 /* error during rollback */

#define JET_wrnDefragAlreadyRunning			 2000 /* Online defrag already running on specified database */
#define JET_wrnDefragNotRunning				 2001 /* Online defrag not running on specified database */

#define JET_wrnCallbackNotRegistered         2100 /* Unregistered a non-existant callback function */
#define JET_errCallbackFailed				-2101 /* A callback failed */
#define JET_errCallbackNotResolved			-2102 /* A callback function could not be found */

#define wrnSLVNoStreamingData				 2200 /* Database does not have a streaming file */
#define JET_errSLVSpaceCorrupted			-2201 /* Corruption encountered in space manager of streaming file */
#define JET_errSLVCorrupted					-2202 /* Corruption encountered in streaming file */
#define JET_errSLVColumnDefaultValueNotAllowed	-2203 /* SLV columns cannot have a default value */
#define JET_errSLVStreamingFileMissing		-2204 /* Cannot find streaming file associated with this database */
#define JET_errSLVDatabaseMissing			-2205 /* Streaming file exists, but database to which it belongs is missing */
#define JET_errSLVStreamingFileAlreadyExists	-2206 /* Tried to create a streaming file when one already exists or is already recorded in the catalog */
#define JET_errSLVInvalidPath				-2207 /* Specified path to a streaming file is invalid */
#define JET_errSLVStreamingFileNotCreated	-2208 /* Tried to perform an SLV operation but streaming file was never created */
#define JET_errSLVStreamingFileReadOnly		-2209 /* Attach a readonly streaming file for read/write operations */
#define JET_errSLVHeaderBadChecksum			-2210 /* SLV file header failed checksum verification */
#define JET_errSLVHeaderCorrupted			-2211 /* SLV file header contains invalid information */
#define wrnSLVNoFreePages					 2212 /* No free pages in SLV space tree */
#define JET_errSLVPagesNotFree				-2213 /* Tried to move pages from the Free state when they were not in that state */
#define JET_errSLVPagesNotReserved			-2214 /* Tried to move pages from the Reserved state when they were not in that state */
#define JET_errSLVPagesNotCommitted			-2215 /* Tried to move pages from the Committed state when they were not in that state */
#define JET_errSLVPagesNotDeleted			-2216 /* Tried to move pages from the Deleted state when they were not in that state */
#define JET_errSLVSpaceWriteConflict		-2217 /* Unexpected conflict detected trying to write-latch SLV space pages */
#define JET_errSLVRootStillOpen				-2218 /* The database can not be created/attached because its corresponding SLV Root is still open by another process. */
#define JET_errSLVProviderNotLoaded			-2219 /* The database can not be created/attached because the SLV Provider has not been loaded. */
#define JET_errSLVEAListCorrupt				-2220 /* The specified SLV EA List is corrupted. */
#define JET_errSLVRootNotSpecified			-2221 /* The database cannot be created/attached because the SLV Root Name was omitted */
#define JET_errSLVRootPathInvalid			-2222 /* The specified SLV Root path was invalid. */
#define JET_errSLVEAListZeroAllocation		-2223 /* The specified SLV EA List has no allocated space. */
#define JET_errSLVColumnCannotDelete		-2224 /* Deletion of SLV columns is not currently supported. */
#define JET_errSLVOwnerMapAlreadyExists 	-2225 /* Tried to create a new catalog entry for SLV Ownership Map when one already exists */
#define JET_errSLVSpaceMapAlreadyExists 	-2225 /* OBSOLETE: Renamed to JET_errSLVOwnerMapCorrupted */
#define JET_errSLVOwnerMapCorrupted			-2226 /* Corruption encountered in SLV Ownership Map */
#define JET_errSLVSpaceMapCorrupted			-2226 /* OBSOLETE: Renamed to JET_errSLVOwnerMapCorrupted */
#define JET_errSLVOwnerMapPageNotFound		-2227 /* Corruption encountered in SLV Ownership Map */
#define JET_errSLVSpaceMapPageNotFound		-2227 /* OBSOLETE: Renamed to JET_errSLVOwnerMapPageNotFound */
#define wrnOLDSLVNothingToMove				 2228 /* Nothing in the streaming file can be moved */
#define errOLDSLVUnableToMove				-2228 /* Unable to move a SLV File in the streaming file */
#define JET_errSLVFileStale					-2229 /* The specified SLV File handle belongs to a SLV Root that no longer exists. */
#define JET_errSLVFileInUse					-2230 /* The specified SLV File is currently in use */
#define JET_errSLVStreamingFileInUse		-2231 /* The specified streaming file is currently in use */
#define JET_errSLVFileIO					-2232 /* An I/O error occurred while accessing an SLV File (general read / write failure) */
#define JET_errSLVStreamingFileFull			-2233 /* No space left in the streaming file */
#define JET_errSLVFileInvalidPath			-2234 /* Specified path to a SLV File was invalid */
#define JET_errSLVFileAccessDenied			-2235 /* Cannot access SLV File, the SLV File is locked or is in use */
#define JET_errSLVFileNotFound				-2236 /* The specified SLV File was not found */
#define JET_errSLVFileUnknown				-2237 /* An unknown error occurred while accessing an SLV File */
#define JET_errSLVEAListTooBig				-2238 /* The specified SLV EA List could not be returned because it is too large to fit in the standard EA format.  Retrieve the SLV File as a file handle instead. */
#define JET_errSLVProviderVersionMismatch	-2239 /* The loaded SLV Provider's version does not match the database engine's version. */
#define errSLVInvalidOwnerMapChecksum		-2240 /* checksum in OwnerMap is invalid */
#define wrnSLVDatabaseHeader				 2241 /* Checking the header of a streaming file */
#define errOLDSLVMoveStopped				-2242 /* OLDSLV was stopped in the middle of a move */
#define JET_errSLVBufferTooSmall			-2243 /* Buffer allocated for SLV data or meta-data was too small */

#define JET_errOSSnapshotInvalidSequence	-2401 /* OS Shadow copy API used in an invalid sequence */
#define JET_errOSSnapshotTimeOut			-2402 /* OS Shadow copy ended with time-out */
#define JET_errOSSnapshotNotAllowed			-2403 /* OS Shadow copy not allowed (backup or recovery in progress) */

#define JET_errLSCallbackNotSpecified		-3000 /* Attempted to use Local Storage without a callback function being specified */
#define JET_errLSAlreadySet					-3001 /* Attempted to set Local Storage for an object which already had it set */
#define JET_errLSNotSet						-3002 /* Attempted to retrieve Local Storage from an object which didn't have it set */

/** FILE ERRORS
 **/
//JET_errFileAccessDenied					-1032
//JET_errFileNotFound						-1811
//JET_errInvalidFilename					-1044
#define JET_errFileIOBeyondEOF				-4001 /* a read was issued to a location beyond EOF (writes will expand the file) */
#define JET_errFileIOAbort					-4002 /* instructs the JET_ABORTRETRYFAILCALLBACK caller to abort the specified I/O */
#define JET_errFileIORetry					-4003 /* instructs the JET_ABORTRETRYFAILCALLBACK caller to retry the specified I/O */
#define JET_errFileIOFail					-4004 /* instructs the JET_ABORTRETRYFAILCALLBACK caller to fail the specified I/O */
#define JET_errFileCompressed				-4005 /* read/write access is not supported on compressed files */

/**********************************************************************/
/***********************     PROTOTYPES      **************************/
/**********************************************************************/

#if !defined(_JET_NOPROTOTYPES)

#ifdef __cplusplus
extern "C" {
#endif


JET_ERR JET_API JetInit( JET_INSTANCE *pinstance);
JET_ERR JET_API JetInit2( JET_INSTANCE *pinstance, JET_GRBIT grbit );
JET_ERR JET_API JetInit3(
	JET_INSTANCE *pinstance,
	JET_RSTMAP *rgstmap,
	long crstfilemap,
	JET_GRBIT grbit );

JET_ERR JET_API JetCreateInstance( JET_INSTANCE *pinstance, const char * szInstanceName );
JET_ERR JET_API JetCreateInstance2(
	JET_INSTANCE *pinstance,
	const char * szInstanceName,
	const char * szDisplayName,
	JET_GRBIT grbit );

JET_ERR JET_API JetTerm( JET_INSTANCE instance );
JET_ERR JET_API JetTerm2( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR JET_API JetStopService();
JET_ERR JET_API JetStopServiceInstance( JET_INSTANCE instance );

JET_ERR JET_API JetStopBackup();
JET_ERR JET_API JetStopBackupInstance( JET_INSTANCE instance );

JET_ERR JET_API JetSetSystemParameter(
	JET_INSTANCE	*pinstance,
	JET_SESID		sesid,
	unsigned long	paramid,
	JET_API_PTR		lParam,
	const char		*sz );

JET_ERR JET_API JetGetSystemParameter(
	JET_INSTANCE	instance,
	JET_SESID		sesid,
	unsigned long	paramid,
	JET_API_PTR		*plParam,
	char			*sz,
	unsigned long	cbMax );

JET_ERR JET_API JetEnableMultiInstance( 	JET_SETSYSPARAM *	psetsysparam,
											unsigned long 		csetsysparam,
											unsigned long *		pcsetsucceed);

JET_ERR JET_API JetResetCounter( JET_SESID sesid, long CounterType );

JET_ERR JET_API JetGetCounter( JET_SESID sesid, long CounterType, long *plValue );

JET_ERR JET_API JetBeginSession(
	JET_INSTANCE	instance,
	JET_SESID		*psesid,
	const char		*szUserName,
	const char		*szPassword );

JET_ERR JET_API JetDupSession( JET_SESID sesid, JET_SESID *psesid );

JET_ERR JET_API JetEndSession( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR JET_API JetGetVersion( JET_SESID sesid, unsigned long *pwVersion );

JET_ERR JET_API JetIdle( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR JET_API JetCreateDatabase(
	JET_SESID		sesid,
	const char		*szFilename,
	const char		*szConnect,
	JET_DBID		*pdbid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetCreateDatabase2(
	JET_SESID		sesid,
	const char		*szFilename,
	const unsigned long	cpgDatabaseSizeMax,
	JET_DBID		*pdbid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetCreateDatabaseWithStreaming(
	JET_SESID		sesid,
	const char		*szDbFileName,
	const char		*szSLVFileName,
	const char		*szSLVRootName,
	const unsigned long	cpgDatabaseSizeMax,
	JET_DBID		*pdbid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetAttachDatabase(
	JET_SESID		sesid,
	const char		*szFilename,
	JET_GRBIT		grbit );

JET_ERR JET_API JetAttachDatabase2(
	JET_SESID		sesid,
	const char		*szFilename,
	const unsigned long	cpgDatabaseSizeMax,
	JET_GRBIT		grbit );

JET_ERR JET_API JetAttachDatabaseWithStreaming(
	JET_SESID		sesid,
	const char		*szDbFileName,
	const char		*szSLVFileName,
	const char		*szSLVRootName,
	const unsigned long	cpgDatabaseSizeMax,
	JET_GRBIT		grbit );

JET_ERR JET_API JetDetachDatabase(
	JET_SESID		sesid,
	const char		*szFilename );

JET_ERR JET_API JetDetachDatabase2(
	JET_SESID		sesid,
	const char		*szFilename,
	JET_GRBIT 		grbit);

JET_ERR JET_API JetGetObjectInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_OBJTYP		objtyp,
	const char		*szContainerName,
	const char		*szObjectName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetGetTableInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetCreateTable(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	unsigned long	lPages,
	unsigned long	lDensity,
	JET_TABLEID		*ptableid );

JET_ERR JET_API JetCreateTableColumnIndex(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_TABLECREATE	*ptablecreate );

JET_ERR JET_API JetCreateTableColumnIndex2(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_TABLECREATE2	*ptablecreate );

JET_ERR JET_API JetDeleteTable(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName );

JET_ERR JET_API JetRenameTable(
	JET_SESID sesid,
	JET_DBID dbid,
	const char *szName,
	const char *szNameNew );

JET_ERR JET_API JetGetTableColumnInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetGetColumnInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	const char		*szColumnName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetAddColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName,
	const JET_COLUMNDEF	*pcolumndef,
	const void		*pvDefault,
	unsigned long	cbDefault,
	JET_COLUMNID	*pcolumnid );

JET_ERR JET_API JetDeleteColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName );
JET_ERR JET_API JetDeleteColumn2(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName,
	const JET_GRBIT	grbit );

JET_ERR JET_API JetRenameColumn(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	const char 		*szName,
	const char 		*szNameNew,
	JET_GRBIT		grbit );

JET_ERR JET_API JetSetColumnDefaultValue(
	JET_SESID			sesid,
	JET_DBID			dbid,
	const char			*szTableName,
	const char			*szColumnName,
	const void			*pvData,
	const unsigned long	cbData,
	const JET_GRBIT		grbit );

JET_ERR JET_API JetGetTableIndexInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	void			*pvResult,
	unsigned long	cbResult,
	unsigned long	InfoLevel );

JET_ERR JET_API JetGetIndexInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	const char		*szIndexName,
	void			*pvResult,
	unsigned long	cbResult,
	unsigned long	InfoLevel );

JET_ERR JET_API JetCreateIndex(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	JET_GRBIT		grbit,
	const char		*szKey,
	unsigned long	cbKey,
	unsigned long	lDensity );

JET_ERR JET_API JetCreateIndex2(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_INDEXCREATE	*pindexcreate,
	unsigned long	cIndexCreate );

JET_ERR JET_API JetDeleteIndex(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName );

JET_ERR JET_API JetBeginTransaction( JET_SESID sesid );
JET_ERR JET_API JetBeginTransaction2( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR JET_API JetPrepareToCommitTransaction(
	JET_SESID		sesid,
	const void		* pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit );
JET_ERR JET_API JetCommitTransaction( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR JET_API JetRollback( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR JET_API JetGetDatabaseInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetGetDatabaseFileInfo(
	const char		*szDatabaseName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetOpenDatabase(
	JET_SESID		sesid,
	const char		*szFilename,
	const char		*szConnect,
	JET_DBID		*pdbid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetCloseDatabase(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetOpenTable(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	const void		*pvParameters,
	unsigned long	cbParameters,
	JET_GRBIT		grbit,
	JET_TABLEID		*ptableid );

JET_ERR JET_API JetSetTableSequential(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetResetTableSequential(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetCloseTable( JET_SESID sesid, JET_TABLEID tableid );

JET_ERR JET_API JetDelete( JET_SESID sesid, JET_TABLEID tableid );

JET_ERR JET_API JetUpdate(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvBookmark,
	unsigned long	cbBookmark,
	unsigned long	*pcbActual);

JET_ERR JET_API JetUpdate2(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvBookmark,
	unsigned long	cbBookmark,
	unsigned long	*pcbActual,
	const JET_GRBIT	grbit );

JET_ERR JET_API JetEscrowUpdate(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	void			*pv,
	unsigned long	cbMax,
	void			*pvOld,
	unsigned long	cbOldMax,
	unsigned long	*pcbOldActual,
	JET_GRBIT		grbit );

JET_ERR JET_API JetRetrieveColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	void			*pvData,
	unsigned long	cbData,
	unsigned long	*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo );

JET_ERR JET_API JetRetrieveColumns(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_RETRIEVECOLUMN	*pretrievecolumn,
	unsigned long	cretrievecolumn );

JET_ERR JET_API JetEnumerateColumns(
	JET_SESID				sesid,
	JET_TABLEID				tableid,
	unsigned long			cEnumColumnId,
	JET_ENUMCOLUMNID*		rgEnumColumnId,
	unsigned long*			pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	unsigned long			cbDataMost,
	JET_GRBIT				grbit );

JET_ERR JET_API JetRetrieveTaggedColumnList(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	unsigned long	*pcColumns,
	void			*pvData,
	unsigned long	cbData,
	JET_COLUMNID	columnidStart,
	JET_GRBIT		grbit );

JET_ERR JET_API JetSetColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	const void		*pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit,
	JET_SETINFO		*psetinfo );

JET_ERR JET_API JetSetColumns(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_SETCOLUMN	*psetcolumn,
	unsigned long	csetcolumn );

JET_ERR JET_API JetPrepareUpdate(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	unsigned long	prep );

JET_ERR JET_API JetGetRecordPosition(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_RECPOS		*precpos,
	unsigned long	cbRecpos );

JET_ERR JET_API JetGotoPosition(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_RECPOS		*precpos );

JET_ERR JET_API JetGetCursorInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetDupCursor(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_TABLEID		*ptableid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetGetCurrentIndex(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	char			*szIndexName,
	unsigned long	cchIndexName );

JET_ERR JET_API JetSetCurrentIndex(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName );

JET_ERR JET_API JetSetCurrentIndex2(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	JET_GRBIT		grbit );

JET_ERR JET_API JetSetCurrentIndex3(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	JET_GRBIT		grbit,
	unsigned long	itagSequence );

JET_ERR JET_API JetSetCurrentIndex4(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	JET_INDEXID		*pindexid,
	JET_GRBIT		grbit,
	unsigned long	itagSequence );

JET_ERR JET_API JetMove(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	long			cRow,
	JET_GRBIT		grbit );

JET_ERR JET_API JetGetLock(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetMakeKey(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const void		*pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit );

JET_ERR JET_API JetSeek(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetGetBookmark(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void *			pvBookmark,
	unsigned long	cbMax,
	unsigned long *	pcbActual );

JET_ERR JET_API JetGetSecondaryIndexBookmark(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void *			pvSecondaryKey,
	unsigned long	cbSecondaryKeyMax,
	unsigned long *	pcbSecondaryKeyActual,
	void *			pvPrimaryBookmark,
	unsigned long	cbPrimaryBookmarkMax,
	unsigned long *	pcbPrimaryKeyActual,
	const JET_GRBIT	grbit );

JET_ERR JET_API JetCompact(
	JET_SESID		sesid,
	const char		*szDatabaseSrc,
	const char		*szDatabaseDest,
	JET_PFNSTATUS	pfnStatus,
	JET_CONVERT		*pconvert,
	JET_GRBIT		grbit );

JET_ERR JET_API JetDefragment(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	unsigned long	*pcPasses,
	unsigned long	*pcSeconds,
	JET_GRBIT		grbit );

JET_ERR JET_API JetDefragment2(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	unsigned long	*pcPasses,
	unsigned long	*pcSeconds,
	JET_CALLBACK	callback,
	JET_GRBIT		grbit );

JET_ERR JET_API JetDefragment3(
	JET_SESID		vsesid,
	const char		*szDatabaseName,
	const char		*szTableName,
	unsigned long	*pcPasses,
	unsigned long	*pcSeconds,
	JET_CALLBACK	callback,
	void			*pvContext,
	JET_GRBIT		grbit );

JET_ERR JET_API JetConvertDDL(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_OPDDLCONV	convtyp,
	void			*pvData,
	unsigned long	cbData );

JET_ERR JET_API JetUpgradeDatabase(
	JET_SESID		sesid,
	const char		*szDbFileName,
	const char		*szSLVFileName,
	const JET_GRBIT	grbit );

JET_ERR JET_API JetSetDatabaseSize(
	JET_SESID		sesid,
	const char		*szDatabaseName,
	unsigned long	cpg,
	unsigned long	*pcpgReal );

JET_ERR JET_API JetGrowDatabase(
	JET_SESID		sesid,
	JET_DBID		dbid,
	unsigned long	cpg,
	unsigned long	*pcpgReal );

JET_ERR JET_API JetSetSessionContext(
	JET_SESID		sesid,
	JET_API_PTR		ulContext );

JET_ERR JET_API JetResetSessionContext(
	JET_SESID		sesid );

JET_ERR JET_API JetDBUtilities( JET_DBUTIL *pdbutil );

JET_ERR JET_API JetGotoBookmark(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void *			pvBookmark,
	unsigned long	cbBookmark );

JET_ERR JET_API JetGotoSecondaryIndexBookmark(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void *			pvSecondaryKey,
	unsigned long	cbSecondaryKey,
	void *			pvPrimaryBookmark,
	unsigned long	cbPrimaryBookmark,
	const JET_GRBIT	grbit );

JET_ERR JET_API JetIntersectIndexes(
	JET_SESID sesid,
	JET_INDEXRANGE * rgindexrange,
	unsigned long cindexrange,
	JET_RECORDLIST * precordlist,
	JET_GRBIT grbit );

JET_ERR JET_API JetComputeStats( JET_SESID sesid, JET_TABLEID tableid );

JET_ERR JET_API JetOpenTempTable(JET_SESID sesid,
	const JET_COLUMNDEF *prgcolumndef, unsigned long ccolumn,
	JET_GRBIT grbit, JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid);

JET_ERR JET_API JetOpenTempTable2(
	JET_SESID			sesid,
	const JET_COLUMNDEF	*prgcolumndef,
	unsigned long		ccolumn,
	unsigned long		lcid,
	JET_GRBIT			grbit,
	JET_TABLEID			*ptableid,
	JET_COLUMNID		*prgcolumnid );

JET_ERR JET_API JetOpenTempTable3(
	JET_SESID			sesid,
	const JET_COLUMNDEF	*prgcolumndef,
	unsigned long		ccolumn,
	JET_UNICODEINDEX	*pidxunicode,
	JET_GRBIT			grbit,
	JET_TABLEID			*ptableid,
	JET_COLUMNID		*prgcolumnid );

JET_ERR JET_API JetBackup( const char *szBackupPath, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus );
JET_ERR JET_API JetBackupInstance(	JET_INSTANCE 	instance,
									const char		*szBackupPath,
									JET_GRBIT		grbit,
									JET_PFNSTATUS	pfnStatus );

JET_ERR JET_API JetRestore(const char *sz, JET_PFNSTATUS pfn );
JET_ERR JET_API JetRestore2(const char *sz, const char *szDest, JET_PFNSTATUS pfn );

JET_ERR JET_API JetRestoreInstance( 	JET_INSTANCE instance,
										const char *sz,
										const char *szDest,
										JET_PFNSTATUS pfn );

JET_ERR JET_API JetSetIndexRange(JET_SESID sesid,
	JET_TABLEID tableidSrc, JET_GRBIT grbit);

JET_ERR JET_API JetIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long *pcrec, unsigned long crecMax );

JET_ERR JET_API JetRetrieveKey(JET_SESID sesid,
	JET_TABLEID tableid, void *pvData, unsigned long cbMax,
	unsigned long *pcbActual, JET_GRBIT grbit );

JET_ERR JET_API JetBeginExternalBackup( JET_GRBIT grbit );
JET_ERR JET_API JetBeginExternalBackupInstance( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR JET_API JetGetAttachInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual );
JET_ERR JET_API JetGetAttachInfoInstance(	JET_INSTANCE	instance,
											void			*pv,
											unsigned long	cbMax,
											unsigned long	*pcbActual );

JET_ERR JET_API JetOpenFile( const char *szFileName,
	JET_HANDLE	*phfFile,
	unsigned long *pulFileSizeLow,
	unsigned long *pulFileSizeHigh );

JET_ERR JET_API JetOpenFileInstance( 	JET_INSTANCE instance,
										const char *szFileName,
										JET_HANDLE	*phfFile,
										unsigned long *pulFileSizeLow,
										unsigned long *pulFileSizeHigh );

JET_ERR JET_API JetOpenFileSectionInstance(
										JET_INSTANCE instance,
										char *szFile,
										JET_HANDLE *phFile,
										long iSection,
										long cSections,
										unsigned long *pulSectionSizeLow,
										long *plSectionSizeHigh);

JET_ERR JET_API JetReadFile( JET_HANDLE hfFile,
	void *pv,
	unsigned long cb,
	unsigned long *pcb );
JET_ERR JET_API JetReadFileInstance(	JET_INSTANCE instance,
										JET_HANDLE hfFile,
										void *pv,
										unsigned long cb,
										unsigned long *pcb );
JET_ERR JET_API JetAsyncReadFileInstance(	JET_INSTANCE instance,
											JET_HANDLE hfFile,
											void* pv,
											unsigned long cb,
											JET_OLP *pjolp );

JET_ERR JET_API JetCheckAsyncReadFileInstance( 	JET_INSTANCE instance,
												void *pv,
												int cb,
												unsigned long pgnoFirst );

JET_ERR JET_API JetCloseFile( JET_HANDLE hfFile );
JET_ERR JET_API JetCloseFileInstance( JET_INSTANCE instance, JET_HANDLE hfFile );

JET_ERR JET_API JetGetLogInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual );
JET_ERR JET_API JetGetLogInfoInstance(	JET_INSTANCE instance,
										void *pv,
										unsigned long cbMax,
										unsigned long *pcbActual );

#define JET_BASE_NAME_LENGTH 	3
typedef struct
	{
	unsigned long 	cbSize;
	unsigned long	ulGenLow;
	unsigned long	ulGenHigh;
	char			szBaseName[ JET_BASE_NAME_LENGTH + 1 ];
	} JET_LOGINFO;

JET_ERR JET_API JetGetLogInfoInstance2(	JET_INSTANCE instance,
										void *pv,
										unsigned long cbMax,
										unsigned long *pcbActual,
										JET_LOGINFO * pLogInfo);

JET_ERR JET_API JetGetTruncateLogInfoInstance(	JET_INSTANCE instance,
												void *pv,
												unsigned long cbMax,
												unsigned long *pcbActual );

JET_ERR JET_API JetTruncateLog( void );
JET_ERR JET_API JetTruncateLogInstance( JET_INSTANCE instance );

JET_ERR JET_API JetEndExternalBackup( void );
JET_ERR JET_API JetEndExternalBackupInstance( JET_INSTANCE instance );

/* Flags for JetEndExternalBackupInstance2 */
#define JET_bitBackupEndNormal				0x0001
#define JET_bitBackupEndAbort				0x0002

JET_ERR JET_API JetEndExternalBackupInstance2( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR JET_API JetExternalRestore( 	char *szCheckpointFilePath,
										char *szLogPath,
										JET_RSTMAP *rgstmap,
										long crstfilemap,
										char *szBackupLogPath,
										long genLow,
										long genHigh,
										JET_PFNSTATUS pfn );


JET_ERR JET_API JetExternalRestore2( 	char *szCheckpointFilePath,
										char *szLogPath,
										JET_RSTMAP *rgstmap,
										long crstfilemap,
										char *szBackupLogPath,
										JET_LOGINFO * pLogInfo,
										char *szTargetInstanceName,
										char *szTargetInstanceLogPath,
										char *szTargetInstanceCheckpointPath,
										JET_PFNSTATUS pfn );


JET_ERR JET_API JetSnapshotStart( 		JET_INSTANCE 		instance,
										char * 				szDatabases,
										JET_GRBIT			grbit);

JET_ERR JET_API JetSnapshotStop( 		JET_INSTANCE 		instance,
										JET_GRBIT			grbit);

JET_ERR JET_API JetRegisterCallback(
	JET_SESID               sesid,
	JET_TABLEID             tableid,
	JET_CBTYP               cbtyp,
	JET_CALLBACK    		pCallback,
	void *              	pvContext,
	JET_HANDLE              *phCallbackId );


JET_ERR JET_API JetUnregisterCallback(
	JET_SESID               sesid,
	JET_TABLEID             tableid,
	JET_CBTYP               cbtyp,
	JET_HANDLE              hCallbackId );

typedef struct _JET_INSTANCE_INFO
	{
	JET_INSTANCE		hInstanceId;
	char * 				szInstanceName;

	JET_API_PTR	 		cDatabases;
	char ** 			szDatabaseFileName;
	char ** 			szDatabaseDisplayName;
	char ** 			szDatabaseSLVFileName;
	} JET_INSTANCE_INFO;

JET_ERR JET_API JetGetInstanceInfo( unsigned long *pcInstanceInfo, JET_INSTANCE_INFO ** paInstanceInfo );


JET_ERR JET_API JetFreeBuffer( char *pbBuf );

JET_ERR JET_API JetSetLS(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	JET_LS			ls,
	JET_GRBIT		grbit );

JET_ERR JET_API JetGetLS(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	JET_LS			*pls,
	JET_GRBIT		grbit );

typedef JET_API_PTR JET_OSSNAPID;  	/* Snapshot Session Identifier */

JET_ERR JET_API JetOSSnapshotPrepare( JET_OSSNAPID * psnapId, const JET_GRBIT grbit );
JET_ERR JET_API JetOSSnapshotFreeze( const JET_OSSNAPID snapId, unsigned long *pcInstanceInfo, JET_INSTANCE_INFO ** paInstanceInfo, const JET_GRBIT grbit );
JET_ERR JET_API JetOSSnapshotThaw( const JET_OSSNAPID snapId, const JET_GRBIT grbit );
JET_ERR JET_API JetOSSnapshotAbort( const JET_OSSNAPID snapId, const JET_GRBIT grbit );


#ifdef	__cplusplus
}
#endif

#endif	/* _JET_NOPROTOTYPES */

#include <poppack.h>

#ifdef	__cplusplus
}
#endif

#endif	/* _JET_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\bf.cxx ===
#include "std.hxx"
#include "_bf.hxx"


///////////////////////////////////////////////////////////////////////////////
//
//  BF API Functions
//
///////////////////////////////////////////////////////////////////////////////

/////////////////
//  Init / Term

//  The following functions control the initialization and termination of
//  the buffer manager.

//  Initializes the buffer manager for normal operation.  Must be called
//  only once and BFTerm() must be called before process termination.  If an
//  error is returned, the buffer manager is not initialized.

ERR ErrBFInit()
	{
	ERR err;

	//  validate our configuration

	CallJ( ErrBFIValidateParameters(), Validate );

	//  critical sections

	critBFParm.Enter();

	//  must not have been initialized

	Assert( !fBFInitialized );

	//  reset all stats

	cBFMemory					= 0;
	cBFPageFlushPending			= 0;
	cBFClean					= 0;
	cBFVersioned				= 0;
	cBFResident					= 0;

	//  init all components

	switch ( bfhash.ErrInit(	dblBFHashLoadFactor,
								dblBFHashUniformity ) )
		{
		default:
			AssertSz( fFalse, "Unexpected error initializing BF Hash Table" );
		case BFHash::errOutOfMemory:
			CallJ( ErrERRCheck( JET_errOutOfMemory ), TermLRUK );
		case BFHash::errSuccess:
			break;
		}
	switch ( bfavail.ErrInit( dblBFSpeedSizeTradeoff ) )
		{
		default:
			AssertSz( fFalse, "Unexpected error initializing BF Avail Pool" );
		case BFAvail::errOutOfMemory:
			CallJ( ErrERRCheck( JET_errOutOfMemory ), TermLRUK );
		case BFAvail::errSuccess:
			break;
		}
	switch ( bflruk.ErrInit(	BFLRUKK,
								csecBFLRUKCorrelatedTouch,
								csecBFLRUKTimeout,
								csecBFLRUKUncertainty,
								dblBFHashLoadFactor,
								dblBFHashUniformity,
								dblBFSpeedSizeTradeoff ) )
		{
		default:
			AssertSz( fFalse, "Unexpected error initializing BF LRUK Manager" );
		case BFLRUK::errOutOfMemory:
			CallJ( ErrERRCheck( JET_errOutOfMemory ), TermLRUK );
		case BFLRUK::errSuccess:
			break;
		}
	CallJ( ErrBFICacheInit(), TermLRUK );
	if ( !critpoolBFDUI.FInit( OSSyncGetProcessorCount(), rankBFDUI, szBFDUI ) )
		{
		CallJ( ErrERRCheck( JET_errOutOfMemory ), TermCache );
		}

	//  start all service threads

	CallJ( ErrBFICleanThreadInit(), TermDUI );

	//  init successful

	fBFInitialized = fTrue;
	goto Validate;

	//  term all initialized threads / components

TermDUI:
	critpoolBFDUI.Term();
TermCache:
	BFICacheTerm();
TermLRUK:
	bflruk.Term();
	bfavail.Term();
	bfhash.Term();
Validate:
	Assert(	err == JET_errOutOfMemory ||
			err == JET_errOutOfThreads ||
			err == JET_errSuccess );
	Assert(	( err != JET_errSuccess && !fBFInitialized ) ||
			( err == JET_errSuccess && fBFInitialized ) );

	critBFParm.Leave();
	return err;
	}

//  Terminates the buffer manager.  Must be called before process
//  termination to avoid loss of system resources.  Cannot be called before
//  ErrBFInit().
//
//  NOTE:  To avoid losing changes to pages, you must call ErrBFFlush() before
//  BFTerm()!
//
//  UNDONE:  Calling BFTerm() without calling ErrBFFlush() can cause the loss
//  of any deferred undo information attached to each buffer.  This can result
//  in recovery failure!!!  Should BFTerm() force any existing deferred undo
//  info to disk to prevent this?

void BFTerm()
	{
	//  must have been initialized

	Assert( fBFInitialized );
	fBFInitialized = fFalse;

	//  terminate all service threads

	BFICleanThreadTerm();

	//  critical sections

	critBFParm.Enter();

	//  terminate all components

	critpoolBFDUI.Term();
	BFICacheTerm();
	bflruk.Term();
	bfavail.Term();
	bfhash.Term();

	critBFParm.Leave();
	}


///////////////////////
//  System Parameters

//  The following functions are used to get and set the many system
//  parameters used by the buffer manager during runtime.  Most of these
//  parameters are used for optimizing performance.

//  Returns the minimum size of the cache in pages.

ERR ErrBFGetCacheSizeMin( ULONG_PTR* pcpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcpg == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	*pcpg = (ULONG_PTR)cbfCacheMin;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the current size of the cache in pages.

ERR ErrBFGetCacheSize( ULONG_PTR* pcpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcpg == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	*pcpg = cBFResident;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the maximum size of the cache in pages.

ERR ErrBFGetCacheSizeMax( ULONG_PTR* pcpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcpg == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	*pcpg = (ULONG_PTR)cbfCacheMax;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the maximum permitted checkpoint depth in bytes.  The buffer
//  manager will attempt to aggressively flush any buffer that is holding
//  the checkpoint to a depth greater than this value.

ERR ErrBFGetCheckpointDepthMax( ULONG_PTR* pcb )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcb == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	*pcb = (ULONG_PTR)cbCleanCheckpointDepthMax;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the current duration (in microseconds) of the interval over
//  which multiple accesses of a single page will be considered correlated.
//  A duration of zero implies that no accesses are correlated.

ERR ErrBFGetLRUKCorrInterval( ULONG_PTR* pcusec )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcusec == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	*pcusec = (ULONG_PTR)( 1000000 * csecBFLRUKCorrelatedTouch );
	critBFParm.Leave();
	return JET_errSuccess;
	}

//	Returns the current K-ness of the LRUK page replacement algorithm.

ERR ErrBFGetLRUKPolicy( ULONG_PTR* pcLRUKPolicy )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcLRUKPolicy == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	*pcLRUKPolicy = (ULONG_PTR)BFLRUKK;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the current LRUK Time-out used by the buffer manager.  The LRUK
//  Time-out is the duration (in seconds) since a multiply accessed page was
//  last accessed when that page is considered for eviction from the cache.

ERR ErrBFGetLRUKTimeout( ULONG_PTR* pcsec )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcsec == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	*pcsec = (ULONG_PTR)csecBFLRUKTimeout;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the current count of clean pages at which we will start cleaning
//  buffers.  We will clean buffers until we reach the corresponding stop
//  threshold.

ERR ErrBFGetStartFlushThreshold( ULONG_PTR* pcpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcpg == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	*pcpg = (ULONG_PTR)cbfCleanThresholdStart;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the current count of clean pages at which we will stop cleaning
//  buffers after beginning a flush by dropping below the corresponding start
//  threshold.

ERR ErrBFGetStopFlushThreshold( ULONG_PTR* pcpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcpg == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	*pcpg = (ULONG_PTR)cbfCleanThresholdStop;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the minimum size of the cache in pages.

ERR ErrBFSetCacheSizeMin( ULONG_PTR cpg )
	{
 	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( cpg < 1 )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	cbfCacheMin = cpg;

	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the current (preferred) size of the cache in pages.

ERR ErrBFSetCacheSize( ULONG_PTR cpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  set the user set point

	cbfCacheSetUser = cpg;
	return JET_errSuccess;
	}

//  Sets the maximum size of the cache in pages.

ERR ErrBFSetCacheSizeMax( ULONG_PTR cpg )
	{
 	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( cpg < 1 )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	cbfCacheMax = cpg;

	//  normalize thresholds

	BFINormalizeThresholds();

	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the maximum permitted checkpoint depth in bytes.  The buffer
//  manager will attempt to aggressively flush any buffer that is holding
//  the checkpoint to a depth greater than this value.  The Maximum
//  Checkpoint Depth can be any positive value.  This parameter can be set
//  at any time.
//
//  NOTE:  Setting this value too low may cause excessive flushing of
//  buffers to disk and reduced I/O performance.

ERR ErrBFSetCheckpointDepthMax( ULONG_PTR cb )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( (long)cb < 0 )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	cbCleanCheckpointDepthMax = (long)cb;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the current duration (in microseconds) of the interval over which
//  multiple accesses of a single page will be considered correlated.  A
//  duration of zero implies that no accesses are correlated.  The
//  Correlation Interval can be any positive duration.  This parameter can
//  be set at any time.

ERR ErrBFSetLRUKCorrInterval( ULONG_PTR cusec )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( (long)cusec < 0 )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	csecBFLRUKCorrelatedTouch = double( cusec ) / 1000000;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//	Sets the current K-ness of the LRUK page replacement algorithm.

ERR ErrBFSetLRUKPolicy( ULONG_PTR cLRUKPolicy )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( cLRUKPolicy > Kmax )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	BFLRUKK = int( cLRUKPolicy );
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the current LRUK Time-out used by the buffer manager.  The LRUK Time-out
//  is the duration (in seconds) since a multiply accessed page was last accessed
//  when that page is considered for eviction from the cache.

ERR ErrBFSetLRUKTimeout( ULONG_PTR csec )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( (long)csec <= 0 )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	csecBFLRUKTimeout = double( csec );
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the current count of clean pages at which we will start cleaning
//  buffers.  We will clean buffers until we reach the corresponding stop
//  threshold.  The Start Threshold must be less than the current Stop
//  Threshold and greater than zero.  This parameter can be set at any time.

ERR ErrBFSetStartFlushThreshold( ULONG_PTR cpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  set start threshold

	cbfCleanThresholdStart = (LONG_PTR)cpg;

	//  normalize thresholds

	BFINormalizeThresholds();

	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the current count of clean pages at which we will stop cleaning
//  buffers after beginning a flush by dropping below the corresponding start
//  threshold.  The Stop Threshold must be greater than the current Start
//  Threshold.  This parameter can be set at any time.

ERR ErrBFSetStopFlushThreshold( ULONG_PTR cpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  set stop threshold

	cbfCleanThresholdStop = (LONG_PTR)cpg;

	//  normalize thresholds

	BFINormalizeThresholds();

	critBFParm.Leave();
	return JET_errSuccess;
	}


//////////////////
//  Page Latches

ERR ErrBFReadLatchPage( BFLatch* pbfl, IFMP ifmp, PGNO pgno, BFLatchFlags bflf )
	{
	ERR err;

	//  validate IN args

	Assert( FBFNotLatched( ifmp, pgno ) );
	Assert( !( bflf & bflfNew ) );

	//  the latch flag criteria are met for a possible fast latch using a user
	//  provided hint

	const BFLatchFlags bflfMask		= BFLatchFlags( bflfNoCached | bflfHint );
	const BFLatchFlags bflfPattern	= BFLatchFlags( bflfHint );

	if ( ( bflf & bflfMask ) == bflfPattern )
		{
		//  fetch the hint from the BFLatch.  we assume that the latch contains
		//  either a valid PBF, a valid BFHashedLatch*, or NULL

		Assert( FBFILatchValidContext( pbfl->dwContext ) || !pbfl->dwContext );

		PBF pbfHint;

		if ( pbfl->dwContext & 1 )
			{
			pbfHint = ((BFHashedLatch*)( pbfl->dwContext ^ 1 ))->pbf;
			}
		else
			{
			pbfHint = PBF( pbfl->dwContext );
			}

		//  the hint is not NULL (this can happen if a NULL hint was passed in
		//  or if a hashed latch hint was passed in and it is not currently
		//  owned by a BF)

		if ( pbfHint != pbfNil )
			{
			//  determine what latch we will acquire.  if the BF has been promoted
			//  to a hashed latch then we will use the appropriate hashed latch for
			//  the appropriate processor.  otherwise, we will simply use the latch
			//  on the BF

			PLS*			ppls;
			CSXWLatch*		psxwl;
			const size_t	iHashedLatch	= pbfHint->iHashedLatch;

			if ( iHashedLatch < cBFHashedLatch )
				{
				ppls	= Ppls();
				psxwl	= &ppls->rgBFHashedLatch[ iHashedLatch ].sxwl;
				}
			else
				{
				ppls	= NULL;
				psxwl	= &pbfHint->sxwl;
				}

			//  try to latch the page as if bflfNoWait were specified.  we must do
			//  this to be compatible with the locking scheme in ErrBFIEvictPage()
			//
			//  NOTE:  we must disable ownership tracking here because we may
			//  accidentally try to latch a page we already have latched causing
			//  an assert.  the assert would be invalid because we will later
			//  find out that we shouldn't have the latch anyway and release it

			CLockDeadlockDetectionInfo::DisableOwnershipTracking();
			if ( psxwl->ErrTryAcquireSharedLatch() == CSXWLatch::errSuccess )
				{
				//  verify that we successfully latched the intended BF and that BF
				//  contains the current version of this IFMP / PGNO and that it is
				//  not in an error state

				PBF pbfLatch;
				if ( iHashedLatch < cBFHashedLatch )
					{
					pbfLatch = ppls->rgBFHashedLatch[ iHashedLatch ].pbf;
					}
				else
					{
					pbfLatch = pbfHint;
					}

				if (	pbfLatch == pbfHint &&
						pbfHint->ifmp == ifmp &&
						pbfHint->pgno == pgno &&
						pbfHint->fCurrentVersion &&
						( err = pbfHint->err ) >= JET_errSuccess &&
						pbfHint->bfrs == bfrsResident )
					{
					//  transfer ownership of the latch to the current context.  we
					//  must do this to properly set up deadlock detection for this
					//  latch

					CLockDeadlockDetectionInfo::EnableOwnershipTracking();
					psxwl->ClaimOwnership( bfltShared );

					//  touch this page if requested

					if ( !( bflf & bflfNoTouch ) )
						{
						if ( bflruk.FSuperHotResource( pbfHint ) )
							{
							BFILatchNominate( pbfHint );
							}
						bflruk.TouchResource( pbfHint );
						}

					//  return the page

					cBFCacheReq.Inc( perfinstGlobal );

					pbfl->pv		= pbfHint->pv;
					pbfl->dwContext	= DWORD_PTR( pbfHint );

					if ( iHashedLatch < cBFHashedLatch )
						{
						ppls->rgBFHashedLatch[ iHashedLatch ].cCacheReq++;
						pbfl->dwContext = DWORD_PTR( &ppls->rgBFHashedLatch[ iHashedLatch ] ) | 1;
						}
					else if ( pbfHint->bfls == bflsElect )
						{
						Ppls()->rgBFNominee[ 0 ].cCacheReq++;
						}

					return err;
					}
				psxwl->ReleaseSharedLatch();
				}
			CLockDeadlockDetectionInfo::EnableOwnershipTracking();
			}
		}

	//  latch the page

	Call( ErrBFILatchPage( pbfl, ifmp, pgno, bflf, bfltShared ) );

	//  validate OUT args

HandleError:
	Assert( err != wrnBFPageFault || !( bflf & bflfNoUncached ) );
	Assert( err != errBFPageCached || ( bflf & bflfNoCached ) );
	Assert( err != errBFPageNotCached || ( bflf & bflfNoUncached ) );
	Assert( err != errBFLatchConflict || ( bflf & bflfNoWait ) );

	Assert(	(	err < JET_errSuccess &&
				FBFNotLatched( ifmp, pgno ) ) ||
			(	( err >= JET_errSuccess || ( bflf & bflfNoFail ) ) &&
				FBFReadLatched( pbfl ) &&
				PbfBFILatchContext( pbfl->dwContext )->ifmp == ifmp &&
				PbfBFILatchContext( pbfl->dwContext )->pgno == pgno ) );

	return err;
	}

ERR ErrBFRDWLatchPage( BFLatch* pbfl, IFMP ifmp, PGNO pgno, BFLatchFlags bflf )
	{
	ERR err;

	//  validate IN args

	Assert( FBFNotLatched( ifmp, pgno ) );
	Assert( !( bflf & bflfNew ) );

	//  the latch flag criteria are met for a possible fast latch using a user
	//  provided hint

	const BFLatchFlags bflfMask		= BFLatchFlags( bflfNoCached | bflfHint );
	const BFLatchFlags bflfPattern	= BFLatchFlags( bflfHint );

	if ( ( bflf & bflfMask ) == bflfPattern )
		{
		//  fetch the hint from the BFLatch.  we assume that the latch contains
		//  either a valid PBF, a valid BFHashedLatch*, or NULL

		Assert( FBFILatchValidContext( pbfl->dwContext ) || !pbfl->dwContext );

		PBF pbfHint;

		if ( pbfl->dwContext & 1 )
			{
			pbfHint = ((BFHashedLatch*)( pbfl->dwContext ^ 1 ))->pbf;
			}
		else
			{
			pbfHint = PBF( pbfl->dwContext );
			}

		//  the hint is not NULL (this can happen if a NULL hint was passed in
		//  or if a hashed latch hint was passed in and it is not currently
		//  owned by a BF)

		if ( pbfHint != pbfNil )
			{
			//  try to latch the page as if bflfNoWait were specified.  we must do
			//  this to be compatible with the locking scheme in ErrBFIEvictPage()
			//
			//  NOTE:  we must disable ownership tracking here because we may
			//  accidentally try to latch a page we already have latched causing
			//  an assert.  the assert would be invalid because we will later
			//  find out that we shouldn't have the latch anyway and release it

			CLockDeadlockDetectionInfo::DisableOwnershipTracking();
			if ( pbfHint->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
				{
				//  this BF contains the current version of this IFMP / PGNO and it
				//  is not in an error state

				if (	pbfHint->ifmp == ifmp &&
						pbfHint->pgno == pgno &&
						pbfHint->fCurrentVersion &&
						( err = pbfHint->err ) >= JET_errSuccess &&
						pbfHint->bfrs == bfrsResident )
					{
					//  transfer ownership of the latch to the current context.  we
					//  must do this to properly set up deadlock detection for this
					//  latch

					CLockDeadlockDetectionInfo::EnableOwnershipTracking();
					pbfHint->sxwl.ClaimOwnership( bfltExclusive );

					//  touch this page if requested

					if ( !( bflf & bflfNoTouch ) )
						{
						bflruk.TouchResource( pbfHint );
						}

					//  return the page

					cBFCacheReq.Inc( perfinstGlobal );

					pbfl->pv		= pbfHint->pv;
					pbfl->dwContext	= DWORD_PTR( pbfHint );

					return err;
					}
				pbfHint->sxwl.ReleaseExclusiveLatch();
				}
			CLockDeadlockDetectionInfo::EnableOwnershipTracking();
			}
		}

	//  latch the page

	Call( ErrBFILatchPage( pbfl, ifmp, pgno, bflf, bfltExclusive ) );

	//  validate OUT args

HandleError:
	Assert( err != wrnBFPageFault || !( bflf & bflfNoUncached ) );
	Assert( err != errBFPageCached || ( bflf & bflfNoCached ) );
	Assert( err != errBFPageNotCached || ( bflf & bflfNoUncached ) );
	Assert( err != errBFLatchConflict || ( bflf & bflfNoWait ) );

	Assert(	(	err < JET_errSuccess &&
				FBFNotLatched( ifmp, pgno ) ) ||
			(	( err >= JET_errSuccess || ( bflf & bflfNoFail ) ) &&
				FBFRDWLatched( pbfl ) &&
				PBF( pbfl->dwContext )->ifmp == ifmp &&
				PBF( pbfl->dwContext )->pgno == pgno ) );

	return err;
	}

ERR ErrBFWARLatchPage( BFLatch* pbfl, IFMP ifmp, PGNO pgno, BFLatchFlags bflf )
	{
	ERR err;

	//  validate IN args

	Assert( FBFNotLatched( ifmp, pgno ) );
	Assert( !( bflf & bflfNew ) );

	//  RDW Latch the page

	Call( ErrBFRDWLatchPage( pbfl, ifmp, pgno, bflf ) );

	//  mark this BF as WAR Latched

	PBF( pbfl->dwContext )->fWARLatch = fTrue;

	//  validate OUT args

HandleError:
	Assert( err != wrnBFPageFault || !( bflf & bflfNoUncached ) );
	Assert( err != errBFPageCached || ( bflf & bflfNoCached ) );
	Assert( err != errBFPageNotCached || ( bflf & bflfNoUncached ) );
	Assert( err != errBFLatchConflict || ( bflf & bflfNoWait ) );

	Assert(	(	err < JET_errSuccess &&
				FBFNotLatched( ifmp, pgno ) ) ||
			(	err >= JET_errSuccess &&
				FBFWARLatched( pbfl ) &&
				PBF( pbfl->dwContext )->ifmp == ifmp &&
				PBF( pbfl->dwContext )->pgno == pgno ) );

	Assert( err < JET_errSuccess || PBF( pbfl->dwContext )->err != errBFIPageNotVerified );

	return err;
	}

ERR ErrBFWriteLatchPage( BFLatch* pbfl, IFMP ifmp, PGNO pgno, BFLatchFlags bflf )
	{
	ERR err;

	//  validate IN args

	Assert( FBFNotLatched( ifmp, pgno ) );
	Assert( !( bflf & bflfNoFail ) );

	//  latch the page

	Call( ErrBFILatchPage( pbfl, ifmp, pgno, bflf, bfltWrite ) );

	//  validate OUT args

HandleError:
	Assert( err != wrnBFPageFault || !( bflf & bflfNoUncached ) );
	Assert( err != errBFPageCached || ( bflf & bflfNoCached ) );
	Assert( err != errBFPageNotCached || ( bflf & bflfNoUncached ) );
	Assert( err != errBFLatchConflict || ( bflf & bflfNoWait ) );

	Assert(	(	err < JET_errSuccess &&
				FBFNotLatched( ifmp, pgno ) ) ||
			(	err >= JET_errSuccess &&
				FBFWriteLatched( pbfl ) &&
				PBF( pbfl->dwContext )->ifmp == ifmp &&
				PBF( pbfl->dwContext )->pgno == pgno ) );

	Assert( err < JET_errSuccess || PBF( pbfl->dwContext )->err != errBFIPageNotVerified );

	return err;
	}

ERR ErrBFUpgradeReadLatchToRDWLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFReadLatched( pbfl ) );

	ERR				err;
	PBF				pbf;
	CSXWLatch*		psxwl;
	CSXWLatch::ERR	errSXWL;

	//  extract our BF and latch from the latch context

	if ( pbfl->dwContext & 1 )
		{
		pbf		= ((BFHashedLatch*)( pbfl->dwContext ^ 1 ))->pbf;
		psxwl	= &((BFHashedLatch*)( pbfl->dwContext ^ 1 ))->sxwl;
		}
	else
		{
		pbf		= PBF( pbfl->dwContext );
		psxwl	= &pbf->sxwl;
		}

	//  try to upgrade our shared latch to the exclusive latch

	if ( psxwl == &pbf->sxwl )
		{
		errSXWL = pbf->sxwl.ErrUpgradeSharedLatchToExclusiveLatch();
		}
	else
		{
		errSXWL = pbf->sxwl.ErrTryAcquireExclusiveLatch();
		if ( errSXWL == CSXWLatch::errSuccess )
			{
			psxwl->ReleaseSharedLatch();
			pbfl->dwContext = DWORD_PTR( pbf );
			}
		}

	//  there was a latch conflict

	if ( errSXWL == CSXWLatch::errLatchConflict )
		{
		//  fail with a latch conflict

		cBFLatchConflict.Inc( perfinstGlobal );
		err = ErrERRCheck( errBFLatchConflict );
		}

	//  there was no latch conflict

	else
		{
		Assert( errSXWL == CSXWLatch::errSuccess );

		//  ensure that if the page is valid it is marked as valid.  it is
		//  possible that we can't do this in the process of getting a Read
		//  Latch because we can't get the exclusive latch so we must make sure
		//  that we do it before we upgrade to a Write Latch or WAR Latch.  the
		//  reason for this is that if we modify the page while it is still
		//  marked as not validated then another thread will misinterpret the
		//  page as invalid
		//
		//  NOTE:  it should be very rare that we will actually need to perform
		//  the full validation of this page.  the reason we must do the full
		//  validation instead of just marking the page as validated is because
		//  the page may have been latched with bflfNoFail in which case we do
		//  not know for sure if it was valid in the first place

		(void)ErrBFIValidatePage( pbf, bfltExclusive );

		//  we have the RDW Latch

		err = JET_errSuccess;
		}

	//  validate OUT args

	Assert(	( err < JET_errSuccess && FBFReadLatched( pbfl ) ) ||
			( err >= JET_errSuccess && FBFRDWLatched( pbfl ) ) );

	return err;
	}

ERR ErrBFUpgradeReadLatchToWARLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFReadLatched( pbfl ) );

	ERR				err;
	PBF				pbf;
	CSXWLatch*		psxwl;
	CSXWLatch::ERR	errSXWL;

	//  extract our BF and latch from the latch context

	if ( pbfl->dwContext & 1 )
		{
		pbf		= ((BFHashedLatch*)( pbfl->dwContext ^ 1 ))->pbf;
		psxwl	= &((BFHashedLatch*)( pbfl->dwContext ^ 1 ))->sxwl;
		}
	else
		{
		pbf		= PBF( pbfl->dwContext );
		psxwl	= &pbf->sxwl;
		}

	//  try to upgrade our shared latch to the exclusive latch

	if ( psxwl == &pbf->sxwl )
		{
		errSXWL = pbf->sxwl.ErrUpgradeSharedLatchToExclusiveLatch();
		}
	else
		{
		errSXWL = pbf->sxwl.ErrTryAcquireExclusiveLatch();
		if ( errSXWL == CSXWLatch::errSuccess )
			{
			psxwl->ReleaseSharedLatch();
			pbfl->dwContext = DWORD_PTR( pbf );
			}
		}

	//  there was a latch conflict

	if ( errSXWL == CSXWLatch::errLatchConflict )
		{
		//  fail with a latch conflict

		cBFLatchConflict.Inc( perfinstGlobal );
		err = ErrERRCheck( errBFLatchConflict );
		}

	//  there was no latch conflict

	else
		{
		Assert( errSXWL == CSXWLatch::errSuccess );

		//  ensure that if the page is valid it is marked as valid.  it is
		//  possible that we can't do this in the process of getting a Read
		//  Latch because we can't get the exclusive latch so we must make sure
		//  that we do it before we upgrade to a Write Latch or WAR Latch.  the
		//  reason for this is that if we modify the page while it is still
		//  marked as not validated then another thread will misinterpret the
		//  page as invalid
		//
		//  NOTE:  it should be very rare that we will actually need to perform
		//  the full validation of this page.  the reason we must do the full
		//  validation instead of just marking the page as validated is because
		//  the page may have been latched with bflfNoFail in which case we do
		//  not know for sure if it was valid in the first place

		(void)ErrBFIValidatePage( pbf, bfltExclusive );

		//  mark this BF as WAR Latched

		pbf->fWARLatch = fTrue;

		err = JET_errSuccess;
		}

	//  validate OUT args

	Assert(	( err < JET_errSuccess && FBFReadLatched( pbfl ) ) ||
			( err >= JET_errSuccess && FBFWARLatched( pbfl ) ) );

	Assert( err < JET_errSuccess || PbfBFILatchContext( pbfl->dwContext )->err != errBFIPageNotVerified );

	return err;
	}

ERR ErrBFUpgradeReadLatchToWriteLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFReadLatched( pbfl ) );

	ERR				err;
	PBF				pbf;
	CSXWLatch*		psxwl;
	CSXWLatch::ERR	errSXWL;

	//  extract our BF and latch from the latch context

	if ( pbfl->dwContext & 1 )
		{
		pbf		= ((BFHashedLatch*)( pbfl->dwContext ^ 1 ))->pbf;
		psxwl	= &((BFHashedLatch*)( pbfl->dwContext ^ 1 ))->sxwl;
		}
	else
		{
		pbf		= PBF( pbfl->dwContext );
		psxwl	= &pbf->sxwl;
		}

	//  try to upgrade our shared latch to the write latch

	if ( psxwl == &pbf->sxwl )
		{
		errSXWL = pbf->sxwl.ErrUpgradeSharedLatchToWriteLatch();
		}
	else
		{
		errSXWL = pbf->sxwl.ErrTryAcquireExclusiveLatch();
		if ( errSXWL == CSXWLatch::errSuccess )
			{
			psxwl->ReleaseSharedLatch();
			errSXWL = pbf->sxwl.ErrUpgradeExclusiveLatchToWriteLatch();
			pbfl->dwContext = DWORD_PTR( pbf );
			}
		}

	//  there was a latch conflict

	if ( errSXWL == CSXWLatch::errLatchConflict )
		{
		//  fail with a latch conflict

		cBFLatchConflict.Inc( perfinstGlobal );
		err = ErrERRCheck( errBFLatchConflict );
		}

	//  there was no latch conflict

	else
		{
		Assert(	errSXWL == CSXWLatch::errSuccess ||
				errSXWL == CSXWLatch::errWaitForWriteLatch );

		//  wait for ownership of the write latch if required

		if ( errSXWL == CSXWLatch::errWaitForWriteLatch )
			{
			cBFLatchStall.Inc( perfinstGlobal );
			pbf->sxwl.WaitForWriteLatch();
			}

		//  if this BF has a hashed latch then grab all the other write latches

		if ( pbf->bfls == bflsHashed )
			{
			for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
				{
				CSXWLatch* const psxwlProc = &Ppls( iProc )->rgBFHashedLatch[ pbf->iHashedLatch ].sxwl;
				if ( psxwlProc->ErrAcquireExclusiveLatch() == CSXWLatch::errWaitForExclusiveLatch )
					{
					cBFLatchStall.Inc( perfinstGlobal );
					psxwlProc->WaitForExclusiveLatch();
					}
				if ( psxwlProc->ErrUpgradeExclusiveLatchToWriteLatch() == CSXWLatch::errWaitForWriteLatch )
					{
					cBFLatchStall.Inc( perfinstGlobal );
					psxwlProc->WaitForWriteLatch();
					}
				}
			}

		//  ensure that if the page is valid it is marked as valid.  it is
		//  possible that we can't do this in the process of getting a Read
		//  Latch because we can't get the exclusive latch so we must make sure
		//  that we do it before we upgrade to a Write Latch or WAR Latch.  the
		//  reason for this is that if we modify the page while it is still
		//  marked as not validated then another thread will misinterpret the
		//  page as invalid
		//
		//  NOTE:  it should be very rare that we will actually need to perform
		//  the full validation of this page.  the reason we must do the full
		//  validation instead of just marking the page as validated is because
		//  the page may have been latched with bflfNoFail in which case we do
		//  not know for sure if it was valid in the first place

		(void)ErrBFIValidatePage( pbf, bfltWrite );

		err = JET_errSuccess;
		}

	//  validate OUT args

	Assert(	( err < JET_errSuccess && FBFReadLatched( pbfl ) ) ||
			( err >= JET_errSuccess && FBFWriteLatched( pbfl ) ) );

	Assert( err < JET_errSuccess || PbfBFILatchContext( pbfl->dwContext )->err != errBFIPageNotVerified );

	return err;
	}

ERR ErrBFUpgradeRDWLatchToWARLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFRDWLatched( pbfl ) );

	ERR err;
	PBF pbf = PBF( pbfl->dwContext );

	//  mark this BF as WAR Latched

	pbf->fWARLatch = fTrue;

	err = JET_errSuccess;

	//  validate OUT args

	Assert(	( err < JET_errSuccess && FBFRDWLatched( pbfl ) ) ||
			( err >= JET_errSuccess && FBFWARLatched( pbfl ) ) );

	Assert( err < JET_errSuccess || PBF( pbfl->dwContext )->err != errBFIPageNotVerified );

	return err;
	}

ERR ErrBFUpgradeRDWLatchToWriteLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFRDWLatched( pbfl ) );

	ERR				err;
	PBF				pbf = PBF( pbfl->dwContext );
	CSXWLatch::ERR	errSXWL;

	//  upgrade our exclusive latch to the write latch

	errSXWL = pbf->sxwl.ErrUpgradeExclusiveLatchToWriteLatch();

	Assert(	errSXWL == CSXWLatch::errSuccess ||
			errSXWL == CSXWLatch::errWaitForWriteLatch );

	//  wait for ownership of the write latch if required

	if ( errSXWL == CSXWLatch::errWaitForWriteLatch )
		{
		cBFLatchStall.Inc( perfinstGlobal );
		pbf->sxwl.WaitForWriteLatch();
		}

	//  if this BF has a hashed latch then grab all the other write latches

	if ( pbf->bfls == bflsHashed )
		{
		for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
			{
			CSXWLatch* const psxwlProc = &Ppls( iProc )->rgBFHashedLatch[ pbf->iHashedLatch ].sxwl;
			if ( psxwlProc->ErrAcquireExclusiveLatch() == CSXWLatch::errWaitForExclusiveLatch )
				{
				cBFLatchStall.Inc( perfinstGlobal );
				psxwlProc->WaitForExclusiveLatch();
				}
			if ( psxwlProc->ErrUpgradeExclusiveLatchToWriteLatch() == CSXWLatch::errWaitForWriteLatch )
				{
				cBFLatchStall.Inc( perfinstGlobal );
				psxwlProc->WaitForWriteLatch();
				}
			}
		}

	err = JET_errSuccess;

	//  validate OUT args

	Assert(	( err < JET_errSuccess && FBFRDWLatched( pbfl ) ) ||
			( err >= JET_errSuccess && FBFWriteLatched( pbfl ) ) );

	Assert( err < JET_errSuccess || PBF( pbfl->dwContext )->err != errBFIPageNotVerified );

	return err;
	}

void BFDowngradeWriteLatchToRDWLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFWriteLatched( pbfl ) );

	PBF pbf = PBF( pbfl->dwContext );

	//  if this BF has a hashed latch then release all the other write latches

	if ( pbf->bfls == bflsHashed )
		{
		for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
			{
			CSXWLatch* const psxwlProc = &Ppls( iProc )->rgBFHashedLatch[ pbf->iHashedLatch ].sxwl;
			psxwlProc->ReleaseWriteLatch();
			}
		}

	//  downgrade our write latch to the exclusive latch

	pbf->sxwl.DowngradeWriteLatchToExclusiveLatch();

	//  validate OUT args

	Assert( FBFRDWLatched( pbfl ) );
	}

void BFDowngradeWARLatchToRDWLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) );

	PBF pbf = PBF( pbfl->dwContext );

	//  mark this BF as not WAR Latched

	pbf->fWARLatch = fFalse;

	//  validate OUT args

	Assert( FBFRDWLatched( pbfl ) );
	}

void BFDowngradeWriteLatchToReadLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFWriteLatched( pbfl ) );

	PBF pbf = PBF( pbfl->dwContext );

	//  if this BF has a hashed latch then release all the other write latches

	if ( pbf->bfls == bflsHashed )
		{
		for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
			{
			CSXWLatch* const psxwlProc = &Ppls( iProc )->rgBFHashedLatch[ pbf->iHashedLatch ].sxwl;
			psxwlProc->ReleaseWriteLatch();
			}
		}

	//  downgrade our write latch to a shared latch

	pbf->sxwl.DowngradeWriteLatchToSharedLatch();

	//  validate OUT args

	Assert( FBFReadLatched( pbfl ) );
	}

void BFDowngradeWARLatchToReadLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) );

	PBF pbf = PBF( pbfl->dwContext );

	//  mark this BF as not WAR Latched

	pbf->fWARLatch = fFalse;

	//  downgrade our exclusive latch to a shared latch

	pbf->sxwl.DowngradeExclusiveLatchToSharedLatch();

	//  validate OUT args

	Assert( FBFReadLatched( pbfl ) );
	}

void BFDowngradeRDWLatchToReadLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFRDWLatched( pbfl ) );

	PBF pbf = PBF( pbfl->dwContext );

	//  downgrade our exclusive latch to a shared latch

	pbf->sxwl.DowngradeExclusiveLatchToSharedLatch();

	//  validate OUT args

	Assert( FBFReadLatched( pbfl ) );
	}

void BFWriteUnlatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFWriteLatched( pbfl ) );

	//  if this BF has a hashed latch then release all the other write latches

	const PBF pbf = PBF( pbfl->dwContext );

	if ( pbf->bfls == bflsHashed )
		{
		for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
			{
			CSXWLatch* const psxwlProc = &Ppls( iProc )->rgBFHashedLatch[ pbf->iHashedLatch ].sxwl;
			psxwlProc->ReleaseWriteLatch();
			}
		}

	//  if this IFMP / PGNO is clean, simply release the write latch

	if ( pbf->bfdf == bfdfClean )
		{
		const IFMP ifmp = pbf->ifmp;
		const PGNO pgno = pbf->pgno;

		pbf->sxwl.ReleaseWriteLatch();

		Assert( FBFNotLatched( ifmp, pgno ) );
		return;
		}

	//  if this IFMP / PGNO is impeding the checkpoint, mark it as filthy so that
	//  we will aggressively flush it

	FMP*	pfmp				= &rgfmp[ pbf->ifmp & ifmpMask ];
	LOG*	plog				= pfmp->Pinst()->m_plog;

	if (	CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) &&
			plog->CbOffsetLgpos(	plog->m_fRecoveringMode == fRecoveringRedo ?
										plog->m_lgposRedo :
										plog->m_lgposLogRec, pbf->lgposOldestBegin0 ) > 2 * cbCleanCheckpointDepthMax )
		{
		BFIDirtyPage( pbf, bfdfFilthy );
		}

	//  if this IFMP / PGNO is filthy, try to version it so that when we try and
	//  aggressively flush it later, it will not cause subsequent RDW/WAR/Write
	//  latches to stall on the page flush
	//
	//  NOTE:  there is no need to version the page if is already versioned

	if ( pbf->bfdf == bfdfFilthy && pbf->pbfTimeDepChainNext == pbfNil )
		{
		PBF pbfOld;
		if ( ErrBFIVersionPage( pbf, &pbfOld ) >= JET_errSuccess )
			{
			pbfOld->sxwl.ReleaseWriteLatch();
			}
		}

	//  release our write latch

	const IFMP			ifmp	= pbf->ifmp;
	const PGNO			pgno	= pbf->pgno;
	const BFDirtyFlags	bfdf	= BFDirtyFlags( pbf->bfdf );

	pbf->sxwl.ReleaseWriteLatch();

	//  if this IFMP / PGNO was filthy, try to flush it

	if ( bfdf == bfdfFilthy )
		{
		if ( ErrBFIFlushPage( pbf, bfdfFilthy ) == errBFIPageFlushed )
			{
			cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
			if ( ifmp & ifmpSLV )
				{
				CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
				}
			else
				{
				CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
				}
			}
		}

	//  validate OUT args

	Assert( FBFNotLatched( ifmp, pgno ) );
	}

void BFWARUnlatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) );

	//  mark this BF as not WAR Latched

	PBF( pbfl->dwContext )->fWARLatch = fFalse;

	//  release our exclusive latch

	BFRDWUnlatch( pbfl );
	}

void BFRDWUnlatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFRDWLatched( pbfl ) );

	//  if this IFMP / PGNO is clean, simply release the rdw latch

	const PBF pbf = PBF( pbfl->dwContext );

	if ( pbf->bfdf == bfdfClean )
		{
		const IFMP ifmp = pbf->ifmp;
		const PGNO pgno = pbf->pgno;

		pbf->sxwl.ReleaseExclusiveLatch();

		Assert( FBFNotLatched( ifmp, pgno ) );
		return;
		}

	//  if this IFMP / PGNO is impeding the checkpoint, mark it as filthy so that
	//  we will aggressively flush it

	FMP*	pfmp				= &rgfmp[ pbf->ifmp & ifmpMask ];
	LOG*	plog				= pfmp->Pinst()->m_plog;

	if (	CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) &&
			plog->CbOffsetLgpos(	plog->m_fRecoveringMode == fRecoveringRedo ?
										plog->m_lgposRedo :
										plog->m_lgposLogRec, pbf->lgposOldestBegin0 ) > 2 * cbCleanCheckpointDepthMax )
		{
		BFIDirtyPage( pbf, bfdfFilthy );
		}

	//  if this IFMP / PGNO is filthy, try to version it so that when we try and
	//  aggressively flush it later, it will not cause subsequent RDW/WAR/Write
	//  latches to stall on the page flush
	//
	//  NOTE:  there is no need to version the page if is already versioned

	if ( pbf->bfdf == bfdfFilthy && pbf->pbfTimeDepChainNext == pbfNil )
		{
		PBF pbfOld;
		if ( ErrBFIVersionPage( pbf, &pbfOld ) >= JET_errSuccess )
			{
			pbfOld->sxwl.ReleaseWriteLatch();
			}
		}

	//  release our exclusive latch

	const IFMP			ifmp	= pbf->ifmp;
	const PGNO			pgno	= pbf->pgno;
	const BFDirtyFlags	bfdf	= BFDirtyFlags( pbf->bfdf );

	pbf->sxwl.ReleaseExclusiveLatch();

	//  if this IFMP / PGNO was filthy, try to flush it

	if ( bfdf == bfdfFilthy )
		{
		if ( ErrBFIFlushPage( pbf, bfdfFilthy ) == errBFIPageFlushed )
			{
			cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
			if ( ifmp & ifmpSLV )
				{
				CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
				}
			else
				{
				CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
				}
			}
		}

	//  validate OUT args

	Assert( FBFNotLatched( ifmp, pgno ) );
	}

void BFReadUnlatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFReadLatched( pbfl ) );

	//  extract our BF and latch from the latch context

	PBF				pbf;
	CSXWLatch*		psxwl;
	CSXWLatch::ERR	errSXWL;

	if ( pbfl->dwContext & 1 )
		{
		pbf		= ((BFHashedLatch*)( pbfl->dwContext ^ 1 ))->pbf;
		psxwl	= &((BFHashedLatch*)( pbfl->dwContext ^ 1 ))->sxwl;
		}
	else
		{
		pbf		= PBF( pbfl->dwContext );
		psxwl	= &pbf->sxwl;
		}

	//  if this IFMP / PGNO is not filthy, simply release the read latch

	if ( pbf->bfdf != bfdfFilthy )
		{
		const IFMP ifmp = pbf->ifmp;
		const PGNO pgno = pbf->pgno;

		psxwl->ReleaseSharedLatch();

		Assert( FBFNotLatched( ifmp, pgno ) );
		return;
		}

	//  release our shared latch

	const IFMP			ifmp	= pbf->ifmp;
	const PGNO			pgno	= pbf->pgno;

	psxwl->ReleaseSharedLatch();

	//  try to flush this filthy IFMP / PGNO

	if ( ErrBFIFlushPage( pbf, bfdfFilthy ) == errBFIPageFlushed )
		{
		cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
		if ( ifmp & ifmpSLV )
			{
			CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
			}
		else
			{
			CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
			}
		}

	//  validate OUT args

	Assert( FBFNotLatched( ifmp, pgno ) );
	}

BOOL FBFReadLatched( const BFLatch* pbfl )
	{
	return	FBFICacheValidPv( pbfl->pv ) &&
			FBFILatchValidContext( pbfl->dwContext ) &&
			pbfl->pv == PbfBFILatchContext( pbfl->dwContext )->pv &&
			PsxwlBFILatchContext( pbfl->dwContext )->FOwnSharedLatch();
	}

BOOL FBFNotReadLatched( const BFLatch* pbfl )
	{
	return	!FBFICacheValidPv( pbfl->pv ) ||
			!FBFILatchValidContext( pbfl->dwContext ) ||
			pbfl->pv != PbfBFILatchContext( pbfl->dwContext )->pv ||
			PsxwlBFILatchContext( pbfl->dwContext )->FNotOwnSharedLatch();
	}

BOOL FBFReadLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fReadLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is Read Latched if it is present in the hash table and
	//  the associated BF or one of its hashed latches is share latched by us

	fReadLatched = errHash == BFHash::errSuccess;

	if ( fReadLatched )
		{
		fReadLatched = pgnopbf.pbf->sxwl.FOwnSharedLatch();

		const size_t iHashedLatch = pgnopbf.pbf->iHashedLatch;
		if ( iHashedLatch < cBFHashedLatch )
			{
			for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
				{
				BFHashedLatch* const pbfhl = &Ppls( iProc )->rgBFHashedLatch[ iHashedLatch ];
				fReadLatched = fReadLatched || pbfhl->sxwl.FOwnSharedLatch() && pbfhl->pbf == pgnopbf.pbf;
				}
			}
		}

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fReadLatched;
	}

BOOL FBFNotReadLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fNotReadLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is not Read Latched if it is not present in the hash
	//  table or the associated BF and any of its hashed latches are not share
	//  latched by us

	fNotReadLatched = errHash == BFHash::errEntryNotFound;

	if ( !fNotReadLatched )
		{
		fNotReadLatched = pgnopbf.pbf->sxwl.FNotOwnSharedLatch();

		const size_t iHashedLatch = pgnopbf.pbf->iHashedLatch;
		if ( iHashedLatch < cBFHashedLatch )
			{
			for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
				{
				BFHashedLatch* const pbfhl = &Ppls( iProc )->rgBFHashedLatch[ iHashedLatch ];
				fNotReadLatched = fNotReadLatched && ( pbfhl->sxwl.FNotOwnSharedLatch() || pbfhl->pbf != pgnopbf.pbf );
				}
			}
		}

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fNotReadLatched;
	}

BOOL FBFRDWLatched( const BFLatch* pbfl )
	{
	return	FBFICacheValidPv( pbfl->pv ) &&
			FBFILatchValidContext( pbfl->dwContext ) &&
			FBFICacheValidPbf( PBF( pbfl->dwContext ) ) &&
			pbfl->pv == PBF( pbfl->dwContext )->pv &&
			!PBF( pbfl->dwContext )->fWARLatch &&
			PBF( pbfl->dwContext )->sxwl.FOwnExclusiveLatch();
	}

BOOL FBFNotRDWLatched( const BFLatch* pbfl )
	{
	return	!FBFICacheValidPv( pbfl->pv ) ||
			!FBFILatchValidContext( pbfl->dwContext ) ||
			!FBFICacheValidPbf( PBF( pbfl->dwContext ) ) ||
			pbfl->pv != PBF( pbfl->dwContext )->pv ||
			PBF( pbfl->dwContext )->fWARLatch ||
			PBF( pbfl->dwContext )->sxwl.FNotOwnExclusiveLatch();
	}

BOOL FBFRDWLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fRDWLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is RDW Latched if it is present in the hash table and
	//  the associated BF is not marked as WAR Latched and the associated BF is
	//  not exclusively latched by us

	fRDWLatched =	errHash == BFHash::errSuccess &&
					!pgnopbf.pbf->fWARLatch &&
					pgnopbf.pbf->sxwl.FOwnExclusiveLatch();

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fRDWLatched;
	}

BOOL FBFNotRDWLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fNotRDWLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is not RDW Latched if it is not present in the hash
	//  table or the associated BF is marked as WAR Latched or the associated
	//  BF is not exclusively latched by us

	fNotRDWLatched =	errHash == BFHash::errEntryNotFound ||
						pgnopbf.pbf->fWARLatch ||
						pgnopbf.pbf->sxwl.FNotOwnExclusiveLatch();

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fNotRDWLatched;
	}

BOOL FBFWARLatched( const BFLatch* pbfl )
	{
	return	FBFICacheValidPv( pbfl->pv ) &&
			FBFILatchValidContext( pbfl->dwContext ) &&
			FBFICacheValidPbf( PBF( pbfl->dwContext ) ) &&
			pbfl->pv == PBF( pbfl->dwContext )->pv &&
			PBF( pbfl->dwContext )->fWARLatch &&
			PBF( pbfl->dwContext )->sxwl.FOwnExclusiveLatch();
	}

BOOL FBFNotWARLatched( const BFLatch* pbfl )
	{
	return	!FBFICacheValidPv( pbfl->pv ) ||
			!FBFILatchValidContext( pbfl->dwContext ) ||
			!FBFICacheValidPbf( PBF( pbfl->dwContext ) ) ||
			pbfl->pv != PBF( pbfl->dwContext )->pv ||
			!PBF( pbfl->dwContext )->fWARLatch ||
			PBF( pbfl->dwContext )->sxwl.FNotOwnExclusiveLatch();
	}

BOOL FBFWARLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fWARLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is WAR Latched if it is present in the hash table and
	//  the associated BF is marked as WAR Latched and the associated BF is not
	//  exclusively latched by us

	fWARLatched =	errHash == BFHash::errSuccess &&
					pgnopbf.pbf->fWARLatch &&
					pgnopbf.pbf->sxwl.FOwnExclusiveLatch();

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fWARLatched;
	}

BOOL FBFNotWARLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fNotWARLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is not WAR Latched if it is not present in the hash
	//  table or the associated BF is not marked as WAR Latched or the associated
	//  BF is not exclusively latched by us

	fNotWARLatched =	errHash == BFHash::errEntryNotFound ||
						!pgnopbf.pbf->fWARLatch ||
						pgnopbf.pbf->sxwl.FNotOwnExclusiveLatch();

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fNotWARLatched;
	}

BOOL FBFWriteLatched( const BFLatch* pbfl )
	{
	BOOL fWriteLatched;

	fWriteLatched =	FBFICacheValidPv( pbfl->pv ) &&
					FBFILatchValidContext( pbfl->dwContext ) &&
					FBFICacheValidPbf( PBF( pbfl->dwContext ) ) &&
					pbfl->pv == PBF( pbfl->dwContext )->pv &&
					PBF( pbfl->dwContext )->sxwl.FOwnWriteLatch();

	if ( fWriteLatched && PBF( pbfl->dwContext )->bfls == bflsHashed )
		{
		const size_t iHashedLatch = PBF( pbfl->dwContext )->iHashedLatch;
		for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
			{
			BFHashedLatch* const pbfhl = &Ppls( iProc )->rgBFHashedLatch[ iHashedLatch ];
			fWriteLatched = fWriteLatched && pbfhl->sxwl.FOwnWriteLatch();
			}
		}

	return fWriteLatched;
	}

BOOL FBFNotWriteLatched( const BFLatch* pbfl )
	{
	BOOL fNotWriteLatched;

	fNotWriteLatched =	!FBFICacheValidPv( pbfl->pv ) ||
						!FBFILatchValidContext( pbfl->dwContext ) ||
						!FBFICacheValidPbf( PBF( pbfl->dwContext ) ) ||
						pbfl->pv != PBF( pbfl->dwContext )->pv ||
						PBF( pbfl->dwContext )->sxwl.FNotOwnWriteLatch();

	if ( !fNotWriteLatched && PBF( pbfl->dwContext )->bfls == bflsHashed )
		{
		const size_t iHashedLatch = PBF( pbfl->dwContext )->iHashedLatch;
		for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
			{
			BFHashedLatch* const pbfhl = &Ppls( iProc )->rgBFHashedLatch[ iHashedLatch ];
			fNotWriteLatched = fNotWriteLatched || pbfhl->sxwl.FNotOwnWriteLatch();
			}
		}

	return fNotWriteLatched;
	}

BOOL FBFWriteLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fWriteLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is Write Latched if it is present in the hash table and
	//  the associated BF and all its hashed latches are write latched by us

	fWriteLatched =	errHash == BFHash::errSuccess &&
					pgnopbf.pbf->sxwl.FOwnWriteLatch();

	if ( fWriteLatched && pgnopbf.pbf->bfls == bflsHashed )
		{
		const size_t iHashedLatch = pgnopbf.pbf->iHashedLatch;
		for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
			{
			BFHashedLatch* const pbfhl = &Ppls( iProc )->rgBFHashedLatch[ iHashedLatch ];
			fWriteLatched = fWriteLatched && pbfhl->sxwl.FOwnWriteLatch();
			}
		}

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fWriteLatched;
	}

BOOL FBFNotWriteLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fNotWriteLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is not Write Latched if it is not present in the hash
	//  table or the associated BF and all of its hashed latches are not write
	//  latched by us

	fNotWriteLatched =	errHash == BFHash::errEntryNotFound ||
						pgnopbf.pbf->sxwl.FNotOwnWriteLatch();

	if ( !fNotWriteLatched && pgnopbf.pbf->bfls == bflsHashed )
		{
		const size_t iHashedLatch = pgnopbf.pbf->iHashedLatch;
		for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
			{
			BFHashedLatch* const pbfhl = &Ppls( iProc )->rgBFHashedLatch[ iHashedLatch ];
			fNotWriteLatched = fNotWriteLatched || pbfhl->sxwl.FNotOwnWriteLatch();
			}
		}

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fNotWriteLatched;
	}

BOOL FBFLatched( const BFLatch* pbfl )
	{
	return	FBFReadLatched( pbfl ) ||
			FBFRDWLatched( pbfl ) ||
			FBFWARLatched( pbfl ) ||
			FBFWriteLatched( pbfl );
	}

BOOL FBFNotLatched( const BFLatch* pbfl )
	{
	return	FBFNotReadLatched( pbfl ) &&
			FBFNotRDWLatched( pbfl ) &&
			FBFNotWARLatched( pbfl ) &&
			FBFNotWriteLatched( pbfl );
	}

BOOL FBFLatched( IFMP ifmp, PGNO pgno )
	{
	return	FBFReadLatched( ifmp, pgno ) ||
			FBFRDWLatched( ifmp, pgno ) ||
			FBFWARLatched( ifmp, pgno ) ||
			FBFWriteLatched( ifmp, pgno );
	}

BOOL FBFNotLatched( IFMP ifmp, PGNO pgno )
	{
	return	FBFNotReadLatched( ifmp, pgno ) &&
			FBFNotRDWLatched( ifmp, pgno ) &&
			FBFNotWARLatched( ifmp, pgno ) &&
			FBFNotWriteLatched( ifmp, pgno );
	}

DWORD_PTR BFGetLatchHint( const BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFLatched( pbfl ) );

	//  return a pointer to the latched BF as the stable latch hint

	return (DWORD_PTR)PbfBFILatchContext( pbfl->dwContext );
	}


////////////////
//  Page State

//  These functions are used to control and query the state of a page (or
//  pages) in the buffer cache.

//  Marks the given WAR Latched or Write Latched page as dirty.  This means
//  that the given buffer for this page contains changes that should be written
//  to disk.  The degree of dirtiness is specified by the given dirty flags.
//  A page can only be made more dirty.  Trying to make a page less dirty than
//  it currently is will have no effect.

void BFDirty( const BFLatch* pbfl, BFDirtyFlags bfdf )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) || FBFWriteLatched( pbfl ) );

	//  dirty the BF

	BFIDirtyPage( PBF( pbfl->dwContext ), bfdf );
	}

//  Returns the current dirtiness of the given latched page.

BFDirtyFlags FBFDirty( const BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFLatched( pbfl ) );

	//  get the dirty flag for the page

	return BFDirtyFlags( PBF( pbfl->dwContext )->bfdf );
	}


////////////////////////
//  Logging / Recovery

//  The following functions are provided for logging / recovery support.
//  The modify log position for each buffer is used to prevent a dirty
//  buffer from being flushed to disk before the changes in it can be logged
//  (under the Write Ahead Logging paradigm).  The Begin 0 log position for
//  each buffer indicates the oldest transaction that has made a
//  modification to that buffer.  This is used in computing the Oldest Begin
//  0 log position, which indicates the oldest transaction that still has
//  unsaved changes in the buffer cache.  This log position is used to
//  compute the current checkpoint depth.

//  Returns the log position of the oldest Begin Transaction at level 0 for
//  any session that has modified any buffer in the cache. If no buffers
//  have been modified, then this function will return lgposMax.  This
//  function is used to compute the current checkpoint depth.

void BFGetLgposOldestBegin0( IFMP ifmp, LGPOS* plgpos )
	{
	FMP* pfmp = &rgfmp[ ifmp & ifmpMask ];

	//  if no context is present, there must be no oldest begin 0

	pfmp->RwlBFContext().EnterAsReader();
	BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( ifmp & ifmpSLV ) );
	if ( !pbffmp )
		{
		*plgpos = lgposMax;
		pfmp->RwlBFContext().LeaveAsReader();
		return;
		}

	//  find the first entry in the oldest begin 0 index

	BFOB0::ERR		errOB0;
	BFOB0::CLock	lockOB0;

	pbffmp->bfob0.MoveBeforeFirst( &lockOB0 );
	errOB0 = pbffmp->bfob0.ErrMoveNext( &lockOB0 );

	//  we found the first entry in the index

	if ( errOB0 != BFOB0::errNoCurrentEntry )
		{
		//  return the lgpos of this oldest entry rounded down to the next level
		//  of uncertainty in the index

		PBF pbf;
		errOB0 = pbffmp->bfob0.ErrRetrieveEntry( &lockOB0, &pbf );
		Assert( errOB0 == BFOB0::errSuccess );

		plgpos->SetByIbOffset(	(	pbf->lgposOldestBegin0.IbOffset() /
									dlgposBFOB0Uncertainty.IbOffset() ) *
								dlgposBFOB0Uncertainty.IbOffset() );
		}

	//  we did not find the first entry in the index

	else
		{
		//  return lgposMax to indicate that there are no BFs with an Oldest
		//  Begin 0 dependency set

		*plgpos = lgposMax;
		}

	//  unlock the oldest begin 0 index

	pbffmp->bfob0.UnlockKeyPtr( &lockOB0 );

	//  scan the Oldest Begin 0 Overflow List and collect the Oldest Begin 0
	//  from there as well

	pbffmp->critbfob0ol.Enter();
	for ( PBF pbf = pbffmp->bfob0ol.PrevMost(); pbf != pbfNil; pbf = pbffmp->bfob0ol.Next( pbf ) )
		{
		if ( CmpLgpos( plgpos, &pbf->lgposOldestBegin0 ) > 0 )
			{
			*plgpos = pbf->lgposOldestBegin0;
			}
		}
	pbffmp->critbfob0ol.Leave();
	pfmp->RwlBFContext().LeaveAsReader();
	}

//  Sets the log position for the most recent log record to reference this
//  buffer for a modification.  This log position determines when we can
//  safely write a buffer to disk by allowing us to wait for the log to be
//  flushed past this log position (under Write Ahead Logging).  This value
//  is set to lgposMin by default.  The page must be WAR Latched or Write
//  Latched.

void BFSetLgposModify( const BFLatch* pbfl, LGPOS lgpos )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) || FBFWriteLatched( pbfl ) );

	FMP* pfmp = &rgfmp[ PBF( pbfl->dwContext )->ifmp & ifmpMask ];
	Assert(	( !pfmp->Pinst()->m_plog->m_fLogDisabled && pfmp->FLogOn() ) ||
			!CmpLgpos( &lgpos, &lgposMin ) );

	//  set the lgposModify for this BF

	BFISetLgposModify( PBF( pbfl->dwContext ), lgpos );
	}

//  Sets the log position for the last Begin Transaction at level 0 for this
//  session that modified this buffer, if more recent than the last log
//  position set.  This log position is used to determine the current
//  checkpoint depth.  This value is set to lgposMax by default.  The page must
//  be WAR Latched or Write Latched.

void BFSetLgposBegin0( const BFLatch* pbfl, LGPOS lgpos )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) || FBFWriteLatched( pbfl ) );

	FMP* pfmp = &rgfmp[ PBF( pbfl->dwContext )->ifmp & ifmpMask ];
	Assert(	( !pfmp->Pinst()->m_plog->m_fLogDisabled && pfmp->FLogOn() ) ||
			!CmpLgpos( &lgpos, &lgposMax ) );

	//  set the lgposOldestBegin0 for this BF

	BFISetLgposOldestBegin0( PBF( pbfl->dwContext ), lgpos );
	}


/////////////
//  Preread

//  The following functions provide support for prereading pages from the
//  disk before they are actually needed.  This technique can be used to
//  minimize or eliminate buffer cache misses when Read Latching pages.

//  Prereads the given range of pages in the given database.  If cpg is greater
//  than zero, we will preread forwards from pgnoFirst to pgnoFirst + cpg - 1.
//  If cpg is less than zero, we will preread backwards from pgnoFirst to
//  pgnoFirst + cpg + 1.  cpg can not be zero.

void BFPrereadPageRange( IFMP ifmp, PGNO pgnoFirst, CPG cpg, CPG* pcpgActual )
	{
	long cbfPreread = 0;

	//  calculate preread direction

	long lDir = cpg > 0 ? 1 : -1;

	//  schedule all specified pages to be preread

	for ( ULONG pgno = pgnoFirst; pgno != pgnoFirst + cpg; pgno += lDir )
		{
		const ERR err = ErrBFIPrereadPage( ifmp, pgno );

		if ( err == JET_errSuccess )
			{
			cbfPreread++;
			}
		else if ( err != errBFPageCached )
			{
			break;
			}
		}

	//  start issuing prereads

	if ( cbfPreread )
		{
		if ( ifmp & ifmpSLV )
			{
			CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
			}
		else
			{
			CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
			}
		}

	//  return the number of pages preread if requested

	if ( pcpgActual )
		{
		*pcpgActual = cpg > 0 ? pgno - pgnoFirst : pgnoFirst - pgno;
		}
	}

//  Prereads the given array of single pages in the given database.

void BFPrereadPageList( IFMP ifmp, PGNO* prgpgno, CPG* pcpgActual )
	{
	long cbfPreread = 0;

	//  schedule each page for preread

	for ( ULONG ipgno = 0; prgpgno[ ipgno ] != pgnoNull; ipgno++ )
		{
		const ERR err = ErrBFIPrereadPage( ifmp, prgpgno[ ipgno ] );

		if ( err == JET_errSuccess )
			{
			cbfPreread++;
			}
		else if ( err != errBFPageCached )
			{
			break;
			}
		}

	//  start issuing prereads

	if ( cbfPreread )
		{
		if ( ifmp & ifmpSLV )
			{
			CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
			}
		else
			{
			CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
			}
		}

	//  return the number of pages preread if requested

	if ( pcpgActual )
		{
		*pcpgActual = ipgno;
		}
	}


///////////////////////
//  Memory Allocation

//  The following routines allow the user to allocate space in the buffer
//  cache for use as general purpose memory.  Remember that every buffer
//  allocated from the buffer cache will reduce the buffer cache's
//  effectiveness by reducing the amount of memory it has to utilize.

//  Allocates a buffer for use as general purpose memory.  This buffer can
//  not be stolen for use by others.  The buffer must be returned to the
//  buffer cache when it is no longer needed via BFFree().  Note that if we
//  cannot immediately allocate a buffer because they are all currently in
//  use, we will wait until a buffer is free to return, possibly across an
//  I/O.

void BFAlloc( void** ppv )
	{
	//  init OUT args

	*ppv = NULL;

	//  try forever until we allocate a temporary buffer

	for ( BOOL fWait = fFalse; !(*ppv); fWait = fTrue )
		{
		//  we allocated a BF from the avail pool

		PBF pbf;
		if ( ErrBFIAllocPage( &pbf, fWait ) == JET_errSuccess )
			{
			//  mark this BF as in use for memory

			pbf->fMemory = fTrue;
			AtomicIncrement( (long*)&cBFMemory );

			//  give the page pointer for this BF to the caller for use as memory

			*ppv = pbf->pv;
			}

		//  we didn't allocate a BF from the avail pool

		else
			{
			//  allocate a page from memory

			*ppv = PvOSMemoryPageAlloc( g_cbPage, NULL );

			if ( !(*ppv) && fWait )
				{
				UtilSleep( cmsecWaitGeneric );
				}
			}
		}
	}

//  Frees a buffer allocated with BFAlloc().

void BFFree( void* pv )
	{
	//  validate IN args

	Assert( PbfBFICachePv( pv ) != pbfNil || !( DWORD_PTR( pv ) % OSMemoryPageReserveGranularity() ) );
	Assert( PbfBFICachePv( pv ) == pbfNil || PbfBFICachePv( pv )->fMemory );

	//  retrieve the BF associated with this pointer

	const PBF pbf = PbfBFICachePv( pv );

	//  this temporary buffer is a BF

	if ( pbf != pbfNil )
		{
		//  reset this BF's memory status

		pbf->fMemory = fFalse;
		AtomicDecrement( (long*)&cBFMemory );

		//  free the BF to the avail pool

		BFIFreePage( pbf );
		}

	//  this temporary buffer is page memory

	else
		{
		//  free the page memory

		OSMemoryPageFree( pv );
		}
	}


//////////////////
//  Dependencies

//  Dependencies can be created between buffers to force one buffer to be
//  flushed to disk successfully before the other.  This mechanism is an
//  optimization to reduce logging overhead during splits and merges, which
//  move large amounts of data between pages.  If we ensure that buffers are
//  flushed in a particular order, there is no need to log the data that is
//  actually moved because we can always find it somewhere (possibly in more
//  than one place) in the database file.

//  Depends one buffer containing a RDW Latched / WAR Latched / Write Latched
//  page on another.  This forces the depended buffer to be flushed after the
//  buffer it is depended on.  The dependency must be declared before the
//  relevant modification is made.

ERR ErrBFDepend( const BFLatch* pbflFlushFirst, const BFLatch* pbflFlushSecond )
	{
	ERR	err		= JET_errSuccess;
	PBF pbf		= PBF( pbflFlushFirst->dwContext );
	PBF pbfOld	= pbfNil;
	PBF pbfD	= PBF( pbflFlushSecond->dwContext );
	PBF pbfDOld	= pbfNil;

	//  validate IN args

	Assert( FBFLatched( pbflFlushFirst ) && FBFNotReadLatched( pbflFlushFirst ) );
	Assert( FBFLatched( pbflFlushSecond ) && FBFNotReadLatched( pbflFlushSecond ) );

	//  no dependency is required if logging is disabled for this IFMP

	FMP* pfmp = &rgfmp[ pbf->ifmp & ifmpMask ];
	Assert( !pfmp->FLogOn() || !pfmp->Pinst()->m_plog->m_fLogDisabled );
	if ( !pfmp->FLogOn() )
		{
		return JET_errSuccess;
		}

	//  mark all BFs involved as at least bfdfDirty

	BFIDirtyPage( pbf, bfdfDirty );
	BFIDirtyPage( pbfD, bfdfDirty );

	//  setting this dependency COULD cause a cycle through space or time
	//
	//  NOTE:  it is WAY to expensive to determine this exactly, so we will
	//  guess conservatively

	if ( pbf->FDependent() || pbf->pbfTimeDepChainNext != pbfNil )
		{
		if ( pbf == pbfD )
			{
			//  Case I:  Simple Time Dependency

			//  just version this page

			Call( ErrBFIVersionPage( pbf, &pbfOld ) );
			}

		else
			{
			//  Case II:  Dependency Cycle Avoidance

			//  version both pages

			Call( ErrBFIVersionPage( pbf, &pbfOld ) );
			Call( ErrBFIVersionPage( pbfD, &pbfDOld ) );

			//  set the dependency between the new images of the pages

			critBFDepend.Enter();
			BFIDepend( pbf, pbfD );
			critBFDepend.Leave();
			}
		}

	//  setting this dependency could not possibly cause a cycle but it would
	//  cause a branch (i.e. more than one direct dependent)

	else if ( pbf->pbfDependent != pbfNil )
		{
		if ( pbf == pbfD )
			{
			//  Case III:  Simple Time Dependency

			//  just version this page

			Call( ErrBFIVersionPage( pbf, &pbfOld ) );
			}
		else
			{
			//  our dependent is already set

			if ( pbf->pbfDependent == pbfD )
				{
				//  Case IV:  Duplicate Dependency

				//  leave the existing dependency
				}

			//  our dependent is not already set

			else
				{
				//  Case V:  Dependency Branch Avoidance

				//  version both pages
				//
				//  NOTE:  we would just version the first page, but doing this in
				//  and of itself causes the potential for a cycle!  as a result, we
				//  treat branch avoidance just like cycle avoidance

				Call( ErrBFIVersionPage( pbf, &pbfOld ) );
				Call( ErrBFIVersionPage( pbfD, &pbfDOld ) );

				//  set the dependency between the new images of the pages

				critBFDepend.Enter();
				BFIDepend( pbf, pbfD );
				critBFDepend.Leave();
				}
			}
		}

	//  setting this dependency would not cause a cycle or a branch

	else
		{
		if ( pbf == pbfD )
			{
			//  Case VI:  Self Dependency

			//  there is no need to set a dependency on yourself if you have no
			//  dependents and are dependent on no one else
			}
		else
			{
			//  Case VII:  Simple Dependency

			//  determine the length of the dependency chain that would be created

			critBFDepend.Enter();

			long cDepChainLength = 1;
			for ( PBF pbfT = pbfD; pbfT != pbfNil ; pbfT = pbfT->pbfDependent )
				{
				cDepChainLength++;
				}

			critBFDepend.Leave();

			//  this dependency would create a dependency chain that is too long

			if ( cDepChainLength > cDepChainLengthMax )
				{
				//  version the second page so that when we set the new dependency,
				//  it will not inhibit the dependency chain starting at the second
				//  page from being flushed, breaking the chain

				Call( ErrBFIVersionPage( pbfD, &pbfDOld ) );
				}

			//  set the dependency between the two pages

			critBFDepend.Enter();
			BFIDepend( pbf, pbfD );
			critBFDepend.Leave();
			}
		}

HandleError:
	if ( pbfOld != pbfNil )
		{
		pbfOld->sxwl.ReleaseWriteLatch();
		}
	if ( pbfDOld != pbfNil )
		{
		pbfDOld->sxwl.ReleaseWriteLatch();
		}
	return err;
	}


///////////////////
//  Purge / Flush

void BFPurge( BFLatch* pbfl, BOOL fPurgeDirty )
	{
	//  validate IN args

	Assert( FBFReadLatched( pbfl ) );

	//  this BF is clean or we can purge dirty BFs and we can get the write latch

	if (	( FBFDirty( pbfl ) < bfdfDirty || fPurgeDirty ) &&
			ErrBFUpgradeReadLatchToWriteLatch( pbfl ) == JET_errSuccess )
		{
		//  just mark this BF as clean to prevent any data from being flushed.
		//  we will allow the clean thread to evict it later.  this will delay
		//  freeing the BF but will be more scalable

		BFICleanPage( PBF( pbfl->dwContext ) );

		//  mark this BF as "newly evicted" so that when it is actually evicted
		//  we will mark it as not "newly evicted".  this will make it so that
		//  purged pages do not cause cache growth when they are reused

		PBF( pbfl->dwContext )->fNewlyEvicted = fTrue;

		//  release the write latch

		BFWriteUnlatch( pbfl );
		}

	//  this BF was dirty and we can't purge dirty BFs or we couldn't get the
	//  write latch

	else
		{
		//  release the read latch without purging the BF

		BFReadUnlatch( pbfl );
		}
	}

void BFPurge( IFMP ifmp, PGNO pgno, CPG cpg )
	{
	//  retry the purge until we have evicted all cached pages for this IFMP

	BOOL	fRetryPurge	= fFalse;
	PGNO	pgnoFirst	= ( pgnoNull == pgno ) ? PGNO( 1 )  : pgno;
	PGNO	pgnoLast	= ( pgnoNull == pgno ) ? PGNO( -1 ) : pgno + cpg - 1;
	do	{
		fRetryPurge	= fFalse;

		//  scan through all initialized BFs looking for cached pages from this
		//  IFMP

		for ( IBF ibf = 0; ibf < cbfInit; ibf++ )
			{
			PBF pbf = PbfBFICacheIbf( ibf );

			//  if this BF doesn't contain a cached page from this IFMP within
			//	the given range, skip it now

			if ( pbf->ifmp != ifmp || pbf->pgno < pgnoFirst || pbf->pgno > pgnoLast )
				{
				continue;
				}

			//  we can exclusively latch this BF

			CSXWLatch::ERR errSXWL = pbf->sxwl.ErrTryAcquireExclusiveLatch();

			if ( errSXWL == CSXWLatch::errSuccess )
				{
				//  this BF contains the IFMP and is within the given page range that we are purging

				if ( pbf->ifmp == ifmp && pbf->pgno >= pgnoFirst && pbf->pgno <= pgnoLast )
					{
					//  lock this BF in the LRUK in preparation for a possible eviction

					BFLRUK::CLock	lockLRUK;
					bflruk.LockResourceForEvict( pbf, &lockLRUK );

					//  release our exclusive latch.  we do not have to worry about
					//  the page being evicted because we have the LRUK locked

					pbf->sxwl.ReleaseExclusiveLatch();

					//  try to evict this page

					const ERR errEvict = ErrBFIEvictPage( pbf, &lockLRUK, fTrue );

					//  we failed to evict this page

					if ( errEvict < JET_errSuccess )
						{
						Assert( errEvict == errBFIPageNotEvicted ||
								errEvict == errBFLatchConflict );

						//  we will need to try again later to check this page

						fRetryPurge = fTrue;
						}

					//  unlock the LRUK

					bflruk.UnlockResourceForEvict( &lockLRUK );
					}

				//  this BF doesn't contain the IFMP or isn't within the given page range that we are purging afterall

				else
					{
					//  release our exclusive latch and continue our search

					pbf->sxwl.ReleaseExclusiveLatch();
					}
				}

			//  we could not exclusively latch this BF

			else
				{
				Assert( errSXWL == CSXWLatch::errLatchConflict );

				//  we will need to try again later to check this page

				fRetryPurge = fTrue;
				}
			}

		//  we are going to retry the purge

		if ( fRetryPurge )
			{
			//  sleep to wait for the resolution of any processes preventing us
			//  from evicting pages based on real time events

			UtilSleep( cmsecWaitGeneric );
			}
		}
	while ( fRetryPurge );

	//	we are purging all pages in the IFMP

	if ( pgnoNull == pgno )
		{
		//  we have an existing BF FMP Context

		FMP* pfmp = &rgfmp[ ifmp & ifmpMask ];
		pfmp->RwlBFContext().EnterAsWriter();
		BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( ifmp & ifmpSLV ) );
		if ( pbffmp )
			{
			//  test to see if the existing OB0 Index is empty

			BOOL fEmpty = fTrue;

			BFOB0::CLock	lockOB0;
			pbffmp->bfob0.MoveBeforeFirst( &lockOB0 );
			fEmpty = fEmpty && pbffmp->bfob0.ErrMoveNext( &lockOB0 ) == BFOB0::errNoCurrentEntry;
			pbffmp->bfob0.UnlockKeyPtr( &lockOB0 );

			pbffmp->critbfob0ol.Enter();
			fEmpty = fEmpty && pbffmp->bfob0ol.FEmpty();
			pbffmp->critbfob0ol.Leave();

			//  we should be empty

			Enforce( fEmpty );

			//  delete our context

			pbffmp->bfob0.Term();
			pbffmp->BFFMPContext::~BFFMPContext();
			OSMemoryHeapFreeAlign( pbffmp );
			pfmp->SetDwBFContext( !!( ifmp & ifmpSLV ), NULL );
			}
		pfmp->RwlBFContext().LeaveAsWriter();
		}
	}


ERR ErrBFFlush( IFMP ifmp, BOOL fFlushAll, const OBJID objidFDP )
	{
	//  retry the flush until we have flushed as much of this IFMP as possible

	ERR		err			= JET_errSuccess;
	BOOL	fRetryFlush	= fFalse;
	long	cRetryFlush	= 0;
	BOOL	fIssueIO	= fFalse;

	OSTrace( ostlHigh, OSFormat(	"cBFPagesAnomalouslyWritten before force-flush: %d\n",
								cBFPagesAnomalouslyWritten.Get( PinstFromIfmp( ifmp & ifmpMask ) ) ) );

	do	{
		fRetryFlush	= fFalse;
		fIssueIO	= fFalse;

		//  scan through all initialized BFs looking for cached pages from this
		//  IFMP

		for ( IBF ibf = 0; ibf < cbfInit; ibf++ )
			{
			PBF pbf = PbfBFICacheIbf( ibf );

			//  if this BF doesn't contain a cached page from this IFMP, skip it now

			if ( pbf->ifmp != ifmp )
				{
				continue;
				}

			//  if we're only flushing pages from a specific btree of this IFMP,
			//	skip any that don't match

			if ( objidNil != objidFDP
				&& objidFDP != ( (CPAGE::PGHDR *)( pbf->pv ) )->objidFDP )
				{
				continue;
				}

			//  we have too many outstanding page flushes

			if ( cBFPageFlushPending >= cBFPageFlushPendingMax )
				{
				//  we will need to retry the flush later

				fRetryFlush = fTrue;
				cRetryFlush = 0;
				break;
				}

			//  possibly async flush this page

			const ERR errFlush = ErrBFIFlushPage( pbf );

			//  there was an error flushing this BF

			if ( errFlush < JET_errSuccess )
				{
				//  this BF still has dependencies

				if ( errFlush == errBFIRemainingDependencies )
					{
					//  we will need to retry the flush

					fRetryFlush = fTrue;
					}

				//  a BF (not necessarily this BF) is being written
				//
				//  NOTE:  this can be caused by this BF being flushed or
				//  by another BF being flushed in its behalf (say for
				//  removing a flush-order dependency)

				else if ( errFlush == errBFIPageFlushed )
					{
					cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );

					//  we will need to retry the flush to check for
					//  completion of the write and issue the I/O

					fRetryFlush	= fTrue;
					fIssueIO	= fTrue;
					}

				//  a BF (not necessarily this BF) is still being written

				else if ( errFlush == errBFIPageFlushPending )
					{
					//  we will need to retry the flush to check for
					//  completion of the write

					fRetryFlush	= fTrue;
					}

				//  there was a latch conflict that prevented us from
				//  flushing this page

				else if ( errFlush == errBFLatchConflict )
					{
					//  we will need to try again later to check this page

					fRetryFlush = fTrue;
					}

				//  there was some other error

				else
					{
					//  save this error if we are not already failing

					err = err < JET_errSuccess ? err : errFlush;
					}
				}
			}

		//  we are going to retry the flush

		if ( fRetryFlush )
			{
			//  issue any remaining queued writes

			if ( fIssueIO )
				{
				if ( ifmp & ifmpSLV )
					{
					CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
					}
				else
					{
					CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
					}
				}

			//  sleep to attempt to resolve outstanding writes and wait for the
			//  resolution of dependencies based on real time events

			UtilSleep( cmsecWaitGeneric );
			}
		}
	while ( fRetryFlush && ( fFlushAll || ++cRetryFlush < 2 * cDepChainLengthMax ) );

	OSTrace( ostlHigh, OSFormat(	"cBFPagesAnomalouslyWritten after force-flush: %d\n",
								cBFPagesAnomalouslyWritten.Get( PinstFromIfmp( ifmp & ifmpMask ) ) ) );

	//  we have an existing BF FMP Context

	FMP* pfmp = &rgfmp[ ifmp & ifmpMask ];
	pfmp->RwlBFContext().EnterAsWriter();
	BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( ifmp & ifmpSLV ) );
	if ( pbffmp )
		{
		//  make sure that if we are performing a full flush that there are no
		//  entries pointing to dirty buffers in the OB0 Index.  there can be
		//  entries pointing to clean buffers because of the way we maintain
		//  this index

		BFOB0::ERR		errOB0;
		BFOB0::CLock	lockOB0;

		pbffmp->bfob0.MoveBeforeFirst( &lockOB0 );
		while ( pbffmp->bfob0.ErrMoveNext( &lockOB0 ) != BFOB0::errNoCurrentEntry )
			{
			PBF pbf;
			errOB0 = pbffmp->bfob0.ErrRetrieveEntry( &lockOB0, &pbf );
			Assert( errOB0 == BFOB0::errSuccess );

			//  if we're only flushing pages from a specific btree of this IFMP,
			//	skip any that don't match

			if ( objidNil != objidFDP
				&& objidFDP != ( (CPAGE::PGHDR *)( pbf->pv ) )->objidFDP )
				{
				continue;
				}

			Enforce( err < JET_errSuccess || pbf->bfdf == bfdfClean || !fFlushAll );
			}
		pbffmp->bfob0.UnlockKeyPtr( &lockOB0 );

		pbffmp->critbfob0ol.Enter();
		PBF pbfNext;
		for ( PBF pbf = pbffmp->bfob0ol.PrevMost(); pbf != pbfNil; pbf = pbfNext )
			{
			pbfNext = pbffmp->bfob0ol.Next( pbf );

			//  if we're only flushing pages from a specific btree of this IFMP,
			//	skip any that don't match

			if ( objidNil != objidFDP
				&& objidFDP != ( (CPAGE::PGHDR *)( pbf->pv ) )->objidFDP )
				{
				continue;
				}

			Enforce( err < JET_errSuccess || pbf->bfdf == bfdfClean || !fFlushAll );
			}
		pbffmp->critbfob0ol.Leave();
		}
	pfmp->RwlBFContext().LeaveAsWriter();

	//  wait until we are sure that the clean thread is no longer referencing
	//  this FMP

	while ( pfmp->FBFICleanDb() || pfmp->FBFICleanSLV() )
		{
		UtilSleep( cmsecWaitGeneric );
		}

	//  return the result of the flush operation

	return err;
	}


///////////////////////////////
//  Deferred Undo Information

void BFAddUndoInfo( const BFLatch* pbfl, RCE* prce )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) || FBFWriteLatched( pbfl ) );
	Assert( prce->PgnoUndoInfo() == pgnoNull );
	Assert( prce->PrceUndoInfoNext() == prceInvalid );

	//  add the undo info to the BF

	PBF pbf = PBF( pbfl->dwContext );

	ENTERCRITICALSECTION ecs( &critpoolBFDUI.Crit( pbf ) );

	BFIAddUndoInfo( pbf, prce );
	}

void BFRemoveUndoInfo( RCE* const prce, const LGPOS lgposModify )
	{
	//  validate IN args

	Assert( prce != prceNil );

	//  try forever to remove the deferred undo information in this RCE

	while ( prce->PgnoUndoInfo() != pgnoNull )
		{
		//  the IFMP / PGNO of the undo info in this RCE is in the cache
		//
		//  NOTE:  as long as we hold the read lock on this IFMP / PGNO, any
		//  BF we find cannot be evicted

		BFHash::CLock lockHash;
		bfhash.ReadLockKey( IFMPPGNO( prce->Ifmp(), prce->PgnoUndoInfo() ), &lockHash );

		PGNOPBF pgnopbf;
		if ( bfhash.ErrRetrieveEntry( &lockHash, &pgnopbf ) == BFHash::errSuccess )
			{
			//  lock the undo info chain on this BF

			CCriticalSection* const pcrit = &critpoolBFDUI.Crit( pgnopbf.pbf );
			pcrit->Enter();

			//  the IFMP / PGNO of the undo info in this RCE has undo info on
			//  this page

			if (	prce->PgnoUndoInfo() == pgnopbf.pbf->pgno &&
					prce->Ifmp() == pgnopbf.pbf->ifmp )
				{
				//  this page has no versions

				if ( pgnopbf.pbf->pbfTimeDepChainNext == pbfNil )
					{
#ifdef DEBUG

					//  we know that the undo info must be on this BF

					for (	RCE* prceT = pgnopbf.pbf->prceUndoInfoNext;
							prceT != prceNil && prceT != prce;
							prceT = prceT->PrceUndoInfoNext() )
						{
						}

					Assert( prceT == prce );

#endif  //  DEBUG

					//  if we are removing this undo info as a part of a lazy commit,
					//  we must depend the page on the commit record.  this is so
					//  that if we log the commit record, remove the undo info,
					//  flush the page, and then crash before flushing the commit
					//  record to the log, we will not be stranded without our undo
					//  info
					//
					//  NOTE:  this will also set the dependency for a durable
					//  commit, but it will not delay the flush of the buffer because
					//  by the time we get here, the commit record has already been
					//  flushed
					//
					//  NOTE:  the only reason it is safe to modify lgposModify
					//  without the page latch is because both lgposModify and
					//  this undo info are preventing the page from being flushed.
					//  as long as at least one keeps the BF from being flushed,
					//  we can change the other

					FMP*	pfmp	= &rgfmp[ prce->Ifmp() & ifmpMask ];
					PIB*	ppib	= prce->Pfucb()->ppib;

					if (	ppib->level == 1 &&
							pfmp->FLogOn() &&
							CmpLgpos( &ppib->lgposCommit0, &lgposMax ) != 0 )
						{
						Assert( !pfmp->Pinst()->m_plog->m_fLogDisabled );
						BFISetLgposModify( pgnopbf.pbf, ppib->lgposCommit0 );
						}

					//  remove our undo info

					BFIRemoveUndoInfo( pgnopbf.pbf, prce, lgposModify );

					//  unlock the undo info chain

					pcrit->Leave();
					}

				//  this page may have versions

				else
					{
					//  unlock the undo info chain

					pcrit->Leave();

					//  lock the dependency tree if the source page has versions
					//  so that no one can add or remove versions while we are
					//  looking for our undo info

					ENTERCRITICALSECTION ecsDepend( &critBFDepend );

					//  scan all versions of this page

					for (	PBF pbfVer = pgnopbf.pbf;
							pbfVer != pbfNil;
							pbfVer = pbfVer->pbfTimeDepChainNext )
						{
						//  lock this undo info chain

						ENTERCRITICALSECTION ecs( &critpoolBFDUI.Crit( pbfVer ) );

						//  the IFMP / PGNO of the undo info in this RCE has undo info
						//  on this page

						if (	prce->PgnoUndoInfo() == pbfVer->pgno &&
								prce->Ifmp() == pbfVer->ifmp )
							{
							//  this BF contains our undo info

							for (	RCE* prceT = pbfVer->prceUndoInfoNext;
									prceT != prceNil && prceT != prce;
									prceT = prceT->PrceUndoInfoNext() )
								{
								}

							if ( prceT != prceNil )
								{
								//  if we are removing this undo info as a part
								//  of a lazy commit, we must depend the page on
								//  the commit record.  this is so that if we
								//  log the commit record, remove the undo info,
								//  flush the page, and then crash before flushing
								//  the commit record to the log, we will not be
								//  stranded without our undo info
								//
								//  NOTE:  this will also set the dependency for
								//  a durable commit, but it will not delay the
								//  flush of the buffer because by the time we
								//  get here, the commit record has already been
								//  flushed
								//
								//  NOTE:  the only reason it is safe to modify
								//  lgposModify without the page latch is because
								//  both lgposModify and this undo info are
								//  preventing the page from being flushed. as
								//  long as at least one keeps the BF from being
								//  flushed, we can change the other

								FMP*	pfmp	= &rgfmp[ prce->Ifmp() & ifmpMask ];
								PIB*	ppib	= prce->Pfucb()->ppib;

								if (	ppib->level == 1 &&
										pfmp->FLogOn() &&
										CmpLgpos( &ppib->lgposCommit0, &lgposMax ) != 0 )
									{
									Assert( !pfmp->Pinst()->m_plog->m_fLogDisabled );

									BFISetLgposModify( pbfVer, ppib->lgposCommit0 );
									}

								//  remove our undo info

								BFIRemoveUndoInfo( pbfVer, prce, lgposModify );

								//  we're done

								break;
								}
							}

						//  this RCE doesn't have undo info on this page

						else
							{
							//  stop looking on this page

							break;
							}
						}
					}
				}

			//  this RCE doesn't have undo info on this page

			else
				{
				//  unlock the undo info chain

				pcrit->Leave();
				}
			}

		bfhash.ReadUnlockKey( &lockHash );
		}

	//  validate OUT args

	Assert( prce->PgnoUndoInfo() == pgnoNull );
	}

void BFMoveUndoInfo( const BFLatch* pbflSrc, const BFLatch* pbflDest, const KEY& keySep )
	{
	//  validate IN args

	Assert( FBFLatched( pbflSrc ) && FBFNotReadLatched( pbflSrc ) );
	Assert( !pbflDest || FBFWARLatched( pbflDest ) || FBFWriteLatched( pbflDest ) );

	PBF pbfSrc = PBF( pbflSrc->dwContext );
	PBF pbfDest = pbflDest ? PBF( pbflDest->dwContext ) : pbfNil;

	//  move all undo info of nodes whose keys are GTE the seperator key from
	//  the source page to the destination page.  if the destination page doesn't
	//  exist, throw away the undo info (i.e. move the undo info to NIL)

	//  lock the source and destination undo info chains

	CCriticalSection* const pcritSrc	= &critpoolBFDUI.Crit( pbfSrc );
	CCriticalSection* const pcritDest	= &critpoolBFDUI.Crit( pbfDest );

	CCriticalSection* const pcritMax	= max( pcritSrc, pcritDest );
	CCriticalSection* const pcritMin	= min( pcritSrc, pcritDest );

	ENTERCRITICALSECTION ecsMax( pcritMax );
	ENTERCRITICALSECTION ecsMin( pcritMin, pcritMin != pcritMax );

	//  scan all RCEs on this page

	RCE* prceNext;
	for ( RCE* prce = pbfSrc->prceUndoInfoNext; prce != prceNil; prce = prceNext )
		{
		prceNext = prce->PrceUndoInfoNext();

		//  this undo info needs to be moved

		BOOKMARK	bm;
		prce->GetBookmark( &bm );

		if ( CmpKeyWithKeyData( keySep, bm ) <= 0 )
			{
			//  remove the undo info from the source page
			//
			//  NOTE:  set the fMove flag so that the RCE's PgnoUndoInfo()
			//  is never pgnoNull during the move.  if it were to be so,
			//  someone might mistakenly think it had been removed
			//
			//  NOTE:  if there is no destination, do not set the flag

			BFIRemoveUndoInfo( pbfSrc, prce, lgposMin, pbfDest != pbfNil );

			//  add the undo info to the destination page, if any

			if ( pbfDest != pbfNil )
				{
				BFIAddUndoInfo( pbfDest, prce, fTrue );
				}
			}
		}
	}


///////////////////////////////////////////////////////////////////////////////
//
//  BF Internal Functions
//
///////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////
//  Buffer Manager System Parameter Critical Section

CCriticalSection critBFParm( CLockBasicInfo( CSyncBasicInfo( szBFParm ), rankBFParm, 0 ) );


//////////////////////////////
//  Buffer Manager Init flag

BOOL fBFInitialized = fFalse;


/////////////////////////////////////
//  Buffer Manager Global Constants

double	dblBFSpeedSizeTradeoff;
BOOL	fEnableOpportuneWrite;


//////////////////////////////////////
//  Buffer Manager Global Statistics

long cBFMemory;
long cBFPageFlushPending;


////////////////////////////////////////////////
//  Buffer Manager System Defaults Loaded flag

BOOL fBFDefaultsSet = fFalse;


//////////////////////////
//  IFMP/PGNO Hash Table

#pragma data_seg( "cacheline_aware_data" )
BFHash bfhash( rankBFHash );
#pragma data_seg()

double dblBFHashLoadFactor;
double dblBFHashUniformity;


////////////////
//  Avail Pool

#pragma bss_seg( "cacheline_aware_data" )
BFAvail bfavail;
#pragma bss_seg()


//////////
//  LRUK

#pragma data_seg( "cacheline_aware_data" )
BFLRUK bflruk( rankBFLRUK );
#pragma data_seg()

int BFLRUKK;
double csecBFLRUKCorrelatedTouch;
double csecBFLRUKTimeout;
double csecBFLRUKUncertainty;


////////////////////////////////////////////
//  Oldest Begin 0 Index and Overflow List

LGPOS dlgposBFOB0Precision;
LGPOS dlgposBFOB0Uncertainty;


///////////////////////////////
//  Deferred Undo Information

CRITPOOL< BF > critpoolBFDUI;


///////////
//  Cache

//  control

LONG_PTR		cbfCacheMin;
LONG_PTR		cbfCacheMax;
LONG_PTR		cbfCacheSet;
LONG_PTR		cbfCacheSetUser;
LONG_PTR		cbfCache;

//  stats

DWORD			cbfNewlyCommitted;
DWORD			cbfNewlyEvictedUsed;
DWORD			cpgReclaim;
DWORD			cResidenceCalc;

//  data (page) storage

LONG_PTR		cpgChunk;
void**			rgpvChunk;


//  status (BF) storage

LONG_PTR		cbfInit;
LONG_PTR		cbfChunk;
BF**			rgpbfChunk;


//  initializes the cache, or returns JET_errOutOfMemory

ERR ErrBFICacheInit()
	{
	ERR		err = JET_errSuccess;
	ULONG	ibfchunk;

	//  reset

	cbfCacheSet			= 0;
	cbfCacheSetUser		= 0;
	cbfCache			= 0;

	cbfNewlyCommitted	= 0;
	cbfNewlyEvictedUsed	= 0;
	cpgReclaim			= 0;
	cResidenceCalc		= 0;

	cpgChunk			= 0;
	rgpvChunk			= NULL;

	cbfInit				= 0;
	cbfChunk			= 0;
	rgpbfChunk			= NULL;

	//  determine our data allocation granularity to be a fraction of the total
	//  VA we have at our disposal or the total RAM we have at our disposal,
	//  whichever is less

	const size_t cbCacheMost = min( OSMemoryPageReserveTotal(), OSMemoryTotal() );
	const LONG_PTR cpgChunkMin = cbCacheMost / cCacheChunkMax / g_cbPage;
	for ( cpgChunk = 1; cpgChunk < cpgChunkMin; cpgChunk <<= 1 );

	//  allocate worst case storage for the data chunk table

	if ( !( rgpvChunk = new void*[ cCacheChunkMax ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	memset( rgpvChunk, 0, sizeof( void* ) * cCacheChunkMax );

	//  make our status chunks the same size as our data chunks

	cbfChunk = cpgChunk * g_cbPage / sizeof( BF );

	//  allocate worst case storage for the status chunk table

	if ( !( rgpbfChunk = new PBF[ cCacheChunkMax ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	memset( rgpbfChunk, 0, sizeof( PBF ) * cCacheChunkMax );

	//  set the initial cache size to the minimum cache size

	Call( ErrBFICacheSetSize( cbfCacheMin ) );

	return JET_errSuccess;

HandleError:
	BFICacheTerm();
	return err;
	}

//  terminates the cache

void BFICacheTerm()
	{
	//  set the cache size to zero

	CallS( ErrBFICacheSetSize( 0 ) );

	//  free our status chunk table

	if ( rgpbfChunk )
		{
		delete [] rgpbfChunk;
		rgpbfChunk = NULL;
		}

	//  free our data chunk table

	if ( rgpvChunk )
		{
		delete [] rgpvChunk;
		rgpvChunk = NULL;
		}
	}

//  sets the cache size

ERR ErrBFICacheSetSize( const LONG_PTR cbfCacheNew )
	{
	ERR err = JET_errSuccess;

	Assert( cbfCacheNew > 0 || !fBFInitialized );

	//  do not allow the cache size to exceed the physical limits of the cache

	const LONG_PTR cbfCacheNewLim = min( min( cbfChunk, cpgChunk ) * cCacheChunkMax, max( 0, cbfCacheNew ) );

	//  there are BFs to unquiesce (we are reducing cache shrink with some
	//  BFs still in the shrink state)

	if ( cbfCacheSet < cbfCache && cbfCacheNewLim > cbfCacheSet )
		{
		//  update the set point to reflect the unquiesced BFs

		LONG_PTR cbfCacheSetOld = cbfCacheSet;
		cbfCacheSet = min( cbfCacheNewLim, cbfCache );

		//  scan through BFs between the old set point and the new set point

		for ( IBF ibf = cbfCacheSetOld; ibf < cbfCacheSet; ibf++ )
			{
			PBF pbf = PbfBFICacheIbf( ibf );

			//  if this BF is quiesced, free it to the avail pool

			if ( pbf->fQuiesced )
				{
				BFIFreePage( pbf, fFalse );
				}
			}
		}

	//  there are BFs to allocate (we are growing the cache)

	if ( cbfCacheNewLim > cbfCache )
		{
		//  the set point should be equal to the current end of cache

		Assert( cbfCacheSet == cbfCache );

		//  update the set point to reflect the allocated BFs

		cbfCacheSet = cbfCacheNewLim;

		//  allocate space for the new cache set point

		if ( ( err = ErrBFICacheISetSize( cbfCacheNewLim ) ) < JET_errSuccess )
			{
			cbfCacheSet = cbfCache;
			Call( err );
			}
		}

	//  we are trying to shrink the cache

	if ( cbfCacheNewLim < cbfCache )
		{
		//  update the set point to quiesce and shrink the requested BFs

		cbfCacheSet = cbfCacheNewLim;

		//  find the first unquiesced BF closest to the end of the cache

		for ( IBF ibf = cbfCache - 1; ibf >= cbfCacheSet; ibf-- )
			{
			PBF pbf = PbfBFICacheIbf( ibf );

			if ( !pbf->fQuiesced )
				{
				break;
				}
			}

		//  if we are setting the cache size to zero then we must be terminating
		//  so we will free all BFs regardless of their quiesce state

		ibf = cbfCacheNewLim ? ibf : -1;

		//  free all cache beyond this BF

		CallS( ErrBFICacheISetSize( ibf + 1 ) );
		}

	//  set the page hint cache size to an appropriate size given the new
	//  cache size

	CallS( CPAGE::ErrSetPageHintCacheSize( cbfCacheNew * sizeof( DWORD_PTR ) ) );

HandleError:
	return err;
	}

//  updates our BF stats

ERR ErrBFICacheUpdateStatistics()
	{
	ERR			err		= JET_errSuccess;
	DWORD		cUpdate	= 0;
	IBitmapAPI*	pbmapi	= NULL;

	//  get our page residence data from the system

	Call( ErrOSMemoryPageResidenceMap( &cUpdate, &pbmapi ) );

	//  there has been a change in the page residence data

	if ( cUpdate != cResidenceCalc )
		{
		//  note this change in our residence data

		cResidenceCalc = cUpdate;

		//  compute our parameters for the residence check

		const size_t cbVMPage = OSMemoryPageCommitGranularity();
		for ( size_t cbitVMPage = 0; 1 << cbitVMPage != cbVMPage; cbitVMPage++ );

		const size_t	cbfVMPage	= max( 1, cbVMPage / g_cbPage );
		const size_t	cpgBF		= max( 1, g_cbPage / cbVMPage );

		//  walk every VM page in the cache

		for ( size_t iCacheChunk = 0, ibf = 0; ibf < cbfInit && iCacheChunk < cCacheChunkMax; iCacheChunk++ )
			{
			const size_t	iVMPageMin	= (size_t)rgpvChunk[ iCacheChunk ] >> cbitVMPage;
			const size_t	iVMPageMax	= iVMPageMin + ( cpgChunk * g_cbPage >> cbitVMPage );

			size_t ipgBF = 0;
			for ( size_t iVMPage = iVMPageMin; ibf < cbfInit && iVMPage < iVMPageMax; iVMPage++)
				{
				BOOL			fResident	= fTrue;
				IBitmapAPI::ERR	errBM		= IBitmapAPI::errSuccess;

				//  determine if this VM page is resident.  when in doubt, claim
				//  that it is resident

				errBM = pbmapi->ErrGet( iVMPage, &fResident );
				if ( errBM != IBitmapAPI::errSuccess )
					{
					fResident = fTrue;
					}

				//  this VM page is not resident

				if ( !fResident )
					{
					//  mark every resident BF that uses this VM page as not
					//  resident

					for ( IBF ibfT = ibf; ibfT < cbfInit && ibfT < ibf + cbfVMPage; ibfT++ )
						{
						const PBF pbf = PbfBFICacheIbf( ibfT );
 						if ( AtomicCompareExchange( (long*)&pbf->bfrs, bfrsResident, bfrsNotResident ) == bfrsResident )
 							{
 							AtomicDecrement( (long*)&cBFResident );
 							}
						}
					}

				//  advance our current BF pointer as we walk VM pages

				if ( ++ipgBF >= cpgBF )
					{
					ipgBF = 0;
					ibf += cbfVMPage;
					}
				}
			}
		}

HandleError:
	return err;
	}

//  returns the BF associated with a page pointer

INLINE PBF PbfBFICachePv( void* const pv )
	{
	return PbfBFICacheIbf( IpgBFICachePv( pv ) );
	}

//  returns fTrue if the specified page pointer is valid

INLINE BOOL FBFICacheValidPv( void* const pv )
	{
	return IpgBFICachePv( pv ) != ipgNil;
	}

//  returns fTrue if the specified BF pointer is valid

INLINE BOOL FBFICacheValidPbf( const PBF pbf )
	{
	return IbfBFICachePbf( pbf ) != ibfNil;
	}

//  returns the PBF associated with the given IBF

INLINE PBF PbfBFICacheIbf( const IBF ibf )
	{
	return (	ibf == ibfNil ?
					pbfNil :
					rgpbfChunk[ ibf / cbfChunk ] + ibf % cbfChunk );
	}

//  returns the page pointer associated with the given IPG

INLINE void* PvBFICacheIpg( const IPG ipg )
	{
	return (	ipg == ipgNil ?
					NULL :
					(BYTE*)rgpvChunk[ ipg / cpgChunk ] + ( ipg % cpgChunk ) * g_cbPage );
	}

//  returns the IBF associated with the given PBF

IBF IbfBFICachePbf( const PBF pbf )
	{
	//  scan the PBF chunk table looking for a chunk that fits in this range

	LONG_PTR ibfChunk;
	for ( ibfChunk = 0; ibfChunk < cCacheChunkMax; ibfChunk++ )
		{
		//  our PBF is part of this chunk and is aligned properly

		if (	rgpbfChunk[ ibfChunk ] &&
				rgpbfChunk[ ibfChunk ] <= pbf && pbf < rgpbfChunk[ ibfChunk ] + cbfChunk &&
				( DWORD_PTR( pbf ) - DWORD_PTR( rgpbfChunk[ ibfChunk ] ) ) % sizeof( BF ) == 0 )
			{
			//  compute the IBF for this PBF

			const IBF ibf = ibfChunk * cbfChunk + pbf - rgpbfChunk[ ibfChunk ];

			Assert( PbfBFICacheIbf( ibf ) == pbf );
			return ibf;
			}
		}

	//  our PBF isn't part of any chunk so return nil

	return ibfNil;
	}

//  returns the IPG associated with the given page pointer

IPG IpgBFICachePv( void* const pv )
	{
	//  scan the page chunk table looking for a chunk that fits in this range

	LONG_PTR ipgChunk;
	for ( ipgChunk = 0; ipgChunk < cCacheChunkMax; ipgChunk++ )
		{
		//  our page pointer is part of this chunk and is aligned properly

		if (	rgpvChunk[ ipgChunk ] &&
				rgpvChunk[ ipgChunk ] <= pv &&
				pv < (BYTE*)rgpvChunk[ ipgChunk ] + cpgChunk * g_cbPage &&
				( DWORD_PTR( pv ) - DWORD_PTR( rgpvChunk[ ipgChunk ] ) ) % g_cbPage == 0 )
			{
			//  compute the IPG for this page pointer

			const IPG ipg = ipgChunk * cpgChunk + ( (BYTE*)pv - (BYTE*)rgpvChunk[ ipgChunk ] ) / g_cbPage;

			Assert( PvBFICacheIpg( ipg ) == pv );
			return ipg;
			}
		}

	//  our page pointer isn't part of any chunk so return nil

	return ipgNil;
	}

ERR ErrBFICacheISetDataSize( const LONG_PTR cpgCacheStart, const LONG_PTR cpgCacheNew )
	{
	ERR err = JET_errSuccess;

	//  set the current cache size as the starting cache size.  this is the
	//  effective cache size for purposes of recovering on an OOM

	LONG_PTR cpgCacheCur = cpgCacheStart;

	//  convert the current and new cache sizes into chunks
	//
	//  NOTE:  this function relies on the fact that if either cpgCacheStart or
	//  cpgCacheNew are 0, then ipgChunkStart or ipgChunkNew will become -1.
	//  do not change their types to unsigned!!!

	const LONG_PTR ipgChunkStart	= cpgCacheStart ? ( cpgCacheStart - 1 ) / cpgChunk : -1;
	const LONG_PTR ipgChunkNew		= cpgCacheNew ? ( cpgCacheNew - 1 ) / cpgChunk : -1;

	//  the cache size has grown

	if ( ipgChunkNew > ipgChunkStart )
		{
		//  this is not the first allocation or an aligned allocation

		if ( cpgCacheStart % cpgChunk )
			{
			//  make sure that all the memory in the chunk at the end of the cache
			//  is committed

			const size_t ib = ( cpgCacheStart % cpgChunk ) * g_cbPage;
			const size_t cb = ( ( ipgChunkStart + 1 ) * cpgChunk - cpgCacheStart ) * g_cbPage;

			if ( !FOSMemoryPageCommit( (BYTE*)rgpvChunk[ ipgChunkStart ] + ib, cb ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}

		//  allocate cache chunks for the new range

		for ( LONG_PTR ipgChunkAlloc = ipgChunkStart + 1; ipgChunkAlloc <= ipgChunkNew; ipgChunkAlloc++ )
			{
			//	reserve a new cache chunk

			Alloc( rgpvChunk[ ipgChunkAlloc ] = PvOSMemoryPageReserve( cpgChunk * g_cbPage, NULL ) );

			//  update the cache size to reflect the new cache chunk
			//
			//  NOTE:  we do this to make OOM recovery easier

			cpgCacheCur = min( cpgCacheNew, ( ipgChunkAlloc + 1 ) * cpgChunk );

			//  commit only the memory which will be in use

			const size_t ib = 0;
			const size_t cb = min( cpgChunk, cpgCacheNew - ipgChunkAlloc * cpgChunk ) * g_cbPage;

			if ( !FOSMemoryPageCommit( (BYTE*)rgpvChunk[ ipgChunkAlloc ] + ib, cb ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}
		}

	//  the cache size has shrunk

	else if ( ipgChunkNew < ipgChunkStart )
		{
		//  free cache chunks for the new range

		for ( LONG_PTR ipgChunkFree = ipgChunkNew + 1; ipgChunkFree <= ipgChunkStart; ipgChunkFree++ )
			{
			void* const pvChunkFree = rgpvChunk[ ipgChunkFree ];
			rgpvChunk[ ipgChunkFree ] = NULL;
			OSMemoryPageDecommit( pvChunkFree, cpgChunk * g_cbPage );
			OSMemoryPageFree( pvChunkFree );
			}

		//  reset cache that will not be in use, being careful of page granularity

		const LONG_PTR cpgPerPage = max( 1, OSMemoryPageCommitGranularity() / g_cbPage );

		LONG_PTR cpgCommit = cpgCacheNew - ipgChunkNew * cpgChunk + cpgPerPage - 1;
		cpgCommit -= cpgCommit % cpgPerPage;

		LONG_PTR cpgCommitMax = cpgChunk + cpgPerPage - 1;
		cpgCommitMax -= cpgCommitMax % cpgPerPage;

		const LONG_PTR cpgReset = cpgCommitMax - cpgCommit;
		if ( cpgReset )
			{
			OSMemoryPageReset(	(BYTE*)rgpvChunk[ ipgChunkNew ] + cpgCommit * g_cbPage,
								cpgReset * g_cbPage,
								fTrue );
			}
		}

	//  the cache size has stayed the same (at least chunk-wise)

	else
		{
		//  the cache size has grown but less than one chunk

		if ( cpgCacheNew > cpgCacheStart )
			{
			//  commit only the memory which will be in use

			const size_t ib = ( cpgCacheStart % cpgChunk ) * g_cbPage;
			const size_t cb = ( cpgCacheNew - cpgCacheStart ) * g_cbPage;

			if ( !FOSMemoryPageCommit( (BYTE*)rgpvChunk[ ipgChunkStart ] + ib, cb ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}

		//  the cache size has shrunk but less than one chunk

		else if ( cpgCacheNew < cpgCacheStart )
			{
			//  reset cache that will not be in use, being careful of page granularity

			const LONG_PTR cpgPerPage = max( 1, OSMemoryPageCommitGranularity() / g_cbPage );

			LONG_PTR cpgCommit = cpgCacheNew - ipgChunkNew * cpgChunk + cpgPerPage - 1;
			cpgCommit -= cpgCommit % cpgPerPage;

			LONG_PTR cpgCommitMax = cpgChunk + cpgPerPage - 1;
			cpgCommitMax -= cpgCommitMax % cpgPerPage;

			const LONG_PTR cpgReset = cpgCommitMax - cpgCommit;
			if ( cpgReset )
				{
				OSMemoryPageReset(	(BYTE*)rgpvChunk[ ipgChunkNew ] + cpgCommit * g_cbPage,
									cpgReset * g_cbPage,
									fTrue );
				}
			}
		}

	return JET_errSuccess;

	//  on an error, rollback all changes

HandleError:
	CallS( ErrBFICacheISetDataSize( cpgCacheCur, cpgCacheStart ) );
	return err;
	}

ERR ErrBFICacheISetStatusSize( const LONG_PTR cbfCacheStart, const LONG_PTR cbfCacheNew )
	{
	ERR err = JET_errSuccess;

	//  set the current cache size as the starting cache size.  this is the
	//  effective cache size for purposes of recovering on an OOM

	LONG_PTR cbfCacheCur = cbfCacheStart;

	//  convert the current and new cache sizes into chunks
	//
	//  NOTE:  this function relies on the fact that if either cbfCacheStart or
	//  cbfCacheNew are 0, then ibfChunkStart or ibfChunkNew will become -1.
	//  do not change their types to unsigned!!!

	const LONG_PTR ibfChunkStart	= cbfCacheStart ? ( cbfCacheStart - 1 ) / cbfChunk : -1;
	const LONG_PTR ibfChunkNew		= cbfCacheNew ? ( cbfCacheNew - 1 ) / cbfChunk : -1;

	//  the cache size has grown

	if ( ibfChunkNew > ibfChunkStart )
		{
		//  this is not the first allocation or an aligned allocation

		if ( cbfCacheStart % cbfChunk )
			{
			//  make sure that all the memory in the chunk at the end of the cache
			//  is committed

			const size_t ib = ( cbfCacheStart % cbfChunk ) * sizeof( BF );
			const size_t cb = ( ( ibfChunkStart + 1 ) * cbfChunk - cbfCacheStart ) * sizeof( BF );

			if ( !FOSMemoryPageCommit( (BYTE*)rgpbfChunk[ ibfChunkStart ] + ib, cb ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}

		//  allocate cache chunks for the new range

		for ( LONG_PTR ibfChunkAlloc = ibfChunkStart + 1; ibfChunkAlloc <= ibfChunkNew; ibfChunkAlloc++ )
			{
			//	reserve a new cache chunk

			Alloc( rgpbfChunk[ ibfChunkAlloc ] = (PBF)PvOSMemoryPageReserve( cbfChunk * sizeof( BF ), NULL ) );

			//  update the cache size to reflect the new cache chunk
			//
			//  NOTE:  we do this to make OOM recovery easier

			cbfCacheCur = min( cbfCacheNew, ( ibfChunkAlloc + 1 ) * cbfChunk );

			//  commit only the memory which will be in use

			const size_t ib = 0;
			const size_t cb = min( cbfChunk, cbfCacheNew - ibfChunkAlloc * cbfChunk ) * sizeof( BF );

			if ( !FOSMemoryPageCommit( (BYTE*)rgpbfChunk[ ibfChunkAlloc ] + ib, cb ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}
		}

	//  the cache size has shrunk

	else if ( ibfChunkNew < ibfChunkStart )
		{
		//  free cache chunks for the new range

		for ( LONG_PTR ibfChunkFree = ibfChunkNew + 1; ibfChunkFree <= ibfChunkStart; ibfChunkFree++ )
			{
			const PBF pbfChunkFree = rgpbfChunk[ ibfChunkFree ];
			rgpbfChunk[ ibfChunkFree ] = NULL;
			OSMemoryPageDecommit( pbfChunkFree, cbfChunk * sizeof( BF ) );
			OSMemoryPageFree( pbfChunkFree );
			}

		//  reset cache that will not be in use, being careful of page granularity

		const LONG_PTR cbfPerPage = max( 1, OSMemoryPageCommitGranularity() / sizeof( BF ) );

		LONG_PTR cbfCommit = cbfCacheNew - ibfChunkNew * cbfChunk + cbfPerPage - 1;
		cbfCommit -= cbfCommit % cbfPerPage;

		LONG_PTR cbfCommitMax = cbfChunk + cbfPerPage - 1;
		cbfCommitMax -= cbfCommitMax % cbfPerPage;

		const LONG_PTR cbfReset = cbfCommitMax - cbfCommit;
		if ( cbfReset )
			{
			OSMemoryPageReset(	rgpbfChunk[ ibfChunkNew ] + cbfCommit,
								cbfReset * sizeof( BF ),
								fTrue );
			}
		}

	//  the cache size has stayed the same (at least chunk-wise)

	else
		{
		//  the cache size has grown but less than one chunk

		if ( cbfCacheNew > cbfCacheStart )
			{
			//  commit only the memory which will be in use

			const size_t ib = ( cbfCacheStart % cbfChunk ) * sizeof( BF );
			const size_t cb = ( cbfCacheNew - cbfCacheStart ) * sizeof( BF );

			if ( !FOSMemoryPageCommit( (BYTE*)rgpbfChunk[ ibfChunkStart ] + ib, cb ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}

		//  the cache size has shrunk but less than one chunk

		else if ( cbfCacheNew < cbfCacheStart )
			{
			//  reset cache that will not be in use, being careful of page granularity

			const LONG_PTR cbfPerPage = max( 1, OSMemoryPageCommitGranularity() / sizeof( BF ) );

			LONG_PTR cbfCommit = cbfCacheNew - ibfChunkNew * cbfChunk + cbfPerPage - 1;
			cbfCommit -= cbfCommit % cbfPerPage;

			LONG_PTR cbfCommitMax = cbfChunk + cbfPerPage - 1;
			cbfCommitMax -= cbfCommitMax % cbfPerPage;

			const LONG_PTR cbfReset = cbfCommitMax - cbfCommit;
			if ( cbfReset )
				{
				OSMemoryPageReset(	rgpbfChunk[ ibfChunkNew ] + cbfCommit,
									cbfReset * sizeof( BF ),
									fTrue );
				}
			}
		}

	return JET_errSuccess;

	//  on an error, rollback all changes

HandleError:
	CallS( ErrBFICacheISetStatusSize( cbfCacheCur, cbfCacheStart ) );
	return err;
	}

//  sets the allocated size of the cache, allocating or freeing memory as
//  necessary

ERR ErrBFICacheISetSize( const LONG_PTR cbfCacheNew )
	{
	ERR err = JET_errSuccess;

	//  save the starting cache size

	const LONG_PTR cbfCacheStart = cbfCache;
	AssertPREFIX( cbfCacheStart >= 0 );

	//  grow / shrink our data storage or rollback on OOM

	Call( ErrBFICacheISetDataSize( cbfCacheStart, cbfCacheNew ) );

	//  the cache size has grown

	if ( cbfCacheStart < cbfCacheNew )
		{
		//  grow our status storage iff we are growing past cbfInit

		if ( cbfCacheNew > cbfInit )
			{
			//  grow our status storage or rollback on OOM

			if ( ( err = ErrBFICacheISetStatusSize( cbfInit, cbfCacheNew ) ) < JET_errSuccess )
				{
				CallS( ErrBFICacheISetDataSize( cbfCacheNew, cbfCacheStart ) );
				return err;
				}

			//  init all BFs in the newly allocated range

			for ( LONG_PTR ibfInit = cbfInit; ibfInit < cbfCacheNew; ibfInit++ )
				{
				PBF pbf = PbfBFICacheIbf( ibfInit );

				//  use placement new to initialize this BF

				new( pbf ) BF;

				CSXWLatch::ERR errSXWL = pbf->sxwl.ErrTryAcquireWriteLatch();
				Assert( errSXWL == CSXWLatch::errSuccess );
				pbf->sxwl.ReleaseOwnership( bfltWrite );

				//  mark this BF as initialized

				cbfInit = ibfInit + 1;
				}
			}

		//  initialize and free all BFs in the added range

		for ( LONG_PTR ibfInit = cbfCacheStart; ibfInit < cbfCacheNew; ibfInit++ )
			{
			PBF pbf = PbfBFICacheIbf( ibfInit );

			//  set this BF's page pointer

			pbf->pv = PvBFICacheIpg( ibfInit );

			//  update our stats

			AtomicIncrement( (long*)&cBFClean );

			pbf->bfrs = bfrsNewlyCommitted;
			AtomicIncrement( (long*)&cbfNewlyCommitted );

			pbf->fNewlyEvicted = fFalse;

			//  free this BF to the avail pool

			BFIFreePage( pbf, fFalse );

			//  increase the actual cache size

			cbfCache = ibfInit + 1;
			}
		}

	//  the cache size has shrunk

	else if ( cbfCacheStart > cbfCacheNew )
		{
		//  terminate all BFs in the removed range

		for ( LONG_PTR ibfTerm = cbfCacheStart - 1; ibfTerm >= cbfCacheNew; ibfTerm-- )
			{
			PBF pbf = PbfBFICacheIbf( ibfTerm );

			//  decrease the actual cache size

			cbfCache = ibfTerm;

			//  update our stats

			if ( pbf->bfrs == bfrsNewlyCommitted )
				{
				AtomicDecrement( (long*)&cbfNewlyCommitted );
				}
			else if ( pbf->bfrs == bfrsResident )
				{
				AtomicDecrement( (long*)&cBFResident );
				}
			pbf->bfrs = bfrsNotCommitted;

			pbf->fNewlyEvicted = fFalse;

			AtomicDecrement( (long*)&cBFClean );

			//  clear this BF's page pointer

			pbf->pv = NULL;
			}

		//  shrink our status storage iff we are terminating the cache

		if ( !cbfCacheNew )
			{
			//  terminate all initialized BFs

			const LONG_PTR cbfTerm = cbfInit;
			for ( LONG_PTR ibfTerm = cbfTerm - 1; ibfTerm >= 0; ibfTerm-- )
				{
				PBF pbf = PbfBFICacheIbf( ibfTerm );

				//  mark this BF as terminated

				cbfInit = ibfTerm;

				//  explicitly destruct this BF

				if ( pbf->fQuiesced || pbf->fAvailable )
					{
					pbf->sxwl.ClaimOwnership( bfltWrite );
					pbf->sxwl.ReleaseWriteLatch();
					}

				pbf->~BF();
				}

			//  shrink our status storage

			CallS( ErrBFICacheISetStatusSize( cbfTerm, 0 ) );
			};
		}

	//  normalize the thresholds

	BFINormalizeThresholds();

HandleError:
	return err;
	}


///////////////////////////////////////
//  Cache Resource Allocation Manager

CCacheRAM cacheram;

inline CCacheRAM::CCacheRAM()
	:	m_cpgReclaimCurr( 0 ),
		m_cpgReclaimLast( 0 ),
		m_cpgReclaimNorm( 0 ),
		m_cpgEvictCurr( 0 ),
		m_cpgEvictLast( 0 ),
		m_cpgEvictNorm( 0 )
	{
	}

inline CCacheRAM::~CCacheRAM()
	{
	}

inline size_t CCacheRAM::TotalPhysicalMemoryPages()
	{
	//  return the amount of physical memory, taking quotas into account

	return OSMemoryQuotaTotal() / OSMemoryPageCommitGranularity();
	}

inline size_t CCacheRAM::AvailablePhysicalMemoryPages()
	{
	//  return the amount of available physical memory, taking quotas into
	//  account

	const size_t	cbAvail	= OSMemoryAvailable();
	const size_t	cbTotal	= OSMemoryQuotaTotal();
	const size_t	cbPool	= TotalResources() * ResourceSize();

	return min( cbAvail, cbTotal - cbPool ) / OSMemoryPageCommitGranularity();
	}

inline size_t CCacheRAM::PhysicalMemoryPageSize()
	{
	return OSMemoryPageCommitGranularity();
	}

inline long CCacheRAM::TotalPhysicalMemoryPageEvictions()
	{
	const size_t	cbQuotaTotal	= OSMemoryQuotaTotal();
	const size_t	cbTotal			= OSMemoryTotal();

	//  scale our page reclaim count up to approximate what the page reclaim
	//  count should be for the system, taking quotas into account

	const double fracCache = cbfCache * g_cbPage / (double)cbQuotaTotal;

	m_cpgReclaimCurr	= cpgReclaim;
	m_cpgReclaimNorm	+= (DWORD)( ( m_cpgReclaimCurr - m_cpgReclaimLast ) / fracCache + 0.5 );
	m_cpgReclaimLast	= m_cpgReclaimCurr;

	//  scale the OS eviction count to take quotas into account
	//
	//  NOTE:  one can set quotas such that different pools end up having
	//  different memory priorities.  for example, a pool in a process with a
	//  max size of 128MB will shrink twice as fast as a pool in a process with
	//  a max size of 64MB

	const double fracQuota = cbQuotaTotal / (double)cbTotal;

	m_cpgEvictCurr		= OSMemoryPageEvictionCount();
	m_cpgEvictNorm		+= (DWORD)( ( m_cpgEvictCurr - m_cpgEvictLast ) * fracQuota + 0.5 );
	m_cpgEvictLast		= m_cpgEvictCurr;

	//  the page eviction count is the sum of the OS eviction count and the
	//  page reclaim count which we approximate above

	return m_cpgEvictNorm + m_cpgReclaimNorm;
	}

inline size_t CCacheRAM::TotalResources()
	{
	//  factor out the newly committed cache size so that unused growth does
	//  not affect the computation for the new pool size

	return cbfCache - cbfNewlyCommitted;
	}

inline size_t CCacheRAM::ResourceSize()
	{
	return g_cbPage;
	}

inline long CCacheRAM::TotalResourceEvictions()
	{
	return cbfNewlyEvictedUsed;
	}

inline void CCacheRAM::SetOptimalResourcePoolSize( size_t cResource )
	{
	//  the optimal resouce pool size will be the new cache size

	LONG_PTR cbfCacheNew = cResource;

	//  if the cache size is being controlled externally then override the RAM

	cbfCacheNew = cbfCacheSetUser ? cbfCacheSetUser : cbfCacheNew;

	//  factor in the newly committed cache size so that unused growth does
	//  not affect the computation of the new pool size

	cbfCacheNew += cbfNewlyCommitted;

	//  limit how much cache memory we can use by the amount of virtual address
	//  space left in our process.  we do this so that we do not starve other
	//  consumers of virtual address space on machines with more physical
	//  memory than can be mapped in the current process
	//
	//  the implications of this are:
	//
	//    - other consumers of VA can push us out of memory and there is no way
	//      for us to push back because VA is not "paged" by the system
	//    - multiple DBAs that do this cannot co-exist in the same process
	//      because they will not converge or balance their memory consumption
	//
	//  NOTE:  this is only a factor on systems with limited VA

	const size_t	cbVATotal		= OSMemoryPageReserveTotal();
	const size_t	cbVAAvailMin	= size_t( cbVATotal * fracVAAvailMin );
	const size_t	cbVAAvail		= OSMemoryPageReserveAvailable();
	const size_t	cbVACache		= ( ( cbfCache + cpgChunk - 1 ) / cpgChunk ) * cpgChunk * g_cbPage;
	const size_t	cbVACacheMax	= max( cbVAAvailMin, cbVACache + cbVAAvail ) - cbVAAvailMin;
	const size_t	cbfVACacheMax	= ( cbVACacheMax / g_cbPage / cpgChunk ) * cpgChunk;

	cbfCacheNew = min( cbfCacheNew, cbfVACacheMax );

	//  limit the new cache size to the preferred operating range of cache sizes

	cbfCacheNew = max( cbfCacheNew, cbfCacheMin );
	cbfCacheNew = min( cbfCacheNew, cbfCacheMax );

	//  if the new cache size is below the deadlock threshold then force it to
	//  be large enough to avoid the deadlock

	cbfCacheNew = max( cbfCacheNew, cbfCacheDeadlock );

	//  set new cache size

	const ERR err = ErrBFICacheSetSize( cbfCacheNew );
	Assert( ( cbfCacheNew > cbfCache && err == JET_errOutOfMemory ) || err == JET_errSuccess );
	}


//////////////////
//  Clean Thread

THREAD				threadClean;
CAutoResetSignal	asigCleanThread( CSyncBasicInfo( _T( "asigCleanThread" ) ) );
volatile BOOL		fCleanThreadTerm;

LONG_PTR			cbfCleanThresholdStart = 0;
LONG_PTR			cbfScaledCleanThresholdStart;
LONG_PTR			cbfCleanThresholdStop = 0;
LONG_PTR			cbfScaledCleanThresholdStop;
long				cbCleanCheckpointDepthMax;
IFMP				ifmpStartCheckpointAdvanceScan = 0;

LONG_PTR			cbfCacheDeadlock;

DWORD				cAvailAllocLast;
TICK				tickAvailAllocLast;
BF					bfDummy;

BOOL				fIdleFlushActive;
DWORD				cIdlePagesRead;
DWORD				cIdlePagesWritten;
TICK				tickIdlePeriodStart;

size_t				icReqOld = 0;
size_t				icReqNew = 1;
ULONG				rgcReqSystem[ 2 ];
ULONG				dcReqSystem;

//  initializes the Clean Thread, or returns either JET_errOutOfMemory or
//  JET_errOutOfThreads

ERR ErrBFICleanThreadInit()
	{
	ERR		err;

	//  reset all pointers

	threadClean = NULL;

	//  reset cache stats

	cbfCacheDeadlock = 0;
	cacheram.ResetStatistics();

	//  reset avail pool stats

	cAvailAllocLast			= bfavail.CRemove();
	tickAvailAllocLast		= TickOSTimeCurrent();

	//  reset idle flush stats

	fIdleFlushActive		= fFalse;
	cIdlePagesRead			= cBFPagesRead.Get( perfinstGlobal );
	cIdlePagesWritten		= (	cBFPagesWritten.Get( perfinstGlobal ) -
								cBFPagesOpportunelyWritten.Get( perfinstGlobal ) -
								cBFPagesIdlyWritten.Get( perfinstGlobal ) );
	tickIdlePeriodStart		= TickOSTimeCurrent();

	//  create Clean Thread

	fCleanThreadTerm = fFalse;
	Call( ErrUtilThreadCreate(	BFICleanThreadIProc,
								cbBFCleanStack,
								priorityNormal,
								&threadClean,
								NULL ) );

	return JET_errSuccess;

HandleError:
	BFICleanThreadTerm();
	return err;
	}

//  terminates the Clean Thread

void BFICleanThreadTerm()
	{
	//  terminate Clean Thread

	if ( threadClean != NULL )
		{
		fCleanThreadTerm = fTrue;
		asigCleanThread.Set();
		UtilThreadEnd( threadClean );
		}
	}

//  tells Clean Thread to clean some pages

INLINE void BFICleanThreadStartClean()
	{
	asigCleanThread.Set();
	}

//  Clean Thread

//  This thread performs the following functions:  cleaning used BFs to make BFs
//  available for allocation, flushing dirty BFs during system idle periods (to
//  minimize redo time after a crash), advancing the checkpoint, and dynamically
//  adjusting the size of the cache for optimal performance according to the run-
//  time system load (cache reorganization).

DWORD BFICleanThreadIProc( DWORD_PTR dw )
	{
	//  remember that this thread is the clean thread

	Ptls()->fCleanThread = fTrue;

	//  reset state

	TICK tickNextPerfSample		= TickOSTimeCurrent() + dtickPerfSamplePeriod;
	TICK tickNextClean			= TickOSTimeCurrent() + dtickCleanPeriod;
	TICK tickNextIdleFlush		= TickOSTimeCurrent() + dtickIdleFlushPeriod;
	TICK tickNextCacheReorg		= TickOSTimeCurrent() + dtickCacheReorgPeriod;
	TICK tickNextCheckpoint		= TickOSTimeCurrent() + dtickCheckpointPeriod;
	TICK tickNextChkptAdv		= TickOSTimeCurrent() + dtickChkptAdvPeriod;

	//  service loop

	while ( !fCleanThreadTerm )
		{
		//  get the current time

		TICK tickNow = TickOSTimeCurrent();

		//  compute next task to execute and sleep duration

		TICK tickNextTask = TickMin(	TickMin(	TickMin( tickNextPerfSample, tickNextIdleFlush ),
													TickMin( tickNextCacheReorg, tickNextCheckpoint ) ),
										TickMin( tickNextClean, tickNextChkptAdv ) );
		TICK tickWait = max( long( tickNextTask - tickNow ), 0 );
		Assert( tickWait <= max(	max(	max( dtickPerfSamplePeriod, dtickIdleFlushPeriod ),
											max( dtickCacheReorgPeriod, dtickCheckpointPeriod ) ),
									max( dtickCleanPeriod, dtickChkptAdvPeriod ) ) );

		//  wait to be killed, signaled for clean, or to timeout for other operations

		BOOL fSignal = asigCleanThread.FWait( tickWait );

		//  get cache perf sample if it is time

		if ( TickCmp( TickOSTimeCurrent(), tickNextPerfSample ) >= 0 )
			{
			//  maintain cache size

			BFICleanThreadIMaintainCacheSize();

			//  maintain hashed latches

			BFICleanThreadIMaintainHashedLatches();

			//  set next perf sample time

			tickNextPerfSample = TickOSTimeCurrent() + dtickPerfSamplePeriod;
			}

		//  perform cache reorg if it is time

		if ( TickCmp( TickOSTimeCurrent(), tickNextCacheReorg ) >= 0 )
			{
			//  perform any necessary cache reorg

			BOOL fReorgDone = FBFICleanThreadIReorgCache();

			//  set next cache reorg time

			if ( fReorgDone )
				{
				tickNextCacheReorg = TickOSTimeCurrent() + dtickCacheReorgPeriod;
				}
			else
				{
				tickNextCacheReorg = TickOSTimeCurrent() + dtickRetryPeriod;
				}
			}

		//  perform checkpoint advancement if it is time

		if ( TickCmp( TickOSTimeCurrent(), tickNextChkptAdv ) >= 0 )
			{
			//  try to flush all buffers that are impeding the checkpoint

			const BOOL	fDone	= FBFICleanThreadIAdvanceCheckpoint();

			//  set next checkpoint advancement time

			tickNextChkptAdv = TickOSTimeCurrent() + ( fDone ? dtickChkptAdvPeriod : dtickRetryPeriod );
			}

		//  perform normal clean if it is time

		if ( fSignal || TickCmp( TickOSTimeCurrent(), tickNextClean ) >= 0 )
			{
			//  clean to get more avail buffers

			BOOL fDone = FBFICleanThreadIClean();

			//  set next clean time

			if ( fDone )
				{
				tickNextClean = TickOSTimeCurrent() + dtickCleanPeriod;
				}
			else
				{
				tickNextClean = TickOSTimeCurrent() + dtickRetryPeriod;
				}
			}

		//  perform idle flush if it is time

		if ( TickCmp( TickOSTimeCurrent(), tickNextIdleFlush ) >= 0 )
			{
			//  perform idle flush

			BFICleanThreadIIdleFlush();

			//  set next idle flush time

			tickNextIdleFlush = TickOSTimeCurrent() + dtickIdleFlushPeriod;
			}

		//  try to update the checkpoint if it is time

		if ( TickCmp( TickOSTimeCurrent(), tickNextCheckpoint ) >= 0 )
			{
			for ( int ipinst = 0; ipinst < ipinstMax; ipinst++ )
				{
				extern CRITPOOL< INST* > critpoolPinstAPI;
				CCriticalSection *pcritInst = &critpoolPinstAPI.Crit(&g_rgpinst[ipinst]);
				pcritInst->Enter();

				INST *pinst = g_rgpinst[ ipinst ];

				if ( pinstNil == pinst )
					{
					pcritInst->Leave();
					continue;
					}

				//	Use APILock to exclude the initializing and
				//	terminating an instance.
				const BOOL fAPILocked = pinst->APILock( pinst->fAPICheckpointing, fTrue );
				pcritInst->Leave();

				if ( fAPILocked )
					{
					if ( pinst->m_fJetInitialized )
						{
						(VOID) pinst->m_plog->ErrLGUpdateCheckpointFile( pinst->m_pfsapi, fFalse );
						}

					pinst->APIUnlock( pinst->fAPICheckpointing );
					}
				}

			//  set next checkpoint update time

			tickNextCheckpoint = TickOSTimeCurrent() + dtickCheckpointPeriod;
			}
		}

	return 0;
	}

//  cleans pages so that the Avail Pool has at least cbfScaledCleanThresholdStart
//  clean BFs, stopping when it reaches cbfScaledCleanThresholdStop BFs.  returns
//  fFalse if more cleaning is needed to reach the stop threshold

BOOL FBFICleanThreadIClean()
	{
	//  scan the LRUK looking for victims to fill the avail pool.  we will limit
	//  our search so that outstanding writes that can eventually become available
	//  buffers count as available.  at the end of the clean, we will still only
	//  consider ourselves done cleaning if the avail pool is at the requested
	//  level.  this is so we can come back later and check on the status of these
	//  flushed buffers and possibly convert them to available buffers

	FMP::BFICleanList	ilBFICleanList;
	BFLRUK::ERR			errLRUK;
	BFLRUK::CLock		lockLRUK;
	bflruk.BeginResourceScan( &lockLRUK );

	ULONG_PTR cbfFlushPending = 0;
	ULONG_PTR cbfLatched = 0;
	ULONG_PTR cbfDependent = 0;
	PBF pbf;
	while (	( errLRUK = bflruk.ErrGetNextResource( &lockLRUK, &pbf ) ) == BFLRUK::errSuccess &&
			bfavail.Cobject() + cbfFlushPending < cbfScaledCleanThresholdStop )
		{
		//  try to evict this page if it is clean or untidy

		const ERR errEvict = ErrBFIEvictPage( pbf, &lockLRUK );

		//  we failed to evict this page and we can flush more pages

		if (	errEvict < JET_errSuccess &&
				cBFPageFlushPending < cBFPageFlushPendingMax )
			{
			//  possibly async flush this page

			const ERR errFlush = ErrBFIFlushPage( pbf );

			//  count the number of latched pages we see

			if ( errEvict == errBFLatchConflict || errFlush == errBFLatchConflict )
				{
				cbfLatched++;
				}

			//  count the number of dependent pages we see

			if ( errFlush == errBFIRemainingDependencies )
				{
				cbfDependent++;
				}

			//  we caused a page to be flushed (not necessarily this page)

			if ( errFlush == errBFIPageFlushed )
				{
				cBFPagesOrdinarilyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
				cbfFlushPending++;

				//	prepare the IFMP to be flushed later

				BFICleanThreadIPrepareIssueIFMP( pbf->ifmp, &ilBFICleanList );
				}

			//  we see a page that is in the process of being flushed

			else if ( errFlush == errBFIPageFlushPending )
				{
				cbfFlushPending++;
				}
			}
		}

	//  end our scan of the LRUK

	bflruk.EndResourceScan( &lockLRUK );

	//  issue any remaining queued writes

	BFICleanThreadIIssue( &ilBFICleanList );

	//  compute the minimum cache size to avoid an allocation deadlock

	cbfCacheDeadlock = (	cbfFlushPending +
							cbfDependent +
							cbfLatched +
							cBFMemory +
							bfavail.CWaiter() );

	//	if we are suffering from an allocation deadlock then grow the cache
	//	immediately

	if ( cbfCacheDeadlock > cbfCacheSet )
		{
		const ERR err = ErrBFICacheSetSize( cbfCacheDeadlock );
		Assert( ( cbfCacheDeadlock > cbfCache && err == JET_errOutOfMemory ) || err == JET_errSuccess );
		}

	//  keep track of ongoing buffer allocations

	if ( cAvailAllocLast != bfavail.CRemove() )
		{
		cAvailAllocLast		= bfavail.CRemove();
		tickAvailAllocLast	= TickOSTimeCurrent();
		}

	if (	TickOSTimeCurrent() - tickAvailAllocLast > 1000 &&
			bfavail.CWaiter() > 0 )
		{
		OSTrace( ostlMedium, OSFormat(	"BF:  Potential clean hang:\n"
										"BF:      dtickElapsed      = %d\n"
										"BF:      cbfFlushPending   = %d\n"
										"BF:      cbfDependent      = %d\n"
										"BF:      cbfLatched        = %d\n"
										"BF:      cBFMemory         = %d\n"
										"BF:      bfavail.CWaiter() = %d\n",
										TickOSTimeCurrent() - tickAvailAllocLast,
										cbfFlushPending,
										cbfDependent,
										cbfLatched,
										cBFMemory,
										bfavail.CWaiter() ) );
		}

	//  if there hasn't been an allocation from the avail pool for some time
	//  yet there are still threads waiting to allocate available buffers
	//  then we will conclude that the clean process has hung and is unable
	//  to produce any more available buffers.  this can happen for many
	//  reasons, including:  OOM growing the cache to avoid an allocation
	//  deadlock, exceeding the max cache size while growing the cache to avoid
	//  an allocation deadlock, and failure to flush dirty buffers due to log
	//  or database write failures

	if (	TickOSTimeCurrent() - tickAvailAllocLast > dtickCleanTimeout &&
			bfavail.CWaiter() > 0 )
		{
		//  trap here first for JET_errOutOfBuffers

		(void)ErrERRCheck( JET_errOutOfBuffers );

		//  reset the last allocation time to be exactly equal to the timeout
		//  to avoid nasty wrap-around issues in case we are permanently hung

		tickAvailAllocLast = TickOSTimeCurrent() - dtickCleanTimeout;

		//  release all waiters by giving them invalid BFs allocated from the
		//  stack.  ErrBFIAllocPage will detect that these BFs are invalid and
		//  translate them into an allocation failure.  this will prevent us
		//  from permanently hanging threads in ErrBFIAllocPage

		while ( bfavail.CWaiter() > 0 )
			{
			//  acquire the X Latch on the BF.  the waiter will release this
			//  latch when it is done referencing the dummy BF

			CSXWLatch::ERR errSXWL = bfDummy.sxwl.ErrAcquireExclusiveLatch();
			Assert(	errSXWL == CSXWLatch::errSuccess );

			//  place the dummy BF in the queue so that it can be allocated by
			//  a thread waiting in ErrBFIAllocPage

			bfDummy.sxwl.ReleaseOwnership( bfltExclusive );
			bfavail.Insert( &bfDummy );

			//  wait for the thread to finish using the BF by waiting to acquire
			//  the X Latch again

			errSXWL = bfDummy.sxwl.ErrAcquireExclusiveLatch();
			Assert(	errSXWL == CSXWLatch::errSuccess ||
					errSXWL == CSXWLatch::errWaitForExclusiveLatch );
			if ( errSXWL == CSXWLatch::errWaitForExclusiveLatch )
				{
				bfDummy.sxwl.WaitForExclusiveLatch();
				}
			bfDummy.sxwl.ReleaseExclusiveLatch();

			//  fudge our last allocation count so that we don't trick ourselves
			//  into thinking that normal operations have resumed because someone
			//  allocated a buffer when in fact it was just us releasing threads
			//  with our dummy BF

			cAvailAllocLast++;
			}
		}

	//  return our status

	return bfavail.Cobject() >= cbfScaledCleanThresholdStop;
	}

//  performs idle flushing of the cache for this IFMP

void BFICleanThreadIIdleFlushForIFMP( IFMP ifmp, FMP::BFICleanList *pilBFICleanList )
	{
	FMP* pfmp = &rgfmp[ ifmp & ifmpMask ];

	//  we have a context so there may be BFs in the OB0 index

	pfmp->RwlBFContext().EnterAsReader();
	BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( ifmp & ifmpSLV ) );
	if ( pbffmp )
		{
		//  flush at least one BF from the OB0 index and overflow list

		BFOB0::ERR		errOB0;
		BFOB0::CLock	lockOB0;

		pbffmp->bfob0.MoveBeforeFirst( &lockOB0 );
		while ( pbffmp->bfob0.ErrMoveNext( &lockOB0 ) != BFOB0::errNoCurrentEntry )
			{
			PBF pbf;
			errOB0 = pbffmp->bfob0.ErrRetrieveEntry( &lockOB0, &pbf );
			Assert( errOB0 == BFOB0::errSuccess );

			LGPOS lgposOldestBegin0;
			lgposOldestBegin0.SetByIbOffset(	(	pbf->lgposOldestBegin0.IbOffset() /
													dlgposBFOB0Uncertainty.IbOffset() ) *
												dlgposBFOB0Uncertainty.IbOffset() );

			if (	pbf->bfdf == bfdfClean &&
					pbf->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
				{
				if ( pbf->bfdf == bfdfClean )
					{
					errOB0 = pbffmp->bfob0.ErrDeleteEntry( &lockOB0 );
					Assert( errOB0 == BFOB0::errSuccess );

					pbf->lgposOldestBegin0	= lgposMax;
					lgposOldestBegin0		= lgposMax;
					}
				pbf->sxwl.ReleaseExclusiveLatch();
				}
			if (	CmpLgpos( &lgposOldestBegin0, &lgposMax ) &&
					ErrBFIFlushPage( pbf ) == errBFIPageFlushed )
				{
				cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
				cBFPagesIdlyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );

				BFICleanThreadIPrepareIssueIFMP( ifmp, pilBFICleanList );
				break;
				}
			}
		pbffmp->bfob0.UnlockKeyPtr( &lockOB0 );

		pbffmp->critbfob0ol.Enter();
		PBF pbfNext;
		for ( PBF pbf = pbffmp->bfob0ol.PrevMost(); pbf != pbfNil; pbf = pbfNext )
			{
			pbfNext = pbffmp->bfob0ol.Next( pbf );

			if (	pbf->bfdf == bfdfClean &&
					pbf->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
				{
				if ( pbf->bfdf == bfdfClean )
					{
					pbf->fInOB0OL = fFalse;

					pbffmp->bfob0ol.Remove( pbf );

					pbf->lgposOldestBegin0	= lgposMax;
					}
				pbf->sxwl.ReleaseExclusiveLatch();
				}
			if (	CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) &&
					ErrBFIFlushPage( pbf ) == errBFIPageFlushed )
				{
				cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
				cBFPagesIdlyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );

				BFICleanThreadIPrepareIssueIFMP( ifmp, pilBFICleanList );
				break;
				}
			}
		pbffmp->critbfob0ol.Leave();
		}
	pfmp->RwlBFContext().LeaveAsReader();
	}

//  performs idle flushing of the cache.  this process performs incremental
//  writes of BFs by BFOB0 index then in-memory order.  The goal is not only to
//  minimize recovery time on a crash but also to give us a chance to write
//  changes made to cached pages that should only be written if we have
//  bandwidth to spare (untidy pages)

void BFICleanThreadIIdleFlush()
	{
	//  collect I/O statistics on the cache maneger

	const long	cPagesRead		= cBFPagesRead.Get( perfinstGlobal );
	const long	cPagesWritten	= (	cBFPagesWritten.Get( perfinstGlobal ) -
									cBFPagesOpportunelyWritten.Get( perfinstGlobal ) -
									cBFPagesIdlyWritten.Get( perfinstGlobal ) );

	const long	dcPagesRead		= cPagesRead - cIdlePagesRead;
	const long	dcPagesWritten	= cPagesWritten - cIdlePagesWritten;
	const long	dcPagesIO		= dcPagesRead + dcPagesWritten;

	//  some non-idle I/O occurred this period

	if ( dcPagesIO > 0 )
		{
		//  reset all I/O counters to forget that this I/O occurred

		cIdlePagesRead			= cPagesRead;
		cIdlePagesWritten		= cPagesWritten;

		//  we experienced more than a minimal amount of non-idle I/O

		if ( dcPagesIO > dcPagesIOIdleLimit )
			{
			//  reset our idle period to indicate that we are no longer idle

			tickIdlePeriodStart = TickOSTimeCurrent();
			}
		}

	//  we are idle if there has been minimal I/O other than idle flushes for
	//  at least a given period of time and we are allowed to do idle activity

	const BOOL fIdle = (	TickOSTimeCurrent() - tickIdlePeriodStart >= dtickIdleDetect &&
							!FUtilSystemRestrictIdleActivity() );

	//  we are not currently idle flushing

	if ( !fIdleFlushActive )
		{
		//  if we are idle and the cache is too dirty then activate the idle
		//  flush process

		if ( fIdle && cBFClean < pctIdleFlushStart * cbfCache / 100 )
			{
			fIdleFlushActive = fTrue;
			}
		}

	//  we are currently idle flushing

	else
		{
		//  if we are not idle or the cache is clean enough then deactivate the
		//  idle flush process

		if ( !fIdle || cBFClean >= pctIdleFlushStop * cbfCache / 100 )
			{
			fIdleFlushActive = fFalse;
			}
		}

	//  perform idle flush if active

	if ( fIdleFlushActive )
		{
		FMP::BFICleanList ilBFICleanList;

		//  compute the number of pages to flush this pass

		LONG_PTR cbfIdleFlushMin	= cbfCache * dtickIdleFlushPeriod / ctickIdleFlushTime;
		LONG_PTR cbfIdleFlushStart	= cBFPagesIdlyWritten.Get( perfinstGlobal );

		//  evenly idle flush pages from the OB0 indexes of all active databases
		//  until we have reached our limit or there are none left

		LONG_PTR cbfIdleFlushIter;
		do
			{
			cbfIdleFlushIter = cBFPagesIdlyWritten.Get( perfinstGlobal );

			for ( IFMP ifmp = FMP::IfmpMinInUse(); ifmp <= FMP::IfmpMacInUse(); ifmp++ )
				{
				if ( rgfmp[ ifmp ].DwBFContext( 0 ) )
					{
					BFICleanThreadIIdleFlushForIFMP( ifmp, &ilBFICleanList );
					}
				if ( rgfmp[ ifmp ].DwBFContext( 1 ) )
					{
					BFICleanThreadIIdleFlushForIFMP( ifmp | ifmpSLV, &ilBFICleanList );
					}
				}
			}
		while (	cBFPagesIdlyWritten.Get( perfinstGlobal ) - cbfIdleFlushStart < cbfIdleFlushMin &&
				cBFPagesIdlyWritten.Get( perfinstGlobal ) - cbfIdleFlushIter > 0 );

		//  use any remaining idle flush limit to circularly walk the cache and
		//  flush whatever we find

		static IBF ibfIdleScan = 0;

		LONG_PTR citer = 0;
		do
			{
			PBF pbf = PbfBFICacheIbf( ++ibfIdleScan % cbfInit );

			if ( ErrBFIFlushPage( pbf, bfdfUntidy ) == errBFIPageFlushed )
				{
				cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
				cBFPagesIdlyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );

				BFICleanThreadIPrepareIssueIFMP( pbf->ifmp, &ilBFICleanList );
				}
			}
		while (	cBFPagesIdlyWritten.Get( perfinstGlobal ) - cbfIdleFlushStart < cbfIdleFlushMin &&
				++citer < cbfIdleFlushMin );

		//  issue any remaining queued writes

		BFICleanThreadIIssue( &ilBFICleanList );
		}
	}

//  performs cache reorganization requested by the user changing the cache set
//  point via ErrBFSetCacheSize(), returning fTrue if done

BOOL FBFICleanThreadIReorgCache()
	{
	//  bail if no reorg is necessary

	if ( cbfCache <= cbfCacheSet )
		{
		return fTrue;
		}

	//  scan through all resident BFs above the set point, trying to flush / evict
	//  pages in order to shrink the cache

	FMP::BFICleanList ilBFICleanList;

	for ( IBF ibf = cbfCache - 1; ibf > cbfCacheSet - 1; ibf-- )
		{
		PBF pbf = PbfBFICacheIbf( ibf );

		//  we can exclusively latch this BF

		CSXWLatch::ERR errSXWL = pbf->sxwl.ErrTryAcquireExclusiveLatch();

		if ( errSXWL == CSXWLatch::errSuccess )
			{
			//  lock this BF in the LRUK in preparation for a possible eviction

			BFLRUK::CLock	lockLRUK;
			bflruk.LockResourceForEvict( pbf, &lockLRUK );

			//  release our exclusive latch.  we do not have to worry about
			//  the page being evicted because we have the LRUK locked

			pbf->sxwl.ReleaseExclusiveLatch();

			//  try to evict this page if it is clean or untidy

			const ERR errEvict = ErrBFIEvictPage( pbf, &lockLRUK );

			//  we failed to evict this page and we can flush more pages

			if (	errEvict < JET_errSuccess &&
					cBFPageFlushPending < cBFPageFlushPendingMax )
				{
				//  possibly async flush this page

				const ERR errFlush = ErrBFIFlushPage( pbf );

				//  we caused a page to be flushed (not necessarily this page)

				if ( errFlush == errBFIPageFlushed )
					{
					cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );

					//	prepare the IFMP to be flushed later

					BFICleanThreadIPrepareIssueIFMP( pbf->ifmp, &ilBFICleanList );
					}
				}

			//  unlock the LRUK

			bflruk.UnlockResourceForEvict( &lockLRUK );
			}
		}

	//  purge all BFs in the avail pool that are above the set point

	BFAvail::CLock lockAvail;
	bfavail.BeginPoolScan( &lockAvail );

	PBF pbfAvail;
	while ( bfavail.ErrGetNextObject( &lockAvail, &pbfAvail ) == BFAvail::errSuccess )
		{
		//  this BF is above the set point

		if ( IbfBFICachePbf( pbfAvail ) >= cbfCacheSet )
			{
			//  we successfully removed this BF from the avail pool

			if ( bfavail.ErrRemoveCurrentObject( &lockAvail ) == BFAvail::errSuccess )
				{
				//  mark this BF as quiesced

				pbfAvail->fAvailable	= fFalse;
				pbfAvail->fQuiesced		= fTrue;

				//  release the memory owned by this BF if possible

				if (	g_cbPage >= OSMemoryPageCommitGranularity() &&
						AtomicCompareExchange( (long*)&pbfAvail->bfrs, bfrsResident, bfrsNotResident ) == bfrsResident )
					{
					OSMemoryPageReset( pbfAvail->pv, g_cbPage, fTrue );
					AtomicDecrement( (long*)&cBFResident );
					}
				}
			}
		}

	bfavail.EndPoolScan( &lockAvail );

	//  issue any remaining queued writes

	BFICleanThreadIIssue( &ilBFICleanList );

	//  we need to start cleaning because we ate too many avail buffers from
	//  above the set point

	if ( bfavail.Cobject() <= cbfScaledCleanThresholdStart )
		{
		//  start cleaning

		BFICleanThreadStartClean();
		}

	//  set the cache size to contain the highest BF we didn't quiesce

	CallS( ErrBFICacheSetSize( cbfCacheSet ) );

	//  we are done if the cache is at or below the set size

	return cbfCache <= cbfCacheSet;
	}

//  tries to flush all buffers that are impeding the checkpoint for the given IFMP

BOOL FBFICleanThreadIAdvanceCheckpointForIFMP( IFMP ifmp, FMP::BFICleanList *pilBFICleanList )
	{
	BOOL fDone = fTrue;

	FMP* pfmp = &rgfmp[ ifmp & ifmpMask ];

	//  if no context is present, there must be no buffers impeding the checkpoint

	pfmp->RwlBFContext().EnterAsReader();
	BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( ifmp & ifmpSLV ) );
	if ( !pbffmp )
		{
		pfmp->RwlBFContext().LeaveAsReader();
		return fDone;
		}

	//  get the most recent log record

	LOG* const	plog		= pfmp->Pinst()->m_plog;
	const LGPOS	lgposNewest	= plog->m_fRecoveringMode == fRecoveringRedo ?
								plog->m_lgposRedo :
								plog->m_lgposLogRec;

	//  flush all buffers that are impeding the checkpoint

	BFOB0::ERR		errOB0;
	BFOB0::CLock	lockOB0;

	pbffmp->bfob0.MoveBeforeFirst( &lockOB0 );
	while ( pbffmp->bfob0.ErrMoveNext( &lockOB0 ) != BFOB0::errNoCurrentEntry )
		{
		//  if we have too many oustanding page flushes then we will need to
		//  try again later

		if ( cBFPageFlushPending >= cBFPageFlushPendingMax )
			{
			break;
			}

		PBF pbf;
		errOB0 = pbffmp->bfob0.ErrRetrieveEntry( &lockOB0, &pbf );
		Assert( errOB0 == BFOB0::errSuccess );

		LGPOS lgposOldestBegin0;
		lgposOldestBegin0.SetByIbOffset(	(	pbf->lgposOldestBegin0.IbOffset() /
												dlgposBFOB0Uncertainty.IbOffset() ) *
											dlgposBFOB0Uncertainty.IbOffset() );

		if (	plog->CbOffsetLgpos( lgposNewest, lgposOldestBegin0 ) > cbCleanCheckpointDepthMax ||
				pbf->bfdf == bfdfClean )
			{
			if (	pbf->bfdf == bfdfClean &&
					pbf->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
				{
				if ( pbf->bfdf == bfdfClean )
					{
					errOB0 = pbffmp->bfob0.ErrDeleteEntry( &lockOB0 );
					Assert( errOB0 == BFOB0::errSuccess );

					pbf->lgposOldestBegin0	= lgposMax;
					lgposOldestBegin0		= lgposMax;
					}
				pbf->sxwl.ReleaseExclusiveLatch();
				}
			if ( CmpLgpos( &lgposOldestBegin0, &lgposMax ) )
				{
				switch( ErrBFIFlushPage( pbf ) )
					{
					case errBFIPageFlushed:
						cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
						BFICleanThreadIPrepareIssueIFMP( ifmp, pilBFICleanList );
					case errBFIPageFlushPending:
					case errBFIRemainingDependencies:
					case errBFLatchConflict:
						fDone = fFalse;
						break;
					default:
						break;
					}
				}
			}
		else
			{
			break;
			}
		}
	pbffmp->bfob0.UnlockKeyPtr( &lockOB0 );

	pbffmp->critbfob0ol.Enter();
	PBF pbfNext;
	for ( PBF pbf = pbffmp->bfob0ol.PrevMost(); pbf != pbfNil; pbf = pbfNext )
		{
		pbfNext = pbffmp->bfob0ol.Next( pbf );

		//  if we have too many oustanding page flushes then we will need to
		//  try again later

		if ( cBFPageFlushPending >= cBFPageFlushPendingMax )
			{
			break;
			}

		if (	plog->CbOffsetLgpos( lgposNewest, pbf->lgposOldestBegin0 ) > cbCleanCheckpointDepthMax ||
				pbf->bfdf == bfdfClean )
			{
			if (	pbf->bfdf == bfdfClean &&
					pbf->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
				{
				if ( pbf->bfdf == bfdfClean )
					{
					pbf->fInOB0OL = fFalse;

					pbffmp->bfob0ol.Remove( pbf );

					pbf->lgposOldestBegin0	= lgposMax;
					}
				pbf->sxwl.ReleaseExclusiveLatch();
				}
			if ( CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) )
				{
				switch( ErrBFIFlushPage( pbf ) )
					{
					case errBFIPageFlushed:
						cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
						BFICleanThreadIPrepareIssueIFMP( ifmp, pilBFICleanList );
					case errBFIPageFlushPending:
					case errBFIRemainingDependencies:
					case errBFLatchConflict:
						fDone = fFalse;
						break;
					default:
						break;
					}
				}
			}
		}
	pbffmp->critbfob0ol.Leave();

	pfmp->RwlBFContext().LeaveAsReader();

	return fDone;
	}

//  tries to flush all buffers that are impeding the checkpoint

BOOL FBFICleanThreadIAdvanceCheckpoint()
	{
	FMP::BFICleanList	ilBFICleanList;
	BOOL				fDone			= fTrue;
	const IFMP			ifmpMin			= FMP::IfmpMinInUse();
	const IFMP			ifmpMac			= FMP::IfmpMacInUse();
	IFMP				ifmpStart		= ifmpStartCheckpointAdvanceScan;
	IFMP				ifmp;

	if ( cBFPageFlushPending >= cBFPageFlushPendingMax || ifmpMin > ifmpMac )
		{
		//	if too many I/O's are already pending, don't even bother
		//	trying to flush more
		//
		//	if no active databases, bail
		//
		return fDone;
		}

	//	NOTE: we took a snapshot of ifmpMin/MacInUse because it could be
	//	being updated even as we're checking.  However, it shouldn't
	//	really matter to take a snapshot because the start/stop ifmps are
	//	just optimisations to prevent us from scanning the entire FMP
	//	array, so in the worst case, we'll either just scan extra FMPs
	//	only to find that there's nothing to be done or we'll end up
	//	skipping some FMPs, but we'll just get those the next time
	//	around

	//	ensure starting FMP is in range
	//
	if ( ifmpStart < ifmpMin || ifmpStart > ifmpMac )
		{
		ifmpStart = ifmpMin;
		}

	//  scan all active databases
	//
	ifmp = ifmpStart;
	do
		{
		Assert( ifmp >= ifmpMin );
		Assert( ifmp <= ifmpMac );

		//  advance the checkpoint for this IFMP
		//
		if ( rgfmp[ ifmp ].DwBFContext( 0 ) )
			{
			fDone = FBFICleanThreadIAdvanceCheckpointForIFMP( ifmp, &ilBFICleanList ) && fDone;
			}
		if ( rgfmp[ ifmp ].DwBFContext( 1 ) )
			{
			fDone = FBFICleanThreadIAdvanceCheckpointForIFMP( ifmp | ifmpSLV, &ilBFICleanList ) && fDone;
			}

		//	advance to next ifmp for the next iteration of the loop,
		//	properly handling wraparound
		//
		ifmp++;
		if ( ifmp > ifmpMac )
			{
			ifmp = ifmpMin;
			}
		}
	while ( ifmp != ifmpStart && cBFPageFlushPending < cBFPageFlushPendingMax );

	if ( cBFPageFlushPending >= cBFPageFlushPendingMax )
		{
		//	if there are excessive I/O's pending, since we queue dirty pages in
		//	ascending IFMP order, we may not have been able to flush dirty pages
		//	for higher-numbered IFMP's (and which subsequently ends up holding back
		//	checkpoint advancement), so to ensure the checkpoint doesn't get bogged
		//	down by a lot of activity on one database, start on the next IFMP the
		//	next time around
		//
		ifmpStartCheckpointAdvanceScan = ifmpStart + 1;
		}
	else
		{
		//	we didn't find a lot of pages to queue for I/O, so next time around,
		//	it's safe to start at the first IFMP without worrying that dirty pages
		//	belonging to higher-numbered IFMP's got skipped
		//
		ifmpStartCheckpointAdvanceScan = 0;
		}

	//  issue any remaining queued writes

	BFICleanThreadIIssue( &ilBFICleanList );

	return fDone;
	}


//	prepare to flush an IFMP by putting it into the clean thread's private flush list and
//	marking its database or SLV file

void BFICleanThreadIPrepareIssueIFMP( IFMP ifmp, FMP::BFICleanList *pilBFICleanList )
	{
	FMP *pfmpFlush = &rgfmp[ ifmp & ifmpMask ];

	Assert( pilBFICleanList );
	if ( !pilBFICleanList->FMember( pfmpFlush ) )
		{
		pilBFICleanList->InsertAsNextMost( pfmpFlush );
		}

	if ( ifmp & ifmpSLV )
		{
		pfmpFlush->SetBFICleanSLV();
		}
	else
		{
		pfmpFlush->SetBFICleanDb();
		}
	}

//	flush the clean thread's private list of IFMPs

void BFICleanThreadIIssue( FMP::BFICleanList *pilBFICleanList )
	{
	FMP *pfmpT;

	//	flush each IFMP in the list

	Assert( pilBFICleanList );
	pfmpT = pilBFICleanList->PrevMost();
	while ( pfmpT )
		{

		//	issue I/O

		if ( pfmpT->FBFICleanDb() )
			{
			CallS( pfmpT->Pfapi()->ErrIOIssue() );
			pfmpT->ResetBFICleanDb();
			}

		if ( pfmpT->FBFICleanSLV() )
			{
			CallS( pfmpT->PfapiSLV()->ErrIOIssue() );
			pfmpT->ResetBFICleanSLV();
			}

		//	remove this FMP and move next

		FMP *pfmpNext = pilBFICleanList->Next( pfmpT );
		pilBFICleanList->Remove( pfmpT );
		pfmpT = pfmpNext;
		}
	}

//  automatically maintains the size of the cache based on real time data

void BFICleanThreadIMaintainCacheSize()
	{
	//  update our BF stats

	(void)ErrBFICacheUpdateStatistics();

	//  update our RAM stats

	cacheram.UpdateStatistics();
	}

//  automatically distributes the hashed latches to the BFs containing the
//  hottest page data in the cache

void BFICleanThreadIMaintainHashedLatches()
	{
	const size_t	cProc = OSSyncGetProcessorCountMax();
	size_t			iProc;
	size_t			iNominee;
	size_t			iHashedLatch;
	ULONG			rgdcReqNomineeSum[ cBFNominee ];
	ULONG			rgdcReqNomineeMax[ cBFNominee ];
	ULONG			rgdcReqHashedLatchSum[ cBFHashedLatch ];
	ULONG			dcReqHashedLatchTotal;
	size_t			iNomineeWinner;
	ULONG			dcReqNomineeSumWinner;
	size_t			iHashedLatchLoser;
	ULONG			dcReqHashedLatchSumLoser;
	PBF				pbfElect;
	PBF				pbfLoser;
	PBF				pbfWinner;

	//  collect the raw latch counts for the system, the nominee elect, each
	//  nominee, and each hashed latch

	rgcReqSystem[ icReqNew ] = cBFCacheReq.Get( perfinstGlobal );

	for ( iProc = 0; iProc < cProc; iProc++ )
		{
		PLS* const ppls = Ppls( iProc );

		for ( iNominee = 0; iNominee < cBFNominee; iNominee++ )
			{
			ppls->rgcreqBFNominee[ icReqNew ][ iNominee ] = ppls->rgBFNominee[ iNominee ].cCacheReq;
			}
		for ( iHashedLatch = 0; iHashedLatch < cBFHashedLatch; iHashedLatch++ )
			{
			ppls->rgcreqBFHashedLatch[ icReqNew ][ iHashedLatch ] = ppls->rgBFHashedLatch[ iHashedLatch ].cCacheReq;
			}
		}

	//  compute the latch count for the sampling interval for the above data

	dcReqSystem = rgcReqSystem[ icReqNew ] - rgcReqSystem[ icReqOld ];

	for ( iProc = 0; iProc < cProc; iProc++ )
		{
		PLS* const ppls = Ppls( iProc );

		for ( iNominee = 0; iNominee < cBFNominee; iNominee++ )
			{
			ppls->rgdcreqBFNominee[ iNominee ] = ppls->rgcreqBFNominee[ icReqNew ][ iNominee ] - ppls->rgcreqBFNominee[ icReqOld ][ iNominee ];
			}
		for ( iHashedLatch = 0; iHashedLatch < cBFHashedLatch; iHashedLatch++ )
			{
			ppls->rgdcreqBFHashedLatch[ iHashedLatch ] = ppls->rgcreqBFHashedLatch[ icReqNew ][ iHashedLatch ] - ppls->rgcreqBFHashedLatch[ icReqOld ][ iHashedLatch ];
			}
		}

	//  swap old and new data sets for the next data collection cycle

	icReqOld	= icReqOld ^ 1;
	icReqNew	= icReqNew ^ 1;

	//  cook the latch count data to support our decision making

	for ( iNominee = 0; iNominee < cBFNominee; iNominee++ )
		{
		rgdcReqNomineeSum[ iNominee ] = 0;
		rgdcReqNomineeMax[ iNominee ] = 0;
		}
	for ( iHashedLatch = 0; iHashedLatch < cBFHashedLatch; iHashedLatch++ )
		{
		rgdcReqHashedLatchSum[ iHashedLatch ] = 0;
		}

	for ( iProc = 0; iProc < cProc; iProc++ )
		{
		PLS* const ppls = Ppls( iProc );

		for ( iNominee = 0; iNominee < cBFNominee; iNominee++ )
			{
			rgdcReqNomineeSum[ iNominee ] += ppls->rgdcreqBFNominee[ iNominee ];
			rgdcReqNomineeMax[ iNominee ] = max( rgdcReqNomineeMax[ iNominee ], ppls->rgdcreqBFNominee[ iNominee ] );
			}
		for ( iHashedLatch = 0; iHashedLatch < cBFHashedLatch; iHashedLatch++ )
			{
			rgdcReqHashedLatchSum[ iHashedLatch ] += ppls->rgdcreqBFHashedLatch[ iHashedLatch ];
			}
		}

	dcReqHashedLatchTotal = 0;
	for ( iHashedLatch = 0; iHashedLatch < cBFHashedLatch; iHashedLatch++ )
		{
		dcReqHashedLatchTotal += rgdcReqHashedLatchSum[ iHashedLatch ];
		}

	//  choose the winning nominee as follows:
	//  -  it doesn't have a majority of its latches on one processor
	//  -  it has the highest latch count of qualifying nominees

	iNomineeWinner			= 0;
	dcReqNomineeSumWinner	= 0;

	for ( iNominee = 1; iNominee < cBFNominee; iNominee++ )
		{
		const PBF pbfNominee = Ppls( 0 )->rgBFNominee[ iNominee ].pbf;

		if (	pbfNominee != pbfNil &&
				rgdcReqNomineeMax[ iNominee ] < pctProcAffined * rgdcReqNomineeSum[ iNominee ] &&
				dcReqNomineeSumWinner < rgdcReqNomineeSum[ iNominee ] )
			{
			iNomineeWinner			= iNominee;
			dcReqNomineeSumWinner	= rgdcReqNomineeSum[ iNominee ];
			}
		}

	//  choose the hashed latch with the smallest latch count as the loser

	iHashedLatchLoser			= 0;
	dcReqHashedLatchSumLoser	= -1;

	for ( iHashedLatch = 0; iHashedLatch < cBFHashedLatch; iHashedLatch++ )
		{
		if ( dcReqHashedLatchSumLoser > rgdcReqHashedLatchSum[ iHashedLatch ] )
			{
			iHashedLatchLoser			= iHashedLatch;
			dcReqHashedLatchSumLoser	= rgdcReqHashedLatchSum[ iHashedLatch ];
			}
		}

	//  we will promote the nominee elect if:
	//  -  it doesn't have a majority of its latches on one processor
	//  -  its latch count exceeds the latch count of the loser
	//  -  we can try acquire the X Latch on the nominee elect and the loser
	//  -  we can demote the loser to a normal latch

	pbfElect	= Ppls( 0 )->rgBFNominee[ 0 ].pbf;
	pbfLoser	= Ppls( 0 )->rgBFHashedLatch[ iHashedLatchLoser ].pbf;

	if (	pbfElect != pbfNil &&
			rgdcReqNomineeMax[ 0 ] < pctProcAffined * rgdcReqNomineeSum[ 0 ] &&
			rgdcReqNomineeSum[ 0 ] > dcReqHashedLatchSumLoser )
		{
		if ( pbfElect->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
			{
			if (	pbfLoser == pbfNil ||
					pbfLoser->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
				{
				if ( pbfLoser == pbfNil || FBFILatchDemote( pbfLoser ) )
					{
					for ( iProc = 0; iProc < cProc; iProc++ )
						{
						PLS* const ppls = Ppls( iProc );
						ppls->rgBFNominee[ 0 ].pbf = pbfNil;
						ppls->rgBFHashedLatch[ iHashedLatchLoser ].pbf = pbfElect;
						}
					pbfElect->iHashedLatch = iHashedLatchLoser;
					pbfElect->bfls = bflsHashed;
					if ( pbfLoser != pbfNil )
						{
						OSTrace( ostlMedium, OSFormat(	"BF %s in slot %d demoted (%.2f%% %d)",
														OSFormatPointer( pbfLoser ),
														iHashedLatchLoser,
														100.0 * dcReqHashedLatchSumLoser / dcReqSystem,
														dcReqHashedLatchSumLoser ) );
						}
					OSTrace( ostlMedium, OSFormat(	"BF %s promoted to slot %d (%.2f%% %d %.2f%%)",
													OSFormatPointer( pbfElect ),
													iHashedLatchLoser,
													100.0 * rgdcReqNomineeSum[ 0 ] / dcReqSystem,
													rgdcReqNomineeSum[ 0 ],
													100.0 * rgdcReqNomineeMax[ 0 ] / rgdcReqNomineeSum[ 0 ] ) );
					OSTrace( ostlMedium, OSFormat(	"Hashed Latch Summary:\n"
													"---------------------\n"
													" 0    %.2f%%\n"
													" 1    %.2f%%\n"
													" 2    %.2f%%\n"
													" 3    %.2f%%\n"
													" 4    %.2f%%\n"
													" 5    %.2f%%\n"
													" 6    %.2f%%\n"
													" 7    %.2f%%\n"
													" 8    %.2f%%\n"
													" 9    %.2f%%\n"
													"10    %.2f%%\n"
													"11    %.2f%%\n"
													"12    %.2f%%\n"
													"13    %.2f%%\n"
													"14    %.2f%%\n"
													"15    %.2f%%\n"
													"Total %.2f%%",
													100.0 * rgdcReqHashedLatchSum[ 0 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 1 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 2 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 3 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 4 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 5 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 6 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 7 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 8 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 9 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 10 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 11 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 12 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 13 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 14 ] / dcReqSystem,
													100.0 * rgdcReqHashedLatchSum[ 15 ] / dcReqSystem,
													100.0 * dcReqHashedLatchTotal / dcReqSystem ) );
					}
				if ( pbfLoser != pbfNil )
					{
					pbfLoser->sxwl.ReleaseExclusiveLatch();
					}
				}
			pbfElect->sxwl.ReleaseExclusiveLatch();
			}
		}

	//  if there was a nominee elect and we decided not to promote it then
	//  strip it of its nominee elect status and make it ineligible for
	//  nomination for a while

	else if ( pbfElect != pbfNil )
		{
		if ( pbfElect->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
			{
			for ( iProc = 0; iProc < cProc; iProc++ )
				{
				BFNominee* const pbfn = &Ppls( iProc )->rgBFNominee[ 0 ];
				pbfn->pbf = pbfNil;
				}
			pbfElect->tickEligibleForNomination = TickOSTimeCurrent() + dtickPromotionDenied;
			pbfElect->bfls = bflsNormal;
			OSTrace( ostlMedium, OSFormat(	"BF %s denied promotion (%.2f%% %d %.2f%% %d)",
											OSFormatPointer( pbfElect ),
											100.0 * rgdcReqNomineeSum[ 0 ] / dcReqSystem,
											rgdcReqNomineeSum[ 0 ],
											100.0 * rgdcReqNomineeMax[ 0 ] / rgdcReqNomineeSum[ 0 ],
											dcReqHashedLatchSumLoser ) );
			OSTrace( ostlMedium, OSFormat(	"Hashed Latch Summary:\n"
											"---------------------\n"
											" 0    %.2f%%\n"
											" 1    %.2f%%\n"
											" 2    %.2f%%\n"
											" 3    %.2f%%\n"
											" 4    %.2f%%\n"
											" 5    %.2f%%\n"
											" 6    %.2f%%\n"
											" 7    %.2f%%\n"
											" 8    %.2f%%\n"
											" 9    %.2f%%\n"
											"10    %.2f%%\n"
											"11    %.2f%%\n"
											"12    %.2f%%\n"
											"13    %.2f%%\n"
											"14    %.2f%%\n"
											"15    %.2f%%\n"
											"Total %.2f%%",
											100.0 * rgdcReqHashedLatchSum[ 0 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 1 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 2 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 3 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 4 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 5 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 6 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 7 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 8 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 9 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 10 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 11 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 12 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 13 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 14 ] / dcReqSystem,
											100.0 * rgdcReqHashedLatchSum[ 15 ] / dcReqSystem,
											100.0 * dcReqHashedLatchTotal / dcReqSystem ) );
			pbfElect->sxwl.ReleaseExclusiveLatch();
			}
		}

	//  if there is no nominee elect and there is a winning nominee then make
	//  it the new nominee elect

	pbfWinner = Ppls( 0 )->rgBFNominee[ iNomineeWinner ].pbf;

	if ( Ppls( 0 )->rgBFNominee[ 0 ].pbf == pbfNil && pbfWinner != pbfNil )
		{
		if ( pbfWinner->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
			{
			for ( iProc = 0; iProc < cProc; iProc++ )
				{
				PLS* const ppls = Ppls( cProc - 1 - iProc );
				ppls->rgBFNominee[ iNomineeWinner ].pbf = pbfNil;
				ppls->rgBFNominee[ 0 ].pbf = pbfWinner;
				}
			pbfWinner->bfls = bflsElect;
			OSTrace( ostlMedium, OSFormat(	"BF %s in slot %d elected (%d %.2f%%)",
											OSFormatPointer( pbfWinner ),
											iNomineeWinner,
											rgdcReqNomineeSum[ iNomineeWinner ],
											100.0 * rgdcReqNomineeMax[ iNomineeWinner ] / rgdcReqNomineeSum[ iNomineeWinner ] ) );
			pbfWinner->sxwl.ReleaseExclusiveLatch();
			}
		}

	//  purge the losing nominees so that new BFs can try for a hashed latch.
	//  also prevent the losers from being nominated again for a while to help
	//  give those BFs a chance to get in

	for ( iNominee = 1; iNominee < cBFNominee; iNominee++ )
		{
		if ( iNominee != iNomineeWinner )
			{
			const PBF pbfNominee = Ppls( 0 )->rgBFNominee[ iNominee ].pbf;

			if (	pbfNominee != pbfNil &&
					pbfNominee->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
				{
				for ( iProc = 0; iProc < cProc; iProc++ )
					{
					PLS* const ppls = Ppls( cProc - 1 - iProc );
					ppls->rgBFNominee[ iNominee ].pbf = pbfNil;
					}
				pbfNominee->tickEligibleForNomination = TickOSTimeCurrent() + dtickLosingNominee;
				pbfNominee->bfls = bflsNormal;
				OSTrace( ostlMedium, OSFormat(	"BF %s in slot %d purged (%d %.2f%%)",
												OSFormatPointer( pbfNominee ),
												iNominee,
												rgdcReqNomineeSum[ iNominee ],
												100.0 * rgdcReqNomineeMax[ iNominee ] / rgdcReqNomineeSum[ iNominee ] ) );
				pbfNominee->sxwl.ReleaseExclusiveLatch();
				}
			}
		}
	}

//  Internal Functions

	//  Hashed Latch

INLINE BOOL FBFILatchValidContext( const DWORD_PTR dwContext )
	{
	//  if the least significant bit is set in the latch context then it
	//  contains a pointer to the BFHashedLatch that is latched

	if ( dwContext & 1 )
		{
		BFHashedLatch* const pbfhl = (BFHashedLatch*)( dwContext ^ 1 );

		for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
			{
			PLS* const ppls = Ppls( iProc );

			if (	ppls->rgBFHashedLatch <= pbfhl && pbfhl < ppls->rgBFHashedLatch + cBFHashedLatch &&
					( DWORD_PTR( pbfhl ) - DWORD_PTR( ppls->rgBFHashedLatch ) ) % sizeof( BFHashedLatch ) == 0 )
				{
				return fTrue;
				}
			}
		return fFalse;
		}

	//  if the least significant bit is clear in the latch context then it
	//  contains a pointer to the BF that is latched

	else
		{
		return FBFICacheValidPbf( PBF( dwContext ) );
		}
	}

INLINE PBF PbfBFILatchContext( const DWORD_PTR dwContext )
	{
	//  if the least significant bit is set in the latch context then it
	//  contains a pointer to the BFHashedLatch that is latched

	if ( dwContext & 1 )
		{
		return ((BFHashedLatch*)( dwContext ^ 1 ))->pbf;
		}

	//  if the least significant bit is clear in the latch context then it
	//  contains a pointer to the BF that is latched

	else
		{
		return PBF( dwContext );
		}
	}

INLINE CSXWLatch* PsxwlBFILatchContext( const DWORD_PTR dwContext )
	{
	//  if the least significant bit is set in the latch context then it
	//  contains a pointer to the BFHashedLatch that is latched

	if ( dwContext & 1 )
		{
		return &((BFHashedLatch*)( dwContext ^ 1 ))->sxwl;
		}

	//  if the least significant bit is clear in the latch context then it
	//  contains a pointer to the BF that is latched

	else
		{
		return &PBF( dwContext )->sxwl;
		}
	}

void BFILatchNominate( const PBF pbf )
	{
	//  we should not have the exclusive latch or write latch on this BF

	Assert( pbf->sxwl.FNotOwnExclusiveLatch() && pbf->sxwl.FNotOwnWriteLatch() );

	//  disable ownership tracking because we abuse the exclusive latch below

	CLockDeadlockDetectionInfo::DisableOwnershipTracking();

	//  the BF has a normal latch, is eligible to be nominated, and can be
	//  locked for nomination

	if (	pbf->bfls == bflsNormal &&
			TickCmp( TickOSTimeCurrent(), pbf->tickEligibleForNomination ) > 0 &&
			bflruk.FSuperHotResource( pbf ) &&
			pbf->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
		{
		//  the BF is locked and still has a normal latch

		if ( pbf->bfls == bflsNormal )
			{
			//  try to allocate a nominee slot for this BF (don't use slot 0!)

			PLS* const ppls = Ppls();
			for ( size_t iNominee = 1; iNominee < cBFNominee; iNominee++ )
				{
				if ( ppls->rgBFNominee[ iNominee ].pbf == pbfNil )
					{
					if ( AtomicCompareExchangePointer(	(void**)&Ppls( 0 )->rgBFNominee[ iNominee ].pbf,
														pbfNil,
														pbf ) == pbfNil )
						{
						break;
						}
					}
				}

			//  we got a nominee slot

			if ( iNominee < cBFNominee )
				{
				//  setup the nominee slot for each processor

				for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
					{
					BFNominee* const pbfn = &Ppls( iProc )->rgBFNominee[ iNominee ];
					pbfn->pbf = pbf;
					}

				//  mark the BF as a nominee

				Assert( bflsNominee1 <= iNominee && iNominee <= bflsNominee3 );
				pbf->bfls = iNominee;
				OSTrace( ostlMedium, OSFormat( "BF %s nominated and placed in slot %d", OSFormatPointer( pbf ), iNominee ) );
				}

			//  we did not get a nominee slot

			else
				{
				//  prevent any further attempts to nominate this BF until nominee
				//  slots become available again

				pbf->tickEligibleForNomination = TickOSTimeCurrent() + dtickPerfSamplePeriod;
				}
			}

		//  unlock the BF

		pbf->sxwl.ReleaseExclusiveLatch();
		}

	//  we're done abusing the exclusive latch now

	CLockDeadlockDetectionInfo::EnableOwnershipTracking();

	//  if the BF is a nominee then vote for it to be promoted to a hashed latch

	const BFLatchState bfls = BFLatchState( pbf->bfls );
	if ( bflsNominee1 <= bfls && bfls <= bflsNominee3 )
		{
		Ppls()->rgBFNominee[ bfls ].cCacheReq++;
		}
	}

BOOL FBFILatchDemote( const PBF pbf )
	{
	//  we should have the exclusive latch or the write latch on this BF

	Assert( pbf->sxwl.FOwnExclusiveLatch() || pbf->sxwl.FOwnWriteLatch() );

	//  if this BF has a hashed latch then try to demote the BF to a normal
	//  latch

	if ( pbf->bfls == bflsHashed )
		{
		//  remember which hashed latch this BF currently owns

		const ULONG iHashedLatch = pbf->iHashedLatch;

		//  try to acquire the write latch on all the hashed latch for all
		//  processors

		for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
			{
			CSXWLatch* const psxwlProc = &Ppls( iProc )->rgBFHashedLatch[ iHashedLatch ].sxwl;
			if ( psxwlProc->ErrTryAcquireWriteLatch() == CSXWLatch::errLatchConflict )
				{
				break;
				}
			}

		//  we got all the latches

		if ( iProc == OSSyncGetProcessorCountMax() )
			{
			//  turn off hashed latch mode for this BF

			pbf->bfls = bflsNormal;

			//  make the BF eligible for nomination

			pbf->tickEligibleForNomination = TickOSTimeCurrent();

			//  reset the hashed latch for each processor

			for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
				{
				BFHashedLatch* const pbfhl = &Ppls( iProc )->rgBFHashedLatch[ iHashedLatch ];
				pbfhl->pbf = pbfNil;
				}
			}

		//  release all the latches we acquired

		for ( size_t iProc2 = 0; iProc2 < iProc; iProc2++ )
			{
			CSXWLatch* const psxwlProc = &Ppls( iProc2 )->rgBFHashedLatch[ iHashedLatch ].sxwl;
			psxwlProc->ReleaseWriteLatch();
			}
		}

	//  we succeeded if the BF is no longer in hashed latch mode

	return pbf->bfls != bflsHashed;
	}

	//  System Parameters

//  validates the current configuration of all cache manager settings

ERR ErrBFIValidateParameters()
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  get all the settings that we are going to be checking

	ULONG_PTR cbfCacheMinT;
	CallS( ErrBFGetCacheSizeMin( &cbfCacheMinT ) );
	ULONG_PTR cbfCacheMaxT;
	CallS( ErrBFGetCacheSizeMax( &cbfCacheMaxT ) );
	ULONG_PTR cbfCleanThresholdStartT;
	CallS( ErrBFGetStartFlushThreshold( &cbfCleanThresholdStartT ) );
	ULONG_PTR cbfCleanThresholdStopT;
	CallS( ErrBFGetStopFlushThreshold( &cbfCleanThresholdStopT ) );

	//  if any of our settings don't make sense then adjust them to be close
	//  to what was asked for but still legal

	if ( cbfCacheMinT > cbfCacheMaxT )
		{
		cbfCacheMinT = cbfCacheMaxT;
		CallS( ErrBFSetCacheSizeMin( cbfCacheMinT ) );
		}

	if ( cbfCleanThresholdStopT > cbfCacheMaxT )
		{
		cbfCleanThresholdStopT = cbfCacheMaxT;
		CallS( ErrBFSetStopFlushThreshold( cbfCleanThresholdStopT ) );
		}

	if ( cbfCleanThresholdStartT > cbfCleanThresholdStopT )
		{
		cbfCleanThresholdStartT = cbfCleanThresholdStopT;
		CallS( ErrBFSetStartFlushThreshold( cbfCleanThresholdStartT ) );
		}

	//  if the max cache size is still set at the default max cache size then
	//  set the max cache size to allow allocating as much physical memory as
	//  we can map into our address space

	if ( cbfCacheMaxT == lCacheSizeDefault )
		{
		cbfCacheMaxT = ULONG_PTR( QWORD( min( OSMemoryPageReserveTotal(), OSMemoryTotal() ) ) / g_cbPage );
		CallS( ErrBFSetCacheSizeMax( cbfCacheMaxT ) );
		cbfCleanThresholdStartT = ULONG_PTR( QWORD( cbfCleanThresholdStartT ) * cbfCacheMaxT / lCacheSizeDefault );
		CallS( ErrBFSetStartFlushThreshold( cbfCleanThresholdStartT ) );
		cbfCleanThresholdStopT = ULONG_PTR( QWORD( cbfCleanThresholdStopT ) * cbfCacheMaxT / lCacheSizeDefault );
		CallS( ErrBFSetStopFlushThreshold( cbfCleanThresholdStopT ) );
		}

	return JET_errSuccess;
	}

//  sets all BF system parameter defaults, if not yet set

void BFISetParameterDefaults()
	{
	//  the defaults have not been set yet

	critBFParm.Enter();
	if ( !fBFDefaultsSet )
		{
		//  the defaults are now being set

		fBFDefaultsSet = fTrue;
		critBFParm.Leave();

		//  set defaults for each and every BF system parameter

		CallS( ErrBFSetCacheSizeMin( lCacheSizeMinDefault ) );
		CallS( ErrBFSetCacheSizeMax( lCacheSizeDefault ) );
		CallS( ErrBFSetCheckpointDepthMax( lCheckpointDepthMaxDefault ) );
		CallS( ErrBFSetLRUKCorrInterval( lLRUKCorrIntervalDefault ) );
		CallS( ErrBFSetLRUKPolicy( lLRUKPolicyDefault ) );
		CallS( ErrBFSetLRUKTimeout( lLRUKTimeoutDefault ) );
		CallS( ErrBFSetStopFlushThreshold( lStopFlushThresholdDefault ) );
		CallS( ErrBFSetStartFlushThreshold( lStartFlushThresholdDefault ) );

		//  CONSIDER:  expose these settings

		dblBFSpeedSizeTradeoff	= 0.0;
		dblBFHashLoadFactor		= 5.0;
		dblBFHashUniformity		= 1.0;
		csecBFLRUKUncertainty	= 1.0;

		dlgposBFOB0Precision.lGeneration	= lgenCheckpointDepthMax;
		dlgposBFOB0Precision.isec			= 0;
		dlgposBFOB0Precision.ib				= 0;

		dlgposBFOB0Uncertainty.lGeneration	= 0;
		dlgposBFOB0Uncertainty.isec			= 128;
		dlgposBFOB0Uncertainty.ib			= 0;

		fEnableOpportuneWrite = fTrue;

		//  load configuration from the registry

		const int	cbBuf			= 256;
		_TCHAR		szBuf[ cbBuf ];

		if (	FOSConfigGet( _T( "Cache Manager" ), _T( "Enable Opportune Writes" ), szBuf, cbBuf ) &&
				szBuf[ 0 ] )
			{
			fEnableOpportuneWrite = !!_ttol( szBuf );
			}
		}
	else
		{
		critBFParm.Leave();
		}
	}

//  normalizes the flush thresholds after a parameter that could affect them changes

void BFINormalizeThresholds()
	{
	//  scale flush thresholds to cache size

	cbfScaledCleanThresholdStart = LONG_PTR( QWORD( cbfCleanThresholdStart ) * cbfCache / cbfCacheMax );
	cbfScaledCleanThresholdStop = LONG_PTR( QWORD( cbfCleanThresholdStop ) * cbfCache / cbfCacheMax );
	if ( cbfScaledCleanThresholdStart == cbfScaledCleanThresholdStop )
		{
		cbfScaledCleanThresholdStop += cbfCache / 100;
		}

	if ( cbfScaledCleanThresholdStop == cbfCacheMax )
		{
		cbfScaledCleanThresholdStop = cbfCacheMax - 1;
		}
	if ( cbfScaledCleanThresholdStop - cbfScaledCleanThresholdStart < 1 )
		{
		cbfScaledCleanThresholdStop = min( cbfCacheMax - 1, cbfScaledCleanThresholdStop + 1 );
		}
	if ( cbfScaledCleanThresholdStop - cbfScaledCleanThresholdStart < 1 )
		{
		cbfScaledCleanThresholdStart = max( 1, cbfScaledCleanThresholdStart - 1 );
		}
	}

	//  Page Manipulation

ERR ErrBFIAllocPage( PBF* const ppbf, const BOOL fWait, const BOOL fMRU )
	{
	ERR err = JET_errSuccess;

	//  try to allocate an available BF, waiting forever if we are not just
	//  allocating only if available

	BFAvail::ERR errAvail;
	errAvail = bfavail.ErrRemove( ppbf, fWait, fMRU );
	if ( errAvail == BFAvail::errOutOfObjects )
		{
		Call( ErrERRCheck( errBFINoBufferAvailable ) );
		}
	Assert( errAvail == BFAvail::errSuccess );

	//  we need to start cleaning

	if ( bfavail.Cobject() <= cbfScaledCleanThresholdStart )
		{
		//  start cleaning

		BFICleanThreadStartClean();
		}

	//  the BF we got from the pool is the dummy BF

	if ( *ppbf == &bfDummy )
		{
		//  the clean thread gave us a dummy BF to unblock us because it could
		//  not produce any more clean buffers.  as a result, we will fail this
		//  allocation with a fatal resource error after acknowledging that we
		//  have received that signal by releasing the X Latch on the dummy BF

		(*ppbf)->sxwl.ClaimOwnership( bfltExclusive );
		(*ppbf)->sxwl.ReleaseExclusiveLatch();

		if ( fWait )
			{
			Call( ErrERRCheck( JET_errOutOfBuffers ) );
			}
		else
			{
			Call( ErrERRCheck( errBFINoBufferAvailable ) );
			}
		}

	//  update DBA statistics

	(*ppbf)->fAvailable = fFalse;

	BFResidenceState bfrs;
	bfrs = (BFResidenceState)AtomicExchange( (long*)&(*ppbf)->bfrs, bfrsResident );
	if ( bfrs != bfrsResident )
		{
		//  if this is the first time we have used this page then remove it
		//  from the newly committed count and add it to the resident count

		if ( bfrs == bfrsNewlyCommitted )
			{
			AtomicDecrement( (long*)&cbfNewlyCommitted );
			}
		AtomicIncrement( (long*)&cBFResident );

		//  we will not try to do this if a buffer is smaller than a VM page or
		//  the page is not marked as not resident

		BOOL	fTryReclaim		= (	g_cbPage >= OSMemoryPageCommitGranularity() &&
									bfrs == bfrsNotResident );

		//  if we are going to try for a reclaim then reset the page before we
		//  touch it to avoid causing a hard page fault if the page data has
		//  been evicted by the OS

		if ( fTryReclaim )
			{
			OSMemoryPageReset( (*ppbf)->pv, g_cbPage );
			}

		//  force the buffer into our working set by touching its pages

		const size_t cbChunk = min( g_cbPage, OSMemoryPageCommitGranularity() );
		for ( size_t ib = 0; ib < g_cbPage; ib += cbChunk )
			{
			if (	AtomicExchangeAdd( &((long*)((BYTE*)(*ppbf)->pv + ib))[0], 0 ) ||
					AtomicExchangeAdd( &((long*)((BYTE*)(*ppbf)->pv + ib + cbChunk))[-1], 0 ) )
				{
				if ( bfrs == bfrsNotResident )
					{
					AtomicIncrement( (long*)&cpgReclaim );
					}
				}
			}
		}

	if ( (*ppbf)->fNewlyEvicted )
		{
		(*ppbf)->fNewlyEvicted = fFalse;
		cbfNewlyEvictedUsed++;
		}

	return JET_errSuccess;

HandleError:
	*ppbf = pbfNil;
	return err;
	}

void BFIFreePage( PBF pbf, const BOOL fMRU )
	{
	//  officially remove this IFMP / PGNO from this BF

	pbf->ifmp = ~( IFMP( 0 ) );
	pbf->pgno = pgnoNull;

	//  if this is the clean thread and this BF is above the set point then we
	//  should quiesce the BF rather than make it available

	if ( Ptls()->fCleanThread && IbfBFICachePbf( pbf ) >= cbfCacheSet )
		{
		//  mark this BF as quiesced

		pbf->fAvailable	= fFalse;
		pbf->fQuiesced	= fTrue;

		//  release the memory owned by this BF if possible

		if (	g_cbPage >= OSMemoryPageCommitGranularity() &&
				AtomicCompareExchange( (long*)&pbf->bfrs, bfrsResident, bfrsNotResident ) == bfrsResident )
			{
			OSMemoryPageReset( pbf->pv, g_cbPage, fTrue );
			AtomicDecrement( (long*)&cBFResident );
			}
		}

	//  we can free this BF

	else
		{
		//  mark this BF as available

		pbf->fQuiesced	= fFalse;
		pbf->fAvailable	= fTrue;

		//  free the available BF

		bfavail.Insert( pbf, fMRU );
		}
	}

ERR ErrBFICachePage(	PBF* const	ppbf,
						const IFMP	ifmp,
						const PGNO	pgno,
						const BOOL	fUseHistory,
						const BOOL	fWait,
						const BOOL	fMRU )
	{
	ERR				err;
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BFLRUK::ERR		errLRUK;

	//  allocate our BF FMP context, if not allocated

	FMP* pfmp = &rgfmp[ ifmp & ifmpMask ];
	if ( !pfmp->DwBFContext( !!( ifmp & ifmpSLV ) ) )
		{
		pfmp->RwlBFContext().EnterAsWriter();
		if ( !pfmp->DwBFContext( !!( ifmp & ifmpSLV ) ) )
			{
			BYTE* rgbBFFMPContext = (BYTE*)PvOSMemoryHeapAllocAlign( sizeof( BFFMPContext ), cbCacheLine );
			if ( !rgbBFFMPContext )
				{
				pfmp->RwlBFContext().LeaveAsWriter();
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			BFFMPContext* pbffmp = new( rgbBFFMPContext ) BFFMPContext();

			BFOB0::ERR errOB0 = pbffmp->bfob0.ErrInit(	dlgposBFOB0Precision.IbOffset(),
														dlgposBFOB0Uncertainty.IbOffset(),
														dblBFSpeedSizeTradeoff );
			if ( errOB0 != BFOB0::errSuccess )
				{
				Assert( errOB0 == BFOB0::errOutOfMemory );

				pbffmp->BFFMPContext::~BFFMPContext();
				OSMemoryHeapFreeAlign( pbffmp );

				pfmp->RwlBFContext().LeaveAsWriter();
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			pfmp->SetDwBFContext( !!( ifmp & ifmpSLV ), DWORD_PTR( pbffmp ) );
			}
		pfmp->RwlBFContext().LeaveAsWriter();
		}

	//  allocate a new BF to contain this IFMP / PGNO, waiting forever if
	//  necessary and requested

	Call( ErrBFIAllocPage( &pgnopbf.pbf, fWait, fMRU ) );

	//  set this BF to contain this IFMP / PGNO

	pgnopbf.pbf->ifmp = ifmp;
	pgnopbf.pbf->pgno = pgno;

	pgnopbf.pgno = pgno;

	//  insert this IFMP / PGNO in the LRUK

	errLRUK = bflruk.ErrCacheResource( IFMPPGNO( ifmp, pgno ), pgnopbf.pbf, fUseHistory );

	//  we failed to insert this IFMP / PGNO in the LRUK

	if ( errLRUK != BFLRUK::errSuccess )
		{
		Assert( errLRUK == BFLRUK::errOutOfMemory );

		//  release our allocated BF

		BFIFreePage( pgnopbf.pbf, fMRU );

		//  bail with out of memory

		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  insert this IFMP / PGNO in the hash table

	bfhash.WriteLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrInsertEntry( &lock, pgnopbf );
	bfhash.WriteUnlockKey( &lock );

	//  the insert succeeded

	if ( errHash == BFHash::errSuccess )
		{
		//  mark this BF as the current version of this IFMP / PGNO

		pgnopbf.pbf->fCurrentVersion = fTrue;

		//  return success

		*ppbf = pgnopbf.pbf;
		return JET_errSuccess;
		}

	//  the insert failed

	else
		{
		//  release our allocated BF
		//
		//  HACK:  if we can't evict the resource, wait until we can.  no one
		//  else will be able to evict it because we have the write latch so we
		//  can't get stuck here forever.  besides, this case is extremely rare

 		while ( bflruk.ErrEvictResource( IFMPPGNO( pgnopbf.pbf->ifmp, pgnopbf.pbf->pgno ), pgnopbf.pbf, fFalse ) != BFLRUK::errSuccess )
 			{
 			UtilSleep( cmsecWaitGeneric );
 			}

		BFIFreePage( pgnopbf.pbf, fMRU );

		//  the insert failed because the IFMP / PGNO is already cached

		if ( errHash == BFHash::errKeyDuplicate )
			{
			//  fail with page already cached

			Call( ErrERRCheck( errBFPageCached ) );
			}

		//  the insert failed because we are out of memory

		else
			{
			Assert( errHash == BFHash::errOutOfMemory );

			//  fail with out of memory

			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}

HandleError:
	*ppbf = pbfNil;
	return err;
	}

ERR ErrBFIVersionPage( PBF pbf, PBF* ppbfOld )
	{
	ERR			err		= JET_errSuccess;
	BFLRUK::ERR	errLRUK;

	//  allocate a new BF to contain the OLD version of the given BF

	Call( ErrBFIAllocPage( ppbfOld ) );

	//  set this BF to contain this IFMP / PGNO

	(*ppbfOld)->ifmp = pbf->ifmp;
	(*ppbfOld)->pgno = pbf->pgno;

	//  insert this IFMP / PGNO in the LRUK.  do not use history so that the
	//  old BF will be evicted ASAP

	errLRUK = bflruk.ErrCacheResource( IFMPPGNO( pbf->ifmp, pbf->pgno ), *ppbfOld, fFalse );

	//  we failed to insert this IFMP / PGNO in the LRUK

	if ( errLRUK != BFLRUK::errSuccess )
		{
		Assert( errLRUK == BFLRUK::errOutOfMemory );

		//  release our allocated BF

		BFIFreePage( *ppbfOld );

		//  bail with out of memory

		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	(*ppbfOld)->sxwl.ClaimOwnership( bfltWrite );

	//  save the current BF image

	UtilMemCpy( (*ppbfOld)->pv, pbf->pv, g_cbPage );

	//  copy the error state

	(*ppbfOld)->err = pbf->err;

	//  mark both BFs as dirty.  if the given BF is filthy, move the filthy state
	//  to the old BF

	BFIDirtyPage( pbf, bfdfDirty );
	BFIDirtyPage( *ppbfOld, BFDirtyFlags( pbf->bfdf ) );
	pbf->bfdf = bfdfDirty;

	//  move the lgpos information to the old BF because it is tied with the
	//  flush of the relevant data

	BFISetLgposOldestBegin0( *ppbfOld, pbf->lgposOldestBegin0 );
	BFIResetLgposOldestBegin0( pbf );

	BFISetLgposModify( *ppbfOld, pbf->lgposModify );
	BFIResetLgposModify( pbf );

	//  move the dependency tree from the given BF to the old BF, fixing up the
	//  dependency tree as necessary

	critBFDepend.Enter();

	Assert( FBFIAssertValidDependencyTree( pbf ) );
	Assert( FBFIAssertValidDependencyTree( *ppbfOld ) );

	(*ppbfOld)->pbfDependent		= pbf->pbfDependent;
	(*ppbfOld)->pbfDepChainHeadPrev	= pbf->pbfDepChainHeadPrev;
	(*ppbfOld)->pbfDepChainHeadNext	= pbf->pbfDepChainHeadNext;

	if ( pbf->FDependent() )
		{
		PBF pbfPrevMost = pbf;
		while ( pbfPrevMost->FDependent() )
			{
			pbfPrevMost = pbfPrevMost->pbfDepChainHeadNext;
			Assert( pbfPrevMost != pbfNil );
			}
		PBF pbfNextMost = pbf;
		while ( pbfNextMost->FDependent() )
			{
			pbfNextMost = pbfNextMost->pbfDepChainHeadPrev;
			Assert( pbfNextMost != pbfNil );
			}
		PBF pbfDepChainHead = pbfNil;
		do
			{
			pbfDepChainHead = pbfDepChainHead == pbfNil ? pbfPrevMost : pbfDepChainHead->pbfDepChainHeadNext;
			PBF pbfCurr = pbfDepChainHead;
			while ( pbfCurr != *ppbfOld && pbfCurr->pbfDependent != pbf )
				{
				pbfCurr = pbfCurr->pbfDependent;
				}
			if ( pbfCurr != *ppbfOld )
				{
				pbfCurr->pbfDependent = *ppbfOld;
				}
			}
		while ( pbfDepChainHead != pbfNextMost );
		}
	else
		{
		if ( pbf->pbfDepChainHeadPrev == pbf )
			{
			Assert( pbf->pbfDepChainHeadNext == pbf );
			(*ppbfOld)->pbfDepChainHeadPrev = *ppbfOld;
			(*ppbfOld)->pbfDepChainHeadNext = *ppbfOld;
			}
		else
			{
			Assert( pbf->pbfDepChainHeadNext != pbf );
			PBF pbfNext = pbf->pbfDepChainHeadNext;
			PBF pbfPrev = pbf->pbfDepChainHeadPrev;
			Assert( pbfNext->pbfDepChainHeadPrev == pbf );
			Assert( pbfPrev->pbfDepChainHeadNext == pbf );
			pbfNext->pbfDepChainHeadPrev = *ppbfOld;
			pbfPrev->pbfDepChainHeadNext = *ppbfOld;
			}
		}
	if ( pbf->pbfDependent != pbfNil )
		{
		PBF pbfD = pbf->pbfDependent;
		if ( pbfD->pbfDepChainHeadPrev == pbf )
			{
			pbfD->pbfDepChainHeadPrev = *ppbfOld;
			}
		if ( pbfD->pbfDepChainHeadNext == pbf )
			{
			pbfD->pbfDepChainHeadNext = *ppbfOld;
			}
		}

	pbf->pbfDependent			= pbfNil;
	pbf->pbfDepChainHeadPrev	= pbf;
	pbf->pbfDepChainHeadNext	= pbf;

	Assert( FBFIAssertValidDependencyTree( pbf ) );
	Assert( FBFIAssertValidDependencyTree( *ppbfOld ) );

	//  add ourself as a time dependency to the given BF

	(*ppbfOld)->pbfTimeDepChainNext	= pbf->pbfTimeDepChainNext;
	(*ppbfOld)->pbfTimeDepChainPrev	= pbf;
	pbf->pbfTimeDepChainNext		= *ppbfOld;
	if ( (*ppbfOld)->pbfTimeDepChainNext != pbfNil )
		{
		(*ppbfOld)->pbfTimeDepChainNext->pbfTimeDepChainPrev = *ppbfOld;
		}

	(*ppbfOld)->fOlderVersion = fTrue;

	critBFDepend.Leave();

	//  move our undo info to the old BF because its removal is tied with the
	//  flush of the relevant data
	//
	//  NOTE:  this must be done after linking in the versioned page so that it
	//  is always possible to reach an RCE containing undo info from the hash
	//  table

	if ( pbf->prceUndoInfoNext != prceNil )
		{
		CCriticalSection* const pcrit		= &critpoolBFDUI.Crit( pbf );
		CCriticalSection* const pcritOld	= &critpoolBFDUI.Crit( *ppbfOld );

		CCriticalSection* const pcritMax	= max( pcrit, pcritOld );
		CCriticalSection* const pcritMin	= min( pcrit, pcritOld );

		ENTERCRITICALSECTION ecsMax( pcritMax );
		ENTERCRITICALSECTION ecsMin( pcritMin, pcritMin != pcritMax );

		(*ppbfOld)->prceUndoInfoNext	= pbf->prceUndoInfoNext;
		pbf->prceUndoInfoNext			= prceNil;
		}

	//  keep versioned page stats

	cBFPagesVersioned.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
	AtomicIncrement( (long*)&cBFVersioned );

	//  update our page write stats
	//
	//  NOTE:  page versioning is a "virtual" flush

	if ( !pbf->fFlushed )
		{
		pbf->fFlushed = fTrue;
		}

	return JET_errSuccess;

HandleError:
	*ppbfOld = pbfNil;
	return err;
	}

ERR ErrBFIPrereadPage( IFMP ifmp, PGNO pgno )
	{
	ERR				err		= errBFPageCached;
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );
	bfhash.ReadUnlockKey( &lock );

	//  the IFMP / PGNO was not present in the hash table

	if ( errHash != BFHash::errSuccess )
		{
		//  try to add this page to the cache

		PBF pbf;
		err = ErrBFICachePage( &pbf, ifmp, pgno, fTrue, fFalse, fFalse );

		//  the page was added to the cache

		if ( err == JET_errSuccess )
			{
			//  schedule the read of the page image from disk.  further preread
			//  manipulation of the BF will be done in BFIAsyncReadComplete()

			BFIAsyncRead( pbf );

			cBFUncachedPagesPreread.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
			}
		}

	cBFPagesPreread.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
	return err;
	}

INLINE ERR ErrBFIValidatePage( const PBF pbf, const BFLatchType bflt )
	{
	//  we should only see bfltShared, bfltExclusive, and bfltWrite

	Assert( bflt == bfltShared || bflt == bfltExclusive || bflt == bfltWrite );

	//  if this page is not in an error state then return its current error code

	ERR errBF;
	if ( ( errBF = pbf->err ) >= JET_errSuccess )
		{
		return errBF;
		}

	//  perform slow validation on this page

	return ErrBFIValidatePageSlowly( pbf, bflt );
	}

INLINE BOOL FBFIDatabasePage( const PBF pbf )
	{
	//	determines if the page contains
	//	unstructured data

	//	UNDONE: only sort pages actually need to be
	//	excluded, but we currently can't differentiate
	//	between sort pages and temp. table pages, so
	//	we need to exclude the temp. database
	//	altogether

	return ( !( pbf->ifmp & ifmpSLV )
			&& dbidTemp != rgfmp[ pbf->ifmp ].Dbid() );
	}

ERR ErrBFIValidatePageSlowly( PBF pbf, const BFLatchType bflt )
	{
	ERR err;

	//  disable ownership tracking because we abuse the exclusive latch below

	CLockDeadlockDetectionInfo::DisableOwnershipTracking();

	//  if this page has already been verified then get the result from the page

	ERR errBF;
	if ( ( errBF = pbf->err ) != errBFIPageNotVerified )
		{
		err = (	pbf->bfdf == bfdfClean || errBF >= JET_errSuccess ?
					errBF :
					JET_errSuccess );
		}

	//  we already have or can acquire the exclusive latch

	else if (	bflt != bfltShared ||
				pbf->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
		{
		//  if the page has still not been verified then verify the page and
		//  save the result

		if ( pbf->err == errBFIPageNotVerified )
			{
			//  perform page verification

			ERR errT = ErrBFIVerifyPage( pbf );
			if ( errT < JET_errSuccess )
				{
				(void)ErrERRCheck( errT );
				}
			pbf->err = SHORT( errT );
			Assert( pbf->err == errT );

			//  if there was no error while verifying the page and we can rule
			//  out the existence of any active versions by its dbtime then go
			//  ahead and reset all versioned state on the page
			//
			//	must exclude pages with unstructured data
			//
			//  NOTE:  these updates are being done as if under a WAR Latch

			if ( errT >= JET_errSuccess
				&& FBFIDatabasePage( pbf ) )
				{
				CPAGE	cpage;
				cpage.LoadPage( pbf->pv );

				if ( cpage.Dbtime() < rgfmp[ pbf->ifmp ].DbtimeOldestGuaranteed() )
					{
					NDResetVersionInfo( &cpage );
					}

				cpage.UnloadPage();
				}

			//  if there was an error while verifying the page and we are not
			//  in repair and we are not in the redo phase of recovery then log
			//  the error

			if (	errT < JET_errSuccess &&
					!fGlobalRepair &&
					(	PinstFromIfmp( pbf->ifmp & ifmpMask )->m_plog->m_fLogDisabled ||
						PinstFromIfmp( pbf->ifmp & ifmpMask )->m_plog->m_fRecoveringMode != fRecoveringRedo ) )
				{
				IFileAPI*		pfapi		= (	( pbf->ifmp & ifmpSLV ) ?
													rgfmp[ pbf->ifmp & ifmpMask ].PfapiSLV() :
													rgfmp[ pbf->ifmp ].Pfapi() );
				const _TCHAR*	rgpsz[ 6 ];
				DWORD			irgpsz		= 0;
				_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
				_TCHAR			szOffset[ 64 ];
				_TCHAR			szLength[ 64 ];
				_TCHAR			szError[ 64 ];

				CallS( pfapi->ErrPath( szAbsPath ) );
				_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), OffsetOfPgno( pbf->pgno ), OffsetOfPgno( pbf->pgno ) );
				_stprintf( szLength, _T( "%u (0x%08x)" ), g_cbPage, g_cbPage );
				_stprintf( szError, _T( "%i (0x%08x)" ), errT, errT );

				rgpsz[ irgpsz++ ]	= szAbsPath;
				rgpsz[ irgpsz++ ]	= szOffset;
				rgpsz[ irgpsz++ ]	= szLength;
				rgpsz[ irgpsz++ ]	= szError;

				if ( errT == JET_errReadVerifyFailure )
					{
					CPAGE cpage;
					cpage.LoadPage( pbf->pv );

					const ULONG	ulChecksumExpected	= *( (LittleEndian<DWORD>*) ( pbf->pv ) );
					const ULONG	ulChecksumActual	= UlUtilChecksum( (const BYTE*) pbf->pv, g_cbPage );
					const PGNO	pgnoExpected		= pbf->pgno;
					const PGNO	pgnoActual			= cpage.Pgno();

					cpage.UnloadPage();

					if ( ulChecksumExpected != ulChecksumActual )
						{
						_TCHAR	szChecksumExpected[ 64 ];
						_TCHAR	szChecksumActual[ 64 ];

						_stprintf( szChecksumExpected, _T( "%u (0x%08x)" ), ulChecksumExpected, ulChecksumExpected );
						_stprintf( szChecksumActual, _T( "%u (0x%08x)" ), ulChecksumActual, ulChecksumActual );

						rgpsz[ irgpsz++ ]	= szChecksumExpected;
						rgpsz[ irgpsz++ ]	= szChecksumActual;

						UtilReportEvent(	eventError,
											BUFFER_MANAGER_CATEGORY,
											DATABASE_PAGE_CHECKSUM_MISMATCH_ID,
											irgpsz,
											rgpsz,
											0,
											NULL,
											PinstFromIfmp( pbf->ifmp & ifmpMask ) );
						}
					else if ( pgnoExpected != pgnoActual )
						{
						_TCHAR	szPgnoExpected[ 64 ];
						_TCHAR	szPgnoActual[ 64 ];

						_stprintf( szPgnoExpected, _T( "%u (0x%08x)" ), pgnoExpected, pgnoExpected );
						_stprintf( szPgnoActual, _T( "%u (0x%08x)" ), pgnoActual, pgnoActual );

						rgpsz[ irgpsz++ ]	= szPgnoExpected;
						rgpsz[ irgpsz++ ]	= szPgnoActual;

						UtilReportEvent(	eventError,
											BUFFER_MANAGER_CATEGORY,
											DATABASE_PAGE_NUMBER_MISMATCH_ID,
											irgpsz,
											rgpsz,
											0,
											NULL,
											PinstFromIfmp( pbf->ifmp & ifmpMask ) );
						}
					}
				else if ( errT == JET_errPageNotInitialized )
					{
					UtilReportEvent(	eventError,
										BUFFER_MANAGER_CATEGORY,
										DATABASE_PAGE_DATA_MISSING_ID,
										irgpsz,
										rgpsz,
										0,
										NULL,
										PinstFromIfmp( pbf->ifmp & ifmpMask ) );
					}
				}
			}

		//  get the error for this page

		err = (	pbf->bfdf == bfdfClean || pbf->err >= JET_errSuccess ?
					pbf->err :
					JET_errSuccess );

		//  release the exclusive latch if acquired

		if ( bflt == bfltShared )
			{
			pbf->sxwl.ReleaseExclusiveLatch();
			}
		}

	//  we do not have exclusive access to the page

	else
		{
		//  verify the page without saving the results.  we do this so that
		//  we can validate the page without blocking if someone else is
		//  currently verifying the page

		err = ErrBFIVerifyPage( pbf );

		//  if there is an error in the page then check the status of the page
		//  again.  there are two possibilities:  the page is really bad or the
		//  page was modified by someone with a WAR Latch
		//
		//  if the page is really bad then it will either be flagged as not
		//  verified or it will be clean and flagged with the verification
		//  error.  if it is still not verified then we should use our own
		//  result.  if it has been verified then we will use the actual result
		//
		//  if the page was modified by someone with a WAR Latch then we know
		//  that it was verified at one time so we should just go ahead and
		//  use the result of that validation

		if ( err < JET_errSuccess )
			{
			if ( ( errBF = pbf->err ) != errBFIPageNotVerified )
				{
				err = (	pbf->bfdf == bfdfClean || errBF >= JET_errSuccess ?
							errBF :
							JET_errSuccess );
				}
			}
		}

	//  return the result

	CLockDeadlockDetectionInfo::EnableOwnershipTracking();
	return err;
	}

ERR ErrBFIVerifyPage( PBF pbf )
	{
	//  the page contains unstructured data

	if ( !FBFIDatabasePage( pbf ) )
		{
		//  the page is verified

		return JET_errSuccess;
		}

	//  compute this page's checksum and pgno

	CPAGE cpage;
	cpage.LoadPage( pbf->pv );

	const ULONG	ulChecksumExpected	= *( (LittleEndian<DWORD>*) ( pbf->pv ) );
	const ULONG	ulChecksumActual	= UlUtilChecksum( (const BYTE*) pbf->pv, g_cbPage );
	const PGNO	pgnoExpected		= pbf->pgno;
	const PGNO	pgnoActual			= cpage.Pgno();

	cpage.UnloadPage();

	//  the pgno of the page is pgnoNull

	if ( pgnoActual == pgnoNull )
		{
		//  the page is uninitialized

		//  do not ErrERRCheck() here so that we can trap on it correctly above
		return JET_errPageNotInitialized;
		}

	//  the checksum matches and the pgno matches

	if ( ulChecksumActual == ulChecksumExpected && pgnoActual == pgnoExpected )
		{
		//  the page is verified

		return JET_errSuccess;
		}

	//  the checksum doesn't match

	else
		{
		//  the page has a verification failure

		//	do not ErrERRCheck() here so that we can trap on it correctly above
		return JET_errReadVerifyFailure;
		}
	}

ERR ErrBFILatchPage(	BFLatch* const		pbfl,
						const IFMP			ifmp,
						const PGNO			pgno,
						const BFLatchFlags	bflf,
						const BFLatchType	bflt )
	{
	ERR				err			= JET_errSuccess;
	BFLatchFlags	bflfT		= bflf;
	BOOL			fCacheMiss	= fFalse;
	IFMPPGNO		ifmppgno	= IFMPPGNO( ifmp, pgno );
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	CSXWLatch::ERR	errSXWL;

	//  try forever until we read latch the page or fail with an error

	forever
		{
		//  look up this IFMP / PGNO in the hash table

		bfhash.ReadLockKey( ifmppgno, &lock );
		errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

		//  we found the IFMP / PGNO and we are latching uncached pages or the
		//  found BF is not currently undergoing I/O

		if (	errHash == BFHash::errSuccess &&
				( !( bflfT & bflfNoUncached ) || pgnopbf.pbf->err != errBFIPageFaultPending ) )
			{
			//  if we are not latching cached pages, bail

			if ( bflfT & bflfNoCached )
				{
				bfhash.ReadUnlockKey( &lock );
				return ErrERRCheck( errBFPageCached );
				}

			//  this is a cache miss if the found BF is currently undergoing I/O

			fCacheMiss = fCacheMiss || pgnopbf.pbf->err == errBFIPageFaultPending;

			//  latch the page

			switch ( bflt )
				{
				case bfltShared:
					if ( bflfT & bflfNoWait )
						{
						errSXWL = pgnopbf.pbf->sxwl.ErrTryAcquireSharedLatch();
						}
					else
						{
						errSXWL = pgnopbf.pbf->sxwl.ErrAcquireSharedLatch();
						}
					break;

				case bfltExclusive:
					if ( bflfT & bflfNoWait )
						{
						errSXWL = pgnopbf.pbf->sxwl.ErrTryAcquireExclusiveLatch();
						}
					else
						{
						errSXWL = pgnopbf.pbf->sxwl.ErrAcquireExclusiveLatch();
						}
					break;

				case bfltWrite:
					if ( bflfT & bflfNoWait )
						{
						errSXWL = pgnopbf.pbf->sxwl.ErrTryAcquireWriteLatch();
						if (errSXWL == CSXWLatch::errSuccess )
							{
							if ( pgnopbf.pbf->bfls == bflsHashed )
								{
								for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
									{
									CSXWLatch* const psxwlProc = &Ppls( iProc )->rgBFHashedLatch[ pgnopbf.pbf->iHashedLatch ].sxwl;
									errSXWL = psxwlProc->ErrTryAcquireWriteLatch();
									if ( errSXWL != CSXWLatch::errSuccess )
										{
										break;
										}
									}
								if ( errSXWL != CSXWLatch::errSuccess )
									{
									for ( size_t iProc2 = 0; iProc2 < iProc; iProc2++ )
										{
										CSXWLatch* const psxwlProc = &Ppls( iProc2 )->rgBFHashedLatch[ pgnopbf.pbf->iHashedLatch ].sxwl;
										psxwlProc->ReleaseWriteLatch();
										}
									pgnopbf.pbf->sxwl.ReleaseWriteLatch();
									}
								}
							}
						}
					else
						{
						errSXWL = pgnopbf.pbf->sxwl.ErrAcquireExclusiveLatch();
						}
					break;

				}

			//  release our lock on the hash table

			bfhash.ReadUnlockKey( &lock );

			//  if this was a latch conflict, bail

			if ( errSXWL == CSXWLatch::errLatchConflict )
				{
				cBFLatchConflict.Inc( perfinstGlobal );
				return ErrERRCheck( errBFLatchConflict );
				}

			//  wait for ownership of the latch if required

			else if ( errSXWL == CSXWLatch::errWaitForSharedLatch )
				{
				cBFLatchStall.Inc( perfinstGlobal );
				pgnopbf.pbf->sxwl.WaitForSharedLatch();
				}

			else if ( errSXWL == CSXWLatch::errWaitForExclusiveLatch )
				{
				cBFLatchStall.Inc( perfinstGlobal );
				pgnopbf.pbf->sxwl.WaitForExclusiveLatch();
				}

			if ( bflt == bfltWrite && !( bflfT & bflfNoWait ) )
				{
				if ( pgnopbf.pbf->sxwl.ErrUpgradeExclusiveLatchToWriteLatch() == CSXWLatch::errWaitForWriteLatch )
					{
					cBFLatchStall.Inc( perfinstGlobal );
					pgnopbf.pbf->sxwl.WaitForWriteLatch();
					}
				if ( pgnopbf.pbf->bfls == bflsHashed )
					{
					for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
						{
						CSXWLatch* const psxwlProc = &Ppls( iProc )->rgBFHashedLatch[ pgnopbf.pbf->iHashedLatch ].sxwl;
						if ( psxwlProc->ErrAcquireExclusiveLatch() == CSXWLatch::errWaitForExclusiveLatch )
							{
							cBFLatchStall.Inc( perfinstGlobal );
							psxwlProc->WaitForExclusiveLatch();
							}
						if ( psxwlProc->ErrUpgradeExclusiveLatchToWriteLatch() == CSXWLatch::errWaitForWriteLatch )
							{
							cBFLatchStall.Inc( perfinstGlobal );
							psxwlProc->WaitForWriteLatch();
							}
						}
					}
				}

			//  update DBA statistics and redirect not resident page faults to
			//  the database whenever possible

			BFResidenceState bfrs;
			bfrs = (BFResidenceState)AtomicExchange( (long*)&pgnopbf.pbf->bfrs, bfrsResident );
			if ( bfrs != bfrsResident )
				{
				//  add this page to the resident count

				AtomicIncrement( (long*)&cBFResident );

				//  we will not try to do this if a buffer is smaller than a VM
				//  page or the page is dirty and we are not trying to new page

				BOOL	fTryReclaim		= (	g_cbPage >= OSMemoryPageCommitGranularity() &&
											( pgnopbf.pbf->bfdf < bfdfDirty || ( bflfT & bflfNew ) ) );
				BOOL	fFailedReclaim	= fFalse;

				//  if we are going to try for a reclaim then we must have the
				//  write latch because we can cause the data on the page to be
				//  temporarily inconsistent

				if ( !fTryReclaim )
					{
					fTryReclaim = fFalse;
					}
				else if ( bflt == bfltWrite )  //  if ( fTryReclaim && bflt == bfltWrite )
					{
					fTryReclaim = fTrue;
					}
				else if ( bflfT & bflfNoWait )  //  if ( fTryReclaim && bflt != bfltWrite && ( bflfT & bflfNoWait ) )
					{
					fTryReclaim = fFalse;
					}
				else if ( bflt == bfltShared )  //  if ( fTryReclaim && !( bflfT & bflfNoWait ) && bflt == bfltShared )
					{
					//  HACK:  we cannot wait for the write latch because there
					//  is code that acquires multiple share latches on the
					//  same thread.  in that case, an attempt to resolve a
					//  page not resident condition on a subsequent share latch
					//  will cause a deadlock
					errSXWL = pgnopbf.pbf->sxwl.ErrTryUpgradeSharedLatchToWriteLatch();
					if ( errSXWL == CSXWLatch::errLatchConflict )
						{
						fTryReclaim = fFalse;
						}
					//  this code is ugly enough without supporting hashed latches
 					if ( errSXWL != CSXWLatch::errLatchConflict && pgnopbf.pbf->bfls == bflsHashed )
						{
						pgnopbf.pbf->sxwl.DowngradeWriteLatchToSharedLatch();
						fTryReclaim = fFalse;
						}
					}
				else  //  if ( fTryReclaim && !( bflfT & bflfNoWait ) && bflt == bfltExclusive )
					{
					errSXWL = pgnopbf.pbf->sxwl.ErrUpgradeExclusiveLatchToWriteLatch();
					if ( errSXWL == CSXWLatch::errWaitForWriteLatch )
						{
						cBFLatchStall.Inc( perfinstGlobal );
						pgnopbf.pbf->sxwl.WaitForWriteLatch();
						}
					//  this code is ugly enough without supporting hashed latches
					if ( pgnopbf.pbf->bfls == bflsHashed )
						{
						pgnopbf.pbf->sxwl.DowngradeWriteLatchToExclusiveLatch();
						fTryReclaim = fFalse;
						}
					}

				//  if we are going to try for a reclaim then reset the page
				//  before we touch it to avoid causing a hard page fault if
				//  the page data has been evicted by the OS

				if ( fTryReclaim )
					{
					OSMemoryPageReset( pgnopbf.pbf->pv, g_cbPage );
					}

				//  force the buffer into our working set by touching its pages.
				//  if we are trying to reclaim the page then we will look at
				//  the start/end of each page.  if any page is seen with zero
				//  data then we will presume that we could not reclaim that
				//  page and that the buffer may now contain invalid page data

				const size_t cbChunk = min( g_cbPage, OSMemoryPageCommitGranularity() );
				for ( size_t ib = 0; ib < g_cbPage; ib += cbChunk )
					{
					if (	AtomicExchangeAdd( &((long*)((BYTE*)pgnopbf.pbf->pv + ib))[0], 0 ) ||
							AtomicExchangeAdd( &((long*)((BYTE*)pgnopbf.pbf->pv + ib + cbChunk))[-1], 0 ) )
						{
						if ( bfrs == bfrsNotResident )
							{
							AtomicIncrement( (long*)&cpgReclaim );
							}
						}
					else
						{
						fFailedReclaim = fFailedReclaim || fTryReclaim;
						}
					}

				//  if we think that we failed to reclaim the data for this
				//  buffer and we need it (i.e. bflfNew was not specified)
				//  then we will checksum each VM page of the buffer looking
				//  for even a single set bit.  if the checksum indicates that
				//  the page is all zeroes then we will presume (now with good
				//  certainty) that we lost the data in this buffer and we will
				//  go ahead and reread it from the database

				if ( fFailedReclaim && !( bflfT & bflfNew ) )
					{
					fFailedReclaim = fFalse;
					for ( ib = 0; ib < g_cbPage; ib += cbChunk )
						{
						const BYTE* pb = (BYTE*)pgnopbf.pbf->pv + ib;

						if ( UlUtilChecksum( pb, cbChunk ) == 0x89abcdef )
							{
							fFailedReclaim = fTrue;
							break;
							}
						}
					if ( fFailedReclaim )
						{
						BFISyncRead( pgnopbf.pbf );
						cBFPagesRepeatedlyRead.Inc( PinstFromIfmp( pgnopbf.pbf->ifmp & ifmpMask ) );
						(void)ErrBFIValidatePage( pgnopbf.pbf, bfltWrite );
						}
					}

				//  if we upgraded to a write latch to try and reclaim then go
				//  back down to the proper latch level

				if ( !fTryReclaim )
					{
					}
				else if ( bflt == bfltWrite )  //  if ( fTryReclaim && bflt == bfltWrite )
					{
					}
				else if ( bflt == bfltShared )  //  if ( fTryReclaim && bflt == bfltShared )
					{
					pgnopbf.pbf->sxwl.DowngradeWriteLatchToSharedLatch();
					}
				else  //  if ( fTryReclaim && bflt == bfltExclusive )
					{
					pgnopbf.pbf->sxwl.DowngradeWriteLatchToExclusiveLatch();
					}
				}

			//  we are latching a new page

			if ( bflfT & bflfNew )
				{
				//  clear the error state of this BF

				pgnopbf.pbf->err = JET_errSuccess;

				//  the page is valid

				err = JET_errSuccess;
				}

			//  we are not latching a new page

			else
				{
				//  if this page was preread and we are touching it for the first
				//  time after the preread, do not touch it again even if asked

				if ( pgnopbf.pbf->err == errBFIPageNotVerified )
					{
					bflfT = BFLatchFlags( bflfT | bflfNoTouch );
					}

				//  validate the page

				err = ErrBFIValidatePage( pgnopbf.pbf, bflt );

				//  the page is in an error state and we should fail on an error

				if ( err < JET_errSuccess && !( bflfT & bflfNoFail ) )
					{
					//  release our latch and return the error

					switch ( bflt )
						{
						case bfltShared:
							pgnopbf.pbf->sxwl.ReleaseSharedLatch();
							break;

						case bfltExclusive:
							pgnopbf.pbf->sxwl.ReleaseExclusiveLatch();
							break;

						case bfltWrite:
							if ( pgnopbf.pbf->bfls == bflsHashed )
								{
								for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
									{
									CSXWLatch* const psxwlProc = &Ppls( iProc )->rgBFHashedLatch[ pgnopbf.pbf->iHashedLatch ].sxwl;
									psxwlProc->ReleaseWriteLatch();
									}
								}
							pgnopbf.pbf->sxwl.ReleaseWriteLatch();
							break;
						}

					return err;
					}
				}

			//  the user requested that we touch this page

			if ( !( bflfT & bflfNoTouch ) )
				{
				//  touch the page

				bflruk.TouchResource( pgnopbf.pbf );
				}

			//  return the page

			break;
			}

		//  we did not find the IFMP / PGNO or we are not latching uncached pages
		//  and the found BF is currently undergoing I/O

		else
			{
			//  release our lock on the hash table

			bfhash.ReadUnlockKey( &lock );

			//  if we are not latching uncached pages, bail

			if ( bflfT & bflfNoUncached )
				{
				return ErrERRCheck( errBFPageNotCached );
				}

			//  this is now officially a cache miss

			fCacheMiss = fTrue;

			//  try to add this page to the cache

			err = ErrBFICachePage( &pgnopbf.pbf, ifmp, pgno, !( bflfT & bflfNew ), fTrue, (bflfT & bflfNew) );

			//  the page was added to the cache

			if ( err == JET_errSuccess )
				{
				//  transfer ownership of the latch to the current context.  we
				//  must do this to properly set up deadlock detection for this
				//  latch

				pgnopbf.pbf->sxwl.ClaimOwnership( bfltWrite );

				//  we are not latching a new page

				if ( !( bflfT & bflfNew ) )
					{
					//  read the page image from disk

					BFISyncRead( pgnopbf.pbf );

					//  validate the page

					err = ErrBFIValidatePage( pgnopbf.pbf, bfltWrite );

					//  the page is in an error state and we should fail on an error

					if ( err < JET_errSuccess && !( bflfT & bflfNoFail ) )
						{
						//  release our latch and return the error

						pgnopbf.pbf->sxwl.ReleaseWriteLatch();
						return err;
						}
					}

				//  make this BF eligible for nomination

				Assert( pgnopbf.pbf->bfls != bflsHashed );
				pgnopbf.pbf->tickEligibleForNomination = TickOSTimeCurrent();

				//  downgrade our write latch to the requested latch

				switch ( bflt )
					{
					case bfltShared:
						pgnopbf.pbf->sxwl.DowngradeWriteLatchToSharedLatch();
						break;

					case bfltExclusive:
						pgnopbf.pbf->sxwl.DowngradeWriteLatchToExclusiveLatch();
						break;

					case bfltWrite:
						break;
					}

				//  return the page

				break;
				}

			//  the page was already in the cache

			else if ( err == errBFPageCached )
				{
				//  try to latch the page again

				continue;
				}

			//  the page could not be added to the cache

			else
				{
				Assert(	err == JET_errOutOfMemory ||
						err == JET_errOutOfBuffers );

				//  fail with out of memory

				return err;
				}
			}
		}

	//  return the page

	if ( fCacheMiss )
		{
		cBFCacheMiss.Inc( perfinstGlobal );
		}
	cBFSlowLatch.Inc( perfinstGlobal );
	if ( bflf & bflfHint )
		{
		cBFBadLatchHint.Inc( perfinstGlobal );
		err = err < JET_errSuccess ? err : ErrERRCheck( wrnBFBadLatchHint );
		}
	cBFCacheReq.Inc( perfinstGlobal );

	pbfl->pv		= pgnopbf.pbf->pv;
	pbfl->dwContext	= DWORD_PTR( pgnopbf.pbf );

	return	(	err != JET_errSuccess ?
					err :
					(	fCacheMiss ?
							ErrERRCheck( wrnBFPageFault ) :
							JET_errSuccess ) );
	}


#ifdef ELIMINATE_PAGE_PATCHING

INLINE BOOL FBFIPatchWouldBeRequired( PBF pbf )
	{
	FMP * const		pfmp			= rgfmp + pbf->ifmp;
	BOOL			fPatchRequired	= fFalse;

	//	"Patching" is required during backup only under very
	//	specific circumstances:
	//		1)	This page is the "flush first" page of a
	//			dependency.
	//		2)	This page has either already been copied to the
	//			backup set or will not be copied to the backup
	//			set (because it's beyond the pre-established
	//			backup end-point.
	//		3)	At least one of the "flush second" pages of the
	//			existing dependencies on this page has not yet
	//			been copied to the backup set, but will.
	//	In all other circumstances, patching is not required
	//	because we can reconstruct the "flush second" page
	//	from either the log files in the backup set or from
	//	the "flush first" page in the backup set.


	Assert( pfmp->CritLatch().FOwner() );
	Assert( pfmp->PgnoMost() > 0 );

	if ( !FBFIPageWillBeCopiedToBackup( pfmp, pbf->pgno ) )
		{
		critBFDepend.Enter();
		for ( PBF pbfDependentT = pbf->pbfDependent;
			NULL != pbfDependentT;
			pbfDependentT = pbfDependentT->pbfDependent )
			{
			if ( FBFIPageWillBeCopiedToBackup( pfmp, pbfDependentT->pgno ) )
				{
				fPatchRequired = fTrue;
				break;
				}
			}
		critBFDepend.Leave();
		}

	return fPatchRequired;
	}

#endif	//	ELIMINATE_PAGE_PATCHING


ERR ErrBFIPrepareFlushPage( PBF pbf, const BOOL fRemoveDependencies )
	{
	ERR err = JET_errSuccess;

	//  check the error state of this BF.  if the BF is already in an error
	//  state, fail immediately
	//
	//  NOTE:  this check makes I/O errors "permanent" such that if we ever fail
	//  when trying to flush a BF then we will never try again.  we may want to
	//  change this behavior in the future.  if so then we need to remove this
	//  check and make sure that anyone who removes this error code has the W
	//  Latch to avoid interactions with ErrBFIValidatePage

	Call( pbf->err );

	//  if this BF had a flush order dependency on another BF and that BF was
	//  purged then it is unflushable

	if ( pbf->fDependentPurged )
		{
		Call( ErrERRCheck( errBFIDependentPurged ) );
		}

	//  remove all flush order dependencies from this BF

	while ( pbf->pbfTimeDepChainNext != pbfNil || pbf->FDependent() )
		{
		//  find a leaf of our branch in the dependency tree

		critBFDepend.Enter();

		PBF pbfT = pbf;
		while ( pbfT->pbfTimeDepChainNext != pbfNil || pbfT->FDependent() )
			{
			while ( pbfT->pbfTimeDepChainNext != pbfNil )
				{
				pbfT = pbfT->pbfTimeDepChainNext;
				Assert( pbfT->ifmp == pbf->ifmp );	//	no cross-database dependencies allowed
				}

			while ( pbfT->FDependent() )
				{
				pbfT = pbfT->pbfDepChainHeadNext;
				Assert( pbfT->ifmp == pbf->ifmp );	//	no cross-database dependencies allowed
				}
			}

		critBFDepend.Leave();

		//  possibly async flush this BF
		//
		//  NOTE:  it is possible that someone else already flushed this
		//  page.  this is because the BF will be in the dependency tree
		//  until after the write completes.  if this happens, we will
		//  get JET_errSuccess and retry the entire operation
		//
		//  NOTE:  this call will result in at least one level of recursion.
		//  usually, we will only recurse once because we are trying to flush
		//  dependency chain heads.  it is possible that another thread could
		//  write latch the page, add a dependency, and release the write
		//  latch between the time we leave the critical section protecting
		//  the dependency tree and try to get the exclusive latch on the
		//  page.  this would cause us to recurse another level.  because we
		//  can recurse far faster than any other thread should be able to
		//  do the above, the probability of deep recursion should be remote.
		//  if we do happen to catch someone doing this, we will stop
		//  recursing with errBFLatchConflict because we will not be able
		//  to exclusively latch the page to flush it
		//
		//  NOTE:  we must disable ownership tracking because it is possible
		//  that we will try to latch a page that we already have latched
		//  while trying to flush the dependency chain.  yes, this is tragic.
		//  the only reason it works is because we try-acquire the exclusive
		//  latch instead of acquiring it and this will work even if we
		//  already have the shared latch

		if (	!fRemoveDependencies &&
				( pbf->pgno != pbfT->pgno || pbf->ifmp != pbfT->ifmp ) )
			{
			Call( ErrERRCheck( errBFIRemainingDependencies ) );
			}

		CLockDeadlockDetectionInfo::DisableOwnershipTracking();
		err = ErrBFIFlushPage( pbfT, bfdfDirty, !fRemoveDependencies );
		CLockDeadlockDetectionInfo::EnableOwnershipTracking();
		Call( err );
		}

	//  log and remove all undo info from the BF

	if ( pbf->prceUndoInfoNext != prceNil )
		{
		if ( !fRemoveDependencies )
			{
			Call( ErrERRCheck( errBFIRemainingDependencies ) );
			}

		ENTERCRITICALSECTION ecs( &critpoolBFDUI.Crit( pbf ) );

		while ( pbf->prceUndoInfoNext != prceNil )
			{
			//  try to log the current undo info, but do not wait if the log buffer
			//  is full

			LGPOS lgpos;
			err = ErrLGUndoInfoWithoutRetry( pbf->prceUndoInfoNext, &lgpos );

			//  we succeeded logging the undo info

			if ( err >= JET_errSuccess )
				{
				//  remove this undo info from the BF

				BFIRemoveUndoInfo( pbf, pbf->prceUndoInfoNext, lgpos );
				}

			//  we failed logging the undo info

			else
				{
				//  we failed because the log is down

				if (	err == JET_errLogWriteFail ||
						err == JET_errLogDisabledDueToRecoveryFailure )
					{
					//  fail with this error

					Call( err );
					}

				//  we failed because we cannot log undo info during redo

				else if ( err == JET_errCannotLogDuringRecoveryRedo )
					{
					//  we must wait for this dependency to be removed via
					//  BFRemoveUndoInfo()
					//
					//  NOTE:  act as if this was a latch conflict so that the
					//  allocation quota system views it as an external buffer
					//  allocation (which it is...  sort of)

					Call( ErrERRCheck( errBFLatchConflict ) );
					}

				//  we failed because the log buffers are full

				else
					{
					Assert( err == errLGNotSynchronous );

					//  flush the log

					PinstFromIfmp( pbf->ifmp & ifmpMask )->m_plog->LGSignalFlush();

					//  we must wait to remove this dependency

					Call( ErrERRCheck( errBFIRemainingDependencies ) );
					}
				}
			}
		}

	//  this BF is depended on the log

	LOG*	plog;
	int		icmp;
	plog	= PinstFromIfmp( pbf->ifmp & ifmpMask )->m_plog;
	plog->m_critLGBuf.Enter();
	icmp	= CmpLgpos( &pbf->lgposModify, &plog->m_lgposToFlush );
	plog->m_critLGBuf.Leave();

	if (	!plog->m_fLogDisabled &&
			plog->m_fRecoveringMode != fRecoveringRedo &&
			icmp >= 0 )
		{
		if ( !fRemoveDependencies )
			{
			Call( ErrERRCheck( errBFIRemainingDependencies ) );
			}

		//  the log is down

		if ( plog->m_fLGNoMoreLogWrite )
			{
			//  fail with this error

			Call( ErrERRCheck( JET_errLogWriteFail ) );
			}

		//  the log is up

		else
			{
			//  flush the log

			plog->LGSignalFlush();

			//  we must wait to remove this dependency

			Call( ErrERRCheck( errBFIRemainingDependencies ) );
			}
		}

	//  check the range lock (backup dependency)

	if ( !( pbf->ifmp & ifmpSLV ) )
		{
		//  get the active range lock

		FMP* const	pfmp		= &rgfmp[ pbf->ifmp ];
		const int	irangelock	= pfmp->EnterRangeLock();
		BOOL		fFlushable	= !pfmp->FRangeLocked( irangelock, pbf->pgno );

#ifdef ELIMINATE_PAGE_PATCHING
		//  this page is not range locked, check if dependencies during
		//	backup preclude flushing

		if ( fFlushable && 0 != pfmp->PgnoMost() )	//	non-zero pgnoMost implies backup in progress
			{
			pfmp->CritLatch().Enter();
			fFlushable	= ( 0 == pfmp->PgnoMost()	//	double-check pgnoMost now that we're in critLatch
							|| !FBFIPatchWouldBeRequired( pbf ) );
			pfmp->CritLatch().Leave();
			}
#endif

		//	this page is not range-locked, and there are no dependencies
		//	that would preclude flushing it during backup

		if ( fFlushable )
			{
			//  leave our reference on this range lock until this BF has
			//  been flushed or we decide to not flush this BF

			pbf->irangelock = BYTE( irangelock );
			Assert( pbf->irangelock == irangelock );
			}
		else
			{
			//  release our reference on this range lock

			pfmp->LeaveRangeLock( irangelock );

			//  there is a dependency on this BF that we must wait to remove

			Call( ErrERRCheck( errBFIRemainingDependencies ) );
			}
		}

HandleError:

	//  we cannot remove all dependencies on this BF due to a fatal error

	if (	err < JET_errSuccess &&
			err != errBFIRemainingDependencies &&
			err != errBFIPageFlushed &&
			err != errBFIPageFlushPending &&
			err != errBFLatchConflict )
		{
		//  set this BF to the appropriate error state

		pbf->err = SHORT( err );
		Assert( pbf->err == err );
		}

	//  return the result of the remove dependencies operation

	return err;
	}

ERR ErrBFIFlushPage( PBF pbf, const BFDirtyFlags bfdfFlushMin, const BOOL fOpportune )
	{
	ERR err = JET_errSuccess;

	//  we can exclusively latch this BF

	CSXWLatch::ERR errSXWL = pbf->sxwl.ErrTryAcquireExclusiveLatch();

	if ( errSXWL == CSXWLatch::errSuccess )
		{
		//  this BF is too clean to flush

		if ( pbf->bfdf < max( bfdfFlushMin, bfdfUntidy ) )
			{
			//  release our latch and leave

			pbf->sxwl.ReleaseExclusiveLatch();
			}

		//  this BF is dirty enough to flush

		else
			{
			//  try to remove all dependencies on this BF.  if there is an
			//  issue, release our latch and fail with the error

			if ( ( err = ErrBFIPrepareFlushPage( pbf, !fOpportune ) ) < JET_errSuccess )
				{
				pbf->sxwl.ReleaseExclusiveLatch();
				Call( err );
				}

			//  schedule this page for async write

			const IFMP	ifmp	= pbf->ifmp;
			const PGNO	pgno	= pbf->pgno;

			pbf->sxwl.ReleaseOwnership( bfltExclusive );
			BFIAsyncWrite( pbf );

			//  perform opportunistic flush of eligible neighboring pages
			//
			//  NOTE:  we must disable ownership tracking because it is possible
			//  that we will try to latch a page that we already have latched
			//  while trying to flush an eligible neighboring page.  *sigh!*
			//  the only reason it works is because we try-acquire the exclusive
			//  latch instead of acquiring it and this will work even if we
			//  already have the shared latch

			BOOL			fDidOpp;
			PGNO			pgnoOpp;
			PGNOPBF			pgnopbf;
			BFHash::ERR		errHash;
			BFHash::CLock	lock;

			fDidOpp = !fOpportune && fEnableOpportuneWrite;
			for ( pgnoOpp = pgno + 1; fDidOpp; pgnoOpp++ )
				{
				bfhash.ReadLockKey( IFMPPGNO( ifmp, pgnoOpp ), &lock );
				errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );
				fDidOpp = (	errHash == BFHash::errSuccess &&
							FBFIOpportuneWrite( pgnopbf.pbf ) );
				bfhash.ReadUnlockKey( &lock );

				CLockDeadlockDetectionInfo::DisableOwnershipTracking();
				fDidOpp = (	fDidOpp &&
							cBFPageFlushPending < cBFPageFlushPendingMax &&
							ErrBFIFlushPage( pgnopbf.pbf, bfdfUntidy, fTrue ) == errBFIPageFlushed );
				CLockDeadlockDetectionInfo::EnableOwnershipTracking();

				if ( fDidOpp )
					{
					cBFPagesOpportunelyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
					}
				}

			fDidOpp = !fOpportune && fEnableOpportuneWrite;
			for ( pgnoOpp = pgno - 1; fDidOpp; pgnoOpp-- )
				{
				bfhash.ReadLockKey( IFMPPGNO( ifmp, pgnoOpp ), &lock );
				errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );
				fDidOpp = (	errHash == BFHash::errSuccess &&
							FBFIOpportuneWrite( pgnopbf.pbf ) );
				bfhash.ReadUnlockKey( &lock );

				CLockDeadlockDetectionInfo::DisableOwnershipTracking();
				fDidOpp = (	fDidOpp &&
							cBFPageFlushPending < cBFPageFlushPendingMax &&
							ErrBFIFlushPage( pgnopbf.pbf, bfdfUntidy, fTrue ) == errBFIPageFlushed );
				CLockDeadlockDetectionInfo::EnableOwnershipTracking();

				if ( fDidOpp )
					{
					cBFPagesOpportunelyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
					}
				}

			//  return an error indicating that the page was flushed

			Call( ErrERRCheck( errBFIPageFlushed ) );
			}
		}

	//  we can not exclusively latch this BF

	else
		{
		//  the page is currently being flushed

		if ( pbf->err == wrnBFPageFlushPending )
			{
			//  return flush in progress

			Call( ErrERRCheck( errBFIPageFlushPending ) );
			}

		//  the page is not currently being flushed

		else
			{
			//  return latch confict because we could not flush the page

			Call( ErrERRCheck( errBFLatchConflict ) );
			}
		}

HandleError:
	return err;
	}

ERR ErrBFIEvictPage( PBF pbf, BFLRUK::CLock* plockLRUK, BOOL fEvictDirty )
	{
	ERR err = JET_errSuccess;

	//  write lock this IFMP / PGNO in the hash table to prevent new
	//  latch attempts on this BF

	BFHash::CLock	lockHash;
	bfhash.WriteLockKey( IFMPPGNO( pbf->ifmp, pbf->pgno ), &lockHash );

	//  no one currently owns or is waiting to own the latch on this BF
	//  (we tell this by trying to acquire the Write Latch)

	CSXWLatch::ERR errSXWL = pbf->sxwl.ErrTryAcquireWriteLatch();

	if ( errSXWL == CSXWLatch::errSuccess )
		{
		//  the BF doesn't have a hashed latch and this BF is clean / untidy or
		//  we are allowed to evict dirty BFs

		if ( FBFILatchDemote( pbf ) && ( pbf->bfdf < bfdfDirty || fEvictDirty ) )
			{
			//  we currently have this BF locked in the LRUK

			PBF pbfLocked;
			if ( bflruk.ErrGetCurrentResource( plockLRUK, &pbfLocked ) == BFLRUK::errSuccess )
				{
				//  determine if we will save the history for this BF.  we only
				//  want to save history for the current version of a page that
				//  was actually touched (i.e. validated) and is not being
				//  purged (inferred via fEvictDirty)

				const BOOL fSaveHistory =	!fEvictDirty &&
											pbf->fCurrentVersion &&
											pbf->err != errBFIPageNotVerified;

				//  remove this BF from the IFMP / PGNO hash table if it is the
				//  current version of the page

				if ( pbf->fCurrentVersion )
					{
					pbf->fCurrentVersion = fFalse;

					BFHash::ERR errHash = bfhash.ErrDeleteEntry( &lockHash );
					Assert( errHash == BFHash::errSuccess );
					}

				//  release our write lock on this IFMP / PGNO

				bfhash.WriteUnlockKey( &lockHash );

				//  remove this BF from the LRUK

				BFLRUK::ERR errLRUK = bflruk.ErrEvictCurrentResource( plockLRUK, IFMPPGNO( pbf->ifmp, pbf->pgno ), fSaveHistory );
				Assert( errLRUK == BFLRUK::errSuccess );

				//  force this BF to be clean, purging any dependencies

				BFICleanPage( pbf );

				//  make sure our lgposOldestBegin0 is reset

				BFIResetLgposOldestBegin0( pbf );

				//  update DBA statistics
				//
				//  NOTE:  we toggle this flag because we want the ability to
				//  exclude some pages from counting as newly evicted pages
				//  once they are reused.  such pages have this flag set before
				//  they are evicted while they still contain valid data

				pbf->fNewlyEvicted = !pbf->fNewlyEvicted;

				//  free this BF to the avail pool

				pbf->sxwl.ReleaseOwnership( bfltWrite );
				BFIFreePage( pbf, fFalse );
				}

			//  we currently do not have this BF locked in the LRUK

			else
				{
				//  release our write lock on this IFMP / PGNO

				bfhash.WriteUnlockKey( &lockHash );

				//  release our write latch on this BF

				pbf->sxwl.ReleaseWriteLatch();

				//  we can not evict this page

				Call( ErrERRCheck( errBFIPageNotEvicted ) );
				}
			}

		//  the BF still has a hashed latch or this BF is dirty / filthy and
		//  we aren't allowed to evict dirty BFs

		else
			{
			//  release our write lock on this IFMP / PGNO

			bfhash.WriteUnlockKey( &lockHash );

			//  release our write latch on this BF

			pbf->sxwl.ReleaseWriteLatch();

			//  we can not evict this page

			Call( ErrERRCheck( errBFIPageNotEvicted ) );
			}
		}

	//  someone owns or is waiting to own a latch on this BF

	else
		{
		//  release our write lock on this IFMP / PGNO

		bfhash.WriteUnlockKey( &lockHash );

		//  we can not evict this page because of a latch conflict

		Call( ErrERRCheck( errBFLatchConflict ) );
		}

HandleError:
	return err;
	}

void BFIDirtyPage( PBF pbf, BFDirtyFlags bfdf )
	{
	//  the BF is clean

	if ( pbf->bfdf == bfdfClean )
		{
		//  reset the BF's lgposOldestBegin0

		BFIResetLgposOldestBegin0( pbf );

		//  reset the error state of the BF
		//
		//  NOTE:  this is to handle the case where we want to modify a page
		//  that was latched with bflfNoFail.  we want a chance to write our
		//  changes to the page

		pbf->err = JET_errSuccess;
		}

	//  make this BF dirtier

	if ( pbf->bfdf < bfdfDirty && bfdf >= bfdfDirty )
		{
		AtomicDecrement( (long*)&cBFClean );
		}

	pbf->bfdf = BYTE( max( pbf->bfdf, bfdf ) );
	Assert( pbf->bfdf == max( pbf->bfdf, bfdf ) );
	}

void BFICleanPage( PBF pbf )
	{
	//  remove every BF above us and ourself from the dependency tree, both in
	//  time and space (time dependencies and flush order dependencies)
	//
	//  NOTE:  we should not be dependent on anyone else if we were flushed.
	//  the generality of this code is aimed at handling the purging of BFs
	//  that are in an error state before crashing the system and forcing a
	//  recovery due to an I/O error on the database or log files

	if (	pbf->bfdf >= bfdfDirty &&
			(	pbf->FDependent() ||
				pbf->pbfDependent != pbfNil ||
				pbf->pbfTimeDepChainPrev != pbfNil ||
				pbf->pbfTimeDepChainNext != pbfNil ||
				pbf->fDependentPurged ) )
		{
		critBFDepend.Enter();

		while (	pbf->FDependent() ||
				pbf->pbfDependent != pbfNil ||
				pbf->pbfTimeDepChainPrev != pbfNil ||
				pbf->pbfTimeDepChainNext != pbfNil )
			{
			//  find a leaf of our branch in the dependency tree

			PBF pbfT = pbf;
			while ( pbfT->pbfTimeDepChainNext != pbfNil || pbfT->FDependent() )
				{
				while ( pbfT->pbfTimeDepChainNext != pbfNil )
					{
					pbfT = pbfT->pbfTimeDepChainNext;
					Assert( pbfT->ifmp == pbf->ifmp );	//	no cross-database dependencies allowed
					}

				while ( pbfT->FDependent() )
					{
					pbfT = pbfT->pbfDepChainHeadNext;
					Assert( pbfT->ifmp == pbf->ifmp );	//	no cross-database dependencies allowed
					}
				}

			//  if this BF is part of the dependency tree, remove it

			if ( pbfT->pbfDependent != pbfNil )
				{
				pbfT->pbfDependent->fDependentPurged = pbf->err != wrnBFPageFlushPending;
				BFIUndepend( pbfT, pbfT->pbfDependent );
				}

			//  if this BF is part of a time dependency list, remove it

			if ( pbfT->pbfTimeDepChainPrev != pbfNil )
				{
				pbfT->pbfTimeDepChainPrev->fDependentPurged		= pbf->err != wrnBFPageFlushPending;
				pbfT->pbfTimeDepChainPrev->pbfTimeDepChainNext	= pbfNil;
				pbfT->pbfTimeDepChainPrev						= pbfNil;
				}
			}

		if ( pbf->fOlderVersion )
			{
			pbf->fOlderVersion = fFalse;
			AtomicDecrement( (long*)&cBFVersioned );
			}
		pbf->fDependentPurged = fFalse;

		critBFDepend.Leave();
		}

	//  remove all undo info

	if ( pbf->prceUndoInfoNext != prceNil )
		{
		ENTERCRITICALSECTION ecs( &critpoolBFDUI.Crit( pbf ) );

		while ( pbf->prceUndoInfoNext != prceNil )
			{
			BFIRemoveUndoInfo( pbf, pbf->prceUndoInfoNext );
			}
		}

	//  reset our lgposModify

	BFIResetLgposModify( pbf );

	//  reset our I/O error status

	if ( pbf->err == errBFIPageNotVerified )
		{
		cBFPagesPrereadUntouched.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
		}

	pbf->err = JET_errSuccess;

	//  update our page write stats

	if ( pbf->fFlushed )
		{
		pbf->fFlushed = fFalse;
		}

	//  make this BF clean (do this after removing ourself from the dependency
	//  tree to avoid asserting)

	if ( pbf->bfdf >= bfdfDirty )
		{
		AtomicIncrement( (long*)&cBFClean );
		}
	pbf->bfdf = bfdfClean;
	}

	//  I/O

//  this function performs a Sync Read into the specified Write Latched BF

void BFISyncRead( PBF pbf )
	{
	//  prepare sync read

	BFISyncReadPrepare( pbf );

	//  issue sync read

	IFileAPI *const pfapi		=	( pbf->ifmp & ifmpSLV ) ?
										rgfmp[pbf->ifmp & ifmpMask].PfapiSLV() :
										rgfmp[pbf->ifmp].Pfapi();
	const QWORD		ibOffset	=	OffsetOfPgno( pbf->pgno );
	const DWORD		cbData		=	g_cbPage;
	BYTE* const		pbData		=	(BYTE*)pbf->pv;

	ERR err = pfapi->ErrIORead( ibOffset, cbData, pbData );

	//  complete sync read

	BFISyncReadComplete( err, pfapi, ibOffset, cbData, pbData, pbf );
	}

void BFISyncReadPrepare( PBF pbf )
	{
	//  declare I/O pending

	ERR errT = ErrERRCheck( errBFIPageFaultPending );
	pbf->err = SHORT( errT );
	Assert( pbf->err == errT );
	}

void BFISyncReadComplete(	const ERR 			err,
							IFileAPI* const		pfapi,
							const QWORD 		ibOffset,
							const DWORD 		cbData,
							const BYTE* const	pbData,
							const PBF 			pbf )
	{
	//  read was successful

	if ( err >= 0 )
		{
		//  declare I/O successful but page unverified

		ERR errT = ErrERRCheck( errBFIPageNotVerified );
		pbf->err = SHORT( errT );
		Assert( pbf->err == errT );
		}

	//  read was not successful

	else
		{
		//  declare the appropriate I/O error

		pbf->err = SHORT( err );
		Assert( pbf->err == err );
		}

	cBFPagesRead.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
	}

//  this function performs a Async Read into the specified Write Latched BF

void BFIAsyncRead( PBF pbf )
	{
	//  prepare async read

	BFIAsyncReadPrepare( pbf );

	//  issue async read

	IFileAPI * const pfapi = (	pbf->ifmp & ifmpSLV ) ?
									rgfmp[pbf->ifmp & ifmpMask].PfapiSLV() :
									rgfmp[pbf->ifmp].Pfapi();

	ERR err = pfapi->ErrIORead(	OffsetOfPgno( pbf->pgno ),
								g_cbPage,
								(BYTE*)pbf->pv,
								IFileAPI::PfnIOComplete( BFIAsyncReadComplete ),
								DWORD_PTR( pbf ) );
	}

void BFIAsyncReadPrepare( PBF pbf )
	{
	//  declare I/O pending

	ERR errT = ErrERRCheck( errBFIPageFaultPending );
	pbf->err = SHORT( errT );
	Assert( pbf->err == errT );
	}

void BFIAsyncReadComplete(	const ERR			err,
							IFileAPI* const		pfapi,
							const QWORD			ibOffset,
							const DWORD			cbData,
							const BYTE* const	pbData,
							const PBF			pbf )
	{
	//  read was successful

	if ( err >= 0 )
		{
		//  declare I/O successful but page unverified

		ERR errT = ErrERRCheck( errBFIPageNotVerified );
		pbf->err = SHORT( errT );
		Assert( pbf->err == errT );
		}

	//  read was not successful

	else
		{
		//  declare the appropriate I/O error

		pbf->err = SHORT( err );
		Assert( pbf->err == err );
		}

	cBFPagesRead.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );

	//  release our Write Latch on this BF

	pbf->sxwl.ClaimOwnership( bfltWrite );
	pbf->sxwl.ReleaseWriteLatch();
	}

//  this function prepares and schedules a BF for Async Write

void BFIAsyncWrite( PBF pbf )
	{
	//  prepare async write

	BFIAsyncWritePrepare( pbf );

	//  issue async write

	IFileAPI * const pfapi = (	pbf->ifmp & ifmpSLV ) ?
									rgfmp[pbf->ifmp & ifmpMask].PfapiSLV() :
									rgfmp[pbf->ifmp].Pfapi();

	ERR err = pfapi->ErrIOWrite(	OffsetOfPgno( pbf->pgno ),
									g_cbPage,
									(BYTE*)pbf->pv,
									IFileAPI::PfnIOComplete( BFIAsyncWriteComplete ),
									DWORD_PTR( pbf ) );
	}

void BFIAsyncWritePrepare( PBF pbf )
	{
	//  declare I/O pending

	ERR errT = ErrERRCheck( wrnBFPageFlushPending );
	pbf->err = SHORT( errT );
	Assert( pbf->err == errT );

	AtomicIncrement( (long*)&cBFPageFlushPending );

	//  the page does not contain unstructured data

	if ( FBFIDatabasePage( pbf ) )
		{
		//  compute and update page checksum

		*( (LittleEndian<DWORD>*) ( pbf->pv ) ) = UlUtilChecksum( (const BYTE*) pbf->pv, g_cbPage );
		}

	//  HACK:  set the flush flag here so that we close a race condition
	//  between flush and the clean thread

	if ( Ptls()->fCleanThread )
		{
		if ( pbf->ifmp & ifmpSLV )
			{
			rgfmp[pbf->ifmp & ifmpMask].SetBFICleanSLV();
			}
		else
			{
			rgfmp[pbf->ifmp].SetBFICleanDb();
			}
		}
	}

void BFIAsyncWriteComplete(	const ERR			err,
							IFileAPI* const		pfapi,
							const QWORD			ibOffset,
							const DWORD			cbData,
							const BYTE* const	pbData,
							const PBF			pbf )
	{
	//  write was successful

	if ( err >= 0 )
		{
		FMP *		pfmp	= rgfmp + ( pbf->ifmp & ifmpMask );

#ifdef ELIMINATE_PAGE_PATCHING
		const BOOL	fPatch	= fFalse;
#else
		BOOL		fPatch	= ( pfapi == pfmp->Pfapi() );

		//  we need to re-issue this write to the patch file

		if ( fPatch )
			{
			pfmp->CritLatch().Enter();
			if ( FBFIPatch( pfmp, pbf ) )
				{
				Assert( !( pbf->ifmp & ifmpSLV ) );

				//  get next available offset in patch file

				QWORD ibOffset = OffsetOfPgno( pfmp->CpagePatch() + 1 );

				//  update patch file size and write count

				pfmp->IncCpagePatch( cbData / g_cbPage );
				pfmp->IncCPatchIO();
				pfmp->CritLatch().Leave();

				//  re-issue write to the patch file

				const ERR	errT	= pfmp->PfapiPatch()->ErrIOWrite(
																ibOffset,
																cbData,
																pbData,
																IFileAPI::PfnIOComplete( BFIAsyncWriteCompletePatch ),
																DWORD_PTR( pbf ) );

				CallS( pfmp->PfapiPatch()->ErrIOIssue() );
				}
			else
				{
				pfmp->CritLatch().Leave();
				fPatch = fFalse;
				}
			}

#endif	//	ELIMINATE_PAGE_PATCHING

		//  we do not need to re-issue this write to the patch file

		if ( !fPatch )
			{
			//  release our reference count on the range lock now that our write
			//  has completed

			if ( !( pbf->ifmp & ifmpSLV ) )
				{
				rgfmp[ pbf->ifmp ].LeaveRangeLock( pbf->irangelock );
				}

			//  reset BF to "cleaned" status

			const BOOL	fFlushed		= pbf->fFlushed;
			const BOOL	fOlderVersion	= pbf->fOlderVersion;

			BFICleanPage( pbf );

			//  update our page write stats

			if ( fFlushed )
				{
				cBFPagesRepeatedlyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
				}
			pbf->fFlushed = fTrue;
			if ( fOlderVersion )
				{
				cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
				}

			cBFPagesWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
			AtomicDecrement( (long*)&cBFPageFlushPending );

			//  release our exclusive latch on this BF

			pbf->sxwl.ClaimOwnership( bfltExclusive );
			pbf->sxwl.ReleaseExclusiveLatch();
			}
		}

	//  write was not successful

	else
		{
		//  release our reference count on the range lock now that our write
		//  has completed

		if ( !( pbf->ifmp & ifmpSLV ) )
			{
			rgfmp[ pbf->ifmp ].LeaveRangeLock( pbf->irangelock );
			}

		//  declare the appropriate I/O error

		pbf->err = SHORT( err );
		Assert( pbf->err == err );

		//  update our page write stats

		if ( pbf->fFlushed )
			{
			cBFPagesRepeatedlyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
			}
		else
			{
			pbf->fFlushed = fTrue;
			}
		if ( pbf->fOlderVersion )
			{
			cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
			}

		cBFPagesWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
		AtomicDecrement( (long*)&cBFPageFlushPending );

		//  release our exclusive latch on this BF

		pbf->sxwl.ClaimOwnership( bfltExclusive );
		pbf->sxwl.ReleaseExclusiveLatch();
		}
	}

#ifdef ELIMINATE_PAGE_PATCHING
#else
void BFIAsyncWriteCompletePatch(	const ERR			err,
									IFileAPI* const		pfapi,
									const QWORD			ibOffset,
									const DWORD			cbData,
									const BYTE* const	pbData,
									const PBF			pbf )
	{
	Assert( !( pbf->ifmp & ifmpSLV ) );

	FMP* pfmp = rgfmp + pbf->ifmp;

	//  update patch file write count and error

	pfmp->CritLatch().Enter();
	pfmp->DecCPatchIO();
	if ( pfmp->ErrPatch() >= JET_errSuccess )
		{
		pfmp->SetErrPatch( err );
		}
	pfmp->CritLatch().Leave();

	//  complete the original write again.  we will not need to patch this page,
	//  so we will take the non-patch case this time

	BFIAsyncWriteComplete( err, pfapi, ibOffset, cbData, pbData, pbf );
	}
#endif	//	ELIMINATE_PAGE_PATCHING

//  returns fTrue if this BF is a good candidate for being opportunely written

INLINE BOOL FBFIOpportuneWrite( PBF pbf )
	{
	//  if this page has older versions then we should try and write it

	if ( pbf->pbfTimeDepChainNext != pbfNil )
		{
		return fTrue;
		}

	//  if this page is not a hot page then we should try and write it

	if ( !bflruk.FHotResource( pbf ) )
		{
		return fTrue;
		}

	//  if this page is impeding the checkpoint and it is not being modified
	//  too frequently then we should try and write it

	LOG* const	plog		= PinstFromIfmp( pbf->ifmp & ifmpMask )->m_plog;
	const LGPOS	lgposNewest	= (	plog->m_fRecoveringMode == fRecoveringRedo ?
									plog->m_lgposRedo :
									plog->m_lgposLogRec );

	if (	CmpLgpos( &pbf->lgposModify, &lgposMin ) &&
			CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) &&
			(	__int64( plog->CbOffsetLgpos( lgposNewest, pbf->lgposModify ) ) >
				__int64(	cbCleanCheckpointDepthMax -
							plog->CbOffsetLgpos( lgposNewest, pbf->lgposOldestBegin0 ) ) ) )
		{
		return fTrue;
		}

	//  otherwise, we should not try and write it

	return fFalse;
	}


	//  Patch File

#ifdef ELIMINATE_PAGE_PATCHING
#else
//  returns TRUE if the BF should be appended to the patch file.
//	*** NOTE *** The general rule to determine if a page should be
//	patched is as follows: "If the source page still needs to be
//	copied to the backup, but the destination page doesn't, then
//	the destination page must be patched".
BOOL FBFIPatch( FMP * pfmp, PBF pbf )
	{
	//  critical section

	Assert( pfmp->CritLatch().FOwner() );

	//	if page written successfully and one of the following two cases
	//
	//	case 1: new page in split is a reuse of old page. contents of
	//	        old page will be moved to new page, but new page is copied
	//			already, so we have to recopy the new page with new data
	//			again.
	//	1) this page must be written before another page, and
	//	2) backup in progress, and
	//	3) page number is less than last copied page number,
	//	then write page to patch file.
	//
	//	case 2: similar to above, but new page is greater than the database
	//	        that will be copied. So the new page will not be able to be
	//			copied. We need to patch it.
	//
	//	Note that if all dependent pages were also before copy
	//	page then write to patch file would not be necessary.

	//  backup is going on and there is no error

	BOOL	fPatch	= ( NULL != pfmp->PfapiPatch()
						&& pfmp->ErrPatch() >= JET_errSuccess
						&& !FBFIPageWillBeCopiedToBackup( pfmp, pbf->pgno ) );

	//	no need to check PgnoMost() because:
	//		- we are in pfmp->CritLatch(), so this value is guaranteed not to change
	//		- the FBFIPageWillBeCopiedToBackup() check on the old page will fail if
	//		  PgnoMost() is 0, meaning the new page will not get patched
	//	fPatch = fPatch && pfmp->PgnoMost() > 0;

	//	if the old page doesn't have to be copied, then this page doesn't
	//	have to be patched:
	//		case 1:	old page already copied, meaning it was flushed, but
	//				it has a dependency on this page, so this page must
	//				have been flushed as well
	//		case 2: old page is beyond end of db to be copied, so must
	//				have all the correct log records to replay all
	//				the operations
	//	if the old page has to be copied, then this page has to be patched
	//	if one of the following is true:
	//		case 1: new page number is less than the page number being copied
	//				while old page is not copied yet. If we flush new page,
	//				and later old page is flushed and copied, then the old
	//				contents of old page is on new page and not copied. So we
	//				have to patch the new page for backup.
	//		case 2:	new page is beyond the last page that will be copied and old
	//				page is not copied yet. If we flush the new page, old page, and
	//				copied the old page, then we lost the old contents of old page.
	//				patch the new page for backup.

	if ( fPatch )
		{
		fPatch = fFalse;

		//	check if any of its old page (depend list) will be copied for backup.

		critBFDepend.Enter();
		for ( PBF pbfDependentT = pbf->pbfDependent;
			NULL != pbfDependentT;
			pbfDependentT = pbfDependentT->pbfDependent )
			{
			//	check if old page wil be copied to backup
			if ( FBFIPageWillBeCopiedToBackup( pfmp, pbfDependentT->pgno ) )
				{
				fPatch = fTrue;
				break;
				}

			}
		critBFDepend.Leave();
		}

	return fPatch;
	}

#endif	//	ELIMINATE_PAGE_PATCHING


	//  Dependencies

//  critical section protecting all dependency trees

CCriticalSection	critBFDepend( CLockBasicInfo( CSyncBasicInfo( szBFDepend ), rankBFDepend, 0 ) );

//  makes pbfD dependent on pbf.  pbf must not have a dependent

void BFIDepend( PBF pbf, PBF pbfD )
	{
	//  critical section

	Assert( critBFDepend.FOwner() );

	//  validate IN args

	Assert( pbf != pbfNil );
	Assert( pbfD != pbfNil );
	Assert( FBFIAssertValidDependencyTree( pbf ) );
	Assert( FBFIAssertValidDependencyTree( pbfD ) );
	Assert( pbf->pbfDependent == pbfNil );

	//  update dependency chain head index

	//  cases 1 & 2:  pbfD is at the head of a dependency chain

	if ( !pbfD->FDependent() )
		{
		//  case 2:  pbfD is at the head of a dependency chain and one of many in
		//           the dependency chain head list

		if ( pbfD->pbfDepChainHeadNext != pbfD )
			{
			Assert( pbfD->pbfDepChainHeadPrev != pbfD );

			//  get prev / next BFs from pbfD

			PBF pbfDPrev = pbfD->pbfDepChainHeadPrev;
			PBF pbfDNext = pbfD->pbfDepChainHeadNext;

			//  get prev-most / next-most BFs from pbf

			PBF pbfPrevMost = pbf;
			while ( pbfPrevMost->FDependent() )
				{
				pbfPrevMost = pbfPrevMost->pbfDepChainHeadNext;
				Assert( pbfPrevMost != pbfNil );
				}
			PBF pbfNextMost = pbfPrevMost->pbfDepChainHeadPrev;

			//  fixup dependency chain head list

			pbfDPrev->pbfDepChainHeadNext = pbfPrevMost;
			pbfDNext->pbfDepChainHeadPrev = pbfNextMost;
			pbfPrevMost->pbfDepChainHeadPrev = pbfDPrev;
			pbfNextMost->pbfDepChainHeadNext = pbfDNext;
			}

		//  set both dependency chain pointers on pbfD to point to pbf

		pbfD->pbfDepChainHeadPrev = pbf;
		pbfD->pbfDepChainHeadNext = pbf;
		}

	// case 3:  pbfD is not at the head of a dependency chain

	else
		{
		//  get next-most / next-most-next BFs from pbfD

		PBF pbfDNextMost = pbfD;
		while ( pbfDNextMost->FDependent() )
			{
			pbfDNextMost = pbfDNextMost->pbfDepChainHeadPrev;
			Assert( pbfDNextMost != pbfNil );
			}
		PBF pbfDNextMostNext = pbfDNextMost->pbfDepChainHeadNext;

		//  get prev-most / next-most BFs from pbf

		PBF pbfPrevMost = pbf;
		while ( pbfPrevMost->FDependent() )
			{
			pbfPrevMost = pbfPrevMost->pbfDepChainHeadNext;
			Assert( pbfPrevMost != pbfNil );
			}
		PBF pbfNextMost = pbfPrevMost->pbfDepChainHeadPrev;

		//  fixup dependency chain head list

		pbfDNextMost->pbfDepChainHeadNext = pbfPrevMost;
		pbfDNextMostNext->pbfDepChainHeadPrev = pbfNextMost;
		pbfPrevMost->pbfDepChainHeadPrev = pbfDNextMost;
		pbfNextMost->pbfDepChainHeadNext = pbfDNextMostNext;

		//  set prev dependency chain pointer on pbfD to point to pbf

		pbfD->pbfDepChainHeadPrev = pbf;
		}

	//  set the dependence

	pbf->pbfDependent = pbfD;

	//  validate OUT args

	Assert( FBFIAssertValidDependencyTree( pbf ) );
	Assert( FBFIAssertValidDependencyTree( pbfD ) );
	}


//  removes pbfD as a dependent on pbf.  pbf must not be dependent on other BFs

void BFIUndepend( PBF pbf, PBF pbfD )
	{
	//  critical section

	Assert( critBFDepend.FOwner() );

	//  validate IN args

	Assert( pbf != pbfNil );
	Assert( pbfD != pbfNil );
	Assert( FBFIAssertValidDependencyTree( pbf ) );
	Assert( FBFIAssertValidDependencyTree( pbfD ) );
	Assert( !pbf->FDependent() );

	//  case 1 & 2:  pbfD is only dependent on pbf

	if ( pbfD->pbfDepChainHeadNext == pbf && pbfD->pbfDepChainHeadPrev == pbf )
		{
		//  case 1:  pbf is the only member of the dependency chain head list

		if ( pbf->pbfDepChainHeadNext == pbf )
			{
			Assert( pbf->pbfDepChainHeadPrev == pbf );

			//  reset pbfD dependency chain head list pointers

			pbfD->pbfDepChainHeadPrev = pbfD;
			pbfD->pbfDepChainHeadNext = pbfD;
			}

		//  case 2:  pbf is not the only member of the dependency chain head list

		else
			{
			Assert( pbf->pbfDepChainHeadPrev != pbf );

			//  get prev / next BFs from pbf

			PBF pbfPrev = pbf->pbfDepChainHeadPrev;
			PBF pbfNext = pbf->pbfDepChainHeadNext;

			//  fixup dependency chain head list

			pbfNext->pbfDepChainHeadPrev = pbfD;
			pbfPrev->pbfDepChainHeadNext = pbfD;
			pbfD->pbfDepChainHeadPrev = pbfPrev;
			pbfD->pbfDepChainHeadNext = pbfNext;

			//  reset pbf dependency chain head list pointers

			pbf->pbfDepChainHeadPrev = pbf;
			pbf->pbfDepChainHeadNext = pbf;
			}
		}

	//  case 3, 4, & 5:  pbfD is not only dependent on pbf

	else
		{
		//  get prev / next BFs from pbf

		PBF pbfPrev = pbf->pbfDepChainHeadPrev;
		PBF pbfNext = pbf->pbfDepChainHeadNext;

		//  case 3:  pbfD dependency chain head list next pointer points to pbf

		if ( pbfD->pbfDepChainHeadNext == pbf )
			{
			//  fixup pbfD dependency chain head list next pointer

			PBF pbfT = pbfNext;
			while ( pbfT->pbfDependent != pbfD )
				{
				pbfT = pbfT->pbfDependent;
				}
			pbfD->pbfDepChainHeadNext = pbfT;
			}

		//  case 5:  pbfD dependency chain head list prev pointers points to pbf

		else if ( pbfD->pbfDepChainHeadPrev == pbf )
			{
			//  fixup pbfD dependency chain head list next pointer

			PBF pbfT = pbfPrev;
			while ( pbfT->pbfDependent != pbfD )
				{
				pbfT = pbfT->pbfDependent;
				}
			pbfD->pbfDepChainHeadPrev = pbfT;
			}

		//  fixup dependency chain head list

		pbfPrev->pbfDepChainHeadNext = pbfNext;
		pbfNext->pbfDepChainHeadPrev = pbfPrev;

		//  reset pbf dependency chain head list pointers

		pbf->pbfDepChainHeadPrev = pbf;
		pbf->pbfDepChainHeadNext = pbf;
		}

	//  reset dependency

	pbf->pbfDependent = pbfNil;

	//  validate OUT args

	Assert( FBFIAssertValidDependencyTree( pbf ) );
	Assert( FBFIAssertValidDependencyTree( pbfD ) );
	}


#ifdef DEBUG

//  set this variable to assert when a dependency tree is found to be
//  invalid (stops only once per call to FBFIAssertValidDependencyTree())

BOOL fStopWhenInvalid = fTrue;

//  asserts the first time fValid is fFalse

//  NOTE:  call this everytime fValid is modified by something other than the
//         retval of FBFIAssertValidDependencyTreeAux() (the redundant case)

BOOL fStopWhenInvalidArmed = fFalse;
void BFIAssertStopWhenInvalid( BOOL fValid )
	{
	if ( !fValid && fStopWhenInvalidArmed )
		{
		fStopWhenInvalidArmed = fFalse;
		AssertSz( fFalse, "Invalid dependency tree encountered" );
		}
	}

//  returns fTrue if the given BF is a member of a valid dependency tree

BOOL FBFIAssertValidDependencyTree( PBF pbf )
	{
	BOOL fValid = fTrue;

	//  critical section

	Assert( critBFDepend.FOwner() );

#ifdef DEBUG_DEPENDENCIES

	//  reset stop-when-invalid logic

	fStopWhenInvalidArmed = fStopWhenInvalid;

	//  move to the root of the dependency tree of which this BF is a member

	PBF pbfRoot = pbf;
	long cLoop = 0;
	while ( pbfRoot->pbfDependent != pbfNil )
		{
		pbfRoot = pbfRoot->pbfDependent;
		BFIAssertStopWhenInvalid
			(
			fValid = fValid && ++cLoop < cbfCache
			);
		}

	//  recursively validate the entire tree

	fValid = fValid && FBFIAssertValidDependencyTreeAux( pbfRoot, pbfRoot );

#endif  //  DEBUG_DEPENDENCIES

	return fValid;
	}


//  returns fTrue if the dependency tree rooted at the given BF is valid

BOOL FBFIAssertValidDependencyTreeAux( PBF pbf, PBF pbfRoot )
	{
	BOOL fValid = fTrue;

	//  we had better never see the same IFMP / PGNO twice

	BFIAssertStopWhenInvalid
		(
		fValid = fValid && ( pbf == pbfRoot || !( pbf->pgno == pbfRoot->pgno && pbf->ifmp == pbfRoot->ifmp ) )
		);

	//  validate pointers

	BFIAssertStopWhenInvalid
		(
		fValid = fValid && ( pbf->pbfDependent == pbfNil || FBFICacheValidPbf( pbf->pbfDependent ) )
		);
	BFIAssertStopWhenInvalid
		(
		fValid = fValid && FBFICacheValidPbf( pbf->pbfDepChainHeadNext )
		);
	BFIAssertStopWhenInvalid
		(
		fValid = fValid && FBFICacheValidPbf( pbf->pbfDepChainHeadPrev )
		);

	//  normalize pointers

	PBF pbfDep = pbf->pbfDependent;
	PBF pbfNext = pbf->pbfDepChainHeadNext;
	PBF pbfPrev = pbf->pbfDepChainHeadPrev;

	//  if we have a dependent or are dependent on others, we must be dirty

	BFIAssertStopWhenInvalid
		(
		fValid = fValid && ( ( pbfDep == pbfNil && !pbf->FDependent() ) || pbf->bfdf >= bfdfDirty )
		);

	//  if we have a dependent, it must be dirty

	BFIAssertStopWhenInvalid
		(
		fValid = fValid && ( pbfDep == pbfNil || pbfDep->bfdf >= bfdfDirty )
		);

	//  we are dependent on others

	if ( pbf->FDependent() )
		{
		//  our next / prev pointers must not point at us

		BFIAssertStopWhenInvalid
			(
			fValid = fValid && pbfNext != pbf
			);
		BFIAssertStopWhenInvalid
			(
			fValid = fValid && pbfPrev != pbf
			);

		//  our next / prev pointers must point at a node that we are
		//  immediately dependent on

		BFIAssertStopWhenInvalid
			(
			fValid = fValid && pbfNext->pbfDependent == pbf
			);
		BFIAssertStopWhenInvalid
			(
			fValid = fValid && pbfPrev->pbfDependent == pbf
			);

		//  both our next / prev pointers are dependent on no-one

		if ( !pbfNext->FDependent() && !pbfPrev->FDependent() )
			{
			//  ensure that we are (eventually) dependent on all the nodes in
			//  the dependency chain head list between our next / prev pointers

			PBF pbfHead = pbfNext;
			long cLoop = 0;
			while ( pbfHead != pbfPrev )
				{
				PBF pbfCurr = pbfHead;
				long cLoop2 = 0;
				while (	pbfCurr->pbfDependent != pbfNil &&
						pbfCurr->pbfDependent != pbf )
					{
					pbfCurr = pbfCurr->pbfDependent;
					BFIAssertStopWhenInvalid
						(
						fValid = fValid && ++cLoop2 < cbfCache
						);
					}
				BFIAssertStopWhenInvalid
					(
					fValid = fValid && pbfCurr->pbfDependent == pbf
					);
				pbfHead = pbfHead->pbfDepChainHeadNext;
				BFIAssertStopWhenInvalid
					(
					fValid = fValid && ++cLoop < cbfCache
					);
				}
			}

		//  our tree is valid only if the trees based at our next / prev
		//  pointers are valid

		fValid = fValid && FBFIAssertValidDependencyTreeAux( pbfNext, pbfRoot );
		fValid = fValid && FBFIAssertValidDependencyTreeAux( pbfPrev, pbfRoot );
		}

	//  we are not dependent on others

	else
		{
		//  either our next / prev pointers must both point at us or neither
		//  must point at us

		BFIAssertStopWhenInvalid
			(
			fValid = fValid && (	( pbfNext == pbf && pbfPrev == pbf ) ||
									( pbfNext != pbf && pbfPrev != pbf ) )
			);

		//  get the root of our next neighbor's dependency tree

		PBF pbfNextRoot = pbfNext;
		long cLoop = 0;
		while ( pbfNextRoot->pbfDependent != pbfNil )
			{
			pbfNextRoot = pbfNextRoot->pbfDependent;
			BFIAssertStopWhenInvalid
				(
				fValid = fValid && ++cLoop < cbfCache
				);
			}

		//  get the root of our prev neighbor's dependency tree

		PBF pbfPrevRoot = pbfNext;
		cLoop = 0;
		while ( pbfPrevRoot->pbfDependent != pbfNil )
			{
			pbfPrevRoot = pbfPrevRoot->pbfDependent;
			BFIAssertStopWhenInvalid
				(
				fValid = fValid && ++cLoop < cbfCache
				);
			}

		//  the root of the dependency tree in which our next / prev neighbors'
		//  reside must be the same as the root or our dependency tree

		BFIAssertStopWhenInvalid
			(
			fValid = fValid && pbfNextRoot == pbfRoot
			);
		BFIAssertStopWhenInvalid
			(
			fValid = fValid && pbfPrevRoot == pbfRoot
			);
		}

	return fValid;
	}

#endif  //  DEBUG

void BFISetLgposOldestBegin0( PBF pbf, LGPOS lgpos )
	{
	//  all pages with an OB0 must be dirty.  this is because we don't want untidy
	//  pages to stick around and hold up the checkpoint as we normally don't want
	//  to flush them

	BFIDirtyPage( pbf, bfdfDirty );

	//  save the current lgposOldestBegin0 for this BF

	LGPOS lgposOldestBegin0 = pbf->lgposOldestBegin0;

	//  if the specified lgposBegin0 is earlier than the current lgposOldestBegin0
	//  then reset the BF's lgposOldestBegin0

	if ( CmpLgpos( &lgposOldestBegin0, &lgpos ) > 0 )
		{
		BFIResetLgposOldestBegin0( pbf );
		}

	//  the new lgposOldestBegin0 is earlier than the current lgposOldestBegin0

	if ( CmpLgpos( &lgposOldestBegin0, &lgpos ) > 0 )
		{
		FMP* pfmp = &rgfmp[ pbf->ifmp & ifmpMask ];
		pfmp->RwlBFContext().EnterAsReader();

		BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( pbf->ifmp & ifmpSLV ) );
		Assert( pbffmp );

		//  set the new lgposOldestBegin0

		pbf->lgposOldestBegin0 = lgpos;

		//  try to insert ourself into the OB0 index

		BFOB0::CLock lock;
		pbffmp->bfob0.LockKeyPtr( lgpos.IbOffset(), pbf, &lock );

		BFOB0::ERR errOB0 = pbffmp->bfob0.ErrInsertEntry( &lock, pbf );

		pbffmp->bfob0.UnlockKeyPtr( &lock );

		//  we failed to insert ourelf into the OB0 index

		if ( errOB0 != BFOB0::errSuccess )
			{
			Assert(	errOB0 == BFOB0::errOutOfMemory ||
					errOB0 == BFOB0::errKeyRangeExceeded );

			//  insert ourself into the OB0 index overflow list.  this always
			//  succeeds but isn't good because it is unordered

			pbf->fInOB0OL = fTrue;

			pbffmp->critbfob0ol.Enter();
			pbffmp->bfob0ol.InsertAsNextMost( pbf );
			pbffmp->critbfob0ol.Leave();
			}

		pfmp->RwlBFContext().LeaveAsReader();
		}
	}

void BFIResetLgposOldestBegin0( PBF pbf )
	{
	//  delete ourself from the Oldest Begin 0 index or the overflow list

	if ( CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) )
		{
		FMP* pfmp = &rgfmp[ pbf->ifmp & ifmpMask ];
		pfmp->RwlBFContext().EnterAsReader();

		BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( pbf->ifmp & ifmpSLV ) );
		Assert( pbffmp );

		if ( pbf->fInOB0OL )
			{
			pbf->fInOB0OL = fFalse;

			pbffmp->critbfob0ol.Enter();
			pbffmp->bfob0ol.Remove( pbf );
			pbffmp->critbfob0ol.Leave();
			}
		else
			{
			BFOB0::CLock lock;
			pbffmp->bfob0.LockKeyPtr( pbf->lgposOldestBegin0.IbOffset(), pbf, &lock );

			BFOB0::ERR errOB0 = pbffmp->bfob0.ErrDeleteEntry( &lock );
			Assert( errOB0 == BFOB0::errSuccess );

			pbffmp->bfob0.UnlockKeyPtr( &lock );
			}

		pfmp->RwlBFContext().LeaveAsReader();

		pbf->lgposOldestBegin0 = lgposMax;
		}
	}

void BFISetLgposModify( PBF pbf, LGPOS lgpos )
	{
	//  the new lgposModify is later than the current lgposModify

	if ( CmpLgpos( &pbf->lgposModify, &lgpos ) < 0 )
		{
		//  set the new lgposModify

		pbf->lgposModify = lgpos;
		}
	}

void BFIResetLgposModify( PBF pbf )
	{
	pbf->lgposModify = lgposMin;
	}

void BFIAddUndoInfo( PBF pbf, RCE* prce, BOOL fMove )
	{
	//  add this RCE to the RCE chain off of the BF

	prce->AddUndoInfo( pbf->pgno, pbf->prceUndoInfoNext, fMove );

	//  put this RCE at the head of the list

	pbf->prceUndoInfoNext = prce;
	}

void BFIRemoveUndoInfo( PBF pbf, RCE* prce, LGPOS lgposModify, BOOL fMove )
	{
	//  depend this BF on the specified lgposModify

	BFISetLgposModify( pbf, lgposModify );

	//  if this RCE is at the head of the list, fix up the next pointer in the BF

	if ( pbf->prceUndoInfoNext == prce )
		{
		pbf->prceUndoInfoNext = prce->PrceUndoInfoNext();
		}

	//  remove the RCE from the RCE chain off of the BF

	prce->RemoveUndoInfo( fMove );
	}


//  Performance Monitoring Support

PERFInstance<> cBFCacheMiss;

long LBFCacheHitsCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFCacheReq.Get( iInstance ) - cBFCacheMiss.Get( iInstance );
		}

	return 0;
	}

PERFInstance<> cBFCacheReq;

long LBFCacheReqsCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		{
		long cCacheReq = cBFCacheReq.Get( iInstance );
		*( (unsigned long*) pvBuf ) = cCacheReq ? cCacheReq : 1;
		}

	return 0;
	}

long cBFClean;

long LBFCleanBuffersCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFClean;
		}

	return 0;
	}

PERFInstanceGlobal<> cBFPagesRead;
long LBFPagesReadCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesRead.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceGlobal<> cBFPagesWritten;
long LBFPagesWrittenCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesWritten.PassTo( iInstance, pvBuf );
	return 0;
	}

long LBFPagesTransferredCEFLPv( long iInstance, void* pvBuf )
	{
	if ( NULL != pvBuf )
		{
		*( (LONG *) pvBuf ) = cBFPagesRead.Get( iInstance ) + cBFPagesWritten.Get( iInstance );
		}
	return 0;
	}

long LBFLatchCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		{
		cBFCacheReq.PassTo( iInstance, pvBuf );
		}

	return 0;
	}

PERFInstance<> cBFSlowLatch;

long LBFFastLatchCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFCacheReq.Get( iInstance ) - cBFSlowLatch.Get( iInstance );
		}

	return 0;
	}

PERFInstance<> cBFBadLatchHint;

long LBFBadLatchHintCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		{
		cBFBadLatchHint.PassTo( iInstance, pvBuf );
		}

	return 0;
	}

PERFInstance<> cBFLatchConflict;

long LBFLatchConflictCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		{
		cBFLatchConflict.PassTo( iInstance, pvBuf );
		}

	return 0;
	}

PERFInstance<> cBFLatchStall;

long LBFLatchStallCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		{
		cBFLatchStall.PassTo( iInstance, pvBuf );
		}

	return 0;
	}

long LBFAvailBuffersCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bfavail.Cobject() : 0;

	return 0;
	}

long LBFCacheFaultCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bfavail.CRemove() : 0;

	return 0;
	}

long LBFCacheEvictCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = cbfNewlyEvictedUsed;

	return 0;
	}

long LBFAvailStallsCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bfavail.CRemoveWait() : 0;

	return 0;
	}

long LBFTotalBuffersCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = (unsigned long)( fBFInitialized ? cbfCache : 1 );

	return 0;
	}

long LBFCacheSizeCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		*( (unsigned __int64*) pvBuf ) = ( cbfCache - cbfNewlyCommitted ) * g_cbPage;

	return 0;
	}

long LBFStartFlushThresholdCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = (unsigned long)cbfScaledCleanThresholdStart;
		}

	return 0;
	}

long LBFStopFlushThresholdCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = (unsigned long)cbfScaledCleanThresholdStop;
		}

	return 0;
	}

PERFInstanceGlobal<> cBFPagesPreread;
long LBFPagesPrereadCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesPreread.PassTo( iInstance, pvBuf );
	return 0;
	}


PERFInstanceGlobal<> cBFUncachedPagesPreread;
long LBFCachedPagesPrereadCEFLPv( long iInstance, void* pvBuf )
	{
	if ( NULL != pvBuf )
		{
		*( (LONG *) pvBuf ) = cBFPagesPreread.Get( iInstance ) - cBFUncachedPagesPreread.Get( iInstance );
		}
	return 0;
	}


PERFInstanceGlobal<> cBFPagesPrereadUntouched;
long LBFPagesPrereadUntouchedCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesPrereadUntouched.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceGlobal<> cBFPagesVersioned;

long LBFPagesVersionedCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesVersioned.PassTo( iInstance, pvBuf );
	return 0;
	}

long cBFVersioned;

long LBFVersionedCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFVersioned;
		}

	return 0;
	}

PERFInstanceGlobal<> cBFPagesOrdinarilyWritten;

long LBFPagesOrdinarilyWrittenCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesOrdinarilyWritten.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceGlobal<> cBFPagesAnomalouslyWritten;

long LBFPagesAnomalouslyWrittenCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesAnomalouslyWritten.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceGlobal<> cBFPagesOpportunelyWritten;

long LBFPagesOpportunelyWrittenCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesOpportunelyWritten.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceGlobal<> cBFPagesRepeatedlyWritten;

long LBFPagesRepeatedlyWrittenCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesRepeatedlyWritten.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceGlobal<> cBFPagesIdlyWritten;

long LBFPagesIdlyWrittenCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesIdlyWritten.PassTo( iInstance, pvBuf );
	return 0;
	}

long LBFPageHistoryCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bflruk.CHistoryRecord() : 0;

	return 0;
	}

long LBFPageHistoryHitsCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bflruk.CHistoryHit() : 0;

	return 0;
	}

long LBFPageHistoryReqsCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bflruk.CHistoryRequest() : 1;

	return 0;
	}

long LBFPageScannedOutOfOrderCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bflruk.CResourceScannedOutOfOrder() : 0;

	return 0;
	}

long LBFPageScannedCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bflruk.CResourceScanned() : 1;

	return 0;
	}

long cBFResident;

long LBFResidentBuffersCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );

	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = cBFResident;

	return 0;
	}

long LBFMemoryEvictCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? cacheram.CpgReclaim() + cacheram.CpgEvict() : 0;

	return 0;
	}

PERFInstanceGlobal<> cBFPagesRepeatedlyRead;

long LBFPagesRepeatedlyReadCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesRepeatedlyRead.PassTo( iInstance, pvBuf );
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\cat.cxx ===
#include "std.hxx"
#include "_cat.cxx"

const OBJID	objidFDPMSO						= 2;
const OBJID objidFDPMSOShadow				= 3;

const ULONG	cbCATNormalizedObjid			= 5;	//	header byte + 4-byte objid

#pragma data_seg( "cacheline_aware_data" )
CATHash g_cathash( rankCATHash );
#pragma data_seg()


//
//	initialization for the CATALOG layer
//

ERR ErrCATInit()
	{
	//	if this assert goes off, you probably messed up adding a new column to the catalog
	//	remember to update idataMSOMax

	Assert( idataMSOMax == cColumnsMSO );

	ERR err = JET_errSuccess;

	//	initialize the catalog hash-table
	//		load factor		5.0
	//		uniformity		1.0

	CATHash::ERR errCATHash = g_cathash.ErrInit( 5.0, 1.0 );
	Assert( errCATHash == CATHash::errSuccess || CATHash::errOutOfMemory );
	if ( errCATHash == CATHash::errOutOfMemory )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	return JET_errSuccess;

HandleError:

	//	term the catalog hash-table

	g_cathash.Term();

	return err;
	}


//
//	termination of the CATALOG layer
//

void CATTerm()
	{
#ifdef DEBUG

	//	catalog hash should be empty

	CATHashAssertClean();

#endif	//	DEBUG

	//	term the catalog hash-table

	g_cathash.Term();
	}


//	lookup an entry in the catalog hash-table
// 	if lookup succeeds, returns FCB from entryCATHash

BOOL FCATHashILookup(
	IFMP			ifmp,
	CHAR* const 	szTableName,
	PGNO* const		ppgnoTableFDP,
	OBJID* const	pobjidTable )
	{
	Assert( NULL != ppgnoTableFDP );
	Assert( NULL != pobjidTable );

	//	attempt to short-circuit the catalog seek by
	//	looking for it in the global ifmp/table-name
	//	hash table first

	CATHashKey		keyCATHash( ifmp, szTableName );
	CATHashEntry	entryCATHash;
	CATHash::CLock	lockCATHash;

	//	lock the key
	g_cathash.ReadLockKey( keyCATHash, &lockCATHash );

	//	see if we the entry exists
	const CATHash::ERR	errCATHash	= g_cathash.ErrRetrieveEntry( &lockCATHash, &entryCATHash );
	const BOOL			fFound		= ( CATHash::errSuccess == errCATHash );
	if ( fFound )
		{
		Assert( pfcbNil != entryCATHash.m_pfcb );
		*ppgnoTableFDP = entryCATHash.m_pfcb->PgnoFDP();
		*pobjidTable = entryCATHash.m_pfcb->ObjidFDP();
		}
	else
		{
		Assert( CATHash::errEntryNotFound == errCATHash );
		}

	//	unlock the key
	g_cathash.ReadUnlockKey( &lockCATHash );

	return fFound;
	}


//	try to insert an entry into the catalog hash-table
//	ignore the result -- at best, we will get it in there or it will already be there
//						 at worst, we will get out-of-memory and the user will just have
//							 to incur the penalty for seeking every time

VOID CATHashIInsert( FCB *pfcb, CHAR *const szTable )
	{

	//	try to add the new pgnoFDP / objidFDP to the
	//	catalog hash-table; if we fail, it means that
	//	someone else was racing with us to insert
	//	the entry and won (assert that the entry matches)

	CATHashKey		keyCATHash( pfcb->Ifmp(), szTable );
	CATHashEntry	entryCATHash( pfcb );
	CATHash::CLock	lockCATHash;
	BOOL			fProceedWithInsert = fTrue;
	BOOL			fInitialized;

	Assert( pfcb != NULL );
	// we never put temp tables in catalog hash
	Assert( pfcb->FTypeTable() );

	fInitialized = pfcb->FInitialized();

	//	lock the key

	g_cathash.WriteLockKey( keyCATHash, &lockCATHash );

	//	insert the entry

	if ( fInitialized )
		{
		entryCATHash.m_pfcb->EnterDML();
		fProceedWithInsert = !entryCATHash.m_pfcb->FDeletePending();
		}

	if ( fProceedWithInsert )
		{
		const CATHash::ERR errCATHash = g_cathash.ErrInsertEntry( &lockCATHash, entryCATHash );

//#ifdef DEBUG
#if 0	//	UNDONE: need to handle EnterDML problems
		if ( errCATHash == CATHash::errKeyDuplicate )
			{

			//	the entry was already there

			//	verify that it matches the data we just got

			CATHash::ERR errCATHashT = g_cathash.ErrRetrieveEntry( &lockCATHash, &entryCATHash );
			Assert( errCATHashT == CATHash::errSuccess );

	//	entryCATHash.m_pfcb->EnterDML();
			Assert( entryCATHash.m_uiHashIfmpName == UiHashIfmpName( entryCATHash.m_pfcb->Ifmp(), entryCATHash.m_pfcb->Ptdb()->SzTableName() ) );
			Assert( UtilCmpName( entryCATHash.m_pfcb->Ptdb()->SzTableName(), keyCATHash.m_pszName ) == 0 );
	//	entryCATHash.m_pfcb->LeaveDML();
			Assert( entryCATHash.m_pfcb == pfcb );
			Assert( entryCATHash.m_pgnoFDPDBG == pfcb->PgnoFDP() );
			Assert( entryCATHash.m_objidFDPDBG == pfcb->ObjidFDP() );
			}
		else
			{
			Assert( errCATHash == CATHash::errSuccess );
			}
#endif
		}

	if ( fInitialized )
		entryCATHash.m_pfcb->LeaveDML();

	//	unlock the key

	g_cathash.WriteUnlockKey( &lockCATHash );
	}



//	delete an entry from the catalog hash-table
//	ignore the results -- at best, we will delete it
//						  at worst, it will already be gone

VOID CATHashIDelete( FCB *pfcb, CHAR *const szTable )
	{

	//	try to add the new pgnoFDP / objidFDP to the
	//	catalog hash-table; if we fail, it means that
	//	someone else was racing with us to insert
	//	the entry and won (assert that the entry matches)

	CATHashKey		keyCATHash( pfcb->Ifmp(), szTable );
	CATHash::CLock	lockCATHash;

	//	lock the key

	g_cathash.WriteLockKey( keyCATHash, &lockCATHash );

	//	delete the entry (ignore the result)

	(VOID)g_cathash.ErrDeleteEntry( &lockCATHash );

	//	unlock the key

	g_cathash.WriteUnlockKey( &lockCATHash );
	}


#ifdef DEBUG

//	make sure all entries in the catalog hash pertaining to the given IFMP are gone

VOID CATHashAssertCleanIfmp( IFMP ifmp )
	{
	CATHash::CLock	lockCATHash;
	CATHash::ERR	errCATHash;
	CATHashEntry	entryCATHash;

	//	start a scan

	g_cathash.BeginHashScan( &lockCATHash );

	while ( ( errCATHash = g_cathash.ErrMoveNext( &lockCATHash ) ) != CATHash::errNoCurrentEntry )
		{

		//	fetch the current entry

		errCATHash = g_cathash.ErrRetrieveEntry( &lockCATHash, &entryCATHash );
		Assert( errCATHash == CATHash::errSuccess );

		//	ifmp should not match

		Assert( pfcbNil != entryCATHash.m_pfcb );
		Assert( entryCATHash.m_pfcb->Ifmp() != ifmp );
		}

	//	complete the scan

	g_cathash.EndHashScan( &lockCATHash );
	}


//	make sure all entries in the catalog hash are gone

VOID CATHashAssertClean()
	{
	CATHash::CLock	lockCATHash;
	CATHash::ERR	errCATHash;
	CATHashEntry	entryCATHash;

	//	start a scan

	g_cathash.BeginHashScan( &lockCATHash );
	errCATHash = g_cathash.ErrMoveNext( &lockCATHash );
	AssertSz( errCATHash == CATHash::errNoCurrentEntry, "Catalog hash-table was not empty during shutdown!" );
	while ( errCATHash != CATHash::errNoCurrentEntry )
		{

		//	fetch the current entry

		errCATHash = g_cathash.ErrRetrieveEntry( &lockCATHash, &entryCATHash );
		Assert( errCATHash == CATHash::errSuccess );

		//	move to the next entry

		errCATHash = g_cathash.ErrMoveNext( &lockCATHash );
		}

	//	complete the scan

	g_cathash.EndHashScan( &lockCATHash );
	}

#endif	//	DEBUG


/*=================================================================
ErrCATCreate

Description:

	Called from ErrIsamCreateDatabase; creates all system tables

Parameters:

	PIB		*ppib		; PIB of user
	IFMP	ifmp		; ifmp of database that needs tables

Return Value:

	whatever error it encounters along the way

=================================================================*/

INLINE ERR ErrCATICreateCatalogIndexes(
	PIB			*ppib,
	const IFMP	ifmp,
	OBJID		*pobjidNameIndex,
	OBJID		*pobjidRootObjectsIndex )
	{
	ERR			err;
	FUCB		*pfucbTableExtent;
	PGNO		pgnoIndexFDP;
	FCB 		*pfcb = pfcbNil;

	//	don't maintain secondary indexes on the shadow catalog.

	// Open cursor for space navigation
	CallR( ErrDIROpen( ppib, pgnoFDPMSO, ifmp, &pfucbTableExtent ) );

	pfcb = pfucbTableExtent->u.pfcb;

	Assert( pfucbTableExtent != pfucbNil );
	Assert( !FFUCBVersioned( pfucbTableExtent ) );	// Verify won't be deferred closed.
	Assert( pfcb != pfcbNil );
	Assert( !pfcb->FInitialized() );
	Assert( pfcb->Pidb() == pidbNil );

	//	complete the initialization of the FCB

	pfcb->Lock();
	pfcb->CreateComplete();
	pfcb->Unlock();

	Call( ErrDIRCreateDirectory(
				pfucbTableExtent,
				(CPG)0,
				&pgnoIndexFDP,
				pobjidNameIndex,
				CPAGE::fPageIndex,
				fSPMultipleExtent|fSPUnversionedExtent ) );
	Assert( pgnoIndexFDP == pgnoFDPMSO_NameIndex );

	Call( ErrDIRCreateDirectory(
				pfucbTableExtent,
				(CPG)0,
				&pgnoIndexFDP,
				pobjidRootObjectsIndex,
				CPAGE::fPageIndex,
				fSPMultipleExtent|fSPUnversionedExtent ) );
	Assert( pgnoIndexFDP == pgnoFDPMSO_RootObjectIndex );

HandleError:
	Assert( pfcb->FInitialized() );
	Assert( pfcb->WRefCount() == 1 );

	//	force the FCB to be uninitialized so it will be purged by DIRClose

	pfcb->Lock();
	pfcb->CreateComplete( errFCBUnusable );
	pfcb->Unlock();

	//	verify that this FUCB won't be defer-closed

	Assert( !FFUCBVersioned( pfucbTableExtent ) );

	//	close the FUCB

	DIRClose( pfucbTableExtent );

	return err;
	}


// Returns the FID of a column in a catalog table.
INLINE FID ColumnidCATColumn( const CHAR *szColumnName )
	{
	COLUMNID	columnid	= 0;
	UINT		i;

	for ( i = 0; i < cColumnsMSO; i++ )
		{
		if ( 0 == UtilCmpName( rgcdescMSO[i].szColName, szColumnName ) )
			{
			Assert( !FCOLUMNIDTemplateColumn( rgcdescMSO[i].columnid ) );
			columnid = rgcdescMSO[i].columnid;
			break;
			}
		}

	Assert( i < cColumnsMSO );
	Assert( columnid > 0 );

	return FID( columnid );
	}


//  ================================================================
ERR ErrCATIRetrieveTaggedColumn(
	FUCB				* const pfucb,
	const FID			fid,
	const ULONG 		itagSequence,
	const DATA&			dataRec,
	BYTE				* const pbRet,
	const ULONG			cbRetMax,
	ULONG				* const pcbRetActual )
//  ================================================================
//
//  Retrieve a tagged column, possibly going to the LV tree
//  Takes a latched page and leaves the page latched. Because the
//  page is unlatched and relatched any pointers held into the page
//  may be invalidated
//
//-
	{
	ERR err;

	Assert( FTaggedFid( fid ) );
	Assert( 1 == itagSequence );
	Assert( Pcsr( pfucb )->FLatched() );

	DATA dataRetrieved;
	Call( ErrRECIRetrieveTaggedColumn(
				pfucb->u.pfcb,
				ColumnidOfFid( fid, fFalse ),
				itagSequence,
				dataRec,
				&dataRetrieved ) );
	Assert( Pcsr( pfucb )->FLatched() );
	Assert( wrnRECUserDefinedDefault != err );
	Assert( wrnRECSeparatedSLV != err );
	Assert( wrnRECIntrinsicSLV != err );

	Assert( wrnRECLongField != err );
	if ( wrnRECSeparatedLV == err )
		{
		Assert( sizeof(LID) == dataRetrieved.Cb() );

		Call( ErrRECIRetrieveSeparatedLongValue(
					pfucb,
					dataRetrieved,
					fTrue,
					0,
					pbRet,
					cbRetMax,
					pcbRetActual,
					NO_GRBIT ) );
		Assert( JET_wrnColumnNull != err );

		//	must re-latch record
		Assert( !Pcsr( pfucb )->FLatched() );
		const ERR errT = ErrDIRGet( pfucb );
		err = ( errT < 0 ) ? errT : err;
		}
	else if( wrnRECIntrinsicLV == err )
		{
		*pcbRetActual = dataRetrieved.Cb();
		UtilMemCpy( pbRet, dataRetrieved.Pv(), min( cbRetMax, dataRetrieved.Cb() ) );
		err = ( cbRetMax >= dataRetrieved.Cb() ) ? JET_errSuccess : ErrERRCheck( JET_wrnBufferTruncated );
		}
	else
		{
		Assert( JET_wrnColumnNull == err );
		*pcbRetActual = 0;
		}

HandleError:
	Assert( err < 0 || Pcsr( pfucb )->FLatched() );

	return err;
	}


/*	Catalog-retrieval routines for system tables.
/*
/*	This code was lifted from the key parsing code in ErrIsamCreateIndex(), with
/*	optimisations for assumptions made for key strings of system table indexes.
/**/
LOCAL BYTE CfieldCATKeyString( CHAR *szKey, IDXSEG* rgidxseg )
	{
	CHAR	*pch;
	ULONG	cfield = 0;

	for ( pch = szKey; *pch != '\0'; pch += strlen( pch ) + 1 )
		{
		/*	Assume the first character of each component is a '+' (this is
		/*	specific to system table index keys).  In general, this may also
		/*	be a '-' or nothing at all (in which case '+' is assumed), but we
		/*	don't use descending indexes for system tables and we'll assume we
		/*	know enough to put '+' characters in our key string.
		/**/
		Assert( *pch == '+' );
		pch++;

		rgidxseg[cfield].ResetFlags();
		rgidxseg[cfield].SetFid( FidOfColumnid( ColumnidCATColumn( pch ) ) );
		Assert( !rgidxseg[cfield].FTemplateColumn() );
		Assert( !rgidxseg[cfield].FDescending() );
		Assert( !rgidxseg[cfield].FMustBeNull() );
		cfield++;
		}


	// Verify the key-field array will fit in the IDB.
	Assert( cfield > 0 );
	Assert( cfield <= cIDBIdxSegMax );

	return (BYTE)cfield;
	}

ERR ErrCATPopulateCatalog(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
	const PGNO	pgnoFDP,
	const OBJID	objidTable,
	const CHAR	*szTableName,
	const CPG	cpgInitial,
	const BOOL  fExpectKeyDuplicateErrors )
	{
	ERR			err;
	UINT		i;
	FIELD		field;

	field.ibRecordOffset	= ibRECStartFixedColumns;	// record offset will be calculated at catalog open time
	field.cp				= usEnglishCodePage;

	//	must insert MSysObjects record to prevent clients from
	//	creating a table named "MSysObjects".
	err = ErrCATAddTable(
				ppib,
				pfucbCatalog,
				pgnoFDP,
				objidTable,
				szTableName,
				NULL,
				cpgInitial,
				ulFILEDefaultDensity,
				JET_bitObjectSystem|JET_bitObjectTableFixedDDL );
	if( JET_errTableDuplicate == err && fExpectKeyDuplicateErrors )
		{
		err = JET_errSuccess;
		}
	Call( err );

	for ( i = 0; i < cColumnsMSO; i++ )
		{
		field.coltyp	= FIELD_COLTYP( rgcdescMSO[i].coltyp );
		field.cbMaxLen 	= UlCATColumnSize( field.coltyp, 0, NULL );

		//	only supported flag for system table columns is JET_bitColumnNotNULL
		field.ffield	= 0;
		Assert( 0 == rgcdescMSO[i].grbit
				|| JET_bitColumnNotNULL == rgcdescMSO[i].grbit
				|| JET_bitColumnTagged == rgcdescMSO[i].grbit );
		if ( JET_bitColumnNotNULL == rgcdescMSO[i].grbit )
			FIELDSetNotNull( field.ffield );

		Assert( ibRECStartFixedColumns == field.ibRecordOffset );	//	offset will be fixed up at catalog open time
		Assert( usEnglishCodePage == field.cp );

		err = ErrCATAddTableColumn(
				ppib,
				pfucbCatalog,
				objidTable,
				rgcdescMSO[i].szColName,
				rgcdescMSO[i].columnid,
				&field,
				NULL,
				0,
				NULL,
				NULL,
				0 );
		if( JET_errColumnDuplicate == err && fExpectKeyDuplicateErrors )
			{
			err = JET_errSuccess;
			}
		Call( err );
		}

HandleError:
	return err;
	}


//  ================================================================
ERR ErrCATUpdate( PIB * const ppib, const IFMP ifmp )
//  ================================================================
//
//  Adds new catalog records to an old format catalog. We may have
//  crashed before updating the version during a previous upgrade
//  so be prepared for the records to already exist
//
//-
	{
	ERR		err;
	FUCB	* pfucb	= pfucbNil;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	Call( ErrFILEOpenTable(
			ppib,
			ifmp,
			&pfucb,
			szMSO,
			JET_bitTableDenyRead ) );

	Call( ErrCATPopulateCatalog(
			ppib,
			pfucb,
			pgnoFDPMSO,
			objidFDPMSO,
			szMSO,
			cpgMSOInitial,
			fTrue ) );
	Call( ErrCATPopulateCatalog(
			ppib,
			pfucb,
			pgnoFDPMSOShadow,
			objidFDPMSOShadow,
			szMSOShadow,
			cpgMSOShadowInitial,
			fTrue ) );

HandleError:
	if( pfucbNil != pfucb )
		{
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}
	err = ErrDIRCommitTransaction( ppib, NO_GRBIT );
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


ERR ErrREPAIRCATCreate(
	PIB *ppib,
	const IFMP ifmp,
	const OBJID	objidNameIndex,
	const OBJID	objidRootObjectsIndex,
	const BOOL	fInRepair )
	{
	ERR		err;
	FUCB	*pfucb				= pfucbNil;

	IDB		idb;

	//	open table in exclusive mode, for output parameter
	//
	CallR( ErrFILEOpenTable(
			ppib,
			ifmp,
			&pfucb,
			szMSO,
			JET_bitTableDenyRead ) );
	Assert( pfucbNil != pfucb );

	Call( ErrCATPopulateCatalog(
				ppib,
				pfucb,
				pgnoFDPMSO,
				objidFDPMSO,
				szMSO,
				cpgMSOInitial,
				fInRepair ) ); //fFalse by default (non-repair situation)

	Call( ErrCATPopulateCatalog(
				ppib,
				pfucb,
				pgnoFDPMSOShadow,
				objidFDPMSOShadow,
				szMSOShadow,
				cpgMSOShadowInitial,
				fInRepair ) ); //fFalse by default (non-repair situation)

	idb.SetLcid( lcidDefault );
	idb.SetDwLCMapFlags( dwLCMapFlagsDefault );
	idb.SetCidxsegConditional( 0 );		//  UNDONE: catalog indexes cannot be conditional

	idb.SetCidxseg( CfieldCATKeyString( rgidescMSO[0].szIdxKeys, idb.rgidxseg ) );
	idb.SetFlagsFromGrbit( rgidescMSO[0].grbit );
	idb.SetCbVarSegMac( JET_cbPrimaryKeyMost );

	err = ErrCATAddTableIndex(
					ppib,
					pfucb,
					objidFDPMSO,
					szMSOIdIndex,
					pgnoFDPMSO,
					objidFDPMSO,
					&idb,
					idb.rgidxseg,
					idb.rgidxsegConditional,
					ulFILEDefaultDensity );
	if( fInRepair && JET_errIndexDuplicate == err )
		{
		err = JET_errSuccess;
		}
	else
		{
		Call( err );
		}

	err = ErrCATAddTableIndex(
					ppib,
					pfucb,
					objidFDPMSOShadow,
					szMSOIdIndex,
					pgnoFDPMSOShadow,
					objidFDPMSOShadow,
					&idb,
					idb.rgidxseg,
					idb.rgidxsegConditional,
					ulFILEDefaultDensity );
	if( fInRepair && JET_errIndexDuplicate == err )
		{
		err = JET_errSuccess;
		}
	else
		{
		Call( err );
		}

	idb.SetCbVarSegMac( JET_cbSecondaryKeyMost );

	idb.SetCidxseg( CfieldCATKeyString( rgidescMSO[1].szIdxKeys, idb.rgidxseg ) );
	idb.SetFlagsFromGrbit( rgidescMSO[1].grbit );
	err = ErrCATAddTableIndex(
					ppib,
					pfucb,
					objidFDPMSO,
					szMSONameIndex,
					pgnoFDPMSO_NameIndex,
					objidNameIndex,
					&idb,
					idb.rgidxseg,
					idb.rgidxsegConditional,
					ulFILEDefaultDensity );
	if( fInRepair && JET_errIndexDuplicate == err )
		{
		err = JET_errSuccess;
		}
	else
		{
		Call( err );
		}

	idb.SetCidxseg( CfieldCATKeyString( rgidescMSO[2].szIdxKeys, idb.rgidxseg ) );
	idb.SetFlagsFromGrbit( rgidescMSO[2].grbit );
	err = ErrCATAddTableIndex(
					ppib,
					pfucb,
					objidFDPMSO,
					szMSORootObjectsIndex,
					pgnoFDPMSO_RootObjectIndex,
					objidRootObjectsIndex,
					&idb,
					idb.rgidxseg,
					idb.rgidxsegConditional,
					ulFILEDefaultDensity );
	if( fInRepair && JET_errIndexDuplicate == err )
		{
		err = JET_errSuccess;
		}
	else
		{
		Call( err );
		}

	Assert( pfucb->u.pfcb->FInitialized() );
	Assert( pfucb->u.pfcb->FTypeTable() );
	Assert( pfucb->u.pfcb->FPrimaryIndex() );

	err = JET_errSuccess;

HandleError:
	if ( pfucbNil != pfucb )
		{
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}

	return err;
	}


ERR ErrCATCreate( PIB *ppib, const IFMP ifmp )
	{
	ERR		err;
	FUCB	*pfucb				= pfucbNil;
	PGNO	pgnoFDP;
	PGNO	pgnoFDPShadow;
	OBJID	objidFDP;
	OBJID	objidFDPShadow;
	OBJID	objidNameIndex;
	OBJID	objidRootObjectsIndex;

	FMP::AssertVALIDIFMP( ifmp );
	Assert( dbidTemp != rgfmp[ifmp].Dbid() );

	//	no transaction/versioning needed because if this fails,
	//	the entire createdb will fail
	Assert( 0 == ppib->level );
	Assert( rgfmp[ifmp].FCreatingDB() );

	CheckPIB( ppib );
	CheckDBID( ppib, ifmp );

	//	allocate cursor
	//
	CallR( ErrDIROpen( ppib, pgnoSystemRoot, ifmp, &pfucb ) );
	Assert( pfucbNil != pfucb );
	Assert( cpgMSOInitial > cpgTableMin );
	Call( ErrDIRCreateDirectory(
				pfucb,
				cpgMSOInitial,
				&pgnoFDP,
				&objidFDP,
				CPAGE::fPagePrimary,
				fSPMultipleExtent|fSPUnversionedExtent ) );
	Call( ErrDIRCreateDirectory(
				pfucb,
				cpgMSOShadowInitial,
				&pgnoFDPShadow,
				&objidFDPShadow,
				CPAGE::fPagePrimary,
				fSPMultipleExtent|fSPUnversionedExtent ) );
	DIRClose( pfucb );
	pfucb = pfucbNil;

	Assert( FCATSystemTable( pgnoFDP ) );
	Assert( PgnoCATTableFDP( szMSO ) == pgnoFDP );
	Assert( pgnoFDPMSO == pgnoFDP );
	Assert( objidFDPMSO == objidFDP );

	Assert( FCATSystemTable( pgnoFDPShadow ) );
	Assert( PgnoCATTableFDP( szMSOShadow ) == pgnoFDPShadow );
	Assert( pgnoFDPMSOShadow == pgnoFDPShadow );
	Assert( objidFDPMSOShadow == objidFDPShadow );

	CallR( ErrCATICreateCatalogIndexes( ppib, ifmp, &objidNameIndex, &objidRootObjectsIndex ) );

	Call( ErrREPAIRCATCreate( ppib, ifmp, objidNameIndex, objidRootObjectsIndex, fFalse ) );

	err = JET_errSuccess;

HandleError:
	if ( pfucbNil != pfucb )
		{
		DIRClose( pfucb );
		}

	return err;
	}


/*=================================================================
ErrCATInsert

Description:

	Inserts a record into a system table when new tables, indexes,
	or columns are added to the database.

Parameters:

	PIB		*ppib;
	IFMP   	ifmp;
	INT		itable;
	DATA   	rgdata[];

Return Value:

	whatever error it encounters along the way

=================================================================*/

INLINE ERR ErrCATIInsert(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
	DATA		rgdata[],
	const UINT	iHighestFixedToSet )
	{
	ERR			err;
	TDB			* const ptdbCatalog		= pfucbCatalog->u.pfcb->Ptdb();

	CallR( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepInsert ) );

	//	set highest fixed column first, to eliminate calls to memmove()
	Assert( iHighestFixedToSet > 0 );
	Assert( iHighestFixedToSet < cColumnsMSO );
	Assert( FCOLUMNIDFixed( rgcdescMSO[iHighestFixedToSet].columnid ) );
	Assert( rgdata[iHighestFixedToSet].Cb() > 0 );
	CallS( ErrRECISetFixedColumn(
				pfucbCatalog,
				ptdbCatalog,
				rgcdescMSO[iHighestFixedToSet].columnid,
				rgdata+iHighestFixedToSet ) );

	for ( UINT i = 0; i < cColumnsMSO; i++ )
		{
		if ( rgdata[i].Cb() != 0 )
			{
			Assert( rgdata[i].Cb() > 0 );

			if ( FCOLUMNIDFixed( rgcdescMSO[i].columnid ) )
				{
				Assert( i <= iHighestFixedToSet );
				if ( iHighestFixedToSet != i )
					{
					CallS( ErrRECISetFixedColumn(
								pfucbCatalog,
								ptdbCatalog,
								rgcdescMSO[i].columnid,
								rgdata+i ) );
					}
				}
			else if( FCOLUMNIDVar( rgcdescMSO[i].columnid ) )
				{
				Assert( i != iHighestFixedToSet );
				CallS( ErrRECISetVarColumn(
							pfucbCatalog,
							ptdbCatalog,
							rgcdescMSO[i].columnid,
							rgdata+i ) );
				}
			else
				{
				Assert( FCOLUMNIDTagged( rgcdescMSO[i].columnid ) );
				Assert( i != iHighestFixedToSet );
				//  currently all tagged fields must be Long-Values
				//  call ErrRECISetTaggedColumn if the column isn't
				Assert( rgcdescMSO[i].coltyp == JET_coltypLongText
						|| rgcdescMSO[i].coltyp == JET_coltypLongBinary );
				CallS( ErrRECSetLongField(
							pfucbCatalog,
							rgcdescMSO[i].columnid,
							0,
							rgdata+i ) );
				}
			}
		}

	/*	insert record into system table
	/**/
	err = ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT );
	if( err < 0 )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepCancel ) );
		}
	return err;
	}

LOCAL ERR ErrCATInsert(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
	DATA		rgdata[],
	const UINT	iHighestFixedToSet )
	{
	ERR			err;

	//	ensure we're in a transaction, so that on failure, updates to both
	//	catalog and its shadow are rolled back
	Assert( ppib->level > 0
		|| rgfmp[pfucbCatalog->ifmp].FCreatingDB() );

	CallR( ErrCATIInsert( ppib, pfucbCatalog, rgdata, iHighestFixedToSet ) );

	if ( !rgfmp[pfucbCatalog->u.pfcb->Ifmp()].FShadowingOff() )
		{
		FUCB	*pfucbShadow;
		CallR( ErrCATOpen( ppib, pfucbCatalog->u.pfcb->Ifmp(), &pfucbShadow, fTrue ) );
		Assert( pfucbNil != pfucbShadow );

		err = ErrCATIInsert( ppib, pfucbShadow, rgdata, iHighestFixedToSet );

		CallS( ErrCATClose( ppib, pfucbShadow ) );
		}

	return err;
	}


ERR ErrCATAddTable(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const PGNO		pgnoTableFDP,
	const OBJID		objidTable,
	const CHAR		*szTableName,
	const CHAR		*szTemplateTableName,
	const ULONG		ulPages,
	const ULONG		ulDensity,
	const ULONG		ulFlags )
	{
	DATA			rgdata[idataMSOMax];
	const SYSOBJ	sysobj				= sysobjTable;
	const BYTE		bTrue				= 0xff;

	Assert( objidTable > objidSystemRoot );

	//	must zero out to ensure unused fields are ignored
	memset( rgdata, 0, sizeof(rgdata) );

	rgdata[iMSO_ObjidTable].SetPv( 		(BYTE *)&objidTable );
	rgdata[iMSO_ObjidTable].SetCb(		sizeof(objidTable) );

	rgdata[iMSO_Type].SetPv(			(BYTE *)&sysobj );
	rgdata[iMSO_Type].SetCb(			sizeof(sysobj) );

	rgdata[iMSO_Id].SetPv(				(BYTE *)&objidTable );
	rgdata[iMSO_Id].SetCb(				sizeof(objidTable) );

	rgdata[iMSO_Name].SetPv(			(BYTE *)szTableName );
	rgdata[iMSO_Name].SetCb(			strlen(szTableName) );

	rgdata[iMSO_PgnoFDP].SetPv(			(BYTE *)&pgnoTableFDP );
	rgdata[iMSO_PgnoFDP].SetCb(			sizeof(pgnoTableFDP) );

	rgdata[iMSO_SpaceUsage].SetPv(		(BYTE *)&ulDensity );
	rgdata[iMSO_SpaceUsage].SetCb(		sizeof(ulDensity) );

	rgdata[iMSO_Flags].SetPv(			(BYTE *)&ulFlags );
	rgdata[iMSO_Flags].SetCb(			sizeof(ulFlags) );

	rgdata[iMSO_Pages].SetPv(			(BYTE *)&ulPages );
	rgdata[iMSO_Pages].SetCb(			sizeof(ulPages) );
	Assert( 0 == rgdata[iMSO_Stats].Cb() );

	rgdata[iMSO_RootFlag].SetPv(		(BYTE *)&bTrue );
	rgdata[iMSO_RootFlag].SetCb(		sizeof(bTrue) );

	if ( NULL != szTemplateTableName )
		{
		rgdata[iMSO_TemplateTable].SetPv( (BYTE *)szTemplateTableName );
		rgdata[iMSO_TemplateTable].SetCb( strlen(szTemplateTableName) );
		}
	else
		{
		Assert( 0 == rgdata[iMSO_TemplateTable].Cb() );
		}

	ERR	err = ErrCATInsert( ppib, pfucbCatalog, rgdata, iMSO_RootFlag );
	if ( JET_errKeyDuplicate == err )
		{
		if ( 0 == strcmp( szTableName, "MSysDefrag1" ) )
			{
			FireWall();
			}
		err = ErrERRCheck( JET_errTableDuplicate );
		}

	return err;
	}


ERR ErrCATAddTableColumn(
	PIB					*ppib,
	FUCB				*pfucbCatalog,
	const OBJID			objidTable,
	const CHAR			*szColumnName,
	COLUMNID			columnid,
	const FIELD			*pfield,
	const VOID			*pvDefault,
	const ULONG			cbDefault,
	const CHAR			* const szCallback,
	const VOID			* const pvUserData,
	const ULONG			cbUserData )
	{
	DATA				rgdata[idataMSOMax];
	UINT				iHighestFixedToSet;
	const SYSOBJ		sysobj				= sysobjColumn;
	const JET_COLTYP	coltyp				= pfield->coltyp;
	const ULONG			ulCodePage			= pfield->cp;

	//	filter out flags that shouldn't be persisted
	Assert( !FFIELDDeleted( pfield->ffield ) );
	const ULONG			ulFlags				= ( pfield->ffield & ffieldPersistedMask );

	Assert( objidTable > objidSystemRoot );


	//	must zero out to ensure unused fields are ignored
	memset( rgdata, 0, sizeof(rgdata) );

	rgdata[iMSO_ObjidTable].SetPv(		(BYTE *)&objidTable );
	rgdata[iMSO_ObjidTable].SetCb(		sizeof(objidTable) );

	rgdata[iMSO_Type].SetPv(			(BYTE *)&sysobj );
	rgdata[iMSO_Type].SetCb(			sizeof(sysobj) );

	Assert( FCOLUMNIDValid( columnid ) );
	Assert( !FCOLUMNIDTemplateColumn( columnid )
		|| FFIELDTemplateColumnESE98( pfield->ffield ) );
	COLUMNIDResetFTemplateColumn( columnid );
	rgdata[iMSO_Id].SetPv(				(BYTE *)&columnid );
	rgdata[iMSO_Id].SetCb(				sizeof(columnid) );

	rgdata[iMSO_Name].SetPv(			(BYTE *)szColumnName );
	rgdata[iMSO_Name].SetCb(			strlen(szColumnName) );

	rgdata[iMSO_Coltyp].SetPv(			(BYTE *)&coltyp );
	rgdata[iMSO_Coltyp].SetCb(			sizeof(coltyp) );

	rgdata[iMSO_SpaceUsage].SetPv(		(BYTE *)&pfield->cbMaxLen );
	rgdata[iMSO_SpaceUsage].SetCb(		sizeof(pfield->cbMaxLen) );

	rgdata[iMSO_Flags].SetPv(			(BYTE *)&ulFlags );
	rgdata[iMSO_Flags].SetCb(			sizeof(ulFlags) );

	rgdata[iMSO_Localization].SetPv(	(BYTE *)&ulCodePage );
	rgdata[iMSO_Localization].SetCb(	sizeof(ulCodePage) );

	rgdata[iMSO_Callback].SetPv(		(BYTE*)szCallback );
	rgdata[iMSO_Callback].SetCb(		( szCallback ? strlen(szCallback) : 0 ) );

	rgdata[iMSO_DefaultValue].SetPv(	(BYTE *)pvDefault );
	rgdata[iMSO_DefaultValue].SetCb(	cbDefault );

	rgdata[iMSO_CallbackData].SetPv(	(BYTE*)pvUserData );
	rgdata[iMSO_CallbackData].SetCb(	cbUserData );

	if ( FCOLUMNIDFixed( columnid ) )
		{
		Assert( pfield->ibRecordOffset >= ibRECStartFixedColumns );
		rgdata[iMSO_RecordOffset].SetPv( (BYTE *)&pfield->ibRecordOffset );
		rgdata[iMSO_RecordOffset].SetCb( sizeof(pfield->ibRecordOffset) );
		iHighestFixedToSet = iMSO_RecordOffset;
		}
	else
		{
		// Don't need to persist record offsets for var/tagged columns.
		Assert( FCOLUMNIDVar( columnid ) || FCOLUMNIDTagged( columnid ) );
		Assert( 0 == rgdata[iMSO_RecordOffset].Cb() );
		iHighestFixedToSet = iMSO_Localization;
		}

	ERR	err = ErrCATInsert( ppib, pfucbCatalog, rgdata, iHighestFixedToSet );
	if ( JET_errKeyDuplicate == err )
		err = ErrERRCheck( JET_errColumnDuplicate );

	return err;
	}


ERR ErrCATAddTableIndex(
	PIB					*ppib,
	FUCB				*pfucbCatalog,
	const OBJID			objidTable,
	const CHAR			*szIndexName,
	const PGNO			pgnoIndexFDP,
	const OBJID			objidIndex,
	const IDB			*pidb,
	const IDXSEG* const	rgidxseg,
	const IDXSEG* const	rgidxsegConditional,
	const ULONG			ulDensity )
	{
	ERR					err = JET_errSuccess;
	DATA				rgdata[idataMSOMax];
	LE_IDXFLAG			le_idxflag;
	const SYSOBJ		sysobj				= sysobjIndex;

	Assert( objidTable > objidSystemRoot );
	Assert( objidIndex > objidSystemRoot );

	//	objids are monotonically increasing, so an index should
	//	always have higher objid than its table
	Assert( ( pidb->FPrimary() && objidIndex == objidTable )
		|| ( !pidb->FPrimary() && objidIndex > objidTable ) );


	//	must zero out to ensure unused fields are ignored
	memset( rgdata, 0, sizeof(rgdata) );

	rgdata[iMSO_ObjidTable].SetPv(		(BYTE *)&objidTable );
	rgdata[iMSO_ObjidTable].SetCb(		sizeof(objidTable) );

	rgdata[iMSO_Type].SetPv(			(BYTE *)&sysobj );
	rgdata[iMSO_Type].SetCb(			sizeof(sysobj) );

	rgdata[iMSO_Id].SetPv(				(BYTE *)&objidIndex );
	rgdata[iMSO_Id].SetCb(				sizeof(objidIndex) );

	rgdata[iMSO_Name].SetPv(			(BYTE *)szIndexName );
	rgdata[iMSO_Name].SetCb(			strlen(szIndexName) );

	rgdata[iMSO_PgnoFDP].SetPv(			(BYTE *)&pgnoIndexFDP );
	rgdata[iMSO_PgnoFDP].SetCb(			sizeof(pgnoIndexFDP) );

	rgdata[iMSO_SpaceUsage].SetPv(		(BYTE *)&ulDensity );
	rgdata[iMSO_SpaceUsage].SetCb(		sizeof(ulDensity) );

	le_idxflag.fidb = pidb->FPersistedFlags();
	le_idxflag.fIDXFlags = fIDXExtendedColumns;

	//	Hack on this field: SetColumn() will convert the fixed
	//	columns. So convert it here so that later it can be
	//	converted back to current value.
	LONG		l			= *(LONG *)&le_idxflag;
	l = ReverseBytesOnBE( l );

	rgdata[iMSO_Flags].SetPv(			(BYTE *)&l );
	rgdata[iMSO_Flags].SetCb(			sizeof(l) );

	LCID		lcid		= pidb->Lcid();
	rgdata[iMSO_Localization].SetPv(	(BYTE *)&lcid );
	rgdata[iMSO_Localization].SetCb(	sizeof(lcid) );

	DWORD		dwMapFlags	= pidb->DwLCMapFlags();
	rgdata[iMSO_LCMapFlags].SetPv(		(BYTE *)&dwMapFlags );
	rgdata[iMSO_LCMapFlags].SetCb(		sizeof(dwMapFlags) );

	BYTE		*pbidxseg;
	LE_IDXSEG	le_rgidxseg[ JET_ccolKeyMost ];
	LE_IDXSEG	le_rgidxsegConditional[ JET_ccolKeyMost ];

	if ( FHostIsLittleEndian() )
		{
		pbidxseg = (BYTE *)rgidxseg;

#ifdef DEBUG
		for ( UINT iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
			{
			Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );
			}
#endif
		}
	else
		{
		for ( UINT iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
			{
			Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );

			//	Endian conversion
			le_rgidxseg[ iidxseg ] = rgidxseg[iidxseg];
			}

		pbidxseg = (BYTE *)le_rgidxseg;
		}

	rgdata[iMSO_KeyFldIDs].SetPv( pbidxseg );
	rgdata[iMSO_KeyFldIDs].SetCb( pidb->Cidxseg() * sizeof(IDXSEG) );

	if ( FHostIsLittleEndian() )
		{
		pbidxseg = (BYTE *)rgidxsegConditional;

#ifdef DEBUG
		for ( UINT iidxseg = 0; iidxseg < pidb->CidxsegConditional(); iidxseg++ )
			{
			//	verify no longer persisting old format
			Assert( FCOLUMNIDValid( rgidxsegConditional[iidxseg].Columnid() ) );
			}
#endif
		}
	else
		{
		for ( UINT iidxseg = 0; iidxseg < pidb->CidxsegConditional(); iidxseg++ )
			{
			Assert( FCOLUMNIDValid( rgidxsegConditional[iidxseg].Columnid() ) );

			//	Endian conversion
			le_rgidxsegConditional[ iidxseg ] = rgidxsegConditional[iidxseg];
			}
		pbidxseg = (BYTE *)le_rgidxsegConditional;
		}

	rgdata[iMSO_ConditionalColumns].SetPv( 	pbidxseg );
	rgdata[iMSO_ConditionalColumns].SetCb( 	pidb->CidxsegConditional() * sizeof(IDXSEG) );

	UnalignedLittleEndian<USHORT>	le_cbVarSegMac = pidb->CbVarSegMac();
	if ( pidb->CbVarSegMac() < KEY::CbKeyMost( pidb->FPrimary() ) )
		{
		rgdata[iMSO_VarSegMac].SetPv( (BYTE *)&le_cbVarSegMac );
		rgdata[iMSO_VarSegMac].SetCb( sizeof(le_cbVarSegMac) );
		}
	else
		{
		Assert( KEY::CbKeyMost( pidb->FPrimary() == pidb->CbVarSegMac() ) );
		Assert( 0 == rgdata[iMSO_VarSegMac].Cb() );
		}

	LE_TUPLELIMITS	le_tuplelimits;
	if ( pidb->FTuples() )
		{
		le_tuplelimits.le_chLengthMin = pidb->ChTuplesLengthMin();
		le_tuplelimits.le_chLengthMax = pidb->ChTuplesLengthMax();
		le_tuplelimits.le_chToIndexMax = pidb->ChTuplesToIndexMax();

		rgdata[iMSO_TupleLimits].SetPv( (BYTE *)&le_tuplelimits );
		rgdata[iMSO_TupleLimits].SetCb( sizeof(le_tuplelimits) );
		}
	else
		{
		Assert( 0 == rgdata[iMSO_TupleLimits].Cb() );
		}

	QWORD qwSortVersion = 0;
	if( pidb->FLocalizedText() )
		{
		Call( ErrNORMGetSortVersion( pidb->Lcid(), &qwSortVersion ) );

		rgdata[iMSO_Version].SetPv( &qwSortVersion );
		rgdata[iMSO_Version].SetCb( sizeof( qwSortVersion ) );
		}

	err = ErrCATInsert( ppib, pfucbCatalog, rgdata, iMSO_LCMapFlags );
	if ( JET_errKeyDuplicate == err )
		err = ErrERRCheck( JET_errIndexDuplicate );

HandleError:
	return err;
	}


ERR ErrCATAddTableLV(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	const PGNO		pgnoLVFDP,
	const OBJID		objidLV )
	{
	DATA			rgdata[idataMSOMax];
	const SYSOBJ	sysobj				= sysobjLongValue;
	const ULONG		ulPages				= cpgLVTree;
	const ULONG		ulDensity			= ulFILEDensityMost;
	const ULONG		ulFlagsNil			= 0;

	//	objids are monotonically increasing, so LV should
	//	always have higher objid than its table
	Assert( objidLV > objidTable );

	//	must zero out to ensure unused fields are ignored
	memset( rgdata, 0, sizeof(rgdata) );

	rgdata[iMSO_ObjidTable].SetPv(		(BYTE *)&objidTable );
	rgdata[iMSO_ObjidTable].SetCb(		sizeof(objidTable) );

	rgdata[iMSO_Type].SetPv(			(BYTE *)&sysobj );
	rgdata[iMSO_Type].SetCb(			sizeof(sysobj) );

	rgdata[iMSO_Id].SetPv(				(BYTE *)&objidLV );
	rgdata[iMSO_Id].SetCb(				sizeof(objidLV) );

	rgdata[iMSO_Name].SetPv(			(BYTE *)szLVRoot );
	rgdata[iMSO_Name].SetCb(			cbLVRoot );

	rgdata[iMSO_PgnoFDP].SetPv(			(BYTE *)&pgnoLVFDP );
	rgdata[iMSO_PgnoFDP].SetCb(			sizeof(pgnoLVFDP) );

	rgdata[iMSO_SpaceUsage].SetPv(		(BYTE *)&ulDensity );
	rgdata[iMSO_SpaceUsage].SetCb(		sizeof(ulDensity) );

	rgdata[iMSO_Flags].SetPv(			(BYTE *)&ulFlagsNil );
	rgdata[iMSO_Flags].SetCb(			sizeof(ulFlagsNil) );

	rgdata[iMSO_Pages].SetPv(			(BYTE *)&ulPages );
	rgdata[iMSO_Pages].SetCb(			sizeof(ulPages) );

	return ErrCATInsert( ppib, pfucbCatalog, rgdata, iMSO_Pages );
	}


//  ================================================================
ERR ErrCATAddTableCallback(
	PIB					*ppib,
	FUCB				*pfucbCatalog,
	const OBJID			objidTable,
	const JET_CBTYP		cbtyp,
	const CHAR * const	szCallback )
//  ================================================================
	{
	Assert( objidNil != objidTable );
	Assert( NULL != szCallback );
	Assert( cbtyp > JET_cbtypNull );

	DATA			rgdata[idataMSOMax];
	const SYSOBJ	sysobj				= sysobjCallback;
	const ULONG		ulId				= sysobjCallback;
	const ULONG		ulFlags				= cbtyp;
	const ULONG		ulNil				= 0;

	//	must zero out to ensure unused fields are ignored
	memset( rgdata, 0, sizeof(rgdata) );

	rgdata[iMSO_ObjidTable].SetPv(		(BYTE *)&objidTable );
	rgdata[iMSO_ObjidTable].SetCb(		sizeof(objidTable) );

	rgdata[iMSO_Type].SetPv(			(BYTE *)&sysobj );
	rgdata[iMSO_Type].SetCb(			sizeof(sysobj) );

	rgdata[iMSO_Id].SetPv(				(BYTE *)&ulId );
	rgdata[iMSO_Id].SetCb(				sizeof(ulId) );

	rgdata[iMSO_Name].SetPv(			(BYTE *)szTableCallback );
	rgdata[iMSO_Name].SetCb(			cbTableCallback );

	rgdata[iMSO_PgnoFDP].SetPv(			(BYTE *)&ulNil );
	rgdata[iMSO_PgnoFDP].SetCb(			sizeof(ulNil) );

	rgdata[iMSO_SpaceUsage].SetPv(		(BYTE *)&ulNil );
	rgdata[iMSO_SpaceUsage].SetCb(		sizeof(ulNil) );

	rgdata[iMSO_Flags].SetPv(			(BYTE *)&ulFlags );
	rgdata[iMSO_Flags].SetCb(			sizeof(ulFlags) );

	rgdata[iMSO_Pages].SetPv(			(BYTE *)&ulNil );
	rgdata[iMSO_Pages].SetCb(			sizeof(ulNil) );

	rgdata[iMSO_Callback].SetPv(		(BYTE *)szCallback );
	rgdata[iMSO_Callback].SetCb(		strlen( szCallback ) );

	return ErrCATInsert( ppib, pfucbCatalog, rgdata, iMSO_Pages );
	}


LOCAL ERR ErrCATISeekTable(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
	const CHAR	*szTableName )
	{
	ERR			err;
	const BYTE	bTrue		= 0xff;

	//	should be on the primary index
	Assert( pfucbNil != pfucbCatalog );
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	//	switch to secondary index
	Call( ErrIsamSetCurrentIndex(
					(JET_SESID)ppib,
					(JET_TABLEID)pfucbCatalog,
					szMSORootObjectsIndex ) );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				&bTrue,
				sizeof(bTrue),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)szTableName,
				(ULONG)strlen(szTableName),
				NO_GRBIT ) );
	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekEQ );
	if ( JET_errRecordNotFound == err )
		err = ErrERRCheck( JET_errObjectNotFound );
	Call( err );
	CallS( err );

	Assert( !Pcsr( pfucbCatalog )->FLatched() );
	Call( ErrDIRGet( pfucbCatalog ) );

#ifdef DEBUG
	{
	//	verify this is a table
	DATA	dataField;
	Assert( FFixedFid( fidMSO_Type ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Type,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(SYSOBJ) );
	Assert( sysobjTable == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
	}
#endif

HandleError:
	return err;
	}


LOCAL ERR ErrCATISeekTable(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
	const OBJID	objidTable )
	{
	ERR			err;
	DATA		dataField;

	//	should be on the primary index
	Assert( pfucbNil != pfucbCatalog );
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey ) );
	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekGT );
	if ( JET_errRecordNotFound == err )
		err = ErrERRCheck( JET_errObjectNotFound );
	Call( err );
	CallS( err );

	Assert( !Pcsr( pfucbCatalog )->FLatched() );
	Call( ErrDIRGet( pfucbCatalog ) );

	Assert( FFixedFid( fidMSO_Id ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Id,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	if ( objidTable != *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) )
		{
		err = ErrERRCheck( JET_errObjectNotFound );
		goto HandleError;
		}

#ifdef DEBUG
	//	first record with this pgnoFDP should always be the Table object.
	Assert( FFixedFid( fidMSO_Type ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Type,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(SYSOBJ) );
	Assert( sysobjTable == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
#endif

HandleError:
	return err;
	}


ERR ErrCATSeekTable(
	PIB				*ppib,
	const IFMP		ifmp,
	const CHAR		*szTableName,
	PGNO			*ppgnoTableFDP,
	OBJID			*pobjidTable )
	{
	ERR		err;
	FUCB	*pfucbCatalog = pfucbNil;
	DATA	dataField;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, szTableName ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	if ( NULL != ppgnoTableFDP )
		{
		Assert( FFixedFid( fidMSO_PgnoFDP ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_PgnoFDP,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(PGNO) );
		*ppgnoTableFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//		UtilMemCpy( ppgnoTableFDP, dataField.Pv(), sizeof(PGNO) );
		}

	if ( NULL != pobjidTable )
		{
		Assert( FFixedFid( fidMSO_Id ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Id,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(OBJID) );
		*pobjidTable = *(UnalignedLittleEndian< OBJID > *) dataField.Pv();
//		UtilMemCpy( pobjidTable, dataField.Pv(), sizeof(OBJID) );
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


//  ================================================================
ERR ErrCATSeekTableByObjid(
	IN PIB			* const ppib,
	IN const IFMP	ifmp,
	IN const OBJID	objidTable,
	OUT CHAR		* const szTableName,
	IN const INT	cchTableName,
	OUT PGNO		* const ppgnoTableFDP )
//  ================================================================
	{
	ERR		err;
	FUCB	*pfucbCatalog = pfucbNil;
	DATA	dataField;

	const INT cbName = cchTableName * sizeof( szTableName[0] );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, objidTable ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	if ( NULL != ppgnoTableFDP )
		{
		Assert( FFixedFid( fidMSO_PgnoFDP ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_PgnoFDP,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(PGNO) );
		*ppgnoTableFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
		}

	if ( NULL != szTableName && 0 != cchTableName )
		{
		Assert( FVarFid( fidMSO_Name ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Name,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );

		memset( szTableName, '\0', cbName );
		memcpy( szTableName, dataField.Pv(), min( cbName, dataField.Cb() ) );
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


LOCAL ERR ErrCATISeekTableObject(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	const SYSOBJ	sysobj,
	const CHAR		*szName )
	{
	ERR				err;

	Assert( sysobjColumn == sysobj
		|| sysobjIndex == sysobj
		|| sysobjLongValue == sysobj
		|| sysobjSLVAvail == sysobj
		|| sysobjSLVOwnerMap == sysobj );

	//	should be on the primary index
	Assert( pfucbNil != pfucbCatalog );
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	//	switch to secondary index
	Call( ErrIsamSetCurrentIndex(
				(JET_SESID)ppib,
				(JET_TABLEID)pfucbCatalog,
				szMSONameIndex ) );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)szName,
				(ULONG)strlen(szName),
				NO_GRBIT ) );
	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekEQ );
	Assert( err <= JET_errSuccess );	//	SeekEQ shouldn't return warnings
	if ( JET_errRecordNotFound == err )
		{
		switch ( sysobj )
			{
			case sysobjColumn:
				err = ErrERRCheck( JET_errColumnNotFound );
				break;
			case sysobjIndex:
				err = ErrERRCheck( JET_errIndexNotFound );
				break;

			default:
				AssertSz( fFalse, "Invalid CATALOG object" );
				//	FALL THROUGH:
			case sysobjLongValue:
			case sysobjSLVAvail:
			case sysobjSLVOwnerMap:
				err = ErrERRCheck( JET_errObjectNotFound );
				break;
			}
		}
	else if ( JET_errSuccess == err )
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		}

HandleError:
	return err;
	}

LOCAL ERR ErrCATISeekTableObject(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	const SYSOBJ	sysobj,
	const OBJID		objid )
	{
	ERR				err;

	Assert( sysobjColumn == sysobj
		|| sysobjIndex == sysobj
		|| sysobjTable == sysobj
		|| sysobjLongValue == sysobj );

	//	should be on the primary index, which is the Id index
	Assert( pfucbNil != pfucbCatalog );
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objid,
				sizeof(objid),
				NO_GRBIT ) );
	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekEQ );
	Assert( err <= JET_errSuccess );	//	SeekEQ shouldn't return warnings
	if ( JET_errRecordNotFound == err )
		{
		switch ( sysobj )
			{
			case sysobjColumn:
				err = ErrERRCheck( JET_errColumnNotFound );
				break;
			case sysobjIndex:
				err = ErrERRCheck( JET_errIndexNotFound );
				break;

			default:
				AssertSz( fFalse, "Invalid CATALOG object" );
				//	FALL THROUGH:
			case sysobjTable:
			case sysobjLongValue:
				err = ErrERRCheck( JET_errObjectNotFound );
				break;
			}
		}
	else if ( JET_errSuccess == err )
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		}

HandleError:
	return err;
	}


LOCAL ERR ErrCATIDeleteTable( PIB *ppib, const IFMP ifmp, const OBJID objidTable, const BOOL fShadow )
	{
	ERR		err;
	FUCB	*pfucbCatalog	= pfucbNil;

	Assert( ppib->level > 0 );

	Assert( objidTable > objidSystemRoot );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fShadow ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTable(
				ppib,
				pfucbCatalog,
				objidTable ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	CallS( ErrDIRRelease( pfucbCatalog ) );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey | JET_bitStrLimit ) );

	err = ErrIsamSetIndexRange( ppib, pfucbCatalog, JET_bitRangeUpperLimit );
	Assert( JET_errNoCurrentRecord != err );

	do
		{
		Call( err );
		Call( ErrIsamDelete( ppib, pfucbCatalog ) );
		err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
		}
	while ( JET_errNoCurrentRecord != err );

	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


ERR ErrCATDeleteTable( PIB *ppib, const IFMP ifmp, const OBJID objidTable )
	{
	ERR			err;

	//	ensure we're in a transaction, so that on failure, updates to both
	//	catalog and its shadow are rolled back
	Assert( ppib->level > 0 );

	CallR( ErrCATIDeleteTable( ppib, ifmp, objidTable, fFalse ) );

	if ( !rgfmp[ifmp].FShadowingOff() )
		{
#ifdef DEBUG
		const ERR	errSave		= err;
#endif

		err = ErrCATIDeleteTable( ppib, ifmp, objidTable, fTrue );

		Assert( JET_errObjectNotFound != err );		// would have been detected in regular catalog
		Assert( err < 0 || errSave == err );
		}

	return err;
	}


/*	replaces the value in a column of a record of a system table.
/**/
LOCAL ERR ErrCATIDeleteTableColumn(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidTable,
	const CHAR		*szColumnName,
	COLUMNID		*pcolumnid,
	const BOOL		fShadow )
	{
	ERR				err;
	FUCB			*pfucbCatalog	= pfucbNil;
	DATA			dataField;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	CHAR			szStubName[cbMaxDeletedColumnStubName];

	Assert( objidTable > objidSystemRoot );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fShadow ) );
	Assert( pfucbNil != pfucbCatalog );

	if ( fShadow )
		{
		Assert( !FCOLUMNIDTemplateColumn( *pcolumnid ) );	//	Template bit is not persisted
		Call( ErrCATISeekTableObject(
					ppib,
					pfucbCatalog,
					objidTable,
					sysobjColumn,
					*pcolumnid ) );
		}
	else
		{
		Call( ErrCATISeekTableObject(
					ppib,
					pfucbCatalog,
					objidTable,
					sysobjColumn,
					szColumnName ) );
		}
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( FFixedFid( fidMSO_Id ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Id,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(JET_COLUMNID) );
	columnid = *(UnalignedLittleEndian< JET_COLUMNID > *) dataField.Pv();
//	UtilMemCpy( &columnid, dataField.Pv(), sizeof(JET_COLUMNID) );

	Assert( !FCOLUMNIDTemplateColumn( columnid ) );	//	Template bit is not persisted

#ifdef DEBUG
	Assert( FFixedFid( fidMSO_Coltyp ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Coltyp,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(JET_COLTYP) );
	Assert( JET_coltypNil != *( UnalignedLittleEndian< JET_COLTYP > *)dataField.Pv() );
#endif

	Call( ErrDIRRelease( pfucbCatalog ) );

	Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplace ) );

	//	Set column type to Nil to flag column as deleted.
	//	If possible, the record will be deleted the next time the table
	//	is opened.
	coltyp = JET_coltypNil;
	Call( ErrIsamSetColumn(
			ppib,
			pfucbCatalog,
			fidMSO_Coltyp,
			(BYTE *)&coltyp,
			sizeof(coltyp),
			0,
			NULL ) );

	// Replace column name with bogus name of the form "JetStub_<objidFDP>_<fid>".
	strcpy( szStubName, szDeletedColumnStubPrefix );
	_ultoa( objidTable, szStubName + strlen( szDeletedColumnStubPrefix ), 10 );
	Assert( strlen( szStubName ) < cbMaxDeletedColumnStubName );
	strcat( szStubName, "_" );
	_ultoa( columnid, szStubName + strlen( szStubName ), 10 );
	Assert( strlen( szStubName ) < cbMaxDeletedColumnStubName );
	Call( ErrIsamSetColumn(
			ppib,
			pfucbCatalog,
			fidMSO_Name,
			(BYTE *)szStubName,
			(ULONG)strlen( szStubName ),
			NO_GRBIT,
			NULL ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );

	//	Set return value.
	*pcolumnid = columnid;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


ERR ErrCATDeleteTableColumn(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szColumnName,
	COLUMNID	*pcolumnid )
	{
	ERR			err;

	//	ensure we're in a transaction, so that on failure, updates to both
	//	catalog and its shadow are rolled back
	Assert( ppib->level > 0 );

	CallR( ErrCATIDeleteTableColumn(
				ppib,
				ifmp,
				objidTable,
				szColumnName,
				pcolumnid,
				fFalse ) );


	if ( !rgfmp[ifmp].FShadowingOff() )
		{
#ifdef DEBUG
		const ERR	errSave			= err;
#endif

		COLUMNID	columnidShadow	= *pcolumnid;

		err = ErrCATIDeleteTableColumn(
					ppib,
					ifmp,
					objidTable,
					szColumnName,
					&columnidShadow,
					fTrue );

		Assert( JET_errColumnNotFound != err );		// would have been detected in regular catalog
		Assert( err < 0
			|| ( errSave == err && columnidShadow == *pcolumnid ) );
		}

	return err;
	}


LOCAL ERR ErrCATIDeleteTableIndex(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szIndexName,
	PGNO		*ppgnoIndexFDP,
	OBJID		*pobjidIndex,
	const BOOL	fShadow )
	{
	ERR			err;
	FUCB		*pfucbCatalog		= pfucbNil;
	DATA		dataField;

	Assert( objidTable > objidSystemRoot );
	Assert( NULL != ppgnoIndexFDP );
	Assert( NULL != pobjidIndex );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fShadow ) );
	Assert( pfucbNil != pfucbCatalog );

	if ( fShadow )
		{
		//	if shadow, must search by objidIndex because there's
		//	no index on name
		Assert( *pobjidIndex > objidSystemRoot );

		//	objids are monotonically increasing, so an index should
		//	always have higher objid than its table
		Assert( *pobjidIndex > objidTable );

		Call( ErrCATISeekTableObject(
					ppib,
					pfucbCatalog,
					objidTable,
					sysobjIndex,
					*pobjidIndex ) );
		}
	else
		{
		//	if not shadow, must search by name because we dont'
		//	know objidIndex yet
		Call( ErrCATISeekTableObject(
					ppib,
					pfucbCatalog,
					objidTable,
					sysobjIndex,
					szIndexName ) );
		}
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( FFixedFid( fidMSO_PgnoFDP ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_PgnoFDP,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(PGNO) );
	*ppgnoIndexFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//	UtilMemCpy( ppgnoIndexFDP, dataField.Pv(), sizeof(PGNO) );

	Assert( FFixedFid( fidMSO_Id ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Id,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	*pobjidIndex = *(UnalignedLittleEndian< OBJID > *) dataField.Pv();
//	UtilMemCpy( pobjidIndex, dataField.Pv(), sizeof(OBJID) );

#ifdef DEBUG
	LE_IDXFLAG		*ple_idxflag;
	IDBFLAG			fidb;
	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Flags,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ple_idxflag = (LE_IDXFLAG*)dataField.Pv();
	fidb = ple_idxflag->fidb;

	if ( FIDBPrimary( fidb ) )
		{
		Assert( objidTable == *pobjidIndex );
		}
	else
		{
		//	objids are monotonically increasing, so an index should
		//	always have higher objid than its table
		Assert( *pobjidIndex > objidTable );
		}
#endif

	CallS( ErrDIRRelease( pfucbCatalog ) );

	if ( objidTable == *pobjidIndex )
		err = ErrERRCheck( JET_errIndexMustStay );
	else
		err = ErrIsamDelete( ppib, pfucbCatalog );

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


LOCAL ERR ErrCATIDeleteDbObject(
	PIB				* const ppib,
	const IFMP		ifmp,
	const CHAR		* const szName,
	const SYSOBJ 	sysobj )
	{
	ERR				err;
	FUCB *			pfucbCatalog		= pfucbNil;
	BOOKMARK 		bm;
	BYTE			rgbBookmark[JET_cbBookmarkMost];
	ULONG			cbBookmark;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidSystemRoot,
				sysobj,
				szName ) );

	Call( ErrDIRRelease( pfucbCatalog ) );

	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrIsamDelete( ppib, pfucbCatalog ) );
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	if( !rgfmp[ifmp].FShadowingOff() )
		{
		Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );
		Assert( pfucbNil != pfucbCatalog );

		Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );
		Call( ErrIsamDelete( ppib, pfucbCatalog ) );
		}

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	return err;
	}

ERR ErrCATDeleteDbObject(
	PIB				* const ppib,
	const IFMP		ifmp,
	const CHAR		* const szName,
	const SYSOBJ 	sysobj)
	{
	ERR	err = JET_errSuccess;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	Call( ErrCATIDeleteDbObject(
				ppib,
				ifmp,
				szName,
				sysobj ) );

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	return err;
	}



ERR ErrCATDeleteTableIndex(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szIndexName,
	PGNO		*ppgnoIndexFDP )
	{
	ERR			err;
	OBJID		objidIndex;

	//	ensure we're in a transaction, so that on failure, updates to both
	//	catalog and its shadow are rolled back
	Assert( ppib->level > 0 );

	CallR( ErrCATIDeleteTableIndex(
				ppib,
				ifmp,
				objidTable,
				szIndexName,
				ppgnoIndexFDP,
				&objidIndex,
				fFalse ) );

	if ( !rgfmp[ifmp].FShadowingOff() )
		{
#ifdef DEBUG
		const ERR	errSave		= err;
#endif

		PGNO		pgnoIndexShadow;

		err = ErrCATIDeleteTableIndex(
					ppib,
					ifmp,
					objidTable,
					szIndexName,
					&pgnoIndexShadow,
					&objidIndex,
					fTrue );

		Assert( JET_errIndexNotFound != err );		// would have been detected in regular catalog
		Assert( err < 0
			|| ( errSave == err && pgnoIndexShadow == *ppgnoIndexFDP ) );
		}

	return err;
	}



ERR ErrCATAccessTableColumn(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidTable,
	const CHAR		*szColumnName,
	COLUMNID		*pcolumnid,
	const BOOL		fLockColumn )
	{
	ERR				err;
	FUCB			*pfucbCatalog	= pfucbNil;
	const BOOL		fSearchByName	= ( szColumnName != NULL );
	DATA			dataField;
	JET_COLTYP		coltyp;

	Assert( NULL != pcolumnid );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	if ( fSearchByName )
		{
		Call( ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidTable,
				sysobjColumn,
				szColumnName ) );
		}
	else
		{
		COLUMNID	columnidT	= *pcolumnid;

		Assert( !FCOLUMNIDTemplateColumn( columnidT ) );
		Call( ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidTable,
				sysobjColumn,
				(OBJID)columnidT ) );
		}
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( FFixedFid( fidMSO_Coltyp ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Coltyp,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(JET_COLTYP) );
	coltyp = *(UnalignedLittleEndian< JET_COLTYP > *) dataField.Pv();
//	UtilMemCpy( &coltyp, dataField.Pv(), sizeof(JET_COLTYP) );

	if ( JET_coltypNil == coltyp )
		{
		// Column has been deleted.
		err = ErrERRCheck( JET_errColumnNotFound );
		goto HandleError;
		}

	Assert( !fLockColumn || fSearchByName );		// Locking column only done by name.
	if ( fSearchByName )
		{
		Assert( FFixedFid( fidMSO_Id ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Id,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(JET_COLUMNID) );
		*pcolumnid = *(UnalignedLittleEndian< JET_COLUMNID > *) dataField.Pv();
//		UtilMemCpy( pcolumnid, dataField.Pv(), sizeof(JET_COLUMNID) );
		Assert( 0 != *pcolumnid );

		if ( fLockColumn )
			{
			// UNDONE: Lock must be obtained in a transaction.  Further, since
			// CreateIndex is currently the only function to lock a table column,
			// we can assert that we are in a transaction.
			Assert( pfucbCatalog->ppib->level > 0 );

			Call( ErrDIRRelease( pfucbCatalog ) );
			Call( ErrDIRGetLock( pfucbCatalog, readLock ) );
			}
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


ERR ErrCATAccessTableIndex(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidTable,
	const OBJID		objidIndex )
	{
	ERR				err;
	FUCB			*pfucbCatalog		= pfucbNil;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTableObject(
			ppib,
			pfucbCatalog,
			objidTable,
			sysobjIndex,
			objidIndex ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}

ERR ErrCATAccessTableLV(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidTable,
	PGNO			*ppgnoLVFDP,
	OBJID			*pobjidLV )
	{
	ERR				err;
	FUCB			*pfucbCatalog	= pfucbNil;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	err = ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidTable,
				sysobjLongValue,
				szLVRoot );

	if ( err < 0 )
		{
		if ( JET_errObjectNotFound == err )
			{
			// LV tree has yet to be created.
			err = JET_errSuccess;
			*ppgnoLVFDP = pgnoNull;
			if( NULL != pobjidLV )
				{
				*pobjidLV	= objidNil;
				}
			}
		}
	else
		{
		DATA	dataField;

		Assert( Pcsr( pfucbCatalog )->FLatched() );

		Assert( FFixedFid( fidMSO_PgnoFDP ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_PgnoFDP,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(PGNO) );

		*ppgnoLVFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//		UtilMemCpy( ppgnoLVFDP, dataField.Pv(), sizeof(PGNO) );

		if( NULL != pobjidLV )
			{
			Assert( FFixedFid( fidMSO_Id ) );
			Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Id,
						pfucbCatalog->kdfCurr.data,
						&dataField ) );
			CallS( err );
			Assert( dataField.Cb() == sizeof(OBJID) );

			*pobjidLV = *(UnalignedLittleEndian< OBJID > *) dataField.Pv();
//			UtilMemCpy( pobjidLV, dataField.Pv(), sizeof(OBJID) );
			}
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


ERR ErrCATGetTableInfoCursor(
	PIB				*ppib,
	const IFMP		ifmp,
	const CHAR		*szTableName,
	FUCB			**ppfucbInfo )
	{
	ERR				err;
	FUCB			*pfucbCatalog;

	Assert( NULL != ppfucbInfo );

	//	Can only open a system table cursor on a specific record.
	if ( NULL == szTableName || '\0' == *szTableName )
		{
		err = ErrERRCheck( JET_errObjectNotFound );
		return err;
		}

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, szTableName ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	CallS( ErrDIRRelease( pfucbCatalog ) );

	*ppfucbInfo = pfucbCatalog;

	return err;

HandleError:
	Assert( err < 0 );
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}

ERR ErrCATGetObjectNameFromObjid(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID		objidTable,
	const SYSOBJ	sysobj,
	const OBJID	objid,
	char * 		szName, // JET_cbNameMost
	ULONG 		cbName )
	{
	ERR			err;
	FUCB 		*pfucbCatalog		= pfucbNil;
	DATA		dataField;

	Assert( NULL != szName);
	Assert( cbName >= JET_cbNameMost + 1 );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call (ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobj, objid) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( FVarFid( fidMSO_Name ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Name,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );

	memset( szName, '\0', cbName);
	memcpy( szName, dataField.Pv(), min(cbName, dataField.Cb() ) );

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


ERR ErrCATGetTableAllocInfo(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	ULONG		*pulPages,
	ULONG		*pulDensity,
	PGNO 		*ppgnoFDP)
	{
	ERR			err;
	FUCB 		*pfucbCatalog		= pfucbNil;
	DATA		dataField;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, objidTable ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	//	pages are optional, density is not
	if ( NULL != pulPages )
		{
		Assert( FFixedFid( fidMSO_Pages ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Pages,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(ULONG) );
		*pulPages = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//		UtilMemCpy( pulPages, dataField.Pv(), sizeof(ULONG) );
		}

	Assert( NULL != pulDensity );

	Assert( FFixedFid( fidMSO_SpaceUsage ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_SpaceUsage,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	*pulDensity = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( pulDensity, dataField.Pv(), sizeof(ULONG) );

	if ( NULL != ppgnoFDP )
		{
		Assert( FFixedFid( iMSO_PgnoFDP ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					iMSO_PgnoFDP,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(PGNO) );
		*ppgnoFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//		UtilMemCpy( ppgnoFDP, dataField.Pv(), sizeof(PGNO) );
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


ERR ErrCATGetIndexAllocInfo(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szIndexName,
	ULONG		*pulDensity )
	{
	ERR			err;
	FUCB 		*pfucbCatalog		= pfucbNil;
	DATA		dataField;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidTable,
				sysobjIndex,
				szIndexName ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( NULL != pulDensity );

	Assert( FFixedFid( fidMSO_SpaceUsage ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_SpaceUsage,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	*pulDensity = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( pulDensity, dataField.Pv(), sizeof(ULONG) );

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}

ERR ErrCATGetIndexLcid(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szIndexName,
	LCID		*plcid )
	{
	ERR			err;
	FUCB 		*pfucbCatalog		= pfucbNil;
	DATA		dataField;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidTable,
				sysobjIndex,
				szIndexName ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( NULL != plcid );

	Assert( FFixedFid( fidMSO_Localization ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Localization,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(LCID) );

	*plcid = *( (UnalignedLittleEndian< LCID > *)dataField.Pv() );

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}

ERR ErrCATGetIndexVarSegMac(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szIndexName,
	USHORT		*pusVarSegMac )
	{
	ERR			err;
	FUCB 		*pfucbCatalog	= pfucbNil;
	DATA		dataField;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidTable,
				sysobjIndex,
				szIndexName ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( NULL != pusVarSegMac );

	Assert( FVarFid( fidMSO_VarSegMac ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_VarSegMac,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	Assert( JET_errSuccess == err || JET_wrnColumnNull == err );

	if ( JET_wrnColumnNull == err )
		{
		Assert( dataField.Cb() == 0 );

		*pusVarSegMac = JET_cbKeyMost;
		}

	else
		{
		Assert( dataField.Cb() == sizeof(USHORT) );
		*pusVarSegMac = *(UnalignedLittleEndian< USHORT > *) dataField.Pv();
//		UtilMemCpy( pusVarSegMac, dataField.Pv(), sizeof(USHORT) );
		Assert( *pusVarSegMac > 0 );
		Assert( *pusVarSegMac < JET_cbKeyMost );
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


ERR ErrCATGetIndexSegments(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidTable,
	const IDXSEG*	rgidxseg,
	const ULONG		cidxseg,
	const BOOL		fConditional,
	const BOOL		fOldFormat,
	CHAR			rgszSegments[JET_ccolKeyMost][JET_cbNameMost+1+1] )		// extra +1 for ascending/descending byte
	{
	ERR				err;
	FUCB			*pfucbCatalog			= pfucbNil;
	DATA			dataField;
	ULONG			ulFlags;
	OBJID			objidTemplateTable		= objidNil;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, objidTable ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	//	should be on primary index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );

	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Flags,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ulFlags = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();

	if ( ulFlags & JET_bitObjectTableDerived )
		{
		CHAR	szTemplateTable[JET_cbNameMost+1];

		Assert( FVarFid( fidMSO_TemplateTable ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_TemplateTable,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() > 0 );
		Assert( dataField.Cb() <= JET_cbNameMost );
		UtilMemCpy( szTemplateTable, dataField.Pv(), dataField.Cb() );
		szTemplateTable[dataField.Cb()] = '\0';

		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );

		Call( ErrCATSeekTable( ppib, ifmp, szTemplateTable, NULL, &objidTemplateTable ) );
		Assert( objidNil != objidTemplateTable );
		}
	else
		{
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );
		}

	//	should still be on the primary index, which is the Id index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	UINT	i;
	for ( i = 0; i < cidxseg; i++ )
		{
		CHAR				szColumnName[JET_cbNameMost+1];
		OBJID				objidT			= objidTable;
		BYTE				bPrefix;

		if ( rgidxseg[i].FTemplateColumn() )
			{
			Assert( !fOldFormat );

			if ( ulFlags & JET_bitObjectTableDerived )
				{
				Assert( objidNil != objidTemplateTable );
				objidT = objidTemplateTable;
				}
			else
				{
				Assert( ulFlags & JET_bitObjectTableTemplate );
				Assert( objidNil == objidTemplateTable );
				}
			}

		err = ErrCATISeekTableObject(
					ppib,
					pfucbCatalog,
					objidT,
					sysobjColumn,
					ColumnidOfFid( rgidxseg[i].Fid(), fFalse ) );	//	Template bit never persisted in catalog ) );
		if ( err < 0 )
			{
			//	SPECIAL-CASE: We never stored template bit in old-format indexes, so it's
			//	possible that the column was actually derived from the template table
			if ( JET_errColumnNotFound == err
				&& fOldFormat
				&& objidNil != objidTemplateTable )
				{
				err = ErrCATISeekTableObject(
							ppib,
							pfucbCatalog,
							objidTemplateTable,
							sysobjColumn,
							ColumnidOfFid( rgidxseg[i].Fid(), fFalse ) );
				}

			Call( err );
			}
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		//	should be on primary index
		Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );

		Assert( FVarFid( fidMSO_Name ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Name,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() > 0 );
		Assert( dataField.Cb() <= JET_cbNameMost );
		UtilMemCpy( szColumnName, dataField.Pv(), dataField.Cb() );
		szColumnName[dataField.Cb()] = '\0';

		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );

		if ( fConditional )
			{
			bPrefix = ( rgidxseg[i].FMustBeNull() ? '?' : '*' );
			}
		else
			{
			bPrefix = ( rgidxseg[i].FDescending() ? '-' : '+' );

			}
		sprintf(
			rgszSegments[i],
			"%c%-s",
			bPrefix,
			szColumnName );
		}

	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


//  ================================================================
ERR ErrCATGetColumnCallbackInfo(
	PIB * const ppib,
	const IFMP ifmp,
	const OBJID objidTable,
	const OBJID objidTemplateTable,
	const COLUMNID columnid,
	CHAR * const szCallback,
	const ULONG cchCallbackMax,
	ULONG * const pcchCallback,
	BYTE * const pbUserData,
	const ULONG cbUserDataMax,
	ULONG * const pcbUserData,
	CHAR * const szDependantColumns,
	const ULONG cchDependantColumnsMax,
	ULONG * const pchDependantColumns )
//  ================================================================
	{
	ERR				err;
	FUCB			*pfucbCatalog			= pfucbNil;
	DATA			dataField;

	FID				rgfidDependencies[JET_ccolKeyMost];
	ULONG			cbActual;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	//	Template bit is not persisted
	Assert( !FCOLUMNIDTemplateColumn( columnid ) );

	Call( ErrCATISeekTableObject(
			ppib,
			pfucbCatalog,
			objidTable,
			sysobjColumn,
			columnid ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( FVarFid( fidMSO_Callback ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Callback,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	//  ErrCATGetColumnCallbackInfo should only be called for columns that have callbacks
	Assert( dataField.Cb() > 0 );
	Assert( dataField.Cb() <= JET_cbNameMost );
	Assert( cchCallbackMax > JET_cbNameMost );
	if ( cchCallbackMax < JET_cbNameMost + 1 )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}
	UtilMemCpy( szCallback, dataField.Pv(), dataField.Cb() );
	*pcchCallback = dataField.Cb() + 1;
	szCallback[dataField.Cb()] = '\0';

	Assert( FTaggedFid( fidMSO_CallbackData ) );
	Call( ErrCATIRetrieveTaggedColumn(
			pfucbCatalog,
			fidMSO_CallbackData,
			1,
			pfucbCatalog->kdfCurr.data,
			pbUserData,
			cbUserDataMax,
			pcbUserData ) );
	Assert( JET_errSuccess == err || JET_wrnColumnNull == err );

	Assert( FTaggedFid( fidMSO_CallbackDependencies ) );
	Call( ErrCATIRetrieveTaggedColumn(
			pfucbCatalog,
			fidMSO_CallbackDependencies,
			1,
			pfucbCatalog->kdfCurr.data,
			(BYTE *)rgfidDependencies,
			sizeof(rgfidDependencies),
			&cbActual ) );
	Assert( JET_errSuccess == err || JET_wrnColumnNull == err );
	Assert( ( cbActual % sizeof(FID) ) == 0 );

	*pchDependantColumns = 0;

	if( cbActual > 0 )
		{
		//	dependencies not currently supported
		//
		Assert( fFalse );

		//  loop through the FIDs in the dependency list and convert them into column names
		//  Put the column names into szDependantColumns in "column\0column\0column\0\0" form.
		//
		UINT iFid;
		for ( iFid = 0; iFid < ( cbActual / sizeof( FID ) ); ++iFid )
			{
			CHAR			szColumnName[JET_cbNameMost+1];
			const COLUMNID	columnidT = rgfidDependencies[iFid];
			Assert( columnidT <= fidMax );
			Assert( columnidT >= fidMin );
			Assert( Pcsr( pfucbCatalog )->FLatched() );

			CallS( ErrDIRRelease( pfucbCatalog ) );
			err = ErrCATISeekTableObject(
						ppib,
						pfucbCatalog,
						objidTable,
						sysobjColumn,
						columnidT );
			if ( JET_errColumnNotFound == err
				&& objidNil != objidTemplateTable )
				{
				err = ErrCATISeekTableObject(
							ppib,
							pfucbCatalog,
							objidTemplateTable,
							sysobjColumn,
							columnidT );
				}
			Call( err );

			Assert( Pcsr( pfucbCatalog )->FLatched() );

			//	should be on primary index
			Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );

			Assert( FVarFid( fidMSO_Name ) );
			Call( ErrRECIRetrieveVarColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Name,
						pfucbCatalog->kdfCurr.data,
						&dataField ) );
			CallS( err );
			Assert( dataField.Cb() > 0 );
			Assert( dataField.Cb() <= JET_cbNameMost );
			UtilMemCpy( szColumnName, dataField.Pv(), dataField.Cb() );
			szColumnName[dataField.Cb()] = '\0';

			//  remember to leave space for the terminating NULL
			//
			if( *pchDependantColumns + dataField.Cb() + 2 >= cchDependantColumnsMax )
				{
				//  buffer should always have enough space
				//
				Assert( fFalse );
				err = JET_wrnBufferTruncated;
				break;
				}
			strcpy( szDependantColumns + *pchDependantColumns, szColumnName );
			*pchDependantColumns += dataField.Cb() + 1;
			}
		szDependantColumns[*pchDependantColumns] = '\0';
		++(*pchDependantColumns);
		}

HandleError:
	Assert( pfucbNil != pfucbCatalog );
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


/*	construct the catalog TDB using the static data structures
/*	defined in _cat.c.
/**/
INLINE ERR ErrCATIInitCatalogTDB( INST *pinst, TDB **pptdbNew )
	{
	ERR					err;
	UINT				i;
	FIELD				field;
	const CDESC			*pcdesc;
	TDB					*ptdb						= ptdbNil;
	TCIB				tcib						= { fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1 };
	REC::RECOFFSET		ibRec						= ibRECStartFixedColumns;

	//	UNDONE:		international support.  Set these values from create database connect string.
	//
	field.cp = usEnglishCodePage;

	/*	first, determine how many columns there are
	/**/
	pcdesc	= rgcdescMSO;
	for ( i = 0; i < cColumnsMSO; i++, pcdesc++ )
		{
		COLUMNID	columnidT;
		CallS( ErrFILEGetNextColumnid( pcdesc->coltyp, pcdesc->grbit, fFalse, &tcib, &columnidT ) );

		//	verify generated columnid matches hard-coded columnid
		//
		Assert( pcdesc->columnid == columnidT );
		}

	CallR( ErrTDBCreate( pinst, &ptdb, &tcib, pfcbNil, fTrue ) );

	/*	check initialisations
	/**/
	Assert( ptdb->FidVersion() == 0 );
	Assert( ptdb->FidAutoincrement() == 0 );
	Assert( NULL == ptdb->PdataDefaultRecord() );
	Assert( tcib.fidFixedLast == ptdb->FidFixedLast() );
	Assert( tcib.fidVarLast == ptdb->FidVarLast() );
	Assert( tcib.fidTaggedLast == ptdb->FidTaggedLast() );
	Assert( ptdb->DbkMost() == 0 );
	Assert( ptdb->UlLongIdLast() == 0 );

	//	add table name
	//
	Assert( ptdb->ItagTableName() == 0 );
	MEMPOOL::ITAG	itagNew;
	Call( ptdb->MemPool().ErrAddEntry( (BYTE *)szMSO, (ULONG)strlen(szMSO) + 1, &itagNew ) );
	Assert( itagNew == itagTDBTableName );
	ptdb->SetItagTableName( itagNew );

	/*	fill in the column info
	/**/
	pcdesc = rgcdescMSO;
	for ( i = 0; i < cColumnsMSO; i++, pcdesc++ )
		{
		Call( ptdb->MemPool().ErrAddEntry(
				(BYTE *)pcdesc->szColName,
				(ULONG)strlen( pcdesc->szColName ) + 1,
				&field.itagFieldName ) );
		field.strhashFieldName = StrHashValue( pcdesc->szColName );
		field.coltyp = FIELD_COLTYP( pcdesc->coltyp );
		Assert( field.coltyp != JET_coltypNil );
		field.cbMaxLen = UlCATColumnSize( pcdesc->coltyp, 0, NULL );

		/*	flag for system table columns is JET_bitColumnNotNULL
		/**/
		field.ffield = 0;

		Assert( 0 == pcdesc->grbit || JET_bitColumnNotNULL == pcdesc->grbit || JET_bitColumnTagged == pcdesc->grbit );
		if ( pcdesc->grbit == JET_bitColumnNotNULL )
			FIELDSetNotNull( field.ffield );

		// ibRecordOffset is only relevant for fixed fields (it will be ignored by
		// RECAddFieldDef(), so don't even bother setting it).
		if ( FCOLUMNIDFixed( pcdesc->columnid ) )
			{
			field.ibRecordOffset = ibRec;
			ibRec = REC::RECOFFSET( ibRec + field.cbMaxLen );
			}
		else
			{
			field.ibRecordOffset = 0;
			}

		Call( ErrRECAddFieldDef(
				ptdb,
				ColumnidOfFid( FID( pcdesc->columnid ), fFalse ),
				&field ) );
		}
	Assert( ibRec <= cbRECRecordMost );
	ptdb->SetIbEndFixedColumns( ibRec, ptdb->FidFixedLast() );

	*pptdbNew = ptdb;

	return JET_errSuccess;

HandleError:
	Assert( ptdb != ptdbNil );
	ptdb->Delete( pinst );

	return err;
	}


LOCAL VOID CATIFreeSecondaryIndexes( FCB *pfcbSecondaryIndexes )
	{
	FCB		* pfcbT		= pfcbSecondaryIndexes;
	FCB		* pfcbKill;
	INST	* pinst;

	Assert( pfcbNil != pfcbSecondaryIndexes );
	pinst = PinstFromIfmp( pfcbSecondaryIndexes->Ifmp() );

	// Must clean up secondary index FCBs and primary index FCB separately,
	// because the secondary index FCBs may not be linked to the primary index FCB.
	while ( pfcbT != pfcbNil )
		{
		if ( pfcbT->Pidb() != pidbNil )
			{
			// No need to explicitly free index name or idxseg array, since
			// memory pool will be freed when TDB is deleted.
			pfcbT->ReleasePidb();
			}
		pfcbKill = pfcbT;
		pfcbT = pfcbT->PfcbNextIndex();

		//	synchronously purge the FCB

		pfcbKill->PrepareForPurge( fFalse );
		pfcbKill->Purge();
		}
	}


/*	get index info of a system table index
/**/
ERR ErrCATInitCatalogFCB( FUCB *pfucbTable )
	{
	ERR			err;
	PIB			*ppib					= pfucbTable->ppib;
	const IFMP	ifmp					= pfucbTable->ifmp;
	FCB			*pfcb					= pfucbTable->u.pfcb;
	TDB			*ptdb					= ptdbNil;
	IDB			idb;
	UINT		iIndex;
	FCB			*pfcbSecondaryIndexes	= pfcbNil;
	const PGNO	pgnoTableFDP			= pfcb->PgnoFDP();
	const BOOL	fShadow					= ( pgnoFDPMSOShadow == pgnoTableFDP );
	BOOL		fProcessedPrimary		= fFalse;
	BOOL		fAbove					= fFalse;

	INST		*pinst = PinstFromIfmp( ifmp );

	Assert( !pfcb->FInitialized() );
	Assert( pfcb->Ptdb() == ptdbNil );

	Assert( FCATSystemTable( pgnoTableFDP ) );

	CallR( ErrCATIInitCatalogTDB( pinst, &ptdb ) );

	idb.SetLcid( lcidDefault );
	idb.SetDwLCMapFlags( dwLCMapFlagsDefault );
	idb.SetCidxsegConditional( 0 );

	Assert( pfcbSecondaryIndexes == pfcbNil );
	const IDESC			*pidesc		= rgidescMSO;
	for( iIndex = 0; iIndex < cIndexesMSO; iIndex++, pidesc++ )
		{
		USHORT		itagIndexName;

		// Add index name to table's byte pool.  On error, the entire TDB
		// and its byte pool is nuked, so we don't have to worry about
		// freeing the memory for the index name.
		Call( ptdb->MemPool().ErrAddEntry(
					(BYTE *)pidesc->szIdxName,
					(ULONG)strlen( pidesc->szIdxName ) + 1,
					&itagIndexName ) );
		idb.SetItagIndexName( itagIndexName );
		idb.SetCidxseg( CfieldCATKeyString( pidesc->szIdxKeys, idb.rgidxseg ) );
		idb.SetFlagsFromGrbit( pidesc->grbit );

		//	catalog indexes are always unique -- if this changes,
		//	ErrCATICreateCatalogIndexes() will have to be modified
		Assert( idb.FUnique() );

		//	catalog indexes are not over Unicode columns
		Assert( !idb.FLocaleId() );

		const BOOL	fPrimary = idb.FPrimary();
		if ( fPrimary )
			{
			Assert( !fProcessedPrimary );

			idb.SetCbVarSegMac( JET_cbPrimaryKeyMost );

			//	initialize FCB for this index
			//
			Call( ErrFILEIInitializeFCB(
					ppib,
					ifmp,
					ptdb,
					pfcb,
					&idb,
					fTrue,
					pgnoTableFDP,
					ulFILEDefaultDensity ) );

			pfcb->SetInitialIndex();
			fProcessedPrimary = fTrue;
			}
		else if ( !fShadow )
			{
			FUCB	*pfucbSecondaryIndex;
			PGNO	pgnoIndexFDP;
			OBJID	objidIndexFDP;

			idb.SetCbVarSegMac( JET_cbSecondaryKeyMost );

			// UNDONE:  This is a real hack to get around the problem of
			// determining pgnoFDPs of secondary system table indexes.
			// These values are currently hard-coded.
			Assert( pidesc == rgidescMSO + iIndex );
			if ( 1 == iIndex )
				{
				Assert( strcmp( pidesc->szIdxName, szMSONameIndex ) == 0 );
				pgnoIndexFDP = pgnoFDPMSO_NameIndex;
				objidIndexFDP = objidFDPMSO_NameIndex;
				}
			else
				{
				Assert( 2 == iIndex );
				Assert( strcmp( pidesc->szIdxName, szMSORootObjectsIndex ) == 0 );
				pgnoIndexFDP = pgnoFDPMSO_RootObjectIndex;
				objidIndexFDP = objidFDPMSO_RootObjectIndex;
				}

			Assert( idb.FUnique() );	//	all catalog indexes are unique
			Call( ErrDIROpenNoTouch(
						ppib,
						ifmp,
						pgnoIndexFDP,
						objidIndexFDP,
						fTrue,					//	all catalog indexes are unique
						&pfucbSecondaryIndex ) );

			Assert( !pfucbSecondaryIndex->u.pfcb->FInitialized() );

			err = ErrFILEIInitializeFCB(
					ppib,
					ifmp,
					ptdb,
					pfucbSecondaryIndex->u.pfcb,
					&idb,
					fFalse,
					pgnoIndexFDP,
					ulFILEDefaultDensity );
			if ( err < 0 )
				{
				DIRClose( pfucbSecondaryIndex );
				goto HandleError;
				}

			pfucbSecondaryIndex->u.pfcb->SetPfcbNextIndex( pfcbSecondaryIndexes );
			pfcbSecondaryIndexes = pfucbSecondaryIndex->u.pfcb;

			Assert( pfucbSecondaryIndex->u.pfcb->FAboveThreshold() ==
					BOOL( pfucbSecondaryIndex->u.pfcb >= PfcbFCBPreferredThreshold( pinst ) ) );
			fAbove |= pfucbSecondaryIndex->u.pfcb->FAboveThreshold();

			//	mark the secondary index as being initialized successfully

			pfucbSecondaryIndex->u.pfcb->SetInitialIndex();
			pfucbSecondaryIndex->u.pfcb->CreateComplete();

			DIRClose( pfucbSecondaryIndex );
			}
		}

	// All system tables have a primary index.
	Assert( fProcessedPrimary );

	// Try to compact byte pool, but if it fails, don't worry.  It just means
	// that the byte pool will have some unused space.
	ptdb->MemPool().FCompact();

	/*	link up sequential/primary index with the rest of the indexes
	/**/
	pfcb->SetPfcbNextIndex( pfcbSecondaryIndexes );

	/*	link up pfcbTable of secondary indexes
	/**/
	pfcb->LinkPrimaryIndex();

	//	set the above-threshold flag if any of the new
	//		secondary-index FCBs are above the threshold
	//
	//	since the FCB is pinned by pfucbTable, it will
	//		not be in the avail list so we can directly
	//		set the above-threshold flag without trying
	//		to manage the avail list

	if ( fAbove )
		{
		pfcb->SetAboveThreshold();
		}

	FILESetAllIndexMask( pfcb );
	pfcb->SetFixedDDL();
	pfcb->SetTypeTable();

	return JET_errSuccess;

	/*	error handling
	/**/
HandleError:
	// Must clean up secondary index FCBs and primary index FCB separately,
	// because the secondary index FCBs never got linked to the primary
	// index FCB.
	if ( pfcbNil != pfcbSecondaryIndexes )
		CATIFreeSecondaryIndexes( pfcbSecondaryIndexes );

	// No need to explicitly free index name or idxseg array, since
	// memory pool will be freed when TDB is deleted below.
	if ( pfcb->Pidb() != pidbNil )
		{
		pfcb->ReleasePidb();
		pfcb->SetPidb( pidbNil );
		}

	Assert( pfcb->Ptdb() == ptdbNil || pfcb->Ptdb() == ptdb );
	Assert( ptdb != ptdbNil );
	ptdb->Delete( pinst );
	pfcb->SetPtdb( ptdbNil );

	return err;
	}

LOCAL ERR ErrCATIFindHighestColumnid(
	PIB					*ppib,
	FUCB				*pfucbCatalog,
	const OBJID			objidTable,
	const JET_COLUMNID	columnidLeast,
	JET_COLUMNID		*pcolumnidMost )
	{
	ERR					err;
	SYSOBJ				sysobj		= sysobjColumn;
	DATA				dataField;
	BOOL				fLatched	= fFalse;

	Assert( *pcolumnidMost == fidFixedMost
		|| *pcolumnidMost == fidVarMost
		|| *pcolumnidMost == fidTaggedMost );

	//	should be on primary index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)pcolumnidMost,
				sizeof(*pcolumnidMost),
				NO_GRBIT ) );

	//	should never return RecordNotFound, because in the worst
	//	case (ie. no columns), we should seek back to the Table record.
	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekLE );
	Assert( JET_errRecordNotFound != err );
	Call( err );

	Assert( JET_errSuccess == err || JET_wrnSeekNotEqual == err );
	if ( JET_wrnSeekNotEqual == err )
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		fLatched = fTrue;

		Assert( FFixedFid( fidMSO_Type ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Type,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(SYSOBJ) );

		if ( sysobjColumn == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
			{
			Assert( FFixedFid( fidMSO_Id ) );
			Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Id,
						pfucbCatalog->kdfCurr.data,
						&dataField ) );
			CallS( err );
			Assert( dataField.Cb() == sizeof(JET_COLUMNID) );

			Assert( *( (UnalignedLittleEndian< JET_COLUMNID > *)dataField.Pv() ) < *pcolumnidMost );
			Assert( *( (UnalignedLittleEndian< JET_COLUMNID > *)dataField.Pv() ) > 0 );

			JET_COLUMNID colidCur = *( (UnalignedLittleEndian< JET_COLUMNID >  *)dataField.Pv() );
			JET_COLUMNID colidLeast = columnidLeast - 1;
			//	might have found a column of a different type
			*pcolumnidMost = max( colidCur, colidLeast );
			}
		else
			{
			//	if no columns, must have seeked to table record
			Assert( sysobjTable == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
			*pcolumnidMost = columnidLeast - 1;
			}
		}

#ifdef DEBUG
	else
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		fLatched = fTrue;

		Assert( FFixedFid( fidMSO_Id ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Id,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(JET_COLUMNID) );

		//	the highest possible FID actually exists in this table
		Assert( *( (UnalignedLittleEndian< JET_COLUMNID > *)dataField.Pv() ) == *pcolumnidMost );
		}
#endif

HandleError:
	if ( fLatched )
		{
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );
		}

	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	return err;
	}

LOCAL ERR ErrCATIFindAllHighestColumnids(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	TCIB			*ptcib )
	{
	ERR				err;
	FUCB			* pfucbCatalogDupe	= pfucbNil;
	COLUMNID		columnidMost;

	//	use dupe cursor to perform columnid seeks, so we won't
	//	lose our place
	CallR( ErrIsamDupCursor( ppib, pfucbCatalog, &pfucbCatalogDupe, NO_GRBIT ) );
	Assert( pfucbNil != pfucbCatalogDupe );

	//	this is an internal cursor - no dispatch needed
	Assert( pfucbCatalogDupe->pvtfndef == &vtfndefIsam );
	pfucbCatalogDupe->pvtfndef = &vtfndefInvalidTableid;

	columnidMost = fidFixedMost;
	Call( ErrCATIFindHighestColumnid(
				ppib,
				pfucbCatalogDupe,
				objidTable,
				fidFixedLeast,
				&columnidMost ) );
	ptcib->fidFixedLast = FidOfColumnid( columnidMost );
	Assert( ptcib->fidFixedLast == fidFixedLeast-1
		|| FFixedFid( ptcib->fidFixedLast ) );

	columnidMost = fidVarMost;
	Call( ErrCATIFindHighestColumnid(
				ppib,
				pfucbCatalogDupe,
				objidTable,
				fidVarLeast,
				&columnidMost ) );
	ptcib->fidVarLast = FidOfColumnid( columnidMost );
	Assert( ptcib->fidVarLast == fidVarLeast-1
		|| FVarFid( ptcib->fidVarLast ) );

	columnidMost = fidTaggedMost;
	Call( ErrCATIFindHighestColumnid(
				ppib,
				pfucbCatalogDupe,
				objidTable,
				fidTaggedLeast,
				&columnidMost ) );
	ptcib->fidTaggedLast = FidOfColumnid( columnidMost );
	Assert( ptcib->fidTaggedLast == fidTaggedLeast-1
		|| FTaggedFid( ptcib->fidTaggedLast ) );


HandleError:
	Assert( pfucbNil != pfucbCatalogDupe );
	CallS( ErrFILECloseTable( ppib, pfucbCatalogDupe ) );

	return err;
	}


LOCAL ERR ErrCATIFindLowestColumnid(
	PIB					*ppib,
	FUCB				*pfucbCatalog,
	const OBJID			objidTable,
	JET_COLUMNID		*pcolumnidLeast )
	{
	ERR					err;
	SYSOBJ				sysobj		= sysobjColumn;
	DATA				dataField;
	BOOL				fLatched	= fFalse;

	Assert( *pcolumnidLeast == fidFixedLeast
		|| *pcolumnidLeast == fidVarLeast
		|| *pcolumnidLeast == fidTaggedLeast );

	//	should be on primary index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)pcolumnidLeast,
				sizeof(*pcolumnidLeast),
				NO_GRBIT ) );

	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekGE );

	if ( JET_wrnSeekNotEqual == err )
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		fLatched = fTrue;

		Assert( FFixedFid( fidMSO_Type ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Type,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(SYSOBJ) );

		if ( sysobjColumn == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
			{
			Assert( FFixedFid( fidMSO_Id ) );
			Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Id,
						pfucbCatalog->kdfCurr.data,
						&dataField ) );
			CallS( err );
			Assert( dataField.Cb() == sizeof(COLUMNID) );

			Assert( *( (UnalignedLittleEndian< COLUMNID > *)dataField.Pv() ) <= fidMax );
			Assert( *( (UnalignedLittleEndian< COLUMNID > *)dataField.Pv() ) >= fidMin );

			//	note that we might have found a column of a different type
			*pcolumnidLeast = *( (UnalignedLittleEndian< COLUMNID > *)dataField.Pv() );
			}
		else
			{
			//	if no columns, must have seeked on some other object
			Assert( sysobjNil != *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
			*pcolumnidLeast -= 1;
			}
		}

	else if ( JET_errSuccess == err )
		{
#ifdef DEBUG
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		fLatched = fTrue;

		Assert( FFixedFid( fidMSO_Id ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Id,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(COLUMNID) );

		//	the lowest possible FID actually exists in this table
		Assert( *( (UnalignedLittleEndian< COLUMNID > *)dataField.Pv() ) == *pcolumnidLeast );
#endif
		}

	else
		{
		Assert( err < 0 );
		if ( JET_errRecordNotFound == err )
			err = JET_errSuccess;

		*pcolumnidLeast -= 1;
		}

HandleError:
	if ( fLatched )
		{
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );
		}

	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	return err;
	}


/*	Populate a FIELD structure with column info.  Called by ErrCATConstructTDB()
/*	once the proper column has been located.
/**/
LOCAL ERR ErrCATIInitFIELD(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
#ifdef DEBUG
	OBJID		objidTable,
#endif
	TDB			*ptdb,
	COLUMNID	*pcolumnid,
	FIELD		*pfield,
	DATA		&dataDefaultValue )
	{
	ERR			err;
	TDB			*ptdbCatalog;
	DATA		dataField;
	DATA&		dataRec			= pfucbCatalog->kdfCurr.data;

	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( pfcbNil != pfucbCatalog->u.pfcb );
	Assert( pfucbCatalog->u.pfcb->FTypeTable() );
	Assert( pfucbCatalog->u.pfcb->FFixedDDL() );
	Assert( pfucbCatalog->u.pfcb->Ptdb() != ptdbNil );
	ptdbCatalog = pfucbCatalog->u.pfcb->Ptdb();

#ifdef DEBUG
	//	verify still on same table
	Assert( FFixedFid( fidMSO_ObjidTable ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_ObjidTable,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	Assert( objidTable == *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) );

	//	verify this is a column
	Assert( FFixedFid( fidMSO_Type ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Type,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(SYSOBJ) );
	Assert( sysobjColumn == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
#endif


	Assert( FFixedFid( fidMSO_Id ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Id,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(COLUMNID) );
	*pcolumnid = *(UnalignedLittleEndian< COLUMNID > *) dataField.Pv();
//	UtilMemCpy( pfid, dataField.Pv(), sizeof(FID) );
	Assert( FCOLUMNIDValid( *pcolumnid ) );
	Assert( !FCOLUMNIDTemplateColumn( *pcolumnid ) );

	if ( ptdb->FTemplateTable() )
		COLUMNIDSetFTemplateColumn( *pcolumnid );

	Assert( FFixedFid( fidMSO_Coltyp ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Coltyp,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(JET_COLTYP) );
	pfield->coltyp = FIELD_COLTYP( *(UnalignedLittleEndian< JET_COLTYP > *)dataField.Pv() );
//	UtilMemCpy( &pfield->coltyp, dataField.Pv(), sizeof(JET_COLTYP) );
	Assert( pfield->coltyp >= JET_coltypNil );	// May be Nil if column deleted.
	Assert( pfield->coltyp < JET_coltypMax );

	Assert( FFixedFid( fidMSO_SpaceUsage ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_SpaceUsage,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	pfield->cbMaxLen = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( &pfield->cbMaxLen, dataField.Pv(), sizeof(ULONG) );

	Assert( FFixedFid( fidMSO_Localization ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Localization,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	pfield->cp = *(UnalignedLittleEndian< USHORT > *) dataField.Pv();
//	UtilMemCpy( &pfield->cp, dataField.Pv(), sizeof(USHORT) );
	if ( 0 != pfield->cp )
		{
		Assert( FRECTextColumn( pfield->coltyp ) || JET_coltypNil == pfield->coltyp );
		Assert( pfield->cp == usEnglishCodePage || pfield->cp == usUniCodePage );
		}

	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Flags,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	pfield->ffield = *(UnalignedLittleEndian< FIELDFLAG > *) dataField.Pv();
//	UtilMemCpy( &pfield->ffield, dataField.Pv(), sizeof(FIELDFLAG) );
	Assert( !FFIELDVersioned( pfield->ffield ) );	// Versioned flag shouldn't persist.
	Assert( !FFIELDDeleted( pfield->ffield ) );

	Assert( FFixedFid( fidMSO_RecordOffset ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_RecordOffset,
				dataRec,
				&dataField ) );
	if ( JET_wrnColumnNull == err )
		{
		Assert( dataField.Cb() == 0 );
		pfield->ibRecordOffset = 0;		// Set to a dummy value.
		}
	else
		{
		CallS( err );
		Assert( dataField.Cb() == sizeof(REC::RECOFFSET) );
		pfield->ibRecordOffset = *(UnalignedLittleEndian< REC::RECOFFSET > *) dataField.Pv();
//		UtilMemCpy( &pfield->ibRecordOffset, dataField.Pv(), sizeof(REC::RECOFFSET) );
		Assert( pfield->ibRecordOffset >= ibRECStartFixedColumns );
		}

	CHAR	szColumnName[JET_cbNameMost+1];
	Assert( FVarFid( fidMSO_Name ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Name,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() <= JET_cbNameMost );
	UtilMemCpy( szColumnName, dataField.Pv(), dataField.Cb() );
	szColumnName[dataField.Cb()] = 0;		// Add null-termination.

	// Add column name to table's byte pool.  On error, the entire TDB
	// and its byte pool is nuked, so we don't have to worry about
	// freeing the memory for the column name.
	Call( ptdb->MemPool().ErrAddEntry(
				(BYTE *)szColumnName,
				dataField.Cb() + 1,
				&pfield->itagFieldName ) );
		pfield->strhashFieldName = StrHashValue( szColumnName );

	if( FFIELDUserDefinedDefault( pfield->ffield ) )
		{
		//  extract the callback information about this column
		//  add a CBDESC to the TDB

		Assert( FVarFid( fidMSO_Callback ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					ptdbCatalog,
					fidMSO_Callback,
					dataRec,
					&dataField ) );

		Assert( dataField.Cb() > 0 );
		Assert( dataField.Cb() <= JET_cbNameMost );

		CHAR szCallback[JET_cbNameMost+1];
		UtilMemCpy( szCallback, dataField.Pv(), dataField.Cb() );
		szCallback[dataField.Cb()] = '\0';

		JET_CALLBACK callback;
		Call( ErrCALLBACKResolve( szCallback, &callback ) );

		Assert( FTaggedFid( fidMSO_CallbackData ) );
		ULONG cbUserData;
		cbUserData = 0;
		Call( ErrCATIRetrieveTaggedColumn(
				pfucbCatalog,
				fidMSO_CallbackData,
				1,
				dataRec,
				NULL,
				0,
				&cbUserData ) );
		Assert( JET_errSuccess == err
				|| JET_wrnColumnNull == err
				|| JET_wrnBufferTruncated == err );

		CBDESC * pcbdesc;
		pcbdesc = new CBDESC;
		if( NULL == pcbdesc )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		if( 0 == cbUserData )
			{
			pcbdesc->pvContext 	= NULL;
			pcbdesc->cbContext 	= 0;
			}
		else
			{
			pcbdesc->pvContext = (BYTE *)PvOSMemoryHeapAlloc( cbUserData );
			pcbdesc->cbContext 	= cbUserData;

			if( NULL == pcbdesc->pvContext )
				{
				delete pcbdesc;
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			Call( ErrCATIRetrieveTaggedColumn(
					pfucbCatalog,
					fidMSO_CallbackData,
					1,
					dataRec,
					reinterpret_cast<BYTE *>( pcbdesc->pvContext ),
					cbUserData,
					&cbUserData ) );
			Assert( JET_wrnBufferTruncated != err );
			}

		pcbdesc->pcallback 	= callback;
		pcbdesc->cbtyp 		= JET_cbtypUserDefinedDefaultValue;
		pcbdesc->ulId 		= *pcolumnid;
		pcbdesc->fPermanent = 1;
		pcbdesc->fVersioned = 0;

		ptdb->RegisterPcbdesc( pcbdesc );

		ptdb->SetFTableHasUserDefinedDefault();
		ptdb->SetFTableHasNonEscrowDefault();
		ptdb->SetFTableHasDefault();
		}
	else if ( FFIELDDefault( pfield->ffield ) )
		{
		Assert( FVarFid( fidMSO_DefaultValue ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					ptdbCatalog,
					fidMSO_DefaultValue,
					dataRec,
					&dataField ) );
		Assert( dataField.Cb() <= cbDefaultValueMost );
		if ( dataField.Cb() > 0 )
			{
			dataField.CopyInto( dataDefaultValue );
			}
		else
			{
			AssertSz( fFalse, "Null default value detected in catalog." );
			Call( ErrERRCheck( JET_errCatalogCorrupted ) );
			}

		if ( !FFIELDEscrowUpdate( pfield->ffield ) )
			{
			ptdb->SetFTableHasNonEscrowDefault();
			}
		ptdb->SetFTableHasDefault();
		}
#ifdef DEBUG
	else
		{
		Assert( FVarFid( fidMSO_DefaultValue ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					ptdbCatalog,
					fidMSO_DefaultValue,
					dataRec,
					&dataField ) );
		Assert( 0 == dataField.Cb() );
		}
#endif

HandleError:
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	return err;
	}


LOCAL VOID CATPatchFixedOffsets(
	TDB *			ptdb,
	const COLUMNID	columnidLastKnownGood,
	const COLUMNID	columnidCurr )
	{
	Assert( FidOfColumnid( columnidLastKnownGood ) < FidOfColumnid( columnidCurr ) );
	Assert( FidOfColumnid( columnidLastKnownGood ) >= ptdb->FidFixedFirst() - 1 );
	Assert( FCOLUMNIDFixed( columnidCurr ) );
	Assert( FidOfColumnid( columnidCurr ) > ptdb->FidFixedFirst() );
	Assert( FidOfColumnid( columnidCurr ) <= ptdb->FidFixedLastInitial() );

	FIELD *	pfield		= ptdb->PfieldFixed( columnidLastKnownGood + 1 );
	FIELD *	pfieldCurr	= ptdb->PfieldFixed( columnidCurr );

	//	this function is only called if there are columns between the
	//	last known good one and the current one
	Assert( pfield < pfieldCurr );

	if ( FidOfColumnid( columnidLastKnownGood ) == ptdb->FidFixedFirst() - 1 )
		{
		pfield->ibRecordOffset = ptdb->IbEndFixedColumns();
		pfield++;
		}

	for ( ; pfield < pfieldCurr; pfield++ )
		{
		FIELD	* pfieldPrev	= pfield - 1;

		//	we're processing columns that have been removed from the catalog
		//	(either because an AddColumn rolled back or because they got
		//	deleted), so their FIELD structures should be zeroed out
		Assert( 0 == pfield->ibRecordOffset );
		Assert( 0 == pfield->cbMaxLen );
		Assert( JET_coltypNil == pfield->coltyp );
		Assert( pfieldPrev->ibRecordOffset >= ibRECStartFixedColumns );
		Assert( pfieldPrev->ibRecordOffset < pfieldCurr->ibRecordOffset );

		//	set offset to a bogus value (it doesn't matter because since
		//	the column is marked as deleted, we'll never retrieve it)
		//	note that previous column may have also been deleted, in
		//	which case its cbMaxLen will be 0, which is why we have
		//	the max() calculation
		pfield->ibRecordOffset = WORD( pfieldPrev->ibRecordOffset
										+ max( 1, pfieldPrev->cbMaxLen ) );
		Assert( pfield->ibRecordOffset < pfieldCurr->ibRecordOffset );
		}

	Assert( (pfieldCurr-1)->ibRecordOffset + max( 1, (pfieldCurr-1)->cbMaxLen )
		<= pfieldCurr->ibRecordOffset );
	}


INLINE VOID CATSetDeletedColumns( TDB *ptdb )
	{
	FIELD *				pfield		= ptdb->PfieldsInitial();
	const ULONG			cfields		= ptdb->CInitialColumns();
	const FIELD	* const	pfieldMax	= pfield + cfields;

	for ( ; pfield < pfieldMax; pfield++ )
		{
		ptdb->AssertFIELDValid( pfield );
		Assert( !FFIELDVersioned( pfield->ffield ) );
		Assert( !FFIELDDeleted( pfield->ffield ) );
		if ( JET_coltypNil == pfield->coltyp )
			{
			FIELDSetDeleted( pfield->ffield );
			}
		}
	}

LOCAL ERR ErrCATIBuildFIELDArray(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	TDB				*ptdb )
	{
	ERR				err;
	const IFMP		ifmp					= pfucbCatalog->ifmp;
	const SYSOBJ	sysobj					= sysobjColumn;
	FUCB			fucbFake;
	FCB				fcbFake( ifmp, objidTable );	// actually expects a pgnoFDP, but it doesn't matter because it never gets referenced
	COLUMNID		columnid				= 0;
	COLUMNID		columnidPrevFixed;
	FIELD			field;
	DATA			dataField;
#ifdef INTRINSIC_LV
	BYTE			rgbDefaultValue[cbDefaultValueMost];
#else // INTRINSIC_LV
	BYTE			rgbDefaultValue[cbLVIntrinsicMost];
#endif // INTRINSIC_LV
	DATA			dataDefaultValue;

	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	//	move to columns
	err = ErrBTNext( pfucbCatalog, fDIRNull );
	if ( err < 0 )
		{
		Assert( JET_errRecordDeleted != err );
		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		if ( JET_errNoCurrentRecord != err )
			return err;
		}

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	dataDefaultValue.SetPv( rgbDefaultValue );
	FILEPrepareDefaultRecord( &fucbFake, &fcbFake, ptdb );
	Assert( fucbFake.pvWorkBuf != NULL );

	columnidPrevFixed = ColumnidOfFid( ptdb->FidFixedFirst(), ptdb->FTemplateTable() ) - 1;

	//	UPDATE: use new FInitialisingDefaultRecord() flag instead of
	//	fudging FidFixedLast()
/*	//	must reset FidFixedLast to silence DEBUG checks in
	//	SetIbEndFixedColumns() and IbOffsetOfNextColumn()
	const FID	fidFixedLastSave	= ptdb->FidFixedLast();
	ptdb->SetFidFixedLast( FID( ptdb->FidFixedFirst() - 1 ) );
*/

	while ( JET_errNoCurrentRecord != err )
		{
		BOOL	fAddDefaultValue	= fFalse;

		Call( err );

		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		Assert( FFixedFid( fidMSO_ObjidTable ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_ObjidTable,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(OBJID) );
		if ( objidTable != *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) )
			{
			goto DoneFields;
			}

		//	verify this is a column
		Assert( FFixedFid( fidMSO_Type ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Type,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(SYSOBJ) );
		switch( *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
			{
			case sysobjColumn:
				break;

			case sysobjTable:
				AssertSz( fFalse, "Catalog corrupted - sysobj in invalid order." );
				err = ErrERRCheck( JET_errCatalogCorrupted );
				goto HandleError;

			default:
				goto DoneFields;
			}

		err = ErrCATIInitFIELD(
					ppib,
					pfucbCatalog,
#ifdef DEBUG
					objidTable,
#endif
					ptdb,
					&columnid,
					&field,
					dataDefaultValue );
		Call( err );

		Assert( FCOLUMNIDValid( columnid ) );
		const BOOL	fFixedColumn	= FCOLUMNIDFixed( columnid );
		if ( fFixedColumn )
			{
			Assert( FidOfColumnid( columnid ) >= ptdb->FidFixedFirst() );
			Assert( FidOfColumnid( columnid ) <= ptdb->FidTaggedLast() );
			}

		// If field is deleted, the coltyp for the FIELD entry should
		// already be JET_coltypNil (initialised that way).
		Assert( field.coltyp != JET_coltypNil
			|| ptdb->Pfield( columnid )->coltyp == JET_coltypNil );

		Assert( ( FCOLUMNIDTemplateColumn( columnid ) && ptdb->FTemplateTable() )
			|| ( !FCOLUMNIDTemplateColumn( columnid ) && !ptdb->FTemplateTable() ) );
		if ( ptdb->FTemplateTable() )
			{
			if ( !FFIELDTemplateColumnESE98( field.ffield ) )
				{
				ptdb->SetFESE97TemplateTable();

				if ( FCOLUMNIDTagged( columnid )
					&& FidOfColumnid( columnid ) > ptdb->FidTaggedLastOfESE97Template() )
					{
					ptdb->SetFidTaggedLastOfESE97Template( FidOfColumnid( columnid ) );
					}
				}
			}
		else if ( ptdb->FDerivedTable() )
			{
			FID		fidFirst;

			if ( FCOLUMNIDTagged( columnid ) )
				{
				fidFirst = ptdb->FidTaggedFirst();
				}
			else if ( FCOLUMNIDFixed( columnid ) )
				{
				fidFirst = ptdb->FidFixedFirst();
				}
			else
				{
				Assert( FCOLUMNIDVar( columnid ) );
				fidFirst = ptdb->FidVarFirst();
				}
			if ( FidOfColumnid( columnid ) < fidFirst )
				{
				Call( ErrERRCheck( JET_errDerivedColumnCorruption ) );
				}
			}

		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		if ( field.coltyp != JET_coltypNil )
			{
			Call( ErrRECAddFieldDef( ptdb, columnid, &field ) );

			/*	set version and auto increment field ids (these are mutually
			/*	exclusive (ie. a field can't be both version and autoinc).
			/**/
			Assert( ptdb->FidVersion() != ptdb->FidAutoincrement()
				|| ptdb->FidVersion() == 0 );
			if ( FFIELDVersion( field.ffield ) )
				{
				ptdb->SetFidVersion( FidOfColumnid( columnid ) );
				}
			if ( FFIELDAutoincrement( field.ffield ) )
				{
				ptdb->SetFidAutoincrement( FidOfColumnid( columnid ), field.coltyp == JET_coltypCurrency );
				}

			if ( fFixedColumn )
				{
				Assert( field.ibRecordOffset >= ibRECStartFixedColumns );
				Assert( field.cbMaxLen > 0 );

				Assert( FidOfColumnid( columnidPrevFixed ) <= FidOfColumnid( columnid ) - 1 );
				if ( FidOfColumnid( columnidPrevFixed ) < FidOfColumnid( columnid ) - 1 )
					{
					CATPatchFixedOffsets( ptdb, columnidPrevFixed, columnid );
					}
				columnidPrevFixed = columnid;

				//	Set the last offset.
				ptdb->SetIbEndFixedColumns(
							WORD( field.ibRecordOffset + field.cbMaxLen ),
							FidOfColumnid( columnid ) );
				}

			fAddDefaultValue = ( FFIELDDefault( field.ffield )
								&& !FFIELDUserDefinedDefault( field.ffield ) );
			}

		else if ( FCOLUMNIDTagged( columnid ) )
			{
			Assert( FidOfColumnid( columnid ) >= ptdb->FidTaggedFirst() );
			Assert( FidOfColumnid( columnid ) <= ptdb->FidTaggedLast() );
			if ( FidOfColumnid( columnid ) < ptdb->FidTaggedLast()
				&& !fGlobalRepair
				&& !rgfmp[ifmp].FReadOnlyAttach()
				&& JET_errSuccess == ErrPIBCheckUpdatable( ppib ) )
				{
				// Clean up unnecessary MSysColumn entries.
				Call( ErrBTRelease( pfucbCatalog ) );
				Call( ErrIsamDelete( ppib, pfucbCatalog ) );
				}
			}
		else if ( fFixedColumn )
			{
			// For deleted fixed columns, we still need its fixed offset.
			// In addition, we also need its length if it is the last fixed
			// column.  We use this length in order to calculate the
			// offset to the rest of the record (past the fixed data).
			Assert( ptdb->Pfield( columnid )->coltyp == JET_coltypNil );
			Assert( ptdb->Pfield( columnid )->cbMaxLen == 0 );
			Assert( field.ibRecordOffset >= ibRECStartFixedColumns );
			Assert( field.cbMaxLen > 0 );

			ptdb->PfieldFixed( columnid )->ibRecordOffset = field.ibRecordOffset;
			ptdb->PfieldFixed( columnid )->cbMaxLen = field.cbMaxLen;

			Assert( FidOfColumnid( columnidPrevFixed ) <= FidOfColumnid( columnid ) - 1 );
			if ( FidOfColumnid( columnidPrevFixed ) < FidOfColumnid( columnid ) - 1 )
				{
				CATPatchFixedOffsets( ptdb, columnidPrevFixed, columnid );
				}
			columnidPrevFixed = columnid;

			//	Set the last offset.
			ptdb->SetIbEndFixedColumns(
						WORD( field.ibRecordOffset + field.cbMaxLen ),
						FidOfColumnid( columnid ) );
			}
		else
			{
			Assert( FCOLUMNIDVar( columnid ) );
			Assert( FidOfColumnid( columnid ) >= ptdb->FidVarFirst() );
			Assert( FidOfColumnid( columnid ) <= ptdb->FidVarLast() );
			if ( FidOfColumnid( columnid ) < ptdb->FidVarLast()
				&& !fGlobalRepair
				&& !rgfmp[ifmp].FReadOnlyAttach()
				&& JET_errSuccess == ErrPIBCheckUpdatable( ppib ) )
				{
				// Clean up unnecessary MSysColumn entries.
				Call( ErrBTRelease( pfucbCatalog ) );
				Call( ErrIsamDelete( ppib, pfucbCatalog ) );
				}
			}

		if ( fAddDefaultValue )
			{
			Assert( FFIELDDefault( field.ffield ) );
			Assert( !FFIELDUserDefinedDefault( field.ffield ) );
			Assert( JET_coltypNil != field.coltyp );
			Assert( FCOLUMNIDValid( columnid ) );

			// Only long values are allowed to be greater than cbColumnMost.
			Assert( dataDefaultValue.Cb() > 0 );
			Assert(	FRECLongValue( field.coltyp ) ?
						dataDefaultValue.Cb() <= JET_cbLVDefaultValueMost :
						dataDefaultValue.Cb() <= JET_cbColumnMost );

			ptdb->SetFInitialisingDefaultRecord();

			err = ErrRECSetDefaultValue( &fucbFake, columnid, dataDefaultValue.Pv(), dataDefaultValue.Cb() );
			CallS( err );

			ptdb->ResetFInitialisingDefaultRecord();

			Call( err );
			}

		err = ErrBTNext( pfucbCatalog, fDIRNull );

		//	we may have just deleted the record for a
		//	deleted column, and we may be at level 0,
		//	so the record may have gotten expunged
		if ( JET_errRecordDeleted == err )
			{
			BTSetupOnSeekBM( pfucbCatalog );
			err = ErrBTPerformOnSeekBM( pfucbCatalog, fDIRFavourNext );
			Assert( JET_errNoCurrentRecord != err );
			Assert( JET_errRecordDeleted != err );

			//	we never delete the highest columnid,
			//	so there must be at least one left
			Assert( JET_errRecordNotFound != err );
			Call( err );

			Assert( wrnNDFoundLess == err
				|| wrnNDFoundGreater == err );
			Assert( Pcsr( pfucbCatalog )->FLatched() );

			if ( wrnNDFoundGreater == err )
				{
				err = JET_errSuccess;
				}
			else
				{
				Assert( wrnNDFoundLess == err );
				err = ErrBTNext( pfucbCatalog, fDIRNull );
				Assert( JET_errNoCurrentRecord != err );
				Assert( JET_errRecordNotFound != err );
				Assert( JET_errRecordDeleted != err );
				}

			pfucbCatalog->locLogical = locOnCurBM;
			}
		}	//	while ( JET_errNoCurrentRecord != err )

	//	verify we didn't unexpectedly break out
	Assert( JET_errNoCurrentRecord == err );

	//	only way to get here is to hit the end of the catalog
	err = ErrERRCheck( wrnCATNoMoreRecords );


DoneFields:

	// Set Deleted bit for all deleted columns.
	CATSetDeletedColumns( ptdb );

	//	in case we have to chain together the buffers (to keep
	//	around copies of previous of old default records
	//	because other threads may have stale pointers),
	//	allocate a RECDANGLING buffer to preface the actual
	//	default record
	//
	RECDANGLING *	precdangling;

	precdangling = (RECDANGLING *)PvOSMemoryHeapAlloc( sizeof(RECDANGLING) + fucbFake.dataWorkBuf.Cb() );
	if ( NULL == precdangling )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	precdangling->precdanglingNext = NULL;
	precdangling->data.SetPv( (BYTE *)precdangling + sizeof(RECDANGLING) );
	fucbFake.dataWorkBuf.CopyInto( precdangling->data );
	ptdb->SetPdataDefaultRecord( &( precdangling->data ) );

HandleError:
	Assert( JET_errRecordDeleted != err );

	FILEFreeDefaultRecord( &fucbFake );

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() || err < 0 );

	return err;
	}


/*	construct a table TDB from the column info in the catalog
/**/
INLINE ERR ErrCATIInitTDB(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	const CHAR		*szTableName,
	const BOOL		fTemplateTable,
	FCB				*pfcbTemplateTable,
	TDB				**pptdbNew )
	{
	ERR    			err;
	TDB				*ptdb		= ptdbNil;
	TCIB			tcib		= { fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1 };
	INST			*pinst		= PinstFromPpib( ppib );
	BOOL			fOldFormat	= fFalse;

	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	Call( ErrCATIFindAllHighestColumnids(
				ppib,
				pfucbCatalog,
				objidTable,
				&tcib ) );

	Call( ErrTDBCreate( pinst, &ptdb, &tcib, pfcbTemplateTable, fTrue ) );

	Assert( ptdb->FidVersion() == 0 );
	Assert( ptdb->FidAutoincrement() == 0 );
	Assert( tcib.fidFixedLast == ptdb->FidFixedLast() );
	Assert( tcib.fidVarLast == ptdb->FidVarLast() );
	Assert( tcib.fidTaggedLast == ptdb->FidTaggedLast() );
	Assert( ptdb->DbkMost() == 0 );
	Assert( ptdb->PfcbLV() == pfcbNil );
	Assert( ptdb->UlLongIdLast() == 0 );

	// Add table name.
	Assert( ptdb->ItagTableName() == 0 );
	MEMPOOL::ITAG	itagNew;
	Call( ptdb->MemPool().ErrAddEntry(
				(BYTE *)szTableName,
				(ULONG)strlen( szTableName ) + 1,
				&itagNew ) );
	Assert( itagNew == itagTDBTableName );
	ptdb->SetItagTableName( itagNew );

	// Inherit fidAutoinc and/or fidVersion from base table.
	Assert( ptdb->PfcbTemplateTable() == pfcbTemplateTable );

	if ( fTemplateTable )
		{
		ptdb->SetFTemplateTable();
		Assert( pfcbNil == pfcbTemplateTable );
		}
	else if ( pfcbNil != pfcbTemplateTable )
		{
		FID		fidT;

		Assert( ptdb->PfcbTemplateTable() == pfcbTemplateTable );
		ptdb->SetFDerivedTable();
		if ( ptdb->PfcbTemplateTable()->Ptdb()->FESE97TemplateTable() )
			ptdb->SetFESE97DerivedTable();

		// Can't have same fidAutoInc and fidVersion.
		fidT = pfcbTemplateTable->Ptdb()->FidAutoincrement();
		if ( fidT != 0 )
			{
			Assert( fidT != pfcbTemplateTable->Ptdb()->FidVersion() );
			ptdb->SetFidAutoincrement( FidOfColumnid( fidT ), pfcbTemplateTable->Ptdb()->F8BytesAutoInc() );
			}

		fidT = pfcbTemplateTable->Ptdb()->FidVersion();
		if ( fidT != 0 )
			{
			Assert( fidT != pfcbTemplateTable->Ptdb()->FidAutoincrement() );
			ptdb->SetFidVersion( fidT );
			}
		}

	Call( ErrCATIBuildFIELDArray( ppib, pfucbCatalog, objidTable, ptdb ) );
	CallSx( err, wrnCATNoMoreRecords );

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	*pptdbNew	= ptdb;

	return err;


HandleError:
	Assert( err < 0 );

	// Delete TDB on error.
	if ( ptdbNil != ptdb )
		ptdb->Delete( pinst );

	Assert( locOnCurBM == pfucbCatalog->locLogical );

	return err;
	}


enum INDEX_UNICODE_STATE
	{
	INDEX_UNICODE_GOOD,
	INDEX_UNICODE_DELETE,
	INDEX_UNICODE_FIXUP,
	};

//  ================================================================
LOCAL ERR ErrIndexUnicodeState(
	IN const LCID	lcid,
	IN const QWORD 	qwVersionCreated,
	IN const BOOL	fUnicodeFixupEnabled,
	OUT INDEX_UNICODE_STATE * const pState )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	if( !FNORMStringHasUndefinedCharsIsSupported() )
		{
		//	if we don't have the needed API's we have to delete all the indexes
		*pState = INDEX_UNICODE_DELETE;
		}
	else if( 0 == qwVersionCreated )
		{
		*pState = INDEX_UNICODE_DELETE;
		}
	else
		{
		const DWORD dwNLSVersionCreated 	= DwNLSVersionFromSortVersion( qwVersionCreated );
		const DWORD dwDefinedVersionCreated = DwDefinedVersionFromSortVersion( qwVersionCreated );

		QWORD qwVersionCurrent;
		Call( ErrNORMGetSortVersion( lcid, &qwVersionCurrent ) );

		DWORD dwNLSVersionCurrent;
		DWORD dwDefinedVersionCurrent;
		dwNLSVersionCurrent 	= DwNLSVersionFromSortVersion( qwVersionCurrent );
		dwDefinedVersionCurrent = DwDefinedVersionFromSortVersion( qwVersionCurrent );

		if( dwNLSVersionCreated != dwNLSVersionCurrent )
			{
			//	the actual sort order has changed. this index must be deleted
			*pState = INDEX_UNICODE_DELETE;
			}
		else if( dwDefinedVersionCreated < dwDefinedVersionCurrent )
			{
			if( fUnicodeFixupEnabled )
				{
				//	the set of defined characters has grown, the unicode fixup table can handle this
				*pState = INDEX_UNICODE_FIXUP;
				}
			else
				{
				*pState = INDEX_UNICODE_DELETE;
				}
			}
		else if( dwDefinedVersionCreated > dwDefinedVersionCurrent )
			{
			//	the set of defined characters has shrunk. even the unicode fixup table cannot deal with this
			*pState = INDEX_UNICODE_DELETE;
			}
		else
			{
			//	nothing has changed
			Assert( dwDefinedVersionCreated == dwDefinedVersionCurrent );
			*pState = INDEX_UNICODE_GOOD;
			}
		}

HandleError:
	return err;
	}



/*	Populate an IDB structure with index info.
/**/
LOCAL ERR ErrCATIInitIDB(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
#ifdef DEBUG
	OBJID		objidTable,
#endif
	TDB			* const ptdb,
	IDB			* const pidb,
	PGNO		*ppgnoIndexFDP,
	OBJID		*ppgnoObjidFDP,
	ULONG_PTR	*pul )	// Density if non-derived index, pfcbTemplateIndex if derived index
	{
	ERR		err;
	TDB		*ptdbCatalog;
	DATA	dataField;
	CHAR	szIndexName[ JET_cbNameMost+1 ];

	Assert( ptdbNil != ptdb );
	Assert( pidbNil != pidb );
	Assert( NULL != pul );

	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	DATA&	dataRec = pfucbCatalog->kdfCurr.data;

	Assert( pfcbNil != pfucbCatalog->u.pfcb );
	Assert( pfucbCatalog->u.pfcb->FTypeTable() );
	Assert( pfucbCatalog->u.pfcb->FFixedDDL() );
	Assert( pfucbCatalog->u.pfcb->Ptdb() != ptdbNil );
	ptdbCatalog = pfucbCatalog->u.pfcb->Ptdb();


#ifdef DEBUG
	//	verify still on same table
	Assert( FFixedFid( fidMSO_ObjidTable ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_ObjidTable,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	Assert( objidTable == *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) );

	//	verify this is an index
	Assert( FFixedFid( fidMSO_Type ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Type,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(SYSOBJ) );
	Assert( sysobjIndex == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
#endif

	Assert( FVarFid( fidMSO_Name ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Name,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() > 0 );
	Assert( dataField.Cb() <= JET_cbNameMost );
	UtilMemCpy( szIndexName, dataField.Pv(), dataField.Cb() );
	szIndexName[dataField.Cb()] = 0;

	Assert( FFixedFid( fidMSO_PgnoFDP ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_PgnoFDP,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(PGNO) );
	*ppgnoIndexFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//	UtilMemCpy( ppgnoIndexFDP, dataField.Pv(), sizeof(PGNO) );

	Assert( FFixedFid( fidMSO_Id ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Id,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	*ppgnoObjidFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//	UtilMemCpy( ppgnoObjidFDP, dataField.Pv(), sizeof(PGNO) );

	LE_IDXFLAG*	ple_idxflag;
	IDXFLAG		idxflag;
	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Flags,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ple_idxflag = (LE_IDXFLAG*)dataField.Pv();
	pidb->SetPersistedFlags( ple_idxflag->fidb );
	idxflag = ple_idxflag->fIDXFlags;

	//	verify flags that shouldn't be persisted, aren't
	Assert( !pidb->FVersioned() );
	Assert( !pidb->FVersionedCreate() );
	Assert( !pidb->FDeleted() );

	if ( pidb->FDerivedIndex() )
		{
		FCB	*pfcbTemplateIndex = ptdb->PfcbTemplateTable();
		Assert( pfcbNil != pfcbTemplateIndex );
		TDB	*ptdbTemplate = pfcbTemplateIndex->Ptdb();
		Assert( ptdbNil != ptdbTemplate );

		forever
			{
			Assert( pfcbNil != pfcbTemplateIndex );
			if ( pfcbTemplateIndex->Pidb() == pidbNil )
				{
				Assert( pfcbTemplateIndex == ptdb->PfcbTemplateTable() );
				Assert( pfcbTemplateIndex->FPrimaryIndex() );
				Assert( pfcbTemplateIndex->FSequentialIndex() );
				Assert( pfcbTemplateIndex->FTypeTable() );
				}
			else
				{
				if ( pfcbTemplateIndex == ptdb->PfcbTemplateTable() )
					{
					Assert( pfcbTemplateIndex->FPrimaryIndex() );
					Assert( !pfcbTemplateIndex->FSequentialIndex() );
					Assert( pfcbTemplateIndex->FTypeTable() );
					}
				else
					{
					Assert( pfcbTemplateIndex->FTypeSecondaryIndex() );
					}
				const USHORT	itagTemplateIndex = pfcbTemplateIndex->Pidb()->ItagIndexName();
				if ( UtilCmpName( szIndexName, ptdbTemplate->SzIndexName( itagTemplateIndex ) ) == 0 )
					break;
				}

			pfcbTemplateIndex = pfcbTemplateIndex->PfcbNextIndex();
			}

		*pul = (ULONG_PTR)pfcbTemplateIndex;

		return JET_errSuccess;
		}

	Assert( FFixedFid( fidMSO_SpaceUsage ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_SpaceUsage,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ULONG	ulDensity;
	ulDensity = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( &ulDensity, dataField.Pv(), sizeof(ULONG) );
	Assert( ulDensity >= ulFILEDensityLeast );
	Assert( ulDensity<= ulFILEDensityMost );

	//	WARNING: Can't copy directly to pul because it may be 64-bit
	*pul = ulDensity;

	Assert( FFixedFid( fidMSO_Localization ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Localization,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(LCID) );
	pidb->SetLcid( *(UnalignedLittleEndian< LCID > *) dataField.Pv() );
//	UtilMemCpy( &pidb->lcid, dataField.Pv(), sizeof(LCID) );

	if ( lcidNone == pidb->Lcid() )
		{
		//	old format: fLocaleId is FALSE and lcid == 0
		//	force lcid to default value
		Assert( !pidb->FLocaleId() );
		pidb->SetLcid( lcidDefault );
		}
	else if ( pidb->FLocalizedText() )
		{
		if ( pidb->Lcid() != lcidDefault
			&& pidb->Lcid() != PinstFromPpib( ppib )->m_idxunicodeDefault.lcid )
			{
			Call( ErrNORMCheckLcid( PinstFromPpib( ppib ), pidb->Lcid() ) );
			}
		else
			{
			Assert( JET_errSuccess == ErrNORMCheckLcid( PinstFromPpib( ppib ), pidb->Lcid() ) );
			}

		//	if the index includes a unicode column we need to see if the
		//	sort-order for that column has changed

		Assert( FVarFid( fidMSO_Version ) );
		Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Version,
				dataRec,
				&dataField ) );
		if( JET_wrnColumnNull == err )
			{
			//	this index was created without any sort-order versioning
			//	we'll assume the worst and say the sort-order version is bad
			//	this flag should only be used by the routine that deletes localized
			//	indexes -- i.e. don't Assert( !FBadSortVersion()) as if the
			//	OS version hasn't changed the flag wil lbe set for all legacy indexes
			pidb->SetFBadSortVersion();
			}
		else
			{
			CallS( err );
			Assert( dataField.Cb() == sizeof( QWORD ) );
			const QWORD qwVersionCreated = *(UnalignedLittleEndian< QWORD > *) dataField.Pv();

			INDEX_UNICODE_STATE state;
			Call( ErrIndexUnicodeState( pidb->Lcid(), qwVersionCreated, pidb->FUnicodeFixupOn(), &state ) );

			switch( state )
				{
				case INDEX_UNICODE_DELETE:
					pidb->SetFBadSortVersion();
					break;
				case INDEX_UNICODE_FIXUP:
				case INDEX_UNICODE_GOOD:
					Assert( !pidb->FBadSortVersion() );
					break;
				default:
					FireWall();
					break;
				}
			}
		}

	Assert( FFixedFid( fidMSO_LCMapFlags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_LCMapFlags,
				dataRec,
				&dataField ) );
	if ( dataField.Cb() == 0 )
		{
		Assert( JET_wrnColumnNull == err );

		//	old format: fLocaleId is FALSE and lcid == 0
		//	(forced above to default value)
		pidb->SetDwLCMapFlags( dwLCMapFlagsDefaultOBSOLETE );
		}
	else
		{
		CallS( err );
		Assert( dataField.Cb() == sizeof(DWORD) );
		pidb->SetDwLCMapFlags( *(UnalignedLittleEndian< DWORD > *) dataField.Pv() );
//		UtilMemCpy( &dwMapFlags, dataField.Pv(), sizeof(DWORD) );
		Assert( JET_errSuccess == ErrNORMCheckLCMapFlags( PinstFromPpib( ppib ), pidb->DwLCMapFlags() ) );
		}

	// UNDONE: make VarSegMac an array parallel to
	// KeyFldIDs so cbVarSegMac can be specified
	// on a per-field basis
	Assert( FVarFid( fidMSO_VarSegMac ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_VarSegMac,
				dataRec,
				&dataField ) );
	if ( dataField.Cb() == 0 )
		{
		Assert( JET_wrnColumnNull == err );
		pidb->SetCbVarSegMac( BYTE( KEY::CbKeyMost( pidb->FPrimary() ) ) );
		}
	else
		{
		CallS( err );
		Assert( dataField.Cb() == sizeof(USHORT) );
		Assert( *( (UnalignedLittleEndian<USHORT> *)dataField.Pv()) <= 0xff );	//  we will store this in one byte
		pidb->SetCbVarSegMac( BYTE( *(UnalignedLittleEndian< USHORT > *)dataField.Pv() ) );
//		UtilMemCpy( &pidb->cbVarSegMac, dataField.Pv(), sizeof(pidb->cbVarSegMac) );
		Assert( pidb->CbVarSegMac() > 0 );
		Assert( pidb->CbVarSegMac() < KEY::CbKeyMost( pidb->FPrimary() ) );
		}

	Assert( FVarFid( fidMSO_KeyFldIDs ) );
	Call( ErrRECIRetrieveVarColumn(
			pfcbNil,
			ptdbCatalog,
			fidMSO_KeyFldIDs,
			dataRec,
			&dataField ) );
	CallS( err );
	Assert( dataField.Cb() > 0 );

	// the length of the list of key fields should be a multiple
	// of the length of one field.
	if ( FIDXExtendedColumns( idxflag ) )
		{
		Assert( sizeof(IDXSEG) == sizeof(JET_COLUMNID) );
		Assert( dataField.Cb() <= sizeof(JET_COLUMNID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(JET_COLUMNID) == 0 );
		Assert( dataField.Cb() / sizeof(JET_COLUMNID) <= JET_ccolKeyMost );
		pidb->SetCidxseg( (BYTE)( dataField.Cb() / sizeof(JET_COLUMNID) ) );
		Call( ErrIDBSetIdxSeg( pidb, ptdb, fFalse, ( const LE_IDXSEG* const )dataField.Pv() ) );
		}
	else
		{
		Assert( sizeof(IDXSEG_OLD) == sizeof(FID) );
		Assert( dataField.Cb() <= sizeof(FID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(FID) == 0);
		Assert( dataField.Cb() / sizeof(FID) <= JET_ccolKeyMost );
		pidb->SetCidxseg( (BYTE)( dataField.Cb() / sizeof(FID) ) );
		Call( ErrIDBSetIdxSegFromOldFormat(
					pidb,
					ptdb,
					fFalse,
					(UnalignedLittleEndian< IDXSEG_OLD > *)dataField.Pv() ) );
		}


	Assert( FVarFid( fidMSO_ConditionalColumns ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_ConditionalColumns,
				dataRec,
				&dataField ) );

	// the length of the list of key fields should be a multiple
	// of the length of one field.
	if ( FIDXExtendedColumns( idxflag ) )
		{
		Assert( sizeof(IDXSEG) == sizeof(JET_COLUMNID) );
		Assert( dataField.Cb() <= sizeof(JET_COLUMNID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(JET_COLUMNID) == 0 );
		Assert( dataField.Cb() / sizeof(JET_COLUMNID) <= JET_ccolKeyMost );
		pidb->SetCidxsegConditional( (BYTE)( dataField.Cb() / sizeof(JET_COLUMNID) ) );
		Call( ErrIDBSetIdxSeg( pidb, ptdb, fTrue, (LE_IDXSEG*)dataField.Pv() ) );
		}
	else
		{
		Assert( sizeof(IDXSEG_OLD) == sizeof(FID) );
		Assert( dataField.Cb() <= sizeof(FID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(FID) == 0);
		Assert( dataField.Cb() / sizeof(FID) <= JET_ccolKeyMost );
		pidb->SetCidxsegConditional( (BYTE)( dataField.Cb() / sizeof(FID) ) );
		Call( ErrIDBSetIdxSegFromOldFormat(
					pidb,
					ptdb,
					fTrue,
					(UnalignedLittleEndian< IDXSEG_OLD > *)dataField.Pv() ) );
		}


	Assert( FVarFid( fidMSO_TupleLimits ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_TupleLimits,
				dataRec,
				&dataField ) );
	if ( dataField.Cb() == 0 )
		{
		Assert( JET_wrnColumnNull == err );
		}
	else
		{
		CallS( err );
		Assert( dataField.Cb() == sizeof(LE_TUPLELIMITS) );

		const LE_TUPLELIMITS * const	ple_tuplelimits		= (LE_TUPLELIMITS *)dataField.Pv();
		ULONG							ul;

		pidb->SetFTuples();

		ul = ple_tuplelimits->le_chLengthMin;
		pidb->SetChTuplesLengthMin( (USHORT)ul );

		ul = ple_tuplelimits->le_chLengthMax;
		pidb->SetChTuplesLengthMax( (USHORT)ul );

		ul = ple_tuplelimits->le_chToIndexMax;
		pidb->SetChTuplesToIndexMax( (USHORT)ul );
		}


	// Add index name to table's byte pool.  On error, the entire TDB
	// and its byte pool is nuked, so we don't have to worry about
	// freeing the memory for the index name.
	USHORT	itagIndexName;
	Call( ptdb->MemPool().ErrAddEntry(
						(BYTE *)szIndexName,
						(ULONG)strlen( szIndexName ) + 1,
						&itagIndexName ) );
	pidb->SetItagIndexName( itagIndexName );

HandleError:
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	return err;
	}

LOCAL ERR ErrCATIInitIndexFCBs(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	FCB				* const pfcb,
	TDB				* const ptdb,
	const ULONG		ulDefaultDensity )
	{
	ERR				err						= JET_errSuccess;
	const IFMP		ifmp					= pfcb->Ifmp();
	const SYSOBJ	sysobj					= sysobjIndex;
	FCB				*pfcbSecondaryIndexes	= pfcbNil;
	BOOL			fFoundPrimary			= fFalse;
	BOOL			fAbove					= fFalse;

	Assert( pfcb->Pidb() == pidbNil );
	Assert( ptdbNil != ptdb );

	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	do
		{
		DATA		dataField;
		IDB			idb;
		PGNO		pgnoIndexFDP;
		OBJID		objidIndexFDP;
		ULONG_PTR	ul;

		Call( err );

		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		Assert( FFixedFid( fidMSO_ObjidTable ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_ObjidTable,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(OBJID) );
		if ( objidTable != *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) )
			{
			goto CheckPrimary;
			}

		//	verify this is an index
		Assert( FFixedFid( fidMSO_Type ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Type,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(SYSOBJ) );
		switch ( *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
			{
			case sysobjIndex:
				break;

			case sysobjLongValue:
			case sysobjCallback:
				goto CheckPrimary;

			case sysobjTable:
			case sysobjColumn:
			default:
				AssertSz( fFalse, "Catalog corrupted - sysobj in invalid order." );
				err = ErrERRCheck( JET_errCatalogCorrupted );
				goto HandleError;
			}


		/*	read the data
		/**/
		err = ErrCATIInitIDB(
					ppib,
					pfucbCatalog,
#ifdef DEBUG
					objidTable,
#endif
					ptdb,
					&idb,
					&pgnoIndexFDP,
					&objidIndexFDP,
					&ul );	// returns density for non-derived index, and pfcbTemplateIndex for derived index
		Call( err );

		if ( idb.FPrimary() )
			{
			Assert( !fFoundPrimary );
			fFoundPrimary = fTrue;
			Assert( pgnoIndexFDP == pfcb->PgnoFDP() || fGlobalRepair );
			Call( ErrFILEIInitializeFCB(
				ppib,
				ifmp,
				ptdb,
				pfcb,
				&idb,
				fTrue,
				pfcb->PgnoFDP(),
				ul ) );
			pfcb->SetInitialIndex();
			}
		else
			{
			FUCB	*pfucbSecondaryIndex;

			Assert( pgnoIndexFDP != pfcb->PgnoFDP() || fGlobalRepair );
			Call( ErrDIROpenNoTouch(
						ppib,
						ifmp,
						pgnoIndexFDP,
						objidIndexFDP,
						idb.FUnique(),
						&pfucbSecondaryIndex ) );
			Assert( !pfucbSecondaryIndex->u.pfcb->FInitialized() );

			err = ErrFILEIInitializeFCB(
					ppib,
					ifmp,
					ptdb,
					pfucbSecondaryIndex->u.pfcb,
					&idb,
					fFalse,
					pgnoIndexFDP,
					ul );
			if ( err < 0 )
				{
				DIRClose( pfucbSecondaryIndex );
				goto HandleError;
				}
			Assert( pfucbSecondaryIndex->u.pfcb->ObjidFDP() == objidIndexFDP );

			pfucbSecondaryIndex->u.pfcb->SetPfcbNextIndex( pfcbSecondaryIndexes );
			pfcbSecondaryIndexes = pfucbSecondaryIndex->u.pfcb;

			Assert( pfucbSecondaryIndex->u.pfcb->FAboveThreshold() ==
					BOOL( pfucbSecondaryIndex->u.pfcb >= PfcbFCBPreferredThreshold( PinstFromPpib( ppib ) ) ) );
			fAbove |= pfucbSecondaryIndex->u.pfcb->FAboveThreshold();

			//	mark the secondary index as being initialized successfully

			pfucbSecondaryIndex->u.pfcb->SetInitialIndex();
			pfucbSecondaryIndex->u.pfcb->CreateComplete();

			DIRClose( pfucbSecondaryIndex );
			}

		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		err = ErrBTNext( pfucbCatalog, fDIRNull );
		Assert( JET_errRecordDeleted != err );
		}
	while ( JET_errNoCurrentRecord != err );

	//	verify we didn't unexpectedly break out
	Assert( JET_errNoCurrentRecord == err );

	//	only way to get here is to hit the end of the catalog
	err = ErrERRCheck( wrnCATNoMoreRecords );


CheckPrimary:
	CallSx( err, wrnCATNoMoreRecords );

	if ( !fFoundPrimary )
		{
		const ERR	errInit	= ErrFILEIInitializeFCB(
										ppib,
										ifmp,
										ptdb,
										pfcb,
										pidbNil,
										fTrue,
										pfcb->PgnoFDP(),
										ulDefaultDensity );
		if ( errInit < 0 )
			{
			err = errInit;
			goto HandleError;
			}

		//	should be success, so just ignore it (to preserve wrnCATNoMoreRecords)
		CallS( errInit );
		}

	/*	link up sequential/primary index with the rest of the indexes
	/**/
	pfcb->SetPfcbNextIndex( pfcbSecondaryIndexes );

	/*	link up pfcbTable of secondary indexes
	/**/
	pfcb->LinkPrimaryIndex();

	//	set the above-threshold flag if any of the new
	//		secondary-index FCBs are above the threshold
	//
	//	since the FCB is pinned by pfucbTable, it will
	//		not be in the avail list so we can directly
	//		set the above-threshold flag without trying
	//		to manage the avail list

	if ( fAbove )
		{
		pfcb->SetAboveThreshold();
		}

	FILESetAllIndexMask( pfcb );

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	return err;

HandleError:
	Assert( err < 0 );

	if ( pfcbNil != pfcbSecondaryIndexes )
		CATIFreeSecondaryIndexes( pfcbSecondaryIndexes );

	// No need to explicitly free index name or idxseg array, since
	// memory pool will be freed when TDB is deleted below.
	if ( pfcb->Pidb() != pidbNil )
		{
		pfcb->ReleasePidb();
		pfcb->SetPidb( pidbNil );
		}
	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	return err;
	}


//  ================================================================
ERR ErrCATCopyCallbacks(
	PIB * const ppib,
	const IFMP ifmpSrc,
	const IFMP ifmpDest,
	const OBJID objidSrc,
	const OBJID objidDest )
//  ================================================================
//
//  Used by defrag to transport callbacks from one table to another
//
//-
	{
	const SYSOBJ	sysobj = sysobjCallback;

	ERR err = JET_errSuccess;

	FUCB * pfucbSrc = pfucbNil;
	FUCB * pfucbDest = pfucbNil;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	Call( ErrCATOpen( ppib, ifmpSrc, &pfucbSrc ) );
	Call( ErrCATOpen( ppib, ifmpDest, &pfucbDest ) );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbSrc,
				(BYTE *)&objidSrc,
				sizeof(objidSrc),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbSrc,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );

	err = ErrIsamSeek( ppib, pfucbSrc, JET_bitSeekGT );
	if ( err < 0 )
		{
		if ( JET_errRecordNotFound != err )
			goto HandleError;
		}
	else
		{
		CallS( err );

		Call( ErrIsamMakeKey(
					ppib,
					pfucbSrc,
					(BYTE *)&objidSrc,
					sizeof(objidSrc),
					JET_bitNewKey ) );
		Call( ErrIsamMakeKey(
					ppib,
					pfucbSrc,
					(BYTE *)&sysobj,
					sizeof(sysobj),
					JET_bitStrLimit ) );
		err = ErrIsamSetIndexRange( ppib, pfucbSrc, JET_bitRangeUpperLimit );
		Assert( err <= 0 );

		while ( JET_errNoCurrentRecord != err )
			{
			Call( err );

			JET_RETRIEVECOLUMN	rgretrievecolumn[3];
			INT					iretrievecolumn		= 0;

			ULONG				cbtyp;
			CHAR				szCallback[JET_cbColumnMost+1];

			memset( rgretrievecolumn, 0, sizeof( rgretrievecolumn ) );

			rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Flags;
			rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&cbtyp;
			rgretrievecolumn[iretrievecolumn].cbData		= sizeof( cbtyp );
			rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
			++iretrievecolumn;

			rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Callback;
			rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)szCallback;
			rgretrievecolumn[iretrievecolumn].cbData		= sizeof( szCallback );
			rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
			ULONG& cbCallback = rgretrievecolumn[iretrievecolumn].cbActual;
			++iretrievecolumn;

			Call( ErrIsamRetrieveColumns(
					(JET_SESID)ppib,
					(JET_TABLEID)pfucbSrc,
					rgretrievecolumn,
					iretrievecolumn ) );

			szCallback[cbCallback] = 0;

			Assert( cbtyp != JET_cbtypNull );

			Call( ErrCATAddTableCallback( ppib, pfucbDest, objidDest, (JET_CBTYP)cbtyp, szCallback ) );
			err = ErrIsamMove( ppib, pfucbSrc, JET_MoveNext, NO_GRBIT );
			}

		Assert( JET_errNoCurrentRecord == err );
		}

	err = JET_errSuccess;

HandleError:
	if( pfucbNil != pfucbSrc )
		{
		CallS( ErrCATClose( ppib, pfucbSrc ) );
		}
	if( pfucbNil != pfucbDest )
		{
		CallS( ErrCATClose( ppib, pfucbDest ) );
		}

	if( err >= 0 )
		{
		err = ErrDIRCommitTransaction( ppib, NO_GRBIT );
		}
	else
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIInitCallbacks(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	FCB				* const pfcb,
	TDB				* const ptdb )
//  ================================================================
	{
	ERR				err							= JET_errSuccess;
	const IFMP		ifmp						= pfcb->Ifmp();
	const SYSOBJ	sysobj						= sysobjCallback;
	BOOL			fMovedOffCurrentRecord		= fFalse;
	JET_CALLBACK	callback;
	ULONG			cbtyp;
	CHAR			szCallback[JET_cbColumnMost+1];
	DATA			dataField;

	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( !g_fCallbacksDisabled );

	do
		{
		Call( err );

		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		Assert( FFixedFid( fidMSO_ObjidTable ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_ObjidTable,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(OBJID) );
		if ( objidTable != *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) )
			{
			goto DoneCallbacks;
			}

		//	verify this is a callback
		Assert( FFixedFid( fidMSO_Type ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Type,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(SYSOBJ) );
		switch( *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
			{
			case sysobjCallback:
				{
				Assert( FFixedFid( fidMSO_Flags ) );
				Call( ErrRECIRetrieveFixedColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Flags,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				CallS( err );
				Assert( dataField.Cb() == sizeof(ULONG) );
				cbtyp = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
				Assert( JET_cbtypNull != cbtyp );

				Assert( FVarFid( fidMSO_Callback ) );
				Call( ErrRECIRetrieveVarColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Callback,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				CallS( err );
				Assert( dataField.Cb() <= JET_cbNameMost );
				UtilMemCpy( szCallback, dataField.Pv(), dataField.Cb() );
				szCallback[dataField.Cb()] = 0;		// Add null-termination.

				Call( ErrCALLBACKResolve( szCallback, &callback ) );

				CBDESC * const pcbdescInsert = new CBDESC;	//	freed in TDB::Delete
				if( NULL == pcbdescInsert )
					{
					Call( ErrERRCheck( JET_errOutOfMemory ) );
					}

				pcbdescInsert->pcbdescNext	= NULL;
				pcbdescInsert->ppcbdescPrev	= NULL;
				pcbdescInsert->pcallback 	= callback;
				pcbdescInsert->cbtyp 		= cbtyp;
				pcbdescInsert->pvContext	= NULL;
				pcbdescInsert->cbContext	= 0;
				pcbdescInsert->ulId			= 0;
				pcbdescInsert->fPermanent	= fTrue;
				pcbdescInsert->fVersioned	= fFalse;
				ptdb->RegisterPcbdesc( pcbdescInsert );
				break;
				}

			case sysobjLongValue:
				//	skip LV's and continue moving to next record
				if ( !fMovedOffCurrentRecord )
					{
					break;
					}

				//	LV's MUST come before callbacks, else
				//	FALL THROUGH to corruption case

			case sysobjTable:
			case sysobjColumn:
			case sysobjIndex:
			default:
				//	callbacks are currently the last type of table-level sysobjs
				AssertSz( fFalse, "Catalog corrupted - sysobj in invalid order." );
				err = ErrERRCheck( JET_errCatalogCorrupted );
				goto HandleError;
			}

		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		fMovedOffCurrentRecord = fTrue;
		err = ErrBTNext( pfucbCatalog, fDIRNull );
		Assert( JET_errRecordDeleted != err );
		}
	while ( JET_errNoCurrentRecord != err );

	//	verify we didn't unexpectedly break out
	Assert( JET_errNoCurrentRecord == err );

	//	only way to get here is to hit the end of the catalog
	err = ErrERRCheck( wrnCATNoMoreRecords );


DoneCallbacks:
	CallSx( err, wrnCATNoMoreRecords );

HandleError:
	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	return err;
	}


ERR ErrCATInitFCB( FUCB *pfucbTable, OBJID objidTable )
	{
	ERR    		err;
	PIB			*ppib					= pfucbTable->ppib;
	INST		*pinst					= PinstFromPpib( ppib );
	const IFMP	ifmp					= pfucbTable->ifmp;
	FUCB   		*pfucbCatalog			= pfucbNil;
	FCB			*pfcb					= pfucbTable->u.pfcb;
	TDB			*ptdb					= ptdbNil;
	FCB			*pfcbTemplateTable		= pfcbNil;
	DATA		dataField;
	ULONG		ulDefaultDensity;
	ULONG		ulFlags;
	BOOL		fHitEOF					= fFalse;
	CHAR		szTableName[ JET_cbNameMost + 1 ];

	// Temporary table FCBs are initialised by CATInitTempFCB.
	Assert( dbidTemp != rgfmp[ifmp].Dbid() );

	Assert( !pfcb->FInitialized() );
	Assert( objidTable == pfucbTable->u.pfcb->ObjidFDP()
			|| objidNil == pfucbTable->u.pfcb->ObjidFDP() && fGlobalRepair );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	FUCBSetPrereadForward( pfucbCatalog, 3 );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, objidTable ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	//	should be on primary index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( locOnCurBM == pfucbCatalog->locLogical );

	Assert( FVarFid( fidMSO_Name ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Name,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() <= JET_cbNameMost );
	UtilMemCpy( szTableName, dataField.Pv(), dataField.Cb() );
	szTableName[ dataField.Cb() ] = 0;

	Assert( FFixedFid( fidMSO_SpaceUsage ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_SpaceUsage,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ulDefaultDensity = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( &ulDefaultDensity, dataField.Pv(), sizeof(ULONG) );

	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Flags,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ulFlags = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( &ulFlags, dataField.Pv(), sizeof(ULONG) );

	//	WARNING: Must do this initial check for the value of ulFlags to get around an
	//	Alpha code gen bug.  The compiler recognises that we only want to compare against
	//	one byte of ulFlags, so it avoids loading the entire dword.  However, it is loading
	//	the incorrect byte.  Checking for non-zero here forces the compiler to load the
	//	entire dword.
	if ( 0 != ulFlags )
		{
		Assert( !( ulFlags & JET_bitObjectSystem ) || FOLDSystemTable( szTableName ) || FCATUnicodeFixupTable( szTableName ) );
		if ( ulFlags & JET_bitObjectTableTemplate )
			{
			Assert( ulFlags & JET_bitObjectTableFixedDDL );
			Assert( !( ulFlags & JET_bitObjectTableDerived ) );
			pfcb->SetFixedDDL();
			pfcb->SetTemplateTable();
			}
		else
			{
			if ( ulFlags & JET_bitObjectTableFixedDDL )
				pfcb->SetFixedDDL();

			if ( ulFlags & JET_bitObjectTableDerived )
				{
				CHAR	szTemplateTable[JET_cbNameMost+1];
				FUCB	*pfucbTemplateTable;

				Assert( FVarFid( fidMSO_TemplateTable ) );
				Call( ErrRECIRetrieveVarColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_TemplateTable,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				CallS( err );
				Assert( dataField.Cb() > 0 );
				Assert( dataField.Cb() <= JET_cbNameMost );
				UtilMemCpy( szTemplateTable, dataField.Pv(), dataField.Cb() );
				szTemplateTable[dataField.Cb()] = '\0';

				//	release latch once we're done retrieving data from Table record
				Call( ErrBTRelease( pfucbCatalog ) );

				Call( ErrFILEOpenTable(
							ppib,
							ifmp,
							&pfucbTemplateTable,
							szTemplateTable,
							JET_bitTableReadOnly ) );
				Assert( pfucbNil != pfucbTemplateTable );

				pfcbTemplateTable = pfucbTemplateTable->u.pfcb;
				Assert( pfcbNil != pfcbTemplateTable );
				Assert( pfcbTemplateTable->FTemplateTable() );
				Assert( pfcbTemplateTable->FFixedDDL() );

				// Close cursor.  FCB will be pinned because FAvail_() checks
				// for TemplateTable flag.
				CallS( ErrFILECloseTable( ppib, pfucbTemplateTable ) );

				pfcb->SetDerivedTable();

#ifdef DEBUG
				//	re-obtain latch on catalog
				Call( ErrBTGet( pfucbCatalog ) );

				//	verify still on same record
				Assert( FFixedFid( fidMSO_ObjidTable ) );
				CallS( ErrRECIRetrieveFixedColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_ObjidTable,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				Assert( dataField.Cb() == sizeof(OBJID) );
				Assert( objidTable == *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) );

				Assert( FFixedFid( fidMSO_Type ) );
				CallS( ErrRECIRetrieveFixedColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Type,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				Assert( dataField.Cb() == sizeof(SYSOBJ) );
				Assert( sysobjTable == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );

				Call( ErrBTRelease( pfucbCatalog ) );
#endif
				}
			}
		}

	//	must release page latch at this point for highest columnid
	//	search in ErrCATIInitTDB()
	//	latch will be reobtained in ErrCATIBuildFIELDArray()
	//	and will not be relinquished from that point forth
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	if ( ulFlags & JET_bitObjectTableDerived )
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		}
	else
		{
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrBTRelease( pfucbCatalog ) );
		}

	//	verify key no longer in prepared state, but still in buffer
	Assert( !FKSPrepared( pfucbCatalog ) );
	FUCBAssertValidSearchKey( pfucbCatalog );
	Assert( cbCATNormalizedObjid == pfucbCatalog->dataSearchKey.Cb() );

	//	force index range on this table
	( (BYTE *)pfucbCatalog->dataSearchKey.Pv() )[cbCATNormalizedObjid] = 0xff;	//	force strlimit
	pfucbCatalog->dataSearchKey.DeltaCb( 1 );
	FUCBSetIndexRange( pfucbCatalog, JET_bitRangeUpperLimit );

	Call( ErrCATIInitTDB(
				ppib,
				pfucbCatalog,
				objidTable,
				szTableName,
				pfcb->FTemplateTable(),
				pfcbTemplateTable,
				&ptdb ) );
	CallSx( err, wrnCATNoMoreRecords );
	fHitEOF = ( wrnCATNoMoreRecords == err );

	Assert( ptdbNil != ptdb );
	Assert( ( pfcb->FTemplateTable() && ptdb->FTemplateTable() )
		|| ( !pfcb->FTemplateTable() && !ptdb->FTemplateTable() ) );

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	if ( fHitEOF )
		{
		//	no primary/secondary indexes, only a sequential index
		Call( ErrFILEIInitializeFCB(
					ppib,
					ifmp,
					ptdb,
					pfcb,
					pidbNil,
					fTrue,
					pfcb->PgnoFDP(),
					ulDefaultDensity ) );
		ptdb->ResetRgbitAllIndex();
		Assert( pfcbNil == pfcb->PfcbNextIndex() );
		}
	else
		{
		Call( ErrCATIInitIndexFCBs(
					ppib,
					pfucbCatalog,
					objidTable,
					pfcb,
					ptdb,
					ulDefaultDensity ) );
		CallSx( err, wrnCATNoMoreRecords );
		fHitEOF = ( wrnCATNoMoreRecords == err );
		}

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	if ( !g_fCallbacksDisabled && !fHitEOF )
		{
		Call( ErrCATIInitCallbacks(
					ppib,
					pfucbCatalog,
					objidTable,
					pfcb,
					ptdb ) );
		CallSx( err, wrnCATNoMoreRecords );
		}

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	BTUp( pfucbCatalog );

	// Try to compact byte pool, but if it fails, don't worry.  It just means
	// that the byte pool will have some unused space.
	ptdb->MemPool().FCompact();

	pfcb->SetTypeTable();

	err = JET_errSuccess;

HandleError:
	if ( err < 0 )
		{
		Assert( pfcb->Ptdb() == ptdbNil || pfcb->Ptdb() == ptdb );

		if ( ptdbNil != ptdb )
			ptdb->Delete( pinst );
		pfcb->SetPtdb( ptdbNil );

		if ( pfcbNil != pfcb->PfcbNextIndex() )
			{
			CATIFreeSecondaryIndexes( pfcb->PfcbNextIndex() );
			pfcb->SetPfcbNextIndex( pfcbNil );
			}

		if ( pidbNil != pfcb->Pidb() )
			{
			pfcb->ReleasePidb();
			pfcb->SetPidb( pidbNil );
			}
		}

	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}



ERR ErrCATInitTempFCB( FUCB *pfucbTable )
	{
	ERR		err;
	PIB		*ppib = pfucbTable->ppib;
	FCB		*pfcb = pfucbTable->u.pfcb;
	TDB		*ptdb = ptdbNil;
	TCIB	tcib = { fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1 };
	INST	*pinst = PinstFromPpib( ppib );

	Assert( !pfcb->FInitialized() );

	/*	the only way a temporary table could get to this point is if it was being
	/*	created, in which case there are no primary or secondary indexes yet.
	/**/

	CallR( ErrTDBCreate( pinst, &ptdb, &tcib ) );

	Assert( ptdb->FidVersion() == 0 );
	Assert( ptdb->FidAutoincrement() == 0 );
	Assert( tcib.fidFixedLast == ptdb->FidFixedLast() );
	Assert( tcib.fidVarLast == ptdb->FidVarLast() );
	Assert( tcib.fidTaggedLast == ptdb->FidTaggedLast() );

	/*	for temporary tables, could only get here from
	/*	create table which means table should currently be empty
	/**/
	Assert( ptdb->FidFixedLast() == fidFixedLeast - 1 );
	Assert( ptdb->FidVarLast() == fidVarLeast - 1 );
	Assert( ptdb->FidTaggedLast() == fidTaggedLeast - 1 );
	Assert( ptdb->DbkMost() == 0 );
	Assert( ptdb->UlLongIdLast() == 0 );

	// NOTE: Table name will be added when sort is materialized.

	Call( ErrFILEIInitializeFCB(
		ppib,
		pinst->m_mpdbidifmp[ dbidTemp ],
		ptdb,
		pfcb,
		pidbNil,
		fTrue,
		pfcb->PgnoFDP(),
		ulFILEDefaultDensity ) );

	Assert( pfcb->PfcbNextIndex() == pfcbNil );

	pfcb->SetPtdb( ptdb );

	FILESetAllIndexMask( pfcb );
	pfcb->SetFixedDDL();
	pfcb->SetTypeTemporaryTable();

	return JET_errSuccess;

HandleError:
	Assert( ptdb != ptdbNil );
	Assert( pfcb->Ptdb() == ptdbNil );		// Verify TDB never got linked in.
	ptdb->Delete( pinst );

	return err;
	}


//	UNDONE:	is there another function in JET which does this?
ULONG UlCATColumnSize( JET_COLTYP coltyp, INT cbMax, BOOL *pfMaxTruncated )
	{
	ULONG	ulLength;
	BOOL	fTruncated = fFalse;

	switch( coltyp )
		{
		case JET_coltypBit:
		case JET_coltypUnsignedByte:
			ulLength = 1;
			Assert( ulLength == sizeof(BYTE) );
			break;

		case JET_coltypShort:
			ulLength = 2;
			Assert( ulLength == sizeof(SHORT) );
			break;

		case JET_coltypLong:
		case JET_coltypIEEESingle:
			ulLength = 4;
			Assert( ulLength == sizeof(LONG) );
			break;

		case JET_coltypCurrency:
		case JET_coltypIEEEDouble:
		case JET_coltypDateTime:
			ulLength = 8;		// sizeof(DREAL)
			break;

		case JET_coltypBinary:
		case JET_coltypText:
			if ( cbMax == 0 )
				{
				ulLength = JET_cbColumnMost;
				}
			else
				{
				ulLength = cbMax;
				if ( ulLength > JET_cbColumnMost )
					{
					ulLength = JET_cbColumnMost;
					fTruncated = fTrue;
					}
				}
			break;

		default:
			// Just pass back what was given.
			Assert( FRECLongValue( coltyp ) || FRECSLV( coltyp ));
			Assert( JET_coltypNil != coltyp );
			ulLength = cbMax;
			break;
		}

	if ( pfMaxTruncated != NULL )
		{
		*pfMaxTruncated = fTruncated;
		}

	return ulLength;
	}


/*	This routines sets/gets table and index stats.
/*	Pass NULL for szSecondaryIndexName if looking for sequential or primary index.
/**/
ERR ErrCATStats(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szSecondaryIndexName,
	SR			*psr,
	const BOOL	fWrite )

	{
	ERR			err;
	FUCB		*pfucbCatalog		= pfucbNil;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	/*	stats for sequential and primary indexes are in MSysObjects, while
	/*	stats for secondary indexes are in MSysIndexes.
	/**/
	if ( szSecondaryIndexName )
		{
		Call( ErrCATISeekTableObject(
					ppib,
					pfucbCatalog,
					objidTable,
					sysobjIndex,
					szSecondaryIndexName ) );
		}
	else
		{
		Call( ErrCATISeekTable(
					ppib,
					pfucbCatalog,
					objidTable ) );
		}

	Assert( Pcsr( pfucbCatalog )->FLatched() );

	/*	set/retrieve value
	/**/
	if ( fWrite )
		{
		LE_SR le_sr;

		le_sr = *psr;

		Call( ErrDIRRelease( pfucbCatalog ) );

		Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );
		Call( ErrIsamSetColumn(
					ppib,
					pfucbCatalog,
					fidMSO_Stats,
					(BYTE *)&le_sr,
					sizeof(LE_SR),
					NO_GRBIT,
					NULL ) );
		Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );
		}
	else
		{
		DATA	dataField;

		Assert( FVarFid( fidMSO_Stats ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Stats,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		if ( dataField.Cb() == 0 )
			{
			Assert( JET_wrnColumnNull == err );
			memset( (BYTE *)psr, '\0', sizeof(SR) );
			err = JET_errSuccess;
			}
		else
			{
			Assert( dataField.Cb() == sizeof(LE_SR) );
			CallS( err );
			LE_SR le_sr;
			le_sr = *(LE_SR*)dataField.Pv();
			*psr = le_sr;
//			UtilMemCpy( psr, dataField.Pv(), sizeof(SR) );
			}
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


//  ================================================================
ERR ErrCATChangePgnoFDP( PIB * ppib, IFMP ifmp, OBJID objidTable, OBJID objid, SYSOBJ sysobj, PGNO pgnoFDPNew )
//  ================================================================
	{
	ERR			err 			= JET_errSuccess;
	FUCB *		pfucbCatalog	= pfucbNil;
	BOOKMARK	bm;
	BYTE		rgbBookmark[JET_cbBookmarkMost];
	ULONG		cbBookmark;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );
	Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobj, objid ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Call( ErrDIRRelease( pfucbCatalog ) );

	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );
	Call( ErrIsamSetColumn(
				ppib,
				pfucbCatalog,
				fidMSO_PgnoFDP,
				(BYTE *)&pgnoFDPNew,
				sizeof(PGNO),
				NO_GRBIT,
				NULL ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );

	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );		//	shadow catalog

	Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );

	Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );
	Call( ErrIsamSetColumn(
				ppib,
				pfucbCatalog,
				fidMSO_PgnoFDP,
				(BYTE *)&pgnoFDPNew,
				sizeof(PGNO),
				NO_GRBIT,
				NULL ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );

HandleError:
	if( pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIChangeColumnDefaultValue(
	PIB			* const ppib,
	FUCB		* const pfucbCatalog,
	const DATA&	dataDefault )
//  ================================================================
	{
	ERR			err;
	DATA		dataField;
	FIELDFLAG	ffield 		= 0;
	ULONG		ulFlags;

	CallR( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );

	// get the exsiting flags
	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Flags,
				pfucbCatalog->dataWorkBuf,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ffield = *(UnalignedLittleEndian< FIELDFLAG > *)dataField.Pv();

	//	force DefaultValue flag in case it's not already set
	FIELDSetDefault( ffield );

	ulFlags = ffield;
	Call( ErrIsamSetColumn(
				ppib,
				pfucbCatalog,
				fidMSO_Flags,
				&ulFlags,
				sizeof(ulFlags),
				NO_GRBIT,
				NULL ) );

	Call( ErrIsamSetColumn(
				ppib,
				pfucbCatalog,
				fidMSO_DefaultValue,
				dataDefault.Pv(),
				dataDefault.Cb(),
				NO_GRBIT,
				NULL ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );

HandleError:
	if( err < 0 )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepCancel ) );
		}
	return err;
	}


//  ================================================================
ERR ErrCATChangeColumnDefaultValue(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szColumn,
	const DATA&	dataDefault )
//  ================================================================
	{
	ERR			err;
	FUCB *		pfucbCatalog		= pfucbNil;
	BOOKMARK	bm;
	BYTE		rgbBookmark[JET_cbKeyMost];
	ULONG		cbBookmark;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );	//  catalog
	Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjColumn, szColumn ) );

	Call( ErrDIRRelease( pfucbCatalog ) );

	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrCATIChangeColumnDefaultValue( ppib, pfucbCatalog, dataDefault ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );		//	shadow catalog
	Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );
	Call( ErrCATIChangeColumnDefaultValue( ppib, pfucbCatalog, dataDefault ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


LOCAL ERR ErrCATIDeleteLocalizedIndexesInTable(
	IN PIB			* const ppib,
	IN const IFMP	ifmp,
	IN const CHAR	* const szTableName,
	OUT BOOL		* const pfIndexesDeleted,
	IN const BOOL	fReadOnly,
	IN const BOOL	fForceDelete )
	{
	ERR			err;
	FUCB		*pfucbTable		= pfucbNil;
	FCB			*pfcbTable;
	FCB			*pfcbIndex;
	CHAR		szIndexName[JET_cbNameMost+1];
	const CHAR	*rgsz[3];
	BOOL		fInTrx			= fFalse;

	Assert( 0 == ppib->level );

	CallR( ErrFILEOpenTable(
				ppib,
				ifmp,
				&pfucbTable,
				szTableName,
				( fReadOnly ? 0 : JET_bitTableDenyRead|JET_bitTablePermitDDL ) ) );
	Assert( pfucbNil != pfucbTable );

	//	wrap in a transaction to ensure one index doesn't disappear
	//	(due to RCE cleanup) while we're working on another
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTrx = fTrue;

	pfcbTable = pfucbTable->u.pfcb;
	Assert( pfcbNil != pfcbTable );
	Assert( pfcbTable->FTypeTable() );
	Assert( ptdbNil != pfcbTable->Ptdb() );

	rgsz[0] = rgfmp[ifmp].SzDatabaseName();
	rgsz[1] = szIndexName;
	rgsz[2] = szTableName;

//	No need to enter critical section because this is only called at AttachDatabase() time,
//	meaning no one else has access to this database yet.
//	ENTERCRITICALSECTION	enterCritFCB( &pfcbTable->Crit() );

	for ( pfcbIndex = pfcbTable;
		pfcbIndex != pfcbNil;
		pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		const IDB	*pidb	= pfcbIndex->Pidb();

		//	only clustered index may be sequential
		//
		Assert( pidbNil != pidb || pfcbIndex == pfcbTable );

		//	we need to rebuild the index if the sort version has changed
		//	and unicode fixup is not enabled for the index.
		//
		if ( pidbNil != pidb
			&& pidb->FLocalizedText()
			&& ( pidb->FBadSortVersion() || fForceDelete ) )
			{
			CSR		csrIndexRootPage;
			ULONG	centries;

			Assert( lcidNone != pidb->Lcid() );		//	CATIInitIDB() filters out lcidNone

#ifdef DEBUG
			BOOL				fFoundUnicodeTextColumn	= fFalse;
			const IDXSEG*		rgidxseg				= PidxsegIDBGetIdxSeg( pidb, pfcbTable->Ptdb() );
			Assert( pidb->Cidxseg() <= JET_ccolKeyMost );

			for ( ULONG iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
				{
				const COLUMNID	columnid	= rgidxseg[iidxseg].Columnid();
				const FIELD		*pfield		= pfcbTable->Ptdb()->Pfield( columnid );
				if ( FRECTextColumn( pfield->coltyp ) && usUniCodePage == pfield->cp )
					{
					fFoundUnicodeTextColumn = fTrue;
					break;
					}
				}
			Assert( fFoundUnicodeTextColumn );
#endif

			Assert( strlen( pfcbTable->Ptdb()->SzIndexName( pidb->ItagIndexName(), pfcbIndex->FDerivedIndex() ) ) <= JET_cbNameMost );
			strcpy( szIndexName, pfcbTable->Ptdb()->SzIndexName( pidb->ItagIndexName(), pfcbIndex->FDerivedIndex() ) );

			Call( csrIndexRootPage.ErrGetPage(
										ppib,
										pfcbIndex->Ifmp(),
										pfcbIndex->PgnoFDP(),
										latchReadTouch ) );
			centries = csrIndexRootPage.Cpage().Clines();
			csrIndexRootPage.ReleasePage();

			if ( fForceDelete )
				{
				*pfIndexesDeleted = fTrue;

				//	Ensure that we can always delete the index
				//	This means that for the life of this FCB, DDL will be
				//	possible and there will be a perf hit because we
				//	will now enter critFCB for many operations.
				//	Note that we cannot simply re-enable the flag after
				//	the deletion because version cleanup does some stuff
				//	with the FCB.
				pfcbTable->ResetFixedDDL();

				err = ErrIsamDeleteIndex( ppib, pfucbTable, szIndexName );
				}
			else
				{
				if ( 0 == centries )
					{
					//	PERF: If we leave the index as it, and it isn't marked for fixup then we will have to delete it when the defined version does
					//	change. To avoid this, update the sort version in the index meta-data to the current version

					//	no entries in index, so no chance of corruption
					//	UNDONE: if there are just a few entries in the index,
					//	it may be more worthwhile to "fix up" the index
					//	instead of rebuilding it (ie. scan the index, use the
					//	primary bookmark to find the owning record, regenerate
					//	the secondary key, and see if it matches)
					err = JET_errSuccess;
					}

				//	non-empty index could be corrupt if it contains a unicode text column

				else if ( pfcbIndex == pfcbTable )
					{
					UtilReportEvent(
							eventWarning,
							DATA_DEFINITION_CATEGORY,
							PRIMARY_INDEX_CORRUPT_ERROR_ID, 3, rgsz, 0, NULL, PinstFromPpib( ppib ) );
					err = ErrERRCheck( JET_errPrimaryIndexCorrupted );
					}
				else if ( fReadOnly
						|| pfcbTable->FTemplateTable()		//	cannot rebuild template/derived indexes
						|| pfcbIndex->FDerivedIndex() )
					{
					UtilReportEvent(
							eventWarning,
							DATA_DEFINITION_CATEGORY,
							SECONDARY_INDEX_CORRUPT_ERROR_ID, 3, rgsz, 0, NULL, PinstFromPpib( ppib ) );
					err = ErrERRCheck( JET_errSecondaryIndexCorrupted );
					}
				else
					{
					UtilReportEvent(
							eventInformation,
							DATA_DEFINITION_CATEGORY,
							DO_SECONDARY_INDEX_CLEANUP_ID, 3, rgsz, 0, NULL, PinstFromPpib( ppib ) );
					*pfIndexesDeleted = fTrue;

					//	Ensure that we can always delete the index
					//	This means that for the life of this FCB, DDL will be
					//	possible and there will be a perf hit because we
					//	will now enter critFCB for many operations.
					//	Note that we cannot simply re-enable the flag after
					//	the deletion because version cleanup does some stuff
					//	with the FCB.
					pfcbTable->ResetFixedDDL();

					err = ErrIsamDeleteIndex( ppib, pfucbTable, szIndexName );
					}
				}
			Call( err );
			}
		}

	Call( ErrDIRCommitTransaction( ppib, 0 ) );
	fInTrx = fFalse;

HandleError:
	if ( fInTrx )
		{
		Assert( err < 0 );
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	Assert( pfucbNil != pfucbTable );
	CallS( ErrFILECloseTable( ppib, pfucbTable ) );
	return err;
	}


//  ================================================================
ERR ErrCATDeleteLocalizedIndexes(
		IN PIB * const ppib,
		IN const IFMP ifmp,
		OUT BOOL * const pfIndexesDeleted,
		OUT BOOL * const pfIndexCleanupNeeded,
		IN const BOOL fReadOnly,
		IN const BOOL fForceDelete )
//  ================================================================
//
//	Check all the localized indexes in the catalog
//
//	For each index:
//
//	if ( index sort order matches OS sort order )
//		success
//	else if ( index is marked for fixup )
//		*pfIndexCleanupNeeded = TRUE
//	else if ( fReadOnly )
//		fCorruptedIndexes = TRUE
//	else
//		delete index
//		*pfIndexesDeleted = TRUE
//
//	if ( fCorruptedIndexes )
//		return error
//
//	the real implementation is more complex...
//
//-
	{
	ERR		err;
	FUCB	*pfucbCatalog				= pfucbNil;		//	cursor to sequentially scan catalog
	OBJID	objidTable					= objidNil;
	OBJID	objidTableLastWithLocalized	= objidNil;
	SYSOBJ	sysobj;
	DATA	dataField;
	CHAR	szTableName[JET_cbNameMost+1];
	BOOL	fLatched					= fFalse;

	*pfIndexesDeleted 		= fFalse;
	*pfIndexCleanupNeeded 	= fFalse;

	Assert( dbidTemp != rgfmp[ifmp].Dbid() );
	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	//	we will be sequentially scanning the catalog for index records
	FUCBSetSequential( pfucbCatalog );

	err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveFirst, NO_GRBIT );
	Assert( JET_errRecordNotFound != err );
	if ( JET_errNoCurrentRecord == err )
		{
		// catalog should not be empty
		err = ErrERRCheck( JET_errCatalogCorrupted );
		}

	do
		{
		Call( err );

		Assert( !fLatched );
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		fLatched = fTrue;

		Assert( FFixedFid( fidMSO_ObjidTable ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_ObjidTable,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(OBJID) );
		objidTable = *(UnalignedLittleEndian< OBJID > *) dataField.Pv();
//		UtilMemCpy( &objidTable, dataField.Pv(), sizeof(OBJID) );

		Assert( objidTable >= objidTableLastWithLocalized );
		if ( objidTable > objidTableLastWithLocalized )
			{
			Assert( FFixedFid( fidMSO_Type ) );
			Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Type,
						pfucbCatalog->kdfCurr.data,
						&dataField ) );
			CallS( err );
			Assert( dataField.Cb() == sizeof(SYSOBJ) );
			sysobj = *(UnalignedLittleEndian< SYSOBJ > *) dataField.Pv();
//			UtilMemCpy( &sysobj, dataField.Pv(), sizeof(SYSOBJ) );

			if ( sysobjTable == sysobj )
				{
				Assert( FVarFid( fidMSO_Name ) );
				Call( ErrRECIRetrieveVarColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Name,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				CallS( err );
				Assert( dataField.Cb() > 0 );
				Assert( dataField.Cb() <= JET_cbNameMost );
				UtilMemCpy( szTableName, dataField.Pv(), dataField.Cb() );
				szTableName[dataField.Cb()] = 0;
				}
			else if ( sysobjIndex == sysobj )
				{
				IDBFLAG		fidb;

				Assert( FFixedFid( fidMSO_Flags ) );
				Call( ErrRECIRetrieveFixedColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Flags,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				CallS( err );
				Assert( dataField.Cb() == sizeof(ULONG) );
				fidb = *(UnalignedLittleEndian< IDBFLAG > *) dataField.Pv();
//				UtilMemCpy( &fidb, dataField.Pv(), sizeof(IDBFLAG) );

				//	don't bother checking derived indexes as they will be checked
				//	when the template table is checked.
				//
				if ( !FIDBDerivedIndex( fidb ) && FIDBLocalizedText( fidb ) )
					{
					if ( fForceDelete )
						{
						Assert( Pcsr( pfucbCatalog )->FLatched() );
						Call( ErrDIRRelease( pfucbCatalog ) );
						fLatched = fFalse;
						Assert( !FCATSystemTable( szTableName ) );
						Call( ErrCATIDeleteLocalizedIndexesInTable(
							ppib,
							ifmp,
							szTableName,
							pfIndexesDeleted,
							fReadOnly,
							fForceDelete ) );

						objidTableLastWithLocalized = objidTable;
						}
					else
						{
						LCID	lcid;
						QWORD	qwSortVersion 			= 0;

						Assert( FFixedFid( fidMSO_Localization ) );
						Call( ErrRECIRetrieveFixedColumn(
									pfcbNil,
									pfucbCatalog->u.pfcb->Ptdb(),
									fidMSO_Localization,
									pfucbCatalog->kdfCurr.data,
									&dataField ) );
						CallS( err );
						Assert( dataField.Cb() == sizeof(LCID) );
						lcid = *(UnalignedLittleEndian<LCID> *)dataField.Pv();
	//					UtilMemCpy( &lcid, dataField.Pv(), sizeof(LCID) );

						//	old format: fLocaleId is FALSE and lcid == 0
						//	(we force lcid to default value in CATIInitIDB())
						Assert( lcidNone != lcid
							|| !FIDBLocaleId( fidb ) );

						Assert( FVarFid( fidMSO_Version ) );
						Call( ErrRECIRetrieveVarColumn(
									pfcbNil,
									pfucbCatalog->u.pfcb->Ptdb(),
									fidMSO_Version,
									pfucbCatalog->kdfCurr.data,
									&dataField ) );
						if ( dataField.Cb() == 0 )
							{
							Assert( JET_wrnColumnNull == err );

							//	old format: no sort order
							Assert( 0 == qwSortVersion );
							}
						else
							{
							CallS( err );
							Assert( dataField.Cb() == sizeof(QWORD) );
							qwSortVersion = *(UnalignedLittleEndian< QWORD > *) dataField.Pv();
							}

						INDEX_UNICODE_STATE state;
						Call( ErrIndexUnicodeState( lcid, qwSortVersion, FIDBUnicodeFixupOn( fidb ), &state ) );

						switch( state )
							{
							case INDEX_UNICODE_FIXUP:
								//	this index can be fixed by the undefined codepoint fixup code
								*pfIndexCleanupNeeded = fTrue;
								break;

							case INDEX_UNICODE_GOOD:
								//	don't need to do anything
								break;

							default:
								//	missed case?!
								FireWall();
								break;

							case INDEX_UNICODE_DELETE:
								//	if we found one localized index in the table, its
								//	easiest to open the table and delete them all
								//	the deletion routine may encounter indexes with fixup enabled
								//	that would otherwise be ignored (once we delete the indexes we ignore
								//	all further index records for that table) so pfIndexCleanupNeeded is set

								*pfIndexCleanupNeeded = fTrue;

								Assert( Pcsr( pfucbCatalog )->FLatched() );
								Call( ErrDIRRelease( pfucbCatalog ) );
								fLatched = fFalse;
								Assert( !FCATSystemTable( szTableName ) );
								Call( ErrCATIDeleteLocalizedIndexesInTable(
											ppib,
											ifmp,
											szTableName,
											pfIndexesDeleted,
											fReadOnly,
											fForceDelete ) );

								objidTableLastWithLocalized = objidTable;
								break;
							}
						}
					}
				}
			else
				{
				Assert( sysobjColumn == sysobj
					|| sysobjLongValue == sysobj
					|| sysobjCallback == sysobj
					|| sysobjSLVAvail == sysobj
					|| sysobjSLVOwnerMap == sysobj );
				}
			}

		if ( fLatched )
			{
			Assert( Pcsr( pfucbCatalog )->FLatched() );
			Call( ErrDIRRelease( pfucbCatalog ) );
			fLatched = fFalse;
			}

		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
		}
	while ( JET_errNoCurrentRecord != err );

	err = JET_errSuccess;

HandleError:
	Assert( pfucbNil != pfucbCatalog );
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIRenameTable(
	PIB			* const ppib,
	const IFMP			ifmp,
	const OBJID			objidTable,
	const CHAR * const 	szNameNew,
	const BOOL fShadow )
//  ================================================================
	{
	ERR err = JET_errSuccess;
	FUCB * pfucbCatalog = pfucbNil;
	BOOL fUpdatePrepared = fFalse;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fShadow ) );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, objidTable ) );
	Call( ErrDIRRelease( pfucbCatalog ) );

	Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplace ) );
	fUpdatePrepared = fTrue;

	ULONG ulFlags;
	ULONG cbActual;
	Call( ErrIsamRetrieveColumn(
			ppib,
			pfucbCatalog,
			fidMSO_Flags,
			&ulFlags,
			sizeof( ulFlags ),
			&cbActual,
			JET_bitRetrieveCopy,
			NULL ) );

	if( ulFlags & JET_bitObjectTableTemplate
		|| ulFlags & JET_bitObjectTableFixedDDL )
		{
		//  we can't rename a template table becuase the derived tables won't be updated
		Call( ErrERRCheck( JET_errFixedDDL ) );
		}

	Call( ErrIsamSetColumn(
			ppib,
			pfucbCatalog,
			fidMSO_Name,
			szNameNew,
			(ULONG)strlen( szNameNew ),
			NO_GRBIT,
			NULL ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );
	fUpdatePrepared = fFalse;

HandleError:
	if( fUpdatePrepared )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepCancel ) );
		}
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	return err;
	}


//  ================================================================
ERR ErrCATRenameTable(
	PIB				* const ppib,
	const IFMP		ifmp,
	const CHAR		* const szNameOld,
	const CHAR		* const szNameNew )
//  ================================================================
	{
	ERR 			err;
	INT				fState				= fFCBStateNull;
	FCB				* pfcbTable			= pfcbNil;
	OBJID		 	objidTable;
	PGNO			pgnoFDPTable;
	MEMPOOL::ITAG	itagTableNameNew	= 0;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	Call( ErrCATSeekTable( ppib, ifmp, szNameOld, &pgnoFDPTable, &objidTable ) );

	//  check to see if the FCB is present and initialized
	//  if its not present we can just update the catalog

	pfcbTable = FCB::PfcbFCBGet( ifmp, pgnoFDPTable, &fState );
	if( pfcbNil != pfcbTable )
		{
		if( fFCBStateInitialized != fState )
			{

			//  this should only happen if this is called in a multi-threaded scenario
			//  (which it shouldn't be)

			Assert( fFalse );
			Call( ErrERRCheck( JET_errTableInUse ) );
			}

		//  place the new table name in memory, to avoid possibly running out of memory later

		TDB * const ptdb = pfcbTable->Ptdb();
		MEMPOOL& mempool = ptdb->MemPool();

		pfcbTable->EnterDDL();

		err = mempool.ErrAddEntry( (BYTE *)szNameNew, (ULONG)strlen( szNameNew ) + 1, &itagTableNameNew );
		Assert( 0 != itagTableNameNew || err < JET_errSuccess );	//	0 is used as "uninit"

		pfcbTable->LeaveDDL();

		Call( err );
		}

	Call( ErrCATIRenameTable( ppib, ifmp, objidTable, szNameNew, fFalse ) );
	Call( ErrCATIRenameTable( ppib, ifmp, objidTable, szNameNew, fTrue ) );

	//  once the commit succeeds, no errors can be generated

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

	if( pfcbNil != pfcbTable )
		{
		//	delete the old name from the catalog hash

		CATHashDelete( pfcbTable, const_cast< CHAR * >( szNameOld ) );

		pfcbTable->EnterDDL();

		TDB * const ptdb = pfcbTable->Ptdb();
		MEMPOOL& mempool = ptdb->MemPool();
		const MEMPOOL::ITAG itagTableNameOld = ptdb->ItagTableName();

		ptdb->SetItagTableName( itagTableNameNew );
		itagTableNameNew = 0;
		mempool.DeleteEntry( itagTableNameOld );

		pfcbTable->LeaveDDL();

		//	insert the new name into to the catalog hash

//	UNDONE: Can't reinsert into hash now because we may be renaming to a table that
//	has just been deleted, but that table's name does not get removed from the
//	hash table until the DeleteTable commits
///		CATHashInsert( pfcbTable );
		}

HandleError:

	if ( 0 != itagTableNameNew )
		{
		if ( pfcbNil != pfcbTable )
			{
			TDB * const ptdb = pfcbTable->Ptdb();
			MEMPOOL& mempool = ptdb->MemPool();

			pfcbTable->EnterDDL();
			mempool.DeleteEntry( itagTableNameNew );
			pfcbTable->LeaveDDL();
			}
		}

	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	if( pfcbNil != pfcbTable )
		{
		pfcbTable->Release();
		}
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIRenameTableObject(
	PIB				* const ppib,
	const IFMP		ifmp,
	const OBJID		objidTable,
	const SYSOBJ	sysobj,
	const OBJID		objid,
	const CHAR		* const szNameNew,
	ULONG			* pulFlags,
	const BOOL		fShadow )
//  ================================================================
	{
	ERR				err				= JET_errSuccess;
	FUCB			* pfucbCatalog	= pfucbNil;
	BOOL			fUpdatePrepared	= fFalse;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fShadow ) );

	Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobj, objid ) );
	Call( ErrDIRRelease( pfucbCatalog ) );

	Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplace ) );
	fUpdatePrepared = fTrue;

	Call( ErrIsamSetColumn(
			ppib,
			pfucbCatalog,
			fidMSO_Name,
			szNameNew,
			(ULONG)strlen( szNameNew ),
			NO_GRBIT,
			NULL ) );

	if ( NULL != pulFlags )
		{
		Call( ErrIsamSetColumn(
				ppib,
				pfucbCatalog,
				fidMSO_Flags,
				pulFlags,
				sizeof(ULONG),
				NO_GRBIT,
				NULL ) );
		}

	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );
	fUpdatePrepared = fFalse;

HandleError:
	if( fUpdatePrepared )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepCancel ) );
		}
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	return err;
	}


//  ================================================================
ERR ErrCATRenameColumn(
	PIB				* const ppib,
	const FUCB		* const pfucbTable,
	const CHAR		* const szNameOld,
	const CHAR		* const szNameNew,
	const JET_GRBIT	grbit )
//  ================================================================
	{
	ERR				err					= JET_errSuccess;
	const INT		cbSzNameNew			= (ULONG)strlen( szNameNew ) + 1;
	Assert( cbSzNameNew > 1 );

	MEMPOOL::ITAG	itagColumnNameNew	= 0;
	MEMPOOL::ITAG	itagColumnNameOld	= 0;

	FCB				* const pfcbTable 	= pfucbTable->u.pfcb;
	TDB				* const ptdbTable 	= pfcbTable->Ptdb();
	FIELD 			* pfield 			= NULL;
	OBJID 			objidTable;
	COLUMNID		columnid;
	ULONG			ulFlags;
	BOOL			fPrimaryIndexPlaceholder	= fFalse;

	Assert( 0 == ppib->level );
	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	objidTable 	= pfcbTable->ObjidFDP();

	pfcbTable->EnterDML();

	//  Get a pointer to the FIELD of the column
	//	WARNING: The following function does a LeaveDML() on error

	Call( ErrFILEPfieldFromColumnName(
			ppib,
			pfcbTable,
			szNameOld,
			&pfield,
			&columnid ) );

	pfcbTable->LeaveDML();

	if ( pfieldNil == pfield )
		{
		Call( ErrERRCheck( JET_errColumnNotFound ) );
		}

	pfcbTable->EnterDDL();

	//  put the new column name in the mempool
	//  do this before getting the FIELD in case we re-arrange the mempool

	err = ptdbTable->MemPool().ErrAddEntry( (BYTE *)szNameNew, cbSzNameNew, &itagColumnNameNew );
	if( err < 0 )
		{
		pfcbTable->LeaveDDL();
		Call( err );
		}
	Assert( 0 != itagColumnNameNew );	//	0 is used as "uninit"

	//	must refresh pfield pointer in case mempool got rearranged adding the new name
	pfield = ptdbTable->Pfield( columnid );
	Assert( pfieldNil != pfield );
	Assert( 0 == UtilCmpName( szNameOld, ptdbTable->SzFieldName( pfield->itagFieldName, fFalse ) ) );

	if ( grbit & JET_bitColumnRenameConvertToPrimaryIndexPlaceholder )
		{
		IDB		* const pidb	= pfcbTable->Pidb();

		//	placeholder column must be fixed bitfield and first column of primary index
		if ( JET_coltypBit != pfield->coltyp
			|| !FCOLUMNIDFixed( columnid )
			|| pidbNil == pidb
			|| pidb->Cidxseg() < 2
			|| PidxsegIDBGetIdxSeg( pidb, ptdbTable )[0].Columnid() != columnid )
			{
			AssertSz( fFalse, "Column cannot be converted to a placeholder." );
			pfcbTable->LeaveDDL();
			Call( ErrERRCheck( JET_errInvalidPlaceholderColumn ) );
			}

		Assert( pidb->FPrimary() );
		fPrimaryIndexPlaceholder = fTrue;

		ulFlags	= FIELDFLAGPersisted(
						FIELDFLAG( pfield->ffield | ffieldPrimaryIndexPlaceholder ) );
		}

	pfcbTable->LeaveDDL();


	//	Template bit is not persisted
	Assert( !FCOLUMNIDTemplateColumn( columnid ) || pfcbTable->FTemplateTable() );
	COLUMNIDResetFTemplateColumn( columnid );

	//  rename in the catalog and shadow catalog

	Call( ErrCATIRenameTableObject(
				ppib,
				pfucbTable->ifmp,
				objidTable,
				sysobjColumn,
				columnid,
				szNameNew,
				fPrimaryIndexPlaceholder ? &ulFlags : NULL,
				fFalse ) );
	Call( ErrCATIRenameTableObject(
				ppib,
				pfucbTable->ifmp,
				objidTable,
				sysobjColumn,
				columnid,
				szNameNew,
				fPrimaryIndexPlaceholder ? &ulFlags : NULL,
				fTrue ) );

	//  once the commit succeeds, no errors can be generated

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

	pfcbTable->EnterDML();

	Call( ErrFILEPfieldFromColumnName(
			ppib,
			pfcbTable,
			szNameOld,
			&pfield,
			&columnid ) );
	Assert( pfieldNil != pfield );

	itagColumnNameOld = pfield->itagFieldName;
	Assert( itagColumnNameOld != itagColumnNameNew );

	pfield->itagFieldName = itagColumnNameNew;
	pfield->strhashFieldName = StrHashValue( szNameNew );
	itagColumnNameNew = 0;

	pfcbTable->LeaveDML();
	pfcbTable->EnterDDL();

	ptdbTable->MemPool().DeleteEntry( itagColumnNameOld );

	if ( fPrimaryIndexPlaceholder )
		{
		FIELDSetPrimaryIndexPlaceholder( pfield->ffield );

		Assert( pidbNil != pfcbTable->Pidb() );
		Assert( pfcbTable->Pidb()->FPrimary() );
		pfcbTable->Pidb()->SetFHasPlaceholderColumn();
		}

	pfcbTable->LeaveDDL();

HandleError:

	if( 0 != itagColumnNameNew )
		{
		pfcbTable->EnterDDL();
		ptdbTable->MemPool().DeleteEntry( itagColumnNameNew );
		pfcbTable->LeaveDDL();
		}

	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	return err;
	}


//  ================================================================
ERR ErrCATAddCallbackToTable(
	PIB * const ppib,
	const IFMP ifmp,
	const CHAR * const szTable,
	const JET_CBTYP cbtyp,
	const CHAR * const szCallback )
//  ================================================================
//
//  Used during upgrade. This does not add the callback to the TDB
//  and doesn't version it properly
//
//-
	{
	ERR 	err 			= JET_errSuccess;
	OBJID 	objidTable		= objidNil;
	PGNO	pgnoFDPTable	= pgnoNull;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDPTable, &objidTable ) );
	Call( ErrCATAddTableCallback( ppib, ifmp, objidTable, cbtyp, szCallback ) );
	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


//  ================================================================
ERR ErrCATIConvert(
	PIB * const ppib,
	FUCB * const pfucbCatalog,
	JET_SETCOLUMN * const psetcols,
	const ULONG csetcols )
//  ================================================================
	{
	ERR		err				= JET_errSuccess;

	CallR( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );
	Call( ErrIsamSetColumns( (JET_SESID)ppib, (JET_VTID)pfucbCatalog, psetcols, csetcols ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );

HandleError:
	if( err < 0 )
		{
		Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepCancel ) );
		}
	return err;
	}

//  ================================================================
ERR ErrCATAddColumnCallback(
	PIB * const ppib,
	const IFMP ifmp,
	const CHAR * const szTable,
	const CHAR * const szColumn,
	const CHAR * const szCallback,
	const VOID * const pvCallbackData,
	const unsigned long cbCallbackData
	)
//  ================================================================
	{
	ERR 		err 			= JET_errSuccess;
	OBJID 		objidTable		= objidNil;
	PGNO		pgnoFDPTable	= pgnoNull;
	FUCB *		pfucbCatalog	= pfucbNil;
	BOOKMARK	bm;
	BYTE 		rgbBookmark[JET_cbBookmarkMost];
	ULONG 		cbBookmark;
	DATA		dataField;
	FIELDFLAG	ffield 		= 0;
	ULONG		ulFlags;

	JET_SETCOLUMN	rgsetcolumn[3];
	memset( rgsetcolumn, 0, sizeof( rgsetcolumn ) );

	rgsetcolumn[0].columnid	= fidMSO_Callback;
	rgsetcolumn[0].pvData	= szCallback;
	rgsetcolumn[0].cbData	= (ULONG)strlen( szCallback );
	rgsetcolumn[0].grbit	= NO_GRBIT;
	rgsetcolumn[0].ibLongValue	= 0;
	rgsetcolumn[0].itagSequence	= 1;
	rgsetcolumn[0].err		= JET_errSuccess;

	rgsetcolumn[1].columnid	= fidMSO_CallbackData;
	rgsetcolumn[1].pvData	= pvCallbackData;
	rgsetcolumn[1].cbData	= cbCallbackData;
	rgsetcolumn[1].grbit	= NO_GRBIT;
	rgsetcolumn[1].ibLongValue	= 0;
	rgsetcolumn[1].itagSequence	= 1;
	rgsetcolumn[1].err		= JET_errSuccess;

	rgsetcolumn[2].columnid	= fidMSO_Flags;
	rgsetcolumn[2].pvData	= &ulFlags;
	rgsetcolumn[2].cbData	= sizeof( ulFlags );
	rgsetcolumn[2].grbit	= NO_GRBIT;
	rgsetcolumn[2].ibLongValue 	= 0;
	rgsetcolumn[2].itagSequence	= 1;
	rgsetcolumn[2].err		= JET_errSuccess;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDPTable, &objidTable ) );

	//  We have to modify both the catalog and the shadow catalog
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );	//  catalog
	Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjColumn, szColumn ) );

	// get the exsiting flags
	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Flags,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ffield = *(UnalignedLittleEndian< FIELDFLAG > *)dataField.Pv();

	FIELDSetUserDefinedDefault( ffield );
	FIELDSetDefault( ffield );

	ulFlags = ffield;

	Call( ErrDIRRelease( pfucbCatalog ) );

	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrCATIConvert( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );		//	shadow catalog
	Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );
	Call( ErrCATIConvert( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}

//  ================================================================
ERR ErrCATConvertColumn(
	PIB * const ppib,
	const IFMP ifmp,
	const CHAR * const szTable,
	const CHAR * const szColumn,
	const JET_COLTYP coltyp,
	const JET_GRBIT grbit )
//  ================================================================
	{
	ERR 		err 			= JET_errSuccess;
	OBJID 		objidTable		= objidNil;
	PGNO		pgnoFDPTable	= pgnoNull;
	FUCB *		pfucbCatalog	= pfucbNil;
	BOOKMARK	bm;
	BYTE		rgbBookmark[JET_cbBookmarkMost];
	ULONG		cbBookmark;
	FIELDFLAG	ffield = 0;

	//  this does no error checking. its for specialized use
	if ( grbit & JET_bitColumnEscrowUpdate )
		{
		FIELDSetEscrowUpdate( ffield );
		FIELDSetDefault( ffield );		//	escrow update fields must have a default valie
		}
	if ( grbit & JET_bitColumnFinalize )
		{
		FIELDSetFinalize( ffield );
		}
	if ( grbit & JET_bitColumnDeleteOnZero )
		{
		FIELDSetDeleteOnZero( ffield );
		}
	if ( grbit & JET_bitColumnVersion )
		{
		FIELDSetVersion( ffield );
		}
	if ( grbit & JET_bitColumnAutoincrement )
		{
		FIELDSetAutoincrement( ffield );
		}
	if ( grbit & JET_bitColumnNotNULL )
		{
		FIELDSetNotNull( ffield );
		}
	if ( grbit & JET_bitColumnMultiValued )
		{
		FIELDSetMultivalued( ffield );
		}

	const ULONG ulFlags = ffield;

	JET_SETCOLUMN	rgsetcolumn[2];
	memset( rgsetcolumn, 0, sizeof( rgsetcolumn ) );

	rgsetcolumn[0].columnid	= fidMSO_Coltyp;
	rgsetcolumn[0].pvData	= &coltyp;
	rgsetcolumn[0].cbData	= sizeof( coltyp );
	rgsetcolumn[0].grbit	= NO_GRBIT;
	rgsetcolumn[0].ibLongValue	= 0;
	rgsetcolumn[0].itagSequence	= 1;
	rgsetcolumn[0].err		= JET_errSuccess;

	rgsetcolumn[1].columnid	= fidMSO_Flags;
	rgsetcolumn[1].pvData	= &ulFlags;
	rgsetcolumn[1].cbData	= sizeof( ulFlags );
	rgsetcolumn[1].grbit	= NO_GRBIT;
	rgsetcolumn[1].ibLongValue	= 0;
	rgsetcolumn[1].itagSequence	= 1;
	rgsetcolumn[1].err		= JET_errSuccess;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDPTable, &objidTable ) );

	//  We have to modify both the catalog and the shadow catalog
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );	//  catalog
	Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjColumn, szColumn ) );

	Call( ErrDIRRelease( pfucbCatalog ) );

	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrCATIConvert( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );		//	shadow catalog
	Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );
	Call( ErrCATIConvert( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


//  ================================================================
ERR ErrCATIncreaseMaxColumnSize(
	PIB * const			ppib,
	const IFMP			ifmp,
	const CHAR * const	szTable,
	const CHAR * const	szColumn,
	const ULONG			cbMaxLen )
//  ================================================================
	{
	ERR 				err 			= JET_errSuccess;
	OBJID 				objidTable		= objidNil;
	PGNO				pgnoFDPTable	= pgnoNull;
	FUCB *				pfucbCatalog	= pfucbNil;
	DATA				dataField;
	BOOKMARK			bm;
	BYTE				rgbBookmark[JET_cbBookmarkMost];
	ULONG				cbBookmark;
	JET_SETCOLUMN		rgsetcolumn[1];

	memset( rgsetcolumn, 0, sizeof( rgsetcolumn ) );

	rgsetcolumn[0].columnid	= fidMSO_SpaceUsage;
	rgsetcolumn[0].pvData	= &cbMaxLen;
	rgsetcolumn[0].cbData	= sizeof( cbMaxLen );
	rgsetcolumn[0].grbit	= NO_GRBIT;
	rgsetcolumn[0].ibLongValue	= 0;
	rgsetcolumn[0].itagSequence	= 1;
	rgsetcolumn[0].err		= JET_errSuccess;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDPTable, &objidTable ) );

	//  We have to modify both the catalog and the shadow catalog
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );	//  catalog
	Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjColumn, szColumn ) );

	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( FFixedFid( fidMSO_Coltyp ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Coltyp,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(JET_COLTYP) );
	if ( !FRECLongValue( *( UnalignedLittleEndian< JET_COLTYP > *)dataField.Pv() ) )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	if ( cbMaxLen > 0 )
		{
		Assert( FFixedFid( fidMSO_SpaceUsage ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_SpaceUsage,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(ULONG) );
		if ( *(UnalignedLittleEndian< ULONG > *)dataField.Pv() > cbMaxLen
			|| 0 == *(UnalignedLittleEndian< ULONG > *)dataField.Pv() )
			{
			//	cannot decrease max. column size
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		}

	Call( ErrDIRRelease( pfucbCatalog ) );

	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrCATIConvert( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );		//	shadow catalog
	Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );
	Call( ErrCATIConvert( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


//  ================================================================
ERR ErrCATChangeIndexDensity(
	PIB * const			ppib,
	const IFMP			ifmp,
	const CHAR * const	szTable,
	const CHAR * const	szIndex,
	const ULONG			ulDensity )
//  ================================================================
	{
	ERR 				err 			= JET_errSuccess;
	OBJID 				objidTable		= objidNil;
	PGNO				pgnoFDPTable	= pgnoNull;
	FUCB *				pfucbCatalog	= pfucbNil;
	DATA				dataField;
	BOOKMARK			bm;
	BYTE				rgbBookmark[JET_cbBookmarkMost];
	ULONG				cbBookmark;
	JET_SETCOLUMN		rgsetcolumn[1];

	if ( ulDensity < ulFILEDensityLeast || ulDensity > ulFILEDensityMost )
		{
		return ErrERRCheck( JET_errDensityInvalid );
		}

	memset( rgsetcolumn, 0, sizeof( rgsetcolumn ) );

	rgsetcolumn[0].columnid	= fidMSO_SpaceUsage;
	rgsetcolumn[0].pvData	= &ulDensity;
	rgsetcolumn[0].cbData	= sizeof( ulDensity );
	rgsetcolumn[0].grbit	= NO_GRBIT;
	rgsetcolumn[0].ibLongValue	= 0;
	rgsetcolumn[0].itagSequence	= 1;
	rgsetcolumn[0].err		= JET_errSuccess;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDPTable, &objidTable ) );

	//  We have to modify both the catalog and the shadow catalog,
	//	but start with the regular catalog first
	//
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );

	if ( NULL != szIndex )
		{
		//	index specified, so go to that index
		//
		Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjIndex, szIndex ) );
		}
	else
		{
		//	index not specified, so go to the primary index
		//
		err = ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjIndex, objidTable );

		if ( JET_errIndexNotFound == err )
			{
			//	no primary index, so go to the sequential index
			//
			err = ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjTable, objidTable );
			}

		Call( err );
		}

	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Call( ErrDIRRelease( pfucbCatalog ) );

	//	save the bookmark so we can use it to update
	//	the shadow catalog
	//
	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	//	update the catalog record
	//
	Call( ErrCATIConvert( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	//	now update the corresponding record
	//	in the shadow catalog
	//
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );		//	shadow catalog
	Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );
	Call( ErrCATIConvert( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


//  ================================================================
ERR ErrCATChangeIndexFlags(
	PIB * const			ppib,
	const IFMP			ifmp,
	const OBJID			objidTable,
	const CHAR * const	szIndex,
	const IDBFLAG		idbflagNew )
//  ================================================================
	{
	ERR 				err 			= JET_errSuccess;
	FUCB *				pfucbCatalog	= pfucbNil;
	DATA				dataField;
	BOOKMARK			bm;
	BYTE				rgbBookmark[JET_cbBookmarkMost];
	ULONG				cbBookmark;
	LE_IDXFLAG			le_idxflag;
	JET_SETCOLUMN		rgsetcolumn[1];

	memset( rgsetcolumn, 0, sizeof( rgsetcolumn ) );

	le_idxflag.fidb 		= idbflagNew;
	le_idxflag.fIDXFlags 	= fIDXExtendedColumns;

	//	Hack on this field: SetColumn() will convert the fixed
	//	columns. So convert it here so that later it can be
	//	converted back to current value.
	LONG		l			= *(LONG *)&le_idxflag;
	l = ReverseBytesOnBE( l );

	rgsetcolumn[0].columnid	= fidMSO_Flags;
	rgsetcolumn[0].pvData	= &l;
	rgsetcolumn[0].cbData	= sizeof( l );
	rgsetcolumn[0].grbit	= NO_GRBIT;
	rgsetcolumn[0].ibLongValue	= 0;
	rgsetcolumn[0].itagSequence	= 1;
	rgsetcolumn[0].err		= JET_errSuccess;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	//  We have to modify both the catalog and the shadow catalog,
	//	but start with the regular catalog first
	//
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );

	if ( NULL != szIndex )
		{
		//	index specified, so go to that index
		//
		Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjIndex, szIndex ) );
		}
	else
		{
		//	index not specified, so go to the primary index
		//
		Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjIndex, objidTable ) );
		}

	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Call( ErrDIRRelease( pfucbCatalog ) );

	//	save the bookmark so we can use it to update
	//	the shadow catalog
	//
	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	//	update the catalog record
	//
	Call( ErrCATIConvert( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	//	now update the corresponding record
	//	in the shadow catalog
	//
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );		//	shadow catalog
	Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );
	Call( ErrCATIConvert( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}



//  ================================================================
LOCAL ERR ErrCATIGetColumnsOfIndex(
	PIB			* const ppib,
	FUCB		* const pfucbCatalog,
	const OBJID	objidTable,
	const BOOL	fTemplateTable,
	const TCIB	* const ptcibTemplateTable,
	LE_IDXFLAG	* const ple_idxflag,
	IDXSEG		* const rgidxseg,
	ULONG		* const pcidxseg,
	IDXSEG		* const rgidxsegConditional,
	ULONG		* const pcidxsegConditional,
	BOOL		* const	pfPrimaryIndex
	)
//  ================================================================
	{
	ERR		err;
	DATA	dataField;

	Assert( !Pcsr( pfucbCatalog )->FLatched() );
	CallR( ErrDIRGet( pfucbCatalog ) );

	DATA&	dataRec = pfucbCatalog->kdfCurr.data;

	Assert( pfcbNil != pfucbCatalog->u.pfcb );
	Assert( pfucbCatalog->u.pfcb->FTypeTable() );
	Assert( pfucbCatalog->u.pfcb->FFixedDDL() );
	Assert( pfucbCatalog->u.pfcb->Ptdb() != ptdbNil );
	TDB * const ptdbCatalog = pfucbCatalog->u.pfcb->Ptdb();

	//	verify still on same table
	Assert( FFixedFid( fidMSO_ObjidTable ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_ObjidTable,
				dataRec,
				&dataField ) );
	CallS( err );
	if( dataField.Cb() != sizeof(OBJID)
		|| objidTable != *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) )
		{
		AssertSz( fFalse, "Catalog corruption" );
		Call( ErrERRCheck( JET_errCatalogCorrupted ) );
		}

	//	verify this is an index
	Assert( FFixedFid( fidMSO_Type ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Type,
				dataRec,
				&dataField ) );
	CallS( err );
	if( dataField.Cb() != sizeof(SYSOBJ)
		|| sysobjIndex != *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
		{
		AssertSz( fFalse, "Catalog corruption" );
		Call( ErrERRCheck( JET_errCatalogCorrupted ) );
		}

	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Flags,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );

	*ple_idxflag = *(LE_IDXFLAG*)dataField.Pv();

	if( FIDBPrimary( ple_idxflag->fidb ) )
		{
		*pfPrimaryIndex = fTrue;
		*pcidxseg = 0;
		*pcidxsegConditional = 0;
		goto HandleError;
		}

	*pfPrimaryIndex = fFalse;

	Assert( FVarFid( fidMSO_KeyFldIDs ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_KeyFldIDs,
				dataRec,
				&dataField ) );

	// the length of the list of key fields should be a multiple
	// of the length of one field.
	if ( FIDXExtendedColumns( ple_idxflag->fIDXFlags ) )
		{
		Assert( sizeof(IDXSEG) == sizeof(JET_COLUMNID) );
		Assert( dataField.Cb() <= sizeof(JET_COLUMNID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(JET_COLUMNID) == 0 );
		Assert( dataField.Cb() / sizeof(JET_COLUMNID) <= JET_ccolKeyMost );
		*pcidxseg = dataField.Cb() / sizeof(JET_COLUMNID);

		if ( FHostIsLittleEndian() )
			{
			UtilMemCpy( rgidxseg, dataField.Pv(), dataField.Cb() );
#ifdef DEBUG
			for ( ULONG iidxseg = 0; iidxseg < *pcidxseg; iidxseg++ )
				{
				Assert( !fTemplateTable || rgidxseg[iidxseg].FTemplateColumn() );
				Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );
				}
#endif
			}
		else
			{
			LE_IDXSEG		*le_rgidxseg	= (LE_IDXSEG*)dataField.Pv();
			for ( ULONG iidxseg = 0; iidxseg < *pcidxseg; iidxseg++ )
				{
				LE_IDXSEG le_idxseg = ((LE_IDXSEG*)le_rgidxseg)[iidxseg]; // see if this will work for CISCO UNIX
				rgidxseg[iidxseg] = le_idxseg;
				Assert( !fTemplateTable || rgidxseg[iidxseg].FTemplateColumn() );
				Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );
				}
			}
		}
	else
		{
		Assert( sizeof(IDXSEG_OLD) == sizeof(FID) );
		Assert( dataField.Cb() <= sizeof(FID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(FID) == 0);
		Assert( dataField.Cb() / sizeof(FID) <= JET_ccolKeyMost );
		*pcidxseg = dataField.Cb() / sizeof(FID);
		SetIdxSegFromOldFormat(
				(UnalignedLittleEndian< IDXSEG_OLD > *)dataField.Pv(),
				rgidxseg,
				*pcidxseg,
				fFalse,
				fTemplateTable,
				ptcibTemplateTable );
		}

	Assert( FVarFid( fidMSO_ConditionalColumns ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_ConditionalColumns,
				dataRec,
				&dataField ) );

	// the length of the list of key fields should be a multiple
	// of the length of one field.
	if ( FIDXExtendedColumns( ple_idxflag->fIDXFlags ) )
		{
		Assert( sizeof(IDXSEG) == sizeof(JET_COLUMNID) );
		Assert( dataField.Cb() <= sizeof(JET_COLUMNID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(JET_COLUMNID) == 0 );
		Assert( dataField.Cb() / sizeof(JET_COLUMNID) <= JET_ccolKeyMost );
		*pcidxsegConditional = dataField.Cb() / sizeof(JET_COLUMNID);

		if ( FHostIsLittleEndian() )
			{
			UtilMemCpy( rgidxsegConditional, dataField.Pv(), dataField.Cb() );
#ifdef DEBUG
			for ( ULONG iidxseg = 0; iidxseg < *pcidxsegConditional; iidxseg++ )
				{
				Assert( !fTemplateTable || rgidxsegConditional[iidxseg].FTemplateColumn() );
				Assert( FCOLUMNIDValid( rgidxsegConditional[iidxseg].Columnid() ) );
				}
#endif
			}
		else
			{
			LE_IDXSEG		*le_rgidxseg	= (LE_IDXSEG*)dataField.Pv();
			for ( ULONG iidxseg = 0; iidxseg < *pcidxsegConditional; iidxseg++ )
				{
				rgidxsegConditional[iidxseg] = le_rgidxseg[iidxseg];
				Assert( !fTemplateTable || rgidxsegConditional[iidxseg].FTemplateColumn() );
				Assert( FCOLUMNIDValid( rgidxsegConditional[iidxseg].Columnid() ) );
				}
			}
		}
	else
		{
		Assert( sizeof(IDXSEG_OLD) == sizeof(FID) );
		Assert( dataField.Cb() <= sizeof(FID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(FID) == 0);
		Assert( dataField.Cb() / sizeof(FID) <= JET_ccolKeyMost );
		*pcidxsegConditional = dataField.Cb() / sizeof(FID);
		SetIdxSegFromOldFormat(
				(UnalignedLittleEndian< IDXSEG_OLD > *)dataField.Pv(),
				rgidxsegConditional,
				*pcidxsegConditional,
				fTrue,
				fTemplateTable,
				ptcibTemplateTable );
		}

HandleError:
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	CallS( ErrDIRRelease( pfucbCatalog ) );

	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIAddConditionalColumnsToIndex(
	PIB * const ppib,
	FUCB * const pfucbCatalog,
	FUCB * const pfucbShadowCatalog,
	LE_IDXFLAG * ple_idxflag,
	const IDXSEG * const rgidxseg,
	const ULONG cidxseg,
	const IDXSEG * const rgidxsegExisting,
	const ULONG cidxsegExisting,
	const IDXSEG * const rgidxsegToAdd,
	const ULONG cidxsegToAdd )
//  ================================================================
//
//  pfucbCatalog should be on the record to be modified
//
//-
	{
	ERR 		err;
	BYTE		rgbBookmark[JET_cbBookmarkMost];
	ULONG 		cbBookmark;
	BOOKMARK	bm;
	UINT		iidxseg;
	IDXSEG 		rgidxsegConditional[JET_ccolKeyMost];
	BYTE		* pbidxsegConditional;
	ULONG		cidxsegConditional;
	LE_IDXSEG	le_rgidxsegConditional[JET_ccolKeyMost];
	LE_IDXSEG	le_rgidxseg[JET_ccolKeyMost];

	memcpy( rgidxsegConditional, rgidxsegExisting, sizeof(IDXSEG) * cidxsegExisting );

	//	start with the existing columns and add the new ones
	cidxsegConditional = cidxsegExisting;

	for ( iidxseg = 0; iidxseg < cidxsegToAdd; iidxseg++ )
		{
		//	verify column doesn't already exist in the list
		UINT	iidxsegT;
		for ( iidxsegT = 0; iidxsegT < cidxsegConditional; iidxsegT++ )
			{
			if ( rgidxsegConditional[iidxsegT].Columnid() == rgidxsegToAdd[iidxseg].Columnid() )
				{
				break;
				}
			}

		if ( iidxsegT == cidxsegConditional )
			{
			memcpy( rgidxsegConditional+cidxsegConditional, rgidxsegToAdd+iidxseg, sizeof(IDXSEG) );
			cidxsegConditional++;
			}
		}
	Assert( cidxsegConditional <= cidxsegExisting + cidxsegToAdd );

	if ( cidxsegConditional == cidxsegExisting )
		{
		//	nothing to do, just get out
		return JET_errSuccess;
		}
	else if( cidxsegConditional > JET_ccolKeyMost )
		{
		AssertSz( fFalse, "Too many conditional columns" );
		return ErrERRCheck( JET_errInvalidParameter );
		}

	LONG			l;
	JET_SETCOLUMN	rgsetcolumn[3];
	ULONG			csetcols = 0;
	memset( rgsetcolumn, 0, sizeof( rgsetcolumn ) );

	if ( FHostIsLittleEndian() )
		{
#ifdef DEBUG
		for ( iidxseg = 0; iidxseg < cidxsegConditional; iidxseg++ )
			{
			Assert( FCOLUMNIDValid( rgidxsegConditional[iidxseg].Columnid() ) );
			}
#endif

		pbidxsegConditional = (BYTE *)rgidxsegConditional;
		}
	else
		{
		for ( iidxseg = 0; iidxseg < cidxsegConditional; iidxseg++ )
			{
			Assert( FCOLUMNIDValid( rgidxsegConditional[iidxseg].Columnid() ) );

			//	Endian conversion
			le_rgidxsegConditional[iidxseg] = rgidxsegConditional[iidxseg];
			}

		pbidxsegConditional = (BYTE *)le_rgidxsegConditional;
		}

	//	see if we also have to update normal index columns to new format
	if ( !FIDXExtendedColumns( ple_idxflag->fIDXFlags ) )
		{
		BYTE	*pbidxseg;

		if ( FHostIsLittleEndian() )
			{
#ifdef DEBUG
			for ( iidxseg = 0; iidxseg < cidxseg; iidxseg++ )
				{
				Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );
				}
#endif

			pbidxseg = (BYTE *)rgidxseg;
			}
		else
			{
			for ( iidxseg = 0; iidxseg < cidxseg; iidxseg++ )
				{
				Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );

				//	Endian conversion
				le_rgidxseg[iidxseg] = rgidxseg[iidxseg];
				}

			pbidxseg = (BYTE *)le_rgidxseg;
			}

		rgsetcolumn[csetcols].columnid		= fidMSO_KeyFldIDs;
		rgsetcolumn[csetcols].pvData		= pbidxseg;
		rgsetcolumn[csetcols].cbData		= sizeof(IDXSEG) * cidxseg;
		rgsetcolumn[csetcols].grbit			= NO_GRBIT;
		rgsetcolumn[csetcols].ibLongValue	= 0;
		rgsetcolumn[csetcols].itagSequence	= 1;
		rgsetcolumn[csetcols].err			= JET_errSuccess;
		++csetcols;

		//	force to new format
		ple_idxflag->fIDXFlags = fIDXExtendedColumns;

		//	Hack on this field: SetColumn() will convert the fixed
		//	columns. So convert it here so that later it can be
		//	converted back to current value.
		l = ReverseBytesOnBE( *(LONG *)ple_idxflag );

		rgsetcolumn[csetcols].columnid		= fidMSO_Flags;
		rgsetcolumn[csetcols].pvData		= &l;
		rgsetcolumn[csetcols].cbData		= sizeof(l);
		rgsetcolumn[csetcols].grbit			= NO_GRBIT;
		rgsetcolumn[csetcols].ibLongValue	= 0;
		rgsetcolumn[csetcols].itagSequence	= 1;
		rgsetcolumn[csetcols].err			= JET_errSuccess;
		++csetcols;
		}

	rgsetcolumn[csetcols].columnid		= fidMSO_ConditionalColumns;
	rgsetcolumn[csetcols].pvData		= pbidxsegConditional;
	rgsetcolumn[csetcols].cbData		= sizeof(IDXSEG) * cidxsegConditional;
	rgsetcolumn[csetcols].grbit			= NO_GRBIT;
	rgsetcolumn[csetcols].ibLongValue	= 0;
	rgsetcolumn[csetcols].itagSequence	= 1;
	rgsetcolumn[csetcols].err			= JET_errSuccess;
	++csetcols;

	Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );
	Call( ErrIsamSetColumns( (JET_SESID)ppib, (JET_VTID)pfucbCatalog, rgsetcolumn, csetcols ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, rgbBookmark, sizeof( rgbBookmark ), &cbBookmark, NO_GRBIT ) );

	bm.key.Nullify();
	bm.data.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );

	Call( ErrDIRGotoBookmark( pfucbShadowCatalog, bm ) );
	Call( ErrIsamPrepareUpdate( ppib, pfucbShadowCatalog, JET_prepReplaceNoLock ) );
	Call( ErrIsamSetColumns( (JET_SESID)ppib, (JET_VTID)pfucbShadowCatalog, rgsetcolumn, csetcols ) );
	Call( ErrIsamUpdate( ppib, pfucbShadowCatalog, NULL, 0, NULL, NO_GRBIT ) );

HandleError:
	return err;
	}


//  ================================================================
ERR ErrCATAddConditionalColumnsToAllIndexes(
	PIB				* const ppib,
	const IFMP		ifmp,
	const CHAR		* const szTable,
	const JET_CONDITIONALCOLUMN	* rgconditionalcolumn,
	const ULONG		cConditionalColumn )
//  ================================================================
	{
	ERR 			err;
	OBJID 			objidTable;
	PGNO			pgnoFDPTable;
	FUCB			* pfucbCatalog			= pfucbNil;
	FUCB			* pfucbShadowCatalog	= pfucbNil;
	IDXSEG			rgidxsegToAdd[JET_ccolKeyMost];
	ULONG			iidxseg;
	ULONG			ulFlags;
	DATA			dataField;
	BOOL			fTemplateTable			= fFalse;
	OBJID			objidTemplateTable		= objidNil;
	TCIB			tcibTemplateTable		= { fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1 };
	LE_IDXFLAG		le_idxflag;
	const SYSOBJ	sysobj 					= sysobjIndex;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDPTable, &objidTable ) );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, objidTable ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	//	should be on primary index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );

	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Flags,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ulFlags = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( &ulFlags, dataField.Pv(), sizeof(ULONG) );

	if ( ulFlags & JET_bitObjectTableDerived )
		{
		CHAR		szTemplateTable[JET_cbNameMost+1];
		COLUMNID	columnidLeast;

		Assert( FVarFid( fidMSO_TemplateTable ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_TemplateTable,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() > 0 );
		Assert( dataField.Cb() <= JET_cbNameMost );
		UtilMemCpy( szTemplateTable, dataField.Pv(), dataField.Cb() );
		szTemplateTable[dataField.Cb()] = '\0';

		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );

		Call( ErrCATSeekTable( ppib, ifmp, szTemplateTable, NULL, &objidTemplateTable ) );
		Assert( objidNil != objidTemplateTable );

		columnidLeast = fidFixedLeast;
		CallR( ErrCATIFindLowestColumnid(
					ppib,
					pfucbCatalog,
					objidTable,
					&columnidLeast ) );
		tcibTemplateTable.fidFixedLast = FID( FFixedFid( FidOfColumnid( columnidLeast ) ) ?	//	use FFixedFid() to avoid valid columnid check
											FidOfColumnid( columnidLeast ) - 1 :
											fidFixedLeast - 1 );

		columnidLeast = fidVarLeast;
		CallR( ErrCATIFindLowestColumnid(
					ppib,
					pfucbCatalog,
					objidTable,
					&columnidLeast ) );
		tcibTemplateTable.fidVarLast = FID( FCOLUMNIDVar( columnidLeast ) ?
											FidOfColumnid( columnidLeast ) - 1 :
											fidVarLeast - 1 );

		columnidLeast = fidTaggedLeast;
		CallR( ErrCATIFindLowestColumnid(
					ppib,
					pfucbCatalog,
					objidTable,
					&columnidLeast ) );
		tcibTemplateTable.fidTaggedLast = FID( FCOLUMNIDTagged( columnidLeast ) ?
											FidOfColumnid( columnidLeast ) - 1 :
											fidTaggedLeast - 1 );
		}
	else
		{
		if ( ulFlags & JET_bitObjectTableTemplate )
			fTemplateTable = fTrue;

		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );
		}

	//	should still be on the primary index, which is the Id index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	for ( iidxseg = 0; iidxseg < cConditionalColumn; iidxseg++ )
		{
		const CHAR		* const szColumnName	= rgconditionalcolumn[iidxseg].szColumnName;
		const JET_GRBIT	grbit					= rgconditionalcolumn[iidxseg].grbit;
		COLUMNID		columnidT;
		BOOL			fColumnWasDerived;

		if( sizeof( JET_CONDITIONALCOLUMN ) != rgconditionalcolumn[iidxseg].cbStruct )
			{
			err = ErrERRCheck( JET_errIndexInvalidDef );
			Call( err );
			}

		if( JET_bitIndexColumnMustBeNonNull != grbit
			&& JET_bitIndexColumnMustBeNull != grbit )
			{
			err = ErrERRCheck( JET_errInvalidGrbit );
			Call( err );
			}

		err = ErrCATAccessTableColumn(
				ppib,
				ifmp,
				objidTable,
				szColumnName,
				&columnidT,
				!fTemplateTable );	//	only need to lock column if it's possible it might be deleted
		if ( JET_errColumnNotFound == err )
			{
			if ( objidNil != objidTemplateTable )
				{
				CallR( ErrCATAccessTableColumn(
						ppib,
						ifmp,
						objidTemplateTable,
						szColumnName,
						&columnidT ) );
				fColumnWasDerived = fTrue;
				}
			}
		else
			{
			CallR( err );
			}

		rgidxsegToAdd[iidxseg].ResetFlags();
		if ( JET_bitIndexColumnMustBeNull == grbit )
			rgidxsegToAdd[iidxseg].SetFMustBeNull();

		//	columnid's template bit is never persisted
		Assert( !FCOLUMNIDTemplateColumn( columnidT ) );
		if ( fColumnWasDerived || fTemplateTable )
			rgidxsegToAdd[iidxseg].SetFTemplateColumn();

		rgidxsegToAdd[iidxseg].SetFid( FidOfColumnid( columnidT ) );
		}

	Call( ErrCATOpen( ppib, ifmp, &pfucbShadowCatalog, fTrue ) );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );

	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekGT );
	if ( err < 0 )
		{
		if ( JET_errRecordNotFound != err )
			{
			//  No indexes?!
			Assert( fFalse );
			goto HandleError;
			}
		}
	else
		{
		CallS( err );

		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					(BYTE *)&objidTable,
					sizeof(objidTable),
					JET_bitNewKey ) );
		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					(BYTE *)&sysobj,
					sizeof(sysobj),
					JET_bitStrLimit ) );
		err = ErrIsamSetIndexRange( ppib, pfucbCatalog, JET_bitRangeUpperLimit );
		Assert( err <= 0 );
		while ( JET_errNoCurrentRecord != err )
			{
			IDXSEG	rgidxseg[JET_ccolKeyMost];
			IDXSEG	rgidxsegConditional[JET_ccolKeyMost];
			ULONG	cidxseg;
			ULONG	cidxsegConditional;
			BOOL	fPrimaryIndex;

			Call( err );

			Call( ErrCATIGetColumnsOfIndex(
					ppib,
					pfucbCatalog,
					objidTable,
					fTemplateTable,
					( objidNil != objidTemplateTable ? &tcibTemplateTable : NULL ),
					&le_idxflag,
					rgidxseg,
					&cidxseg,
					rgidxsegConditional,
					&cidxsegConditional,
					&fPrimaryIndex ) );

			if( !fPrimaryIndex )
				{
				Call( ErrCATIAddConditionalColumnsToIndex(
					ppib,
					pfucbCatalog,
					pfucbShadowCatalog,
					&le_idxflag,
					rgidxseg,
					cidxseg,
					rgidxsegConditional,
					cidxsegConditional,
					rgidxsegToAdd,
					cConditionalColumn ) );
				}

			err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
			}

		Assert( JET_errNoCurrentRecord == err );
		err = JET_errSuccess;
		}

	err = ErrDIRCommitTransaction( ppib, NO_GRBIT );

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	if( pfucbNil != pfucbShadowCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbShadowCatalog ) );
		}
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


// for addinf SLV tree and SLV Space Map Tree
LOCAL ERR ErrCATAddDbSLVObject(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const CHAR		*szName,
	const PGNO		pgnoFDP,
	const OBJID		objidSLV,
	const SYSOBJ	sysobj,
	const ULONG		ulPages)
	{
	DATA			rgdata[idataMSOMax];
	const OBJID		objid				= objidSystemRoot;
	const ULONG		ulDensity			= ulFILEDensityMost;
	const ULONG		ulFlagsNil			= 0;

	//	must zero out to ensure unused fields are ignored
	memset( rgdata, 0, sizeof(rgdata) );

	rgdata[iMSO_ObjidTable].SetPv(		(BYTE *)&objid );
	rgdata[iMSO_ObjidTable].SetCb(		sizeof(objid) );
	rgdata[iMSO_Type].SetPv(			(BYTE *)&sysobj );
	rgdata[iMSO_Type].SetCb(			sizeof(sysobj) );
	rgdata[iMSO_Id].SetPv(				(BYTE *)&objidSLV );
	rgdata[iMSO_Id].SetCb(				sizeof(objidSLV) );
	rgdata[iMSO_Name].SetPv(			(BYTE *)szName );
	rgdata[iMSO_Name].SetCb(			strlen( szName ) );
	rgdata[iMSO_PgnoFDP].SetPv(			(BYTE *)&pgnoFDP );
	rgdata[iMSO_PgnoFDP].SetCb(			sizeof(pgnoFDP) );
	rgdata[iMSO_SpaceUsage].SetPv(		(BYTE *)&ulDensity );
	rgdata[iMSO_SpaceUsage].SetCb(		sizeof(ulDensity) );
	rgdata[iMSO_Flags].SetPv(			(BYTE *)&ulFlagsNil );
	rgdata[iMSO_Flags].SetCb(			sizeof(ulFlagsNil) );
	rgdata[iMSO_Pages].SetPv(			(BYTE *)&ulPages );
	rgdata[iMSO_Pages].SetCb(			sizeof(ulPages) );

	return ErrCATInsert( ppib, pfucbCatalog, rgdata, iMSO_Pages );
	}


LOCAL ERR ErrCATAccessDbSLVObject(
	PIB				* const ppib,
	const IFMP		ifmp,
	const CHAR		* const szName,
	PGNO			* const ppgno,
	OBJID			* const pobjid,
	const SYSOBJ 	sysobj)
	{
	ERR				err;
	FUCB			*pfucbCatalog	= pfucbNil;

	Assert( NULL != ppgno );
	*ppgno 	= pgnoNull;
	*pobjid = objidNil;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	err = ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidSystemRoot,
				sysobj,
				szName );

	if ( JET_errSuccess <= err  )
		{
		DATA	dataField;

		Assert( Pcsr( pfucbCatalog )->FLatched() );

		Assert( FFixedFid( fidMSO_PgnoFDP ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_PgnoFDP,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(PGNO) );

		*ppgno = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//		UtilMemCpy( ppgno, dataField.Pv(), sizeof(PGNO) );

		Assert( FFixedFid( fidMSO_Id ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Id,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(OBJID) );

		*pobjid = *(UnalignedLittleEndian< OBJID > *) dataField.Pv();
//		UtilMemCpy( pobjid, dataField.Pv(), sizeof(OBJID) );
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


//  ================================================================
static JET_COLUMNCREATE	rgcolumncreateMSU[] =
//  ================================================================
	{

#define MSU_COLUMN_GRBIT JET_bitColumnTagged
// 	  cbStruct,                 szColumn,        coltyp,               cbMax, grbit,               pvDefault, cbDefault, cp, columnid, err

	{ sizeof(JET_COLUMNCREATE), "objidTable",    JET_coltypLong,       4,     MSU_COLUMN_GRBIT,    NULL,      0,         0,  0,        JET_errSuccess },
	{ sizeof(JET_COLUMNCREATE), "objidIndex",    JET_coltypLong,       4,     MSU_COLUMN_GRBIT,    NULL,      0,         0,  0,        JET_errSuccess },
	{ sizeof(JET_COLUMNCREATE), "keyPrimary",    JET_coltypLongBinary, 0,     MSU_COLUMN_GRBIT,    NULL,      0,         0,  0,        JET_errSuccess },
	{ sizeof(JET_COLUMNCREATE), "keySecondary",  JET_coltypLongBinary, 0,     MSU_COLUMN_GRBIT,    NULL,      0,         0,  0,        JET_errSuccess },
	{ sizeof(JET_COLUMNCREATE), "lcid",          JET_coltypLong,       4,     MSU_COLUMN_GRBIT,    NULL,      0,         0,  0,        JET_errSuccess },
	{ sizeof(JET_COLUMNCREATE), "sortVersion",   JET_coltypLong,       4,     MSU_COLUMN_GRBIT,    NULL,      0,         0,  0,        JET_errSuccess },
	{ sizeof(JET_COLUMNCREATE), "definedVersion",JET_coltypLong,       4,     MSU_COLUMN_GRBIT,    NULL,      0,         0,  0,        JET_errSuccess },
	{ sizeof(JET_COLUMNCREATE), "itag",          JET_coltypLong,       4,     MSU_COLUMN_GRBIT,    NULL,      0,         0,  0,        JET_errSuccess },
	{ sizeof(JET_COLUMNCREATE), "ichOffset",     JET_coltypLong,       4,     MSU_COLUMN_GRBIT,    NULL,      0,         0,  0,        JET_errSuccess },

	{ sizeof(JET_COLUMNCREATE), "autoinc",       JET_coltypCurrency,   8,     JET_bitColumnFixed | JET_bitColumnAutoincrement,    NULL,      0,         0,  0,        JET_errSuccess },
	};

static const JET_COLUMNID columnidMSU_objidTable		= fidTaggedLeast;
static const JET_COLUMNID columnidMSU_objidIndex		= fidTaggedLeast + 1;
static const JET_COLUMNID columnidMSU_primaryKey		= fidTaggedLeast + 2;
static const JET_COLUMNID columnidMSU_secondaryKey		= fidTaggedLeast + 3;
static const JET_COLUMNID columnidMSU_lcid				= fidTaggedLeast + 4;
static const JET_COLUMNID columnidMSU_sortVersion		= fidTaggedLeast + 5;
static const JET_COLUMNID columnidMSU_definedVersion	= fidTaggedLeast + 6;
static const JET_COLUMNID columnidMSU_itag				= fidTaggedLeast + 7;
static const JET_COLUMNID columnidMSU_ichOffset			= fidTaggedLeast + 8;
static const JET_COLUMNID columnidMSU_autoinc			= fidFixedLeast;

static const INT ccolumnsMSU	= sizeof( rgcolumncreateMSU ) / sizeof( rgcolumncreateMSU[0] );

//	these indexes have the objidIndex descending. this means that traversing the records in order
//	encounters any records describing a corruption in the primary index last. this makes cleanup
//	easier (the primary key corruptions have to be fixed last)

static const CHAR szMSUPrimaryIndex[]			= "primary";
static const CHAR szMSUPrimaryIndexKey[]		= "+objidTable\0-objidIndex\0+autoinc\0";

static const CHAR szMSUSecondaryIndex[]			= "secondary";
static const CHAR szMSUSecondaryIndexKey[]		= "+objidTable\0-objidIndex\0+keyPrimary\0+keySecondary\0+itag\0+ichOffset\0";

//  ================================================================
static JET_INDEXCREATE rgindexcreateMSU[] = {
//  ================================================================
	{
	sizeof( JET_INDEXCREATE ),							// size of this structure (for future expansion)
	const_cast<char *>( szMSUPrimaryIndex ),			// index name
	const_cast<char *>( szMSUPrimaryIndexKey ),			// index key
	sizeof( szMSUPrimaryIndexKey ),						// length of key
	JET_bitIndexPrimary,								// index options
	100,												// index density
	0,													// lcid for the index
	0,													// maximum length of variable length columns in index key
	NULL,												// pointer to conditional column structure
	0,													// number of conditional columns
	JET_errSuccess										// returned error code
	},
	{
	sizeof( JET_INDEXCREATE ),							// size of this structure (for future expansion)
	const_cast<char *>( szMSUSecondaryIndex ),			// index name
	const_cast<char *>( szMSUSecondaryIndexKey ),		// index key
	sizeof( szMSUSecondaryIndexKey ),					// length of key
	NO_GRBIT,											// index options
	100,												// index density
	0,													// lcid for the index
	0,													// maximum length of variable length columns in index key
	NULL,												// pointer to conditional column structure
	0,													// number of conditional columns
	JET_errSuccess										// returned error code
	},
};


//  ================================================================
static JET_TABLECREATE2 tablecreateMSU = {
//  ================================================================
	sizeof( JET_TABLECREATE2 ),										// size of this structure
	const_cast<char *>( szMSU ),									// name of table
	NULL,															// name of base table
	2,																// initial pages
	100,															// density
	rgcolumncreateMSU,												// columns to create
	ccolumnsMSU,													// number of columns to create
	rgindexcreateMSU,												// array of index creation info
	sizeof( rgindexcreateMSU ) / sizeof( rgindexcreateMSU[0] ),		// number of indexes to create
	NULL,															// callback to use for this table
	JET_cbtypNull,													// when the callback should be called
	JET_bitTableCreateSystemTable,									// grbit
	0,																// returned tableid
	0																// returned count of objects created
};


//  ================================================================
ERR ErrCATCreateMSU(
		IN PIB * const ppib,
		IN const IFMP ifmp )
//  ================================================================
	{
	ERR 	err 			= JET_errSuccess;
	BOOL 	fInTransaction 	= fFalse;

	Assert( !fGlobalRepair );
	Assert( ppibNil != ppib );
	Assert( ifmpNil != ifmp );
	Assert( szMSU == tablecreateMSU.szTableName );

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID  dbid 	= (JET_DBID)ifmp;

	Assert( !fInTransaction );
	Call( ErrIsamBeginTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fTrue;

	Call( ErrFILECreateTable( ppib, dbid, &tablecreateMSU ) );

	Assert( columnidMSU_objidTable 		== rgcolumncreateMSU[0].columnid );
	Assert( columnidMSU_objidIndex 		== rgcolumncreateMSU[1].columnid );
	Assert( columnidMSU_primaryKey 		== rgcolumncreateMSU[2].columnid );
	Assert( columnidMSU_secondaryKey 	== rgcolumncreateMSU[3].columnid );
	Assert( columnidMSU_lcid 			== rgcolumncreateMSU[4].columnid );
	Assert( columnidMSU_sortVersion 	== rgcolumncreateMSU[5].columnid );
	Assert( columnidMSU_definedVersion 	== rgcolumncreateMSU[6].columnid );
	Assert( columnidMSU_itag 			== rgcolumncreateMSU[7].columnid );
	Assert( columnidMSU_ichOffset 		== rgcolumncreateMSU[8].columnid );
	Assert( columnidMSU_autoinc			== rgcolumncreateMSU[9].columnid );
	Assert( 10 == ccolumnsMSU );

	Call( ErrFILECloseTable( ppib, (FUCB *)tablecreateMSU.tableid ) );

	Assert( fInTransaction );
	Call( ErrIsamCommitTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fFalse;

HandleError:

	if( fInTransaction )
		{
		CallS( ErrIsamRollback( sesid, NO_GRBIT ) );
		fInTransaction = fFalse;
		}

	OSTrace(
		ostlMedium,
		OSFormat(
			"creating %s on ifmp %d with pib 0x%x (error = %d)",
			szMSU,
			ifmp,
			ppib,
			err ) );

	Assert( !fInTransaction );
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIDeleteMSUTable(
		IN PIB * const ppib,
		IN const IFMP ifmp )
//  ================================================================
	{
	ERR 	err 			= JET_errSuccess;
	BOOL 	fInTransaction 	= fFalse;

	Assert( ppibNil != ppib );
	Assert( ifmpNil != ifmp );
	Assert( szMSU == tablecreateMSU.szTableName );

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID  dbid 	= (JET_DBID)ifmp;

	Assert( !fInTransaction );
	Call( ErrIsamBeginTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fTrue;

	Call( ErrIsamDeleteTable( sesid, dbid, szMSU ) );

	Assert( fInTransaction );
	Call( ErrIsamCommitTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fFalse;

HandleError:

	if( fInTransaction )
		{
		CallS( ErrIsamRollback( sesid, NO_GRBIT ) );
		fInTransaction = fFalse;
		}

	OSTrace(
		ostlMedium,
		OSFormat(
			"deleting %s on ifmp %d with pib 0x%x (error = %d)",
			szMSU,
			ifmp,
			ppib,
			err ) );

	Assert( !fInTransaction );
	return err;
	}


//
//	resetFixupFlag: unset the fixup flag on the index
//	updateUnicodeVersion: set the unicode version stamp on the index to the current OS versions
//

enum INDEXACTION { resetFixupFlag, updateUnicodeVersion };

//  ================================================================
LOCAL ERR ErrCATIChangeUnicodeFixupFlagsOnOneRecord(
		IN PIB * const ppib,
		IN FUCB * const pfucbCatalog,
		IN const INDEXACTION indexaction,
		OUT BOOL * const pfReset )
//  ================================================================
	{
	Assert( FHostIsLittleEndian() );

	ERR 	err 		= JET_errSuccess;
	BOOL	fInUpdate	= fFalse;

	*pfReset = fFalse;

	const JET_SESID 	sesid 		= (JET_SESID)ppib;
	const JET_TABLEID	tableid		= (JET_TABLEID)pfucbCatalog;
	const INT cretrievecolumn 	= 2;
	INT iretrievecolumn			= 0;
	JET_RETRIEVECOLUMN	rgretrievecolumn[cretrievecolumn];

	LE_IDXFLAG 	idxflag;
	SYSOBJ 		sysobj;
	memset( rgretrievecolumn, 0, sizeof( rgretrievecolumn ) );

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Type;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&sysobj;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( sysobj );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Flags;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&idxflag;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( idxflag );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;

	Assert( cretrievecolumn == iretrievecolumn );

	Call( ErrIsamRetrieveColumns(
		sesid,
		tableid,
		rgretrievecolumn,
		iretrievecolumn ) );
	CallS( err );	//	no null columns allowed

	if( sysobjIndex != sysobj
		|| !FIDBUnicodeFixupOn( idxflag.fidb ) )
		{
		return JET_errSuccess;
		}

	//	this is a fixup-enabled index

	Assert( !fInUpdate );
	Call( ErrIsamPrepareUpdate( sesid, tableid, JET_prepReplace ) );
	fInUpdate = fTrue;

	if( resetFixupFlag == indexaction )
		{
		idxflag.fidb = (IDBFLAG)(idxflag.fidb & ~fidbUnicodeFixupOn);
		Call( ErrIsamSetColumn( sesid, tableid, fidMSO_Flags, &idxflag, sizeof( idxflag ), NO_GRBIT, NULL ) );
		}
	else if( updateUnicodeVersion == indexaction )
		{
		LCID	lcid			= 0;
		QWORD 	qwSortVersion 	= 0;
		ULONG	cbActual		= 0;

		Call( ErrIsamRetrieveColumn(
			sesid,
			tableid,
			fidMSO_Localization,
			&lcid,
			sizeof( lcid ),
			&cbActual,
			NO_GRBIT,
			NULL ) );

		Call( ErrNORMGetSortVersion( lcid, &qwSortVersion ) );
		Call( ErrIsamSetColumn( sesid, tableid, fidMSO_Version, &qwSortVersion, sizeof( qwSortVersion ), NO_GRBIT, NULL ) );
		}
	else
		{
		Assert( fFalse );
		Call( ErrERRCheck( JET_errInternalError ) );
		}

	Assert( fInUpdate );
	Call( ErrIsamUpdate( sesid, tableid, NULL, 0, NULL, NO_GRBIT ) );
	fInUpdate = fFalse;

HandleError:
	if( fInUpdate )
		{
		CallS( ErrIsamPrepareUpdate( sesid, tableid, JET_prepCancel ) );
		fInUpdate = fFalse;
		}

	Assert( !fInUpdate );
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIChangeUnicodeFixupFlagsOnAllIndexes(
		IN PIB * const ppib,
		IN FUCB * const pfucbCatalog,
		IN const INDEXACTION indexaction,
		OUT QWORD * const pqwIndexesChanged )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	*pqwIndexesChanged = 0;

	for( err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveFirst, NO_GRBIT );
		 JET_errSuccess == err;
		 err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT ) )
		{
		BOOL fChanged = fFalse;
		err = ErrCATIChangeUnicodeFixupFlagsOnOneRecord( ppib, pfucbCatalog, indexaction, &fChanged );
		if( fChanged )
			{
			++(*pqwIndexesChanged);
			}
		}

	if( JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;
		}

	return err;
	}



//  ================================================================
LOCAL ERR ErrCATIChangeUnicodeFixupFlags(
		IN PIB * const ppib,
		IN const IFMP ifmp,
		IN const INDEXACTION indexaction )
//  ================================================================
	{
	ERR 	err 			= JET_errSuccess;
	BOOL	fInTransaction	= fFalse;
	FUCB * 	pfucbCatalog	= pfucbNil;

	QWORD	qwIndexesChanged		=	0;
	QWORD	qwIndexesChangedShadow	=	0;

	Assert( !fInTransaction );
	Call( ErrIsamBeginTransaction( (JET_SESID)ppib, NO_GRBIT ) );
	fInTransaction = fTrue;

	Assert( pfucbNil == pfucbCatalog );
	Call( ErrCATOpen( ppib, ifmp, 
&pfucbCatalog, fFalse ) );

	Call( ErrCATIChangeUnicodeFixupFlagsOnAllIndexes( ppib, pfucbCatalog, indexaction, &qwIndexesChanged ) );

	Assert( pfucbNil != pfucbCatalog );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Assert( pfucbNil == pfucbCatalog );
	Call( ErrCATOpen( ppib, ifmp, 
&pfucbCatalog, fTrue ) );

	Call( ErrCATIChangeUnicodeFixupFlagsOnAllIndexes( ppib, pfucbCatalog, indexaction, &qwIndexesChangedShadow ) );
	Assert( qwIndexesChanged == qwIndexesChangedShadow );

	Assert( pfucbNil != pfucbCatalog );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Assert( fInTransaction );
	Call( ErrIsamCommitTransaction( (JET_SESID)ppib, NO_GRBIT ) );
	fInTransaction = fFalse;

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		pfucbCatalog = pfucbNil;
		}

	if( fInTransaction )
		{
		(void)ErrIsamRollback( (JET_SESID)ppib, NO_GRBIT );
		fInTransaction = fFalse;
		}

	Assert( !fInTransaction );
	Assert( pfucbNil == pfucbCatalog );
	return err;
	}


//  ================================================================
ERR ErrCATDeleteMSU(
		IN PIB * const ppib,
		IN const IFMP ifmp )
//  ================================================================
//
//	This removes the MSU table and resets the unicode-fixup-enabled
//	flag on all the indexes in the catalog (and shadow catalog)
//
//	o	Open the catalog
//	o 	Reset the flags
//	o 	Open the shadow catalog
//	o	Reset the flags
//	o	Delete the MSU table
//
//
//-
	{
	ERR 	err 			= JET_errSuccess;
	BOOL	fDatabaseOpen	= fFalse;
	BOOL	fInTransaction	= fFalse;

	CHAR * const szDatabaseName	= rgfmp[ifmp].SzDatabaseName();
	IFMP		ifmpT;

	Call( ErrDBOpenDatabase( ppib, szDatabaseName, &ifmpT, NO_GRBIT ) );
	Assert( ifmp == ifmpT );
	fDatabaseOpen = fTrue;

	Assert( !fInTransaction );
	Call( ErrIsamBeginTransaction( (JET_SESID)ppib, NO_GRBIT ) );
	fInTransaction = fTrue;

	Call( ErrCATIChangeUnicodeFixupFlags( ppib, ifmp, resetFixupFlag ) );

	err = ErrCATIDeleteMSUTable( ppib, ifmp);
	if( JET_errObjectNotFound == err )
		{
		err = JET_errSuccess;
		}
	Call( err );

	Assert( fInTransaction );
	Call( ErrIsamCommitTransaction( (JET_SESID)ppib, NO_GRBIT ) );
	fInTransaction = fFalse;

HandleError:
	if( fInTransaction )
		{
		(void)ErrIsamRollback( (JET_SESID)ppib, NO_GRBIT );
		fInTransaction = fFalse;
		}
	if( fDatabaseOpen )
		{
		CallS( ErrDBCloseDatabase( ppib, ifmpT, NO_GRBIT ) );
		}

	Assert( !fInTransaction );
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATRetrieveMSURecord(
		IN 		PIB * const 	ppib,
		IN 		FUCB * const 	pfucbMSU,
		OUT 	OBJID * const 	pobjidTable,
		OUT 	OBJID * const 	pobjidIndex,
		OUT 	BYTE * const 	rgbPrimaryKey,
		IN OUT 	INT * const 	pcbPrimaryKey,
		OUT 	BYTE * const 	rgbSecondaryKey,
		IN OUT 	INT * const 	pcbSecondaryKey,
		OUT 	LCID * const 	plcid,
		OUT		DWORD * const	pdwSortVersion,
		OUT		DWORD * const	pdwDefinedVersion,
		OUT 	INT * const		pitag,
		OUT 	INT * const		pichOffset )
//  ================================================================
	{
	ERR 	err 			= JET_errSuccess;

	JET_RETRIEVECOLUMN rgretrievecolumn[ccolumnsMSU-1];	//	subtract one as we don't retrieve the autoinc column
	INT iretrievecolumn = 0;

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_VTID 	tableid = (JET_VTID)pfucbMSU;

	INT iretrievecolumnPrimaryKey	= -1;
	INT iretrievecolumnSecondaryKey	= -1;

	memset( rgretrievecolumn, 0, sizeof( rgretrievecolumn ) );

	for( 	iretrievecolumn = 0;
			iretrievecolumn < ( sizeof( rgretrievecolumn ) / sizeof( rgretrievecolumn[0] ) );
			++iretrievecolumn )
		{
		rgretrievecolumn[iretrievecolumn].itagSequence = 1;
		}
	iretrievecolumn = 0;

	if( pobjidTable )
		{
		rgretrievecolumn[iretrievecolumn].columnid 	= columnidMSU_objidTable;
		rgretrievecolumn[iretrievecolumn].pvData	= pobjidTable;
		rgretrievecolumn[iretrievecolumn].cbData	= sizeof( *pobjidTable );
		++iretrievecolumn;
		}
	if( pobjidIndex )
		{
		rgretrievecolumn[iretrievecolumn].columnid 	= columnidMSU_objidIndex;
		rgretrievecolumn[iretrievecolumn].pvData	= pobjidIndex;
		rgretrievecolumn[iretrievecolumn].cbData	= sizeof( *pobjidIndex );
		++iretrievecolumn;
		}
	if( pcbPrimaryKey )
		{
		rgretrievecolumn[iretrievecolumn].columnid 	= columnidMSU_primaryKey;
		rgretrievecolumn[iretrievecolumn].pvData	= rgbPrimaryKey;
		rgretrievecolumn[iretrievecolumn].cbData	= *pcbPrimaryKey;
		iretrievecolumnPrimaryKey = iretrievecolumn;
		++iretrievecolumn;
		}
	if( pcbSecondaryKey )
		{
		rgretrievecolumn[iretrievecolumn].columnid 	= columnidMSU_secondaryKey;
		rgretrievecolumn[iretrievecolumn].pvData	= rgbSecondaryKey;
		rgretrievecolumn[iretrievecolumn].cbData	= *pcbSecondaryKey;
		iretrievecolumnSecondaryKey = iretrievecolumn;
		++iretrievecolumn;
		}
	if( plcid )
		{
		rgretrievecolumn[iretrievecolumn].columnid 	= columnidMSU_lcid;
		rgretrievecolumn[iretrievecolumn].pvData	= plcid;
		rgretrievecolumn[iretrievecolumn].cbData	= sizeof( *plcid );
		++iretrievecolumn;
		}
	if( pdwSortVersion)
		{
		rgretrievecolumn[iretrievecolumn].columnid 	= columnidMSU_sortVersion;
		rgretrievecolumn[iretrievecolumn].pvData	= pdwSortVersion;
		rgretrievecolumn[iretrievecolumn].cbData	= sizeof( *pdwSortVersion );
		++iretrievecolumn;
		}
	if( pdwDefinedVersion )
		{
		rgretrievecolumn[iretrievecolumn].columnid 	= columnidMSU_definedVersion;
		rgretrievecolumn[iretrievecolumn].pvData	= pdwDefinedVersion;
		rgretrievecolumn[iretrievecolumn].cbData	= sizeof( *pdwDefinedVersion );
		++iretrievecolumn;
		}
	if( pitag )
		{
		rgretrievecolumn[iretrievecolumn].columnid 	= columnidMSU_itag;
		rgretrievecolumn[iretrievecolumn].pvData	= pitag;
		rgretrievecolumn[iretrievecolumn].cbData	= sizeof( *pitag );
		++iretrievecolumn;
		}
	if( pichOffset )
		{
		rgretrievecolumn[iretrievecolumn].columnid 	= columnidMSU_ichOffset;
		rgretrievecolumn[iretrievecolumn].pvData	= pichOffset;
		rgretrievecolumn[iretrievecolumn].cbData	= sizeof( *pichOffset );
		++iretrievecolumn;
		}

	Assert( iretrievecolumn <= ( sizeof( rgretrievecolumn ) / sizeof( rgretrievecolumn[0] ) ) );

	Call( ErrIsamRetrieveColumns( sesid, tableid, rgretrievecolumn, iretrievecolumn ) );

	Assert( -1 == iretrievecolumnPrimaryKey || rgretrievecolumn[iretrievecolumnPrimaryKey].cbActual <= JET_cbPrimaryKeyMost );
	Assert( -1 == iretrievecolumnSecondaryKey || rgretrievecolumn[iretrievecolumnSecondaryKey].cbActual <= JET_cbSecondaryKeyMost );

	if( pcbPrimaryKey )
		{
		Assert( -1 != iretrievecolumnPrimaryKey );
		*pcbPrimaryKey = rgretrievecolumn[iretrievecolumnPrimaryKey].cbActual;
		}
	if( pcbSecondaryKey )
		{
		Assert( -1 != iretrievecolumnSecondaryKey );
		*pcbSecondaryKey = rgretrievecolumn[iretrievecolumnSecondaryKey].cbActual;
		}

	//	strip out any warnings from retrieve columns

	err = JET_errSuccess;

HandleError:
	return err;
	}


//  ================================================================
ERR ErrCATICheckSeekToMSURecord(
		IN 	PIB * const 	ppib,
		IN 	FUCB * const 	pfucbMSU,
		IN 	const OBJID 	objidTable,
		IN 	const OBJID 	objidIndex,
		IN 	const KEY& 		keyPrimary,
		IN 	const KEY& 		keySecondary,
		IN 	const INT		itag,
		IN 	const INT		ichOffset,
		OUT BOOL * const 	pfEqual )
//  ================================================================
//
//	Check the record we are on against the record we want
//
//-
	{
	ERR err = JET_errSuccess;

	BYTE 	rgbPrimaryKeyT[JET_cbKeyMost];
	BYTE 	rgbSecondaryKeyT[JET_cbKeyMost];
	OBJID 	objidTableT 		= 0;
	OBJID 	objidIndexT			= 0;
	INT 	cbPrimaryKeyT 		= sizeof( rgbPrimaryKeyT );
	INT 	cbSecondaryKeyT 	= sizeof( rgbSecondaryKeyT );
	INT		itagT				= 0;
	INT		ichOffsetT			= 0;

	KEY 	keyPrimaryT;
	KEY		keySecondaryT;

	Call( ErrCATRetrieveMSURecord(
			ppib,
			pfucbMSU,
			&objidTableT,
			&objidIndexT,
			rgbPrimaryKeyT,
			&cbPrimaryKeyT,
			rgbSecondaryKeyT,
			&cbSecondaryKeyT,
			NULL,
			NULL,
			NULL,
			&itagT,
			&ichOffsetT ) );

	keyPrimaryT.prefix.Nullify();
	keyPrimaryT.suffix.SetPv( rgbPrimaryKeyT );
	keyPrimaryT.suffix.SetCb( cbPrimaryKeyT );
	keySecondaryT.prefix.Nullify();
	keySecondaryT.suffix.SetPv( rgbSecondaryKeyT );
	keySecondaryT.suffix.SetCb( cbSecondaryKeyT );

	*pfEqual = (
		( objidTable == objidTableT )
		&& ( objidIndex == objidIndexT )
		&& ( 0 == CmpKey( keyPrimary, keyPrimaryT ) )
		&& ( 0 == CmpKey( keySecondary, keySecondaryT ) )
		&& itag == itagT
		&& ichOffset == ichOffsetT );

HandleError:
	return err;
	}



//  ================================================================
ERR ErrCATILinearSeekToMSURecord(
		IN PIB * const 	ppib,
		IN FUCB * const pfucbMSU,
		IN const OBJID 	objidTable,
		IN const OBJID 	objidIndex,
		IN const KEY& 	keyPrimary,
		IN const KEY& 	keySecondary,
		IN const INT	itag,
		IN const INT	ichOffset )
//  ================================================================
//
//	Used when there are duplicates. Walk the records until we find
//	the one we want
//
//-
	{
	ERR 	err 				= JET_errSuccess;
	BOOL 	fEqual 				= fFalse;
	INT 	cIterations 		= 0;
#ifdef DEBUG
	const INT cIterationsMax	= 100000;
#endif	//	DEBUG

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_VTID 	tableid = (JET_VTID)pfucbMSU;

	while( 1 )
		{
		Call( ErrCATICheckSeekToMSURecord(
				ppib,
				pfucbMSU,
				objidTable,
				objidIndex,
				keyPrimary,
				keySecondary,
				itag,
				ichOffset,
				&fEqual ) );
		if( fEqual )
			{
			CallS( err );
			break;
			}
#ifdef DEBUG
		if( ++cIterations > cIterationsMax )
			{
			AssertSz( fFalse, "infinite loop in ErrCATISeekToMSURecord?" );
			}
#endif	//	DEBUG
		Call( ErrIsamMove( sesid, tableid, JET_MoveNext, NO_GRBIT ) );
		}

HandleError:
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATISeekToMSURecord(
		IN PIB * const ppib,
		IN FUCB * const pfucbMSU,
		IN const OBJID objidTable,
		IN const OBJID objidIndex,
		IN const KEY& 	keyPrimary,
		IN const KEY& 	keySecondary,
		IN const INT	itag,
		IN const INT	ichOffset )
//  ================================================================
	{
	ERR 	err 			= JET_errSuccess;

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_VTID 	tableid = (JET_VTID)pfucbMSU;

	BYTE rgbPrimaryKey[JET_cbKeyMost];
	BYTE rgbSecondaryKey[JET_cbKeyMost];

	Assert( sizeof( rgbPrimaryKey ) >= keyPrimary.Cb() );
	Assert( sizeof( rgbSecondaryKey ) >= keySecondary.Cb() );

	memset( rgbPrimaryKey, 'w', sizeof( rgbPrimaryKey ) );
	keyPrimary.CopyIntoBuffer( rgbPrimaryKey, sizeof( rgbPrimaryKey ) );
	memset( rgbSecondaryKey, 'm', sizeof( rgbSecondaryKey ) );
	keySecondary.CopyIntoBuffer( rgbSecondaryKey, sizeof( rgbSecondaryKey ) );

	Call( ErrIsamSetCurrentIndex( sesid, tableid, szMSUSecondaryIndex, NULL, NO_GRBIT, 1 ) );

	Call( ErrIsamMakeKey( sesid, tableid, &objidTable, sizeof( objidTable ), JET_bitNewKey ) );
	Call( ErrIsamMakeKey( sesid, tableid, &objidIndex, sizeof( objidIndex ), NO_GRBIT ) );
	Call( ErrIsamMakeKey( sesid, tableid, rgbPrimaryKey, keyPrimary.Cb(), NO_GRBIT ) );
	Call( ErrIsamMakeKey( sesid, tableid, rgbSecondaryKey, keySecondary.Cb(), NO_GRBIT ) );
	Call( ErrIsamMakeKey( sesid, tableid, &itag, sizeof( itag ), NO_GRBIT ) );
	Call( ErrIsamMakeKey( sesid, tableid, &ichOffset, sizeof( ichOffset ), NO_GRBIT ) );

	Call( ErrIsamSeek( sesid, tableid, JET_bitSeekEQ | JET_bitCheckUniqueness ) );

	if( JET_wrnUniqueKey == err )
		{
		//	this is the precise record we want
		}
	else
		{
		//	the key is too short to differentiate the records
		//	walk through the records
		Call( ErrCATILinearSeekToMSURecord(
				ppib,
				pfucbMSU,
				objidTable,
				objidIndex,
				keyPrimary,
				keySecondary,
				itag,
				ichOffset ) );
		}

#ifdef DEBUG
	BOOL fMatch;
	CallS( ErrCATICheckSeekToMSURecord( ppib, pfucbMSU, objidTable, objidIndex, keyPrimary, keySecondary, itag, ichOffset, &fMatch ) );
	Assert( fMatch );
#endif	//	DEBUG

HandleError:
	return err;
	}


//  ================================================================
ERR ErrCATInsertMSURecord(
		IN PIB * const ppib,
		IN const IFMP ifmp,
		IN FUCB * const pfucbMSU,		// optional, can be NULL
		IN const OBJID objidTable,
		IN const OBJID objidIndex,
		IN const KEY& 	keyPrimary,
		IN const KEY& 	keySecondary,
		IN const LCID	lcid,
		IN const INT	itag,
		IN const INT	ichOffset )
//  ================================================================
	{
	ERR 	err 			= JET_errSuccess;
	BOOL 	fInTransaction 	= fFalse;
	BOOL	fInUpdate		= fFalse;
	BOOL	fOpenedTable	= fFalse;

	JET_SETCOLUMN rgsetcolumn[9];
	INT isetcolumn = 0;

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID	dbid	= (JET_DBID)ifmp;

	JET_VTID tableid = (JET_VTID)pfucbMSU;

	if( fGlobalRepair )
		{
		//	don't maintain the table during integrity check/repair
		rgfmp[ifmp].IncrementCundefinedUnicodeEntries();
		return JET_errSuccess;
		}

	Assert( !fInTransaction );
	Call( ErrIsamBeginTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fTrue;

	Assert( !fOpenedTable );
	if( !tableid )
		{
		Call( ErrIsamOpenTable( sesid, dbid, &tableid, const_cast<CHAR *>( szMSU ), NO_GRBIT ) );
		fOpenedTable = fTrue;
		}


	Assert( !fInUpdate );
	Call( ErrIsamPrepareUpdate( sesid, tableid, JET_prepInsert ) );
	fInUpdate = fTrue;

	memset( rgsetcolumn, 0, sizeof( rgsetcolumn ) );

	BYTE rgbPrimaryKey[JET_cbPrimaryKeyMost];
	BYTE rgbSecondaryKey[JET_cbSecondaryKeyMost];

	memset( rgbPrimaryKey, 'u', sizeof( rgbPrimaryKey ) );
	Assert( sizeof( rgbPrimaryKey ) >= keyPrimary.Cb() );
	keyPrimary.CopyIntoBuffer( rgbPrimaryKey, sizeof( rgbPrimaryKey ) );

	memset( rgbSecondaryKey, 'n', sizeof( rgbSecondaryKey ) );
	Assert( sizeof( rgbSecondaryKey ) >= keySecondary.Cb() );
	keySecondary.CopyIntoBuffer( rgbSecondaryKey, sizeof( rgbSecondaryKey ) );

	QWORD qwSortVersion;
	DWORD dwNLSVersion;
	DWORD dwDefinedVersion;

	Call( ErrNORMGetSortVersion( lcid, &qwSortVersion ) );
	dwNLSVersion 		= DwNLSVersionFromSortVersion( qwSortVersion );
	dwDefinedVersion	= DwDefinedVersionFromSortVersion( qwSortVersion );

	rgsetcolumn[isetcolumn].columnid 	= columnidMSU_objidTable;
	rgsetcolumn[isetcolumn].pvData		= &objidTable;
	rgsetcolumn[isetcolumn].cbData		= sizeof( objidTable );
	++isetcolumn;
	rgsetcolumn[isetcolumn].columnid 	= columnidMSU_objidIndex;
	rgsetcolumn[isetcolumn].pvData		= &objidIndex;
	rgsetcolumn[isetcolumn].cbData		= sizeof( objidIndex );
	++isetcolumn;
	rgsetcolumn[isetcolumn].columnid 	= columnidMSU_primaryKey;
	rgsetcolumn[isetcolumn].pvData		= rgbPrimaryKey;
	rgsetcolumn[isetcolumn].cbData		= keyPrimary.Cb();
	++isetcolumn;
	rgsetcolumn[isetcolumn].columnid 	= columnidMSU_secondaryKey;
	rgsetcolumn[isetcolumn].pvData		= rgbSecondaryKey;
	rgsetcolumn[isetcolumn].cbData		= keySecondary.Cb();
	++isetcolumn;
	rgsetcolumn[isetcolumn].columnid 	= columnidMSU_lcid;
	rgsetcolumn[isetcolumn].pvData		= &lcid;
	rgsetcolumn[isetcolumn].cbData		= sizeof( lcid );
	++isetcolumn;
	rgsetcolumn[isetcolumn].columnid 	= columnidMSU_sortVersion;
	rgsetcolumn[isetcolumn].pvData		= &dwNLSVersion;
	rgsetcolumn[isetcolumn].cbData		= sizeof( dwNLSVersion );
	++isetcolumn;
	rgsetcolumn[isetcolumn].columnid 	= columnidMSU_definedVersion;
	rgsetcolumn[isetcolumn].pvData		= &dwDefinedVersion;
	rgsetcolumn[isetcolumn].cbData		= sizeof( dwDefinedVersion );
	++isetcolumn;
	rgsetcolumn[isetcolumn].columnid 	= columnidMSU_itag;
	rgsetcolumn[isetcolumn].pvData		= &itag;
	rgsetcolumn[isetcolumn].cbData		= sizeof( itag );
	++isetcolumn;
	rgsetcolumn[isetcolumn].columnid 	= columnidMSU_ichOffset;
	rgsetcolumn[isetcolumn].pvData		= &ichOffset;
	rgsetcolumn[isetcolumn].cbData		= sizeof( ichOffset );
	++isetcolumn;

	Assert( isetcolumn == ( sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );

	Call( ErrIsamSetColumns( sesid, tableid, rgsetcolumn, isetcolumn ) );

	Assert( fInUpdate );
	Call( ErrIsamUpdate( sesid, tableid, NULL, 0, NULL, NO_GRBIT ) );
	fInUpdate = fFalse;

	Assert( fInTransaction );
	Call( ErrIsamCommitTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fFalse;

HandleError:

	if( fInUpdate )
		{
		CallS( ErrIsamPrepareUpdate( sesid, tableid, JET_prepCancel ) );
		fInUpdate = fFalse;
		}

	if( fOpenedTable )
		{
		//	we opened MSU internally
		Assert( tableid );
		CallS( ErrIsamCloseTable( sesid, tableid ) );
		tableid 		= JET_tableidNil;
		fOpenedTable 	= fFalse;
		}

	if( fInTransaction )
		{
		CallS( ErrIsamRollback( sesid, NO_GRBIT ) );
		fInTransaction = fFalse;
		}

	Assert( !fInUpdate );
	Assert( !fOpenedTable );
	Assert( !fInTransaction );
	return err;
	}


//  ================================================================
ERR ErrCATDeleteMSURecord(
		IN PIB * const ppib,
		IN const IFMP ifmp,
		IN FUCB * const pfucbMSU,		// optional, can be NULL
		IN const OBJID objidTable,
		IN const OBJID objidIndex,
		IN const KEY& 	keyPrimary,
		IN const KEY& 	keySecondary,
		IN const INT	itag,
		IN const INT	ichOffset )
//  ================================================================
	{
	ERR 	err 			= JET_errSuccess;
	BOOL 	fInTransaction 	= fFalse;
	BOOL	fOpenedTable	= fFalse;

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID	dbid	= (JET_DBID)ifmp;

	JET_VTID tableid = (JET_VTID)pfucbMSU;

	if( fGlobalRepair )
		{
		//	don't maintain the table during integrity check/repair
		//	this actually shouldn't be called -- only ErrCATInsertMSURecord should be called
		Assert( fFalse );
		return JET_errSuccess;
		}

	Assert( !fInTransaction );
	Call( ErrIsamBeginTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fTrue;

	Assert( !fOpenedTable );
	if( !tableid )
		{
		Call( ErrIsamOpenTable( sesid, dbid, &tableid, const_cast<CHAR *>( szMSU ), NO_GRBIT ) );
		fOpenedTable = fTrue;
		}

	Call( ErrCATISeekToMSURecord(
			ppib,
			(FUCB *)tableid,
			objidTable,
			objidIndex,
			keyPrimary,
			keySecondary,
			itag,
			ichOffset ) );

	Call( ErrIsamDelete( sesid, tableid ) );

	Assert( fInTransaction );
	Call( ErrIsamCommitTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fFalse;

HandleError:

	if( fOpenedTable )
		{
		//	we opened MSU internally
		Assert( tableid );
		CallS( ErrIsamCloseTable( sesid, tableid ) );
		tableid 		= JET_tableidNil;
		fOpenedTable 	= fFalse;
		}

	if( fInTransaction )
		{
		CallS( ErrIsamRollback( sesid, NO_GRBIT ) );
		fInTransaction = fFalse;
		}

	Assert( !fOpenedTable );
	Assert( !fInTransaction );
	return err;
	}



//  ================================================================
ERR ErrCATIDeleteMSUEntriesForTableIndex(
		IN PIB * const ppib,
		IN const IFMP ifmp,
		IN FUCB * const pfucbMSU,		// optional, can be NULL
		IN const OBJID objidTable,
		IN const OBJID objidIndexMin,
		IN const OBJID objidIndexMax )
//  ================================================================
//
//	Delete all entries for the given table whose objidIndex is between
//	objidIndexMin and objidIndexMax (inclusive)
//
//-
	{
	ERR 	err 			= JET_errSuccess;
	BOOL 	fInTransaction 	= fFalse;
	BOOL	fOpenedTable	= fFalse;

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID	dbid	= (JET_DBID)ifmp;

	const QWORD qwMin		= 0;
	const QWORD qwMax		= 0x7fffffffffffffff;	//	maximum for a SIGNED integer

	INT cRecordsDeleted = 0;

	JET_VTID tableid = (JET_VTID)pfucbMSU;

	if( fGlobalRepair )
		{
		//	don't maintain the table during integrity check/repair
		//	this actually shouldn't be called -- only ErrCATInsertMSURecord should be called
		Assert( fFalse );
		return JET_errSuccess;
		}

	Assert( objidIndexMin <= objidIndexMax );

	Assert( !fInTransaction );
	Call( ErrIsamBeginTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fTrue;

	if( !tableid )
		{
		err = ErrIsamOpenTable( sesid, dbid, &tableid, const_cast<CHAR *>( szMSU ), NO_GRBIT );
		if( JET_errObjectNotFound == err )
			{
			//	MSU doesn't exist. expected error
			err = JET_errSuccess;
			goto HandleError;
			}
		Call( err );
		fOpenedTable = fTrue;
		}
	else
		{
		//	if the table is already opened, we can't be sure we are on the primary index
		Call( ErrIsamSetCurrentIndex( sesid, tableid, szMSUPrimaryIndex, NULL, NO_GRBIT, 1 ) );
		}

	//	Create an index range on the primary index
	//	Delete all the records in the range

	Call( ErrIsamMakeKey( sesid, tableid, &objidTable, sizeof( objidTable ), JET_bitNewKey ) );
	Call( ErrIsamMakeKey( sesid, tableid, &objidIndexMax, sizeof( objidIndexMax ), NO_GRBIT ) );	//	the objidIndex key element is descending
	Call( ErrIsamMakeKey( sesid, tableid, &qwMin, sizeof( qwMin ), NO_GRBIT ) );

	err = ErrIsamSeek( sesid, tableid, JET_bitSeekGE );
	if( JET_errRecordNotFound == err )
		{
		//	no entries for this table
		err = JET_errSuccess;
		goto HandleError;
		}
	Call( err )

	Call( ErrIsamMakeKey( sesid, tableid, &objidTable, sizeof( objidTable ), JET_bitNewKey ) );
	Call( ErrIsamMakeKey( sesid, tableid, &objidIndexMin, sizeof( objidIndexMin ), NO_GRBIT ) );	//	the objidIndex key element is descending
	Call( ErrIsamMakeKey( sesid, tableid, &qwMax, sizeof( qwMax ), NO_GRBIT ) );

	err = ErrIsamSetIndexRange( sesid, tableid, JET_bitRangeInclusive | JET_bitRangeUpperLimit );
	if( JET_errNoCurrentRecord == err )
		{
		//	the index range is empty
		err = JET_errSuccess;
		goto HandleError;
		}

	//	we now have a non-empty index range which contains the entries we want to delete

	do
		{
		Call( err );

#ifndef RTM
		OBJID objidTableT;
		OBJID objidIndexT;

		Call( ErrCATRetrieveMSURecord(
				ppib,
				(FUCB *)tableid,
				&objidTableT,
				&objidIndexT,
				NULL,	//	rgbPrimaryKey
				NULL,	//	pcbPrimaryKey
				NULL,	//	rgbSecondaryKey
				NULL,	//	pcbSecondaryKey
				NULL,	//	plcid
				NULL,	//	pdwSortVersion
				NULL,	//	pdwDefinedVersion
				NULL,	//	pitag
				NULL	//	pichOffset
				));
		AssertRTL( objidTable == objidTableT );
		AssertRTL( objidIndexT >= objidIndexMin );
		AssertRTL( objidIndexT <= objidIndexMax );
#endif

		Call( ErrIsamDelete( sesid, tableid ) );

		++cRecordsDeleted;
		AssertSz( cRecordsDeleted < 1000000, "Deleting a lot of records. Infinite loop?" );

		err = ErrIsamMove( sesid, tableid, JET_MoveNext, NO_GRBIT );
		}
	while ( JET_errNoCurrentRecord != err );

	err = JET_errSuccess;

	Assert( fInTransaction );
	Call( ErrIsamCommitTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fFalse;

HandleError:

	if( fOpenedTable )
		{
		//	we opened MSU internally
		Assert( tableid );
		CallS( ErrIsamCloseTable( sesid, tableid ) );
		tableid 		= JET_tableidNil;
		fOpenedTable 	= fFalse;
		}

	if( fInTransaction )
		{
		CallS( ErrIsamRollback( sesid, NO_GRBIT ) );
		fInTransaction = fFalse;
		}

	Assert( !fOpenedTable );
	Assert( !fInTransaction );
	return err;
	}


//  ================================================================
ERR ErrCATDeleteMSUEntriesForTable(
		IN PIB * const ppib,
		IN const IFMP ifmp,
		IN FUCB * const pfucbMSU,		// optional, can be NULL
		IN const OBJID objidTable )
//  ================================================================
	{
	return ErrCATIDeleteMSUEntriesForTableIndex(
			ppib,
			ifmp,
			pfucbMSU,
			objidTable,
			0,				//	minimum for a SIGNED integer
			0x7fffffff );	//	maximum for a SIGNED integer
	}


//  ================================================================
ERR ErrCATDeleteMSUEntriesForTableIndex(
		IN PIB * const ppib,
		IN const IFMP ifmp,
		IN FUCB * const pfucbMSU,		// optional, can be NULL
		IN const OBJID objidTable,
		IN const OBJID objidIndex )
//  ================================================================
	{
	return ErrCATIDeleteMSUEntriesForTableIndex(
			ppib,
			ifmp,
			pfucbMSU,
			objidTable,
			objidIndex,
			objidIndex );
	}




//  ================================================================
LOCAL ERR ErrCATICleanupOneSecondaryMSUEntry( IN PIB * const ppib, IN FUCB * const pfucbMSU )
//  ================================================================
//
//	o	Retrieve the information from the MSU record
//	o	If the defined version hasn't changed, we are finished
//	o	If the entry is a secondary index
//		o	Open the table
//		o	Find the fcb of the index
//		o	Open the index
//		o	Seek to the secondary key
//		o	Delete the secondary key
//
//-
	{
	ERR 		err 	= JET_errSuccess;
	const IFMP 	ifmp	= pfucbMSU->ifmp;

	BYTE 	rgbPrimaryKey[JET_cbPrimaryKeyMost] 		= {0};
	BYTE 	rgbSecondaryKey[JET_cbSecondaryKeyMost] 	= {0};
	INT 	cbPrimaryKey					= sizeof( rgbPrimaryKey );
	INT 	cbSecondaryKey 					= sizeof( rgbSecondaryKey );
	OBJID 	objidTable 						= 0;
	OBJID 	objidIndex						= 0;
	LCID 	lcid							= 0;
	DWORD	dwSortVersion					= 0;
	DWORD	dwDefinedVersion				= 0;

	const	INT cchTableName				= JET_cbNameMost + 1;
	CHAR	szTableName[cchTableName];

	FUCB * 	pfucbTable						= pfucbNil;
	FUCB * 	pfucbIndex						= pfucbNil;

	BOOKMARK	bookmark;
	bookmark.Nullify();

	DIB 		dib;
	dib.pos 	= posDown;
	dib.pbm		= &bookmark;
	dib.dirflag	= fDIRExact;

	//	o	Retrieve the information from the MSU record

	Call( ErrCATRetrieveMSURecord(
			ppib,
			pfucbMSU,
			&objidTable,
			&objidIndex,
			rgbPrimaryKey,
			&cbPrimaryKey,
			rgbSecondaryKey,
			&cbSecondaryKey,
			&lcid,
			&dwSortVersion,
			&dwDefinedVersion,
			NULL,
			NULL ) );

	//	o	If the defined version hasn't changed, we are finished

	QWORD qwSortVersion;
	Call( ErrNORMGetSortVersion( lcid, &qwSortVersion ) );
	if( DwNLSVersionFromSortVersion( qwSortVersion ) != dwSortVersion )
		{
		AssertSz( fFalse, "Sort versions differ. This index should have been deleted" );
		Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
		}
	if( DwDefinedVersionFromSortVersion( qwSortVersion ) == dwDefinedVersion )
		{
		err = JET_errSuccess;
		goto HandleError;
		}
	Assert( DwDefinedVersionFromSortVersion( qwSortVersion ) > dwDefinedVersion );

	if( objidIndex == objidTable )
		{
		//	we are only processing secondary index entries. this is a corrupted primary index
		err = JET_errSuccess;
		goto HandleError;
		}

	//	o	Open the table

	Call( ErrCATSeekTableByObjid( ppib, ifmp, objidTable, szTableName, cchTableName, NULL ) );
	Call( ErrFILEOpenTable( ppib, ifmp, &pfucbTable, szTableName, NO_GRBIT, NULL ) );

	//	o	Find the fcb of the index

	FCB * pfcbIndex;
	for(	pfcbIndex = pfucbTable->u.pfcb;
			NULL != pfcbIndex && pfcbIndex->ObjidFDP() != objidIndex;
			pfcbIndex = pfcbIndex->PfcbNextIndex() )
		;
	Assert( pfcbIndex != pfucbTable->u.pfcb );

	if( NULL == pfcbIndex )
		{
		//	we didn't find the index! this shouldn't happen
		AssertSz( fFalse, "ErrCATIFixupOneMSUEntry: can't find the index!" );
		Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
		}

	//	o	Open the index

	Call( ErrDIROpen( ppib, pfcbIndex, &pfucbIndex ) );

	//	o	Delete the secondary key

	bookmark.Nullify();
	bookmark.key.suffix.SetPv( rgbSecondaryKey );
	bookmark.key.suffix.SetCb( cbSecondaryKey );
	if( !pfcbIndex->FUnique() )
		{
		bookmark.data.SetPv( rgbPrimaryKey );
		bookmark.data.SetCb( cbPrimaryKey );
		}

	err = ErrDIRDown( pfucbIndex, &dib );
	if( JET_errRecordNotFound == err )
		{
		//	expected
		err = JET_errSuccess;
		goto HandleError;
		}

	Call( ErrDIRDelete( pfucbIndex, fDIRNull, prceNil ) );

HandleError:
	if( pfucbNil != pfucbIndex )
		{
		BTClose( pfucbIndex );
		pfucbIndex = pfucbNil;
		}

	if( pfucbNil != pfucbTable )
		{
		CallS( ErrFILECloseTable( ppib, pfucbTable ) );
		pfucbTable = pfucbNil;
		}

	Assert( pfucbNil == pfucbIndex );
	Assert( pfucbNil == pfucbTable );
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATICreateOneSecondaryMSUEntry( IN PIB * const ppib, IN FUCB * const pfucbMSU )
//  ================================================================
//
//	o	Retrieve the information from the MSU record
//	o	If the defined version hasn't changed, we are finished
//	o	If the entry is a secondary index
//		o	Open the table
//		o	Find the fcb of the index
//		o	Seek to the primary key
//		o	Using the IDB from the fcb of the index, call ErrRECRetrieveKeyFromRecord()
//		o	Open the index
//		o	Insert the new secondary index key
//		o	If the fUndefinedUnicode flag is not returned
//			o	Delete the MSU entry
//		o	Else
//			o	Update the defined version in the record
//
//-
	{
	ERR 		err 	= JET_errSuccess;
	const IFMP 	ifmp	= pfucbMSU->ifmp;

	BYTE 	rgbPrimaryKey[JET_cbPrimaryKeyMost] 		= {0};
	INT 	cbPrimaryKey					= sizeof( rgbPrimaryKey );
	OBJID 	objidTable 						= 0;
	OBJID 	objidIndex						= 0;
	LCID 	lcid							= 0;
	DWORD	dwSortVersion					= 0;
	DWORD	dwDefinedVersion				= 0;
	INT		itag							= 0;
	INT		ichOffset						= 0;
	const	INT cchTableName				= JET_cbNameMost + 1;
	CHAR	szTableName[cchTableName]		= {0};
	FUCB * 	pfucbTable						= pfucbNil;
	FUCB * 	pfucbIndex						= pfucbNil;
	BOOL	fInMSUUpdate					= fFalse;
	BYTE	rgbSecondaryKeyNew[JET_cbKeyMost]	= {0};
	KEY 	keySecondaryNew;

	keySecondaryNew.prefix.Nullify();
	keySecondaryNew.suffix.SetPv( rgbSecondaryKeyNew );
	keySecondaryNew.suffix.SetCb( sizeof( rgbSecondaryKeyNew ) );

	BOOKMARK	bookmark;
	bookmark.Nullify();

	DIB 		dib;
	dib.pos 	= posDown;
	dib.pbm		= &bookmark;
	dib.dirflag	= fDIRExact;

	//	o	Retrieve the information from the MSU record

	Call( ErrCATRetrieveMSURecord(
			ppib,
			pfucbMSU,
			&objidTable,
			&objidIndex,
			rgbPrimaryKey,
			&cbPrimaryKey,
			NULL,
			NULL,
			&lcid,
			&dwSortVersion,
			&dwDefinedVersion,
			&itag,
			&ichOffset ) );

	//	o	If the defined version hasn't changed, we are finished

	QWORD qwSortVersion;
	Call( ErrNORMGetSortVersion( lcid, &qwSortVersion ) );
	if( DwNLSVersionFromSortVersion( qwSortVersion ) != dwSortVersion )
		{
		AssertSz( fFalse, "Sort versions differ. This index should have been deleted" );
		Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
		}
	if( DwDefinedVersionFromSortVersion( qwSortVersion ) == dwDefinedVersion )
		{
		err = JET_errSuccess;
		goto HandleError;
		}
	Assert( DwDefinedVersionFromSortVersion( qwSortVersion ) > dwDefinedVersion );

	if( objidIndex == objidTable )
		{
		err = JET_errSuccess;
		goto HandleError;
		}

	//	o	Open the table

	Call( ErrCATSeekTableByObjid( ppib, ifmp, objidTable, szTableName, cchTableName, NULL ) );
	Call( ErrFILEOpenTable( ppib, ifmp, &pfucbTable, szTableName, NO_GRBIT, NULL ) );

	//	o	Find the fcb of the index

	FCB * pfcbIndex;
	for(	pfcbIndex = pfucbTable->u.pfcb;
			NULL != pfcbIndex && pfcbIndex->ObjidFDP() != objidIndex;
			pfcbIndex = pfcbIndex->PfcbNextIndex() )
		;
	Assert( pfcbIndex != pfucbTable->u.pfcb );

	if( NULL == pfcbIndex )
		{
		//	we didn't find the index! this shouldn't happen
		AssertSz( fFalse, "ErrCATIFixupOneMSUEntry: can't find the index!" );
		Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
		}

	//	o	Seek to the primary key

	bookmark.Nullify();
	bookmark.key.suffix.SetPv( rgbPrimaryKey );
	bookmark.key.suffix.SetCb( cbPrimaryKey );

	Call( ErrDIRDown( pfucbTable, &dib ) );

	//	o	Using the IDB from the fcb of the index, call ErrRECRetrieveKeyFromRecord()

	BOOL fUndefinedUnicodeChars;
	Call( ErrRECIRetrieveKey(
			pfucbTable,
			pfcbIndex->Pidb(),
			pfucbTable->kdfCurr.data,
			&keySecondaryNew,
			itag,
			ichOffset,
			&fUndefinedUnicodeChars,
			fFalse,
			prceNil ) );
	DIRUp( pfucbTable );

	//	o	Open the index

	Call( ErrDIROpen( ppib, pfcbIndex, &pfucbIndex ) );

	//	o	Insert the new secondary index key

	err = ErrDIRInsert( pfucbIndex, keySecondaryNew, bookmark.key.suffix, fDIRNull, NULL );
	if( JET_errKeyDuplicate == err || JET_errMultiValuedIndexViolation == err )
		{
		Assert( itag > 1 || ichOffset > 0 );
		//	expected error, see the large comment above
		err = JET_errSuccess;
		}
	Call( err );
	DIRUp( pfucbIndex );

	if( !fUndefinedUnicodeChars )
		{
		//	o	If the fUndefinedUnicode flag is not returned, delete the MSU entry

		Call( ErrIsamDelete( ppib, pfucbMSU ) );
		}
	else
		{
		//	o	Else update the defined version in the record

		const DWORD dwDefinedVersionNew = DwDefinedVersionFromSortVersion( qwSortVersion );
		Assert( !fInMSUUpdate );
		Call( ErrIsamPrepareUpdate( ppib, pfucbMSU, JET_prepReplace ) );
		fInMSUUpdate = fTrue;
		Call( ErrIsamSetColumn( ppib, pfucbMSU, columnidMSU_definedVersion, &dwDefinedVersionNew, sizeof( dwDefinedVersionNew ), NO_GRBIT, NULL ) );
		Assert( keySecondaryNew.prefix.FNull() );
		Call( ErrIsamSetColumn( ppib, pfucbMSU, columnidMSU_secondaryKey, keySecondaryNew.suffix.Pv(), keySecondaryNew.suffix.Cb(), NO_GRBIT, NULL ) );
		Assert( fInMSUUpdate );
		Call( ErrIsamUpdate( ppib, pfucbMSU, NULL, 0, NULL, NO_GRBIT ) );
		fInMSUUpdate = fFalse;
		}

HandleError:
	if( fInMSUUpdate )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucbMSU, JET_prepCancel ) );
		fInMSUUpdate = fFalse;
		}

	if( pfucbNil != pfucbIndex )
		{
		DIRClose( pfucbIndex );
		pfucbIndex = pfucbNil;
		}

	if( pfucbNil != pfucbTable )
		{
		CallS( ErrFILECloseTable( ppib, pfucbTable ) );
		pfucbTable = pfucbNil;
		}

	Assert( !fInMSUUpdate );
	Assert( pfucbNil == pfucbIndex );
	Assert( pfucbNil == pfucbTable );
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIFixupOnePrimaryMSUEntry( IN PIB * const ppib, IN FUCB * const pfucbMSU )
//  ================================================================
//
//	o	Retrieve the information from the MSU record
//	o	If the defined version hasn't changed, we are finished
//	o	If the entry is a primary index
//		o	Open the table
//		o 	Replace the record with JET_prepInsertCopyDeleteOriginal
//		o	If the fUndefinedUnicode flag is not returned
//			o	Delete the MSU entry
//		o	Else
//			o	Update the defined version in the record
//
//-
	{
	ERR 		err 	= JET_errSuccess;
	const IFMP 	ifmp	= pfucbMSU->ifmp;

	BYTE 	rgbPrimaryKey[JET_cbPrimaryKeyMost] 		= {0};
	INT 	cbPrimaryKey					= sizeof( rgbPrimaryKey );
	OBJID 	objidTable 						= 0;
	OBJID 	objidIndex						= 0;
	LCID 	lcid							= 0;
	DWORD	dwSortVersion					= 0;
	DWORD	dwDefinedVersion				= 0;

	const	INT cchTableName				= JET_cbNameMost + 1;
	CHAR	szTableName[cchTableName]		= {0};
	FUCB * 	pfucbTable						= pfucbNil;
	BOOL	fInTableUpdate					= fFalse;
	BOOL 	fUndefinedUnicodeChars = fFalse;
	BYTE	rgbKey[JET_cbKeyMost];
	KEY	 	keyToDelete;

	//	o	Retrieve the information from the MSU record

	Call( ErrCATRetrieveMSURecord(
			ppib,
			pfucbMSU,
			&objidTable,
			&objidIndex,
			rgbPrimaryKey,
			&cbPrimaryKey,
			NULL,
			NULL,
			&lcid,
			&dwSortVersion,
			&dwDefinedVersion,
			NULL,
			0 ) );

	//	o	If the defined version hasn't changed, we are finished

	QWORD qwSortVersion;
	Call( ErrNORMGetSortVersion( lcid, &qwSortVersion ) );
	if( DwNLSVersionFromSortVersion( qwSortVersion ) != dwSortVersion )
		{
		AssertSz( fFalse, "Sort versions differ. This index should have been deleted" );
		Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
		}
	if( DwDefinedVersionFromSortVersion( qwSortVersion ) == dwDefinedVersion )
		{
		err = JET_errSuccess;
		goto HandleError;
		}
	Assert( DwDefinedVersionFromSortVersion( qwSortVersion ) > dwDefinedVersion );

	if( objidIndex != objidTable )
		{
		err = JET_errSuccess;
		goto HandleError;
		}

	//	o	Open the table

	Call( ErrCATSeekTableByObjid( ppib, ifmp, objidTable, szTableName, cchTableName, NULL ) );
	Call( ErrFILEOpenTable( ppib, ifmp, &pfucbTable, szTableName, NO_GRBIT, NULL ) );

	keyToDelete.Nullify();
	keyToDelete.suffix.SetPv( rgbKey );
	keyToDelete.suffix.SetCb( sizeof( rgbKey ) );

	Assert( pfucbNil == pfucbTable->pfucbCurIndex );	//	we must be on the primary index
	Call( ErrIsamMakeKey( ppib, pfucbTable, rgbPrimaryKey, cbPrimaryKey, JET_bitNormalizedKey ) );
	Call( ErrIsamSeek( ppib, pfucbTable, JET_bitSeekEQ ) );
	CallS( err );

	Assert( pidbNil != pfucbTable->u.pfcb->Pidb() );
	Assert( pfucbTable->u.pfcb->Pidb()->FLocalizedText() );

	Call( ErrRECRetrieveKeyFromRecord(
			pfucbTable,
			pfucbTable->u.pfcb->Pidb(),
			&keyToDelete,
			1,
			0,
			&fUndefinedUnicodeChars,
			fFalse ) );
	Call( ErrDIRRelease( pfucbTable ) );

	if( !fUndefinedUnicodeChars )
		{
		Call( ErrIsamDelete( ppib, pfucbMSU ) );
		}
	//	PERF: if keyToDelete == the key in the record we don't need to do anything but update MSU with the current version info

	Assert( !fInTableUpdate );
	Call( ErrIsamPrepareUpdate( ppib, pfucbTable, JET_prepInsertCopyDeleteOriginal ) );
	fInTableUpdate = fTrue;

	//	we don't need to do anything in the update. JET_prepInsertCopyDeleteOriginal deletes the record and re-inserts it

	Assert( fInTableUpdate );
	Call( ErrIsamUpdate( ppib, pfucbTable, NULL, 0, NULL, NO_GRBIT ) );
	fInTableUpdate = fFalse;

HandleError:
	if( fInTableUpdate )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucbTable, JET_prepCancel ) );
		fInTableUpdate = fFalse;
		}

	if( pfucbNil != pfucbTable )
		{
		CallS( ErrFILECloseTable( ppib, pfucbTable ) );
		pfucbTable = pfucbNil;
		}

	Assert( !fInTableUpdate );
	Assert( pfucbNil == pfucbTable );
	return err;
	}


//  ================================================================
LOCAL VOID CATIReportMSUFixup( IN const INST * const pinst, IN const IFMP ifmp, IN const QWORD qwRecords )
//  ================================================================
	{
	//	log an event, indicating the number of records processed

	CHAR szEntries[21];	//	2^64 fits in 20 decimal digits + NULL terminator
	const INT	csz			= 2;
	const CHAR * rgsz[csz] 	= { szEntries, rgfmp[ifmp].SzDatabaseName() };

	sprintf( szEntries, "%I64d", qwRecords );

	UtilReportEvent(
		eventInformation,
		GENERAL_CATEGORY,
		DO_MSU_CLEANUP_ID, csz, rgsz, 0, NULL, pinst );
	}


//  ================================================================
ERR ErrCATFixupUnicodeIndexes( IN PIB * const ppib, IN const IFMP ifmp )
//  ================================================================
//
//	To cleanup the entries we make three passes through MSU:
//		- Delete all secondary index entries (the entry may not be there)
//		- Insert all secondary index entries (expect/accept duplicates)
//		- Process all primary index entries
//
//	There may be multiple MSU entries for the same secondary index entry. trying to delete
//	the secondary index entry a second time will fail (if the key has actually changed)
//
//	The reason that there are multiple MSU entries is that defining characters may make strings
//	which used to normalize to the same value normalize to a different value
//
//	Imagine X and Y are both undefined characters
//
//	"aXb" => "ab"
//	"aYb" => "ab"
//
//	So there will be only one secondary index entry. imagine that character X is defined, but Y is
//	left undefined
//
//	"aXb" => "aXb"
//	"aYb" => "ab"
//
//	Thus, there should now be two different index entries. to make sure this happens we have one
//	MSU entry for each itag/ichOffset combination which contains undefined characters, even if they
//	map to the same secondary key (the code in recupd.cxx makes this happen)
//
//	We can't do the secondary index deletion/insertion in one pass because of the problem outlined
//	above (consider the case where Y becomes defined, while X remains undefined)
//
//	To re-index the primary key we do a JET_prepInsertCopyDeleteOriginal.
//
//	The InsertCopyDeleteOriginal code will remove all the secondary index entries and recreate them,
//	deleting them from MSU if necessary. If the new key still has undefined unicode characters the
//	MSU entry for the primary index will be deleted as well. All needed MSU entries will be created
//	as the records are inserted.
//
//	This is actually quite inefficent as it means that we fix all the secondary index entries
//	and then delete them during the JET_prepInsertCopyDeleteOriginal (all secondary index entries
//	have to be removed as the primary key is changing). Having a corrupted primary index should be
//	rare and the code is simplest this way.
//
//	One problem remains: if the new primary index key contains no undefined unicode characters
//	its MSU entry won't be deleted (see the code in ErrIsamDelete). To deal with that we create a
//	special case here, retrieving the new primary key and deleting the MSU entry ONLY if the new
//	key contains no undefined characters. This means the code in ErrIsamDelete doesn't have to be
//	modified.
//
//	There are a lot of performance optimizations that can be made:
//	- It is possible to do the work more efficently by setting index ranges so that we process narrower ranges
//	  of records at a time.
//	- Caching the last table/index we were working on will help a lot as the records are clustered by table/index.
//	- Noticing that nothing has changed and avoiding deletion/insertion will reduce the amount of work that is done.
//	- We can go from three passes to two by cominging the insertion of secondary index entries with the fixup of
//    primary index entries. Note that the primary index on MSU has objidIndex as a descending key element so the
//	  primary index entries will be the last entries processed for a given table (the primary index has the lowest objid).
//
//-
	{
	ERR err = JET_errSuccess;

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID	dbid	= (JET_DBID)ifmp;
	JET_VTID tableid		= JET_tableidNil;

	QWORD 	qwRecords		= 0;
	BOOL	fInTransaction	= fFalse;

	if( fGlobalRepair )
		{
		//	don't maintain the table during integrity check/repair
		//	this actually shouldn't be called
		Assert( fFalse );
		return JET_errSuccess;
		}

	Assert( !fInTransaction );
	Call( ErrIsamBeginTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fTrue;

	err = ErrIsamOpenTable( sesid, dbid, &tableid, const_cast<CHAR *>( szMSU ), NO_GRBIT );
	if( JET_errObjectNotFound == err )
		{
		//	expected error: MSU doesn't always exist
		err = JET_errSuccess;
		goto HandleError;
		}
	Call( err );

	//	Phase 1: delete secondary index entries

	for(
		err = ErrIsamMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ), qwRecords = 0;
		JET_errSuccess == err;
		err = ErrIsamMove( sesid, tableid, JET_MoveNext, NO_GRBIT ), ++qwRecords )
		{
		if( !FNORMStringHasUndefinedCharsIsSupported() )
			{
			//	if this API isn't supported we should have deleted all the indexes, which would have left MSU empty
			AssertSz( fFalse, "GetNLSVersion isn't supported. MSU should be empty" );
			Call( ErrERRCheck( JET_errInternalError ) );
			}
		AssertSz( qwRecords < 1000000, "ErrCATFixupUnicodeIndexes: fixing lots of records. infinite loop?" );
		Call( ErrCATICleanupOneSecondaryMSUEntry( ppib, (FUCB *)tableid ) );
		}
	if( JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;	//	expected error
		}
	Call( err );

	//	Phase 2: create secondary index entries

	for(
		err = ErrIsamMove( sesid, tableid, JET_MoveFirst, NO_GRBIT );
		JET_errSuccess == err;
		err = ErrIsamMove( sesid, tableid, JET_MoveNext, NO_GRBIT ) )
		{
		Call( ErrCATICreateOneSecondaryMSUEntry( ppib, (FUCB *)tableid ) );
		}
	if( JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;	//	expected error
		}
	Call( err );

	//	Phase 3: primary index entries

	for(
		err = ErrIsamMove( sesid, tableid, JET_MoveFirst, NO_GRBIT );
		JET_errSuccess == err;
		err = ErrIsamMove( sesid, tableid, JET_MoveNext, NO_GRBIT ) )
		{
		Call( ErrCATIFixupOnePrimaryMSUEntry( ppib, (FUCB *)tableid ) );
		}
	if( JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;	//	expected error
		}
	Call( err );

	//	Now update the indexes with the new sort version

	Call( ErrCATIChangeUnicodeFixupFlags( ppib, ifmp, updateUnicodeVersion ) );

	//	Commit transaction and finish

	Assert( fInTransaction );
	Call( ErrIsamCommitTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fFalse;

	CATIReportMSUFixup( PinstFromPpib( ppib ), ifmp, qwRecords );

HandleError:
	if( JET_tableidNil != tableid )
		{
		CallS( ErrIsamCloseTable( sesid, tableid ) );
		tableid = JET_tableidNil;
		}
	if( fInTransaction )
		{
		CallS( ErrIsamRollback( sesid, NO_GRBIT ) );
		fInTransaction = fFalse;
		}

	Assert( JET_tableidNil == tableid );
	Assert( !fInTransaction );
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIDumpOneMSUEntry( IN PIB * const ppib, IN FUCB * const pfucbMSU, IN const CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CHAR	szBuf[JET_cbKeyMost*4];
	CHAR	*sz 							= szBuf;
	BYTE 	rgbPrimaryKey[JET_cbPrimaryKeyMost] 	= {0};
	BYTE 	rgbSecondaryKey[JET_cbSecondaryKeyMost] = {0};
	OBJID 	objidTable 						= 0;
	OBJID 	objidIndex						= 0;
	INT 	cbPrimaryKey					= sizeof( rgbPrimaryKey );
	INT 	cbSecondaryKey 					= sizeof( rgbSecondaryKey );
	LCID 	lcid							= 0;
	DWORD	dwSortVersion					= 0;
	DWORD	dwDefinedVersion				= 0;
	INT		itag							= 0;
	INT		ichOffset						= 0;

	INT 	ib;

	Call( ErrCATRetrieveMSURecord(
			ppib,
			pfucbMSU,
			&objidTable,
			&objidIndex,
			rgbPrimaryKey,
			&cbPrimaryKey,
			rgbSecondaryKey,
			&cbSecondaryKey,
			&lcid,
			&dwSortVersion,
			&dwDefinedVersion,
			&itag,
			&ichOffset ) );

	(*pcprintf)( "\tobjidTable: %d\r\n", objidTable );
	(*pcprintf)( "\tobjdidIndex: %d\r\n", objidIndex );
	(*pcprintf)( "\tprimaryKey (%d bytes):\r\n", cbPrimaryKey );
	for( ib = 0, sz = szBuf; ib < cbPrimaryKey; ++ib )
		{
		sz += sprintf( sz, "%2.2X ", rgbPrimaryKey[ib] );
		}
	(*pcprintf)( "\t\t%s\r\n", szBuf );
	(*pcprintf)( "\tsecondaryKey (%d bytes):\r\n", cbSecondaryKey );
	for( ib = 0, sz = szBuf; ib < cbSecondaryKey; ++ib )
		{
		sz += sprintf( sz, "%2.2X ", rgbSecondaryKey[ib] );
		}
	(*pcprintf)( "\t\t%s\r\n", szBuf );
	(*pcprintf)( "\tlcid: %d\r\n", lcid );
	(*pcprintf)( "\tdwSortVersion: %d\r\n", dwSortVersion );
	(*pcprintf)( "\tdwDefinedVersion: %d\r\n", dwDefinedVersion );
	(*pcprintf)( "\titag: %d\r\n", itag );
	(*pcprintf)( "\tichOffset: %d\r\n", ichOffset );

HandleError:
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIVerifyOneMSUEntry( IN PIB * const ppib, IN FUCB * const pfucbMSU, IN const CPRINTF * const pcprintf )
//  ================================================================
//
//	o	Retrieve the information from the MSU record
//	o	Open the table
//	o	Find the fcb of the index
//	o	Open the index
//	o	Seek to the secondary key
//	o	Seek to the primary key
//	o	Using the IDB from the fcb of the index, call ErrRECRetrieveKeyFromRecord()
//	o	Make sure the fUndefinedUnicode flag is set and that the key returned equals the secondary key in the record
//
//-
	{
	ERR 		err 	= JET_errSuccess;
	const IFMP 	ifmp	= pfucbMSU->ifmp;

	BYTE 	rgbPrimaryKey[JET_cbKeyMost] 	= {0};
	BYTE 	rgbSecondaryKey[JET_cbKeyMost] 	= {0};
	OBJID 	objidTable 						= 0;
	OBJID 	objidIndex						= 0;
	INT 	cbPrimaryKey					= sizeof( rgbPrimaryKey );
	INT 	cbSecondaryKey 					= sizeof( rgbSecondaryKey );
	LCID 	lcid							= 0;
	DWORD	dwSortVersion					= 0;
	DWORD	dwDefinedVersion				= 0;
	INT		itag							= 0;
	INT		ichOffset						= 0;

	const	INT cchTableName				= JET_cbNameMost + 1;
	CHAR	szTableName[cchTableName];
	PGNO	pgnoFDPTable;

	FUCB * 	pfucbTable						= pfucbNil;
	FUCB * 	pfucbIndex						= pfucbNil;

	BYTE	rgbSecondaryKeyT[JET_cbKeyMost]	= {0};
	KEY 		keySecondaryT;
	keySecondaryT.prefix.Nullify();
	keySecondaryT.suffix.SetPv( rgbSecondaryKeyT );
	keySecondaryT.suffix.SetCb( sizeof( rgbSecondaryKeyT ) );
	KEY			keySecondary;
	keySecondary.Nullify();

	BOOKMARK	bookmark;
	bookmark.Nullify();
	DIB 		dib;
	dib.pos 	= posDown;
	dib.pbm		= &bookmark;
	dib.dirflag	= fDIRExact;

	BOOL fCorrupt	= fFalse;

	//	o	Retrieve the information from the MSU record

	Call( ErrCATRetrieveMSURecord(
			ppib,
			pfucbMSU,
			&objidTable,
			&objidIndex,
			rgbPrimaryKey,
			&cbPrimaryKey,
			rgbSecondaryKey,
			&cbSecondaryKey,
			&lcid,
			&dwSortVersion,
			&dwDefinedVersion,
			&itag,
			&ichOffset ) );

	keySecondary.suffix.SetPv( rgbSecondaryKey );
	keySecondary.suffix.SetCb( cbSecondaryKey );

	//	o	Open the table
	//	PERF: cache the information from the previous lookup to improve performance

	Call( ErrCATSeekTableByObjid( ppib, ifmp, objidTable, szTableName, cchTableName, &pgnoFDPTable ) );
	Call( ErrFILEOpenTable( ppib, ifmp, &pfucbTable, szTableName, JET_bitTableReadOnly, NULL ) );

	//	o	Find the fcb of the index

	FCB * pfcbIndex;
	for(	pfcbIndex = pfucbTable->u.pfcb;
			NULL != pfcbIndex && pfcbIndex->ObjidFDP() != objidIndex;
			pfcbIndex = pfcbIndex->PfcbNextIndex() )
		;

	if( objidIndex == objidTable )
		{
		Assert( pfcbIndex == pfucbTable->u.pfcb );
		}
	else
		{
		//	o	Open the index
		//	o	Seek to the secondary key

		Assert( pfcbIndex != pfucbTable->u.pfcb );

		DATA dataPrimaryKey;

		if( NULL == pfcbIndex )
			{
			//	we didn't find the index! this shouldn't happen
			(*pcprintf)( "ErrCATIVerifyOneMSUEntry: can't find the index\r\n" );
			Call( ErrCATIDumpOneMSUEntry( ppib, pfucbMSU, pcprintf ) );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}

		Call( ErrBTOpen( ppib, pfcbIndex, &pfucbIndex, fTrue ) );

		bookmark.Nullify();
		bookmark.key.suffix.SetPv( rgbSecondaryKey );
		bookmark.key.suffix.SetCb( cbSecondaryKey );
		if( !pfcbIndex->FUnique() )
			{
			bookmark.data.SetPv( rgbPrimaryKey );
			bookmark.data.SetCb( cbPrimaryKey );
			}

		err = ErrBTDown( pfucbIndex, &dib, latchReadTouch );
		if( JET_errRecordNotFound == err )
			{
			(*pcprintf)( "ErrCATIVerifyOneMSUEntry: can't find the secondary key entry\r\n" );
			Call( ErrCATIDumpOneMSUEntry( ppib, pfucbMSU, pcprintf ) );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		Call( err );

		//	we now have found the secondary index entry
		//	make sure the primary key in the index mactches the primary key we expect

		dataPrimaryKey.SetPv( rgbPrimaryKey );
		dataPrimaryKey.SetCb( cbPrimaryKey );
		if( 0 != CmpData( pfucbIndex->kdfCurr.data, dataPrimaryKey ) )
			{
			BTUp( pfucbIndex );	//	can't do the BTUp earlier as we need kdfCurr
			(*pcprintf)( "ErrCATIVerifyOneMSUEntry: secondary key data doesn't match primary key\r\n" );
			Call( ErrCATIDumpOneMSUEntry( ppib, pfucbMSU, pcprintf ) );
			fCorrupt = fTrue;
			}
		BTUp( pfucbIndex );
		}

	//	o	Seek to the primary key

	bookmark.Nullify();
	bookmark.key.suffix.SetPv( rgbPrimaryKey );
	bookmark.key.suffix.SetCb( cbPrimaryKey );

	err = ErrDIRDown( pfucbTable, &dib );
	if( JET_errRecordNotFound == err )
		{
		(*pcprintf)( "ErrCATIVerifyOneMSUEntry: can't find the primary index entry\r\n" );
		Call( ErrCATIDumpOneMSUEntry( ppib, pfucbMSU, pcprintf ) );
		Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
		}
	Call( err );

	//	o	Using the IDB from the fcb of the index, call ErrRECRetrieveKeyFromRecord()

	BOOL fUndefinedUnicodeChars;
	Call( ErrRECIRetrieveKey(
			pfucbTable,
			pfcbIndex->Pidb(),
			pfucbTable->kdfCurr.data,
			&keySecondaryT,
			itag,
			ichOffset,
			&fUndefinedUnicodeChars,
			fFalse,
			prceNil ) );
	DIRUp( pfucbTable );

	//	o	Make sure the fUndefinedUnicode flag is set and that the key returned equals the secondary key in the record

	if( !fUndefinedUnicodeChars )
		{
		(*pcprintf)( "ErrCATIVerifyOneMSUEntry: key doesn't contain undefined unicode characters\r\n" );
		Call( ErrCATIDumpOneMSUEntry( ppib, pfucbMSU, pcprintf ) );
		fCorrupt = fTrue;
		}

	if( 0 != CmpKey( keySecondary, keySecondaryT ) )
		{
		(*pcprintf)( "ErrCATIVerifyOneMSUEntry: generated key is different from key in MSU\r\n");
		Call( ErrCATIDumpOneMSUEntry( ppib, pfucbMSU, pcprintf ) );
		fCorrupt = fTrue;
		}

	if( fCorrupt )
		{
		Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
		}

HandleError:
	if( pfucbNil != pfucbIndex )
		{
		BTClose( pfucbIndex );
		}

	if( pfucbNil != pfucbTable )
		{
		CallS( ErrFILECloseTable( ppib, pfucbTable ) );
		}
	return err;
	}


//  ================================================================
ERR ErrCATVerifyMSU(
		IN PIB * const ppib,
		IN const IFMP ifmp,
		IN const QWORD qwRecordsMax,
		OUT QWORD * const pqwRecordsSeen,
		IN const CPRINTF * const pcprintf )
//  ================================================================
//
//	Walk the MSU table verify each entry is valid (there is actually a record with undefined
//	unicode)
//
//	Compare each entry to the previous entry to make sure that the entries are unique
//
//-
	{
	ERR err = JET_errSuccess;

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID	dbid	= (JET_DBID)ifmp;
	JET_VTID tableid		= JET_tableidNil;
	BOOL fInTransaction		= fFalse;
	BOOL fCorruptionSeen	= fFalse;
	QWORD qwRecords 		= 0;

	BYTE 	rgbPrimaryKey[JET_cbKeyMost];
	BYTE 	rgbSecondaryKey[JET_cbKeyMost];
	OBJID 	objidTable 		= 0;
	OBJID 	objidIndex		= 0;
	INT 	cbPrimaryKey 	= 0;
	INT 	cbSecondaryKey 	= 0;
	INT		itag			= 0;
	INT		ichOffset		= 0;

	if( !FNORMStringHasUndefinedCharsIsSupported() )
		{
		return JET_errSuccess;
		}

	Assert( !fInTransaction );
	Call( ErrIsamBeginTransaction( sesid, JET_bitTransactionReadOnly ) );
	fInTransaction = fTrue;

	err = ErrIsamOpenTable( sesid, dbid, &tableid, const_cast<CHAR *>( szMSU ), JET_bitTableReadOnly );
	if( JET_errObjectNotFound == err )
		{
		//	expected error: MSU doesn't always exist
		err = JET_errSuccess;
		goto HandleError;
		}
	Call( err );

	for(
		err = ErrIsamMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ), qwRecords = 0;
		JET_errSuccess == err && qwRecords < qwRecordsMax;
		err = ErrIsamMove( sesid, tableid, JET_MoveNext, NO_GRBIT ), ++qwRecords )
		{
		KEY 	keyPrimary;
		KEY		keySecondary;

		//	check this entry

		err = ErrCATIVerifyOneMSUEntry( ppib, (FUCB *)tableid, pcprintf );
		if( JET_errDatabaseCorrupted == err )
			{
			fCorruptionSeen = fTrue;
			err = JET_errSuccess;
			}
		Call( err );

		//	verify that this entry is not equal to the previous entry

		BOOL	fEqual			= fFalse;

		keyPrimary.prefix.Nullify();
		keyPrimary.suffix.SetPv( rgbPrimaryKey );
		keyPrimary.suffix.SetCb( cbPrimaryKey );
		keySecondary.prefix.Nullify();
		keySecondary.suffix.SetPv( rgbSecondaryKey );
		keySecondary.suffix.SetCb( cbSecondaryKey );

		Call( ErrCATICheckSeekToMSURecord(
				ppib,
				(FUCB *)tableid,
				objidTable,
				objidIndex,
				keyPrimary,
				keySecondary,
				itag,
				ichOffset,
				&fEqual ) );

		if( fEqual )
			{
			//	two identical entries?!
			(*pcprintf)( "Duplicate entries in unicode fixup table (entry %I64D )\r\n", qwRecords );
			Call( ErrCATIDumpOneMSUEntry( ppib, (FUCB *)tableid, pcprintf ) );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}

		//	remember this entry for comparison against the next one

		cbPrimaryKey 	= sizeof( rgbPrimaryKey );
		cbSecondaryKey 	= sizeof( rgbSecondaryKey );
		Call( ErrCATRetrieveMSURecord(
			ppib,
			(FUCB *)tableid,
			&objidTable,
			&objidIndex,
			rgbPrimaryKey,
			&cbPrimaryKey,
			rgbSecondaryKey,
			&cbSecondaryKey,
			NULL,
			NULL,
			NULL,
			&itag,
			&ichOffset ) );
		}

	if( JET_errNoCurrentRecord == err )
		{
		//	expected error
		err = JET_errSuccess;
		}

	Call( err );

HandleError:
	if( JET_tableidNil != tableid )
		{
		CallS( ErrIsamCloseTable( sesid, tableid ) );
		tableid = JET_tableidNil;
		}
	if( fInTransaction )
		{
		CallS( ErrIsamRollback( sesid, NO_GRBIT ) );
		fInTransaction = fFalse;
		}
	Assert( JET_tableidNil == tableid );
	Assert( !fInTransaction );

	if( pqwRecordsSeen )
		{
		*pqwRecordsSeen = qwRecords;
		}

	if( JET_errSuccess == err && fCorruptionSeen )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		}
	return err;
	}


#ifndef RTM

//  ================================================================
LOCAL ERR ErrCATCheckMSUColumnids(
		IN PIB * const ppib,
		IN const IFMP ifmp )
//  ================================================================
	{
	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID	dbid	= (JET_DBID)ifmp;

	JET_COLUMNDEF	columndef;
	memset( &columndef, 0, sizeof( columndef ) );
	columndef.cbStruct = sizeof( columndef );

	ERR err = JET_errSuccess;

	Call( ErrIsamGetColumnInfo( sesid, dbid, szMSU, "objidTable", NULL, &columndef, sizeof( columndef ), JET_ColInfo ) );
	AssertRTL( columnidMSU_objidTable == columndef.columnid );

	Call( ErrIsamGetColumnInfo( sesid, dbid, szMSU, "objidIndex", NULL, &columndef, sizeof( columndef ), JET_ColInfo ) );
	AssertRTL( columnidMSU_objidIndex == columndef.columnid );

	Call( ErrIsamGetColumnInfo( sesid, dbid, szMSU, "keyPrimary", NULL, &columndef, sizeof( columndef ), JET_ColInfo ) );
	AssertRTL( columnidMSU_primaryKey == columndef.columnid );

	Call( ErrIsamGetColumnInfo( sesid, dbid, szMSU, "keySecondary", NULL, &columndef, sizeof( columndef ), JET_ColInfo ) );
	AssertRTL( columnidMSU_secondaryKey == columndef.columnid );

	Call( ErrIsamGetColumnInfo( sesid, dbid, szMSU, "lcid", NULL, &columndef, sizeof( columndef ), JET_ColInfo ) );
	AssertRTL( columnidMSU_lcid == columndef.columnid );

	Call( ErrIsamGetColumnInfo( sesid, dbid, szMSU, "sortVersion", NULL, &columndef, sizeof( columndef ), JET_ColInfo ) );
	AssertRTL( columnidMSU_sortVersion == columndef.columnid );

	Call( ErrIsamGetColumnInfo( sesid, dbid, szMSU, "definedVersion", NULL, &columndef, sizeof( columndef ), JET_ColInfo ) );
	AssertRTL( columnidMSU_definedVersion == columndef.columnid );

	Call( ErrIsamGetColumnInfo( sesid, dbid, szMSU, "itag", NULL, &columndef, sizeof( columndef ), JET_ColInfo ) );
	AssertRTL( columnidMSU_itag == columndef.columnid );

	Call( ErrIsamGetColumnInfo( sesid, dbid, szMSU, "ichOffset", NULL, &columndef, sizeof( columndef ), JET_ColInfo ) );
	AssertRTL( columnidMSU_ichOffset == columndef.columnid );

	Call( ErrIsamGetColumnInfo( sesid, dbid, szMSU, "autoinc", NULL, &columndef, sizeof( columndef ), JET_ColInfo ) );
	AssertRTL( columnidMSU_autoinc == columndef.columnid );

HandleError:
	CallS( err );
	AssertRTL( JET_errSuccess == err );
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATITestMSURetrieveRecord(
			IN PIB * const ppib,
			IN FUCB * const pfucb )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	BYTE 	rgbPrimaryKey[JET_cbKeyMost] = {0};
	BYTE 	rgbSecondaryKey[JET_cbKeyMost] = {0};
	OBJID 	objidTable 			= 0;
	OBJID 	objidIndex			= 0;
	INT 	cbPrimaryKey		= sizeof( rgbPrimaryKey );
	INT 	cbSecondaryKey 		= sizeof( rgbSecondaryKey );
	LCID 	lcid				= 0;
	DWORD	dwSortVersion		= 0;
	DWORD	dwDefinedVersion	= 0;
	INT		itag				= 0;
	INT		ichOffset			= 0;

	Call( ErrCATRetrieveMSURecord(
			ppib,
			pfucb,
			&objidTable,
			&objidIndex,
			rgbPrimaryKey,
			&cbPrimaryKey,
			rgbSecondaryKey,
			&cbSecondaryKey,
			&lcid,
			&dwSortVersion,
			&dwDefinedVersion,
			&itag,
			&ichOffset ) );

	BYTE 	rgbPrimaryKeyT[JET_cbKeyMost] = {0};
	BYTE 	rgbSecondaryKeyT[JET_cbKeyMost] = {0};
	OBJID 	objidTableT 		= 0;
	OBJID 	objidIndexT			= 0;
	INT 	cbPrimaryKeyT 		= 0;
	INT 	cbSecondaryKeyT 	= 0;
	LCID 	lcidT				= 0;
	DWORD	dwSortVersionT		= 0;
	DWORD	dwDefinedVersionT	= 0;
	INT		itagT				= 0;
	INT		ichOffsetT			= 0;

	Call( ErrCATRetrieveMSURecord(
			ppib,
			pfucb,
			&objidTableT,
			NULL,
			NULL,
			&cbPrimaryKeyT,
			NULL,
			&cbSecondaryKeyT,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL ) );
	AssertRTL( objidTable == objidTableT );
	AssertRTL( cbPrimaryKeyT == cbPrimaryKeyT );
	AssertRTL( cbSecondaryKeyT == cbSecondaryKeyT );

	Call( ErrCATRetrieveMSURecord(
			ppib,
			pfucb,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL,
			&ichOffsetT ) );
	AssertRTL( ichOffsetT == ichOffset );

	cbPrimaryKeyT 	= sizeof( rgbPrimaryKeyT );
	cbSecondaryKeyT = sizeof( rgbSecondaryKeyT );

	Call( ErrCATRetrieveMSURecord(
			ppib,
			pfucb,
			NULL,
			&objidIndexT,
			NULL,
			NULL,
			rgbSecondaryKeyT,
			&cbSecondaryKeyT,
			&lcidT,
			&dwSortVersionT,
			&dwDefinedVersionT,
			&itagT,
			NULL ) );
	AssertRTL( objidIndexT == objidIndex );
	AssertRTL( cbSecondaryKeyT == cbSecondaryKey );
	AssertRTL( 0 == memcmp( rgbSecondaryKeyT, rgbSecondaryKey, cbSecondaryKey ) );
	AssertRTL( lcidT == lcid );
	AssertRTL( dwSortVersionT == dwSortVersion );
	AssertRTL( dwDefinedVersionT == dwDefinedVersion );
	AssertRTL( itagT == itag );

	CallS( err );

HandleError:
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATITestMSUBasic(
			IN PIB * const ppib,
			IN const IFMP ifmp )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID	dbid	= (JET_DBID)ifmp;
	JET_TABLEID tableid		= JET_tableidNil;

	const OBJID objidTable		= 99;
	const OBJID objidIndex		= 107;
	const LCID 	lcid 			= lcidDefault;
	const INT 	itag 			= 19;
	const INT 	ichOffset 		= 512;
	const BYTE rgbPrimaryKeyPrefix[]	= { 0x10, 0x20, 0x30, 0x40 };
	const BYTE rgbPrimaryKeySuffix[]	= { 0x55, 0x66, 0x77 };
	const BYTE rgbSecondaryKey[]		= { 0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9 };

	KEY keyPrimary;
	keyPrimary.prefix.SetPv( const_cast<BYTE *>( rgbPrimaryKeyPrefix ) );
	keyPrimary.prefix.SetCb( sizeof( rgbPrimaryKeyPrefix ) );
	keyPrimary.suffix.SetPv( const_cast<BYTE *>( rgbPrimaryKeySuffix ) );
	keyPrimary.suffix.SetCb( sizeof( rgbPrimaryKeySuffix ) );

	KEY keySecondary;
	keySecondary.prefix.SetPv( const_cast<BYTE *>( rgbSecondaryKey ) );
	keySecondary.prefix.SetCb( sizeof( rgbSecondaryKey ) );
	keySecondary.suffix.Nullify();

	OBJID 	objidTableT 		= 0;
	OBJID 	objidIndexT			= 0;
	LCID 	lcidT				= 0;
	DWORD	dwSortVersionT		= 0;
	DWORD	dwDefinedVersionT	= 0;
	INT		itagT				= 0;
	INT		ichOffsetT			= 0;
	BYTE 	rgbPrimaryKeyT[JET_cbKeyMost];
	BYTE 	rgbSecondaryKeyT[JET_cbKeyMost];
	INT 	cbPrimaryKeyT 		= sizeof( rgbPrimaryKeyT );
	INT 	cbSecondaryKeyT 	= sizeof( rgbSecondaryKeyT );

	Call( ErrCATInsertMSURecord( ppib, ifmp, NULL, objidTable, objidIndex, keyPrimary, keySecondary, lcid, itag, ichOffset ) );

	Call( ErrIsamOpenTable( sesid, dbid, &tableid, const_cast<CHAR *>( szMSU ), NO_GRBIT ) );
	Call( ErrIsamMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ) );

	Call( ErrCATRetrieveMSURecord(
			ppib,
			(FUCB *)tableid,
			&objidTableT,
			&objidIndexT,
			rgbPrimaryKeyT,
			&cbPrimaryKeyT,
			rgbSecondaryKeyT,
			&cbSecondaryKeyT,
			&lcidT,
			&dwSortVersionT,
			&dwDefinedVersionT,
			&itagT,
			&ichOffsetT ) );

	AssertRTL( objidTable == objidTableT );
	AssertRTL( objidIndex == objidIndexT );
	AssertRTL( keyPrimary.Cb() == cbPrimaryKeyT );
	AssertRTL( 0 == memcmp( rgbPrimaryKeyT, rgbPrimaryKeyPrefix, sizeof( rgbPrimaryKeyPrefix ) ) );
	AssertRTL( 0 == memcmp( rgbPrimaryKeyT + sizeof( rgbPrimaryKeyPrefix ), rgbPrimaryKeySuffix, sizeof( rgbPrimaryKeySuffix ) ) );
	AssertRTL( keySecondary.Cb() == cbSecondaryKeyT );
	AssertRTL( 0 == memcmp( rgbSecondaryKeyT, rgbSecondaryKey, sizeof( rgbSecondaryKey ) ) );
	AssertRTL( lcid == lcidT );
	AssertRTL( itag == itagT );
	AssertRTL( ichOffset == ichOffsetT );

	Call( ErrCATITestMSURetrieveRecord( ppib, (FUCB *)tableid ) );

	Call( ErrCATDeleteMSURecord(
			ppib,
			ifmp,
			NULL,
			objidTable,
			objidIndex,
			keyPrimary,
			keySecondary,
			itag,
			ichOffset ) );

	//	do the insert using the already opened table

	Call( ErrCATInsertMSURecord(
			ppib,
			ifmp,
			(FUCB *)tableid,
			objidTable,
			objidIndex,
			keyPrimary,
			keySecondary,
			lcid,
			itag,
			ichOffset ) );

	//	if this fails we may have closed the tableid in the above call (that would be a bug :-))

	Call( ErrIsamMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ) );
	Call( ErrCATRetrieveMSURecord(
			ppib,
			(FUCB *)tableid,
			&objidTableT,
			&objidIndexT,
			rgbPrimaryKeyT,
			&cbPrimaryKeyT,
			rgbSecondaryKeyT,
			&cbSecondaryKeyT,
			&lcidT,
			NULL,
			NULL,
			&itagT,
			&ichOffsetT ) );

	AssertRTL( objidTable == objidTableT );
	AssertRTL( objidIndex == objidIndexT );
	AssertRTL( keyPrimary.Cb() == cbPrimaryKeyT );
	AssertRTL( 0 == memcmp( rgbPrimaryKeyT, rgbPrimaryKeyPrefix, sizeof( rgbPrimaryKeyPrefix ) ) );
	AssertRTL( 0 == memcmp( rgbPrimaryKeyT + sizeof( rgbPrimaryKeyPrefix ), rgbPrimaryKeySuffix, sizeof( rgbPrimaryKeySuffix ) ) );
	AssertRTL( keySecondary.Cb() == cbSecondaryKeyT );
	AssertRTL( 0 == memcmp( rgbSecondaryKeyT, rgbSecondaryKey, sizeof( rgbSecondaryKey ) ) );
	AssertRTL( lcid == lcidT );
	AssertRTL( itag == itagT );
	AssertRTL( ichOffset == ichOffsetT );

	Call( ErrCATDeleteMSURecord(
			ppib,
			ifmp,
			(FUCB *)tableid,
			objidTable,
			objidIndex,
			keyPrimary,
			keySecondary,
			itag,
			ichOffset ) );

	CallS( ErrIsamCloseTable( sesid, tableid ) );
	tableid = JET_tableidNil;

HandleError:
	CallS( err );
	if( JET_tableidNil != tableid )
		{
		CallS( ErrIsamCloseTable( sesid, tableid ) );
		tableid = JET_tableidNil;
		}

	return err;
	}




//  ================================================================
LOCAL ERR ErrCATITestMSUDuplicateKeys(
			IN PIB * const ppib,
			IN const IFMP ifmp )
//  ================================================================
//
//	Insert long keys, differing only at the end
//	This tests the seek logic that deals with identical keys
//
//-
	{
	ERR err = JET_errSuccess;

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID	dbid	= (JET_DBID)ifmp;
	JET_TABLEID tableid		= JET_tableidNil;

	const OBJID objidTable		= 1076;
	const OBJID objidIndex		= 4569;
	const LCID 	lcid 			= lcidDefault;
	const INT 	ichOffset 		= 7;
	const BYTE rgbPrimaryKey[]  = { 0x00, 0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0x1 };
	BYTE rgbSecondaryKey[JET_cbKeyMost];
	const INT  cbSecondaryKey = sizeof( rgbSecondaryKey ) / sizeof( rgbSecondaryKey[0] );

	INT i;
	for( i = 0; i < cbSecondaryKey; ++i )
		{
		rgbSecondaryKey[i] = (BYTE)~i;
		}

	KEY keyPrimary;
	keyPrimary.prefix.Nullify();
	keyPrimary.suffix.SetPv( const_cast<BYTE *>( rgbPrimaryKey ) );
	keyPrimary.suffix.SetCb( sizeof( rgbPrimaryKey ) );

	KEY keySecondary;
	keySecondary.prefix.SetPv( const_cast<BYTE *>( rgbSecondaryKey ) );
	keySecondary.prefix.SetCb( sizeof( rgbSecondaryKey ) );
	keySecondary.suffix.Nullify();

	Call( ErrIsamOpenTable( sesid, dbid, &tableid, const_cast<CHAR *>( szMSU ), NO_GRBIT ) );

	for( i = 0; i < 256; ++i )
		{
		rgbSecondaryKey[cbSecondaryKey-1] = (BYTE)i;
		Call( ErrCATInsertMSURecord(
				ppib,
				ifmp,
				(FUCB *)tableid,
				objidTable,
				objidIndex,
				keyPrimary,
				keySecondary,
				lcid,
				i+1,	//	itag
				ichOffset ) );
		}

	rgbSecondaryKey[cbSecondaryKey-1] = 97;
	Call( ErrCATISeekToMSURecord(
			ppib,
			(FUCB *)tableid,
			objidTable,
			objidIndex,
			keyPrimary,
			keySecondary,
			98,
			ichOffset ) );

	OBJID 	objidTableT 		= 0;
	OBJID 	objidIndexT			= 0;
	LCID 	lcidT				= 0;
	DWORD	dwSortVersionT		= 0;
	DWORD	dwDefinedVersionT	= 0;
	INT		itagT				= 0;
	INT		ichOffsetT			= 0;
	BYTE 	rgbPrimaryKeyT[JET_cbKeyMost];
	BYTE 	rgbSecondaryKeyT[JET_cbKeyMost];
	INT 	cbPrimaryKeyT 		= sizeof( rgbPrimaryKeyT );
	INT 	cbSecondaryKeyT 	= sizeof( rgbSecondaryKeyT );

	Call( ErrCATRetrieveMSURecord(
			ppib,
			(FUCB *)tableid,
			&objidTableT,
			&objidIndexT,
			rgbPrimaryKeyT,
			&cbPrimaryKeyT,
			rgbSecondaryKeyT,
			&cbSecondaryKeyT,
			&lcidT,
			&dwSortVersionT,
			&dwDefinedVersionT,
			&itagT,
			&ichOffsetT ) );

	AssertRTL( objidTable == objidTableT );
	AssertRTL( objidIndex == objidIndexT );
	AssertRTL( keyPrimary.Cb() == cbPrimaryKeyT );
	AssertRTL( keySecondary.Cb() == cbSecondaryKeyT );
	AssertRTL( 0 == memcmp( rgbPrimaryKeyT, rgbPrimaryKey, sizeof( rgbPrimaryKey ) ) );
	AssertRTL( 0 == memcmp( rgbSecondaryKeyT, rgbSecondaryKey, sizeof( rgbSecondaryKey ) ) );
	AssertRTL( lcid == lcidT );
	AssertRTL( 98 == itagT );
	AssertRTL( ichOffset == ichOffsetT );

	Call( ErrCATITestMSURetrieveRecord( ppib, (FUCB *)tableid ) );

	for( i = 0; i < 256; ++i )
		{
		rgbSecondaryKey[cbSecondaryKey-1] = (BYTE)i;
		Call( ErrCATDeleteMSURecord(
			ppib,
			ifmp,
			(FUCB *)tableid,
			objidTable,
			objidIndex,
			keyPrimary,
			keySecondary,
			i+1,
			ichOffset ) );
		}

	CallS( ErrIsamCloseTable( sesid, tableid ) );
	tableid = JET_tableidNil;

HandleError:
	CallS( err );
	if( JET_tableidNil != tableid )
		{
		CallS( ErrIsamCloseTable( sesid, tableid ) );
		tableid = JET_tableidNil;
		}

	return err;
	}


//  ================================================================
LOCAL ERR ErrCATITestMSUCountEntries(
			IN PIB * const ppib,
			IN const IFMP ifmp,
			OUT QWORD * const pqwRecords )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID	dbid	= (JET_DBID)ifmp;
	JET_TABLEID tableid = JET_tableidNil;

	Call( ErrIsamOpenTable( sesid, dbid, &tableid, const_cast<CHAR *>( szMSU ), NO_GRBIT ) );

	for(
		err = ErrIsamMove( sesid, tableid, JET_MoveFirst, NO_GRBIT ), *pqwRecords = 0;
		JET_errSuccess == err;
		err = ErrIsamMove( sesid, tableid, JET_MoveNext, NO_GRBIT ), ++(*pqwRecords ) )
		;

	if( JET_errNoCurrentRecord == err )
		{
		//	expected error
		err = JET_errSuccess;
		}

	Call( err );

HandleError:
	if( JET_tableidNil != tableid )
		{
		CallS( ErrIsamCloseTable( sesid, tableid ) );
		tableid = JET_tableidNil;
		}
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATITestMSUMultipleIndexes(
			IN PIB * const ppib,
			IN const IFMP ifmp )
//  ================================================================
//
//	create multiple entries for a table with multiple indexes with multiple records per index
//	delete some of the indexes
//	delete the entire table
//	try deleting tables/indexes with no entries in MSU
//
//-
	{
	ERR err = JET_errSuccess;

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID	dbid	= (JET_DBID)ifmp;
	JET_TABLEID tableid		= JET_tableidNil;

	const OBJID objidTable1		= 99;
	const OBJID objidTable2		= 1049;
	const OBJID objidIndex1		= 107;
	const OBJID objidIndex2		= 108;
	const OBJID objidIndex3		= 110;
	const OBJID objidIndex4		= 666;
	const LCID 	lcid 			= lcidDefault;
	const INT 	itag 			= 19;
	const INT 	ichOffset 		= 512;

	BYTE rgbPrimaryKey[64];
	BYTE rgbSecondaryKey[64];

	KEY keyPrimary;
	keyPrimary.prefix.SetPv( const_cast<BYTE *>( rgbPrimaryKey ) );
	keyPrimary.prefix.SetCb( sizeof( rgbPrimaryKey ) );
	keyPrimary.suffix.Nullify();

	KEY keySecondary;
	keySecondary.prefix.SetPv( const_cast<BYTE *>( rgbSecondaryKey ) );
	keySecondary.prefix.SetCb( sizeof( rgbSecondaryKey ) );
	keySecondary.suffix.Nullify();

	QWORD qwRecords;

	//	insert 100 entries for 4 indexes (400 entries)
	INT i;
	for( i = 0; i < 100; ++i )
		{
		rgbPrimaryKey[0] = (BYTE)i;
		rgbSecondaryKey[0] = (BYTE)i;
		Call( ErrCATInsertMSURecord( ppib, ifmp, NULL, objidTable1, objidIndex1, keyPrimary, keySecondary, lcid, itag, ichOffset ) );
		Call( ErrCATInsertMSURecord( ppib, ifmp, NULL, objidTable1, objidIndex2, keyPrimary, keySecondary, lcid, itag, ichOffset ) );
		Call( ErrCATInsertMSURecord( ppib, ifmp, NULL, objidTable1, objidIndex3, keyPrimary, keySecondary, lcid, itag, ichOffset ) );
		Call( ErrCATInsertMSURecord( ppib, ifmp, NULL, objidTable2, objidIndex4, keyPrimary, keySecondary, lcid, itag, ichOffset ) );
		}

	Call( ErrCATITestMSUCountEntries( ppib, ifmp, &qwRecords ) );
	AssertRTL( 400 == qwRecords );

	//	delete an index with no entries
	Call( ErrCATDeleteMSUEntriesForTableIndex( ppib, ifmp, NULL, objidTable1, 978 ) );
	Call( ErrCATITestMSUCountEntries( ppib, ifmp, &qwRecords ) );
	AssertRTL( 400 == qwRecords );

	//	delete an index with no entries, test boundary
	Call( ErrCATDeleteMSUEntriesForTableIndex( ppib, ifmp, NULL, objidTable1, 106 ) );
	Call( ErrCATITestMSUCountEntries( ppib, ifmp, &qwRecords ) );
	AssertRTL( 400 == qwRecords );

	//	delete an index with no entries, test boundary
	Call( ErrCATDeleteMSUEntriesForTableIndex( ppib, ifmp, NULL, objidTable1, 109 ) );
	Call( ErrCATITestMSUCountEntries( ppib, ifmp, &qwRecords ) );
	AssertRTL( 400 == qwRecords );

	//	delete an index (400 - 100 entries = 300 entries)
	Call( ErrCATDeleteMSUEntriesForTableIndex( ppib, ifmp, NULL, objidTable1, objidIndex2 ) );
	Call( ErrCATITestMSUCountEntries( ppib, ifmp, &qwRecords ) );
	AssertRTL( 300 == qwRecords );

	//	delete a table with no entries, test boundary
	Call( ErrCATDeleteMSUEntriesForTable( ppib, ifmp, NULL, objidTable1-1 ) );
	Call( ErrCATITestMSUCountEntries( ppib, ifmp, &qwRecords ) );
	AssertRTL( 300 == qwRecords );

	//	delete a table with no entries, test boundary
	Call( ErrCATDeleteMSUEntriesForTable( ppib, ifmp, NULL, objidTable1+1 ) );
	Call( ErrCATITestMSUCountEntries( ppib, ifmp, &qwRecords ) );
	AssertRTL( 300 == qwRecords );

	//	delete a table with no entries
	Call( ErrCATDeleteMSUEntriesForTable( ppib, ifmp, NULL, 1066 ) );
	Call( ErrCATITestMSUCountEntries( ppib, ifmp, &qwRecords ) );
	AssertRTL( 300 == qwRecords );

	//	delete a table with 200 entries (300 - 200 = 100 entries)
	Call( ErrCATDeleteMSUEntriesForTable( ppib, ifmp, NULL, objidTable1 ) );
	Call( ErrCATITestMSUCountEntries( ppib, ifmp, &qwRecords ) );
	AssertRTL( 100 == qwRecords );

HandleError:
	CallS( err );
	if( JET_tableidNil != tableid )
		{
		CallS( ErrIsamCloseTable( sesid, tableid ) );
		tableid = JET_tableidNil;
		}

	return err;
	}


//  ================================================================
ERR ErrCATTestMSU(
			IN PIB * const ppib,
			IN const IFMP ifmp )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	extern VOID FLDNormUnitTest();
	FLDNormUnitTest();

	const JET_SESID sesid 	= (JET_SESID)ppib;
	const JET_DBID	dbid	= (JET_DBID)ifmp;

	BOOL fInTransaction = fFalse;

	Call( ErrIsamBeginTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fTrue;
	Call( ErrCATCreateMSU( ppib, ifmp ) );
	Call( ErrIsamCommitTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fFalse;

	Call( ErrIsamBeginTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fTrue;
	Call( ErrCATCheckMSUColumnids( ppib, ifmp ) );
	Call( ErrCATITestMSUBasic( ppib, ifmp ) );
	Call( ErrCATITestMSUDuplicateKeys( ppib, ifmp ) );
	Call( ErrCATITestMSUMultipleIndexes( ppib, ifmp ) );
	Call( ErrIsamCommitTransaction( sesid, NO_GRBIT ) );
	fInTransaction = fFalse;

	Call( ErrCATIDeleteMSUTable( ppib, ifmp ) );

HandleError:
	CallS( err );
	if( fInTransaction )
		{
		CallS( ErrIsamRollback( sesid, NO_GRBIT ) );
		fInTransaction = fFalse;
		}
	return err;
	}

#endif //	!RTM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\bt.cxx ===
#include "std.hxx"
#include "_bt.hxx"

//	general directives
//	always correct bmCurr and csr.DBTime on loss of physical currency
//	unless not needed because of loc in which case, reset bmCurr

//	*****************************************************
//	internal function prototypes
//
ERR	ErrBTIIRefresh( FUCB *pfucb, LATCH latch );
ERR ErrBTDelete( FUCB *pfucb, const BOOKMARK& bm );
INT CbBTIFreeDensity( const FUCB *pfucb );
VOID BTIComputePrefix( FUCB *pfucb, CSR *pcsr, const KEY& key, KEYDATAFLAGS	*pkdf );
BOOL FBTIAppend( const FUCB *pfucb, CSR *pcsr, ULONG cbReq, const BOOL fUpdateUncFree = fTrue );
BOOL FBTISplit( const FUCB *pfucb, CSR *pcsr, const ULONG cbReq, const BOOL fUpdateUncFree = fTrue );
ERR ErrBTISplit(
					FUCB * const pfucb,
					KEYDATAFLAGS * const pkdf,
					const DIRFLAG	dirflagT,
					const RCEID rceid1,
					const RCEID rceid2,
					RCE * const prceReplace,
					const INT cbDataOld,
					const VERPROXY * const pverproxy );
VOID BTISplitSetCbAdjust(
					SPLIT 				*psplit,
					FUCB				*pfucb,
					const KEYDATAFLAGS& kdf,
					const RCE			*prce1,
					const RCE			*prce2 );
VOID BTISplitSetCursor( FUCB *pfucb, SPLITPATH *psplitPathLeaf );
VOID BTIPerformSplit( FUCB *pfucb, SPLITPATH *psplitPathLeaf, KEYDATAFLAGS *pkdf, DIRFLAG dirflag );
LOCAL VOID BTIComputePrefixAndInsert( FUCB *pfucb, CSR *pcsr, const KEYDATAFLAGS& kdf );
VOID BTICheckSplitLineinfo( FUCB *pfucb, SPLIT *psplit, const KEYDATAFLAGS& kdf );
VOID BTICheckSplits( FUCB *pfucb, SPLITPATH *psplitPathLeaf, KEYDATAFLAGS *pkdf, DIRFLAG dirflag );
LOCAL VOID BTICheckSplitFlags( const SPLIT *psplit );
VOID BTICheckOneSplit( FUCB *pfucb, SPLITPATH *psplitPathLeaf, KEYDATAFLAGS *pkdf, DIRFLAG dirflag );
LOCAL VOID BTIInsertPgnoNewAndSetPgnoSplit( FUCB *pfucb, SPLITPATH *psplitPath );
BOOL FBTIUpdatablePage( const CSR& csr );
LOCAL VOID BTISplitFixSiblings( SPLIT *psplit );
LOCAL VOID BTIInsertPgnoNew ( FUCB *pfucb, SPLITPATH *psplitPath );
VOID BTISplitMoveNodes( FUCB *pfucb, SPLIT *psplit, KEYDATAFLAGS *pkdf, DIRFLAG dirflag );
VOID BTISplitBulkCopy( FUCB *pfucb, SPLIT *psplit, INT ilineStart, INT clines );
VOID BTISplitBulkDelete( CSR * pcsr, INT clines );
const LINEINFO *PlineinfoFromIline( SPLIT *psplit, INT iline );
VOID BTISplitSetPrefixInSrcPage( FUCB *pfucb, SPLIT *psplit );
LOCAL ERR ErrBTIGetNewPages( FUCB *pfucb, SPLITPATH *psplitPathLeaf );
VOID BTISplitRevertDbtime( SPLITPATH *psplitPathLeaf );
VOID BTIMergeRevertDbtime( MERGEPATH *pmergePathLeaf );
LOCAL VOID BTISplitReleaseUnneededPages( INST *pinst, SPLITPATH **psplitPathLeaf );
LOCAL ERR ErrBTISplitUpgradeLatches( const IFMP ifmp, SPLITPATH * const psplitPathLeaf );
LOCAL VOID BTISplitSetLgpos( SPLITPATH *psplitPathLeaf, const LGPOS& lgpos );
VOID BTIReleaseOneSplitPath( INST *pinst, SPLITPATH *psplitPath );
VOID BTIReleaseSplitPaths( INST *pinst, SPLITPATH *psplitPath );
VOID BTIReleaseMergePaths( MERGEPATH *pmergePathLeaf );
LOCAL VOID BTISplitCheckPath( SPLITPATH *psplitPathLeaf );

ERR	ErrBTINewMergePath( MERGEPATH **ppmergePath );
LOCAL ERR ErrBTICreateMergePath( FUCB *pfucb, const BOOKMARK& bm, MERGEPATH **ppmergePath );

ERR	ErrBTINewSplitPath( SPLITPATH **ppsplitPath );
ERR ErrBTICreateSplitPath( FUCB				*pfucb,
						   const BOOKMARK&	bm,
						   SPLITPATH		**ppsplitPath );

ERR	ErrBTICreateSplitPathAndRetryOper( FUCB 			* const pfucb,
									   const KEYDATAFLAGS * const pkdf,
									   SPLITPATH 		**ppsplitPath,
									   DIRFLAG	* const pdirflag,
									   const RCEID rceid1,
									   const RCEID rceid2,
									   const RCE * const prceReplace,
									   const VERPROXY * const pverproxy );
ERR	ErrBTISelectSplit( FUCB *pfucb, SPLITPATH *psplitPath, KEYDATAFLAGS *pkdf, DIRFLAG dirflag );
ERR	ErrBTISplitAllocAndCopyPrefix( const KEY &key, DATA *pdata );
ERR	ErrBTISplitAllocAndCopyPrefixes( FUCB *pfucb, SPLIT *psplit );
VOID BTISeekSeparatorKey( SPLIT *psplit, FUCB *pfucb );
ERR ErrBTISplitComputeSeparatorKey( SPLIT *psplit, FUCB *pfucb );
LOCAL VOID BTISelectPrefix( const LINEINFO 	*rglineinfo,
							INT 			clines,
							PREFIXINFO		*pprefixinfo );
LOCAL VOID BTISelectPrefixes( SPLIT *psplit, INT ilineSplit );
VOID BTISplitSetPrefixes( SPLIT *psplit );
VOID BTISetPrefix( LINEINFO *rglineinfo, INT clines, const PREFIXINFO& prefixinfo );
VOID BTISplitCalcUncFree( SPLIT *psplit );
VOID BTISelectAppend( SPLIT *psplit, FUCB *pfucb );
VOID BTISelectVerticalSplit( SPLIT *psplit, FUCB *pfucb );
VOID BTISelectRightSplit( SPLIT *psplit, FUCB *pfucb );
BOOL FBTISplitCausesNoOverflow( SPLIT *psplit, INT cLineSplit );
VOID BTIRecalcWeightsLE( SPLIT *psplit );
VOID BTISelectSplitWithOperNone( SPLIT *psplit, FUCB *pfucb );
ERR	ErrBTINewSplit( FUCB *pfucb, SPLITPATH *psplitPath, KEYDATAFLAGS *pkdf, DIRFLAG dirflag );
ERR ErrBTINewMerge( MERGEPATH *pmergePathLeaf );
VOID BTIReleaseSplit( INST *pinst, SPLIT *psplit );
VOID BTIReleaseMergeLineinfo( MERGE *pmerge );
VOID BTIReleaseMerge( MERGE *pmerge );
LOCAL ULONG CbBTIMaxSizeOfNode( const FUCB * const pfucb, const CSR * const pcsr );
INT IlineBTIFrac( FUCB *pfucb, DIB *pdib );

ERR	ErrBTISelectMerge(
	FUCB	*pfucb,
	MERGEPATH *pmergePathLeaf,
	const BOOKMARK& bm,
	BOOKMARK *pbmNext,
	RECCHECK * const preccheck );
ERR ErrBTIMergeCollectPageInfo( FUCB *pfucb, MERGEPATH *pmergePathLeaf, RECCHECK * preccheck );
ERR ErrBTIMergeLatchSiblingPages( FUCB *pfucb, MERGEPATH * const pmergePathLeaf );
VOID BTICheckMergeable( FUCB *pfucb, MERGEPATH *pmergePath );
BOOL FBTIOverflowOnReplacingKey( FUCB 					*pfucb,
								 MERGEPATH				*pmergePath,
								 const KEYDATAFLAGS& 	kdfSep );
ERR ErrBTIMergeCopySeparatorKey( MERGEPATH 	*pmergePath,
								 MERGE		*pmergeLeaf,
								 FUCB 		*pfucb );

ERR ErrBTISelectMergeInternalPages( FUCB *pfucb, MERGEPATH * const pmergePathLeaf );
ERR  ErrBTIMergeOrEmptyPage( FUCB *pfucb, MERGEPATH *pmergePathLeaf );
VOID BTIPerformMerge( FUCB *pfucb, MERGEPATH *pmergePathLeaf );
VOID BTIPerformOneMerge( FUCB *pfucb,
						 MERGEPATH *pmergePath,
						 MERGE *pmergeLeaf );
VOID BTIChangeKeyOfPagePointer( FUCB *pfucb, CSR *pcsr, const KEY& key );
LOCAL ERR ErrBTIMergeUpgradeLatches( const IFMP ifmp, MERGEPATH * const pmergePathLeaf );
VOID BTIMergeReleaseUnneededPages( MERGEPATH *pmergePathLeaf );
VOID BTIMergeSetLgpos( MERGEPATH *pmergePathLeaf, const LGPOS& lgpos );
VOID BTIMergeReleaseLatches( MERGEPATH *pmergePathLeaf );
VOID BTIReleaseEmptyPages( FUCB *pfucb, MERGEPATH *pmergePathLeaf );
VOID BTIMergeDeleteFlagDeletedNodes( FUCB *pfucb, MERGEPATH *pmergePath );
VOID BTIMergeFixSiblings( INST *pinst, MERGEPATH *pmergePath );
VOID BTIMergeMoveNodes( FUCB *pfucb, MERGEPATH *pmergePath );

VOID BTICheckMerge( FUCB *pfucb, MERGEPATH *pmergePathLeaf );
VOID BTICheckMergeLeaf( FUCB *pfucb, MERGEPATH *pmergePath );
VOID BTICheckMergeInternal( FUCB 		*pfucb,
							MERGEPATH 	*pmergePath,
							MERGE		*pmergeLeaf );

//	single page cleanup routines
//
LOCAL ERR ErrBTISinglePageCleanup( FUCB *pfucb, const BOOKMARK& bm );
LOCAL ERR ErrBTISPCCollectLeafPageInfo(
	FUCB		*pfucb,
	CSR			*pcsr,
	LINEINFO	**plineinfo,
	RECCHECK	* const preccheck,
	BOOL		*pfEmptyPage,
	BOOL		*pfExistsFlagDeletedNodeWithActiveVersion,
	BOOL		*pfLessThanOneThirdFull );
LOCAL ERR ErrBTISPCDeleteNodes( FUCB *pfucb, CSR *pcsr, LINEINFO *rglineinfo );
ERR ErrBTISPCSeek( FUCB *pfucb, const BOOKMARK& bm );
BOOL FBTISPCCheckMergeable( FUCB *pfucb, CSR *pcsrRight, LINEINFO *rglineinfo );

//	debug routines
//
VOID AssertBTIVerifyPgnoSplit( FUCB *pfucb, SPLITPATH *psplitPath );
VOID AssertBTIBookmarkSaved( const FUCB *pfucb );

//	move to node
//
INT CbNDCommonPrefix( FUCB *pfucb, CSR *pcsr, const KEY& key );

//  HACK:  reference to BF internal

extern TABLECLASS tableclassNameSetMax;

PERFInstanceG<> cBTSeekShortCircuit;
PM_CEF_PROC LBTSeekShortCircuitCEFLPv;
LONG LBTSeekShortCircuitCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTSeekShortCircuit.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTUnnecessarySiblingLatch;
PM_CEF_PROC LBTUnnecessarySiblingLatchCEFLPv;
LONG LBTUnnecessarySiblingLatchCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTUnnecessarySiblingLatch.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTNext;
PM_CEF_PROC LBTNextCEFLPv;
LONG LBTNextCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTNext.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTPrev;
PM_CEF_PROC LBTPrevCEFLPv;
LONG LBTPrevCEFLPv( LONG iInstance, VOID* pvBuf )
	{
	cBTPrev.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTSeek;
PM_CEF_PROC LBTSeekCEFLPv;
LONG LBTSeekCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTSeek.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTAppend;
PM_CEF_PROC LBTAppendCEFLPv;
LONG LBTAppendCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTAppend.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTInsert;
PM_CEF_PROC LBTInsertCEFLPv;
LONG LBTInsertCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTInsert.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTReplace;
PM_CEF_PROC LBTReplaceCEFLPv;
LONG LBTReplaceCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTReplace.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTFlagDelete;
PM_CEF_PROC LBTFlagDeleteCEFLPv;
LONG LBTFlagDeleteCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTFlagDelete.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTDelete;
PM_CEF_PROC LBTDeleteCEFLPv;
LONG LBTDeleteCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTDelete.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTAppendSplit;
PM_CEF_PROC LBTAppendSplitCEFLPv;
LONG LBTAppendSplitCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTAppendSplit.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTRightSplit;
PM_CEF_PROC LBTRightSplitCEFLPv;
LONG LBTRightSplitCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTRightSplit.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTVerticalSplit;
PM_CEF_PROC LBTVerticalSplitCEFLPv;
LONG LBTVerticalSplitCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTVerticalSplit.PassTo( iInstance, pvBuf );
	return 0;
	}

PM_CEF_PROC LBTSplitCEFLPv;
LONG LBTSplitCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	if ( NULL != pvBuf )
		{
		*(LONG*)pvBuf = cBTAppendSplit.Get( iInstance ) + cBTRightSplit.Get( iInstance ) + cBTVerticalSplit.Get( iInstance );
		}
	return 0;
	}

PERFInstanceG<> cBTEmptyPageMerge;
PM_CEF_PROC LBTEmptyPageMergeCEFLPv;
LONG LBTEmptyPageMergeCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTEmptyPageMerge.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTRightMerge;
PM_CEF_PROC LBTRightMergeCEFLPv;
LONG LBTRightMergeCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTRightMerge.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTPartialMerge;
PM_CEF_PROC LBTPartialMergeCEFLPv;
LONG LBTPartialMergeCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTPartialMerge.PassTo( iInstance, pvBuf );
	return 0;
	}

PM_CEF_PROC LBTMergeCEFLPv;
LONG LBTMergeCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	if ( NULL != pvBuf )
		{
		*(LONG*)pvBuf = cBTEmptyPageMerge.Get( iInstance ) + cBTRightMerge.Get( iInstance ) + cBTPartialMerge.Get( iInstance );
		}
	return 0;
	}

//	UNDONE: Fully add support for this counter
PERFInstanceG<> cBTFailedWriteLatchForSPC;
PM_CEF_PROC LBTFailedWriteLatchForSPC;
LONG LBTFailedWriteLatchForSPC( LONG iInstance, VOID *pvBuf )
	{
	cBTFailedWriteLatchForSPC.PassTo( iInstance, pvBuf );
	return 0;
	}



//	******************************************************
//	BTREE API ROUTINES
//


//	******************************************************
//	Open/Close operations
//

//	opens a cursor on given fcb [BTree]
//	uses defer-closed cursor, if possible
//	given FCB must already have a cursor on it
//		which will not be closed while this operation is
//		in progress
//
ERR	ErrBTOpen( PIB *ppib, FCB *pfcb, FUCB **ppfucb, BOOL fAllowReuse )
	{
	ERR		err;
	FUCB 	*pfucb;

	Assert( pfcb != pfcbNil );
	Assert( pfcb->FInitialized() );

	// In most cases, we should reuse a deferred-closed FUCB.  The one
	// time we don't want to is if we're opening a space cursor.
	if ( fAllowReuse )
		{
		// cannabalize deferred closed cursor
		for ( pfucb = ppib->pfucbOfSession;
			pfucb != pfucbNil;
			pfucb = pfucb->pfucbNextOfSession )
			{
			if ( FFUCBDeferClosed( pfucb ) && !FFUCBNotReuse( pfucb ) )
				{
				Assert( !FFUCBSpace( pfucb ) );		// Space cursors are never defer-closed.

				// Secondary index FCB may have been deallocated by
				// rollback of CreateIndex or cleanup of DeleteIndex
				Assert( pfucb->u.pfcb != pfcbNil || FFUCBSecondary( pfucb ) );
				if ( pfucb->u.pfcb == pfcb )
					{
					const BOOL	fVersioned	= FFUCBVersioned( pfucb );

					Assert( pfcbNil != pfucb->u.pfcb );
					Assert( ppib->level > 0 );
					Assert( pfucb->levelOpen <= ppib->level );

					//	Reset all used flags. Keep Updatable (fWrite) flag
					//
					FUCBResetFlags( pfucb );
					Assert( !FFUCBDeferClosed( pfucb ) );

					FUCBResetPreread( pfucb );

					//	must persist Versioned flag
					Assert( !FFUCBVersioned( pfucb ) );		//	got reset by FUCBResetFlags()
					if ( fVersioned )
						FUCBSetVersioned( pfucb );

					Assert( !FFUCBUpdatable( pfucb ) );
					if ( !rgfmp[ pfcb->Ifmp() ].FReadOnlyAttach() )
						{
						FUCBSetUpdatable( pfucb );
						}

					*ppfucb = pfucb;

					return JET_errSuccess;
					}
				}
			}
		}
	else
		pfucb = pfucbNil;		// Initialise for FUCBOpen() below.

	Assert( pfucbNil == pfucb );
	CallR( ErrFUCBOpen( ppib,
					   pfcb->Ifmp(),
					   &pfucb ) );

	//	link FCB
	//
	pfcb->Link( pfucb );
	*ppfucb = pfucb;

	return JET_errSuccess;
	}

//	opens a cursor on given FCB on behalf of another thread.
//	uses defer-closed cursor, if possible
ERR	ErrBTOpenByProxy( PIB *ppib, FCB *pfcb, FUCB **ppfucb, const LEVEL level )
	{
	ERR		err;
	FUCB 	*pfucb;

	Assert( ppib->critTrx.FOwner() );

	Assert( level > 0 );
	Assert( pfcb != pfcbNil );
	Assert( pfcb->FInitialized() );

	// This routine only called by concurrent create index to obtain a cursor
	// on a secondary index tree.
	Assert( pfcb->FTypeSecondaryIndex() );
	Assert( pfcbNil == pfcb->PfcbTable() );	// FCB not yet linked into table's index list
	Assert( !pfcb->FInitialIndex() );

	pfcb->Lock();

	for ( pfucb = pfcb->Pfucb();
		pfucb != pfucbNil;
		pfucb = pfucb->pfucbNextOfFile )
		{
		if ( pfucb->ppib == ppib )
			{
			const BOOL	fVersioned	= FFUCBVersioned( pfucb );

			// If there are any cursors on this tree at all for this user, then
			// it must be deferred closed, because we only use the cursor to
			// insert into the version store, then close it.
			Assert( FFUCBDeferClosed( pfucb ) );

			Assert( !FFUCBNotReuse( pfucb ) );
			Assert( !FFUCBSpace( pfucb ) );
			Assert( FFUCBIndex( pfucb ) );
			Assert( FFUCBSecondary( pfucb ) );
			Assert( pfucb->u.pfcb == pfcb );
			Assert( ppib->level > 0 );
			Assert( pfucb->levelOpen > 0 );

			// Temporarily set levelOpen to 0 to ensure
			// that ErrIsamRollback() doesn't close the
			// FUCB on us.
			pfucb->levelOpen = 0;

			// Reset all used flags. Keep Updatable (fWrite) flag
			//
			FUCBResetFlags( pfucb );
			Assert( !FFUCBDeferClosed( pfucb ) );

			FUCBResetPreread( pfucb );

			//	must persist Versioned flag
			Assert( !FFUCBVersioned( pfucb ) );		//	got reset by FUCBResetFlags()
			if ( fVersioned )
				FUCBSetVersioned( pfucb );

			// Set fIndex/fSecondary flags to ensure FUCB
			// doesn't get closed by ErrIsamRollback(), then
			// set proper levelOpen.
			FUCBSetIndex( pfucb );
			FUCBSetSecondary( pfucb );
			pfucb->levelOpen = level;

			Assert( !rgfmp[ pfcb->Ifmp() ].FReadOnlyAttach() );
			FUCBSetUpdatable( pfucb );

			pfcb->Unlock();

			*ppfucb = pfucb;

			return JET_errSuccess;
			}
		}

	pfcb->Unlock();

	Assert( pfucbNil == pfucb );
	Assert( level > 0 );
	CallR( ErrFUCBOpen( ppib,
					   pfcb->Ifmp(),
					   &pfucb,
					   level ) );

	// Must have these flags set BEFORE linking into session list to
	// ensure ErrIsamRollback() doesn't close the FUCB prematurely.
	Assert( FFUCBIndex( pfucb ) );
	Assert( FFUCBSecondary( pfucb ) );

	//	link FCB
	//
	pfcb->Link( pfucb );

	*ppfucb = pfucb;

	return JET_errSuccess;
	}


//	closes cursor at BT level
//	releases BT level resources
//
VOID BTClose( FUCB *pfucb )
	{
	INST *pinst = PinstFromPfucb( pfucb );

	FUCBAssertNoSearchKey( pfucb );

	// Current secondary index should already have been closed.
	Assert( !FFUCBCurrentSecondary( pfucb ) );

	//	release memory used by bookmark buffer
	//
	BTReleaseBM( pfucb );

	if ( Pcsr( pfucb )->FLatched() )
		{
		if( pfucb->pvRCEBuffer )
			{
			OSMemoryHeapFree( pfucb->pvRCEBuffer );
			pfucb->pvRCEBuffer = NULL;
			}
		Pcsr( pfucb )->ReleasePage( pfucb->u.pfcb->FNoCache() );
		}

	Assert( pfucb->u.pfcb != pfcbNil );
	if ( pinst->m_plog->m_fRecovering &&
		 pinst->m_plog->m_ptablehfhash != NULL &&
		 pfucb == pinst->m_plog->m_ptablehfhash->PfucbGet( pfucb->ifmp,
	 											PgnoFDP( pfucb ),
	 											pfucb->ppib->procid,
	 											FFUCBSpace( pfucb ) ) )
		{
		//	delete reference to FUCB from hash table
		//
		pinst->m_plog->m_ptablehfhash->Delete( pfucb );
		}

	//	if cursor created version,
	//		defer close until commit to transaction level 0
	//		since rollback needs cursor
	//
	if ( pfucb->ppib->level > 0 && FFUCBVersioned( pfucb ) )
		{
		Assert( !FFUCBSpace( pfucb ) );		// Space operations not versioned.
		FUCBSetDeferClose( pfucb );
		}
	else
		{
		FCB *pfcb = pfucb->u.pfcb;

		//	reset FCB flags associated with this cursor
		//
		if ( FFUCBDenyRead( pfucb ) )
			{
			pfcb->ResetDomainDenyRead();
			}
		if ( FFUCBDenyWrite( pfucb ) )
			{
			pfcb->ResetDomainDenyWrite();
			}

		if ( !pfcb->FInitialized() )
			{

			//	we own the FCB (we're closing because the FCB was created during
			//		a DIROpen() of a DIRCreateDirectory() or because an error
			//		occurred during FILEOpenTable())

			//	unlink the FUCB from the FCB without moving the FCB to the
			//		avail LRU list (this prevents the FCB from being purged)

			FCBUnlinkWithoutMoveToAvailList( pfucb );

			//	synchronously purge the FCB

			pfcb->PrepareForPurge();
			pfcb->Purge();
			}
		else if ( pfcb->FTypeTable() )
			{

			//	only table FCBs can be moved to the avail-LRU list

			//	unlink the FUCB from the FCB and place the FCB in the avail-LRU
			//		list so it can be used or purged later

			FCBUnlink( pfucb );
			}
		else
			{

			//	all other types of FCBs will not be allowed in the avail-LRU list
			//
			//	NOTE: these FCBs must be purged manually!

			//	possible reasons why we are here:
			//		- we were called from ErrFILECloseTable() and have taken the
			//			special temp-table path
			//		- we are closing a sort FCB
			//		- ???
			//
			//	NOTE: database FCBs will never be purged because they are never
			//			available (PgnoFDP() == pgnoSystemRoot); these FCBs will
			//			be cleaned up when the database is detached or the instance
			//			is closed
			//	NOTE: sentinel FCBs will never be purged because they are never
			//			available either (FTypeSentinel()); these FCBs will be
			//			purged by version cleanup

			FCBUnlinkWithoutMoveToAvailList( pfucb );
			}

		//	close the FUCB

		FUCBClose( pfucb );
		}
	}


//	******************************************************
//	retrieve/release operations
//

//	UNDONE: INLINE the following functions

//	gets node in pfucb->kdfCurr
//	refreshes currency to point to node
//	if node is versioned get correct version from the version store
//
ERR ErrBTGet( FUCB *pfucb )
	{
	ERR			err;
	const BOOL	fBookmarkPreviouslySaved	= pfucb->fBookmarkPreviouslySaved;

	Call( ErrBTIRefresh( pfucb ) );
	CallS( err );
	Assert( Pcsr( pfucb )->FLatched() );

	BOOL	fVisible;
	err = ErrNDVisibleToCursor( pfucb, &fVisible );
	if ( err < 0 )
		{
		BTUp( pfucb );
		}
	else if ( !fVisible )
		{
		BTUp( pfucb );
		err = ErrERRCheck( JET_errRecordDeleted );
		}
	else
		{
		//	if this flag was FALSE when we first came into
		//	this function, it means the bookmark has yet
		//	to be saved (so leave it to FALSE so that
		//	BTRelease() will know to save it)
		//	if this flag was TRUE when we first came into
		//	this function, it means that we previously
		//	saved the bookmark already, so no need to
		//	re-save it (if NDGet() was called in the call
		//	to ErrBTIRefresh() above, it would have set
		//	the flag to FALSE, which is why we need to
		//	set it back to TRUE here)
		pfucb->fBookmarkPreviouslySaved = fBookmarkPreviouslySaved;
		}

HandleError:
	Assert( err >= 0 || !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	releases physical currency,
//	save logical currency
//	then, unlatch page
//
ERR ErrBTRelease( FUCB	*pfucb )
	{
	ERR	err = JET_errSuccess;

	if ( Pcsr( pfucb )->FLatched() )
		{
		if ( !pfucb->fBookmarkPreviouslySaved )
			{
			err = ErrBTISaveBookmark( pfucb );
			}
		if ( err >= JET_errSuccess )
			{
			AssertBTIBookmarkSaved( pfucb );
			}
		pfucb->ulLTCurr = pfucb->ulLTLast;
		pfucb->ulTotalCurr = pfucb->ulTotalLast;

		// release page anyway, return previous error
		Pcsr( pfucb )->ReleasePage( pfucb->u.pfcb->FNoCache() );
		if( NULL != pfucb->pvRCEBuffer )
			{
			OSMemoryHeapFree( pfucb->pvRCEBuffer );
			pfucb->pvRCEBuffer = NULL;
			}
		}

	//	We have touched, no longer need to touch again.
	//
	pfucb->fTouch = fFalse;

#ifdef DEBUG
	pfucb->kdfCurr.Invalidate();
#endif	//	DEBUG

	return err;
	}


// return fTrue in *pfReplaced if node updated by this transaction
//
ERR	ErrBTFReplace( FUCB * const pfucb, BOOL *pfReplace )
	{
	ERR			err = JET_errSuccess;

	Call( ErrBTIRefresh( pfucb ) );
	CallS( err );
	Assert( Pcsr( pfucb )->FLatched() );
	Call( ErrNDFModified( pfucb, pfReplace ) );

HandleError:
	Assert( err >= 0 || !Pcsr( pfucb )->FLatched() );
	return err;
	}

//	saves given bookmark in cursor
//	and resets physical currency
//
ERR	ErrBTDeferGotoBookmark( FUCB *pfucb, const BOOKMARK& bm, BOOL fTouch )
	{
	ERR		err;

	CallR( ErrBTISaveBookmark( pfucb, bm, fTouch ) );
	BTUp( pfucb );

	return err;
	}


//	saves logical currency -- bookmark only
//	must be called before releasing physical currency
//	CONSIDER: change callers to not ask for bookmarks if not needed
//	CONSIDER: simplify by invalidating currency on resource allocation failure
//
//	tries to save primary key [or data] in local cache first
//	since it has higher chance of fitting
//	and in many cases we can refresh currency using just the primary key
//	bookmark save operation should be after all resources are allocated,
//	so resource failure would still leave previous bm valid
//
ERR ErrBTISaveBookmark( FUCB *pfucb, const BOOKMARK& bm, BOOL fTouch )
	{
	const UINT	cbKey	= bm.key.Cb();
	const UINT	cbData	= bm.data.Cb();
	UINT	cbReq;
	BOOL	fUnique		=  FFUCBUnique( pfucb );
	BOOL	fKeyLocal	= fFalse;
	BOOL	fDataLocal	= fFalse;

	Assert( !fUnique || pfucb->bmCurr.data.FNull() );
	Assert( NULL == bm.key.suffix.Pv() || bm.key.suffix.Pv() != pfucb->bmCurr.key.suffix.Pv() );
	Assert( NULL == bm.key.prefix.Pv() || bm.key.prefix.Pv() != pfucb->bmCurr.key.prefix.Pv() );
	Assert( NULL == bm.data.Pv() || bm.data.Pv() != pfucb->bmCurr.data.Pv() );

	//	if tree does not allow duplicates
	//	store only key
	//
	cbReq = cbKey;
	if ( !fUnique )
		{
		cbReq += cbData;
		}

	//	assess key and data placement
	//
	if ( cbReq <= cbBMCache )
		{
		fKeyLocal	= fTrue;
		fDataLocal	= fTrue;
		cbReq = 0;
		}
	else if ( cbData <= cbBMCache && !fUnique )
		{
		fDataLocal = fTrue;
		Assert( cbReq >= cbData );
		cbReq -= cbData;
		}
	else if ( cbKey <= cbBMCache )
		{
		fKeyLocal = fTrue;
		Assert( cbReq >= cbKey );
		cbReq -= cbKey;
		}

	const UINT	fracIncrease	= 2;

	//	if we need more memory than allocated buffer, allocate more
	//	if  we have allocated way too much, free some
	//
	if ( cbReq > pfucb->cbBMBuffer ||
		 cbReq < pfucb->cbBMBuffer / ( fracIncrease * 2 ) )
		{
		UINT	cbAlloc = cbReq > pfucb->cbBMBuffer ?
								cbReq * fracIncrease :
								pfucb->cbBMBuffer / fracIncrease;
		Assert( cbAlloc >= cbReq );

		VOID	*pvTemp = NULL;

		if ( cbAlloc > 0 )
			{
			pvTemp = PvOSMemoryHeapAlloc( cbAlloc );
			if ( pvTemp == NULL )
				{
				return ErrERRCheck( JET_errOutOfMemory );
				}
			}

		Assert( pvTemp != NULL || cbAlloc == 0 );
		if ( pfucb->cbBMBuffer > 0 )
			{
			OSMemoryHeapFree( pfucb->pvBMBuffer );
			}
		pfucb->pvBMBuffer = pvTemp;
		pfucb->cbBMBuffer = cbAlloc;
		Assert( cbAlloc >= cbReq );
		}

	//	now we are ready to copy the bookmark
	//	since we are guaranteed  not to fail

	//	Record if we are going to touch the data page of this bookmark

	pfucb->fTouch = fTouch;

	//
	//	copy key
	//
	pfucb->bmCurr.key.Nullify();
	if ( fKeyLocal )
		{
		Assert( cbKey <= cbBMCache );
		pfucb->bmCurr.key.suffix.SetPv( pfucb->rgbBMCache );
		}
	else
		{
		Assert( cbKey <= pfucb->cbBMBuffer );
		pfucb->bmCurr.key.suffix.SetPv( pfucb->pvBMBuffer );
		}
	pfucb->bmCurr.key.suffix.SetCb( cbKey );
	bm.key.CopyIntoBuffer( pfucb->bmCurr.key.suffix.Pv() );

	//	copy data
	//
	if ( fUnique )
		{
		//	bookmark does not need data
		pfucb->bmCurr.data.Nullify();
		}

	else
		{
		if ( fDataLocal )
			{
			Assert( cbData <= cbBMCache );
			pfucb->bmCurr.data.SetPv ( fKeyLocal ?
				pfucb->rgbBMCache + cbKey : pfucb->rgbBMCache );
			}
		else if ( fKeyLocal )
			{
			Assert( fKeyLocal && !fDataLocal );
			Assert( cbKey <= cbBMCache );
			Assert( cbData <= pfucb->cbBMBuffer );
			pfucb->bmCurr.data.SetPv( pfucb->pvBMBuffer );
			}
		else
			{
			Assert( !fKeyLocal && !fDataLocal );
			Assert( cbKey > cbBMCache && cbData > cbBMCache );
			Assert( cbData + cbKey <= pfucb->cbBMBuffer );
			pfucb->bmCurr.data.SetPv( (BYTE *) pfucb->pvBMBuffer + cbKey );
			}

		bm.data.CopyInto( pfucb->bmCurr.data );
		}

	//	Record that we now have the bookmark saved

	pfucb->fBookmarkPreviouslySaved = fTrue;

	return JET_errSuccess;
	}



//  ================================================================
LOCAL BOOL FKeysEqual( const KEY& key1, KEY * const pkey, const ULONG cbKey )
//  ================================================================
//
//  Compares two keys, using length as a tie-breaker
//
//-
	{
	if( key1.Cb() == cbKey )
		{
		KEY		key2;
		key2.prefix.Nullify();
		key2.suffix.SetPv( pkey );
		key2.suffix.SetCb( cbKey );
		return ( 0 == CmpKeyShortest( key1, key2 ) );
		}
	return fFalse;
	}


LOCAL ERR ErrBTIReportBadPageLink(
	FUCB		* const pfucb,
	const ERR	err,
	const PGNO	pgnoComingFrom,
	const PGNO	pgnoGoingTo,
	const PGNO	pgnoBadLink )	//	may actually be an OBJID if the bad link is due to mismatched objids
	{
	//	only report the error if not repairing
	if ( !fGlobalRepair )
		{
		const UINT	csz		= 7;
		const CHAR	* rgsz[csz];
		CHAR		rgszDw[csz][16];

		sprintf( rgszDw[0], "%d", err );
		sprintf( rgszDw[1], "%d", pfucb->u.pfcb->ObjidFDP() );
		sprintf( rgszDw[2], "%d", pfucb->u.pfcb->PgnoFDP() );
		sprintf( rgszDw[3], "%d", pgnoComingFrom );
		sprintf( rgszDw[4], "%d", pgnoGoingTo );
		sprintf( rgszDw[5], "%d", pgnoBadLink );

		rgsz[0] = rgszDw[0];
		rgsz[1] = rgszDw[1];
		rgsz[2] = rgszDw[2];
		rgsz[3] = rgfmp[pfucb->u.pfcb->Ifmp()].SzDatabaseName();
		rgsz[4] = rgszDw[3];
		rgsz[5] = rgszDw[4];
		rgsz[6] = rgszDw[5];

		UtilReportEvent(
				eventError,
				DATABASE_CORRUPTION_CATEGORY,
				BAD_PAGE_LINKS_ID,
				csz,
				rgsz,
				0,
				NULL,
				PinstFromPfucb( pfucb ) );
		}

	Assert( JET_errBadPageLink == err || JET_errBadParentPageLink == err );
	return err;
	}


//	goto the next line in tree
//
ERR	ErrBTNext( FUCB *pfucb, DIRFLAG dirflag )
	{
	// function called with dirflag == fDIRAllNode from eseutil - node dumper
	// Assert( ! ( dirflag & fDIRAllNode ) );

	ERR			err;
	KEY *		pkeySave	= NULL;
	ULONG		cbKeySave;
	CSR * const	pcsr		= Pcsr( pfucb );

	//	refresh currency
	//	places cursor on record to move from
	//
	CallR( ErrBTIRefresh( pfucb ) );

Start:
	PERFIncCounterTable( cBTNext, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	//	now we have a read latch on page
	//
	Assert( pcsr->Latch() == latchReadTouch ||
			pcsr->Latch() == latchReadNoTouch ||
			pcsr->Latch() == latchRIW );
	Assert( ( pcsr->Cpage().FLeafPage() ) != 0 );
	AssertNDGet( pfucb );

	//	get next node in page
	//	if it does not exist, go to next page
	//
	if ( pcsr->ILine() + 1 < pcsr->Cpage().Clines() )
		{
		//	get next node
		//
		pcsr->IncrementILine();
		NDGet( pfucb );

		//  adjust key position
		//
		if ( pfucb->ulTotalLast )
			{
			pfucb->ulLTLast++;
			}
		}
	else
		{
		Assert( pcsr->ILine() + 1 == pcsr->Cpage().Clines() );

		//  reset key position
		//
		pfucb->ulLTLast = 0;
		pfucb->ulTotalLast = 0;

		//	next node not in current page
		//	get next page and continue
		//
		if ( pcsr->Cpage().PgnoNext() == pgnoNull )
			{
			//	past the last node
			//	callee must set loc to AfterLast
			//
			err = ErrERRCheck( JET_errNoCurrentRecord );
			goto HandleError;
			}
		else
			{
			const PGNO	pgnoFrom	= pcsr->Pgno();

			//	access next page [R latched]
			//
			Call( pcsr->ErrSwitchPage(
								pfucb->ppib,
								pfucb->ifmp,
								pcsr->Cpage().PgnoNext(),
								pfucb->u.pfcb->Tableclass(),
								pfucb->u.pfcb->FNoCache() ) );

			const BOOL	fBadSiblingPointer	= ( pcsr->Cpage().PgnoPrev() != pgnoFrom );
			if( fBadSiblingPointer
				|| pcsr->Cpage().ObjidFDP() != pfucb->u.pfcb->ObjidFDP() )
				{
				const PGNO	pgnoBadLink		= ( fBadSiblingPointer ?
														pcsr->Cpage().PgnoPrev() :
														pcsr->Cpage().ObjidFDP() );

				//	if not repair, assert, otherwise, suppress the assert and
				//	repair will just naturally err out
				AssertSz( fGlobalRepair, "Corrupt B-tree: bad leaf page links detected on MoveNext" );
				Call( ErrBTIReportBadPageLink(
						pfucb,
						ErrERRCheck( JET_errBadPageLink ),
						pgnoFrom,
						pcsr->Pgno(),
						pgnoBadLink ) );
				}

			// get first node
			//
			NDMoveFirstSon( pfucb );

			if( FFUCBPreread( pfucb ) &&
				FFUCBPrereadForward( pfucb ) )
				{
				if ( pfucb->cpgPrereadNotConsumed > 0 )
					{
					//	read one more of preread pages
					//
					pfucb->cpgPrereadNotConsumed--;
					}

				if( 1 == pfucb->cpgPrereadNotConsumed
					&& pcsr->Cpage().PgnoNext() != pgnoNull )
					{
					//  preread the next page as it was not originally preread
					const PGNO pgnoNext = pcsr->Cpage().PgnoNext();
					BFPrereadPageRange( pfucb->ifmp, pgnoNext, 1 );
					}

				if ( 0 == pfucb->cpgPrereadNotConsumed
					 && !FNDDeleted( pfucb->kdfCurr ) )
					{
					//	if we need to do neighbour-key check, must save off
					//	bookmark
					if ( ( dirflag & fDIRNeighborKey )
						&& NULL == pkeySave )
						{
						pkeySave = (KEY *)PvOSMemoryHeapAlloc( KEY::cbKeyMax );
						if ( NULL == pkeySave )
							{
							Call( ErrERRCheck( JET_errOutOfMemory ) );
							}

						cbKeySave = pfucb->bmCurr.key.Cb();
						pfucb->bmCurr.key.CopyIntoBuffer( pkeySave, KEY::cbKeyMax );
						}

					//	UNDONE:	this might cause a bug since there is an assumption
					//			that ErrBTNext does not lose latch
					//
					//	preread more pages
					//
					Call( ErrBTRelease( pfucb ) );
					BTUp( pfucb );
					Call( ErrBTIRefresh( pfucb ) );
					}
				}
			}
		}

	AssertNDGet( pfucb );

	//	but node may not be valid due to dirFlag
	//

	//	move again if fDIRNeighborKey set and next node has same key
	//
	if ( dirflag & fDIRNeighborKey )
		{
		const BOOL	fSkip	= ( NULL == pkeySave ?
									FKeysEqual( pfucb->kdfCurr.key, pfucb->bmCurr.key ) :
									FKeysEqual( pfucb->kdfCurr.key, pkeySave, cbKeySave ) );
		if ( fSkip )
			{
			Assert( !FFUCBUnique( pfucb ) );
			goto Start;
			}
		}

	// function called with dirflag == fDIRAllNode from eseutil - node dumper
	// Assert( ! ( dirflag & fDIRAllNode ) );
	if ( !( dirflag & fDIRAllNode ) )
		{
		//	fDIRAllNode not set
		//	check version store to see if node is visible to cursor
		//
		BOOL fVisible;
		Call( ErrNDVisibleToCursor( pfucb, &fVisible ) );
		if ( !fVisible )
			{
			//	node not visible to cursor
			//	goto next node
			//
			goto Start;
			}
		}

	AssertNDGet( pfucb );
	err = JET_errSuccess;

HandleError:
	if ( NULL != pkeySave )
		{
		Assert( dirflag & fDIRNeighborKey );
		OSMemoryHeapFree( pkeySave );
		}
	return err;
	}


//	goes to previous line in tree
//
ERR	ErrBTPrev( FUCB *pfucb, DIRFLAG dirflag )
	{
	Assert( !( dirflag & fDIRAllNode ) );

	ERR			err;
	KEY *		pkeySave		= NULL;
	ULONG		cbKeySave;
	CSR * const	pcsr			= Pcsr( pfucb );

#ifdef DEBUG
	INT			crepeat			= 0;
#endif

	//	refresh currency
	//	places cursor on record to move from
	//

	CallR( ErrBTIRefresh( pfucb ) );

Start:
	PERFIncCounterTable( cBTPrev, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	//	now we have a read latch on page
	//
	Assert( latchReadTouch == pcsr->Latch() ||
			latchReadNoTouch == pcsr->Latch() ||
			latchRIW == pcsr->Latch() );
	Assert( ( pcsr->Cpage().FLeafPage() ) != 0 );
	AssertNDGet( pfucb );

	//	get prev node in page
	//	if it does not exist, go to prev page
	//
	if ( pcsr->ILine() > 0 )
		{
		//	get prev node
		//
		pcsr->DecrementILine();
		NDGet( pfucb );

		//  adjust key position
		//
		if ( pfucb->ulTotalLast )
			{
			pfucb->ulLTLast--;
			}
		}
	else
		{
		Assert( pcsr->ILine() == 0 );

		//  reset key position
		//
		pfucb->ulLTLast = 0;
		pfucb->ulTotalLast = 0;

		//	prev node not in current page
		//	get prev page and continue
		//
		if ( pcsr->Cpage().PgnoPrev() == pgnoNull )
			{
			//	past the first node
			//
			err = ErrERRCheck( JET_errNoCurrentRecord );
			goto HandleError;
			}
		else
			{
			const PGNO	pgnoFrom	= pcsr->Pgno();

			//	access prev page [R latched] without wait
			//	if conflict, release latches and retry
			//	else proceed
			//	the release of current page is done atomically by CSR
			//
			err = pcsr->ErrSwitchPageNoWait(
									pfucb->ppib,
									pfucb->ifmp,
									pcsr->Cpage().PgnoPrev(),
									pfucb->u.pfcb->Tableclass() );
			if ( err == errBFLatchConflict )
				{
				#ifdef DEBUG
				crepeat++;
				Assert( crepeat < 1000 );
				#endif

				//	save bookmark
				//	release latches
				//	re-seek
				//
				const PGNO		pgnoWait	= pcsr->Cpage().PgnoPrev();
				const LATCH		latch		= pcsr->Latch();

				//	if we need to do neighbour-key check, must save off
				//	bookmark
				if ( ( dirflag & fDIRNeighborKey )
					&& NULL == pkeySave )
					{
					pkeySave = (KEY *)PvOSMemoryHeapAlloc( KEY::cbKeyMax );
					if ( NULL == pkeySave )
						{
						Call( ErrERRCheck( JET_errOutOfMemory ) );
						}

					cbKeySave = pfucb->bmCurr.key.Cb();
					pfucb->bmCurr.key.CopyIntoBuffer( pkeySave, KEY::cbKeyMax );
					}

				Assert( pcsr->FLatched() );
				Call( ErrBTRelease( pfucb ) );
				Assert( !pcsr->FLatched() );

				//	wait & refresh currency
				//
				//  NOTE:  we wait on the page that caused the conflict solely
				//  as a form of delay.  there is no guarantee that this will
				//  really be the page we want once we wake up
				//
				err = pcsr->ErrGetRIWPage(
									pfucb->ppib,
									pfucb->ifmp,
									pgnoWait,
									pfucb->u.pfcb->Tableclass() );
				if ( err < JET_errSuccess )
					{
					//  use sleep as a last resort
					UtilSleep( cmsecWaitGeneric );
					}
				else
					{
					pcsr->ReleasePage();
					}

				Call( ErrBTGotoBookmark( pfucb, pfucb->bmCurr, latch, fFalse ) );

				if ( wrnNDFoundGreater == err ||
					 JET_errSuccess == err )
					{
					//	go to previous node
					//
					goto Start;
					}
				}
			else
				{
				Call( err );

				const BOOL	fBadSiblingPointer	= ( pcsr->Cpage().PgnoNext() != pgnoFrom );
				if( fBadSiblingPointer
					|| pcsr->Cpage().ObjidFDP() != pfucb->u.pfcb->ObjidFDP() )
					{
					const PGNO	pgnoBadLink		= ( fBadSiblingPointer ?
															pcsr->Cpage().PgnoNext() :
															pcsr->Cpage().ObjidFDP() );

					//	if not repair, assert, otherwise, suppress the assert and
					//	repair will just naturally err out
					AssertSz( fGlobalRepair, "Corrupt B-tree: bad leaf page links detected on MovePrev" );
					Call( ErrBTIReportBadPageLink(
								pfucb,
								ErrERRCheck( JET_errBadPageLink ),
								pgnoFrom,
								pcsr->Pgno(),
								pgnoBadLink ) );
					}

				//	get last node in page
				//
				NDMoveLastSon( pfucb );

				if( FFUCBPreread( pfucb ) &&
					FFUCBPrereadBackward( pfucb ) )
					{
					if ( pfucb->cpgPrereadNotConsumed > 0 )
						{
						pfucb->cpgPrereadNotConsumed--;
						}

					if( 1 == pfucb->cpgPrereadNotConsumed
						&& pcsr->Cpage().PgnoPrev() != pgnoNull )
						{
						//  preread the next page as it was not originally preread
						const PGNO pgnoPrev = pcsr->Cpage().PgnoPrev();
						BFPrereadPageRange( pfucb->ifmp, pgnoPrev, 1 );
						}

					if ( 0 == pfucb->cpgPrereadNotConsumed
						 && !FNDDeleted( pfucb->kdfCurr ) )
						{
						//	if we need to do neighbour-key check, must save off
						//	bookmark
						if ( ( dirflag & fDIRNeighborKey )
							&& NULL == pkeySave )
							{
							pkeySave = (KEY *)PvOSMemoryHeapAlloc( KEY::cbKeyMax );
							if ( NULL == pkeySave )
								{
								Call( ErrERRCheck( JET_errOutOfMemory ) );
								}

							cbKeySave = pfucb->bmCurr.key.Cb();
							pfucb->bmCurr.key.CopyIntoBuffer( pkeySave, KEY::cbKeyMax );
							}

						//	preread more pages
						//
						Call( ErrBTRelease( pfucb ) );
						BTUp( pfucb );
						Call( ErrBTIRefresh( pfucb ) );
						}
					}
				}
			}
		}

	//	get prev node
	//
	AssertNDGet( pfucb );

	//	but node may not be valid due to dirFlag
	//

	//	move again if fDIRNeighborKey set and prev node has same key
	//
	if ( dirflag & fDIRNeighborKey )
		{
		const BOOL	fSkip	= ( NULL == pkeySave ?
									FKeysEqual( pfucb->kdfCurr.key, pfucb->bmCurr.key ) :
									FKeysEqual( pfucb->kdfCurr.key, pkeySave, cbKeySave ) );
		if ( fSkip )
			{
			Assert( !FFUCBUnique( pfucb ) );
			goto Start;
			}
		}

	Assert( !( dirflag & fDIRAllNode ) );
	if ( !( dirflag & fDIRAllNode ) )
		{
		//	fDIRAllNode not set
		//	check version store to see if node is visible to cursor
		//
		BOOL fVisible;
		Call( ErrNDVisibleToCursor( pfucb, &fVisible ) );
		if ( !fVisible)
			{
			//	node not visible to cursor
			//	goto prev node
			//
			goto Start;
			}
		}

	AssertNDGet( pfucb );
	err = JET_errSuccess;

HandleError:
	if ( NULL != pkeySave )
		{
		Assert( dirflag & fDIRNeighborKey );
		OSMemoryHeapFree( pkeySave );
		}
	return err;
	}


//  ================================================================
VOID BTPrereadPage( IFMP ifmp, PGNO pgno )
//  ================================================================
	{
	PGNO rgpgno[2] = { pgno, pgnoNull };
	BFPrereadPageList( ifmp, rgpgno );
	}


//  ================================================================
VOID BTPrereadSpaceTree( const FCB * const pfcb )
//  ================================================================
//
//  Most of the time we will only need the Avail-Extent. Only if it
//  is empty will we need the Owned-Extent. However, the two pages are together
//  on disk so they are very cheap to read together.
//
//-
	{
	Assert( pfcbNil != pfcb );

	INT		ipgno = 0;
	PGNO	rgpgno[3];		// pgnoOE, pgnoAE, pgnoNull
	if( pgnoNull != pfcb->PgnoOE() )	//	may be single-extent
		{
		Assert( pgnoNull != pfcb->PgnoAE() );
		rgpgno[ipgno++] = pfcb->PgnoOE();
		rgpgno[ipgno++] = pfcb->PgnoAE();
		rgpgno[ipgno++] = pgnoNull;
		BFPrereadPageList( pfcb->Ifmp(), rgpgno );
		}
	}


//  ================================================================
VOID BTPrereadIndexesOfFCB( FCB * const pfcb )
//  ================================================================
	{
	Assert( pfcbNil != pfcb );
	Assert( pfcb->FTypeTable() );
	Assert( ptdbNil != pfcb->Ptdb() );

	const INT	cMaxIndexesToPreread	= 16;
	PGNO 		rgpgno[cMaxIndexesToPreread + 1];	//  NULL-terminated
	INT			ipgno					= 0;

	pfcb->EnterDML();

	for ( const FCB * pfcbT = pfcb->PfcbNextIndex();
		pfcbNil != pfcbT && ipgno < cMaxIndexesToPreread;
		pfcbT = pfcbT->PfcbNextIndex() )
		{
		const IDB * const	pidbT	= pfcbT->Pidb();
		if ( !pidbT->FSparseIndex()
			&& !pidbT->FSparseConditionalIndex() )
			{
			//	this index isn't sparse, so odds are it
			//	will have to be updated, so go ahead
			//	and preread its pgnoFDP
			//
			rgpgno[ipgno++] = pfcbT->PgnoFDP();
			}
		}

	pfcb->LeaveDML();

	//	NULL-terminate the list of pages to preread,
	//	then issue the actual preread
	//
	rgpgno[ipgno] = pgnoNull;
	BFPrereadPageList( pfcb->Ifmp(), rgpgno );
	}


//  extracts the list of pages to preread and call BF to preread them
//
ERR ErrBTIPreread( FUCB *pfucb, CPG cpg, CPG * pcpgActual )
	{
#ifdef DEBUG
	const INT	ilineOrig = Pcsr( pfucb )->ILine();
#endif	//	DEBUG

	const CPG	cpgPreread = min( cpg,
								  FFUCBPrereadForward( pfucb ) ?
									Pcsr( pfucb )->Cpage().Clines() - Pcsr( pfucb )->ILine() :
									Pcsr( pfucb )->ILine() + 1 );


	//  add 1 PGNO for null termination of the list
	PGNO * rgpgnoPreread = (PGNO *)PvOSMemoryHeapAlloc( ( cpgPreread + 1 ) * sizeof(PGNO) );
	if( NULL == rgpgnoPreread )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	KEY		keyLimit;
	BOOL	fOutOfRange = fFalse;
	if( FFUCBLimstat( pfucb ) )
		{
		//  we don't want to preread pages that aren't part of the index range
		//  the separator key is greater than any key on the page it points to
		//  so we always preread a page if the separator key is equal to our
		//  index limit

		FUCBAssertValidSearchKey( pfucb );
		keyLimit.prefix.Nullify();
		keyLimit.suffix.SetPv( pfucb->dataSearchKey.Pv() );
		keyLimit.suffix.SetCb( pfucb->dataSearchKey.Cb() );
		}

	INT 	ipgnoPreread;
	for( ipgnoPreread = 0; ipgnoPreread < cpgPreread; ++ipgnoPreread )
		{
		NDGet( pfucb );
		Assert( pfucb->kdfCurr.data.Cb() == sizeof( PGNO ) );

		if( FFUCBLimstat( pfucb ) )
			{

			//  we want to preread the first page that is out of range
			//  so don't break until the top of the loop

			if( fOutOfRange )
				{
				break;
				}

			//  the separator key is suffix compressed so just compare the shortest key

			const INT	cmp				= CmpKeyShortest( pfucb->kdfCurr.key, keyLimit );

			if ( cmp > 0 )
				{
				fOutOfRange = FFUCBUpper( pfucb );
				}
			else if ( cmp < 0 )
				{
				fOutOfRange = !FFUCBUpper( pfucb );
				}
			else
				{
				//  always preread the page if the separator key is equal
				fOutOfRange = fFalse;
				}
			}

		rgpgnoPreread[ipgnoPreread] = *(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv();

		if( FFUCBPrereadBackward( pfucb ) )
			{
			Assert( Pcsr( pfucb )->ILine() >= 0 );
			Pcsr( pfucb )->DecrementILine();
			}
		else
			{
			Assert( Pcsr( pfucb )->ILine() < Pcsr( pfucb )->Cpage().Clines() );
			Pcsr( pfucb )->IncrementILine();
			}
		}

	rgpgnoPreread[ipgnoPreread] = pgnoNull;

	BFPrereadPageList( pfucb->u.pfcb->Ifmp(), rgpgnoPreread, pcpgActual );

	OSMemoryHeapFree( rgpgnoPreread );
	return JET_errSuccess;
	}


//	seeks to key from root of tree
//
//		pdib->pos == posFirst --> seek to first node in tree
//					 posLast  --> seek to last node in tree
//					 posDown --> seek to pdib->key in tree
//					 posFrac --> fractional positioning
//
//		pdib->pbm	used for posDown and posFrac
//
//		pdib->dirflag == fDIRAllNode --> seek to deleted/versioned nodes too
//
//	positions cursor on node if one exists and is visible to cursor
//	else on next node visible to cursor
//	if no next node exists that is visible to cursor,
//		move previous to visible node
//
ERR	ErrBTDown( FUCB *pfucb, DIB *pdib, LATCH latch )
	{
	ERR			err							= JET_errSuccess;
	ERR			wrn							= JET_errSuccess;
	CSR * const	pcsr						= Pcsr( pfucb );
	PGNO 		pgnoParent					= pgnoNull;
	const BOOL	fSeekOnNonUniqueKeyOnly		= ( posDown == pdib->pos
												&& !FFUCBUnique( pfucb )
												&& 0 == pdib->pbm->data.Cb() );

#ifdef CHECK_UNIQUE_KEY_ON_NONUNIQUE_INDEX
	//	unique-key check can only be done for an exact-match key-only seek on
	//	a non-unique index
	BOOL		fKeyIsolatedToCurrentPage	= fFalse;
	const BOOL	fCheckUniqueness			= ( ( pdib->dirflag & fDIRCheckUniqueness )
												&& ( pdib->dirflag & fDIRExact )
												&& fSeekOnNonUniqueKeyOnly );
#endif

#ifdef DEBUG
	ULONG		ulTrack						= 0x00;
#endif	//	DEBUG

	Assert( latchReadTouch == latch || latchReadNoTouch == latch ||
			latchRIW == latch );
	Assert( posDown == pdib->pos
			|| 0 == ( pdib->dirflag & (fDIRFavourPrev|fDIRFavourNext|fDIRExact) ) );

	//	no latch should be held by cursor on tree
	//
	Assert( !pcsr->FLatched() );

	PERFIncCounterTable( cBTSeek, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	//	go to root
	//
	Call( ErrBTIGotoRoot( pfucb, latch ) );

	//	if no nodes in root, return
	//
	if ( 0 == pcsr->Cpage().Clines() )
		{
		BTUp( pfucb );
		return ErrERRCheck( JET_errRecordNotFound );
		}

	CallS( err );

	//  setup to compute our record position
	//
	pfucb->ulLTLast = 0;
	pfucb->ulTotalLast = 1;

	//	seek to key
	//
	for ( ; ; )
		{
		//	verify page belongs to this btree
		//
		if ( pcsr->Cpage().ObjidFDP() != pfucb->u.pfcb->ObjidFDP() )
			{
			//	if not repair, assert, otherwise, suppress the assert and repair will
			//	just naturally err out
			AssertSz( fGlobalRepair, "Corrupt B-tree: page does not belong to btree" );
			Call( ErrBTIReportBadPageLink(
						pfucb,
						ErrERRCheck( JET_errBadParentPageLink ),
						pgnoParent,
						pcsr->Pgno(),
						pcsr->Cpage().ObjidFDP() ) );
			}

		//	for every page level, seek to key
		//	if internal page,
		//		get child page
		//		move cursor to new page
		//		release parent page
		//
		switch ( pdib->pos )
			{
			case posDown:
				Call( ErrNDSeek( pfucb, *(pdib->pbm) ) );
				wrn = err;
				break;

			case posFirst:
				NDMoveFirstSon( pfucb );
				break;

			case posLast:
				NDMoveLastSon( pfucb );
				break;

			default:
				Assert( pdib->pos == posFrac );
				pcsr->SetILine( IlineBTIFrac( pfucb, pdib ) );
				NDGet( pfucb );
				break;
			}


		const INT	iline	= pcsr->ILine();
		const INT	clines	= pcsr->Cpage().Clines();

		//	adjust number of records and key position
		//	for this tree level
		//
		pfucb->ulLTLast = pfucb->ulLTLast * clines + iline;
		pfucb->ulTotalLast = pfucb->ulTotalLast * clines;

		if ( pcsr->Cpage().FLeafPage() )
			{
			//	leaf node reached, exit loop
			//
			break;
			}
		else
			{
#ifdef DEBUG
			const PGNO	pgnoDBG				= pcsr->Pgno();
			ulTrack |= 0x01;
#endif

			const BOOL	fPageParentOfLeaf 	= pcsr->Cpage().FParentOfLeaf();

			//	if performing a key-only seek on a non-unique tree,
			//	ErrNDSeek above GUARANTEES that this node's key+data
			//	is greater than the key being seeked, because of one
			//	of the following:
			//		- the node has a NULL key
			//		- the node's key itself is greater than the key being seeked
			//		- keys are equal, but the node's data portion forces it greater
			Assert( !fSeekOnNonUniqueKeyOnly
				|| pfucb->kdfCurr.key.FNull()
				|| CmpKeyShortest( pfucb->kdfCurr.key, pdib->pbm->key ) > 0
				|| ( CmpKeyShortest( pfucb->kdfCurr.key, pdib->pbm->key ) == 0
					&& pfucb->kdfCurr.key.Cb() > pdib->pbm->key.Cb() ) );

#ifdef CHECK_UNIQUE_KEY_ON_NONUNIQUE_INDEX
			if ( fPageParentOfLeaf && fCheckUniqueness )
				{
				//	The key being seeked may have dupes if this
				//	node's key is not strictly greater than the
				//	key being seeked when we compare up to the
				//	length of the shortest of the two
				//
				fKeyIsolatedToCurrentPage = ( pfucb->kdfCurr.key.FNull()
											|| CmpKeyShortest( pfucb->kdfCurr.key, pdib->pbm->key ) > 0 );
				}
#endif

			//	get pgno of child from node
			//	switch to that page
			//
			Assert( pfucb->kdfCurr.data.Cb() == sizeof( PGNO ) );
			const PGNO	pgnoChild			= *(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv();

			if ( FFUCBPreread( pfucb ) )
				{
				//  NOTE: the preread code below may not restore the kdfCurr

				if ( fPageParentOfLeaf )
					{
					if ( 0 == pfucb->cpgPrereadNotConsumed && pfucb->cpgPreread > 1 )
						{
						//	if prereading and have reached the page above the leaf level,
						//	extract next set of pages to be preread
						Call( ErrBTIPreread( pfucb, pfucb->cpgPreread, &pfucb->cpgPrereadNotConsumed) );
						}
					}
				else if ( ( FFUCBSequential( pfucb ) || FFUCBLimstat( pfucb ) )
						&& FFUCBPrereadForward( pfucb ) )
					{
					//  if prereading a sequential table and on an internal page read the next
					//  internal child page as well
					CPG cpgUnused;
					Call( ErrBTIPreread( pfucb, 2, &cpgUnused ) );
					}

				//	iline must be restored because ErrBTIPreread may have fiddled
				//	with it in order to look at other nodes on the page
				//
				pcsr->SetILine( iline );
				}

			pgnoParent = pcsr->Pgno();

			Call( pcsr->ErrSwitchPage(
						pfucb->ppib,
						pfucb->ifmp,
						pgnoChild,
						pfucb->u.pfcb->Tableclass(),
						pfucb->u.pfcb->FNoCache()  ) );

			Assert( FFUCBRepair( pfucb )
					|| pcsr->Cpage().FLeafPage() && fPageParentOfLeaf
					|| !pcsr->Cpage().FLeafPage() && !fPageParentOfLeaf );
			}
		}

	//	now, the cursor is on leaf node
	//
	Assert( pcsr->Cpage().FLeafPage() );
	AssertBTType( pfucb );
	AssertNDGet( pfucb );

	//  if we were going to the first/last page in the tree, check to see that it
	//  doesn't have a sibling
	if ( posFirst == pdib->pos && pgnoNull != pcsr->Cpage().PgnoPrev() )
		{
		//	if not repair, assert, otherwise, suppress the assert and repair will
		//	just naturally err out
		AssertSz( fGlobalRepair, "Corrupt B-tree: first page has pgnoPrev" );
		Call( ErrBTIReportBadPageLink(
					pfucb,
					ErrERRCheck( JET_errBadParentPageLink ),
					pgnoParent,
					pcsr->Pgno(),
					pcsr->Cpage().PgnoPrev() ) );
		}
	else if ( posLast == pdib->pos && pgnoNull != pcsr->Cpage().PgnoNext() )
		{
		//	if not repair, assert, otherwise, suppress the assert and repair will
		//	just naturally err out
		AssertSz( fGlobalRepair, "Corrupt B-tree: last page has pgnoNext" );
		Call( ErrBTIReportBadPageLink(
					pfucb,
					ErrERRCheck( JET_errBadParentPageLink ),
					pgnoParent,
					pcsr->Pgno(),
					pcsr->Cpage().PgnoNext() ) );
		}

	//	if node is not visible to cursor,
	//	move next till a node visible to cursor is found,
	//		if that leaves end of tree,
	//			move previous to first node visible to cursor
	//
	//	fDIRAllNode flag is used by ErrBTGotoBookmark
	//	to go to deleted records
	//
	Assert( !( ( pdib->dirflag & fDIRAllNode ) &&
			JET_errNoCurrentRecord == err ) );
	if ( !( pdib->dirflag & fDIRAllNode ) )
		{
#ifdef DEBUG
		ulTrack |= 0x02;
#endif	//	DEBUG

		BOOL	fVisible;
		Call( ErrNDVisibleToCursor( pfucb, &fVisible ) );
		Assert( !fVisible || JET_errNoCurrentRecord != err );

		if ( !fVisible )
			{
#ifdef DEBUG
			ulTrack |= 0x04;
#endif	//	DEBUG

			if ( ( pdib->dirflag & fDIRFavourNext ) || posFirst == pdib->pos )
				{
				//	fDIRFavourNext is only set if we know we want RecordNotFound
				//	if there are no nodes greater than or equal to the one we
				//	want, in which case there's no point going ErrBTPrev().
				//
#ifdef DEBUG
				ulTrack |= 0x08;
#endif	//	DEBUG
				wrn = wrnNDFoundGreater;
				err = ErrBTNext( pfucb, fDIRNull );
				}
			else if ( ( pdib->dirflag & fDIRFavourPrev ) || posLast == pdib->pos )
				{
				//	this flag is only set if we know we want RecordNotFound
				//	if there are no nodes less than or equal to the one we
				//	want, in which case there's no point going ErrBTNext().
				//
#ifdef DEBUG
				ulTrack |= 0x10;
#endif	//	DEBUG
				wrn = wrnNDFoundLess;
				err = ErrBTPrev( pfucb, fDIRNull );
				}
			else if ( ( pdib->dirflag & fDIRExact ) && !fSeekOnNonUniqueKeyOnly )
				{
#ifdef DEBUG
				ulTrack |= 0x20;
#endif	//	DEBUG
				err = ErrERRCheck( JET_errRecordNotFound );
				}
			else
				{
#ifdef DEBUG
				ulTrack |= 0x40;
#endif	//	DEBUG
				wrn = wrnNDFoundGreater;
				err = ErrBTNext( pfucb, fDIRNull );
				if( JET_errNoCurrentRecord == err )
					{
					wrn = wrnNDFoundLess;
					err = ErrBTPrev( pfucb, fDIRNull );
					}
				}
			Call( err );

			//	BTNext/Prev() shouldn't return these warnings
			Assert( wrnNDFoundGreater != err );
			Assert( wrnNDFoundLess != err );

			//	if on a non-unique index and no data portion of the
			//	bookmark was passed in, may need to do a "just the key"
			//	comparison
			if ( fSeekOnNonUniqueKeyOnly )
				{
#ifdef DEBUG
				ulTrack |= 0x80;
#endif	//	DEBUG
				const BOOL fKeysEqual = FKeysEqual( pfucb->kdfCurr.key, pdib->pbm->key );
				if ( fKeysEqual )
					{
					wrn = JET_errSuccess;
					}
				else
					{
#ifdef DEBUG
					const INT cmp = CmpKey( pfucb->kdfCurr.key, pdib->pbm->key );
					Assert( ( cmp < 0 && wrnNDFoundLess == wrn )
						|| ( cmp > 0 && wrnNDFoundGreater == wrn ) );
#endif	//	DEBUG
					}
				}
			}
		}

	if ( posDown == pdib->pos )
		{
#ifdef DEBUG
		const INT	cmp		= ( ( FFUCBUnique( pfucb ) || fSeekOnNonUniqueKeyOnly ) ?
											CmpKey( pfucb->kdfCurr.key, pdib->pbm->key ) :
											CmpKeyData( pfucb->kdfCurr, *pdib->pbm ) );
		if ( cmp < 0 )
			Assert( wrnNDFoundLess == wrn );
		else if ( cmp > 0 )
			Assert( wrnNDFoundGreater == wrn );
		else
			CallS( wrn );
#endif

		err = wrn;

#ifdef CHECK_UNIQUE_KEY_ON_NONUNIQUE_INDEX
		if ( fCheckUniqueness && JET_errSuccess == err )
			{
			Assert( fSeekOnNonUniqueKeyOnly );
			if ( pcsr->ILine() < pcsr->Cpage().Clines() - 1 )
				{
				//	we're not on the last node on this page
				//	so check the key of the next node
				//
				const INT	cmp		= CmpNDKeyOfNextNode( pcsr, pdib->pbm->key );
				Assert( cmp >= 0 );
				if ( cmp > 0 )
					{
					//	these asserts must be commented out because they do not handle the case
					//	of a down operation landing on a page with all flag deleted nodes
					//	and moving laterally to a page containing the node of interest.
					//
					//	Assert( fKeyIsolatedToCurrentPage || pgnoNull == pcsr->Cpage().PgnoNext() );
					//	Assert( fKeyIsolatedToCurrentPage || pcsr->Cpage().FRootPage() );
					err = ErrERRCheck( JET_wrnUniqueKey );
					}
				}
			else
				{
				//	we're on the last node of the page, so
				//	best check we can do is to see if it's
				//	possible that the next page may contain
				//	the same key
				//
				//	if we are on the last page the key is unique
				//	(we are on the last record in the entire b-tree)
				//
				if ( fKeyIsolatedToCurrentPage || pgnoNull == pcsr->Cpage().PgnoNext() )
					{
					err = ErrERRCheck( JET_wrnUniqueKey );
					}
				}
			}
#endif	//	CHECK_UNIQUE_KEY_ON_NONUNIQUE_INDEX
		}


	//	now, the cursor is on leaf node
	//
	Assert( pcsr->Cpage().FLeafPage() );
	AssertBTType( pfucb );
	AssertNDGet( pfucb );
	Assert( err >= 0 );

///	Assert( Pcsr( pfucb )->Latch() == latch );
	return err;

HandleError:
	Assert( err < 0 );
	BTUp( pfucb );
	if ( JET_errNoCurrentRecord == err )
		{
		err = ErrERRCheck( JET_errRecordNotFound );
		}
	return err;
	}


ERR ErrBTPerformOnSeekBM( FUCB * const pfucb, const DIRFLAG dirflag )
	{
	ERR		err;
	DIB		dib;

	Assert( locOnSeekBM == pfucb->locLogical );
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( fDIRFavourPrev == dirflag
		|| fDIRFavourNext == dirflag );

	dib.pbm		= &pfucb->bmCurr;
	dib.pos		= posDown;
	dib.dirflag	= dirflag;
	err = ErrBTDown( pfucb, &dib, latchReadNoTouch );
	Assert( JET_errRecordDeleted != err );
	Assert( JET_errNoCurrentRecord != err );
	if ( JET_errRecordNotFound == err )
		{
		//	moved past last node
		//
		pfucb->locLogical = ( fDIRFavourPrev == dirflag ? locBeforeFirst : locAfterLast );
		}

	Assert( err < 0 || Pcsr( pfucb )->FLatched() );
	return err;
	}


//	*********************************************
//	direct access routines
//


//	gets position of key by seeking down from root
//	ulTotal is estimated total number of records in tree
//	ulLT is estimated number of nodes lesser than given node
//
ERR ErrBTGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal )
	{
	ERR		err;
	UINT	ulLT = 0;
	UINT	ulTotal = 1;

	//	no latch should be held by cursor on tree
	//
	Assert( !Pcsr( pfucb )->FLatched() );

	//  if we are on locOnSeekBM then purge our cached key position because it
	//  is incorrect
	//
	if ( pfucb->locLogical == locOnSeekBM )
		{
		pfucb->ulLTCurr = 0;
		pfucb->ulTotalCurr = 0;
		}
	else
		{
		//	this function assumes we have a valid bookmark, and
		//	it is currently only called by ErrDIRGetPosition(),
		//	which guarantees logical currency is either
		//	locOnCurBM or locOnSeekBM (and therefore the
		//	current bookmark is valid)
		//
		Assert( locOnCurBM == pfucb->locLogical );
		}

	//  if we have a cached key position then return that
	//
	if ( pfucb->ulTotalCurr )
		{
		*pulLT = pfucb->ulLTCurr;
		*pulTotal = pfucb->ulTotalCurr;
		return JET_errSuccess;
		}

	PERFIncCounterTable( cBTSeek, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	//	go to root
	//
	CallR( ErrBTIGotoRoot( pfucb, latchReadTouch ) );

	//	seek to bookmark key
	//
	for ( ; ; )
		{
		INT		clines = Pcsr( pfucb )->Cpage().Clines();

		//	for every page level, seek to bookmark key
		//
		Call( ErrNDSeek( pfucb, pfucb->bmCurr ) );

		//	adjust number of records and key position
		//	for this tree level
		//
		ulLT = ulLT * clines + Pcsr( pfucb )->ILine();
		ulTotal = ulTotal * clines;

		if ( !Pcsr( pfucb )->Cpage().FInvisibleSons( ) )
			{
			//	leaf node reached, exit loop
			//
			break;
			}
		else
			{
			//	get pgno of child from node
			//	switch to that page
			//
			Assert( pfucb->kdfCurr.data.Cb() == sizeof( PGNO ) );
			Call( Pcsr( pfucb )->ErrSwitchPage(
								pfucb->ppib,
								pfucb->ifmp,
								*(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv(),
								pfucb->u.pfcb->Tableclass(),
								pfucb->u.pfcb->FNoCache()
								) );
			}
		}

	*pulLT = ulLT;
	*pulTotal = ulTotal;
	Assert( ulTotal >= ulLT );

HandleError:
	//	unlatch the page
	//	do not save logical currency
	//
	BTUp( pfucb );
	return err;
	}


//	goes to given bookmark on page [does not check version store]
//	bookmark must have been obtained on a node
//	if bookmark does not exist, returns JET_errRecordNotFound
//	if ExactPos is set, and we can not find node with bookmark == bm
//		we return error
//
ERR ErrBTGotoBookmark( FUCB *pfucb, const BOOKMARK& bm, LATCH latch, BOOL fExactPos )
	{
	ERR			err;
	DIB			dib;
	BOOKMARK 	bmT = bm;

	Assert( !bm.key.FNull() );
	Assert( !FFUCBUnique( pfucb ) || bm.data.Cb() == 0 );
	Assert( FFUCBUnique( pfucb ) || bm.data.Cb() != 0 );
	Assert( latchReadTouch == latch || latchReadNoTouch == latch ||
			latchRIW == latch );

	//	similar to BTDown
	//	goto Root and seek down using bookmark key and data
	//
	dib.pos		= posDown;
	dib.pbm		= &bmT;
	dib.dirflag = fDIRAllNode | ( fExactPos ? fDIRExact : fDIRNull );

	err = ErrBTDown( pfucb, &dib, latch );
	Assert( err < 0 || Pcsr( pfucb )->Latch() == latch );

	if ( fExactPos
		&& ( JET_errRecordNotFound == err
			|| wrnNDFoundLess == err
			|| wrnNDFoundGreater == err ) )
		{
		//	bookmark does not exist anymore
		//
		BTUp( pfucb );
		Assert( !Pcsr( pfucb )->FLatched() );
///		AssertTracking();		//	need this assert to track concurrency bugs
		err = ErrERRCheck( JET_errRecordDeleted );
		}

	return err;
	}


//	seeks for bookmark in page
//	functionality is similar to ErrBTGotoBookmark
//		looking at all nodes [fDIRAllNode]
//		and seeking for equal
//	returns wrnNDNotInPage if bookmark falls outside page boundary
//
ERR	ErrBTISeekInPage( FUCB *pfucb, const BOOKMARK& bmSearch )
	{
	ERR		err;

	Assert( Pcsr( pfucb )->FLatched() );

	if ( Pcsr( pfucb )->Cpage().FEmptyPage() ||
		 !Pcsr( pfucb )->Cpage().FLeafPage() ||
		 Pcsr( pfucb )->Cpage().ObjidFDP() != ObjidFDP( pfucb ) ||
		 0 == Pcsr( pfucb )->Cpage().Clines() )
		{
		return ErrERRCheck( wrnNDNotFoundInPage );
		}

	Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
	Assert( Pcsr( pfucb )->Cpage().ObjidFDP() == ObjidFDP( pfucb ) );
	Assert( !Pcsr( pfucb )->Cpage().FEmptyPage() );

	CallR( ErrNDSeek( pfucb, bmSearch ) );

	if ( wrnNDFoundLess == err &&
			 Pcsr( pfucb )->Cpage().Clines() - 1 == Pcsr( pfucb )->ILine() ||
		 wrnNDFoundGreater == err &&
			 0 == Pcsr( pfucb )->ILine() )
		{
		//	node may be elsewhere if it is not in the range of this page
		//
		err = ErrERRCheck( wrnNDNotFoundInPage );
		}

	return err;
	}


//	******************************************************
//	UPDATE OPERATIONS
//

//	lock record. this does not lock anything, we do not set
//  the version bit and the page is not write latched
//
//  UNDONE: we don't need to latch the page at all. just create
//          the version using the bookmark in the FUCB
//
ERR	ErrBTLock( FUCB *pfucb, DIRLOCK dirlock )
	{
	Assert( dirlock == writeLock
			|| dirlock == readLock );

	const BOOL  fVersion = !rgfmp[pfucb->ifmp].FVersioningOff();
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	ERR		err = JET_errSuccess;

	// UNDONE: If versioning is disabled, so is locking.
	if ( fVersion )
		{
		OPER oper = 0;
		switch( dirlock )
			{
			case writeLock:
				oper = operWriteLock;
				break;
			case readLock:
				oper = operReadLock;
				break;
			default:
				Assert( fFalse );
				Call( ErrERRCheck( JET_errInvalidParameter ) );
				break;
			}

		RCE	*prce = prceNil;
		VER *pver = PverFromIfmp( pfucb->ifmp );
		Call( pver->ErrVERModify(
				pfucb,
				pfucb->bmCurr,
				oper,
				&prce,
				NULL ) );
		Assert( prceNil != prce );
		VERInsertRCEIntoLists( pfucb, pcsrNil, prce, NULL );
		}
	Assert( !Pcsr( pfucb )->FLatched() );

HandleError:
	return err;
	}

//	replace data of current node with given data
//		if necessary, split before replace
//  doesn't take a proxy because it isn't used by concurrent create index
//
ERR	ErrBTReplace( FUCB * const pfucb, const DATA& data, const DIRFLAG dirflag )
	{
	Assert( !FFUCBSpace( pfucb ) || fDIRNoVersion & dirflag );

	ERR		err;
	LATCH	latch		= latchReadNoTouch;
	INT		cbDataOld	= 0;

	PERFIncCounterTable( cBTReplace, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	//	save bookmark
	//
	if ( Pcsr( pfucb )->FLatched() )
		CallR( ErrBTISaveBookmark( pfucb ) );

#ifdef DEBUG
	char rgbKey[ KEY::cbKeyMax ];
	int cbKey;
	char rgbData[ JET_cbPrimaryKeyMost ];
	DATA dataBM;
	dataBM.SetPv( rgbData );

	BOOKMARK *pbmCur = &pfucb->bmCurr;
	pbmCur->key.CopyIntoBuffer( rgbKey, (ULONG)pbmCur->key.Cb() );
	cbKey = pbmCur->key.Cb();
	pbmCur->data.CopyInto( dataBM );
#endif

	const BOOL		fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	RCE * prceReplace = prceNil;
	RCEID rceidReplace = rceidNull;

Start:
	CallR( ErrBTIRefresh( pfucb, latch ) );
	AssertNDGet( pfucb );

	//	non-unique trees have nodes in key-data order
	//	so to replace data, we need to delete and re-insert
	//
	Assert( FFUCBUnique( pfucb ) );

#ifdef DEBUG
	if ( ( latchReadTouch == latch || latchReadNoTouch == latch )
		&& ( latchReadTouch == Pcsr( pfucb )->Latch() || latchReadNoTouch == Pcsr( pfucb )->Latch() ) )
		{
		//	fine!
		}
	else if ( latch == Pcsr( pfucb )->Latch() )
		{
		//	fine!
		}
	else
		{
		Assert( latchWrite == Pcsr( pfucb )->Latch() );
		Assert( FFUCBSpace( pfucb ) || pfucb->u.pfcb->FTypeSLVAvail() );
		}
#endif

#ifdef DEBUG
	char rgbKey2[ KEY::cbKeyMax ];
	pbmCur = &pfucb->bmCurr;
	pbmCur->key.CopyIntoBuffer( rgbKey2, (ULONG)pbmCur->key.Cb() );
	Assert( pbmCur->key.Cb() == cbKey );
	Assert( memcmp( rgbKey, rgbKey2, pbmCur->key.Cb() ) == 0 );
	Assert( pbmCur->data.Cb() == dataBM.Cb() );
	Assert( memcmp( pbmCur->data.Pv(), dataBM.Pv(), dataBM.Cb() ) == 0 );
#endif

	if ( latchWrite != Pcsr( pfucb )->Latch() )
		{
		//	upgrade latch
		//

		err = Pcsr( pfucb )->ErrUpgrade();

		if ( err == errBFLatchConflict )
			{
			Assert( !Pcsr( pfucb )->FLatched() );
			latch = latchRIW;
			goto Start;
			}
		Call( err );
		}

	Assert( latchWrite == Pcsr( pfucb )->Latch() );

	if( fVersion )
		{
		Assert( prceNil == prceReplace );
		VER *pver = PverFromIfmp( pfucb->ifmp );
		Call( pver->ErrVERModify( pfucb, pfucb->bmCurr, operReplace, &prceReplace, NULL ) );
		Assert( prceNil != prceReplace );
		rceidReplace = Rceid( prceReplace );
		}

#ifdef DEBUG
	USHORT	cbUncFreeDBG;
	cbUncFreeDBG = Pcsr( pfucb )->Cpage().CbUncommittedFree();
#endif

	//	try to replace node data with new data
	//
	cbDataOld = pfucb->kdfCurr.data.Cb();
	err = ErrNDReplace( pfucb, &data, dirflag, rceidReplace, prceReplace );

	if ( errPMOutOfPageSpace == err )
		{
		const INT	cbData		= data.Cb();
		Assert( cbData >= 0 );
		const INT	cbReq 		= data.Cb() - cbDataOld;
		Assert( cbReq > 0 );

		KEYDATAFLAGS	kdf;

		//	node replace causes page overflow
		//
		Assert( data.Cb() > pfucb->kdfCurr.data.Cb() );

		AssertNDGet( pfucb );

		kdf.Nullify();
		kdf.data = data;
		Assert( 0 == kdf.fFlags );

		//	call split repeatedly till replace succeeds
		//
		err = ErrBTISplit(
					pfucb,
					&kdf,
					dirflag | fDIRReplace,
					rceidReplace,
					rceidNull,
					prceReplace,
					cbDataOld,
					NULL );

		if ( errBTOperNone == err )
			{
			//	split was performed
			//	but replace did not succeed
			//	retry replace
			//
			Assert( !Pcsr( pfucb )->FLatched() );
			prceReplace = prceNil;	//  the version was nullified in ErrBTISplit
			latch = latchRIW;
			goto Start;
			}
		}

	//	this is the error either from ErrNDReplace() or from ErrBTISplit()
	Call( err );

	AssertBTGet( pfucb );

	if( prceNil != prceReplace )
		{
		Assert( fVersion );
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prceReplace, NULL );
		}
	else
		{
		Assert( !fVersion );
		}

	return err;

HandleError:
	Assert( err < 0 );
	if( prceNil != prceReplace )
		{
		Assert( fVersion );
		VERNullifyFailedDMLRCE( prceReplace );
		}
	BTUp( pfucb );	//  UNDONE:  is this correct?

	return err;
	}


//	performs a delta operation on current node at specified offset
//
ERR	ErrBTDelta(
	FUCB*		pfucb,
	INT			cbOffset,
	const VOID*	pv,
	ULONG		cbMax,
	VOID*		pvOld,
	ULONG		cbMaxOld,
	ULONG*		pcbOldActual,
	DIRFLAG		dirflag )
	{
	ERR			err;
	LATCH		latch		= latchReadNoTouch;

	Assert( !FFUCBSpace( pfucb ) || fDIRNoVersion & dirflag );

	Assert( cbOffset >= 0 );
	if( sizeof( LONG ) != cbMax )
		{
		Assert( fFalse );
		return ErrERRCheck( JET_errInvalidBufferSize );
		}

	if( 0 != cbMaxOld
		&& NULL != pvOld
		&& sizeof( LONG ) != cbMaxOld )
		{
		Assert( fFalse );
		return ErrERRCheck( JET_errInvalidBufferSize );
		}

	//	can't normally come into this function with the page latched,
	//	because we may have to wait on a wait-lock when we go to create
	//	the Delta RCE, but the exception is a delta on the LV tree,
	//	which we know won't conflict with a wait-lock
	Assert( locOnCurBM == pfucb->locLogical );
	if ( Pcsr( pfucb )->FLatched() )
		{
		Assert( pfucb->u.pfcb->FTypeLV() );
		CallR( ErrBTISaveBookmark( pfucb ) );
		}

#ifdef DEBUG
	char rgbKey[ KEY::cbKeyMax ];
	int cbKey;
	char rgbData[ JET_cbPrimaryKeyMost ];
	DATA dataBM;
	dataBM.SetPv( rgbData );

	BOOKMARK *pbmCur = &pfucb->bmCurr;
	pbmCur->key.CopyIntoBuffer( rgbKey, (ULONG)pbmCur->key.Cb() );
	cbKey = pbmCur->key.Cb();
	pbmCur->data.CopyInto( dataBM );
#endif	//	DEBUG

	const LONG		lDelta			= *((LONG *)pv);
	const BOOL		fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	RCE*			prce			= prceNil;
	RCEID			rceid			= rceidNull;

	//	create delta RCE first but can't put in true delta yet
	//	because the page operation hasn't occurred yet
	//	(meaning other threads could still come in
	//	before we're able to obtain the write-latch and
	//	would calculate the wrong versioned delta
	//	because they would take into account this delta
	//	and erroneously compensate for it assuming it
	//	has already occurred on the page), so initially
	//	put in a zero-delta and then update RCE once
	//	we've done the node operation
	if( fVersion )
		{
		VERDELTA	verdelta;
		verdelta.lDelta				= 0;		//	this will be set properly after the node operation
		verdelta.cbOffset			= (USHORT)cbOffset;
		verdelta.fDeferredDelete	= fFalse; 	//	this will be set properly after the node operation
		verdelta.fCallbackOnZero	= fFalse;	//  this will be set properly after the node operation
		verdelta.fDeleteOnZero		= fFalse;	//  this will be set properly after the node operation

		const KEYDATAFLAGS kdfSave = pfucb->kdfCurr;

		pfucb->kdfCurr.data.SetPv( &verdelta );
		pfucb->kdfCurr.data.SetCb( sizeof( VERDELTA ) );

		VER *pver = PverFromIfmp( pfucb->ifmp );
		err = pver->ErrVERModify( pfucb, pfucb->bmCurr, operDelta, &prce, NULL );

		pfucb->kdfCurr = kdfSave;

		Call( err );

		Assert( prceNil != prce );
		rceid = Rceid( prce );
		Assert( rceidNull != rceid );
		}

Start:
	Call( ErrBTIRefresh( pfucb, latch ) );
	AssertNDGet( pfucb );

#ifdef DEBUG
	char rgbKey2[ KEY::cbKeyMax ];
	pbmCur = &pfucb->bmCurr;
	pbmCur->key.CopyIntoBuffer( rgbKey2, (ULONG)pbmCur->key.Cb() );
	Assert( pbmCur->key.Cb() == cbKey );
	Assert( memcmp( rgbKey, rgbKey2, pbmCur->key.Cb() ) == 0 );
	Assert( pbmCur->data.Cb() == dataBM.Cb() );
	Assert( memcmp( pbmCur->data.Pv(), dataBM.Pv(), dataBM.Cb() ) == 0 );
#endif

	Assert(	( ( latchReadTouch == latch || latchReadNoTouch == latch ) &&
			  ( latchReadTouch == Pcsr( pfucb )->Latch() ||
				latchReadNoTouch == Pcsr( pfucb )->Latch() ) ) ||
			latch == Pcsr( pfucb )->Latch() );

	err = Pcsr( pfucb )->ErrUpgrade();

	if ( err == errBFLatchConflict )
		{
		Assert( !Pcsr( pfucb )->FLatched() );
		latch = latchRIW;
		goto Start;
		}
	Call( err );

	//	try to replace node data with new data
	//  we need to store the old value
	LONG lPrev;
	ULONG cbPrevActual;

	Call( ErrNDDelta( pfucb, cbOffset, pv, cbMax, &lPrev, sizeof( lPrev ), &cbPrevActual, dirflag, rceid ) );

	Assert( sizeof( lPrev ) == cbPrevActual );
	if( pvOld )
		{
		*((LONG *)pvOld) = lPrev;
		}
	if( pcbOldActual )
		{
		*pcbOldActual = cbPrevActual;
		}

	if( prceNil != prce )
		{
		VERDELTA* const		pverdelta		= (VERDELTA *)prce->PbData();

		Assert( fVersion );
		Assert( rceidNull != rceid );
		Assert( Pcsr( pfucb )->FLatched() );

		pverdelta->lDelta = lDelta;

		//  if the refcount went to zero we may need to set a flag in the RCE
		if ( 0 == ( lDelta + lPrev ) )
			{
			if( dirflag & fDIRDeltaDeleteDereferencedLV )
				{
				pverdelta->fDeferredDelete = fTrue;
				}
			else
				{
				if( dirflag & fDIREscrowCallbackOnZero )
					{
					pverdelta->fCallbackOnZero = fTrue;
					}
				if ( dirflag & fDIREscrowDeleteOnZero )
					{
					pverdelta->fDeleteOnZero = fTrue;
					}
				}
			}

		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prce, NULL );
		}
	else
		{
		Assert( !fVersion );
		}

	return err;

HandleError:
	Assert( err < 0 );
	if( prceNil != prce )
		{
		Assert( fVersion );
		VERNullifyFailedDMLRCE( prce );
		}

	BTUp( pfucb );
	return err;
	}

//	inserts key and data into tree
//	if inserted node does not fit into leaf page, split page and insert
//	if tree does not allow duplicates,
//		check that there are no duplicates in the tree
//		and also block out other inserts with the same key
//
ERR	ErrBTInsert(
	FUCB			*pfucb,
	const KEY&		key,
	const DATA&		data,
	DIRFLAG			dirflag,
	RCE				*prcePrimary )
	{
	ERR				err;
	BOOKMARK		bmSearch;
	ULONG			cbReq;
	BOOL			fInsert;
	const BOOL		fUnique			= FFUCBUnique( pfucb );
	const BOOL		fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	INT cbDataOld;

	BOOKMARK	bookmark;
	bookmark.key = key;
	if( fUnique )
		{
		bookmark.data.Nullify();
		}
	else
		{
		bookmark.data = data;
		}

	RCE				*prceInsert		= prceNil;
	RCE				*prceReplace	= prceNil;

	RCEID			rceidInsert		= rceidNull;
	RCEID			rceidReplace	= rceidNull;

	VERPROXY		verproxy;
	if ( prceNil != prcePrimary )
		{
		verproxy.prcePrimary 	= prcePrimary;
		verproxy.proxy 			= proxyCreateIndex;
		}

	const VERPROXY * const pverproxy = ( prceNil != prcePrimary ) ? &verproxy : NULL;

	KEYDATAFLAGS	kdf;
	LATCH			latch	= latchReadTouch;

	if ( fVersion )
		{
		VER *pver = PverFromIfmp( pfucb->ifmp );
		err = pver->ErrVERModify( pfucb, bookmark, operPreInsert, &prceInsert, pverproxy );
		if( JET_errWriteConflict == err )
			{
			//  insert never returns a writeConflict, turn it into a keyDuplicate
			err = ErrERRCheck( JET_errKeyDuplicate );
			}
		Call( err );
		Assert( prceInsert );
		rceidInsert = Rceid( prceInsert );
		}

	Assert( !Pcsr( pfucb )->FLatched( ) );
	Assert( !FFUCBSpace( pfucb ) || fDIRNoVersion & dirflag );

	PERFIncCounterTable( cBTInsert, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

Seek:
	PERFIncCounterTable( cBTSeek, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	//	set kdf to insert
	//

	kdf.data	= data;
	kdf.key		= key;
	kdf.fFlags	= 0;
	ASSERT_VALID( &kdf );

	NDGetBookmarkFromKDF( pfucb, kdf, &bmSearch );

	//	no page should be latched
	//
	Assert( !Pcsr( pfucb )->FLatched( ) );

	//	go to root
	//
	Call( ErrBTIGotoRoot( pfucb, latch ) );
	Assert( 0 == Pcsr( pfucb )->ILine() );

	if ( Pcsr( pfucb )->Cpage().Clines() == 0 )
		{
		//	page is empty
		//	set error so we insert at current iline
		//
		Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
		pfucb->kdfCurr.Nullify();
		err = ErrERRCheck( wrnNDFoundGreater );
		}
	else
		{
		//	seek down tree for key alone
		//
		for ( ; ; )
			{
			//	for every page level, seek to bmSearch
			//	if internal page,
			//		get child page
			//		move cursor to new page
			//		release parent page
			//
			Call( ErrNDSeek( pfucb, bmSearch ) );

			if ( !Pcsr( pfucb )->Cpage().FInvisibleSons( ) )
				{
				//	leaf node reached, exit loop
				//
				break;
				}
			else
				{
				//	get pgno of child from node
				//	switch to that page
				//
				Assert( pfucb->kdfCurr.data.Cb() == sizeof( PGNO ) );
				Call( Pcsr( pfucb )->ErrSwitchPage(
							pfucb->ppib,
							pfucb->ifmp,
							*(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv(),
							pfucb->u.pfcb->Tableclass(),
							pfucb->u.pfcb->FNoCache() ) );
				Assert( Pcsr( pfucb )->Cpage().Clines() > 0 );
				}
			}
		}

Insert:
	kdf.data	= data;
	kdf.key		= key;
	kdf.fFlags	= 0;
	ASSERT_VALID( &kdf );

	//	now, the cursor is on leaf node
	//
	Assert( Pcsr( pfucb )->Cpage().FLeafPage() );

	if ( JET_errSuccess == err )
		{
		if ( fUnique )
			{
			Assert( FKeysEqual( kdf.key, pfucb->kdfCurr.key ) );

			if( !FNDDeleted( pfucb->kdfCurr ) )
				{
				//  this is either committed by another transaction that committed before we began
				//  or we inserted this key ourselves earlier
				Call( ErrERRCheck( JET_errKeyDuplicate ) );
				}
#ifdef DEBUG
			else
				{
				Assert( !FNDPotVisibleToCursor( pfucb ) );	//  should have gotten a JET_errWriteConflict when we created the RCE
				}
#endif	//	DEBUG


			cbReq = kdf.data.Cb() > pfucb->kdfCurr.data.Cb() ?
						kdf.data.Cb() - pfucb->kdfCurr.data.Cb() :
						0;
			}
		else
			{
			Assert( 0 == CmpKeyData( bmSearch, pfucb->kdfCurr ) );

			//	can not have two nodes with same key-data
			//
			if ( !FNDDeleted( pfucb->kdfCurr ) )
				{
				// Only way to get here is if a multi-valued index column
				// caused us to generate the same key for the record.
				// This would have happened if the multi-values are non-
				// unique, or if we ran out of keyspace before we could
				// evaluate the unique portion of the multi-values.
				err = ErrERRCheck( JET_errMultiValuedIndexViolation );
				goto HandleError;
				}
#ifdef DEBUG
			else
				{
				Assert( !FNDPotVisibleToCursor( pfucb ) );	//  should have gotten a JET_errWriteConflict when we created the RCE
				}
#endif	//	DEBUG

			//	flag insert node
			//
			cbReq	= 0;
			}

		//	flag insert node and replace data atomically
		//
		fInsert = fFalse;
		}
	else
		{
		//	error is from ErrNDSeek
		//
		if ( wrnNDFoundLess == err )
			{
			//	inserted key-data falls past last node on cursor
			//
			Assert( Pcsr( pfucb )->Cpage().Clines() - 1
						== Pcsr( pfucb )->ILine() );
			Assert( Pcsr( pfucb )->Cpage().Clines() == 0 ||
					!fUnique && CmpKeyData( pfucb->kdfCurr, bmSearch ) < 0 ||
					fUnique && CmpKey( pfucb->kdfCurr.key, bmSearch.key ) < 0 );

 			Pcsr( pfucb )->IncrementILine();
 			}

		//	calculate key prefix
		//
		BTIComputePrefix( pfucb, Pcsr( pfucb ), key, &kdf );
		Assert( !FNDCompressed( kdf ) || kdf.key.prefix.Cb() > 0 );

 		cbReq = CbNDNodeSizeCompressed( kdf );
 		fInsert = fTrue;
 		}

	if( !fInsert && fUnique && fVersion )
		{
		Assert( prceNil != prceInsert );
		Assert( prceNil == prceReplace );
		VER *pver = PverFromIfmp( pfucb->ifmp );
		Call( pver->ErrVERModify( pfucb, bookmark, operReplace, &prceReplace, pverproxy ) );
		Assert( prceNil != prceReplace );
		rceidReplace = Rceid( prceReplace );
		cbDataOld = pfucb->kdfCurr.data.Cb();
		}
#ifdef DEBUG
	else
		{
		Assert( rceidNull == rceidReplace );
		}
#endif	//	DEBUG

#ifdef DEBUG
	USHORT	cbUncFreeDBG;
	cbUncFreeDBG = Pcsr( pfucb )->Cpage().CbUncommittedFree();
#endif

 	//	cursor is at insertion point
 	//
 	//	check if node fits in page
 	//
 	if ( FBTIAppend( pfucb, Pcsr( pfucb ), cbReq ) || FBTISplit( pfucb, Pcsr( pfucb ), cbReq ) )
 		{
		Assert( fUnique || fInsert );

#ifdef PREREAD_SPACETREE_ON_SPLIT
		if( pfucb->u.pfcb->FPreread() )
			{
	 		//  PREREAD space tree while we determine what to split (we WILL need the AE and possibly the OE)
	 		BTPrereadSpaceTree( pfucb->u.pfcb );
	 		}
#endif	//	PREREAD_SPACETREE_ON_SPLIT

		//	re-adjust kdf to not contain prefix info
		//
		kdf.key		= key;
		kdf.data 	= data;
		kdf.fFlags 	= 0;

 		//	split and insert in tree
 		//
 		err = ErrBTISplit(
 					pfucb,
					&kdf,
					dirflag | ( fInsert ? fDIRInsert : fDIRFlagInsertAndReplaceData ),
					rceidInsert,
					rceidReplace,
					prceReplace,
					cbDataOld,
					pverproxy
					);

		if ( errBTOperNone == err )
			{
			//	insert was not performed
			//	retry insert
			//
			Assert( !Pcsr( pfucb )->FLatched() );

			//  the RCE was nullified in ErrBTISplit
			rceidReplace = rceidNull;
			prceReplace = prceNil;
			latch = latchRIW;
			goto Seek;
			}

		Call( err );
		}
	else
		{
		//	upgrade latch to write
		//
		PGNO	pgno = Pcsr( pfucb )->Pgno();

		err = Pcsr( pfucb )->ErrUpgrade();

		if ( err == errBFLatchConflict )
			{
			//	upgrade conflicted
			//	we lost our read latch
			//
			Assert( !Pcsr( pfucb )->FLatched( ) );

			Call( Pcsr( pfucb )->ErrGetPage(
						pfucb->ppib,
						pfucb->ifmp,
						pgno,
						latch,
						pfucb->u.pfcb->Tableclass()
						) );

			Call( ErrBTISeekInPage( pfucb, bmSearch ) );

			if ( wrnNDNotFoundInPage != err )
				{
				//	we have re-seeked to the insert position in page
				//
				Assert( JET_errSuccess == err ||
						wrnNDFoundLess == err ||
						wrnNDFoundGreater == err );

				//  if necessary, we will recreate this so remove it now
				if( prceNil != prceReplace )
					{
					Assert( prceNil != prceInsert );
					VERNullifyFailedDMLRCE( prceReplace );
					rceidReplace = rceidNull;
					prceReplace = prceNil;
					}

				latch = latchRIW;
				goto Insert;
				}

			//  if necessary, we will recreate this so remove it now

			if( prceNil != prceReplace )
				{
				Assert( prceNil != prceInsert );
				VERNullifyFailedDMLRCE( prceReplace );
				rceidReplace = rceidNull;
				prceReplace = prceNil;
				}

			//	reseek from root for insert

			BTUp( pfucb );

			latch = latchRIW;
			goto Seek;
			}

		Call( err );
		Assert( !FBTIAppend( pfucb, Pcsr( pfucb ), cbReq, fFalse ) );
		Assert(	!FBTISplit( pfucb, Pcsr( pfucb ), cbReq, fFalse ) );

		if ( fInsert )
			{
			err = ErrNDInsert( pfucb, &kdf, dirflag, rceidInsert, pverproxy );
			}
		else if ( fUnique )
			{
			Assert( FKeysEqual( kdf.key, pfucb->kdfCurr.key ) );
			err = ErrNDFlagInsertAndReplaceData(
						pfucb,
						&kdf,
						dirflag,
						rceidInsert,
						rceidReplace,
						prceReplace,
						pverproxy );
			}
		else
			{
			err = ErrNDFlagInsert( pfucb, dirflag, rceidInsert, pverproxy );
			}
		Assert ( errPMOutOfPageSpace != err );
		Call( err );
		}

	Assert( err >= 0 );
	Assert( Pcsr( pfucb )->FLatched( ) );
	if( prceNil != prceInsert )
		{
		Assert( fVersion );

		prceInsert->ChangeOper( operInsert );
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prceInsert, pverproxy );
		}
#ifdef DEBUG
	else
		{
		Assert( !fVersion );
		}
#endif	//	DEBUG

	if( prceNil != prceReplace )
		{
		Assert( fVersion );
		Assert( prceNil != prceInsert );
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prceReplace, pverproxy );
		}

HandleError:
	if ( err < 0 )
		{
		if( prceNil != prceReplace )
			{
			Assert( fVersion );
			Assert( prceNil != prceInsert );
			VERNullifyFailedDMLRCE( prceReplace );
			}
		if( prceNil != prceInsert )
			{
			Assert( fVersion );
			VERNullifyFailedDMLRCE( prceInsert );
			}
		BTUp( pfucb );
		}

	return err;
	}


//	append a node to the end of the  latched page
//	if node insert violates density constraint
//		split and insert
//
ERR	ErrBTAppend( FUCB			*pfucb,
				 const KEY& 	key,
				 const DATA& 	data,
				 DIRFLAG		dirflag )
	{
	const BOOL		fUnique			= FFUCBUnique( pfucb );
	const BOOL		fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	ERR				err;
	KEYDATAFLAGS	kdf;
	ULONG			cbReq;

Retry:

	Assert( !FFUCBSpace( pfucb ) || fDIRNoVersion & dirflag );
	Assert( Pcsr( pfucb )->FLatched() &&
			latchWrite == Pcsr( pfucb )->Latch() );
	Assert( pgnoNull == Pcsr( pfucb )->Cpage().PgnoNext() );
	Assert( Pcsr( pfucb )->Cpage().FLeafPage( ) );

	PERFIncCounterTable( cBTAppend, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	BOOKMARK	bookmark;
	bookmark.key = key;
	if( fUnique )
		{
		bookmark.data.Nullify();
		}
	else
		{
		bookmark.data = data;
		}

	RCE	* prceInsert = prceNil;
	if ( fVersion )
		{
		VER *pver = PverFromIfmp( pfucb->ifmp );
		Call( pver->ErrVERModify( pfucb, bookmark, operPreInsert, &prceInsert, NULL ) );
		Assert( prceInsert );
		}

	//	set kdf
	//
	kdf.key		= key;
	kdf.data	= data;
	kdf.fFlags	= 0;

#ifdef DEBUG
	Pcsr( pfucb )->SetILine( Pcsr( pfucb )->Cpage().Clines() - 1 );
	NDGet( pfucb );
	//  while repairing we may append a NULL key to the end of the page
	if( !( FFUCBRepair( pfucb ) && key.Cb() == 0 ) )
		{
		if ( FFUCBUnique( pfucb ) )
			{
			Assert( CmpKey( pfucb->kdfCurr.key, kdf.key ) < 0 );
			}
		else
			{
			Assert( CmpKeyData( pfucb->kdfCurr, kdf ) < 0 );
			}
		}
#endif

	//	set insertion point
	//
	Pcsr( pfucb )->SetILine( Pcsr( pfucb )->Cpage().Clines() );

	//	insert node at end of page
	//
	BTIComputePrefix( pfucb, Pcsr( pfucb ), key, &kdf );
	Assert( !FNDCompressed( kdf ) || kdf.key.prefix.Cb() > 0 );

	cbReq = CbNDNodeSizeCompressed( kdf );

#ifdef DEBUG
	USHORT	cbUncFreeDBG;
	cbUncFreeDBG = Pcsr( pfucb )->Cpage().CbUncommittedFree();
#endif

	//	cursor is at insertion point
	//
	//	check if node fits in page
	//
	if ( FBTIAppend( pfucb, Pcsr( pfucb ), cbReq ) )
		{
		//	readjust kdf to not contain prefix info
		//
		kdf.key		= key;
		kdf.data	= data;
		kdf.fFlags	= 0;

		//	split and insert in tree
		//
		err = ErrBTISplit( pfucb,
						   &kdf,
						   dirflag | fDIRInsert,
						   Rceid( prceInsert ),
						   rceidNull,
						   prceNil,
						   0,
						   NULL );

		if ( errBTOperNone == err && !FFUCBRepair( pfucb ) )
			{
			//	insert was not performed
			//	retry insert using normal insert operation
			//
			Assert( !Pcsr( pfucb )->FLatched() );
			Call( ErrBTInsert( pfucb, key, data, dirflag ) );
			return err;
			}
		else if ( errBTOperNone == err && FFUCBRepair( pfucb ) )
			{
			//	insert was not performed
			//	we may be inserting a NULL key so we can't go through
			//	the normal insert logic. move to the end of the tree
			//	and insert
			//
			Assert( !Pcsr( pfucb )->FLatched() );

			DIB dib;
			dib.pos = posLast;
			dib.pbm = NULL;
			dib.dirflag = fDIRNull;
			Call( ErrBTDown( pfucb, &dib, latchRIW ) );
			Call( Pcsr( pfucb )->ErrUpgrade() );
			goto Retry;
			}

		}
	else
		{
		Assert( !FBTISplit( pfucb, Pcsr( pfucb ), cbReq, fFalse ) );
		Assert( latchWrite == Pcsr( pfucb )->Latch() );

		//	insert node
		//
		err = ErrNDInsert( pfucb, &kdf, dirflag, Rceid( prceInsert ), NULL );
		Assert ( errPMOutOfPageSpace != err );
		}

	Call( err );

	AssertBTGet( pfucb );

	Assert( err >= 0 );
	Assert( Pcsr( pfucb )->FLatched( ) );
	if( prceNil != prceInsert )
		{
		Assert( fVersion );
		prceInsert->ChangeOper( operInsert );
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prceInsert, NULL );
		}
#ifdef DEBUG
	else
		{
		Assert( !fVersion );
		}
#endif	//	DEBUG

	return err;

HandleError:
	Assert( err < 0 );
	if( prceNil != prceInsert )
		{
		Assert( fVersion );
		VERNullifyFailedDMLRCE( prceInsert );
		}
#ifdef DEBUG
	else
		{
		Assert( !fVersion );
		}
#endif	//	DEBUG

	BTUp( pfucb );
	return err;
	}


LOCAL ERR ErrBTITryAvailExtMerge( FUCB * const pfucb )
	{
	Assert( FFUCBAvailExt( pfucb ) );

	ERR					err = JET_errSuccess;
	MERGEAVAILEXTTASK	* const ptask = new MERGEAVAILEXTTASK(
												pfucb->u.pfcb->PgnoFDP(),
												pfucb->u.pfcb,
												pfucb->ifmp,
												pfucb->bmCurr );

	if( NULL == ptask )
		{
		CallR ( ErrERRCheck( JET_errOutOfMemory ) );
		}

	if ( PinstFromIfmp( pfucb->ifmp )->m_pver->m_fSyncronousTasks
		|| rgfmp[ pfucb->ifmp ].FDetachingDB() )
		{
		// don't start the task because the task manager is no longer running
		// and we can't run it synchronously because it will deadlock.
		delete ptask;
		return JET_errSuccess;
		}

	err = PinstFromIfmp( pfucb->ifmp )->Taskmgr().ErrTMPost( TASK::DispatchGP, ptask );
	if( err < JET_errSuccess )
		{
		//  The task was not enqueued sucessfully.
		delete ptask;
		}

	return err;
	}

//	flag-deletes a node
//
ERR ErrBTFlagDelete( FUCB *pfucb, DIRFLAG dirflag, RCE *prcePrimary )
	{
	const BOOL		fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
	Assert( !FFUCBSpace( pfucb ) || fDIRNoVersion & dirflag );

	ERR		err;
	LATCH	latch = latchReadNoTouch;

	//	save bookmark
	//
	if ( Pcsr( pfucb )->FLatched() )
		CallR( ErrBTISaveBookmark( pfucb ) );

#ifdef DEBUG
	char rgbKey[ KEY::cbKeyMax ];
	int cbKey;
	char rgbData[ JET_cbPrimaryKeyMost ];
	DATA dataBM;
	dataBM.SetPv( rgbData );

	BOOKMARK *pbmCur = &pfucb->bmCurr;
	pbmCur->key.CopyIntoBuffer( rgbKey, (ULONG)pbmCur->key.Cb() );
	cbKey = pbmCur->key.Cb();
	pbmCur->data.CopyInto( dataBM );
#endif

	PERFIncCounterTable( cBTFlagDelete, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	VERPROXY		verproxy;
	if ( prceNil != prcePrimary )
		{
		verproxy.prcePrimary 	= prcePrimary;
		verproxy.proxy 			= proxyCreateIndex;
		}

	const VERPROXY * const pverproxy = ( prceNil != prcePrimary ) ? &verproxy : NULL;

	RCE * prce = prceNil;
	RCEID rceid = rceidNull;

	if( fVersion )
		{
		VER *pver = PverFromIfmp( pfucb->ifmp );
		Call( pver->ErrVERModify( pfucb, pfucb->bmCurr, operFlagDelete, &prce, pverproxy ) );
		Assert( prceNil != prce );
		rceid = Rceid( prce );
		Assert( rceidNull != rceid );
		}

Start:
	Call( ErrBTIRefresh( pfucb, latch ) );
	AssertNDGet( pfucb );

#ifdef DEBUG
	if ( ( latchReadTouch == latch || latchReadNoTouch == latch )
		&& ( latchReadTouch == Pcsr( pfucb )->Latch() || latchReadNoTouch == Pcsr( pfucb )->Latch() ) )
		{
		//	fine!
		}
	else if ( latch == Pcsr( pfucb )->Latch() )
		{
		//	fine!
		}
	else
		{
		Assert( latchWrite == Pcsr( pfucb )->Latch() );
		Assert( FFUCBSpace( pfucb ) || pfucb->u.pfcb->FTypeSLVAvail() );
		}

	char rgbKey2[ KEY::cbKeyMax ];
	pbmCur = &pfucb->bmCurr;
	pbmCur->key.CopyIntoBuffer( rgbKey2, (ULONG)pbmCur->key.Cb() );
	Assert( pbmCur->key.Cb() == cbKey );
	Assert( memcmp( rgbKey, rgbKey2, pbmCur->key.Cb() ) == 0 );
	Assert( pbmCur->data.Cb() == dataBM.Cb() );
	Assert( memcmp( pbmCur->data.Pv(), dataBM.Pv(), dataBM.Cb() ) == 0 );
#endif

	if ( latchWrite != Pcsr( pfucb )->Latch() )
		{
		//	upgrade latch
		//
		err = Pcsr( pfucb )->ErrUpgrade();

		if ( err == errBFLatchConflict )
			{
			Assert( !Pcsr( pfucb )->FLatched() );
			latch = latchRIW;
			goto Start;
			}
		Call( err );
		}

	Assert( latchWrite == Pcsr( pfucb )->Latch() );

	Assert( Pcsr( pfucb )->FLatched( ) );
	AssertNDGet( pfucb );

	//  if we are in the space tree and unversioned and we are
	//  not the first node in the page expunge the node
	//  UNDONE: if we do a BTPrev we will end up on the wrong node
	if ( dirflag & fDIRNoVersion
		 && Pcsr( pfucb )->Cpage().FSpaceTree() )
		{
		Assert( FFUCBSpace( pfucb ) );
		if ( 0 != Pcsr( pfucb )->ILine() )
			{
			Assert( !FNDVersion( pfucb->kdfCurr ) );
			Assert( prceNil == prcePrimary );
			Call( ErrNDDelete( pfucb, dirflag ) );

			Assert( Pcsr( pfucb )->ILine() > 0 );
			Pcsr( pfucb )->DecrementILine();	//  correct the currency for a BTNext
			NDGet( pfucb );
			}
		else
			{
			Call( ErrNDFlagDelete( pfucb, dirflag, rceid, pverproxy ) );
			}

		if ( FFUCBAvailExt( pfucb )
			&& pgnoNull != Pcsr( pfucb )->Cpage().PgnoNext()
			&& Pcsr( pfucb )->Cpage().Clines() < 32
			&& dbidTemp != rgfmp[pfucb->ifmp].Dbid()
			&& !fGlobalRepair 
			&& !( dirflag & fDIRNoLog ))
			{
			Call( ErrBTITryAvailExtMerge( pfucb ) );
			}
		}
	else
		{
		Call( ErrNDFlagDelete( pfucb, dirflag, rceid, pverproxy ) );
		}

	if( prceNil != prce )
		{
		Assert( rceidNull != rceid );
		Assert( fVersion );
		Assert( Pcsr( pfucb )->FLatched() );
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prce, pverproxy );
		}
#ifdef DEBUG
	else
		{
		Assert( !fVersion );
		}
#endif	//	DEBUG

	return err;

HandleError:
	//  the page may or may not be latched
	//  it won't be latched if RCE creation failed

	Assert( err < 0 );
	if( prceNil != prce )
		{
		Assert( fVersion );
		VERNullifyFailedDMLRCE( prce );
		}

	CallS( ErrBTRelease( pfucb ) );
	return err;
	}



//  ================================================================
ERR ErrBTCopyTree( FUCB * pfucbSrc, FUCB * pfucbDest, DIRFLAG dirflag )
//  ================================================================
//
//  Used by repair. Copy all records in one tree to another tree.
//
	{
	ERR err;

	FUCBSetPrereadForward( pfucbSrc, cpgPrereadSequential );

	VOID * pvWorkBuf;
	BFAlloc( &pvWorkBuf );

	DIB dib;
	dib.pos 	= posFirst;
	dib.pbm 	= NULL;
	dib.dirflag = fDIRNull;
	err = ErrBTDown( pfucbSrc, &dib, latchReadTouch );

	//	check for RecordNotFound, let the loop
	//	handle all other errors
	//
	Assert( JET_errNoCurrentRecord != err );
	if ( JET_errRecordNotFound == err )
		{
		err = JET_errSuccess;
		goto HandleError;
		}

	do
		{
		KEY key;
		DATA data;

		Call( err );

		key.Nullify();
		data.Nullify();

		BYTE * pb = (BYTE *)pvWorkBuf;
		pfucbSrc->kdfCurr.key.CopyIntoBuffer( pb );
		key.suffix.SetPv( pb );
		key.suffix.SetCb( pfucbSrc->kdfCurr.key.Cb() );
		pb += pfucbSrc->kdfCurr.key.Cb();

		UtilMemCpy( pb, pfucbSrc->kdfCurr.data.Pv(), pfucbSrc->kdfCurr.data.Cb() );
		data.SetPv( pb );
		data.SetCb( pfucbSrc->kdfCurr.data.Cb() );

		Call( ErrBTRelease( pfucbSrc ) );
		Call( ErrBTInsert( pfucbDest, key, data, dirflag, NULL ) );
		BTUp( pfucbDest );

		err = ErrBTNext( pfucbSrc, fDIRNull );
		}
	while( JET_errNoCurrentRecord != err );

	err = JET_errSuccess;

HandleError:
	BTUp( pfucbSrc );
	BTUp( pfucbDest );
	BFFree( pvWorkBuf );
	return err;
	}


//	******************************************************
//	STATISTICAL OPERATIONS
//

//	computes statistics on a given tree
//		calculates number of nodes, keys and leaf pages
//		in tree
ERR ErrBTComputeStats( FUCB *pfucb, INT *pcnode, INT *pckey, INT *pcpage )
	{
	ERR		err;
	DIB		dib;
	PGNO	pgnoT;
	INT		cnode = 0;
	INT		ckey = 0;
	INT		cpage = 0;

	const INST * const	pinst	= PinstFromPfucb( pfucb );

	Assert( !Pcsr( pfucb )->FLatched() );

	//	go to first node, this is one-time deal. No need to change buffer touch,
	//	set read latch as a ReadAgain latch.
	//
	FUCBSetPrereadForward( pfucb, cpgPrereadSequential );
	dib.dirflag = fDIRNull;
	dib.pos		= posFirst;
	err = ErrBTDown( pfucb, &dib, latchReadNoTouch );
	if ( err < 0 )
		{
		//	if index empty then set err to success
		//
		if ( err == JET_errRecordNotFound )
			{
			err = JET_errSuccess;
			goto Done;
			}
		goto HandleError;
		}

	Assert( Pcsr( pfucb )->FLatched() );

	//	if there is at least one node, then there is a first page.
	//
	cpage = 1;

	if ( FFUCBUnique( pfucb ) )
		{
		forever
			{
			cnode++;

			//	this loop can take some time, so see if we need
			//	to terminate because of shutdown
			//
			Call( pinst->ErrCheckForTermination() );

			//	move to next node
			//
			pgnoT = Pcsr( pfucb )->Pgno();
			err = ErrBTNext( pfucb, fDIRNull );
			if ( err < JET_errSuccess )
				{
				ckey = cnode;
				goto Done;
				}

			if ( Pcsr( pfucb )->Pgno() != pgnoT )
				{
				//	increment page count, if page boundary is crossed
				//
				cpage++;
				}
			}
		}
	else
		{
		BYTE	rgbKey[ JET_cbSecondaryKeyMost ];
		KEY		key;

		Assert( dib.dirflag == fDIRNull );
		key.Nullify();
		key.suffix.SetPv( rgbKey );

		Assert( pfucb->u.pfcb->FTypeSecondaryIndex() );
		Assert( pidbNil != pfucb->u.pfcb->Pidb() );
		Assert( !pfucb->u.pfcb->Pidb()->FUnique() );

		//	initialize key count to 1, to represent the
		//	node we're currently on
		ckey = 1;

		forever
			{
			//	copy key of current node
			//
			Assert( pfucb->kdfCurr.key.Cb() <= JET_cbSecondaryKeyMost );
			key.suffix.SetCb( pfucb->kdfCurr.key.Cb() );
			pfucb->kdfCurr.key.CopyIntoBuffer( key.suffix.Pv() );

			cnode++;

			//	this loop can take some time, so see if we need
			//	to terminate because of shutdown
			//
			Call( pinst->ErrCheckForTermination() );

			//	move to next node
			//
			pgnoT = Pcsr( pfucb )->Pgno();
			err = ErrBTNext( pfucb, fDIRNull );
			if ( err < JET_errSuccess )
				{
				goto Done;
				}

			if ( Pcsr( pfucb )->Pgno() != pgnoT )
				{
				//	increment page count, if page boundary is crossed
				//
				cpage++;
				}

			if ( !FKeysEqual( pfucb->kdfCurr.key, key ) )
				{
				//	increment key count, if key boundary is crossed
				//
				ckey++;
				}
			}
		}


Done:
	//	common exit loop processing
	//
	if ( err < 0 && err != JET_errNoCurrentRecord )
		goto HandleError;

	err		= JET_errSuccess;
	*pcnode = cnode;
	*pckey	= ckey;
	*pcpage = cpage;

HandleError:
	BTUp( pfucb );
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	******************************************************
//	SPECIAL OPERATIONS
//


INLINE ERR ErrBTICreateFCB(
	PIB				*ppib,
	const IFMP		ifmp,
	const PGNO		pgnoFDP,
	const OBJID		objidFDP,
	const OPENTYPE	opentype,
	FUCB			**ppfucb )
	{
	ERR				err;
	FCB				*pfcb		= pfcbNil;
	FUCB			*pfucb		= pfucbNil;

	//	create a new FCB

	CallR( FCB::ErrCreate( ppib, ifmp, pgnoFDP, &pfcb ) );

	//	the creation was successful

	Assert( pfcb->IsLocked() );
	Assert( pfcb->FTypeNull() );				// No fcbtype yet.
	Assert( pfcb->Ifmp() == ifmp );
	Assert( pfcb->PgnoFDP() == pgnoFDP );
	Assert( !pfcb->FInitialized() );
	Assert( pfcb->WRefCount() == 0 );
	pfcb->Unlock();

	Call( ErrFUCBOpen( ppib, ifmp, &pfucb ) );
	pfcb->Link( pfucb );

	Assert( !pfcb->FSpaceInitialized() );
	Assert( openNew != opentype || objidNil == objidFDP );
	if ( openNew != opentype )
		{
		if ( objidNil == objidFDP )
			{
			Assert( openNormal == opentype );

			//	read space info into FCB cache, including objid
			Call( ErrSPInitFCB( pfucb ) );
			Assert( fGlobalRepair || pfcb->FSpaceInitialized() );
			}
		else
			{
			pfcb->SetObjidFDP( objidFDP );
			if ( openNormalNonUnique == opentype )
				{
				pfcb->SetNonUnique();
				}
			else
				{
				Assert( pfcb->FUnique() );			//	btree is initially assumed to be unique
				Assert( openNormalUnique == opentype );
				}
			Assert( !pfcb->FSpaceInitialized() );
			}
		}

	if ( pgnoFDP == pgnoSystemRoot )
		{
		// SPECIAL CASE: For database cursor, we've got all the
		// information we need.

		//	when opening db cursor, always force to check the root page
		Assert( objidNil == objidFDP );
		if ( openNew == opentype )
			{
			//	objid will be set when we return to ErrSPCreate()
			Assert( objidNil == pfcb->ObjidFDP() );
			}
		else
			{
			Assert( objidSystemRoot == pfcb->ObjidFDP() );
			}

		//	insert this FCB into the global list

		pfcb->InsertList();

		//	finish initializing this FCB

		pfcb->Lock();
		Assert( pfcb->FTypeNull() );
		pfcb->SetTypeDatabase();
		pfcb->CreateComplete();
		pfcb->Unlock();
		}

	*ppfucb = pfucb;
	Assert( !Pcsr( pfucb )->FLatched() );

	return err;

HandleError:
	Assert( pfcbNil != pfcb );
	Assert( !pfcb->FInitialized() );
	Assert( !pfcb->FInList() );
	Assert( !pfcb->FInLRU() );
	Assert( ptdbNil == pfcb->Ptdb() );
	Assert( pfcbNil == pfcb->PfcbNextIndex() );
	Assert( pidbNil == pfcb->Pidb() );

	if ( pfucbNil != pfucb )
		{
		Assert( pfcb == pfucb->u.pfcb );
		FCBUnlinkWithoutMoveToAvailList( pfucb );

		//	synchronously purge the FCB
		pfcb->PrepareForPurge( fFalse );
		pfcb->Purge( fFalse );

		//	close the FUCB
		FUCBClose( pfucb );
		}
	else
		{
		//	synchronously purge the FCB
		pfcb->PrepareForPurge( fFalse );
		pfcb->Purge( fFalse );
		}

	return err;
	}


//	*****************************************************
//	BTREE INTERNAL ROUTINES
//

//	opens a cursor on a tree rooted at pgnoFDP
//	open cursor on corresponding FCB if it is in cache [common case]
//	if FCB not in cache, create one, link with cursor
//				and initialize FCB space info
//	if fNew is set, this is a new tree,
//		so do not initialize FCB space info
//
ERR ErrBTIOpen(
	PIB				*ppib,
	const IFMP		ifmp,
	const PGNO		pgnoFDP,
	const OBJID		objidFDP,
	const OPENTYPE	opentype,
	FUCB			**ppfucb )
	{
	ERR				err;
	FCB				*pfcb;
	INT				fState;

RetrieveFCB:

	//	get the FCB for the given ifmp/pgnoFDP

	pfcb = FCB::PfcbFCBGet( ifmp, pgnoFDP, &fState );
	if ( pfcb == pfcbNil )
		{

		//	the FCB does not exist

		Assert( fFCBStateNull == fState );

		//	try to create a new B-tree which will cause the creation of the new FCB

		err = ErrBTICreateFCB( ppib, ifmp, pgnoFDP, objidFDP, opentype, ppfucb );
		Assert( err <= JET_errSuccess );		// Shouldn't return warnings.
		if ( err < 0 )
			{

			//	the B-tree creation failed

			if ( err == errFCBExists )
				{

				//	we failed because someone else was racing to create
				//		the same FCB that we want, but they beat us to it

				//	try to get the FCB again

				goto RetrieveFCB;
				}
			}
		}
	else
		{
		if ( fFCBStateInitialized == fState )
			{
			Assert( pfcb->WRefCount() >= 1);
			err = ErrBTOpen( ppib, pfcb, ppfucb );

			// Cursor has been opened on FCB, so refcount should be
			// at least 2 (one for cursor, one for call to PfcbFCBGet()).
			// (if ErrBTOpen returns w/o error)
			Assert( pfcb->WRefCount() > 1 || (1 == pfcb->WRefCount() && err < JET_errSuccess) );

			pfcb->Release();
			}
		else
			{
			Assert( fFCBStateSentinel == fState );
			Assert( rgfmp[ ifmp ].Dbid() != dbidTemp );		// Sentinels not used by sort/temp. tables.

			// If we encounter a sentinel, it means the
			// table has been locked for subsequent deletion.
			err = ErrERRCheck( JET_errTableLocked );
			}
		}

	return err;
	}


//	*************************************************
//	movement operations
//

//	positions cursor on root page of tree
//	this is root page of data/index for user cursors
//		and root of AvailExt or OwnExt trees for Space cursors
//	page is latched Read or RIW
//
ERR ErrBTIGotoRoot( FUCB *pfucb, LATCH latch )
	{
	ERR		err;

	//	should have no page latched
	//
	Assert( !Pcsr( pfucb )->FLatched() );

	CallR( Pcsr( pfucb )->ErrGetPage( pfucb->ppib,
									  pfucb->ifmp,
									  PgnoRoot( pfucb ),
									  latch,
									  pfucb->u.pfcb->Tableclass(),
									  PBFLatchHintPgnoRoot( pfucb )
									  ) );
	Pcsr( pfucb )->SetILine( 0 );

	return JET_errSuccess;
	}


ERR ErrBTIOpenAndGotoRoot( PIB *ppib, const PGNO pgnoFDP, const IFMP ifmp, FUCB **ppfucb )
	{
	ERR		err;
	FUCB	*pfucb;

	CallR( ErrBTIOpen( ppib, ifmp, pgnoFDP, objidNil, openNormal, &pfucb ) );
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( pfucb->u.pfcb->FInitialized() );

	err = ErrBTIGotoRoot( pfucb, latchRIW );
	if ( err < JET_errSuccess )
		{
		BTClose( pfucb );
		}
	else
		{
		Assert( latchRIW == Pcsr( pfucb )->Latch() );
		Assert( pcsrNil == pfucb->pcsrRoot );
		pfucb->pcsrRoot = Pcsr( pfucb );

		*ppfucb = pfucb;
		}

	return err;
	}


//	this is the uncommon case in the refresh logic
//	where we lost physical currency on page
//
ERR	ErrBTIIRefresh( FUCB *pfucb, LATCH latch )
	{
	ERR		err;

	DBTIME	dbtimeLast = Pcsr( pfucb )->Dbtime();

	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( !pfucb->bmCurr.key.FNull() );
	Assert( latchReadTouch == latch || latchReadNoTouch == latch ||
			latchRIW == latch );

	if ( pgnoNull != Pcsr( pfucb )->Pgno() )
		{
		//	get page latched as per request
		//
		Call( Pcsr( pfucb )->ErrGetPage( pfucb->ppib,
										 pfucb->ifmp,
										 Pcsr( pfucb )->Pgno(),
										 latch,
										 pfucb->u.pfcb->Tableclass() ) );

		//	check if DBTime of page is same as last seen by CSR
		//
		if ( Pcsr( pfucb )->Dbtime() == dbtimeLast )
			{
			//	page is same as last seen by cursor
			//
			Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
			Assert( Pcsr( pfucb )->Cpage().ObjidFDP() == ObjidFDP( pfucb ) );
			NDGet( pfucb );

			AssertNDGet( pfucb );
			return JET_errSuccess;
			}

		Assert( Pcsr( pfucb )->Dbtime() > dbtimeLast );

		//	check if node still belongs to latched page
		//
		Call( ErrBTISeekInPage( pfucb, pfucb->bmCurr ) );

		if ( JET_errSuccess == err )
			{
			goto HandleError;
			}
		else
			{
			//	smart refresh did not work
			//	use bookmark to seek to node
			//
			BTUp( pfucb );

			if ( wrnNDFoundGreater == err || wrnNDFoundLess == err )
				{
				err = ErrERRCheck( JET_errRecordDeleted );
				goto HandleError;
				}
			}

		Assert( wrnNDNotFoundInPage == err );
		}

	//	Although the caller said no need to touch, but the buffer of the bookmark
	//	never touched before, refresh as touch.

	if ( latch == latchReadNoTouch && pfucb->fTouch )
		latch = latchReadTouch;

	Call( ErrBTGotoBookmark( pfucb, pfucb->bmCurr, latch ) );

	pfucb->fTouch = fFalse;

	AssertNDGet( pfucb );

HandleError:
	if ( err >= 0 )
		{
		CallS( err );
		Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
		Assert( Pcsr( pfucb )->Cpage().ObjidFDP() == ObjidFDP( pfucb ) );
		AssertNDGet( pfucb );
		}

	return err;
	}


//	deletes a node and blows it away
//	performs single-page cleanup or multipage cleanup, if possible
//	this is called from VER cleanup or other cleanup threads
//
INLINE ERR ErrBTIDelete( FUCB *pfucb, const BOOKMARK& bm )
	{
	ERR		err;

	ASSERT_VALID( &bm );
	Assert( !Pcsr( pfucb )->FLatched( ) );
	Assert( !FFUCBSpace( pfucb ) );
	Assert( dbidTemp != rgfmp[pfucb->ifmp].Dbid() );

	PERFIncCounterTable( cBTDelete, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	//	try to delete node, if multi-page operation is not needed
	//
	CallR( ErrBTISinglePageCleanup( pfucb, bm ) );
	Assert( !Pcsr( pfucb )->FLatched() );

	if ( wrnBTMultipageOLC == err )
		{
		//	multipage operations are needed to cleanup page
		//
		err = ErrBTIMultipageCleanup( pfucb, bm );
		if ( errBTMergeNotSynchronous == err )
			{
			//	ignore merge conflicts
			err = JET_errSuccess;
			}
		}

	return err;
	}

ERR ErrBTDelete( FUCB *pfucb, const BOOKMARK& bm )
	{
	ERR		err;
	PIB *	ppib	= pfucb->ppib;

	//	UNDONE: is a transaction really needed?  None of the operations
	//	performed by single/multi-page cleanup are versioned, so it's not
	//	for rollback reasons. Probably not visibility either, since I
	//	believe single/multi-page cleanup ignores version bits when
	//	looking at nodes. Are we worried about the visibility of other
	//	transactions? Or maybe are we worried that if we don't begin a
	//	transaction here, version cleanup might interfere?
	//
	//	RESOLVED: The reason we need a transaction is to ensure that
	//	the parent FCB is not purged out from underneath us.
	//	The scenario is:
	//		- DELETERECTASK on LV tree is dispatched
	//		- table is deleted
	//		- version cleanup purges table FCB, then waits for
	//		  all tasks on LV to complete
	//		- DELETERECTASK is executed, space is freed to table
	//		  btree, but FCB for the table has already been purged
	//	If we wrap the DELETERECTASK in a transaction, then check
	//	to make sure that the FCB is not flagged as DeletePending,
	//	we're guaranteed that any btree deletion (eg. table delete)
	//	will not be processed by version cleanup until after this
	//	transaction has committed.
	//
	CallR( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );

	err = ErrBTIDelete( pfucb, bm );

	//	the node may have gotten expunged by someone else or may have
	//	gotten undeleted (because a new node was inserted with the same key)
	//
	switch ( err )
		{
		case JET_errSuccess:
		case JET_errNoCurrentRecord:
		case JET_errRecordNotDeleted:
			break;
		default:
			Call( err );
		}

	//	no versioned updates performed, so just force success
	//
	Assert( prceNil == ppib->prceNewest );
	Call( ErrDIRCommitTransaction( ppib, JET_bitCommitLazyFlush ) );

HandleError:
	if ( err < JET_errSuccess )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	return err;
	}


#ifdef DISABLE_SLV
#else
//  ================================================================
ERR ErrBTMungeSLVSpace( FUCB * const pfucb,
						const SLVSPACEOPER slvspaceoper,
						const LONG ipage,
						const LONG cpages,
						const DIRFLAG dirflag,
						const QWORD fileid,
						const QWORD cbAlloc,
						const wchar_t* const wszFileName )
//  ================================================================
//
//  Transition the given range of pages from one state to another
//  in the SLV space tree. The FUCB be pointing to the write-latched
//  SLVSPACENODE
//
//-
	{
	ASSERT_VALID( pfucb );
	Assert( latchWrite == Pcsr( pfucb )->Latch() );
	Assert( pfucb->kdfCurr.data.Cb() == sizeof( SLVSPACENODE ) );
	Assert( pfucb->kdfCurr.key.Cb() == sizeof( PGNO ) );

	const BOOL fVersion	= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();

	ERR 	err 	= JET_errSuccess;
	RCEID 	rceid 	= rceidNull;
	RCE		*prce	= prceNil;

	//  We'll need the bookmark to create the version
	CallR( ErrBTISaveBookmark( pfucb ) );

	//  Create the version

	if( fVersion )
		{
		VERSLVSPACE	verslvspace;
		verslvspace.oper 	= slvspaceoper;
		verslvspace.ipage	= ipage;
		verslvspace.cpages	= cpages;
		verslvspace.fileid	= fileid;
		verslvspace.cbAlloc	= cbAlloc;

		SIZE_T cbFileName = ( wcslen( wszFileName ) + 1 ) * sizeof( wchar_t );
		UtilMemCpy( verslvspace.wszFileName, wszFileName, cbFileName );

		//  these are only used by rollback
		Assert( slvspaceoperFree != verslvspace.oper );
		Assert( slvspaceoperDeletedToCommitted != verslvspace.oper );
		Assert( slvspaceoperDeletedToFree != verslvspace.oper );
		Assert( slvspaceoperFreeReserved != verslvspace.oper );

		const KEYDATAFLAGS kdfSave = pfucb->kdfCurr;

		pfucb->kdfCurr.data.SetPv( &verslvspace );
		pfucb->kdfCurr.data.SetCb( OffsetOf( VERSLVSPACE, wszFileName ) + cbFileName );

		VER * const pver = PverFromIfmp( pfucb->ifmp );
		err = pver->ErrVERModify( pfucb, pfucb->bmCurr, operSLVSpace, &prce, NULL );

		pfucb->kdfCurr = kdfSave;

		Call( err );

		Assert( prceNil != prce );
		rceid = Rceid( prce );
		Assert( rceidNull != rceid );
		}

	Call( ErrNDMungeSLVSpace(
				pfucb,
				Pcsr( pfucb ),
				slvspaceoper,
				ipage,
				cpages,
				dirflag,
				rceid ) );

	if( prceNil != prce )
		{
		Assert( rceidNull != rceid );
		Assert( fVersion );
		Assert( Pcsr( pfucb )->FLatched() );
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prce, NULL );
		}
#ifdef DEBUG
	else
		{
		Assert( !fVersion );
		}
#endif	//	DEBUG

	Assert( Pcsr( pfucb )->FLatched() );
	Assert( err >= 0 );

	return err;

HandleError:
	Assert( err < 0 );
	Assert( Pcsr( pfucb )->FLatched() );
	if( prceNil != prce )
		{
		Assert( fVersion );
		VERNullifyFailedDMLRCE( prce );
		}

	BTUp( pfucb );
	return err;
	}
#endif	//	DISABLE_SLV


//	returns number of bytes to leave free in page
//	to satisfied density constraint
//
INLINE INT CbBTIFreeDensity( const FUCB *pfucb )
	{
	Assert( pfucb->u.pfcb != pfcbNil );
	return ( (INT) pfucb->u.pfcb->CbDensityFree() );
	}


//	returns required space for inserting a node into given page
//	used by split for estimating cbReq for internal page insertions
//
LOCAL ULONG CbBTICbReq( FUCB *pfucb, CSR *pcsr, const KEYDATAFLAGS& kdf )
	{
	Assert( pcsr->Latch() == latchRIW );
	Assert( !pcsr->Cpage().FLeafPage() );
	Assert( sizeof( PGNO )== kdf.data.Cb() );

	//	temporary kdf to accommodate
	KEYDATAFLAGS	kdfT = kdf;

	//	get prefix from page
	//
	const INT	cbCommon = CbNDCommonPrefix( pfucb, pcsr, kdf.key );

	if ( cbCommon > cbPrefixOverhead )
		{
		kdfT.key.prefix.SetCb( cbCommon );
		#ifdef	DEBUG
		kdfT.key.prefix.SetPv( (VOID *)lBitsAllFlipped );
		#endif
		kdfT.key.suffix.SetCb( kdf.key.Cb() - cbCommon );
		kdfT.fFlags = fNDCompressed;
		}
	else
		{
		kdfT.key.prefix.SetCb( 0 );
		kdfT.key.suffix.SetCb( kdf.key.Cb() );
		}

	const	ULONG	cbReq = CbNDNodeSizeCompressed( kdfT );
	return cbReq;
	}


//	returns cbCommon for given key
//	with respect to prefix in page
//
INT	CbNDCommonPrefix( FUCB *pfucb, CSR *pcsr, const KEY& key )
	{
	Assert( pcsr->FLatched() );

	//	get prefix from page
	//
	NDGetPrefix( pfucb, pcsr );
	Assert( pfucb->kdfCurr.key.suffix.Cb() == 0 );

	const ULONG	cbCommon = CbCommonKey( key, pfucb->kdfCurr.key );

	return cbCommon;
	}


//	computes prefix for a given key with respect to prefix key in page
//	reorganizes key in given kdf to reflect prefix
//
VOID BTIComputePrefix( FUCB 		*pfucb,
					   CSR 			*pcsr,
					   const KEY& 	key,
					   KEYDATAFLAGS	*pkdf )
	{
	Assert( key.prefix.Cb() == 0 );
	Assert( pkdf->key.prefix.FNull() );
	Assert( pcsr->FLatched() );

	INT		cbCommon = CbNDCommonPrefix( pfucb, pcsr, key );

	if ( cbCommon > cbPrefixOverhead )
		{
		//	adjust inserted key to reflect prefix
		//
		pkdf->key.prefix.SetCb( cbCommon );
		pkdf->key.prefix.SetPv( key.suffix.Pv() );
		pkdf->key.suffix.SetCb( key.suffix.Cb() - cbCommon );
		pkdf->key.suffix.SetPv( (BYTE *)key.suffix.Pv() + cbCommon );

		pkdf->fFlags = fNDCompressed;
		}
	else
		{
		}

	return;
	}


//	decides if a particular insert should be treated as an append
//
INLINE BOOL FBTIAppend( const FUCB *pfucb, CSR *pcsr, ULONG cbReq, const BOOL fUpdateUncFree )
	{
	Assert( cbReq <= cbNDPageAvailMost );
	Assert( cbNDPageAvailMost > 0 );
	Assert( pcsr->FLatched() );

	//	adjust cbReq for density constraint
	//
	if ( pcsr->Cpage().FLeafPage()
		&& !pcsr->Cpage().FSpaceTree() )		//	100% density on space trees
		{
		cbReq += CbBTIFreeDensity( pfucb );
		}

	//	last page in tree
	//	inserting past the last node in page
	//	and inserting a node of size cbReq violates density contraint
	//
	return ( pgnoNull == pcsr->Cpage().PgnoNext()
			&& pcsr->ILine() == pcsr->Cpage().Clines()
			&& !FNDFreePageSpace( pfucb, pcsr, cbReq, fUpdateUncFree ) );
	}


INLINE BOOL FBTISplit( const FUCB *pfucb, CSR *pcsr, const ULONG cbReq, const BOOL fUpdateUncFree )
	{
	return !FNDFreePageSpace( pfucb, pcsr, cbReq, fUpdateUncFree );
	}


//	finds max size of node in pfucb->kdfCurr
//	checks version store to find reserved space for
//	uncommitted nodes
//
LOCAL ULONG CbBTIMaxSizeOfNode( const FUCB * const pfucb, const CSR * const pcsr )
	{
	if ( FNDPossiblyVersioned( pfucb, pcsr ) )
		{
		BOOKMARK	bm;
		INT			cbData;

		NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );
		cbData = CbVERGetNodeMax( pfucb, bm );

		if ( cbData >= pfucb->kdfCurr.data.Cb() )
			{
			return CbNDNodeSizeTotal( pfucb->kdfCurr ) - pfucb->kdfCurr.data.Cb() + cbData;
			}
		}

	return CbNDNodeSizeTotal( pfucb->kdfCurr );
	}


//	split page and perform operation
//	update operation to be be performed can be
//		Insert:		node to insert is in kdf
//		Replace:	data to replace with is in kdf
//		FlagInsertAndReplaceData:	node to insert is in kdf
//					[for unique trees that
//					 already have a flag-deleted node
//					 with the same key]
//
//	cursor is placed on node to replace, or insertion point
//
ERR ErrBTISplit( FUCB		 	* const pfucb,
				 KEYDATAFLAGS	* const pkdf,
				 const DIRFLAG	dirflagT,
				 const RCEID	rceid1,
				 const RCEID	rceid2,
				 RCE			* const prceReplace,
				 const INT		cbDataOld,
				 const VERPROXY	* const pverproxy
				 )
	{
	ERR			err;
	BOOL		fOperNone 	= fFalse;
	SPLITPATH	*psplitPath = NULL;
	INST		*pinst = PinstFromIfmp( pfucb->ifmp );

	Assert( rceid2 == Rceid( prceReplace )
			|| rceid1 == Rceid( prceReplace ) );

	//	copy flags into local, since it can be changed by SelectSplitPath
	//
	DIRFLAG		dirflag 	= dirflagT;
	BOOL		fVersion	= !( dirflag & fDIRNoVersion ) && !rgfmp[ pfucb->ifmp ].FVersioningOff();
	const BOOL	fLogging	= !( dirflag & fDIRNoLog ) && rgfmp[pfucb->ifmp].FLogOn();

	ASSERT_VALID( pkdf );

#ifdef DEBUG
	Assert( !fVersion || rceidNull != rceid1 );
	Assert( pfucb->ppib->level > 0 || !fVersion );
	Assert( dirflag & fDIRInsert ||
			dirflag & fDIRReplace ||
			dirflag & fDIRFlagInsertAndReplaceData );
	Assert( !( dirflag & fDIRInsert && dirflag & fDIRReplace ) );
	if ( NULL != pverproxy )
		{
		Assert( !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
		Assert( proxyCreateIndex == pverproxy->proxy );
		}
	Assert( pkdf->key.prefix.FNull() );
#endif	//	DEBUG

	//	seek from root
	//	RIW latching all intermediate pages
	//		and right sibling of leaf page
	//	also retry the operation
	//
	err = ErrBTICreateSplitPathAndRetryOper(
				pfucb,
				pkdf,
				&psplitPath,
				&dirflag,
				rceid1,
				rceid2,
				prceReplace,
				pverproxy );

	if ( JET_errSuccess == err )
		{
		Assert( psplitPath != NULL ) ;
		//	performed operation successfully
		//	set cursor to leaf page,
		//	release splitPath and return
		//
		const INT	ilineT		= psplitPath->csr.ILine();
		*Pcsr( pfucb ) = psplitPath->csr;
		Pcsr( pfucb )->SetILine( ilineT );
		Assert( Pcsr( pfucb )->FLatched() );
		goto HandleError;
		}
	else if ( err != errPMOutOfPageSpace )
		{
		Assert( err < 0 );
		Call( err );
		}

	Assert( psplitPath != NULL ) ;

	//	select split
	//		-- this selects split of parents too
	//
	Call( ErrBTISelectSplit( pfucb, psplitPath, pkdf, dirflag ) );
	BTISplitCheckPath( psplitPath );
	if ( NULL == psplitPath->psplit ||
		 splitoperNone == psplitPath->psplit->splitoper )
		{
		//	save err if operNone
		//
		fOperNone = fTrue;
		}

	//	get new pages
	//
	Call( ErrBTIGetNewPages( pfucb, psplitPath ) );

	//	release latch on unnecessary pages
	//
	BTISplitReleaseUnneededPages( pinst, &psplitPath );
	Assert( psplitPath->psplit != NULL );

	//	write latch remaining pages in order
	//	flag pages dirty and set each with max dbtime of the pages
	//
	Call( ErrBTISplitUpgradeLatches( pfucb->ifmp, psplitPath ) );

	//	The logging code will log the iline currently in the CSR of the
	//	psplitPath. The iline is ignored for recovery, but its nice to
	//	have it set to something sensible for debugging

	psplitPath->csr.SetILine( psplitPath->psplit->ilineOper );

	//	log split -- macro logging for whole split
	//
	if ( fLogging )
		{
		LGPOS	lgpos;

		err = ErrLGSplit( pfucb,
					  psplitPath,
					  *pkdf,
					  rceid1,
					  rceid2,
					  dirflag,
					  &lgpos,
					  pverproxy );

		// on error, return to before dirty dbtime on all pages
		if ( err < JET_errSuccess )
			{
			BTISplitRevertDbtime( psplitPath );
			goto HandleError;
			}

		BTISplitSetLgpos( psplitPath, lgpos );
		}

	//	NOTE: after logging succeeds, nothing should fail...
	//
	if ( prceNil != prceReplace && !fOperNone )
		{
		const INT cbData 	= pkdf->data.Cb();

		//	set uncommitted freed space for shrinking node
		VERSetCbAdjust( Pcsr( pfucb ), prceReplace, cbData, cbDataOld, fDoNotUpdatePage );
		}

	//	perform split
	//	insert parent page pointers
	//	fix sibling page pointers at leaf
	//	move nodes
	//	set dependencies
	//
	BTIPerformSplit( pfucb, psplitPath, pkdf, dirflag );

	BTICheckSplits( pfucb, psplitPath, pkdf, dirflag );

	//	move cursor to leaf page [write-latched]
	//	and iLine to operNode
	//
	BTISplitSetCursor( pfucb, psplitPath );

	//	release all splitPaths
	//
	BTIReleaseSplitPaths( pinst, psplitPath );

	if ( fOperNone )
		{
		Assert( !Pcsr( pfucb )->FLatched() );
		err = ErrERRCheck( errBTOperNone );

		if( prceNil != prceReplace )
			{
			//  UNDONE: we don't have to nullify the RCE here. We could keep it and reuse it. No-one
			//  else can alter the node because we have a version on it.
			Assert( fVersion );
			VERNullifyFailedDMLRCE( prceReplace );
			}
		}
	else
		{
		Assert( Pcsr( pfucb )->FLatched() );
		}

	return err;

HandleError:
	//	release splitPath
	//
	if ( psplitPath != NULL )
		{
		BTIReleaseSplitPaths( pinst, psplitPath );
		}

	return err;
	}


//	creates path of RIW-latched pages from root for split to work on
//	if DBTime or leaf pgno has changed after RIW latching path,
//		retry operation
//
ERR	ErrBTICreateSplitPathAndRetryOper( FUCB 			* const pfucb,
									   const KEYDATAFLAGS * const pkdf,
									   SPLITPATH 		**ppsplitPath,
									   DIRFLAG	* const pdirflag,
									   const RCEID rceid1,
									   const RCEID rceid2,
									   const RCE * const prceReplace,
									   const VERPROXY * const pverproxy )
	{
	ERR			err;
	BOOKMARK	bm;
	PGNO		pgnoSplit = Pcsr( pfucb )->Pgno();
	DBTIME		dbtimeLast = Pcsr( pfucb )->Dbtime();

	Assert( Pcsr( pfucb )->FLatched() );
	Assert( NULL == pfucb->pvRCEBuffer );
	Pcsr( pfucb )->ReleasePage();

	//	initialize bookmark to seek for
	//
	NDGetBookmarkFromKDF( pfucb, *pkdf, &bm );

	if ( *pdirflag & fDIRInsert )
		{
		Assert( bm.key.Cb() == pkdf->key.Cb() );
		//	[ldb 4/30/96]: assert below _may_ go off wrongly. possibly use CmpBm == 0
		Assert( bm.key.suffix.Pv() == pkdf->key.suffix.Pv() );
		Assert( bm.key.prefix.FNull() );
		}
	else if ( *pdirflag & fDIRFlagInsertAndReplaceData )
		{
		Call( ErrBTISaveBookmark( pfucb, bm, fFalse ) );
		}
	else
		{
		//	get key from cursor
		//
		Assert( *pdirflag & fDIRReplace );
		bm.key = pfucb->bmCurr.key;
		}

	Call( ErrBTICreateSplitPath( pfucb, bm, ppsplitPath ) );
	Assert( (*ppsplitPath)->csr.Cpage().FLeafPage() );

	//	set iline to point of insert
	//
	if ( wrnNDFoundLess == err )
		{
		Assert( (*ppsplitPath)->csr.Cpage().Clines() - 1 ==  (*ppsplitPath)->csr.ILine() );
		(*ppsplitPath)->csr.SetILine( (*ppsplitPath)->csr.Cpage().Clines() );
		}

	//	retry operation if timestamp / pgno has changed
	//
	if ( (*ppsplitPath)->csr.Pgno() != pgnoSplit ||
		 (*ppsplitPath)->csr.Dbtime() != dbtimeLast )
		{
		CSR		*pcsr = &(*ppsplitPath)->csr;

		if ( fDIRReplace & *pdirflag )
			{
			//	check if replace fits in page
			//
			AssertNDGet( pfucb, pcsr );
			const INT  cbReq = pfucb->kdfCurr.data.Cb() >= pkdf->data.Cb() ?
								  0 :
								  pkdf->data.Cb() - pfucb->kdfCurr.data.Cb();

			if ( cbReq > 0 && FBTISplit( pfucb, pcsr, cbReq ) )
				{
				err = ErrERRCheck( errPMOutOfPageSpace );
				goto HandleError;
				}

			//	upgrade to write latch
			//
			pcsr->UpgradeFromRIWLatch();
			Assert( latchWrite == pcsr->Latch() );

			//	try to replace node data with new data
			//
			err = ErrNDReplace( pfucb, pcsr, &pkdf->data, *pdirflag, rceid1, prceReplace );
			Assert( errPMOutOfPageSpace != err );
			Call( err );
			}
		else
			{
			ULONG	cbReq;

			Assert( ( fDIRInsert & *pdirflag ) ||
					( fDIRFlagInsertAndReplaceData & *pdirflag ) );

			//	UNDONE: copy code from BTInsert
			//	set *pdirflag
			//
			//	if seek succeeded
			//		if unique
			//			flag insert and replace data
			//		else
			//			flag insert
			//	else
			//		insert whole node
			//
			if ( JET_errSuccess == err )
				{
				//	seek succeeded
				//
				//	can not have two nodes with same bookmark (attempts
				//	to do so should have been caught before split)
				//
#ifdef DEBUG
				FUCBResetUpdatable( pfucb );	//  don't reset the version bit in FNDPotVisibleToCursor
				Assert( FNDDeleted( pfucb->kdfCurr ) );
				Assert( !FNDPotVisibleToCursor( pfucb, pcsr ) );
				FUCBSetUpdatable( pfucb );
#endif	//	DEBUG

				if ( FFUCBUnique( pfucb ) )
					{
					Assert( *pdirflag & fDIRFlagInsertAndReplaceData );

					//	calcualte space requred
					//	if new data fits, flag insert node and replace data
					//
					cbReq = pkdf->data.Cb() > pfucb->kdfCurr.data.Cb() ?
								pkdf->data.Cb() - pfucb->kdfCurr.data.Cb() :
								0;

					if ( FBTISplit( pfucb, pcsr, cbReq ) )
						{
						err = ErrERRCheck( errPMOutOfPageSpace );
						goto HandleError;
						}

					//	upgrade to write latch
					//
					pcsr->UpgradeFromRIWLatch();
					Assert( latchWrite == pcsr->Latch() );

					//	flag insert node and replace data
					//
					Call( ErrNDFlagInsertAndReplaceData( pfucb,
														 pcsr,
														 pkdf,
														 *pdirflag,
														 rceid1,
														 rceid2,
														 prceReplace,
														 pverproxy ) );
					}
				else
					{
					//	should never happen, because:
					//		- if this is an insert, the dupe should
					//		  have been caught by BTInsert() before
					//		  the split
					//		- if this is a flag-insert, it wouldn't
					//		  have caused a split
					//		- FlagInsertAndReplaceData doesn't happen
					//		  on non-unique indexes
					Assert( fFalse );
					Assert( *pdirflag & fDIRInsert );
					Assert( 0 == CmpKeyData( bm, pfucb->kdfCurr ) );

					if ( !FNDDeleted( pfucb->kdfCurr )
						|| FNDPotVisibleToCursor( pfucb, pcsr ) )
						{
						err = ErrERRCheck( JET_errMultiValuedIndexViolation );
						goto HandleError;
						}

					//	upgrade to write latch
					//
					pcsr->UpgradeFromRIWLatch();
					Assert( latchWrite == pcsr->Latch() );

					//	no additional space required
					//
					Assert( fFalse );
					Call( ErrNDFlagInsert( pfucb, pcsr, *pdirflag, rceid1, pverproxy ) );
					}
				}
			else
				{
				//	insert node if it fits
				//
				KEYDATAFLAGS kdfCompressed = *pkdf;

				//  bug #57023, #58638
				//  if we were doing a flag insert and replace data and didn't find the node
				//  then it has been removed. change the operation to an ordinary insert
				*pdirflag &= ~fDIRFlagInsertAndReplaceData;
				*pdirflag |= fDIRInsert;

				BTIComputePrefix( pfucb, pcsr, pkdf->key, &kdfCompressed );
				Assert( !FNDCompressed( kdfCompressed ) ||
						kdfCompressed.key.prefix.Cb() > 0 );

				cbReq = CbNDNodeSizeCompressed( kdfCompressed );

				if ( FBTISplit( pfucb, pcsr, cbReq ) || FBTIAppend( pfucb, pcsr, cbReq ) )
					{
					err = ErrERRCheck( errPMOutOfPageSpace );
					goto HandleError;
					}

				//	upgrade to write latch
				//
				pcsr->UpgradeFromRIWLatch();
				Assert( latchWrite == pcsr->Latch() );

				Call( ErrNDInsert( pfucb, pcsr, &kdfCompressed, *pdirflag, rceid1, pverproxy ) );
				}
			}

		Assert( errPMOutOfPageSpace != err );
		CallS( err );
		}
	else
		{
		err = ErrERRCheck( errPMOutOfPageSpace );
		}

HandleError:
	Assert( errPMOutOfPageSpace != err ||
			latchRIW == (*ppsplitPath)->csr.Latch() );
	return err;
	}


//	creates splitPath of RIW latched pages from root of tree
//	to seeked bookmark
//
LOCAL ERR	ErrBTICreateSplitPath( FUCB 			*pfucb,
								   const BOOKMARK& 	bm,
								   SPLITPATH 		**ppsplitPath )
	{
	ERR		err;
	BOOL	fLeftEdgeOfBtree	= fTrue;
	BOOL	fRightEdgeOfBtree	= fTrue;

	//	create splitPath structure
	//
	CallR( ErrBTINewSplitPath( ppsplitPath ) );
	Assert( NULL != *ppsplitPath );

	//	RIW latch root
	//
	Call( (*ppsplitPath)->csr.ErrGetRIWPage( pfucb->ppib,
											 pfucb->ifmp,
											 PgnoRoot( pfucb ),
											 pfucb->u.pfcb->Tableclass() ) );

	if ( 0 == (*ppsplitPath)->csr.Cpage().Clines() )
		{
		(*ppsplitPath)->csr.SetILine( -1 );
		err = ErrERRCheck( wrnNDFoundLess );
		goto HandleError;
		}

	for ( ; ; )
		{
		Assert( (*ppsplitPath)->csr.Cpage().Clines() > 0 );
		if( fGlobalRepair
			&& FFUCBRepair( pfucb )
			&& bm.key.Cb() == 0 )
			{
			//	when creating a repair tree we want NULL keys to go at the end, not the beginning
			NDMoveLastSon( pfucb, &(*ppsplitPath)->csr );
			err = ErrERRCheck( wrnNDFoundLess );
			}
		else
			{
			Call( ErrNDSeek( pfucb,
						 &(*ppsplitPath)->csr,
						 bm ) );
			}

		Assert( (*ppsplitPath)->csr.ILine() < (*ppsplitPath)->csr.Cpage().Clines() );

		if ( (*ppsplitPath)->csr.Cpage().FLeafPage() )
			{
			const SPLITPATH * const		psplitPathParent		= (*ppsplitPath)->psplitPathParent;

			if ( NULL != psplitPathParent )
				{
				Assert( !( (*ppsplitPath)->csr.Cpage().FRootPage() ) );

				const BOOL				fLeafPageIsFirstPage	= ( pgnoNull == (*ppsplitPath)->csr.Cpage().PgnoPrev() );
				const BOOL				fLeafPageIsLastPage		= ( pgnoNull == (*ppsplitPath)->csr.Cpage().PgnoNext() );

				if ( fLeftEdgeOfBtree ^ fLeafPageIsFirstPage )
					{
					//	if not repair, assert, otherwise, suppress the assert
					//	and repair will just naturally err out
					AssertSz( fGlobalRepair, "Corrupt B-tree: first leaf page has mismatched parent" );
					Call( ErrBTIReportBadPageLink(
								pfucb,
								ErrERRCheck( JET_errBadParentPageLink ),
								psplitPathParent->csr.Pgno(),
								(*ppsplitPath)->csr.Pgno(),
								(*ppsplitPath)->csr.Cpage().PgnoPrev() ) );
					}
				if ( fRightEdgeOfBtree ^ fLeafPageIsLastPage )
					{
					//	if not repair, assert, otherwise, suppress the assert
					//	and repair will just naturally err out
					AssertSz( fGlobalRepair, "Corrupt B-tree: last leaf page has mismatched parent" );
					Call( ErrBTIReportBadPageLink(
								pfucb,
								ErrERRCheck( JET_errBadParentPageLink ),
								psplitPathParent->csr.Pgno(),
								(*ppsplitPath)->csr.Pgno(),
								(*ppsplitPath)->csr.Cpage().PgnoNext() ) );
					}
				}
			else
				{
				Assert( (*ppsplitPath)->csr.Cpage().FRootPage() );
				}

			break;
			}

		Assert( (*ppsplitPath)->csr.Cpage().FInvisibleSons() );
		Assert( !( fRightEdgeOfBtree ^ (*ppsplitPath)->csr.Cpage().FLastNodeHasNullKey() ) );

		fRightEdgeOfBtree = ( fRightEdgeOfBtree
							&& (*ppsplitPath)->csr.ILine() == (*ppsplitPath)->csr.Cpage().Clines() - 1 );
		fLeftEdgeOfBtree = ( fLeftEdgeOfBtree
							&& 0 == (*ppsplitPath)->csr.ILine() );

		//	allocate another splitPath structure for next level
		//
		Call( ErrBTINewSplitPath( ppsplitPath ) );

		//	access child page
		//
		Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
		Call( (*ppsplitPath)->csr.ErrGetRIWPage(
								pfucb->ppib,
								pfucb->ifmp,
								*(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv(),
								pfucb->u.pfcb->Tableclass() ) );
		}

HandleError:
	return err;
	}


//	creates a new SPLITPATH structure and initializes it
//		adds newly created splitPath structure to head of list
//		pointed to by *ppSplitPath passed in
//
ERR	ErrBTINewSplitPath( SPLITPATH **ppsplitPath )
	{
	SPLITPATH	*psplitPath;

	psplitPath = static_cast<SPLITPATH *>( PvOSMemoryHeapAlloc( sizeof(SPLITPATH) ) );
	if ( NULL == psplitPath )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	psplitPath->psplitPathParent	= *ppsplitPath;
	psplitPath->psplitPathChild		= NULL;
	psplitPath->psplit				= NULL;
	psplitPath->dbtimeBefore		= dbtimeInvalid;
	new( &psplitPath->csr ) CSR;

	if ( psplitPath->psplitPathParent != NULL )
		{
		Assert( NULL == psplitPath->psplitPathParent->psplitPathChild );
		psplitPath->psplitPathParent->psplitPathChild = psplitPath;
		}

	*ppsplitPath = psplitPath;
	return JET_errSuccess;
	}


//	selects split at leaf level
//	recursively calls itself to select split at parent level
//		psplitPath is already created and all required pages RIW latched
//
LOCAL ERR ErrBTISelectSplit( FUCB 			*pfucb,
							 SPLITPATH		*psplitPath,
							 KEYDATAFLAGS	*pkdf,
							 DIRFLAG		dirflag )
	{
	ERR		err;

///	Assert( pkdf->key.prefix.cb == 0 );

	//	create and initialize split structure
	//	and link to psplitPath
	//
	CallR( ErrBTINewSplit( pfucb, psplitPath, pkdf, dirflag ) );
	Assert( psplitPath->psplit != NULL );
	Assert( psplitPath->psplit->psplitPath == psplitPath );

	SPLIT	*psplit = psplitPath->psplit;
	BTIRecalcWeightsLE( psplit );

	//	if root page
	//		select vertical split
	//
	if ( psplitPath->csr.Cpage().FRootPage() )
		{
		BTISelectVerticalSplit( psplit, pfucb );

		//	calculate uncommitted freed space
		//
		BTISplitCalcUncFree( psplit );

		Call( ErrBTISplitAllocAndCopyPrefixes( pfucb, psplit ) );
		return JET_errSuccess;
		}

	ULONG	cbReq;
	CSR		*pcsrParent;

	//	horizontal split
	//
	//	check if append
	//
	if	( psplit->splitoper == splitoperInsert &&
		  psplit->ilineOper == psplit->clines - 1 &&
		  psplit->psplitPath->csr.Cpage().PgnoNext() == pgnoNull )
		{
		BTISelectAppend( psplit, pfucb );
		}
	else
		{
		//	find split point such that the
		//	two pages have almost equal weight
		//
		BTISelectRightSplit( psplit, pfucb );
		Assert( psplit->ilineSplit >= 0 );
		}

	//	calculate uncommitted freed space
	//
	BTISplitCalcUncFree( psplit );

	//	copy page flags
	//
	psplit->fNewPageFlags 	=
	psplit->fSplitPageFlags	= psplitPath->csr.Cpage().FFlags();

	//	allocate and copy prefixes
	//
	Call( ErrBTISplitAllocAndCopyPrefixes( pfucb, psplit ) );

	//	compute separator key to insert in parent
	//	allocate space for key and link to psplit
	//
	Call( ErrBTISplitComputeSeparatorKey( psplit, pfucb ) );
	Assert( sizeof( PGNO ) == psplit->kdfParent.data.Cb() );

	//	seek to separator key in parent
	//
	BTISeekSeparatorKey( psplit, pfucb );

	//	if insert in parent causes split
	//	call BTSelectSplit recursively
	//
	pcsrParent = &psplit->psplitPath->psplitPathParent->csr;
	cbReq = CbBTICbReq( pfucb, pcsrParent, psplit->kdfParent );

	if ( FBTISplit( pfucb, pcsrParent, cbReq ) )
		{
		Call( ErrBTISelectSplit( pfucb,
								 psplitPath->psplitPathParent,
								 &psplit->kdfParent,
								 dirflag ) );

		if ( NULL == psplitPath->psplitPathParent->psplit ||
			 splitoperNone == psplitPath->psplitPathParent->psplit->splitoper )
			{
			//	somewhere up the tree, split could not bepsplit->kdfParent performed
			//	along with the operation [insert]
			//	so reset psplit at this level
			//
			BTIReleaseSplit( PinstFromIfmp( pfucb->ifmp ), psplit );
			psplitPath->psplit = NULL;
			return err;
			}
		}

	Assert( psplit->ilineSplit < psplit->clines );
	Assert( splittypeAppend == psplit->splittype ||
			FBTISplitCausesNoOverflow( psplit, psplit->ilineSplit ) );
	Assert( psplitPath->psplit != NULL );
	Assert( psplitPath->psplitPathParent != NULL );

HandleError:
	return err;
	}


//	allocates a new SPLIT structure
//	initalizes psplit and links it to psplitPath
//
ERR	ErrBTINewSplit(
	FUCB *			pfucb,
	SPLITPATH *		psplitPath,
	KEYDATAFLAGS *	pkdf,
	DIRFLAG			dirflag )
	{
	ERR				err;
	SPLIT *			psplit;
	INT				iLineTo;
	INT				iLineFrom;
	BOOL			fPossibleHotpoint		= fFalse;
	VOID *			pvHighest				= NULL;

	Assert( psplitPath != NULL );
	Assert( psplitPath->psplit == NULL );

	//	allocate split structure
	//
	psplit = static_cast<SPLIT *>( PvOSMemoryHeapAlloc( sizeof(SPLIT) ) );
	if ( psplit == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	memset( (BYTE *)psplit, 0, sizeof(SPLIT) );
	new( &psplit->csrRight ) CSR;
	new( &psplit->csrNew ) CSR;

	psplit->dbtimeRightBefore = dbtimeInvalid;

	psplit->prefixinfoSplit.Nullify();
	psplit->prefixinfoNew.Nullify();

	psplit->pgnoSplit = psplitPath->csr.Pgno();

	//	initialize split structure
	//	and link to psplitPath
	//
	if ( psplitPath->csr.Cpage().FLeafPage( ) &&
		 pgnoNull != psplitPath->csr.Cpage().PgnoNext() )
		{
		//	set right page
		//
		Assert( !psplitPath->csr.Cpage().FRootPage( ) );
		Call( psplit->csrRight.ErrGetRIWPage(
										pfucb->ppib,
										pfucb->ifmp,
										psplitPath->csr.Cpage().PgnoNext( ),
										pfucb->u.pfcb->Tableclass() ) );

		const BOOL	fBadSiblingPointer	= ( psplit->csrRight.Cpage().PgnoPrev() != psplit->pgnoSplit );
		if( fBadSiblingPointer
			|| psplit->csrRight.Cpage().ObjidFDP() != pfucb->u.pfcb->ObjidFDP() )
			{
			const PGNO	pgnoBadLink		= ( fBadSiblingPointer ?
													psplit->csrRight.Cpage().PgnoPrev() :
													psplit->csrRight.Cpage().ObjidFDP() );

			//	if not repair, assert, otherwise, suppress the assert and
			//	repair will just naturally err out
			AssertSz( fGlobalRepair, "Corrupt B-tree: bad leaf page links detected on Split" );
			Call( ErrBTIReportBadPageLink(
					pfucb,
					ErrERRCheck( JET_errBadPageLink ),
					psplit->pgnoSplit,
					psplit->csrRight.Pgno(),
					pgnoBadLink ) );
			}
		}
	else
		{
		Assert( pgnoNull == psplit->csrRight.Pgno() );
		}

	psplit->psplitPath = psplitPath;

	//	get operation
	//	this will be corrected later to splitoperNone (for leaf pages only)
	//	if split can not still satisfy space requested for operation
	//
	if ( psplitPath->csr.Cpage().FInvisibleSons( ) )
		{
		//	internal pages have only insert operation
		//
		psplit->splitoper = splitoperInsert;
		}
	else if ( dirflag & fDIRInsert )
		{
		Assert( !( dirflag & fDIRReplace ) );
		Assert( !( dirflag & fDIRFlagInsertAndReplaceData ) );
		psplit->splitoper = splitoperInsert;

		//	must have at least two existing nodes to establish a hotpoint pattern
		fPossibleHotpoint = ( !psplitPath->csr.Cpage().FRootPage()
							&& psplitPath->csr.ILine() >= 2 );
		}
	else if ( dirflag & fDIRReplace )
		{
		Assert( !( dirflag & fDIRFlagInsertAndReplaceData ) );
		psplit->splitoper = splitoperReplace;
		}
	else
		{
		Assert( dirflag & fDIRFlagInsertAndReplaceData );
		psplit->splitoper = splitoperFlagInsertAndReplaceData;
		}

	//	allocate line info
	//
	psplit->clines = psplitPath->csr.Cpage().Clines();

	if ( splitoperInsert == psplit->splitoper )
		{
		//	insert needs one more line for inserted node
		//
		psplit->clines++;
		}

	//  allocate one more entry than we need so that BTISelectPrefix can use a sentinel value
	psplit->rglineinfo = new LINEINFO[psplit->clines + 1];

	if ( NULL == psplit->rglineinfo )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	//	psplitPath->csr is positioned at point of insert/replace
	//
	Assert( splitoperInsert == psplit->splitoper &&
			psplitPath->csr.Cpage().Clines() >= psplitPath->csr.ILine() ||
			psplitPath->csr.Cpage().Clines() > psplitPath->csr.ILine() );

	psplit->ilineOper = psplitPath->csr.ILine();

	for ( iLineFrom = 0, iLineTo = 0; iLineTo < psplit->clines; iLineTo++ )
		{
		if ( psplit->ilineOper == iLineTo &&
			 splitoperInsert == psplit->splitoper )
			{
			//	place to be inserted node here
			//
			psplit->rglineinfo[iLineTo].kdf = *pkdf;
			psplit->rglineinfo[iLineTo].cbSizeMax =
			psplit->rglineinfo[iLineTo].cbSize =
					CbNDNodeSizeTotal( *pkdf );

			if ( fPossibleHotpoint )
				{
				Assert( iLineTo >= 2 );

				//	verify last two nodes before insertion point are
				//	currently last two nodes physically in page
				if ( psplit->rglineinfo[iLineTo-2].kdf.key.suffix.Pv() > pvHighest
					&& psplit->rglineinfo[iLineTo-1].kdf.key.suffix.Pv() > psplit->rglineinfo[iLineTo-2].kdf.key.suffix.Pv() )
					{
					//	need to guarantee that nodes after
					//	the insert point are all physically
					//	located before the nodes in the
					//	the hotpoint area
					pvHighest = psplit->rglineinfo[iLineTo-2].kdf.key.suffix.Pv();
					}
				else
					{
					fPossibleHotpoint = fFalse;
					}
				}

			//	do not increment iLineFrom
			//
			continue;
			}

		//	get node from page
		//
		psplitPath->csr.SetILine( iLineFrom );

		NDGet( pfucb, &psplitPath->csr );

		if ( iLineTo == psplit->ilineOper )
			{
			//	get key from node
			//	and data from parameter
			//
			Assert( splitoperInsert != psplit->splitoper );
			Assert( splitoperNone != psplit->splitoper );

			//	hotpoint is dealt with above
			Assert( !fPossibleHotpoint );

			psplit->rglineinfo[iLineTo].kdf.key		= pfucb->kdfCurr.key;
			psplit->rglineinfo[iLineTo].kdf.data	= pkdf->data;
			psplit->rglineinfo[iLineTo].kdf.fFlags	= pfucb->kdfCurr.fFlags;

			ULONG	cbMax 		= CbBTIMaxSizeOfNode( pfucb, &psplitPath->csr );
			ULONG	cbSize		= CbNDNodeSizeTotal( psplit->rglineinfo[iLineTo].kdf );

			psplit->rglineinfo[iLineTo].cbSizeMax = max( cbSize, cbMax );

			//	there should be no uncommitted version for node
			//
			Assert( cbSize != cbMax || CbNDReservedSizeOfNode( pfucb, &psplitPath->csr ) == 0 );
			}
		else
			{
			psplit->rglineinfo[iLineTo].kdf			= pfucb->kdfCurr;
			psplit->rglineinfo[iLineTo].cbSizeMax	= CbBTIMaxSizeOfNode( pfucb, &psplitPath->csr );

			if ( fPossibleHotpoint )
				{
				if ( iLineTo < psplit->ilineOper - 2 )
					{
					//	for nodes before the hotpoint area, keep track
					//	of highest physical location
					pvHighest = max( pvHighest, pfucb->kdfCurr.key.suffix.Pv() );
					}
				else if ( iLineTo > psplit->ilineOper )
					{
					//	for nodes after insertion point, ensure
					//	all are physically located before nodes in hotpoint area
					fPossibleHotpoint = pfucb->kdfCurr.key.suffix.Pv() < pvHighest;
					}
				}

#ifdef DEBUG
			const ULONG		cbMax 		= CbBTIMaxSizeOfNode( pfucb, &psplitPath->csr );
			const ULONG		cbReserved 	= CbNDReservedSizeOfNode( pfucb, &psplitPath->csr );
			const ULONG		cbSize		= CbNDNodeSizeTotal( pfucb->kdfCurr );

			Assert( cbMax >= cbSize + cbReserved );
#endif
			}

		psplit->rglineinfo[iLineTo].cbSize =
					CbNDNodeSizeTotal( psplit->rglineinfo[iLineTo].kdf );

		Assert( iLineFrom <= iLineTo );
		Assert(	iLineFrom + 1 >= iLineTo );

		iLineFrom++;
		}

	if ( fPossibleHotpoint )
		{
		Assert( psplitPath->csr.Cpage().FLeafPage( ) );
		Assert( splitoperInsert == psplit->splitoper );
		Assert( psplit->ilineOper >= 2 );
		Assert( psplit->clines >= 3 );
		Assert( !psplit->fHotpoint );
		psplit->fHotpoint = fTrue;
		}

	psplitPath->psplit = psplit;
	return JET_errSuccess;

HandleError:
	BTIReleaseSplit( PinstFromIfmp( pfucb->ifmp ), psplit );
	Assert( psplitPath->psplit == NULL );
	return err;
	}


//	calculates
//		size of all nodes to the left of a node
//			using size of nodes already collected
//		maximum size of nodes possible due to rollback
//		size of common key with previous node
//		cbUncFree in the source and dest pages
//			using info collected
//
VOID BTIRecalcWeightsLE( SPLIT *psplit )
	{
	INT		iline;
	Assert( psplit->clines > 0 );

	psplit->rglineinfo[0].cbSizeLE = psplit->rglineinfo[0].cbSize;
	psplit->rglineinfo[0].cbSizeMaxLE = psplit->rglineinfo[0].cbSizeMax;
	psplit->rglineinfo[0].cbCommonPrev = 0;
	psplit->rglineinfo[0].cbPrefix = 0;
	for ( iline = 1; iline < psplit->clines; iline++ )
		{
		Assert( CbNDNodeSizeTotal( psplit->rglineinfo[iline].kdf ) ==
				psplit->rglineinfo[iline].cbSize );

		psplit->rglineinfo[iline].cbSizeLE =
			psplit->rglineinfo[iline-1].cbSizeLE +
			psplit->rglineinfo[iline].cbSize;

		psplit->rglineinfo[iline].cbSizeMaxLE =
			psplit->rglineinfo[iline-1].cbSizeMaxLE +
			psplit->rglineinfo[iline].cbSizeMax;

		const INT	cbCommonKey =
						CbCommonKey( psplit->rglineinfo[iline].kdf.key,
									 psplit->rglineinfo[iline - 1].kdf.key );

		psplit->rglineinfo[iline].cbCommonPrev =
						cbCommonKey > cbPrefixOverhead ?
							cbCommonKey - cbPrefixOverhead :
							0;

		psplit->rglineinfo[0].cbPrefix = 0;
		}

	Assert( iline == psplit->clines );
	}


//	calculates cbUncommitted for split and new pages
//
VOID BTISplitCalcUncFree( SPLIT *psplit )
	{
	Assert( psplit->ilineSplit > 0 ||
			splittypeVertical == psplit->splittype );
	psplit->cbUncFreeDest = SHORT( ( psplit->rglineinfo[psplit->clines - 1].cbSizeMaxLE -
							  psplit->rglineinfo[psplit->clines - 1].cbSizeLE ) -
							( splittypeVertical == psplit->splittype ?
								0 :
								( psplit->rglineinfo[psplit->ilineSplit - 1].cbSizeMaxLE -
								  psplit->rglineinfo[psplit->ilineSplit - 1].cbSizeLE ) ) );

	psplit->cbUncFreeSrc = SHORT( ( splittypeVertical == psplit->splittype ?
								0 :
								( psplit->rglineinfo[psplit->ilineSplit - 1].cbSizeMaxLE -
								  psplit->rglineinfo[psplit->ilineSplit - 1].cbSizeLE ) ) );

	Assert( splittypeAppend != psplit->splittype || 0 == psplit->cbUncFreeDest );
	Assert( psplit->cbUncFreeSrc <= psplit->psplitPath->csr.Cpage().CbUncommittedFree() );

	Assert( psplit->psplitPath->csr.Cpage().FLeafPage() ||
			0 == psplit->cbUncFreeSrc && 0 == psplit->cbUncFreeDest );
	return;
	}

//	selects vertical split
//	if oper can not be performed with split,
//		selects vertical split with operNone
//
VOID BTISelectVerticalSplit( SPLIT *psplit, FUCB *pfucb )
	{
	Assert( psplit->psplitPath->csr.Pgno() == PgnoRoot( pfucb ) );

	psplit->splittype	= splittypeVertical;
	psplit->ilineSplit	= 0;

	//	select prefix
	//
	BTISelectPrefixes( psplit, psplit->ilineSplit );

	//	check if oper fits in new page
	//
	if ( !FBTISplitCausesNoOverflow( psplit, psplit->ilineSplit ) )
		{
		//	split without performing operation
		//
		BTISelectSplitWithOperNone( psplit, pfucb );
		BTISelectPrefixes( psplit, psplit->ilineSplit );
		Assert( FBTISplitCausesNoOverflow( psplit, psplit->ilineSplit ) );
		}
	else
		{
		//	split and oper would both succeed
		//
		Assert( psplit->splitoper != splitoperNone );
		}

	BTISplitSetPrefixes( psplit );
	Assert( FBTISplitCausesNoOverflow( psplit, psplit->ilineSplit ) );

	//	set page flags for split and new pages
	//
	Assert( !psplit->fNewPageFlags );
	Assert( !psplit->fSplitPageFlags );

	psplit->fSplitPageFlags =
	psplit->fNewPageFlags = psplit->psplitPath->csr.Cpage().FFlags();

	psplit->fNewPageFlags &= ~ CPAGE::fPageRoot;
	if ( psplit->psplitPath->csr.Cpage().FLeafPage() && !FFUCBRepair( pfucb ) )
		{
		psplit->fSplitPageFlags = psplit->fSplitPageFlags | CPAGE::fPageParentOfLeaf;
		}
	else
		{
		Assert( !( PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering && FFUCBRepair( pfucb ) ) );
		psplit->fSplitPageFlags &= ~ CPAGE::fPageParentOfLeaf;
		}

	psplit->fSplitPageFlags &= ~ CPAGE::fPageLeaf;
	Assert( FFUCBRepair( pfucb ) || !( psplit->fSplitPageFlags & CPAGE::fPageRepair ) );
	psplit->fSplitPageFlags &= ~ CPAGE::fPageRepair;

	return;
	}


//	selects append split
//	if appended node would not cause an overflow,
//		set prefix in page to inserted key
//
VOID BTISelectAppend( SPLIT *psplit, FUCB *pfucb )
	{
	Assert( psplit->clines - 1 == psplit->ilineOper );
	Assert( splitoperInsert == psplit->splitoper );
	Assert( psplit->psplitPath->csr.Cpage().FLeafPage() );

	psplit->splittype			= splittypeAppend;
	psplit->ilineSplit			= psplit->ilineOper;

	LINEINFO	*plineinfoOper	= &psplit->rglineinfo[psplit->ilineOper];
	if ( CbNDNodeSizeTotal( plineinfoOper->kdf ) + cbPrefixOverhead <= cbNDPageAvailMost &&
		 plineinfoOper->kdf.key.Cb() > cbPrefixOverhead )
		{
		plineinfoOper->cbPrefix = plineinfoOper->kdf.key.Cb();
		psplit->prefixinfoNew.ilinePrefix	= 0;
		psplit->prefixinfoNew.ilineSegBegin = 0;
		psplit->prefixinfoNew.cbSavings		= 0;
		}
	else
		{
		psplit->prefixinfoNew.Nullify();
		plineinfoOper->cbPrefix = 0;
		}

	psplit->prefixinfoSplit.Nullify();
	}


//	selects split point such that
//		node weights are almost equal
//		and split nodes fit in both pages [with optimal prefix key]
//	if no such node exists,
//		select split with operNone
//
VOID BTISelectRightSplit( SPLIT *psplit, FUCB *pfucb )
	{
	INT			iline;
	INT			ilineCandidate;
	PREFIXINFO	prefixinfoSplitCandidate;
	PREFIXINFO	prefixinfoNewCandidate;
	ULONG		cbSizeCandidateLE;
	ULONG		cbSizeTotal;
	BOOL		fAppendLeaf = fFalse;

	psplit->splittype = splittypeRight;

	//	check if internal page
	//		and split at leaf level is append
	//
	if ( !psplit->psplitPath->csr.Cpage().FLeafPage( ) )
		{
		SPLITPATH	*psplitPath = psplit->psplitPath;

		for ( ; psplitPath->psplitPathChild != NULL; psplitPath = psplitPath->psplitPathChild )
			{
			}

		Assert( psplitPath->psplitPathChild == NULL );
		Assert( psplitPath->csr.Cpage().FLeafPage() );
		if ( NULL != psplitPath->psplit &&
			 splittypeAppend == psplitPath->psplit->splittype )
			{
			fAppendLeaf = fTrue;
			}
		}

	if ( psplit->fHotpoint )
		{
		Assert( psplit->psplitPath->csr.Cpage().FLeafPage( ) );
		Assert( splitoperInsert == psplit->splitoper );
		Assert( psplit->ilineOper < psplit->clines );
		Assert( psplit->ilineOper >= 2 );
		Assert( psplit->clines >= 3 );

		ilineCandidate = psplit->ilineOper;
		if ( ilineCandidate < psplit->clines - 1 )
			{
			//	there are nodes after the hotpoint, so what
			//	we do is force a split consisting of just
			//	the nodes beyond the hotpoint, then try
			//	the operation again (the retry will either
			//	result in the new node being inserted as
			//	the last node on the page or it will
			//	result in a hotpoint split)

			BTISelectSplitWithOperNone( psplit, pfucb );
			psplit->fHotpoint = fFalse;
			}
		else
			{
			Assert( ilineCandidate == psplit->clines - 1 );
			}

		psplit->ilineSplit = ilineCandidate;

		//	find optimal prefix key for split page
		BTISelectPrefix(
				psplit->rglineinfo,
				ilineCandidate,
				&psplit->prefixinfoSplit );

		//	find optimal prefix key for new pages
		BTISelectPrefix(
				&psplit->rglineinfo[ilineCandidate],
				psplit->clines - ilineCandidate,
				&psplit->prefixinfoNew );

		Assert( FBTISplitCausesNoOverflow( psplit, ilineCandidate ) );
		BTISplitSetPrefixes( psplit );
		return;
		}

Start:
	ilineCandidate		= 0;
	cbSizeCandidateLE	= 0;
	cbSizeTotal			= psplit->rglineinfo[psplit->clines - 1].cbSizeLE;

	Assert( psplit->clines > 1 );

	//	starting from last node
	//	find candidate split points
	//
	for ( iline = psplit->clines - 1; iline > 0; iline-- )
		{
		//	UNDONE:	optimize prefix selection using a prefix upgrade function
		//
		//	find optimal prefix key for both pages
		//
		BTISelectPrefixes( psplit, iline );

		if ( FBTISplitCausesNoOverflow( psplit, iline ) )
			{
			if ( fAppendLeaf )
				{
				//	if this is an internal page split for an append at leaf
				//		set prefixes and return
				//
				ilineCandidate = iline;
				prefixinfoNewCandidate = psplit->prefixinfoNew;
				prefixinfoSplitCandidate = psplit->prefixinfoSplit;
				break;
				}

			//	if this candidate is closer to cbSizeTotal / 2
			//	than last one, replace candidate
			//
			if ( absdiff( cbSizeCandidateLE, cbSizeTotal / 2 ) >
				 absdiff( psplit->rglineinfo[iline - 1].cbSizeLE, cbSizeTotal / 2 ) )
				{
				ilineCandidate = iline;
				prefixinfoNewCandidate = psplit->prefixinfoNew;
				prefixinfoSplitCandidate = psplit->prefixinfoSplit;
				cbSizeCandidateLE = psplit->rglineinfo[iline - 1].cbSizeLE;
				}
			}
		else
			{
			//	shouldn't get overflow if only two nodes on page (should end up getting
			//	one node on split page and one node on new page), but it appears that
			//	we may have a bug where this is not the case, so put in a firewall
			//	to trap the occurrence and allow us to debug it the next time it is hit.
			Enforce( psplit->clines > 2 );
			}
		}

	if ( ilineCandidate == 0 )
		{
		//	no candidate line fits the bill
		//	need to split without performing operation
		//
		Assert( psplit->psplitPath->csr.Cpage().FLeafPage() );
		Assert( psplit->splitoper != splitoperNone );
		BTISelectSplitWithOperNone( psplit, pfucb );
		goto Start;
		}

	Assert( ilineCandidate != 0 );
	psplit->ilineSplit = ilineCandidate;
///	BTISelectPrefixes( psplit, ilineCandidate );
	psplit->prefixinfoNew = prefixinfoNewCandidate;
	psplit->prefixinfoSplit = prefixinfoSplitCandidate;
	Assert( FBTISplitCausesNoOverflow( psplit, ilineCandidate ) );
	BTISplitSetPrefixes( psplit );
	return;
	}


//	sets up psplit, so split is performed with no
//	user-requested operation
//
VOID BTISelectSplitWithOperNone( SPLIT *psplit, FUCB *pfucb )
	{
	if ( splitoperInsert == psplit->splitoper )
		{
		//	move up all lines beyond ilineOper
		//
		INT		iLine = psplit->ilineOper;

		for ( ; iLine < psplit->clines - 1 ; iLine++ )
			{
			psplit->rglineinfo[iLine] = psplit->rglineinfo[iLine + 1];
			}

		psplit->clines--;
		}
	else
		{
		Assert( psplit->psplitPath->csr.Cpage().FLeafPage( ) );

		//	adjust only rglineinfo[ilineOper]
		//
		//	get kdfCurr for ilineOper
		//
		psplit->psplitPath->csr.SetILine( psplit->ilineOper );
		NDGet( pfucb, &psplit->psplitPath->csr );

		psplit->rglineinfo[psplit->ilineOper].kdf = pfucb->kdfCurr;
		psplit->rglineinfo[psplit->ilineOper].cbSize =
			CbNDNodeSizeTotal( pfucb->kdfCurr );

		ULONG	cbMax 	= CbBTIMaxSizeOfNode( pfucb, &psplit->psplitPath->csr );
		Assert( cbMax >= psplit->rglineinfo[psplit->ilineOper].cbSize );
		psplit->rglineinfo[psplit->ilineOper].cbSizeMax = cbMax;
		}

	//	UNDONE: optimize recalc for only nodes >= ilineOper
	//			optimize recalc for cbCommonPrev separately
	//
	psplit->ilineOper = 0;
	BTIRecalcWeightsLE( psplit );
	psplit->splitoper = splitoperNone;

	psplit->prefixinfoNew.Nullify();
	psplit->prefixinfoSplit.Nullify();
	}


//	checks if splitting psplit->rglineinfo[] at cLineSplit
//		-- i.e., moving nodes cLineSplit and above to new page --
//		would cause an overflow in either page
//
BOOL FBTISplitCausesNoOverflow( SPLIT *psplit, INT ilineSplit )
	{
#ifdef DEBUG
	//	check that prefixes have been calculated correctly
	//
	PREFIXINFO	prefixinfo;

	if ( 0 == ilineSplit )
		{
		//	root page in vertical split has no prefix
		//
		Assert( splittypeVertical == psplit->splittype );
		prefixinfo.Nullify();
		}
	else
		{
		//	select prefix for split page
		//
		BTISelectPrefix( psplit->rglineinfo,
						 ilineSplit,
						 &prefixinfo );
		}

///	Assert( prefixinfo.ilinePrefix 	== psplit->prefixinfoSplit.ilinePrefix );
	Assert( prefixinfo.cbSavings 	== psplit->prefixinfoSplit.cbSavings );
	Assert( prefixinfo.ilineSegBegin
				== psplit->prefixinfoSplit.ilineSegBegin );
	Assert( prefixinfo.ilineSegEnd
				== psplit->prefixinfoSplit.ilineSegEnd );

	//	select prefix for new page
	//
	Assert( psplit->clines > ilineSplit );
	BTISelectPrefix( &psplit->rglineinfo[ilineSplit],
					 psplit->clines - ilineSplit,
					 &prefixinfo );

///	Assert( prefixinfo.ilinePrefix 	== psplit->prefixinfoNew.ilinePrefix );
	Assert( prefixinfo.cbSavings 	== psplit->prefixinfoNew.cbSavings );
	Assert( prefixinfo.ilineSegBegin
				== psplit->prefixinfoNew.ilineSegBegin );
	Assert( prefixinfo.ilineSegEnd
				== psplit->prefixinfoNew.ilineSegEnd );
#endif

	//	ilineSplit == 0 <=> vertical split
	//	where every node is moved to new page
	//
	Assert( splittypeVertical != psplit->splittype || ilineSplit == 0 );
	Assert( splittypeVertical == psplit->splittype || ilineSplit > 0 );
	Assert( ilineSplit < psplit->clines );

	//	all nodes to left of ilineSplit should fit in page
	//	and all nodes >= ilineSplit should fit in page
	//
	const INT	cbSplitPage =
					ilineSplit == 0 ?
						0 :
						( psplit->rglineinfo[ilineSplit - 1].cbSizeMaxLE -
						  psplit->prefixinfoSplit.cbSavings );

	Assert( cbSplitPage >= 0 );
	const BOOL	fSplitPageFits = cbSplitPage <= cbNDPageAvailMostNoInsert;

	const INT	cbNewPage =
					psplit->rglineinfo[psplit->clines - 1].cbSizeMaxLE -
					( ilineSplit == 0 ?
						0 :
		 				psplit->rglineinfo[ilineSplit - 1].cbSizeMaxLE ) -
		 			psplit->prefixinfoNew.cbSavings;

	const BOOL	fNewPageFits = ( ilineSplit == psplit->clines ||
								 cbNewPage <= cbNDPageAvailMostNoInsert );

	return fSplitPageFits && fNewPageFits;
	}


//	allocates space for key in data and copies entire key into data
//
ERR	ErrBTISplitAllocAndCopyPrefix( const KEY &key, DATA *pdata )
	{
	Assert( pdata->Pv() == NULL );
	Assert( !key.FNull() );

	pdata->SetPv( PvOSMemoryHeapAlloc( key.Cb() ) );
	if ( pdata->Pv() == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	pdata->SetCb( key.Cb() );
	key.CopyIntoBuffer( pdata->Pv(), pdata->Cb() );

	return JET_errSuccess;
	}


//	allocate space for new and old prefixes for split page
//	copy prefixes
//
ERR	ErrBTISplitAllocAndCopyPrefixes( FUCB *pfucb, SPLIT *psplit )
	{
	ERR		err = JET_errSuccess;

	Assert( psplit->prefixSplitOld.FNull() );
	Assert( psplit->prefixSplitNew.FNull() );

	NDGetPrefix( pfucb, &psplit->psplitPath->csr );
	if ( !pfucb->kdfCurr.key.prefix.FNull() )
		{
		CallR( ErrBTISplitAllocAndCopyPrefix( pfucb->kdfCurr.key,
											  &psplit->prefixSplitOld ) );
		}

	if ( psplit->prefixinfoSplit.ilinePrefix != ilineInvalid )
		{
		const INT	ilinePrefix = psplit->prefixinfoSplit.ilinePrefix;

		Assert( psplit->splittype != splittypeAppend );
		CallR( ErrBTISplitAllocAndCopyPrefix(
						psplit->rglineinfo[ilinePrefix].kdf.key,
						&psplit->prefixSplitNew ) );
		}

	CallS( err );
	return err;
	}


//	leave psplitPath->psplitPathParent->csr at insert point in parent
//
VOID BTISeekSeparatorKey( SPLIT *psplit, FUCB *pfucb )
	{
	ERR			err;
	CSR			*pcsr = &psplit->psplitPath->psplitPathParent->csr;
	BOOKMARK	bm;


	Assert( !psplit->kdfParent.key.FNull() );
	Assert( sizeof( PGNO ) == psplit->kdfParent.data.Cb() );
	Assert( splittypeVertical != psplit->splittype );
	Assert( pcsr->Cpage().FInvisibleSons() );

	//	seeking in internal page should have NULL data
	//
	bm.key	= psplit->kdfParent.key;
	bm.data.Nullify();
	err = ErrNDSeek( pfucb, pcsr, bm );

	Assert( err == wrnNDFoundGreater );
	Assert( err != JET_errSuccess );
	if ( err == wrnNDFoundLess )
		{
		//	inserted node should never fall after last node in page
		//
		Assert( fFalse );
		Assert( pcsr->Cpage().Clines() - 1 == pcsr->ILine() );
		pcsr->IncrementILine();
		}

	return;
	}


//	allocates and computes separator key between given lines
//
ERR	ErrBTIComputeSeparatorKey( FUCB 				*pfucb,
							   const KEYDATAFLAGS 	&kdfPrev,
							   const KEYDATAFLAGS 	&kdfSplit,
							   KEY					*pkey )
	{
	INT		cbDataCommon	= 0;
	INT		cbKeyCommon		= CbCommonKey( kdfSplit.key, kdfPrev.key );
	BOOL	fKeysEqual		= fFalse;

	if ( cbKeyCommon == kdfSplit.key.Cb() &&
		 cbKeyCommon == kdfPrev.key.Cb() )
		{
		//	split key is the same as the previous one
		//
		Assert( !FFUCBUnique( pfucb ) );
		Assert( FKeysEqual( kdfSplit.key, kdfPrev.key ) );
		Assert( CmpData( kdfSplit.data, kdfPrev.data ) > 0 );

		fKeysEqual = fTrue;
		cbDataCommon = CbCommonData( kdfSplit.data, kdfPrev.data );
		}
	else
		{
		Assert( CmpKey( kdfSplit.key, kdfPrev.key ) > 0 );
		Assert( cbKeyCommon < kdfSplit.key.Cb() );
		}

	//	allocate memory for separator key
	//
	Assert( pkey->FNull() );
	pkey->suffix.SetPv( PvOSMemoryHeapAlloc( cbKeyCommon + cbDataCommon + 1 ) );
	if ( pkey->suffix.Pv() == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	pkey->suffix.SetCb( cbKeyCommon + cbDataCommon + 1 );

	//	copy separator key and data into alocated memory
	//
	Assert( cbKeyCommon <= pkey->Cb() );
	Assert( pkey->suffix.Pv() != NULL );
	kdfSplit.key.CopyIntoBuffer( pkey->suffix.Pv(),
								 cbKeyCommon );

	if ( !fKeysEqual )
		{
		//	copy difference byte from split key
		//
		Assert( 0 == cbDataCommon );
		Assert( kdfSplit.key.Cb() > cbKeyCommon );

		if ( kdfSplit.key.prefix.Cb() > cbKeyCommon )
			{
			//	byte of difference is in prefix
			//
			( (BYTE *)pkey->suffix.Pv() )[cbKeyCommon] =
					( (BYTE *) kdfSplit.key.prefix.Pv() )[cbKeyCommon];
			}
		else
			{
			//	get byte of difference from suffix
			//
			( (BYTE *)pkey->suffix.Pv() )[cbKeyCommon] =
					( (BYTE *) kdfSplit.key.suffix.Pv() )[cbKeyCommon -
											kdfSplit.key.prefix.Cb() ];
			}
		}
	else
		{
		//	copy common data
		//	then copy difference byte from split data
		//
		UtilMemCpy( (BYTE *)pkey->suffix.Pv() + cbKeyCommon,
				kdfSplit.data.Pv(),
				cbDataCommon );

		Assert( kdfSplit.data.Cb() > cbDataCommon );

		( (BYTE *)pkey->suffix.Pv() )[cbKeyCommon + cbDataCommon] =
				( (BYTE *)kdfSplit.data.Pv() )[cbDataCommon];
		}

	return JET_errSuccess;
	}


//	for leaf level,
//	computes shortest separator
//	between the keys of ilineSplit and ilineSplit - 1
//	allocates memory for node to be inserted
//		and the pointer to it in psplit->kdfParent
//	for internal pages, return last kdf in page
//
ERR ErrBTISplitComputeSeparatorKey( SPLIT *psplit, FUCB *pfucb )
	{
	ERR				err;
	KEYDATAFLAGS	*pkdfSplit = &psplit->rglineinfo[psplit->ilineSplit].kdf;
	KEYDATAFLAGS	*pkdfPrev = &psplit->rglineinfo[psplit->ilineSplit - 1].kdf;

	Assert( psplit->kdfParent.key.FNull() );
	Assert( psplit->kdfParent.data.FNull() );
	Assert( psplit->psplitPath->psplitPathParent != NULL );

	//	data of node inserted at parent should point to split page
	//
	psplit->kdfParent.data.SetCb( sizeof( PGNO ) );
	psplit->kdfParent.data.SetPv( &psplit->pgnoSplit );

	if ( psplit->psplitPath->csr.Cpage().FInvisibleSons( ) || FFUCBRepair( pfucb ) )
		{
		//	not leaf page
		//	separator key should be key of ilineSplit - 1
		//
		Assert( !psplit->psplitPath->csr.Cpage().FLeafPage() &&	pkdfSplit->key.FNull()
				|| CmpKey( pkdfPrev->key, pkdfSplit->key )  < 0
				|| fGlobalRepair );

		psplit->kdfParent.key = pkdfPrev->key;
		return JET_errSuccess;
		}

	Assert( psplit->psplitPath->csr.Cpage().FLeafPage() );
	Assert( !psplit->fAllocParent );

	CallR( ErrBTIComputeSeparatorKey( pfucb, *pkdfPrev, *pkdfSplit, &psplit->kdfParent.key ) );
	psplit->fAllocParent = fTrue;

	return err;
	}


//	selects prefix for clines in rglineinfo
//	places result in *pprefixinfo
//
LOCAL VOID BTISelectPrefixCheck( const LINEINFO 	*rglineinfo,
								 INT	 			clines,
								 PREFIXINFO			*pprefixinfo )
	{
#ifdef DEBUG
	pprefixinfo->Nullify();

	Assert( clines > 0 );
	if ( 1 == clines )
		{
		return;
		}

	//	set cbCommonPrev for first line to zero
	//
	const ULONG	cbCommonPrevSav = rglineinfo[0].cbCommonPrev;
	((LINEINFO *)rglineinfo)[0].cbCommonPrev = 0;

	INT			iline;

	//	UNDONE:	optimize loop to use info from previous iteration
	//
	//	calculate prefixinfo for line
	//	if better than previous candidate
	//		choose as new candidate
	//
	for ( iline = 0; iline < clines; iline++ )
		{
		if ( iline != 0 )
			{
			ULONG cbCommonKey = CbCommonKey( rglineinfo[iline].kdf.key,
											 rglineinfo[iline - 1].kdf.key );

			Assert( cbCommonKey <= cbPrefixOverhead &&
						rglineinfo[iline].cbCommonPrev == 0 ||
					cbCommonKey - cbPrefixOverhead ==
						rglineinfo[iline].cbCommonPrev );
			}
		else
			{
			Assert( rglineinfo[iline].cbCommonPrev == 0 );
			}

		INT		ilineSegLeft;
		INT		ilineSegRight;
		INT		cbSavingsLeft = 0;
		INT		cbSavingsRight = 0;
		ULONG	cbCommonMin;

		//	calculate savings for previous lines
		//
		cbCommonMin = rglineinfo[iline].cbCommonPrev;
		for ( ilineSegLeft = iline;
			  ilineSegLeft > 0 && rglineinfo[ilineSegLeft].cbCommonPrev > 0;
			  ilineSegLeft-- )
			{
			Assert( cbCommonMin > 0 );
			if ( cbCommonMin > rglineinfo[ilineSegLeft].cbCommonPrev )
				{
				cbCommonMin = rglineinfo[ilineSegLeft].cbCommonPrev;
				}

			cbSavingsLeft += cbCommonMin;
			}

		//	calculate savings for following lines
		//
		for ( ilineSegRight = iline + 1;
			  ilineSegRight < clines && rglineinfo[ilineSegRight].cbCommonPrev > 0;
			  ilineSegRight++ )
			{
			if ( ilineSegRight == iline + 1 )
				{
				cbCommonMin = rglineinfo[ilineSegRight].cbCommonPrev;
				}
			else if ( cbCommonMin > rglineinfo[ilineSegRight].cbCommonPrev )
				{
				cbCommonMin = rglineinfo[ilineSegRight].cbCommonPrev;
				}
			Assert( cbCommonMin > 0 );
			cbSavingsRight += cbCommonMin;
			}
		ilineSegRight--;

		//	check if savings with iline as prefix
		//		compensate for prefix overhead
		//	 	and are better than previous prefix candidate
		//
		const INT		cbSavings = cbSavingsLeft + cbSavingsRight - cbPrefixOverhead;
		if ( cbSavings > pprefixinfo->cbSavings )
			{
			Assert( cbSavings > 0 );
			pprefixinfo->ilinePrefix 	= iline;
			pprefixinfo->cbSavings 		= cbSavings;
			pprefixinfo->ilineSegBegin	= ilineSegLeft;
			pprefixinfo->ilineSegEnd 	= ilineSegRight;
			}
		}

	//	set cbCommonPrev for first line to original value
	//
	((LINEINFO *)rglineinfo)[0].cbCommonPrev = cbCommonPrevSav;
#endif
	}


//	selects prefix for clines in rglineinfo
//	places result in *pprefixinfo
//
LOCAL VOID BTISelectPrefix( const LINEINFO 	*rglineinfo,
							INT 			clines,
							PREFIXINFO		*pprefixinfo )
	{
	pprefixinfo->Nullify();

	Assert( clines > 0 );
	if ( 1 == clines )
		{
		return;
		}

	if ( 2 == clines )
		{
		INT		cbSavings = rglineinfo[1].cbCommonPrev - cbPrefixOverhead;
		if ( cbSavings > 0 )
			{
			pprefixinfo->ilinePrefix 	= 1;
			pprefixinfo->cbSavings 		= cbSavings;
			pprefixinfo->ilineSegBegin	= 0;
			pprefixinfo->ilineSegEnd 	= 1;
			}

		return;
		}

	//	set cbCommonPrev for first and last line to zero
	//  we exploit this to remove an extra check in the calculation loops
	//  WARNING:  the rglineinfo array must be allocated one entry too large!
	//
	const ULONG	cbCommonPrevFirstSav = rglineinfo[0].cbCommonPrev;
	const ULONG	cbCommonPrevLastSav	 = rglineinfo[clines].cbCommonPrev;
	((LINEINFO *)rglineinfo)[0].cbCommonPrev = 0;
	((LINEINFO *)rglineinfo)[clines].cbCommonPrev = 0;

	INT			iline;

	//	UNDONE:	optimize loop to use info from previous iteration
	//
	//	calculate prefixinfo for line
	//	if better than previous candidate
	//		choose as new candidate
	//
	for ( iline = 1; iline < clines - 1; iline++ )
		{
#ifdef DEBUG
		if ( iline != 0 )
			{
			ULONG cbCommonKey = CbCommonKey( rglineinfo[iline].kdf.key,
											 rglineinfo[iline - 1].kdf.key );

			Assert( cbCommonKey <= cbPrefixOverhead &&
						rglineinfo[iline].cbCommonPrev == 0 ||
					cbCommonKey - cbPrefixOverhead ==
						rglineinfo[iline].cbCommonPrev );
			}
		else
			{
			Assert( rglineinfo[iline].cbCommonPrev == 0 );
			}
#endif

		if ( iline != 1 &&
			 iline != clines - 2 &&
			 rglineinfo[iline + 1].cbCommonPrev >= rglineinfo[iline].cbCommonPrev )
			{
			//	next line would be at least as good a prefix as this one
			//
			continue;
			}

		INT		ilineSegLeft;
		INT		ilineSegRight;
		INT		cbSavingsLeft = 0;
		INT		cbSavingsRight = 0;
		ULONG	cbCommonMin;

		//	calculate savings for previous lines
		//
		cbCommonMin = rglineinfo[iline].cbCommonPrev;
		for ( ilineSegLeft = iline;
			  rglineinfo[ilineSegLeft].cbCommonPrev > 0; //  rglineinfo[0].cbCommonPrev == 0
			  ilineSegLeft-- )
			{
			Assert( ilineSegLeft > 0 );
			Assert( cbCommonMin > 0 );
			if ( cbCommonMin > rglineinfo[ilineSegLeft].cbCommonPrev )
				{
				cbCommonMin = rglineinfo[ilineSegLeft].cbCommonPrev;
				}

			cbSavingsLeft += cbCommonMin;
			}

		//	calculate savings for following lines
		//
		cbCommonMin = rglineinfo[iline+1].cbCommonPrev;
		for ( ilineSegRight = iline + 1;
			  rglineinfo[ilineSegRight].cbCommonPrev > 0; //  rglineinfo[clines].cbCommonPrev == 0
			  ilineSegRight++ )
			{
			Assert( ilineSegRight < clines );
			if ( cbCommonMin > rglineinfo[ilineSegRight].cbCommonPrev )
				{
				cbCommonMin = rglineinfo[ilineSegRight].cbCommonPrev;
				}
			Assert( cbCommonMin > 0 );
			cbSavingsRight += cbCommonMin;
			}
		ilineSegRight--;

		//	check if savings with iline as prefix
		//		compensate for prefix overhead
		//	 	and are better than previous prefix candidate
		//
		const INT		cbSavings = cbSavingsLeft + cbSavingsRight - cbPrefixOverhead;
		if ( cbSavings > pprefixinfo->cbSavings )
			{
			Assert( cbSavings > 0 );
			pprefixinfo->ilinePrefix 	= iline;
			pprefixinfo->cbSavings 		= cbSavings;
			pprefixinfo->ilineSegBegin	= ilineSegLeft;
			pprefixinfo->ilineSegEnd 	= ilineSegRight;
			}
		}

	//	set cbCommonPrev for first line to original value
	//
	((LINEINFO *)rglineinfo)[0].cbCommonPrev = cbCommonPrevFirstSav;
	((LINEINFO *)rglineinfo)[clines].cbCommonPrev = cbCommonPrevLastSav;

	#ifdef DEBUG
	PREFIXINFO	prefixinfoT;
	BTISelectPrefixCheck( rglineinfo, clines, &prefixinfoT );
//	Assert( prefixinfoT.ilinePrefix == pprefixinfo->ilinePrefix );
	Assert( prefixinfoT.cbSavings == pprefixinfo->cbSavings );
	Assert( prefixinfoT.ilineSegBegin == pprefixinfo->ilineSegBegin );
	Assert( prefixinfoT.ilineSegEnd == pprefixinfo->ilineSegEnd );
	#endif
	}


//	remove last line and re-calculate prefix
//
LOCAL VOID BTISelectPrefixDecrement( const LINEINFO *rglineinfo,
									 INT 			clines,
									 PREFIXINFO		*pprefixinfo )
	{
	Assert( pprefixinfo->ilinePrefix <= clines );
	Assert( pprefixinfo->ilineSegBegin <= clines );
	Assert( pprefixinfo->ilineSegEnd <= clines );
	Assert( pprefixinfo->ilineSegBegin <= pprefixinfo->ilineSegEnd );

	if ( pprefixinfo->ilineSegEnd == clines )
		{
		//	removed line contributed to prefix
		//
		Assert( !pprefixinfo->FNull() );
		BTISelectPrefix( rglineinfo, clines, pprefixinfo );
		}
	else
		{
		//	no need to change prefix
		//
///		Assert( fFalse );
		}

	return;
	}


//	add line at beginning and re-calculate prefix
//
LOCAL VOID BTISelectPrefixIncrement( const LINEINFO *rglineinfo,
									 INT 			clines,
									 PREFIXINFO		*pprefixinfo )
	{
	Assert( pprefixinfo->ilinePrefix <= clines - 1 );
	Assert( pprefixinfo->ilineSegBegin <= clines - 1);
	Assert( pprefixinfo->ilineSegEnd <= clines - 1 );
	Assert( pprefixinfo->ilineSegBegin <= pprefixinfo->ilineSegEnd );

	if ( clines > 1 &&
		 rglineinfo[1].cbCommonPrev == 0 )
		{
		//	added line does not contribute to prefix
		//
		if ( !pprefixinfo->FNull() )
			{
			pprefixinfo->ilinePrefix++;
			pprefixinfo->ilineSegBegin++;
			pprefixinfo->ilineSegEnd++;
			}
		}
	else if ( pprefixinfo->FNull() )
		{

		//	look for prefix only in first segment
		//
		INT		iline;
		for ( iline = 1; iline < clines; iline++ )
			{
			if ( rglineinfo[iline].cbCommonPrev == 0 )
				{
				break;
				}
			}

		BTISelectPrefix( rglineinfo, iline, pprefixinfo );
		}
	else
		{
		//	current prefix should be at or before earlier prefix
		//
		Assert( clines > 1 );
		Assert( pprefixinfo->ilineSegEnd + 1 + 1 <= clines );
		BTISelectPrefix( rglineinfo,
						 pprefixinfo->ilineSegEnd + 1 + 1,
						 pprefixinfo );
		}

	return;
	}


//	selects optimal prefix for split page and new page
//	and places result in prefixinfoSplit and prefixinfoNew
//
LOCAL VOID BTISelectPrefixes( SPLIT *psplit, INT ilineSplit )
	{
	if ( 0 == ilineSplit )
		{
		//	root page in vertical split has no prefix
		//
		Assert( splittypeVertical == psplit->splittype );
		Assert( psplit->prefixinfoSplit.FNull() );
		BTISelectPrefix( &psplit->rglineinfo[ilineSplit],
						 psplit->clines - ilineSplit,
						 &psplit->prefixinfoNew );
		}
	else
		{
		Assert( psplit->clines > ilineSplit );

		//	select prefix for split page
		//
		if ( psplit->clines - 1 == ilineSplit )
			{
			Assert( psplit->prefixinfoSplit.FNull() );

			BTISelectPrefix( psplit->rglineinfo,
							 ilineSplit,
							 &psplit->prefixinfoSplit );
			}
		else
			{
			BTISelectPrefixDecrement( psplit->rglineinfo,
							 		  ilineSplit,
									  &psplit->prefixinfoSplit );
			}

		//	select prefix for new page
		//
		BTISelectPrefixIncrement( &psplit->rglineinfo[ilineSplit],
						 		  psplit->clines - ilineSplit,
								  &psplit->prefixinfoNew );
		}
	}


//	sets cbPrefix for clines in rglineinfo
//	based on prefix selected in prefixinfo
//
LOCAL VOID BTISetPrefix( LINEINFO *rglineinfo, INT clines, const PREFIXINFO& prefixinfo )
	{
	Assert( clines > 0 );

	INT			iline;

	//	set all cbPrefix to zero
	//
	for ( iline = 0; iline < clines; iline++ )
		{
		rglineinfo[iline].cbPrefix = 0;

#ifdef DEBUG
		if ( iline != 0 )
			{
			ULONG cbCommonKey = CbCommonKey( rglineinfo[iline].kdf.key,
											 rglineinfo[iline - 1].kdf.key );

			Assert( cbCommonKey <= cbPrefixOverhead &&
						rglineinfo[iline].cbCommonPrev == 0 ||
					cbCommonKey - cbPrefixOverhead ==
						rglineinfo[iline].cbCommonPrev );
			}
#endif
		}

	if ( ilineInvalid == prefixinfo.ilinePrefix )
		{
		return;
		}

	//	set cbPrefix to appropriate value for lines in prefix segment
	//
	const INT	ilineSegLeft 	= prefixinfo.ilineSegBegin;
	const INT	ilineSegRight 	= prefixinfo.ilineSegEnd;
	const INT	ilinePrefix		= prefixinfo.ilinePrefix;
	ULONG		cbCommonMin;

	#ifdef DEBUG
	INT		cbSavingsLeft = 0;
	INT		cbSavingsRight = 0;
	#endif

	Assert( ilineSegLeft != ilineSegRight );

	//	cbPrefix for ilinePrefix
	//
	rglineinfo[ilinePrefix].cbPrefix = rglineinfo[ilinePrefix].kdf.key.Cb();

	//	cbPrefix for previous lines
	//
	cbCommonMin = rglineinfo[ilinePrefix].cbCommonPrev;
	for ( iline = ilinePrefix; iline > ilineSegLeft; iline-- )
		{
		Assert( cbCommonMin > 0 );
		Assert( iline > 0 );
		Assert( rglineinfo[iline].cbCommonPrev > 0 );

		if ( cbCommonMin > rglineinfo[iline].cbCommonPrev )
			{
			cbCommonMin = rglineinfo[iline].cbCommonPrev;
			}

		rglineinfo[iline-1].cbPrefix = cbCommonMin + cbPrefixOverhead;

		#ifdef DEBUG
		cbSavingsLeft += cbCommonMin;
		#endif
		}

	//	calculate savings for following lines
	//
	for ( iline = ilinePrefix + 1; iline <= ilineSegRight; iline++ )
		{
		Assert( iline > 0 );
		if ( iline == ilinePrefix + 1 )
			{
			cbCommonMin = rglineinfo[iline].cbCommonPrev;
			}
		else if ( cbCommonMin > rglineinfo[iline].cbCommonPrev )
			{
			cbCommonMin = rglineinfo[iline].cbCommonPrev;
			}

		rglineinfo[iline].cbPrefix = cbCommonMin + cbPrefixOverhead;

		#ifdef DEBUG
		cbSavingsRight += cbCommonMin;
		#endif
		}

	#ifdef DEBUG
	//	check if savings are same as in prefixinfo
	const INT	cbSavings = cbSavingsLeft + cbSavingsRight - cbPrefixOverhead;

	Assert( cbSavings > 0 );
	Assert( prefixinfo.ilinePrefix == ilinePrefix );
	Assert( prefixinfo.cbSavings == cbSavings );
	#endif
	}

//	sets cbPrefix in all lineinfo to correspond to chosen prefix
//
VOID BTISplitSetPrefixes( SPLIT *psplit )
	{
	const INT	ilineSplit = psplit->ilineSplit;

	if ( 0 == ilineSplit )
		{
		//	root page in vertical split has no prefix
		//
		Assert( splittypeVertical == psplit->splittype );
		Assert( ilineInvalid == psplit->prefixinfoSplit.ilinePrefix );
		}
	else
		{
		//	select prefix for split page
		//
		BTISetPrefix( psplit->rglineinfo,
					  ilineSplit,
					  psplit->prefixinfoSplit );
		}

	//	select prefix for new page
	//
	Assert( psplit->clines > ilineSplit );
	BTISetPrefix( &psplit->rglineinfo[ilineSplit],
				  psplit->clines - ilineSplit,
				  psplit->prefixinfoNew );
	}


//	get new pages for split
//
LOCAL ERR ErrBTIGetNewPages( FUCB *pfucb, SPLITPATH *psplitPathLeaf )
	{
	ERR			err;
	SPLITPATH	*psplitPath;

	//	find pcsrRoot for pfucb
	//
	Assert( pfucb->pcsrRoot == pcsrNil );
	for ( psplitPath = psplitPathLeaf;
		  psplitPath->psplitPathParent != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		//	all logic in for loop
		//
		}
	pfucb->pcsrRoot = &psplitPath->csr;

	//	get a new page for every split
	//
	Assert( psplitPath->psplitPathParent == NULL );
	for ( ; psplitPath != NULL; psplitPath = psplitPath->psplitPathChild )
		{
		if ( psplitPath->psplit != NULL )
			{
			SPLIT *	psplit		= psplitPath->psplit;

			BTICheckSplitFlags( psplit );

			//	pass in split page for getting locality
			//
			Assert( psplit->psplitPath == psplitPath );
			PGNO	pgnoNew		= psplitPath->csr.Pgno();

			Call( ErrSPGetPage( pfucb, &pgnoNew ) );
			psplit->pgnoNew = pgnoNew;

			Call( psplit->csrNew.ErrGetNewPage(
					pfucb->ppib,
					pfucb->ifmp,
					psplit->pgnoNew,
					ObjidFDP( pfucb ),
					psplit->fNewPageFlags,
					pfucb->u.pfcb->Tableclass() ) );

			Assert( latchWrite == psplit->csrNew.Latch() );

			//  if this is not an append split, depend the new page on the split
			//  page so that the data moved from the split page to the new page
			//  will always be available no matter when we crash

			if ( FBTISplitDependencyRequired( psplit ) )
				{
				Call( ErrBFDepend(
							psplit->csrNew.Cpage().PBFLatch(),
							psplitPath->csr.Cpage().PBFLatch() ) );
				}
			}
		}

	pfucb->pcsrRoot = pcsrNil;
	return JET_errSuccess;

HandleError:
	//	release all latched pages
	//	free all allocated pages
	//
	for ( psplitPath = psplitPathLeaf;
		  psplitPath != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		if ( psplitPath->psplit != NULL	&&
			 pgnoNull != psplitPath->psplit->pgnoNew )
			{
			SPLIT	*psplit = psplitPath->psplit;

			if ( psplit->csrNew.Pgno() == psplit->pgnoNew )
				{
				Assert( latchWrite == psplit->csrNew.Latch() );

				psplit->csrNew.ReleasePage();
				psplit->csrNew.Reset();
				}

			//	UNDONE: we will leak the space if ErrSPFreeExt() fails
			//
			const ERR	errFreeExt	= ErrSPFreeExt( pfucb, psplit->pgnoNew, 1 );
#ifdef DEBUG
			if ( !FSPExpectedError( errFreeExt ) )
				{
				CallS( errFreeExt );
				}
#endif

			psplit->pgnoNew = pgnoNull;
			}
		}

	pfucb->pcsrRoot = pcsrNil;
	return err;
	}


//	release latches on pages that are not in the split
//		this might cause psplitPathLeaf to change\
//
LOCAL VOID BTISplitReleaseUnneededPages( INST *pinst, SPLITPATH **ppsplitPathLeaf )
	{
	SPLITPATH 	*psplitPath;
	SPLITPATH 	*psplitPathNewLeaf = NULL;

	//	go to root
	//	since we need to latch bottom-down
	//
	for ( psplitPath = *ppsplitPathLeaf;
		  psplitPath->psplitPathParent != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		}

	for ( ; NULL != psplitPath;  )
		{
		//	check if page is needed
		//		-- either there is a split at this level
		//		   or there is a split one level below
		//			when we need write latch for inserting page pointer
		//
		SPLIT	*psplit = psplitPath->psplit;

		if ( psplit == NULL &&
			 ( psplitPath->psplitPathChild == NULL ||
			   psplitPath->psplitPathChild->psplit == NULL ) )
			{
			//	release latch and psplitPath at this level
			//
			SPLITPATH *psplitPathT = psplitPath;
			psplitPath = psplitPath->psplitPathChild;

			BTIReleaseOneSplitPath( pinst, psplitPathT );
			}
		else
			{
			//	update new leaf
			//
			Assert( NULL == psplitPathNewLeaf ||
					psplitPath == psplitPathNewLeaf->psplitPathChild );

			psplitPathNewLeaf = psplitPath;
			psplitPath = psplitPath->psplitPathChild;
			}
		}
	Assert( psplitPathNewLeaf != NULL );
	Assert( psplitPathNewLeaf->psplit != NULL );

	*ppsplitPathLeaf = psplitPathNewLeaf;

	return;
	}


//	upgrade to write latch on all pages invloved in the split
//	new pages are already latched
//
LOCAL ERR ErrBTISplitUpgradeLatches( const IFMP ifmp, SPLITPATH * const psplitPathLeaf )
	{
	ERR				err;
	SPLITPATH 		* psplitPath;
	const DBTIME	dbtimeSplit		= rgfmp[ifmp].DbtimeIncrementAndGet();

	Assert( dbtimeSplit > 1 );
	Assert( PinstFromIfmp( ifmp )->m_plog->m_fRecoveringMode != fRecoveringRedo
		|| rgfmp[ifmp].FCreatingDB() );			//	may hit this code path during recovery if explicitly redoing CreateDb

	//	go to root
	//	since we need to latch bottom-down
	//
	for ( psplitPath = psplitPathLeaf;
		  psplitPath->psplitPathParent != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		}

	Assert( NULL == psplitPath->psplitPathParent );
	for ( ; NULL != psplitPath;  psplitPath = psplitPath->psplitPathChild )
		{
		//	assert write latch is needed
		//		-- either there is a split at this level
		//		   or there is a split one level below
		//			when we need write latch for inserting page pointer
		//
		SPLIT	*psplit = psplitPath->psplit;

		Assert( psplit != NULL ||
			 	( psplitPath->psplitPathChild != NULL &&
			   	  psplitPath->psplitPathChild->psplit != NULL ) );
		Assert( psplitPath->csr.Latch() == latchWrite ||
				psplitPath->csr.Latch() == latchRIW );
		if ( psplitPath->csr.Latch() != latchWrite )
			 psplitPath->csr.UpgradeFromRIWLatch();


		Assert( psplitPath->csr.Latch() == latchWrite );
		if ( psplitPath->csr.Dbtime() < dbtimeSplit )
			{
			psplitPath->dbtimeBefore = psplitPath->csr.Dbtime();
			psplitPath->csr.CoordinatedDirty( dbtimeSplit );
			}
		else
			{
			FireWall();
			Call( ErrERRCheck( JET_errDbTimeCorrupted ) );
			}

		//	new page will already be write latched
		//	dirty it and update max dbtime
		//
		if ( psplit != NULL )
			{
			Assert( psplit->csrNew.Latch() == latchWrite );
			psplit->csrNew.CoordinatedDirty( dbtimeSplit );
			}

		//	write latch right page at leaf-level
		//
		if ( psplitPath->psplitPathChild == NULL )
			{
			Assert( psplit != NULL );
			Assert( psplitPath->csr.Cpage().FLeafPage()
				|| ( splitoperNone == psplit->splitoper
					&& splittypeVertical == psplit->splittype ) );

			if ( pgnoNull != psplit->csrRight.Pgno() )
				{
				Assert( psplit->splittype != splittypeAppend );
				Assert( psplit->csrRight.Cpage().FLeafPage() );

				psplit->csrRight.UpgradeFromRIWLatch();

				if ( psplit->csrRight.Dbtime() < dbtimeSplit )
					{
					psplit->dbtimeRightBefore = psplit->csrRight.Dbtime() ;
					psplit->csrRight.CoordinatedDirty( dbtimeSplit );
					}
				else
					{
					FireWall();
					Call( ErrERRCheck( JET_errDbTimeCorrupted ) );
					}
				}
			else
				{
				psplit->dbtimeRightBefore = dbtimeNil ;
				}
			}
		}

	return JET_errSuccess;

HandleError:
	Assert( err < 0 );
	BTISplitRevertDbtime( psplitPathLeaf );
	return err;
	}


//	sets dbtime of every (write) latched page to given dbtime
//
VOID BTISplitRevertDbtime( SPLITPATH *psplitPathLeaf )
	{
	SPLITPATH *psplitPath = psplitPathLeaf;

	Assert( NULL == psplitPath->psplitPathChild );

	for ( ; NULL != psplitPath;
			psplitPath = psplitPath->psplitPathParent )
		{
		//	set the dbtime for this page
		//
		Assert( latchWrite == psplitPath->csr.Latch() );

		Assert( dbtimeInvalid != psplitPath->dbtimeBefore && dbtimeNil != psplitPath->dbtimeBefore);
		Assert( psplitPath->dbtimeBefore < psplitPath->csr.Dbtime() );
		psplitPath->csr.RevertDbtime( psplitPath->dbtimeBefore );

		SPLIT	*psplit = psplitPath->psplit;

		//	set dbtime for sibling and new pages
		//
		if ( psplit != NULL && pgnoNull != psplit->csrRight.Pgno() )
			{
			Assert( psplit->splittype != splittypeAppend );
			Assert( psplit->csrRight.Cpage().FLeafPage() );

			Assert( dbtimeInvalid != psplit->dbtimeRightBefore && dbtimeNil != psplit->dbtimeRightBefore);
			Assert( psplit->dbtimeRightBefore < psplit->csrRight.Dbtime() );
			psplit->csrRight.RevertDbtime( psplit->dbtimeRightBefore );
			}
		}
	}


//	sets lgpos for all pages involved in split
//
LOCAL VOID BTISplitSetLgpos( SPLITPATH *psplitPathLeaf, const LGPOS& lgpos )
	{
	SPLITPATH	*psplitPath = psplitPathLeaf;

	for ( ; psplitPath != NULL ; psplitPath = psplitPath->psplitPathParent )
		{
		Assert( psplitPath->csr.FDirty() );

		psplitPath->csr.Cpage().SetLgposModify( lgpos );

		SPLIT	*psplit = psplitPath->psplit;

		if ( psplit != NULL )
			{
			psplit->csrNew.Cpage().SetLgposModify( lgpos );

			if ( psplit->csrRight.Pgno() != pgnoNull )
				{
				Assert( psplit->csrRight.Cpage().FLeafPage() );
				psplit->csrRight.Cpage().SetLgposModify( lgpos );
				}
			}
		}
	}


//	gets node to replace or flagInsertAndReplaceData at leaf level
//
VOID BTISplitGetReplacedNode( FUCB *pfucb, SPLIT *psplit )
	{
	Assert( psplit != NULL );
	Assert( splitoperFlagInsertAndReplaceData == psplit->splitoper ||
			splitoperReplace == psplit->splitoper );

	CSR 	*pcsr = &psplit->psplitPath->csr;
	Assert( pcsr->Cpage().FLeafPage() );
	Assert( pcsr->Cpage().Clines() > psplit->ilineOper );

	pcsr->SetILine( psplit->ilineOper );
	NDGet( pfucb, pcsr );
	}


VOID BTISplitInsertIntoRCELists( FUCB 				*pfucb,
								 SPLITPATH			*psplitPath,
								 const KEYDATAFLAGS	*pkdf,
								 RCE				*prce1,
								 RCE				*prce2,
								 VERPROXY			*pverproxy )
	{
	Assert( splitoperNone != psplitPath->psplit->splitoper );

	SPLIT	*psplit = psplitPath->psplit;
	CSR		*pcsrOper = psplit->ilineOper < psplit->ilineSplit ?
							&psplitPath->csr : &psplit->csrNew;

	if ( splitoperInsert != psplitPath->psplit->splitoper
		&& !PinstFromIfmp( pfucb->ifmp )->FRecovering()
		&& FBTIUpdatablePage( *pcsrOper ) )
		{
		Assert( latchWrite == psplitPath->csr.Latch() );
		Assert( pcsrOper->Cpage().FLeafPage() );
		BTISplitSetCbAdjust( psplitPath->psplit,
							 pfucb,
							 *pkdf,
							 prce1,
							 prce2 );
		}

	VERInsertRCEIntoLists( pfucb, &psplitPath->csr, prce1, pverproxy );
	if ( prceNil != prce2 )
		{
		VERInsertRCEIntoLists( pfucb, &psplitPath->csr, prce2, pverproxy );
		}

	return;
	}


VOID BTISplitSetCbAdjust( SPLIT 				*psplit,
						  FUCB					*pfucb,
						  const KEYDATAFLAGS& 	kdf,
						  const RCE				*prce1,
						  const RCE				*prce2 )
	{
	Assert( NULL != psplit );

	const SPLITOPER splitoper 	= psplit->splitoper;
	const RCE		*prceReplace;

	Assert( splitoperReplace == splitoper ||
			splitoperFlagInsertAndReplaceData == splitoper );

	BTISplitGetReplacedNode( pfucb, psplit );
	const INT	cbDataOld = pfucb->kdfCurr.data.Cb();

	if ( splitoper == splitoperReplace )
		{
		Assert( NULL == prce2 );
		prceReplace = prce1;
		}
	else
		{
		Assert( NULL != prce2 );
		prceReplace = prce2;
		}

	Assert( cbDataOld < kdf.data.Cb() );
	Assert( PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
	VERSetCbAdjust( &psplit->psplitPath->csr,
					prceReplace,
					kdf.data.Cb(),
					cbDataOld,
					fDoNotUpdatePage );
	}


//	sets cursor to point to ilineOper if requested
//	leaf-level operation was performed successfully
//
VOID BTISplitSetCursor( FUCB *pfucb, SPLITPATH *psplitPathLeaf )
	{
	SPLIT	*psplit = psplitPathLeaf->psplit;

	Assert( NULL != psplit );
	Assert( !Pcsr( pfucb )->FLatched() );

	if ( splitoperNone == psplit->splitoper ||
		 !psplit->csrNew.Cpage().FLeafPage() )
		{
		//	split was not performed
		//	set cursor to point to no valid node
		//
		BTUp( pfucb );
		}
	else
		{
		//	set Pcsr( pfucb ) to leaf page with oper
		//	reset CSR copied from to point to no page
		//
		Assert( psplit->csrNew.Cpage().FLeafPage() );
		Assert( splitoperNone != psplitPathLeaf->psplit->splitoper );
		Assert( !Pcsr( pfucb )->FLatched() );

		if ( psplit->ilineOper < psplit->ilineSplit )
			{
			//	ilineOper falls in split page
			//
			*Pcsr( pfucb )			= psplitPathLeaf->csr;
			Pcsr( pfucb )->SetILine( psplit->ilineOper );
			}
		else
			{
			*Pcsr( pfucb )			= psplit->csrNew;
			Pcsr( pfucb )->SetILine( psplit->ilineOper - psplit->ilineSplit );
			}

		Assert( Pcsr( pfucb )->ILine() < Pcsr( pfucb )->Cpage().Clines() );
		NDGet( pfucb );
		}
	}


//	performs split
//	this code shared between do and redo phases
//		insert parent page pointers
//		fix sibling page pointers at leaf
//		move nodes
//		set dependencies
//
VOID BTIPerformSplit( FUCB 			*pfucb,
					  SPLITPATH 	*psplitPathLeaf,
					  KEYDATAFLAGS	*pkdf,
					  DIRFLAG		dirflag )
	{
	SPLITPATH	*psplitPath;

	ASSERT_VALID( pkdf );

	//	go to root
	//	since we need to latch bottom-down
	//
	for ( psplitPath = psplitPathLeaf;
		  psplitPath->psplitPathParent != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		}

	for ( ; psplitPath != NULL; psplitPath = psplitPath->psplitPathChild )
		{
		SPLIT	*psplit = psplitPath->psplit;

		if ( psplit == NULL )
			{
			Assert( psplitPath->psplitPathChild != NULL &&
					psplitPath->psplitPathChild->psplit != NULL );

			//	insert parent page pointer for next level
			//
			BTIInsertPgnoNewAndSetPgnoSplit( pfucb, psplitPath );

			continue;
			}

		KEYDATAFLAGS	*pkdfOper;

		if ( splitoperNone == psplit->splitoper )
			{
			pkdfOper = NULL;
			}
		else if ( psplit->fNewPageFlags & CPAGE::fPageLeaf )
			{
			pkdfOper = pkdf;
			}
		else
			{
			Assert( psplitPath->psplitPathChild != NULL &&
					psplitPath->psplitPathChild->psplit != NULL );
			pkdfOper = &psplitPath->psplitPathChild->psplit->kdfParent;
			}

		if ( psplit->splittype == splittypeVertical )
			{
			PERFIncCounterTable( cBTVerticalSplit, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

			//	move all nodes from root to new page
			//
			BTISplitMoveNodes( pfucb, psplit, pkdfOper, dirflag );

			CSR		*pcsrRoot = &psplit->psplitPath->csr;

			if ( FBTIUpdatablePage( *pcsrRoot ) )
				{
				Assert( latchWrite == pcsrRoot->Latch() );
				Assert( pcsrRoot->Cpage().FRootPage() );

				//	set parent page to non-leaf
				//
				pcsrRoot->Cpage().SetFlags( psplit->fSplitPageFlags );

				//	insert page pointer in root zero-sized key
				//
				Assert( NULL != psplit->psplitPath );
				Assert( 0 == pcsrRoot->Cpage().Clines() );

#ifdef DEBUG
				//	check prefix in root is null
				//
				NDGetPrefix( pfucb, pcsrRoot );
				Assert( pfucb->kdfCurr.key.prefix.FNull() );
#endif

				KEYDATAFLAGS		kdf;
				LittleEndian<PGNO>	le_pgnoNew = psplit->pgnoNew;

				kdf.key.Nullify();
				kdf.fFlags = 0;
				Assert( psplit->csrNew.Pgno() == psplit->pgnoNew );
				kdf.data.SetPv( &le_pgnoNew );
				kdf.data.SetCb( sizeof( PGNO ) );
				NDInsert( pfucb, pcsrRoot, &kdf );
				}

			if ( psplitPath->psplitPathChild != NULL &&
				 psplitPath->psplitPathChild->psplit != NULL )
				{
				//	replace data in ilineOper + 1 with pgnoNew
				//	assert data in ilineOper is pgnoSplit
				//
				BTIInsertPgnoNew( pfucb, psplitPath );
				AssertBTIVerifyPgnoSplit( pfucb, psplitPath );
				}
			}
		else
			{
			PERFIncCounterTable(
				splittypeAppend == psplit->splittype ? cBTAppendSplit : cBTRightSplit,
				PinstFromPfucb( pfucb ),
				pfucb->u.pfcb->Tableclass() );

			Assert( psplit->splittype == splittypeAppend ||
					psplit->splittype == splittypeRight );
			BTISplitMoveNodes( pfucb, psplit, pkdfOper, dirflag );

			if ( psplit->fNewPageFlags & CPAGE::fPageLeaf )
				{
				//	set sibling page pointers
				//
				BTISplitFixSiblings( psplit );
				}
			else
				{
				//	set page pointers
				//
				//	internal pages have no sibling pointers
				//
#ifdef DEBUG
				if ( FBTIUpdatablePage( psplit->csrNew ) )
					{
					Assert( pgnoNull == psplit->csrNew.Cpage().PgnoPrev() );
					Assert( pgnoNull == psplit->csrNew.Cpage().PgnoNext() );
					}
				if ( FBTIUpdatablePage( psplitPath->csr ) )
					{
					Assert( pgnoNull == psplitPath->csr.Cpage().PgnoPrev() );
					Assert( pgnoNull == psplitPath->csr.Cpage().PgnoNext() );
					}
				Assert( pgnoNull == psplit->csrRight.Pgno() );
#endif

				//	replace data in ilineOper + 1 with pgnoNew
				//	assert data in ilineOper is pgnoSplit
				//
				BTIInsertPgnoNew( pfucb, psplitPath );
				AssertBTIVerifyPgnoSplit( pfucb, psplitPath );
				}
			}
		}
	}


//	inserts kdfParent of lower level with pgnoSplit as data
//	replace data of next node with pgnoNew
//
LOCAL VOID BTIInsertPgnoNewAndSetPgnoSplit( FUCB *pfucb, SPLITPATH *psplitPath )
	{
	ERR			err;
	CSR			*pcsr = &psplitPath->csr;
	DATA		data;
	BOOKMARK	bmParent;

	if ( !FBTIUpdatablePage( *pcsr ) )
		{
		//	page does not need redo
		//
		return;
		}
	Assert( latchWrite == pcsr->Latch() );

	Assert( NULL == psplitPath->psplit );
	Assert( !psplitPath->csr.Cpage().FLeafPage() );
	Assert( psplitPath->psplitPathChild != NULL );
	Assert( psplitPath->psplitPathChild->psplit != NULL );

	SPLIT	*psplit = psplitPath->psplitPathChild->psplit;

	Assert( !psplitPath->csr.Cpage().FLeafPage() );
	Assert( sizeof(PGNO) == psplit->kdfParent.data.Cb() );
	Assert( psplit->pgnoSplit ==
			*( reinterpret_cast<UnalignedLittleEndian<PGNO> *>( psplit->kdfParent.data.Pv() ) ) );

	bmParent.key	= psplit->kdfParent.key;
	bmParent.data.Nullify();
	err = ErrNDSeek( pfucb, pcsr, bmParent );
	Assert( err != JET_errSuccess );
	Assert( err != wrnNDFoundLess );
	Assert( err == wrnNDFoundGreater );
	Assert( psplit->pgnoSplit ==
			*( reinterpret_cast<UnalignedLittleEndian< PGNO > *> ( pfucb->kdfCurr.data.Pv() ) ) );
	Assert( pcsr->FDirty() );

	BTIComputePrefixAndInsert( pfucb, pcsr, psplit->kdfParent );

	//	go to next node and update pgno to pgnoNew
	//
	Assert( pcsr->ILine() < pcsr->Cpage().Clines() );
	pcsr->IncrementILine();
#ifdef DEBUG
	//	current page pointer should point to pgnoSplit
	//
	NDGet( pfucb, pcsr );
	Assert( sizeof(PGNO) == pfucb->kdfCurr.data.Cb() );
	Assert( psplit->pgnoSplit ==
			*( reinterpret_cast<UnalignedLittleEndian< PGNO > *>
						( pfucb->kdfCurr.data.Pv() ) ) );
#endif

	LittleEndian<PGNO> le_pgnoNew = psplit->pgnoNew;
	data.SetCb( sizeof( PGNO ) );
	data.SetPv( reinterpret_cast<VOID *> (&le_pgnoNew) );
	NDReplace( pcsr, &data );
	}


//	computes prefix for node with repect to given page
//	inserts with appropriate prefix
//
LOCAL VOID BTIComputePrefixAndInsert( FUCB *pfucb, CSR *pcsr, const KEYDATAFLAGS& kdf )
	{
	Assert( latchWrite == pcsr->Latch() );

	INT		cbCommon = CbNDCommonPrefix( pfucb, pcsr, kdf.key );

	if ( cbCommon <= cbPrefixOverhead )
		{
		cbCommon = 0;
		}

	NDInsert( pfucb, pcsr, &kdf, cbCommon );
	return;
	}


//	replace data in ilineOper + 1 with pgnoNew at lower level
//
LOCAL VOID BTIInsertPgnoNew( FUCB *pfucb, SPLITPATH *psplitPath )
	{
	SPLIT	*psplit = psplitPath->psplit;
	CSR		*pcsr;
	DATA	data;

	Assert( psplit != NULL );
	Assert( splittypeRight == psplit->splittype
		|| ( splittypeVertical == psplit->splittype
				&& psplitPath->psplitPathChild != NULL
				&& psplitPath->psplitPathChild->psplit != NULL ) );
	Assert( psplit->ilineOper < psplit->clines - 1 );
	Assert( psplitPath->psplitPathChild != NULL );
	Assert( psplitPath->psplitPathChild->psplit != NULL );
	Assert( !FBTIUpdatablePage( psplitPath->csr )
		|| !psplitPath->csr.Cpage().FLeafPage() );
	Assert( !FBTIUpdatablePage( psplit->csrNew )
		|| !psplit->csrNew.Cpage().FLeafPage() );

	LittleEndian<PGNO> le_pgnoNew = psplitPath->psplitPathChild->psplit->pgnoNew;
	data.SetCb( sizeof( PGNO ) );
	data.SetPv( reinterpret_cast<BYTE *>(&le_pgnoNew) );

	if ( psplit->ilineOper + 1 >= psplit->ilineSplit )
		{
		//	page pointer to new page falls in new page
		//
		pcsr			= &psplit->csrNew;
		pcsr->SetILine( psplit->ilineOper + 1 - psplit->ilineSplit );
		}
	else
		{
		//	page pointer falls in split page
		//
		Assert( splittypeVertical != psplit->splittype );
		pcsr			= &psplit->psplitPath->csr;
		pcsr->SetILine( psplit->ilineOper + 1 );
		}

	if ( !FBTIUpdatablePage( *pcsr ) )
		{
		//	page does not need redo
		//
		return;
		}
	Assert( latchWrite == pcsr->Latch() );

	//	check that we already dirtied these pages
	//
	Assert( pcsr->FDirty() );

#ifdef DEBUG
	//	current page pointer should point to pgnoSplit
	//
	NDGet( pfucb, pcsr );
	Assert( sizeof(PGNO) == pfucb->kdfCurr.data.Cb() );
	Assert( psplitPath->psplitPathChild->psplit->pgnoSplit ==
			*( reinterpret_cast<UnalignedLittleEndian< PGNO >  *>
					(pfucb->kdfCurr.data.Pv() ) ) );
#endif

	NDReplace( pcsr, &data );
	}


//	fixes sibling pages of split, new and right pages
//
LOCAL VOID BTISplitFixSiblings( SPLIT *psplit )
	{
	SPLITPATH	*psplitPath = psplit->psplitPath;

	//	set sibling page pointers only if page is write-latched
	//
	if ( FBTIUpdatablePage( psplit->csrNew ) )
		{
		psplit->csrNew.Cpage().SetPgnoPrev( psplit->pgnoSplit );
		}

	if ( FBTIUpdatablePage( psplitPath->csr ) )
		{
		psplitPath->csr.Cpage().SetPgnoNext( psplit->pgnoNew );
		}

	if ( pgnoNull != psplit->csrRight.Pgno() )
		{
		Assert( psplit->splittype == splittypeRight );

		if ( FBTIUpdatablePage( psplit->csrRight ) )
			{
			Assert( psplit->csrRight.FDirty() );
			psplit->csrRight.Cpage().SetPgnoPrev( psplit->pgnoNew );
			}

		if ( FBTIUpdatablePage( psplit->csrNew ) )
			{
			psplit->csrNew.Cpage().SetPgnoNext( psplit->csrRight.Pgno() );
			}
		}
	else
		{
		Assert( pgnoNull == psplit->csrNew.Cpage().PgnoNext() ||
				!FBTIUpdatablePage( psplit->csrNew ) );
		}
	return;
	}


//	move nodes from src to dest page
//	set prefix in destination page
//	move nodes >= psplit->ilineSplit
//	if oper is not operNone, perform oper on ilineOper
//	set prefix in src page [in-page]
//	set cbUncommittedFree in src and dest pages
//	move undoInfo of moved nodes to destination page
//
VOID BTISplitMoveNodes( FUCB			*pfucb,
						SPLIT			*psplit,
						KEYDATAFLAGS	*pkdf,
						DIRFLAG			dirflag )
	{
	CSR				*pcsrSrc		= &psplit->psplitPath->csr;
	CSR				*pcsrDest		= &psplit->csrNew;
	INT				cLineInsert 	= psplit->splitoper == splitoperInsert ? 1 : 0;
	const LINEINFO	*plineinfoOper	= &psplit->rglineinfo[psplit->ilineOper];

	Assert( splittypeVertical != psplit->splittype
		|| 0 == psplit->ilineSplit );
	Assert( splittypeVertical == psplit->splittype
		|| 0 < psplit->ilineSplit );
	Assert( !( psplit->fSplitPageFlags & CPAGE::fPageRoot )
		|| splittypeVertical == psplit->splittype );
	Assert( psplit->splitoper != splitoperNone
		|| 0 == psplit->ilineOper );

	Assert( !FBTIUpdatablePage( *pcsrDest ) || pcsrDest->FDirty() );
	Assert( !FBTIUpdatablePage( *pcsrSrc ) || pcsrSrc->FDirty() );

	pcsrDest->SetILine( 0 );
	BTICheckSplitLineinfo( pfucb, psplit, *pkdf );

	//	set prefix in destination page
	//
	if ( psplit->prefixinfoNew.ilinePrefix != ilineInvalid
		&& FBTIUpdatablePage( *pcsrDest ) )
		{
		const INT	ilinePrefix = psplit->prefixinfoNew.ilinePrefix + psplit->ilineSplit;

		Assert( ilinePrefix < psplit->clines );
		Assert( ilinePrefix >= psplit->ilineSplit );

		NDSetPrefix( pcsrDest, psplit->rglineinfo[ilinePrefix].kdf.key );
		}

	//	move every node from Src to Dest
	//
	if ( psplit->splitoper != splitoperNone
		&& psplit->ilineOper >= psplit->ilineSplit )
		{
		//	ilineOper falls in Dest page
		//	copy lines from ilineSplit till ilineOper - 1 from Src to Dest
		//	perform oper
		//	copy remaining lines
		//	delete copied lines from Src
		//
		Assert( 0 == pcsrDest->ILine() );
		BTISplitBulkCopy( pfucb,
						  psplit,
						  psplit->ilineSplit,
						  psplit->ilineOper - psplit->ilineSplit );

		//	insert ilineOper
		//
		pcsrSrc->SetILine( psplit->ilineOper );

		if ( FBTIUpdatablePage( *pcsrDest ) )
			{
			//	if need to redo destination, must need to redo source page as well
			Assert( FBTIUpdatablePage( *pcsrSrc )
				|| !FBTISplitDependencyRequired( psplit ) );
			Assert( psplit->ilineOper - psplit->ilineSplit == pcsrDest->ILine() );
			Assert( psplit->ilineOper - psplit->ilineSplit == pcsrDest->Cpage().Clines() );

			switch( psplit->splitoper )
				{
				case splitoperNone:
					Assert( fFalse );
					break;

				case splitoperInsert:
#ifdef DEBUG
					{
					const INT	cbCommon = CbNDCommonPrefix( pfucb, pcsrDest, pkdf->key );
					if ( cbCommon > cbPrefixOverhead )
						{
						Assert( cbCommon == plineinfoOper->cbPrefix  ) ;
						}
					else
						{
						Assert( 0 == plineinfoOper->cbPrefix );
						}
					}
#endif
					NDInsert( pfucb, pcsrDest, pkdf, plineinfoOper->cbPrefix );
					if ( !( dirflag & fDIRNoVersion ) &&
						 !rgfmp[ pfucb->ifmp ].FVersioningOff() &&
						 ( psplit->fNewPageFlags & CPAGE::fPageLeaf ) )
						{
						//	UNDONE: assert version for this node exists
						//
						CallS( ErrNDFlagVersion( pcsrDest ) );
						}
					else
						{
#ifdef	DEBUG
						NDGet( pfucb, pcsrDest );
						Assert( !FNDVersion( pfucb->kdfCurr ) );
#endif
						}
					break;

				default:
					Assert( psplit->splitoper == splitoperFlagInsertAndReplaceData ||
							psplit->splitoper == splitoperReplace );
					Assert( psplit->ilineOper == pcsrSrc->ILine() );
					Assert( pkdf->data == plineinfoOper->kdf.data );

					NDInsert( pfucb,
							  pcsrDest,
							  &plineinfoOper->kdf,
							  plineinfoOper->cbPrefix );

					if ( splitoperReplace != psplit->splitoper )
						{
#ifdef DEBUG
						NDGet( pfucb, pcsrDest );
						Assert( FNDDeleted( pfucb->kdfCurr ) );
#endif
						NDResetFlagDelete( pcsrDest );
						NDGet( pfucb, pcsrDest );
						}
					else
						{
#ifdef	DEBUG
						NDGet( pfucb, pcsrDest );
						Assert( !FNDDeleted( pfucb->kdfCurr ) );
#endif
						}

					if ( !( dirflag & fDIRNoVersion ) &&
						 !rgfmp[ pfucb->ifmp ].FVersioningOff( ) &&
						 ( psplit->fNewPageFlags & CPAGE::fPageLeaf ) )
						{
						//	UNDONE: assert version for this node exists
						//
						CallS( ErrNDFlagVersion( pcsrDest ) );
						}
					else
						{
#ifdef DEBUG
						NDGet( pfucb, pcsrDest );
						Assert( !FNDVersion( pfucb->kdfCurr ) ||
								FNDVersion( plineinfoOper->kdf ) );
						Assert( FNDVersion( pfucb->kdfCurr ) ||
								!FNDVersion( plineinfoOper->kdf ) );
#endif
						}
				}
			}

		pcsrDest->IncrementILine();
		Assert( pcsrDest->Cpage().Clines() == pcsrDest->ILine() ||
				latchRIW == pcsrDest->Latch() );

		BTISplitBulkCopy( pfucb,
						  psplit,
						  psplit->ilineOper + 1,
						  psplit->clines - psplit->ilineOper - 1 );

		pcsrSrc->SetILine( psplit->ilineSplit );
		BTISplitBulkDelete( pcsrSrc,
				psplit->clines - psplit->ilineSplit - cLineInsert );

		//	set prefix in source page
		//
		if ( splittypeAppend != psplit->splittype )
			{
			//	set new prefix in src page
			//	adjust nodes in src to correspond to new prefix
			//
			BTISplitSetPrefixInSrcPage( pfucb, psplit );
			}
		}
	else
		{
		//	oper node is in Src page
		//	move nodes to Dest page
		//	delete nodes that have been moved
		//	perform oper in Src page
		//
		Assert( psplit->ilineOper < psplit->ilineSplit ||
				splitoperNone == psplit->splitoper );

		pcsrSrc->SetILine( psplit->ilineSplit - cLineInsert );
		Assert( 0 == pcsrDest->ILine() );

		BTISplitBulkCopy( pfucb,
						  psplit,
						  psplit->ilineSplit,
						  psplit->clines - psplit->ilineSplit );

		Assert( psplit->ilineSplit - cLineInsert == pcsrSrc->ILine() );
		BTISplitBulkDelete( pcsrSrc,
							psplit->clines - psplit->ilineSplit );

		//	set prefix
		//
		Assert( splittypeAppend != psplit->splittype );
		BTISplitSetPrefixInSrcPage( pfucb, psplit );

		//	can't use rglineinfo[].kdf anymore
		//	since page may have been reorged
		//

		pcsrSrc->SetILine( psplit->ilineOper );

		if ( FBTIUpdatablePage( *pcsrSrc ) )
			{
			switch ( psplit->splitoper )
				{
				case splitoperNone:
					break;

				case splitoperInsert:
					NDInsert( pfucb, pcsrSrc, pkdf, plineinfoOper->cbPrefix );
					if ( !( dirflag & fDIRNoVersion ) &&
						 !rgfmp[ pfucb->ifmp ].FVersioningOff( ) &&
						 ( psplit->fNewPageFlags & CPAGE::fPageLeaf ) )
						{
						//	UNDONE: assert version for this node exists
						//
						CallS( ErrNDFlagVersion( pcsrSrc ) );
						}
					else
						{
#ifdef DEBUG
						NDGet( pfucb, pcsrSrc );
						Assert( !FNDVersion( pfucb->kdfCurr ) );
#endif
						}

					break;

				default:
					//	replace data
					//	by deleting and re-inserting [to avoid page reorg problems]
					//
					Assert( psplit->splitoper == splitoperFlagInsertAndReplaceData ||
							psplit->splitoper == splitoperReplace );

#ifdef DEBUG
					//	assert that key of node is in pfucb->bmCurr
					//
					NDGet( pfucb, pcsrSrc );
					Assert( FFUCBUnique( pfucb ) );
					Assert( FKeysEqual( pfucb->bmCurr.key, pfucb->kdfCurr.key ) );
#endif

					NDDelete( pcsrSrc );

					Assert( !pkdf->data.FNull() );
					Assert(	pkdf->data.Cb() > pfucb->kdfCurr.data.Cb() );
					Assert( pcsrSrc->ILine() == psplit->ilineOper );

					KEYDATAFLAGS	kdfInsert;
					kdfInsert.data		= pkdf->data;
					kdfInsert.key		= pfucb->bmCurr.key;
					kdfInsert.fFlags	= 0;

					NDInsert( pfucb, pcsrSrc, &kdfInsert, plineinfoOper->cbPrefix );
					if ( !( dirflag & fDIRNoVersion ) &&
						 !rgfmp[ pfucb->ifmp ].FVersioningOff( ) &&
						 ( psplit->fNewPageFlags & CPAGE::fPageLeaf ) )
						{
						//	UNDONE: assert version for this node exists
						//
						CallS( ErrNDFlagVersion( pcsrSrc ) );
						}
					else
						{
#ifdef DEBUG
						NDGet( pfucb, pcsrDest );
						Assert( !FNDVersion( pfucb->kdfCurr ) );
#endif
						}

					break;
				}
			}
		else
			{
			//	if we didn't need to redo the source page, we shouldn't need to redo the
			//	destination page
			Assert( !FBTIUpdatablePage( *pcsrDest ) );
			}
		}

	if ( psplit->fNewPageFlags & CPAGE::fPageLeaf )
		{
		//	set cbUncommittedFreed in src and dest pages
		//
		Assert( PinstFromIfmp( pfucb->ifmp )->FRecovering()
			|| ( pcsrDest->Cpage().FLeafPage() && latchWrite == pcsrDest->Latch() ) );
		if ( FBTIUpdatablePage( *pcsrDest ) )
			{
			//	if need to redo destination, must need to redo source page as well
			Assert( FBTIUpdatablePage( *pcsrSrc )
				|| !FBTISplitDependencyRequired( psplit ) );
			pcsrDest->Cpage().SetCbUncommittedFree( psplit->cbUncFreeDest );
			if ( pcsrDest->Cpage().FSpaceTree() )
				{
				Assert( 0 == psplit->cbUncFreeDest );
				}
			else
				{
				Assert( CbNDUncommittedFree( pfucb, pcsrDest ) <= psplit->cbUncFreeDest );
				}
			}

		if ( FBTIUpdatablePage( *pcsrSrc ) )
			{
			pcsrSrc->Cpage().SetCbUncommittedFree( psplit->cbUncFreeSrc );
			if ( pcsrSrc->Cpage().FSpaceTree() )
				{
				Assert( 0 == psplit->cbUncFreeSrc );
				}
			else
				{
				Assert( CbNDUncommittedFree( pfucb, pcsrSrc ) <= psplit->cbUncFreeSrc );
				}
			}
		else
			{
			//	if we didn't need to redo the source page, we shouldn't need to redo the
			//	destination page if not an append
			Assert( !FBTIUpdatablePage( *pcsrDest )
				|| !FBTISplitDependencyRequired( psplit ) );
			}


		//	move UndoInfo of moved nodes to destination page
		//
		Assert( ( splittypeVertical == psplit->splittype && psplit->kdfParent.key.FNull() )
			|| ( splittypeVertical != psplit->splittype && !psplit->kdfParent.key.FNull() ) );
		if ( FBTIUpdatablePage( *pcsrSrc ) )
			{
			VERMoveUndoInfo( pfucb, pcsrSrc, pcsrDest, psplit->kdfParent.key );
			}
		else
			{
			//	if we didn't need to redo the source page, we shouldn't need to redo the
			//	destination page if not an append
			Assert( !FBTIUpdatablePage( *pcsrDest )
				|| !FBTISplitDependencyRequired( psplit ) );
			}
		}
	else
		{
		Assert( 0 == psplit->cbUncFreeSrc );
		Assert( 0 == psplit->cbUncFreeDest );

#ifdef DEBUG
		if ( !PinstFromIfmp( pfucb->ifmp )->FRecovering() )
			{
			Assert( !pcsrDest->Cpage().FLeafPage() );
			Assert( pcsrSrc->Cpage().CbUncommittedFree() == 0 );
			Assert( pcsrDest->Cpage().CbUncommittedFree() == 0 );
			}
#endif
		}

	return;
	}


INLINE VOID BTISplitBulkDelete( CSR * pcsr, INT clines )
	{
	if ( !FBTIUpdatablePage( *pcsr ) )
		{
		//	page does not need redo
		//
		return;
		}
	Assert( latchWrite == pcsr->Latch() );

	NDBulkDelete( pcsr, clines );
	}


//	copy clines starting from rglineInfo[ilineStart] to csrDest
//	prefixes have been calculated in rglineInfo
//
VOID BTISplitBulkCopy( FUCB *pfucb, SPLIT *psplit, INT ilineStart, INT clines )
	{
	INT			iline;
	const INT	ilineEnd	= ilineStart + clines;
	CSR			*pcsrDest	= &psplit->csrNew;

	if ( !FBTIUpdatablePage( *pcsrDest ) )
		{
		//	page does not need redo
		//
		return;
		}
	Assert( latchWrite == pcsrDest->Latch() );

	Assert( ilineEnd <= psplit->clines );
	for ( iline = ilineStart; iline < ilineEnd; iline++ )
		{
		Assert( iline != psplit->ilineOper ||
				splitoperNone == psplit->splitoper );
		Assert( pcsrDest->Cpage().Clines() == pcsrDest->ILine() );

		const LINEINFO	* plineinfo	= &psplit->rglineinfo[iline];

#ifdef DEBUG
		const INT		cbCommon	= CbNDCommonPrefix( pfucb, pcsrDest, plineinfo->kdf.key );
		if ( cbCommon > cbPrefixOverhead )
			{
			Assert( cbCommon == plineinfo->cbPrefix  ) ;
			}
		else
			{
			Assert( 0 == plineinfo->cbPrefix );
			}
#endif

		NDInsert( pfucb, pcsrDest, &plineinfo->kdf, plineinfo->cbPrefix );

		pcsrDest->IncrementILine();
		}
	}


//	returns reference to rglineInfo corresponding to iline
//
INLINE const LINEINFO *PlineinfoFromIline( SPLIT *psplit, INT iline )
	{
	Assert( iline < psplit->clines );
	if ( psplit->splitoper != splitoperInsert ||
		 iline < psplit->ilineOper )
		{
		return &psplit->rglineinfo[iline];
		}

	Assert( psplit->splitoper == splitoperInsert );
	Assert( iline >= psplit->ilineOper );
	Assert( iline + 1 < psplit->clines );

	return &psplit->rglineinfo[iline+1];
	}

//	set prefix in page to psplit->prefix and reorg nodes
//
VOID BTISplitSetPrefixInSrcPage( FUCB *pfucb, SPLIT *psplit )
	{
	Assert( psplit->splittype != splittypeAppend );
	Assert( !psplit->prefixSplitNew.FNull()
		|| psplit->prefixinfoSplit.ilinePrefix == ilineInvalid );

	CSR			*pcsr = &psplit->psplitPath->csr;

	if ( !FBTIUpdatablePage( *pcsr ) )
		{
		//	page does not need redo
		//
		return;
		}
	Assert( latchWrite == pcsr->Latch() );

	const DATA	*pprefixOld = &psplit->prefixSplitOld;
	const DATA 	*pprefixNew = &psplit->prefixSplitNew;
	Assert( psplit->prefixinfoSplit.ilinePrefix != ilineInvalid ||
			pprefixNew->FNull() );
	Assert( psplit->prefixinfoSplit.ilinePrefix == ilineInvalid ||
			!pprefixNew->FNull() );

	INT			iline;
	const INT	clines = pcsr->Cpage().Clines();

	//	delete old prefix
	//
	if ( !pprefixOld->FNull() )
		{
		KEY	keyNull;

		keyNull.Nullify();
		NDSetPrefix( pcsr, keyNull );
		}
	else
		{
#ifdef DEBUG
		//	check prefix was null before
		//
		NDGetPrefix( pfucb, pcsr );
		Assert( pfucb->kdfCurr.key.FNull() );
#endif
		}

	//	fix nodes that shrink because of prefix change
	//
	for ( iline = 0; iline < clines; iline++ )
		{
		pcsr->SetILine( iline );
		NDGet( pfucb, pcsr );

		const LINEINFO	*plineinfo = PlineinfoFromIline( psplit, iline );
		Assert( plineinfo->cbPrefix == 0 ||
				plineinfo->cbPrefix > cbPrefixOverhead );

#ifdef DEBUG
		KEY		keyPrefix;

		keyPrefix.Nullify();
		keyPrefix.prefix = *pprefixNew;

		const INT	cbCommonKey = CbCommonKey( keyPrefix, pfucb->kdfCurr.key );

		if ( cbCommonKey > cbPrefixOverhead )
			{
			Assert( cbCommonKey == plineinfo->cbPrefix );
			}
		else
			{
			Assert( plineinfo->cbPrefix == 0 );
			}
#endif

		if ( plineinfo->cbPrefix > pfucb->kdfCurr.key.prefix.Cb() )
			{

			NDGrowCbPrefix( pfucb, pcsr, plineinfo->cbPrefix );

#ifdef DEBUG
			NDGet( pfucb, pcsr );
			Assert( pfucb->kdfCurr.key.prefix.Cb() == plineinfo->cbPrefix );
#endif
			}
		}

	//	fix nodes that grow because of prefix change
	//
	for ( iline = 0; iline < clines; iline++ )
		{
		pcsr->SetILine( iline );
		NDGet( pfucb, pcsr );

		const LINEINFO	*plineinfo = PlineinfoFromIline( psplit, iline );
		Assert( plineinfo->cbPrefix == 0 ||
				plineinfo->cbPrefix > cbPrefixOverhead );

		if ( plineinfo->cbPrefix < pfucb->kdfCurr.key.prefix.Cb() )
			{
			NDShrinkCbPrefix( pfucb, pcsr, pprefixOld, plineinfo->cbPrefix );

#ifdef DEBUG
			NDGet( pfucb, pcsr );
			Assert( pfucb->kdfCurr.key.prefix.Cb() == plineinfo->cbPrefix );
#endif
			}
		}

	//	set new prefix
	//
	KEY		keyPrefixNew;

	keyPrefixNew.Nullify();
	keyPrefixNew.prefix = *pprefixNew;
	NDSetPrefix( pcsr, keyPrefixNew );

	return;
	}


//	releases splitPath at this level
//	also releases any latches held at this level
//		sets pointers at parent and child SplitPath's to NULL
//
VOID BTIReleaseOneSplitPath( INST *pinst, SPLITPATH *psplitPath )
	{
	if ( psplitPath->psplit != NULL )
		{
		BTIReleaseSplit( pinst, psplitPath->psplit );
		psplitPath->psplit = NULL;
		}

	if ( pgnoNull != psplitPath->csr.Pgno() )
		{
		Assert( psplitPath->csr.FLatched() );
		psplitPath->csr.ReleasePage();
		psplitPath->csr.Reset();
		}

//	delete( &psplitPath->csr.Cpage() );

	if ( NULL != psplitPath->psplitPathParent )
		{
		psplitPath->psplitPathParent->psplitPathChild = NULL;
		}

	if ( NULL != psplitPath->psplitPathChild )
		{
		psplitPath->psplitPathChild->psplitPathParent = NULL;
		}

	OSMemoryHeapFree( psplitPath );
	}


//	releases whole chain of splitpath's
//	from leaf to root
//
VOID BTIReleaseSplitPaths( INST *pinst, SPLITPATH *psplitPathLeaf )
	{
	SPLITPATH *psplitPath = psplitPathLeaf;

	for ( ; psplitPath != NULL; )
		{
		//	save parent
		//
		SPLITPATH *psplitPathParent = psplitPath->psplitPathParent;

		BTIReleaseOneSplitPath( pinst, psplitPath );
		psplitPath = psplitPathParent;
		}
	}


VOID BTIReleaseSplit( INST *pinst, SPLIT *psplit )
	{
	if ( psplit->fAllocParent )
		{
		//	space is allocated for leaf pages only
		//	for internal pages, this is not allocated space
		//
		Assert( !psplit->kdfParent.key.FNull() );
		Assert( pinst->m_plog->m_fRecovering ||
				!psplit->csrNew.FLatched() ||
				psplit->csrNew.Cpage().FLeafPage() );

		OSMemoryHeapFree( psplit->kdfParent.key.suffix.Pv() );
		psplit->fAllocParent = fFalse;
		}

	if ( psplit->prefixSplitOld.Pv() != NULL )
		{
		Assert( psplit->prefixSplitOld.Cb() > 0 );
		OSMemoryHeapFree( psplit->prefixSplitOld.Pv() );
		psplit->prefixSplitOld.Nullify();
		}

	if ( psplit->prefixSplitNew.Pv() != NULL )
		{
		Assert( psplit->prefixSplitNew.Cb() > 0 );
		OSMemoryHeapFree( psplit->prefixSplitNew.Pv() );
		psplit->prefixSplitNew.Nullify();
		}

	if ( psplit->csrNew.FLatched() )
		{
		psplit->csrNew.ReleasePage();
		}
//	delete( &psplit->csrNew.Cpage() );

	if ( psplit->csrRight.FLatched() )
		{
		psplit->csrRight.ReleasePage();
		}
//	delete( &psplit->csrRight.Cpage() );

	if ( psplit->rglineinfo != NULL )
		{
		delete [] psplit->rglineinfo;
		psplit->rglineinfo = NULL;
		}
	OSMemoryHeapFree( psplit );
	}


//	checks to make sure there are no erroneous splits
//	if there is a operNone split at any level,
//		there should be no splits at lower levels
//
LOCAL VOID BTISplitCheckPath( SPLITPATH *psplitPathLeaf )
	{
#ifdef DEBUG
	SPLITPATH	*psplitPath;
	BOOL		fOperNone = fFalse;

	//	goto root
	//
	for ( psplitPath = psplitPathLeaf;
		  psplitPath->psplitPathParent != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		}

	Assert( NULL == psplitPath->psplit ||
			splittypeVertical == psplitPath->psplit->splittype );

	for ( ; psplitPath != NULL; psplitPath = psplitPath->psplitPathChild )
		{
		SPLIT	*psplit = psplitPath->psplit;

		if ( fOperNone )
			{
			//	higher level has a split with no oper
			//
			Assert( NULL == psplit );
			}
		else
			{
			if ( psplit != NULL && splitoperNone == psplit->splitoper )
				{
				fOperNone = fTrue;
				}
			}
		}
#endif
	}


//	checks lineinfo in split point to the right nodes
//
VOID BTICheckSplitLineinfo( FUCB *pfucb, SPLIT *psplit, const KEYDATAFLAGS& kdf )
	{
#ifdef DEBUG
	if ( PinstFromIfmp( pfucb->ifmp )->FRecovering() && psplit->psplitPath->csr.Latch() != latchWrite )
		{
		return;
		}

	INT				iline;
	CSR				*pcsr 		= &psplit->psplitPath->csr;
	const INT		clines 		= pcsr->Cpage().Clines();
	const SPLITOPER	splitoper	= psplit->splitoper;

	for ( iline = 0; iline < clines; iline++ )
		{
		const LINEINFO	*plineinfo = PlineinfoFromIline( psplit, iline );

		pcsr->SetILine( iline );
		NDGet( pfucb, pcsr );

		if ( splitoper == splitoperInsert ||
			 iline != psplit->ilineOper )
			{
			Assert( FKeysEqual( plineinfo->kdf.key, pfucb->kdfCurr.key ) );
			Assert( FDataEqual( plineinfo->kdf.data, pfucb->kdfCurr.data ) );
///			Assert( plineinfo->kdf.fFlags == pfucb->kdfCurr.fFlags );
			}
		else if ( splitoper == splitoperNone )
			{
			}
		else
			{
			Assert( iline == psplit->ilineOper );
			if ( splitoper != splitoperReplace )
				{
				Assert( FKeysEqual( plineinfo->kdf.key, kdf.key ) );
				}
			else
				{
				Assert( kdf.key.FNull() );
				}

			Assert( FKeysEqual( pfucb->kdfCurr.key, plineinfo->kdf.key ) );
			Assert( FDataEqual( plineinfo->kdf.data, kdf.data ) );
			}
		}

	//	check ilineOper
	//
	LINEINFO	*plineinfo = &psplit->rglineinfo[psplit->ilineOper];
	if ( splitoperInsert == psplit->splitoper )
		{
		Assert( plineinfo->kdf == kdf );
		}
#endif
	}


//	check if a split just performed is correct
//
VOID BTICheckSplits( FUCB 			*pfucb,
					SPLITPATH		*psplitPathLeaf,
					KEYDATAFLAGS	*pkdf,
					DIRFLAG			dirflag )
	{
#ifdef DEBUG
	SPLITPATH	*psplitPath;
	for ( psplitPath = psplitPathLeaf;
		  psplitPath != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		BTICheckOneSplit( pfucb, psplitPath, pkdf, dirflag );
		}
#endif
	}


LOCAL VOID BTICheckSplitFlags( const SPLIT *psplit )
	{
#ifdef DEBUG
	const SPLITPATH	*psplitPath = psplit->psplitPath;

	if ( psplit->splittype == splittypeVertical )
		{
		Assert( psplit->fSplitPageFlags & CPAGE::fPageRoot );
		Assert( !( psplit->fSplitPageFlags & CPAGE::fPageLeaf ) );

		if ( psplitPath->csr.Cpage().FLeafPage() )
			{
			Assert( psplit->fNewPageFlags | CPAGE::fPageLeaf );
			Assert( fGlobalRepair || ( psplit->fSplitPageFlags & CPAGE::fPageParentOfLeaf ) );
			}
		else
			{
			Assert( !( psplit->fSplitPageFlags & CPAGE::fPageParentOfLeaf ) );
			}
		}
	else
		{
		Assert( psplit->fNewPageFlags == psplit->fSplitPageFlags );
		Assert( psplitPath->csr.Cpage().FFlags() == psplit->fNewPageFlags );
		Assert( !( psplit->fSplitPageFlags & CPAGE::fPageRoot ) );
		}

	Assert( !( psplit->fNewPageFlags & CPAGE::fPageRoot ) );
	Assert( !(psplit->fNewPageFlags & CPAGE::fPageEmpty ) );
	Assert( !(psplit->fSplitPageFlags & CPAGE::fPageEmpty ) );
#endif
	}


//	check split at one level
//
VOID BTICheckOneSplit( FUCB 			*pfucb,
					   SPLITPATH		*psplitPath,
					   KEYDATAFLAGS		*pkdf,
					   DIRFLAG			dirflag )
	{
#ifdef DEBUG
	SPLIT			*psplit = psplitPath->psplit;
	const DBTIME	dbtime	= psplitPath->csr.Dbtime();

//	UNDONE:	check lgpos of all pages is the same
//	const LGPOS		lgpos;

	//	check that nodes in every page are in order
	//	this will be done by node at NDGet
	//

	//	check that key at parent > all sons
	//
	if ( psplit == NULL )
		{
		return;
		}

	Assert( psplit->csrNew.Pgno() == psplit->pgnoNew );
	switch ( psplit->splittype )
		{
		case splittypeVertical:
			{
			CSR 	*pcsrRoot = &psplitPath->csr;

			//	parent page has only one node
			//
			Assert( pcsrRoot->Cpage().FRootPage() );
			Assert( !pcsrRoot->Cpage().FLeafPage() );
			Assert( 1 == pcsrRoot->Cpage().Clines() );
			Assert( pcsrRoot->Dbtime() == dbtime );
			Assert( psplit->csrNew.Dbtime() == dbtime );

			NDGet( pfucb, pcsrRoot );
			Assert( pfucb->kdfCurr.key.FNull() );
			Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
			Assert( psplit->pgnoNew == *( (UnalignedLittleEndian< PGNO > *)pfucb->kdfCurr.data.Pv() ) );
			}
			break;

		case splittypeAppend:
			//	assert no node is moved
			//
			Assert( psplit->csrNew.Cpage().Clines() == 1 );
			Assert( psplit->csrRight.Pgno() == pgnoNull );
			Assert( psplit->csrNew.Cpage().PgnoNext() == pgnoNull );

		case splittypeRight:
			CSR				*pcsrParent		= &psplitPath->psplitPathParent->csr;
			CSR				*pcsrSplit		= &psplitPath->csr;
			CSR				*pcsrNew		= &psplit->csrNew;
			CSR				*pcsrRight		= &psplit->csrRight;

			KEYDATAFLAGS	kdfLess, kdfGreater;

			//	if parent is undergoing a vertical split, new page is parent
			//
			if ( psplitPath->psplitPathParent->psplit != NULL &&
				 splittypeVertical == psplitPath->psplitPathParent->psplit->splittype )
				{
				pcsrParent = &psplitPath->psplitPathParent->psplit->csrNew;
				}

			Assert( pcsrSplit->Dbtime() == dbtime );
			Assert( pcsrNew->Dbtime() == dbtime );
			Assert( pcsrParent->Dbtime() == dbtime );

			//	check split, new and right pages are in order
			//
			NDMoveLastSon( pfucb, pcsrSplit );
			kdfLess = pfucb->kdfCurr;

			NDMoveFirstSon( pfucb, pcsrNew );
			kdfGreater = pfucb->kdfCurr;

			if ( pcsrNew->Cpage().FLeafPage() )
				{
				Assert( CmpKeyData( kdfLess, kdfGreater ) < 0 || fGlobalRepair );
				}
			else
				{
				Assert( sizeof( PGNO ) == kdfGreater.data.Cb() );
				Assert( sizeof( PGNO ) == kdfLess.data.Cb() );
				Assert( !kdfLess.key.FNull() );
				Assert( kdfGreater.key.FNull() ||
						CmpKey( kdfLess.key, kdfGreater.key ) < 0 );
				}

			if ( pcsrRight->Pgno() != pgnoNull )
				{
				Assert( pcsrRight->Dbtime() == dbtime );
				Assert( pcsrRight->Cpage().FLeafPage() );
				NDMoveLastSon( pfucb, pcsrNew );
				kdfLess = pfucb->kdfCurr;

				NDMoveFirstSon( pfucb, pcsrRight );
				kdfGreater = pfucb->kdfCurr;

				Assert( CmpKeyData( kdfLess, kdfGreater ) < 0 );

				//	right page should also be >= parent of new page
				//

				}

			//	check parent pointer key > all nodes in child page
			//
			NDMoveFirstSon( pfucb, pcsrParent );

			Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
			PGNO	pgnoChild = *( (UnalignedLittleEndian< PGNO > *)pfucb->kdfCurr.data.Pv() );
			for ( ; pgnoChild != psplit->pgnoSplit ; )
				{

				Assert( pgnoChild != psplit->pgnoNew );
				Assert( pgnoChild != psplit->csrRight.Pgno() );

				//	get next page-pointer node
				//
				if ( pcsrParent->ILine() + 1 == pcsrParent->Cpage().Clines() )
					{
					Assert( psplitPath->psplitPathParent->psplit != NULL );
					pcsrParent = &psplitPath->psplitPathParent->psplit->csrNew;
					NDMoveFirstSon( pfucb, pcsrParent );
					}
				else
					{
					pcsrParent->IncrementILine();
					}

				Assert( pcsrParent->ILine() < pcsrParent->Cpage().Clines() );
				NDGet( pfucb, pcsrParent );

				Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
				pgnoChild = *( (UnalignedLittleEndian< PGNO > *)pfucb->kdfCurr.data.Pv() );
				}

			Assert( pgnoChild == psplit->pgnoSplit );
			kdfGreater = pfucb->kdfCurr;

			NDMoveLastSon( pfucb, pcsrSplit );
			if ( pcsrSplit->Cpage().FLeafPage() && !FFUCBRepair( pfucb ) )
				{
				if ( !FFUCBUnique( pfucb ) )
					{
					Assert( kdfGreater.key.FNull() ||
							CmpKeyWithKeyData( kdfGreater.key, pfucb->kdfCurr ) > 0 );
					}
				else
					{
					Assert( kdfGreater.key.FNull() ||
							CmpKey( kdfGreater.key, pfucb->kdfCurr.key ) > 0 );
					}
				}
			else
				{
				//	no suffix compression at internal levels
				//
				Assert( FKeysEqual( kdfGreater.key, pfucb->kdfCurr.key ) );
				}

			//	next page pointer should point to new page
			//
			if ( pcsrParent->ILine() + 1 == pcsrParent->Cpage().Clines() )
				{
				Assert( psplitPath->psplitPathParent->psplit != NULL );
				pcsrParent = &psplitPath->psplitPathParent->psplit->csrNew;
				NDMoveFirstSon( pfucb, pcsrParent );
				}
			else
				{
				pcsrParent->IncrementILine();
				NDGet( pfucb, pcsrParent );
				}

			Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
			Assert( psplit->pgnoNew == *( (UnalignedLittleEndian< PGNO > *)pfucb->kdfCurr.data.Pv() ) );

			//	key at this node should be > last node in pgnoNew
			//
			kdfGreater = pfucb->kdfCurr;

			NDMoveLastSon( pfucb, pcsrNew );
			if ( pcsrNew->Cpage().FLeafPage() )
				{
				if ( !FFUCBUnique( pfucb ) )
					{
					Assert( kdfGreater.key.FNull() ||
							CmpKeyWithKeyData( kdfGreater.key, pfucb->kdfCurr ) > 0 );
					}
				else
					{
					Assert( kdfGreater.key.FNull() ||
							CmpKey( kdfGreater.key, pfucb->kdfCurr.key ) > 0 );
					}
				}
			else
				{
				//	no suffix compression at internal levels
				//
				Assert( FKeysEqual( kdfGreater.key, pfucb->kdfCurr.key ) );
				}

			//	key at this node should be < first node in right page, if any
			//
			if ( pcsrRight->Pgno() != pgnoNull )
				{
				Assert( pcsrRight->Cpage().FLeafPage() );

				kdfLess = kdfGreater;
				NDMoveFirstSon( pfucb, pcsrRight );

				Assert( !kdfLess.key.FNull() );
				Assert( CmpKeyWithKeyData( kdfLess.key, pfucb->kdfCurr ) <= 0 );
				}
		}
#endif	//	DEBUG
	}


//	creates a new MERGEPATH structure and initializes it
//	adds newly created mergePath structure to head of list
//	pointed to by *ppMergePath passed in
//
ERR	ErrBTINewMergePath( MERGEPATH **ppmergePath )
	{
	MERGEPATH	*pmergePath;

	pmergePath = static_cast<MERGEPATH *>( PvOSMemoryHeapAlloc( sizeof(MERGEPATH) ) );
	if ( NULL == pmergePath )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	memset( (BYTE *) pmergePath, 0, sizeof( MERGEPATH ) );

	pmergePath->pmergePathParent = *ppmergePath;
	new( &pmergePath->csr ) CSR;

	pmergePath->dbtimeBefore = dbtimeInvalid;

	if ( pmergePath->pmergePathParent != NULL )
		{
		Assert( NULL == pmergePath->pmergePathParent->pmergePathChild );
		pmergePath->pmergePathParent->pmergePathChild = pmergePath;
		}

	*ppmergePath = pmergePath;
	return JET_errSuccess;
	}


//	releases mergePath at this level
//	also releases any latches held at this level
//		sets pointers at parent and child mergePath's to NULL
//
VOID BTIReleaseOneMergePath( MERGEPATH *pmergePath )
	{
	if ( pmergePath->pmerge != NULL )
		{
		BTIReleaseMerge( pmergePath->pmerge );
		pmergePath->pmerge = NULL;
		}

	if ( pmergePath->csr.FLatched() )
		{
		Assert( pmergePath->csr.Pgno() != pgnoNull );
		pmergePath->csr.ReleasePage();
		}
	pmergePath->csr.Reset();

	if ( NULL != pmergePath->pmergePathParent )
		{
		pmergePath->pmergePathParent->pmergePathChild = NULL;
		}

	if ( NULL != pmergePath->pmergePathChild )
		{
		pmergePath->pmergePathChild->pmergePathParent = NULL;
		}

	OSMemoryHeapFree( pmergePath );
	}


//	seeks to node for single page cleanup
//	returns error if node is not found
//
INLINE ERR ErrBTISPCSeek( FUCB *pfucb, const BOOKMARK& bm )
	{
	ERR		err;

	//	no page should be latched
	//
	Assert( !Pcsr( pfucb )->FLatched( ) );

	//	go to root
	//
	Call( ErrBTIGotoRoot( pfucb, latchReadNoTouch ) );
	Assert( 0 == Pcsr( pfucb )->ILine() );

	if ( Pcsr( pfucb )->Cpage().Clines() == 0 )
		{
		//	page is empty
		//
		Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
		err = wrnNDFoundGreater;
		}
	else
		{
		//	seek down tree for bm
		//
		for ( ; ; )
			{
			Call( ErrNDSeek( pfucb, bm ) );

			if ( !Pcsr( pfucb )->Cpage().FInvisibleSons( ) )
				{
				//	leaf node reached, exit loop
				//
				break;
				}
			else
				{
				//	get pgno of child from node
				//	switch to that page
				//
				Assert( pfucb->kdfCurr.data.Cb() == sizeof( PGNO ) );
				Call( Pcsr( pfucb )->ErrSwitchPage(
							pfucb->ppib,
							pfucb->ifmp,
							*(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv(),
							pfucb->u.pfcb->Tableclass(),
							pfucb->u.pfcb->FNoCache() ) );
				Assert( Pcsr( pfucb )->Cpage().Clines() > 0 );
				}
			}
		}

	if ( wrnNDFoundGreater == err ||
		 wrnNDFoundLess == err )
		{
		Call( ErrERRCheck( JET_errNoCurrentRecord ) );
		}
	else if ( !FNDDeleted( pfucb->kdfCurr ) )
		{
		Call( ErrERRCheck( JET_errRecordNotDeleted ) );
		}

HandleError:
	if ( err < 0 )
		{
		BTUp( pfucb );
		}

	return err;
	}


//	deletes all nodes in page that are flagged-deleted
//		and have no active version
//	also nullifies versions on deleted nodes
//
LOCAL ERR ErrBTISPCDeleteNodes( FUCB *pfucb, CSR *pcsr, LINEINFO *rglineinfo )
	{
	ERR		err = JET_errSuccess;
	INT		iline;
	INT		clines = pcsr->Cpage().Clines();

	Assert( clines > 0 );
	for ( iline = clines - 1; iline >= 0 ; iline-- )
		{
		LINEINFO	*plineinfo = &rglineinfo[iline];

		if ( FNDDeleted( plineinfo->kdf )
			&& !plineinfo->fVerActive
			&& pcsr->Cpage().Clines() > 1 )
			{
			pcsr->SetILine( iline );

			BOOKMARK	bm;
			NDGet( pfucb, pcsr );
			NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );

			Assert( FKeysEqual( pfucb->kdfCurr.key, plineinfo->kdf.key ) );
			Assert( FDataEqual( pfucb->kdfCurr.data, plineinfo->kdf.data ) );
			Assert( FNDDeleted( pfucb->kdfCurr ) );
			Assert( FNDDeleted( plineinfo->kdf ) );

			Call( ErrNDDelete( pfucb, pcsr, fDIRNull ) );

//			WARNING: The assert below is wrong, because by this point, there may actually
//			be future active versions.  This is because versioning is now done before we
//			latch the page.
//			Assert( !FVERActive( pfucb, bm ) );
			VERNullifyInactiveVersionsOnBM( pfucb, bm );
			}
		}

HandleError:
	return err;
	}


LOCAL ERR ErrBTIMergeEmptyTree(
	FUCB		* const pfucb,
	MERGEPATH	* const pmergePathLeaf )
	{
	ERR			err					= JET_errSuccess;
	MERGEPATH	* pmergePath;
	ULONG		cPagesToFree		= 0;
	EMPTYPAGE	rgemptypage[cBTMaxDepth];
	LGPOS		lgpos;

	//	go to root
	//	since we need to latch top-down
	for ( pmergePath = pmergePathLeaf;
		  pmergePath->pmergePathParent != NULL;
		  pmergePath = pmergePath->pmergePathParent )
		{
		Assert( latchRIW == pmergePath->csr.Latch() );
		}

	MERGEPATH	* const pmergePathRoot	= pmergePath;
	CSR			* const pcsrRoot		= &pmergePathRoot->csr;

	Assert( pcsrRoot->Cpage().FRootPage() );
	Assert( !pcsrRoot->Cpage().FLeafPage() );
	Assert( 1 == pcsrRoot->Cpage().Clines() );
	pcsrRoot->UpgradeFromRIWLatch();

	//	latch and dirty all pages
	Assert( NULL != pmergePathRoot->pmergePathChild );
	for ( pmergePath = pmergePathRoot->pmergePathChild;
		NULL != pmergePath;
		pmergePath = pmergePath->pmergePathChild )
		{
		pmergePath->csr.UpgradeFromRIWLatch();

		rgemptypage[cPagesToFree].dbtimeBefore = pmergePath->csr.Dbtime();
		rgemptypage[cPagesToFree].pgno = pmergePath->csr.Pgno();
		rgemptypage[cPagesToFree].ulFlags = pmergePath->csr.Cpage().FFlags();

		cPagesToFree++;
		Assert( cPagesToFree <= cBTMaxDepth );
		}
	Assert( cPagesToFree > 0 );

	err = ErrLGEmptyTree(
				pfucb,
				pcsrRoot,
				rgemptypage,
				cPagesToFree,
				&lgpos );

	if ( JET_errSuccess <= err )
		{
		NDSetEmptyTree( pcsrRoot );

		//	update lgpos
		pcsrRoot->Cpage().SetLgposModify( lgpos );

		//	update all child pages with dbtime of root, mark them as empty, and update lgpos
		const DBTIME	dbtime		= pcsrRoot->Dbtime();
		for ( pmergePath = pmergePathRoot->pmergePathChild;
			NULL != pmergePath;
			pmergePath = pmergePath->pmergePathChild )
			{
			pmergePath->csr.CoordinatedDirty( dbtime );
			pmergePath->csr.Cpage().SetEmpty();
			pmergePath->csr.Cpage().SetLgposModify( lgpos );
			}
		}

	BTIReleaseMergePaths( pmergePathLeaf );
	CallR( err );

	//	WARNING: If we crash after this point, we will lose space

	const BOOL		fAvailExt	= FFUCBAvailExt( pfucb );
	const BOOL		fOwnExt		= FFUCBOwnExt( pfucb );

	//	fake out cursor to make it think it's not a space cursor
	if ( fAvailExt )
		{
		Assert( !fOwnExt );
		FUCBResetAvailExt( pfucb );
		}
	else if ( fOwnExt )
		{
		FUCBResetOwnExt( pfucb );
		}
	Assert( !FFUCBSpace( pfucb ) );

	//	return freed pages to AvailExt
	BTUp( pfucb );
	for ( ULONG i = 0; i < cPagesToFree; i++ )
		{
		//	UNDONE:	track lost space because of inability
		//			to split availExt tree with the released space
		Assert( PgnoRoot( pfucb ) != rgemptypage[i].pgno );
		const ERR	errFreeExt	= ErrSPFreeExt( pfucb, rgemptypage[i].pgno, 1 );
#ifdef DEBUG
		if ( !FSPExpectedError( errFreeExt ) )
			{
			CallS( errFreeExt );
			}
#endif

		CallR( errFreeExt );
		}

	Assert( !FFUCBSpace( pfucb ) );
	if ( fAvailExt )
		{
		FUCBSetAvailExt( pfucb );
		}
	else if ( fOwnExt )
		{
		FUCBSetOwnExt( pfucb );
		}

	return JET_errSuccess;
	}



//	performs multipage cleanup
//		seeks down to node
//		performs empty page or merge operation if possible
//		else expunges all deletable nodes in page
//

#ifdef OLD_DEPENDENCY_CHAIN_HACK
	const CPG	cpgOLDAdjacentPartialMergesThreshold	= 32;		//	number of consecutive-page merges before bailing out
#endif																	//	(to avoid building length dependency chain)

ERR ErrBTIMultipageCleanup(
	FUCB			*pfucb,
	const BOOKMARK&	bm,
	BOOKMARK		*pbmNext,
	RECCHECK		* preccheck )
	{
	ERR				err;
	MERGEPATH		*pmergePath		= NULL;

#ifdef OLD_DEPENDENCY_CHAIN_HACK
#ifdef DEBUG
	const PGNO		pgnoPrevMergeT	= PinstFromIfmp( pfucb->ifmp )->m_rgoldstatDB[ rgfmp[pfucb->ifmp].Dbid() ].PgnoPrevPartialMerge();
#endif
#endif

	if ( pfucb->u.pfcb->FDeletePending() )
		{
		//	btree is scheduled for deletion - don't bother attempting cleanup
		//
		if ( NULL != pbmNext )
			{
			pbmNext->key.suffix.SetCb( 0 );
			pbmNext->data.SetCb( 0 );
			}

		return JET_errSuccess;
		}

	//	get path RIW latched
	//
	Call( ErrBTICreateMergePath( pfucb, bm, &pmergePath ) );
	if ( wrnBTShallowTree == err )
		{
		if ( NULL != pbmNext )
			{
			pbmNext->key.suffix.SetCb( 0 );
			pbmNext->data.SetCb( 0 );
			}
		goto HandleError;
		}

	//	check if merge conditions hold
	//
	Call( ErrBTISelectMerge( pfucb, pmergePath, bm, pbmNext, preccheck ) );
	Assert( pmergePath->pmerge != NULL );
	Assert( pmergePath->pmerge->rglineinfo != NULL );

	if ( mergetypeEmptyTree == pmergePath->pmerge->mergetype )
		{
		if ( NULL != pbmNext )
			{
			pbmNext->key.suffix.SetCb( 0 );
			pbmNext->data.SetCb( 0 );
			}


		err = ErrBTIMergeEmptyTree( pfucb, pmergePath );
		return err;
		}

	//	release pages not involved in merge
	//
	BTIMergeReleaseUnneededPages( pmergePath );


#ifdef OLD_DEPENDENCY_CHAIN_HACK
	if ( mergetypePartialRight == pmergePath->pmerge->mergetype
		&& pfucb->ppib->FSessionOLD() )
		{
		const IFMP				ifmp			= pfucb->ifmp;
		INST * const			pinst			= PinstFromIfmp( ifmp );
		OLDDB_STATUS * const	poldstatDB		= pinst->m_rgoldstatDB + rgfmp[ifmp].Dbid();

		//	if right page already had a partial merge, increment
		//	adjacent partial merge count, and don't bother doing
		//	a partial merge on this page if we exceed the threshold
		Assert( pgnoNull != pmergePath->csr.Cpage().PgnoNext() );
		if ( poldstatDB->PgnoPrevPartialMerge() == pmergePath->csr.Cpage().PgnoNext() )
			{
			if ( poldstatDB->CpgAdjacentPartialMerges() > cpgOLDAdjacentPartialMergesThreshold )
				{
				pmergePath->pmerge->mergetype = mergetypeNone;
				poldstatDB->ResetCpgAdjacentPartialMerges();
				}
			else
				{
				poldstatDB->IncCpgAdjacentPartialMerges();
				}
			}
		else
			{
			poldstatDB->ResetCpgAdjacentPartialMerges();
			}

		poldstatDB->SetPgnoPrevPartialMerge( pmergePath->csr.Pgno() );
		}
#endif	//	OLD_DEPENDENCY_CHAIN_HACK

	switch( pmergePath->pmerge->mergetype )
		{
		case mergetypeEmptyPage:
			Call( ErrBTIMergeOrEmptyPage( pfucb, pmergePath ) );
			break;

		//	UNDONE:	disable partial merges from RCE cleanup
		//
		case mergetypePartialRight:
		case mergetypeFullRight:
			//	sibling pages, if any, should be RIW latched
			//
			Assert( pgnoNull != pmergePath->csr.Cpage().PgnoNext() );
			Assert( latchRIW == pmergePath->pmerge->csrRight.Latch() );

			Assert( pgnoNull == pmergePath->csr.Cpage().PgnoPrev()
				|| latchRIW == pmergePath->pmerge->csrLeft.Latch() );

			//	log merge, merge pages, release empty page
			//
			Call( ErrBTIMergeOrEmptyPage( pfucb, pmergePath ) );
			break;

		default:
			Assert( pmergePath->pmerge->mergetype == mergetypeNone );
			Assert( latchRIW == pmergePath->csr.Latch() );

			//	can not delete only node in page
			//
			if ( pmergePath->csr.Cpage().Clines() == 1 )
				{
				goto HandleError;
				}

			//	upgrade to write latch on leaf page
			//
			pmergePath->csr.UpgradeFromRIWLatch();

			//	delete all other flag-deleted nodes with no active version
			//
			Call( ErrBTISPCDeleteNodes( pfucb, &pmergePath->csr, pmergePath->pmerge->rglineinfo ) );
			Assert( pmergePath->csr.Cpage().Clines() > 0 );
			break;
		}

HandleError:
	BTIReleaseMergePaths( pmergePath );
	return err;
	}


//	performs cleanup deleting bookmarked node from tree
//	seeks for node using single page read latches
//	if page is empty/mergeable
//		return NeedsMultipageOLC
//	else
//		expunge all flag deleted nodes without active version from page
//
LOCAL ERR ErrBTISinglePageCleanup( FUCB *pfucb, const BOOKMARK& bm )
	{
	Assert( !Pcsr( pfucb )->FLatched() );

	ERR			err;

	if ( pfucb->u.pfcb->FDeletePending() )
		{
		//	btree is scheduled for deletion - don't bother attempting cleanup
		//
		return JET_errSuccess;
		}

	CallR( ErrBTISPCSeek( pfucb, bm ) );

	LINEINFO	*rglineinfo = NULL;
	BOOL		fEmptyPage;
	BOOL		fLessThanOneThirdFull;

	//	collect page info for nodes
	//
	Call( ErrBTISPCCollectLeafPageInfo(
				pfucb,
				Pcsr( pfucb ),
				&rglineinfo,
				NULL,
				&fEmptyPage,
				NULL,
				&fLessThanOneThirdFull ) );

	//	do not call multi-page cleanup if online backup is occurring
	if ( !PinstFromPfucb( pfucb )->m_plog->m_fBackupInProgress )
		{
		//	if page is empty
		//		needs MultipageOLC
		//
		if ( fEmptyPage )
			{
			err = ErrERRCheck( wrnBTMultipageOLC );
			goto HandleError;
			}

		if ( fLessThanOneThirdFull && pgnoNull != Pcsr( pfucb )->Cpage().PgnoNext() )
			{
			const PGNO	pgnoRight = Pcsr( pfucb )->Cpage().PgnoNext();
			CSR			csrRight;
			BOOL		fMergeable;

			//	latch right page
			//
			Call( csrRight.ErrGetReadPage( pfucb->ppib, pfucb->ifmp, pgnoRight, bflfNoTouch ) );

			//	check is page is mergeable with right page
			//
			fMergeable = FBTISPCCheckMergeable( pfucb, &csrRight, rglineinfo );
			if ( !fMergeable )
				{
				PERFIncCounterTable( cBTUnnecessarySiblingLatch, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );
				}

			//	release right page
			//
			csrRight.ReleasePage();
			if ( fMergeable )
				{
				//	if page is mergeable
				//		needs MultipageOLC
				//
				err = ErrERRCheck( wrnBTMultipageOLC );
				goto HandleError;
				}
			}
		}

	//	upgrade page to write latch
	//	if upgrade fails, return NeedsMultipageOLC
	//
	err = Pcsr( pfucb )->ErrUpgradeFromReadLatch( );
	if ( errBFLatchConflict == err )
		{
		cBTFailedWriteLatchForSPC.Inc( PinstFromPfucb( pfucb ) );
		err = ErrERRCheck( wrnBTMultipageOLC );
		goto HandleError;
		}
	Call( err );

	//	delete all flag-deleted nodes in page
	//		that have no active versions
	//
	Assert( latchWrite == Pcsr( pfucb )->Latch() );
	Call( ErrBTISPCDeleteNodes( pfucb, Pcsr( pfucb ), rglineinfo ) );

HandleError:
	if ( rglineinfo != NULL )
		{
		delete [] rglineinfo;
		}

	BTUp( pfucb );
	return err;
	}


//	creates mergePath of RIW latched pages from root of tree
//	to seeked bookmark
//
LOCAL ERR ErrBTICreateMergePath( FUCB	 			*pfucb,
								 const BOOKMARK& 	bm,
								 MERGEPATH 			**ppmergePath )
	{
	ERR		err;

	//	create mergePath structure
	//
	CallR( ErrBTINewMergePath( ppmergePath ) );
	Assert( NULL != *ppmergePath );

	//	RIW latch root
	//
	Call( (*ppmergePath)->csr.ErrGetRIWPage( pfucb->ppib,
											 pfucb->ifmp,
											 PgnoRoot( pfucb ),
											 pfucb->u.pfcb->Tableclass() ) );

	if ( (*ppmergePath)->csr.Cpage().FLeafPage() )
		{
		//	tree is too shallow to bother doing merges on
		//
		err = ErrERRCheck( wrnBTShallowTree );
		}
	else
		{
		BOOL	fLeftEdgeOfBtree	= fTrue;
		BOOL	fRightEdgeOfBtree	= fTrue;

		Assert( (*ppmergePath)->csr.Cpage().Clines() > 0 );

		for ( ; ; )
			{
			Call( ErrNDSeek( pfucb,
							 &(*ppmergePath)->csr,
							 bm ) );

			//	save iLine for later use
			//
			(*ppmergePath)->iLine = SHORT( (*ppmergePath)->csr.ILine() );
			Assert( (*ppmergePath)->iLine < (*ppmergePath)->csr.Cpage().Clines() );

			if ( (*ppmergePath)->csr.Cpage().FLeafPage() )
				{
				const MERGEPATH * const	pmergePathParent		= (*ppmergePath)->pmergePathParent;
				const BOOL				fLeafPageIsFirstPage	= ( pgnoNull == (*ppmergePath)->csr.Cpage().PgnoPrev() );
				const BOOL				fLeafPageIsLastPage		= ( pgnoNull == (*ppmergePath)->csr.Cpage().PgnoNext() );

				//	if root page was also a leaf page, we would have
				//	err'd out above with wrnBTShallowTree
				Assert( NULL != pmergePathParent );
				Assert( !( (*ppmergePath)->csr.Cpage().FRootPage() ) );

				if ( fLeftEdgeOfBtree ^ fLeafPageIsFirstPage )
					{
					//	if not repair, assert, otherwise, suppress the assert
					//	and repair will just naturally err out
					AssertSz( fGlobalRepair, "Corrupt B-tree: first leaf page has mismatched parent" );
					Call( ErrBTIReportBadPageLink(
								pfucb,
								ErrERRCheck( JET_errBadParentPageLink ),
								pmergePathParent->csr.Pgno(),
								(*ppmergePath)->csr.Pgno(),
								(*ppmergePath)->csr.Cpage().PgnoPrev() ) );
					}
				if ( fRightEdgeOfBtree ^ fLeafPageIsLastPage )
					{
					//	if not repair, assert, otherwise, suppress the assert
					//	and repair will just naturally err out
					AssertSz( fGlobalRepair, "Corrupt B-tree: last leaf page has mismatched parent" );
					Call( ErrBTIReportBadPageLink(
								pfucb,
								ErrERRCheck( JET_errBadParentPageLink ),
								pmergePathParent->csr.Pgno(),
								(*ppmergePath)->csr.Pgno(),
								(*ppmergePath)->csr.Cpage().PgnoNext() ) );
					}

				break;
				}

			Assert( (*ppmergePath)->csr.Cpage().FInvisibleSons() );
			Assert( !( fRightEdgeOfBtree ^ (*ppmergePath)->csr.Cpage().FLastNodeHasNullKey() ) );

			fRightEdgeOfBtree = ( fRightEdgeOfBtree
								&& (*ppmergePath)->iLine == (*ppmergePath)->csr.Cpage().Clines() - 1 );
			fLeftEdgeOfBtree = ( fLeftEdgeOfBtree
								&& 0 == (*ppmergePath)->iLine );

			//	allocate another mergePath structure for next level
			//
			Call( ErrBTINewMergePath( ppmergePath ) );

			//	access child page
			//
			Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
			Call( (*ppmergePath)->csr.ErrGetRIWPage(
									pfucb->ppib,
									pfucb->ifmp,
									*(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv(),
									pfucb->u.pfcb->Tableclass() ) );
			}
		}

HandleError:
	return err;
	}


//	copies next bookmark to seek for online defrag
//	from left page
//
LOCAL VOID BTIMergeCopyNextBookmark( FUCB		*pfucb,
									 MERGEPATH 	*pmergePathLeaf,
									 BOOKMARK	*pbmNext )
	{
	Assert( NULL != pmergePathLeaf );
	Assert( NULL != pbmNext );
	Assert( pmergePathLeaf->csr.FLatched() );
	Assert( pmergePathLeaf->pmerge != NULL );

	Assert( pbmNext->key.prefix.FNull() );

	//	if no left sibling, nullify bookmark
	//
	if ( pmergePathLeaf->pmerge->csrLeft.Pgno() == pgnoNull )
		{
		Assert( pmergePathLeaf->csr.Cpage().PgnoPrev() == pgnoNull );
		pbmNext->key.suffix.SetCb( 0 );
		pbmNext->data.SetCb( 0 );
		return;
		}

	Assert( mergetypeEmptyTree != pmergePathLeaf->pmerge->mergetype );

	CSR			*pcsrLeft = &pmergePathLeaf->pmerge->csrLeft;
	BOOKMARK	bm;

	Assert( pcsrLeft->FLatched() );
	Assert( pcsrLeft->Cpage().Clines() > 0 );

	//	get bm of first node from page
	//
	pcsrLeft->SetILine( 0 );
	NDGet( pfucb, pcsrLeft );
	NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );

	//	copy bm into given buffer
	//
	Assert( NULL != pbmNext->key.suffix.Pv() );
	Assert( 0 == pbmNext->key.prefix.Cb() );
	bm.key.CopyIntoBuffer( pbmNext->key.suffix.Pv(), bm.key.Cb() );
	pbmNext->key.suffix.SetCb( bm.key.Cb() );

	pbmNext->data.SetPv( (BYTE *) pbmNext->key.suffix.Pv() + pbmNext->key.Cb() );
	bm.data.CopyInto( pbmNext->data );

	return;
	}


//	select merge at leaf level and recursively at parent levels
//	pmergePath already created and RIW latched
//
LOCAL ERR ErrBTISelectMerge(
	FUCB			*pfucb,
	MERGEPATH 		*pmergePathLeaf,
	const BOOKMARK&	bm,
	BOOKMARK		*pbmNext,
	RECCHECK 		* const preccheck )
	{
	ERR				err;

	Assert( pmergePathLeaf->csr.Cpage().FLeafPage() );

	//	allocate merge structure and initialize
	//
	CallR( ErrBTINewMerge( pmergePathLeaf ) );
	Assert( NULL != pmergePathLeaf->pmerge );

	MERGE	*pmerge = pmergePathLeaf->pmerge;
	pmerge->mergetype = mergetypeNone;

	//	check if page is mergeable, without latching sibling pages,
	//	also collect info on all nodes in page
	//
	CallR( ErrBTIMergeCollectPageInfo( pfucb, pmergePathLeaf, preccheck ) );

	//	if we want the next bookmark, then we have to latch the left page to
	//	obtain it, even if no merge will occur will the current page
	if ( mergetypeNone == pmerge->mergetype
		&& NULL == pbmNext )
		{
		return err;
		}
	else if ( mergetypeEmptyTree == pmerge->mergetype )
		{
		return err;
		}

	//	page could be merged
	//	acquire latches on sibling pages
	//	this might cause latch of merged page to be released
	//
	const DBTIME	dbtimeLast	= pmergePathLeaf->csr.Cpage().Dbtime();
	const VOID		*pvPageLast	= pmergePathLeaf->csr.Cpage().PvBuffer();

	Call( ErrBTIMergeLatchSiblingPages( pfucb, pmergePathLeaf ) );

	//	copy next bookmark to seek for online defrag
	//
	if ( NULL != pbmNext )
		{
		BTIMergeCopyNextBookmark( pfucb, pmergePathLeaf, pbmNext );
		}

	Assert( pmergePathLeaf->pmergePathParent != NULL || mergetypeNone == pmerge->mergetype );

	if ( pmergePathLeaf->csr.Cpage().Dbtime() != dbtimeLast ||
		 pmergePathLeaf->csr.Cpage().PvBuffer() != pvPageLast )
		{
		//	page was changed when we released and reacquired latch
		//	reseek to deleted node
		//	recompute if merge is possible
		//
		BTIReleaseMergeLineinfo( pmerge );

		Call( ErrNDSeek( pfucb, &pmergePathLeaf->csr, bm ) );

		pmergePathLeaf->iLine = SHORT( pmergePathLeaf->csr.ILine() );

		//  we don't want to check the same node multiple times so we don't bother with the reccheck
		Call( ErrBTIMergeCollectPageInfo( pfucb, pmergePathLeaf, NULL ) );
		}

	switch ( pmerge->mergetype )
		{
		case mergetypeEmptyPage:
			Call( ErrBTISelectMergeInternalPages( pfucb, pmergePathLeaf ) );
			break;

		case mergetypeFullRight:
		case mergetypePartialRight:

			//	check if page can be merged to next page
			//	without violating density constraint
			//
			BTICheckMergeable( pfucb, pmergePathLeaf );
			if ( mergetypeNone == pmerge->mergetype )
				{
				return err;
				}

			//	select merge at parent pages
			//
			Call( ErrBTISelectMergeInternalPages( pfucb, pmergePathLeaf ) );

			if ( mergetypeEmptyPage != pmerge->mergetype )
				{
				//	calcualte uncommitted freed space in right page
				//
				pmerge->cbUncFreeDest	= pmerge->csrRight.Cpage().CbUncommittedFree() +
											pmerge->cbSizeMaxTotal -
											pmerge->cbSizeTotal;
				}
			break;

		default:
			Assert( mergetypeNone == pmerge->mergetype
				|| mergetypeEmptyTree == pmerge->mergetype );
		}

HandleError:
	return err;
	}


//	allocate a new merge structure
//		and link it to mergePath
//
ERR ErrBTINewMerge( MERGEPATH *pmergePath )
	{
	MERGE	*pmerge;

	Assert( pmergePath != NULL );
	Assert( pmergePath->pmerge == NULL );

	//	allocate split structure
	//
	pmerge = static_cast<MERGE *>( PvOSMemoryHeapAlloc( sizeof(MERGE) ) );
	if ( pmerge == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	memset( (BYTE *)pmerge, 0, sizeof(MERGE) );
	new( &pmerge->csrRight ) CSR;
	new( &pmerge->csrLeft ) CSR;

	pmerge->dbtimeLeftBefore = dbtimeInvalid;
	pmerge->dbtimeRightBefore = dbtimeInvalid;

	//	link merge structure to pmergePath
	//
	pmerge->pmergePath = pmergePath;
	pmergePath->pmerge = pmerge;

	return JET_errSuccess;
	}


INLINE VOID BTIReleaseMergeLineinfo( MERGE *pmerge )
	{
	if ( pmerge->rglineinfo != NULL )
		{
		delete [] pmerge->rglineinfo;
		pmerge->rglineinfo = NULL;
		}
	}


//	revert dbtime of every (write) latched page to the before dirty dbtime
//
VOID BTIMergeRevertDbtime( MERGEPATH *pmergePathLeaf )
	{
	MERGEPATH *pmergePath = pmergePathLeaf;

	Assert( NULL == pmergePath->pmergePathChild );
	for ( ; NULL != pmergePath && pmergePath->csr.Latch() == latchWrite;
			pmergePath = pmergePath->pmergePathParent )
		{
		//	set the dbtime for this page
		//
		Assert ( latchWrite == pmergePath->csr.Latch() );

		Assert ( dbtimeInvalid != pmergePath->dbtimeBefore && dbtimeNil != pmergePath->dbtimeBefore);
		Assert ( pmergePath->dbtimeBefore < pmergePath->csr.Dbtime() );
		pmergePath->csr.RevertDbtime( pmergePath->dbtimeBefore );

		MERGE	*pmerge = pmergePath->pmerge;

		//	set dbtime for sibling and new pages
		//
		if ( pmerge != NULL )
			{
			if ( pgnoNull != pmerge->csrLeft.Pgno() )
				{
				Assert( pmerge->csrLeft.Cpage().FLeafPage() );

				Assert ( dbtimeInvalid != pmerge->dbtimeLeftBefore && dbtimeNil != pmerge->dbtimeLeftBefore);
				Assert ( pmerge->dbtimeLeftBefore < pmerge->csrLeft.Dbtime() );
				pmerge->csrLeft.RevertDbtime( pmerge->dbtimeLeftBefore );
				}

			if ( pgnoNull != pmerge->csrRight.Pgno() )
				{
				Assert( pmerge->csrRight.Cpage().FLeafPage() );

				Assert ( dbtimeInvalid != pmerge->dbtimeRightBefore && dbtimeNil != pmerge->dbtimeRightBefore);
				Assert ( pmerge->dbtimeRightBefore < pmerge->csrRight.Dbtime() );
				pmerge->csrRight.RevertDbtime( pmerge->dbtimeRightBefore );
				}
			}
		}
	}


VOID BTIReleaseMerge( MERGE *pmerge )
	{
	if ( pmerge->fAllocParentSep )
		{
		//	space is allocated for leaf pages only
		//	for internal pages, this is not allocated space
		//
		Assert( !pmerge->kdfParentSep.key.FNull() );
		Assert( pmerge->kdfParentSep.key.prefix.FNull() );

		OSMemoryHeapFree( pmerge->kdfParentSep.key.suffix.Pv() );
		pmerge->fAllocParentSep = fFalse;
		}

	if ( pmerge->csrLeft.FLatched() )
		{
		pmerge->csrLeft.ReleasePage();
		}

	if ( pmerge->csrRight.FLatched() )
		{
		pmerge->csrRight.ReleasePage();
		}

	BTIReleaseMergeLineinfo( pmerge );
	OSMemoryHeapFree( pmerge );
	}


//	positions cursor fractionally
//	so that approximately ( pfrac->ulLT / pfrac->ulTotal ) * 100 %
//	of all records are less than cursor position
//	UNDONE: understand and rewrite so it does not use clinesMax
//
LOCAL INT IlineBTIFrac( FUCB *pfucb, DIB *pdib )
	{
	INT			iLine;
	INT			clines		= Pcsr( pfucb )->Cpage().Clines( );
	FRAC		*pfrac		= (FRAC *)pdib->pbm;
	const INT	clinesMax	= 4096;

	Assert( pdib->pos == posFrac );
	Assert( pfrac->ulTotal >= pfrac->ulLT );

	//	cast to float to avoid overflow/underflow with
	//	INT operation
	//
	iLine = (INT) ( ( (float) pfrac->ulLT * clines ) / pfrac->ulTotal );
	Assert( iLine <= clines );
	if ( iLine >= clines )
		{
		iLine = clines - 1;
		}

	//	preseve fractional information by avoiding underflow
	//
	if ( pfrac->ulTotal / clines == 0 )
		{
		pfrac->ulTotal *= clinesMax;
		pfrac->ulLT *= clinesMax;
		}

	//	prepare fraction for next lower B-tree level
	//
	Assert( pfrac->ulTotal > 0 );
	pfrac->ulLT =  (INT) ( (float) pfrac->ulLT -
						   (float) ( iLine * pfrac->ulTotal ) / clines );
	pfrac->ulTotal /= clines;

	Assert( pfrac->ulLT <= pfrac->ulTotal );
	return iLine;
	}


//	collects lineinfo for page
//	if all nodes in page are flag-deleted without active version
//		set fEmptyPage
//	if there exists a flag deleted node with active version
//		set fExistsFlagDeletedNodeWithActiveVersion
//
ERR ErrBTISPCCollectLeafPageInfo(
	FUCB		*pfucb,
	CSR			*pcsr,
	LINEINFO	**pplineinfo,
	RECCHECK	* const preccheck,
	BOOL		*pfEmptyPage,
	BOOL		*pfExistsFlagDeletedNodeWithActiveVersion,
	BOOL		*pfLessThanOneThirdFull )
	{
	const INT 	clines									= pcsr->Cpage().Clines();
	BOOL		fExistsFlagDeletedNodeWithActiveVersion	= fFalse;
	ULONG		cbSizeMaxTotal							= 0;

	Assert( pcsr->Cpage().FLeafPage() );

	//	UNDONE:	allocate rglineinfo on demand [only if not empty page]
	//
	//	allocate rglineinfo
	//
	Assert( NULL == *pplineinfo );
	*pplineinfo = new LINEINFO[clines];

	if ( NULL == *pplineinfo )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	LINEINFO	*rglineinfo = *pplineinfo;

	Assert( NULL != pfEmptyPage );
	*pfEmptyPage = fTrue;

	//	collect total size of movable nodes in page
	//		i.e, nodes that are not flag-deleted
	//			 or flag-deleted with active versions
	//
	for ( INT iline = 0; iline < clines; iline++ )
		{
		pcsr->SetILine( iline );
		NDGet( pfucb, pcsr );

		rglineinfo[iline].kdf 		= pfucb->kdfCurr;
		rglineinfo[iline].cbSize	= CbNDNodeSizeTotal( pfucb->kdfCurr );
		rglineinfo[iline].cbSizeMax	= CbBTIMaxSizeOfNode( pfucb, pcsr );

		if ( !FNDDeleted( pfucb->kdfCurr ) )
			{
			if( NULL != preccheck )
				{
				(*preccheck)( pfucb->kdfCurr );
				}

			cbSizeMaxTotal += rglineinfo[iline].cbSizeMax;
			*pfEmptyPage = fFalse;
			continue;
			}

		rglineinfo[iline].fVerActive = fFalse;

		Assert( FNDDeleted( pfucb->kdfCurr ) );
		if ( FNDPossiblyVersioned( pfucb, pcsr ) )
			{
			BOOKMARK	bm;
			NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );

			if ( FVERActive( pfucb, bm ) )
				{
				//	version is still active
				//
				cbSizeMaxTotal += rglineinfo[iline].cbSizeMax;
				rglineinfo[iline].fVerActive = fTrue;
				*pfEmptyPage = fFalse;
				fExistsFlagDeletedNodeWithActiveVersion = fTrue;
				}
			}
		}

	if ( NULL != pfExistsFlagDeletedNodeWithActiveVersion )
		{
		*pfExistsFlagDeletedNodeWithActiveVersion = fExistsFlagDeletedNodeWithActiveVersion;
		}
	if ( NULL != pfLessThanOneThirdFull )
		{
		const ULONG		cbDensityFree	= CbBTIFreeDensity( pfucb );
		Assert( cbDensityFree < cbNDPageAvailMostNoInsert );
		*pfLessThanOneThirdFull = ( cbSizeMaxTotal < ( ( cbNDPageAvailMostNoInsert - cbDensityFree ) / 3 ) );
		}

	return JET_errSuccess;
	}


//	collects merge info for page
//	if page has flag-deleted node with an active version
//		return pmerge->mergetype = mergetypeNone
//
ERR ErrBTIMergeCollectPageInfo( FUCB *pfucb, MERGEPATH *pmergePath, RECCHECK * const preccheck )
	{
	ERR			err;
	const INT 	clines = pmergePath->csr.Cpage().Clines();
	MERGE		*pmerge = pmergePath->pmerge;

	Assert( pmerge != NULL );
	Assert( pmergePath->csr.Cpage().FLeafPage() );

	BOOL	fEmptyPage;
	BOOL	fExistsFlagDeletedNodeWithActiveVersion;

	pmerge->clines = clines;
	Assert( NULL == pmerge->rglineinfo );

	Assert( 0 == pmerge->cbSavings );
	Assert( 0 == pmerge->cbSizeTotal );
	Assert( 0 == pmerge->cbSizeMaxTotal );

	CallR( ErrBTISPCCollectLeafPageInfo(
			pfucb,
			&pmergePath->csr,
			&pmerge->rglineinfo,
			preccheck,
			&fEmptyPage,
			&fExistsFlagDeletedNodeWithActiveVersion,
			NULL ) );
	Assert( NULL != pmerge->rglineinfo );

	Assert( pmergePath->pmergePathParent != NULL ||
			PgnoRoot( pfucb ) == pmergePath->csr.Pgno() &&
			pmergePath->csr.Cpage().FRootPage() );

	//	no merge/empty page possible if single-page tree
	//	also eliminate the case where right sibling does not exist
	//	and left sibling does not have the same parent
	//	since we can't fix page pointer to left sibling to be NULL-keyed
	//		[left sibling page's parent is not latched]
	//
	if ( pmergePath->pmergePathParent == NULL ||
		 ( pmergePath->csr.Cpage().PgnoPrev() != pgnoNull &&
		   pmergePath->csr.Cpage().PgnoNext() == pgnoNull &&
		   pmergePath->pmergePathParent->csr.Cpage().Clines() == 1 ) )
		{
		pmerge->mergetype = mergetypeNone;
		}
	else if ( fEmptyPage )
		{
		pmerge->mergetype	= ( pmergePath->csr.Cpage().PgnoPrev() == pgnoNull
								&& pmergePath->csr.Cpage().PgnoNext() == pgnoNull ?
									mergetypeEmptyTree :
									mergetypeEmptyPage );
		}
	else if ( fExistsFlagDeletedNodeWithActiveVersion )
		{
		//	next cleanup with clean this page
		//
		pmerge->mergetype	= mergetypeNone;
		}
	else
		{
		pmerge->mergetype	= mergetypeFullRight;
		}

	return err;
	}


//	latches sibling pages
//	release current page
//	RIW latch left, current and right pages in order
//
ERR ErrBTIMergeLatchSiblingPages( FUCB *pfucb, MERGEPATH * const pmergePathLeaf )
	{
	ERR				err				= JET_errSuccess;
	CSR * const		pcsr			= &pmergePathLeaf->csr;
	MERGE * const	pmerge			= pmergePathLeaf->pmerge;
	const PGNO		pgnoCurr		= pcsr->Pgno();
	ULONG			cLatchFailures	= 0;

	Assert( NULL != pmerge );

Start:
	Assert( latchRIW == pcsr->Latch() );

	const DBTIME	dbtimeCurr		= pcsr->Dbtime();
	const PGNO		pgnoLeft		= pcsr->Cpage().PgnoPrev();
	PGNO			pgnoRight;

	if ( pgnoLeft != pgnoNull )
		{
		pcsr->ReleasePage();

		Assert( mergetypeEmptyTree != pmerge->mergetype );
		Call( pmerge->csrLeft.ErrGetRIWPage( pfucb->ppib,
											 pfucb->ifmp,
											 pgnoLeft,
											 pfucb->u.pfcb->Tableclass() ) );

		const BOOL	fBadSiblingPointer	= ( pmerge->csrLeft.Cpage().PgnoNext() != pgnoCurr );
		if( fBadSiblingPointer
			|| pmerge->csrLeft.Cpage().ObjidFDP() != pfucb->u.pfcb->ObjidFDP() )
			{
			const PGNO	pgnoBadLink		= ( fBadSiblingPointer ?
													pmerge->csrLeft.Cpage().PgnoNext() :
													pmerge->csrLeft.Cpage().ObjidFDP() );

			//	left page has split after we released current page
			//	release left page
			//	relatch current page and retry
			//
			pmerge->csrLeft.ReleasePage();

			Call( pcsr->ErrGetRIWPage( pfucb->ppib,
									   pfucb->ifmp,
									   pgnoCurr,
									   pfucb->u.pfcb->Tableclass() ) );

			Assert( pcsr->Dbtime() >= dbtimeCurr );
			if ( pcsr->Dbtime() == dbtimeCurr )
				{
				//	dbtime didn't change, but pgnoNext of the left page doesn't
				//	match pgnoPrev of the current page - must be bad page link, so
				//	if not repair, assert, otherwise, suppress the assert and
				//	repair will just naturally err out
				AssertSz( fGlobalRepair, "Corrupt B-tree: bad leaf page links detected on Merge (left sibling)" );
				Call( ErrBTIReportBadPageLink(
							pfucb,
							ErrERRCheck( JET_errBadPageLink ),
							pgnoCurr,
							pgnoLeft,
							pgnoBadLink ) );
				}
			else if ( cLatchFailures < 10
				&& !pcsr->Cpage().FEmptyPage() )	//	someone else could have cleaned the page when we gave it up to latch the sibling
				{
				cLatchFailures++;
				goto Start;
				}
			else
				{
				err = ErrERRCheck( errBTMergeNotSynchronous );
				goto HandleError;
				}
			}

		//	relatch current page
		//
		Call( pcsr->ErrGetRIWPage( pfucb->ppib,
								   pfucb->ifmp,
								   pgnoCurr,
								   pfucb->u.pfcb->Tableclass() ) );
		}
	else
		{
		//	set pgnoLeft to pgnoNull
		//
		pmerge->csrLeft.Reset();
		}


	Assert( latchRIW == pcsr->Latch() );
	pgnoRight = pcsr->Cpage().PgnoNext();

	Assert( pmerge->csrRight.Pgno() == pgnoNull );
	if ( pgnoRight != pgnoNull )
		{
		Assert( mergetypeEmptyTree != pmerge->mergetype );
		Call( pmerge->csrRight.ErrGetRIWPage( pfucb->ppib,
											  pfucb->ifmp,
											  pgnoRight,
											  pfucb->u.pfcb->Tableclass() ) );

		const BOOL	fBadSiblingPointer	= ( pmerge->csrRight.Cpage().PgnoPrev() != pgnoCurr );
		if( fBadSiblingPointer
			|| pmerge->csrRight.Cpage().ObjidFDP() != pfucb->u.pfcb->ObjidFDP() )
			{
			const PGNO	pgnoBadLink		= ( fBadSiblingPointer ?
													pmerge->csrRight.Cpage().PgnoPrev() :
													pmerge->csrRight.Cpage().ObjidFDP() );

			//	if not repair, assert, otherwise, suppress the assert and
			//	repair will just naturally err out
			AssertSz( fGlobalRepair, "Corrupt B-tree: bad leaf page links detected on Merge (right sibling)" );
			Call( ErrBTIReportBadPageLink(
					pfucb,
					ErrERRCheck( JET_errBadPageLink ),
					pgnoCurr,
					pmerge->csrRight.Pgno(),
					pgnoBadLink ) );
			}
		}

	Assert( pgnoRight == pcsr->Cpage().PgnoNext() );
	Assert( pgnoLeft == pcsr->Cpage().PgnoPrev() );
	Assert( pcsr->Cpage().FLeafPage() );
	Assert( pgnoLeft == pgnoNull || pmerge->csrLeft.Cpage().FLeafPage() );
	Assert( pgnoRight == pgnoNull || pmerge->csrRight.Cpage().FLeafPage() );

HandleError:
	return err;
	}


//	calculates how many nodes in merged page fit in the right/root page
//		without violating density constraint
//
VOID BTICheckMergeable( FUCB *pfucb, MERGEPATH *pmergePath )
	{
	CSR		*pcsr;
	MERGE	*pmerge = pmergePath->pmerge;

	Assert( pmerge != NULL );
	Assert( pmerge->mergetype == mergetypeFullRight );

	if ( pmergePath->csr.Cpage().PgnoNext() == pgnoNull )
		{
		//	no right sibling -- can not merge
		//
		Assert( latchNone == pmerge->csrRight.Latch() );
		pmerge->mergetype = mergetypeNone;
		return;
		}

	Assert( mergetypeFullRight == pmerge->mergetype );
	Assert( pmerge->csrRight.FLatched() );
	pcsr = &pmerge->csrRight;

	//	calculate total size, total max size and prefixes of nodes to move
	//
	Assert( NULL != pmerge->rglineinfo );
	Assert( mergetypeFullRight == pmerge->mergetype );
	Assert( 0 == pmerge->cbSizeTotal );
	Assert( 0 == pmerge->cbSizeMaxTotal );

	const ULONG	cbDensityFree	= ( pcsr->Cpage().FLeafPage() ? CbBTIFreeDensity( pfucb ) : 0 );
	INT			iline;

	NDGetPrefix( pfucb, pcsr );

	for ( iline = pmerge->clines - 1; iline >= 0 ; pmerge->ilineMerge = iline, iline-- )
		{
		LINEINFO	*plineinfo = &pmerge->rglineinfo[iline];

		if ( FNDDeleted( plineinfo->kdf ) && !plineinfo->fVerActive )
			{
			//	this node will not be moved
			//
			continue;
			}

		//	calculate cbPrefix for node
		//
		const INT	cbCommon = CbCommonKey( pfucb->kdfCurr.key,
											plineinfo->kdf.key );
		INT			cbSavings = pmerge->cbSavings;

		if ( cbCommon > cbPrefixOverhead )
			{
			plineinfo->cbPrefix = cbCommon;
			cbSavings += cbCommon - cbPrefixOverhead;
			}
		else
			{
			plineinfo->cbPrefix = 0;
			}

		//	moving nodes should not violate density constraint [assuming no rollbacks]
		//	and moving nodes should still allow rollbacks to succeed
		//
		Assert( pcsr->Pgno() != pgnoNull );
		const INT	cbSizeTotal		= pmerge->cbSizeTotal  + plineinfo->cbSize;
		const INT	cbSizeMaxTotal 	= pmerge->cbSizeMaxTotal + plineinfo->cbSizeMax;
		const INT	cbReq 			= ( cbSizeMaxTotal - cbSavings ) + cbDensityFree;

		//	UNDONE:	this may be expensive if we do not want a partial merge
		//			move this check to later [on all nodes in page]
		//
		Assert( cbReq >= 0 );
		if ( !FNDFreePageSpace( pfucb, pcsr, cbReq ) )
			{
			//	if no nodes are moved, there is no merge
			//
			if ( iline == pmerge->clines - 1 )
				{
				pmerge->mergetype = mergetypeNone;
				}
			else
				{
				Assert( iline + 1 == pmerge->ilineMerge );
				Assert( pmerge->ilineMerge < pmerge->clines );
				Assert( 0 < pmerge->ilineMerge );

				pmerge->mergetype 	= mergetypePartialRight;
				}

			break;
			}

		//	update merge to include node
		//
		pmerge->cbSavings		= cbSavings;
		pmerge->cbSizeTotal 	= cbSizeTotal;
		pmerge->cbSizeMaxTotal 	= cbSizeMaxTotal;
		}

	return;
	}


//	check if remaining nodes in merged page fit in the right/root page
//		without violating density constraint
//
BOOL FBTISPCCheckMergeable( FUCB *pfucb, CSR *pcsrRight, LINEINFO *rglineinfo )
	{
	const INT	clines = Pcsr( pfucb )->Cpage().Clines();

	Assert( Pcsr( pfucb )->FLatched() );
	Assert( pcsrRight->FLatched() );
	Assert( Pcsr( pfucb )->Cpage().PgnoNext() == pcsrRight->Pgno() );
	Assert( pcsrRight->Cpage().PgnoPrev() == Pcsr( pfucb )->Pgno() );
	Assert( pcsrRight->Cpage().FLeafPage() );
	Assert( Pcsr( pfucb )->Cpage().FLeafPage() );

	//	calculate total size, total max size and prefixes of nodes to move
	//
	INT		cbSizeTotal = 0;
	INT		cbSizeMaxTotal = 0;
	INT		cbSavings = 0;
	INT		iline;

	NDGetPrefix( pfucb, pcsrRight );

	for ( iline = 0; iline < clines; iline++ )
		{
		LINEINFO	*plineinfo = &rglineinfo[iline];

		if ( FNDDeleted( plineinfo->kdf ) && !plineinfo->fVerActive )
			{
			//	this node will not be moved
			//
			continue;
			}

		//	calculate cbPrefix for node
		//
		INT		cbCommon = CbCommonKey( pfucb->kdfCurr.key,
										plineinfo->kdf.key );
		if ( cbCommon > cbPrefixOverhead )
			{
			plineinfo->cbPrefix = cbCommon;
			cbSavings += cbCommon - cbPrefixOverhead;
			}
		else
			{
			plineinfo->cbPrefix = 0;
			}

		//	add cbSize and cbSizeMax
		//
		cbSizeTotal 	+= plineinfo->cbSize;
		cbSizeMaxTotal 	+= plineinfo->cbSizeMax;
		}

	//	moving nodes should not violate density constraint [assuming no rollbacks]
	//	and moving nodes should still allow rollbacks to succeed
	//
	Assert( pcsrRight->Pgno() != pgnoNull );
	const INT		cbReq		= ( cbSizeMaxTotal - cbSavings )
									+ ( Pcsr( pfucb )->Cpage().FLeafPage() ? CbBTIFreeDensity( pfucb ) : 0 );
	const BOOL		fMergeable	= FNDFreePageSpace( pfucb, pcsrRight, cbReq );

	return fMergeable;
	}

//	check if last node in internal page is null-keyed
//
INLINE BOOL FBTINullKeyedLastNode( FUCB *pfucb, MERGEPATH *pmergePath )
	{
	CSR 	*pcsr = &pmergePath->csr;

	Assert( !pcsr->Cpage().FLeafPage() );

	pcsr->SetILine( pmergePath->iLine );
	NDGet( pfucb, pcsr );
	Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );

	//	cannot be null if not last node
	Assert( pcsr->Cpage().Clines() - 1 == pmergePath->iLine
		|| !pfucb->kdfCurr.key.FNull() );

	return pfucb->kdfCurr.key.FNull();
	}


//	checks if internal pages are emptied because of page merge/deletion
//	also checks if internal page must and can adjust page-pointer key
//
ERR ErrBTISelectMergeInternalPages( FUCB *pfucb, MERGEPATH * const pmergePathLeaf )
	{
	ERR			err;
	MERGEPATH	*pmergePath			= pmergePathLeaf->pmergePathParent;
	MERGE		* const pmergeLeaf	= pmergePathLeaf->pmerge;
	const BOOL	fLeftSibling		= pgnoNull != pmergeLeaf->csrLeft.Pgno();
	const BOOL	fRightSibling		= pgnoNull != pmergeLeaf->csrRight.Pgno();
	BOOL		fKeyChange			= fFalse;

	//	check input
	//
	Assert( mergetypeNone != pmergeLeaf->mergetype );
	Assert( pmergePath != NULL );
	Assert( !pmergePath->csr.Cpage().FLeafPage() );
	Assert( fRightSibling ||
			pmergePath->csr.Cpage().Clines() - 1 == pmergePath->csr.ILine() );
	Assert( fLeftSibling ||
			0 == pmergePath->csr.ILine() );
	Assert( fRightSibling ||
			!fLeftSibling ||
			pmergePath->csr.ILine() > 0 );

	//	set flag to empty leaf page
	//
	Assert( !pmergePathLeaf->fEmptyPage );
	if ( mergetypePartialRight != pmergeLeaf->mergetype )
		{
		pmergePathLeaf->fEmptyPage = fTrue;
		}

	for ( ; pmergePath != NULL; pmergePath = pmergePath->pmergePathParent )
		{
		Assert( pmergePath->pmerge == NULL );
		Assert( !pmergePath->csr.Cpage().FLeafPage() );
		Assert( !pmergePath->fKeyChange );
		Assert( !pmergePath->fEmptyPage );
		Assert( !pmergePath->fDeleteNode );
		Assert( pmergePath->iLine == pmergePath->csr.ILine() );

		if ( mergetypePartialRight == pmergeLeaf->mergetype )
			{
			MERGEPATH	*pmergePathChild = pmergePath->pmergePathChild;

			Assert( NULL != pmergePathChild );

			//	if parent of leaf
			//	  or last node in child is changing key
			//		change key at level
			//	else break
			if ( NULL == pmergePathChild->pmergePathChild ||
				 pmergePathChild->csr.Cpage().Clines() - 1 == pmergePathChild->iLine )
				{
				if ( NULL == pmergePathChild->pmergePathChild )
					{
					const INT		ilineMerge 	= pmergeLeaf->ilineMerge;
					KEYDATAFLAGS 	*pkdfMerge 	= &pmergeLeaf->rglineinfo[ilineMerge].kdf;
					KEYDATAFLAGS 	*pkdfPrev 	= &pmergeLeaf->rglineinfo[ilineMerge - 1].kdf;

					//	allocate key separator
					//
					Assert( ilineMerge > 0 );
					Assert( !pmergeLeaf->fAllocParentSep );
					CallR( ErrBTIComputeSeparatorKey( pfucb,
													  *pkdfPrev,
													  *pkdfMerge,
													  &pmergeLeaf->kdfParentSep.key ) );

					pmergeLeaf->kdfParentSep.data.SetCb( sizeof( PGNO ) );
					pmergeLeaf->fAllocParentSep = fTrue;
					}
				else
					{
///					Assert( fFalse );
					}

				Assert( pmergeLeaf->fAllocParentSep );

				if ( FBTIOverflowOnReplacingKey( pfucb, pmergePath, pmergeLeaf->kdfParentSep ) )
					{
					goto Overflow;
					}

				pmergePath->fKeyChange = fTrue;
				continue;
				}

			break;
			}

		if ( pmergePath->csr.Cpage().Clines() == 1 )
			{
			//	only node in page
			//	whole page will be deleted
			//
			Assert( pmergePath->csr.ILine() == 0 );

			if ( pmergePath->csr.Cpage().FRootPage() )
				{
				//	UNDONE:	fix this by deleting page pointer in root,
				//			releasing all pages except root and
				//			setting root to be a leaf page
				//
				//	we can't free root page -- so punt empty page operation
				//
				Assert( fFalse );	//	should now be handled by mergetypeEmptyTree/
				Assert( mergetypeEmptyPage == pmergeLeaf->mergetype );

				goto Overflow;
				}

			//	can only delete this page if child page is deleted as well
			if ( pmergePath->pmergePathChild->fEmptyPage )
				{
				Assert( pmergePath->pmergePathChild->csr.Cpage().FLeafPage()
						|| ( 0 == pmergePath->pmergePathChild->csr.ILine()
							&& 1 == pmergePath->pmergePathChild->csr.Cpage().Clines() ) );
				pmergePath->fEmptyPage = fTrue;
				}
			else
				{
				//	this code path is a very specialised case -- there is only one page pointer
				//	in this page, and in the non-leaf child page, the page pointer with
				//	the largest key was deleted (and the key was non-null), necessitating a key
				//	change in the key of the sole page pointer in this page
				Assert( fKeyChange );
				Assert( pmergePath->pmergePathChild->fDeleteNode );
				Assert( pmergePath->pmergePathChild->iLine ==
				   pmergePath->pmergePathChild->csr.Cpage().Clines() - 1 );
				Assert( !pmergePath->pmergePathChild->csr.Cpage().FLeafPage() );
				if ( FBTIOverflowOnReplacingKey(
							pfucb,
							pmergePath,
							pmergeLeaf->kdfParentSep ) )
					{
					goto Overflow;
					}

				pmergePath->fKeyChange = fTrue;
				}

			continue;
			}

		Assert( pmergePath->csr.ILine() == pmergePath->iLine );
		if ( pmergePath->csr.Cpage().Clines() - 1 == pmergePath->iLine )
			{
			//	delete largest parent pointer node in page
			//		replace current last node in page with new separator key
			//
			Assert( fLeftSibling );

			if ( !fKeyChange )
				{
				//	allocate and compute separator key from leaf level
				//
				Assert( !pmergePathLeaf->pmerge->fAllocParentSep );

				fKeyChange = fTrue;
				CallR( ErrBTIMergeCopySeparatorKey( pmergePath,
													pmergePathLeaf->pmerge,
													pfucb ) );
				Assert( pmergePathLeaf->pmerge->fAllocParentSep );

				pmergePath->fDeleteNode = fTrue;

				Assert( pmergePath->csr.Cpage().Clines() > 1 );
				if ( FBTINullKeyedLastNode( pfucb, pmergePath ) )
					{
					//	parent pointer is also null-keyed
					//
					Assert( NULL == pmergePath->pmergePathParent ||
							pmergePath->pmergePathParent->csr.Cpage().Clines() - 1 ==
								pmergePath->pmergePathParent->iLine &&
							FBTINullKeyedLastNode( pfucb,
												   pmergePath->pmergePathParent ) );
					break;
					}
				}
			else
				{
				if ( FBTIOverflowOnReplacingKey( pfucb,
												 pmergePath,
												 pmergeLeaf->kdfParentSep ) )
					{
					goto Overflow;
					}

				pmergePath->fKeyChange = fTrue;
				}

			continue;
			}

		if ( pmergePath->pmergePathChild->fKeyChange ||
			 ( pmergePath->pmergePathChild->fDeleteNode &&
			   pmergePath->pmergePathChild->iLine ==
			   pmergePath->pmergePathChild->csr.Cpage().Clines() - 1 ) )
			{
			//	change key of page pointer in this page
			//	since largest key in child page has changed
			//
			Assert( !pmergePath->pmergePathChild->csr.Cpage().FLeafPage() );
			Assert( pmergePath->pmergePathChild->iLine ==
					pmergePath->pmergePathChild->csr.Cpage().Clines() - 1 );
			Assert( fKeyChange );

			if ( FBTIOverflowOnReplacingKey( pfucb,
											 pmergePath,
											 pmergeLeaf->kdfParentSep ) )
				{
				goto Overflow;
				}

			pmergePath->fKeyChange = fTrue;
			}
		else if ( pmergePath->pmergePathChild->fEmptyPage )
			{
			//	parent of merged or emptied page
			//
			Assert( pmergePath->iLine != pmergePath->csr.Cpage().Clines() - 1 );
			Assert( pmergePath->csr.Cpage().Clines() > 1 );

			pmergePath->fDeleteNode = fTrue;
			}

		break;
		}

	return JET_errSuccess;

Overflow:
	pmergePathLeaf->pmerge->mergetype = mergetypeNone;
	return JET_errSuccess;
	}



//	does replacing the key in node pmergePath->iLine of page
//	cause a page overflow?
//
BOOL FBTIOverflowOnReplacingKey( FUCB 					*pfucb,
								 MERGEPATH				*pmergePath,
								 const KEYDATAFLAGS& 	kdfSep )
	{
	CSR		*pcsr = &pmergePath->csr;

	Assert( !kdfSep.key.FNull() );
	Assert( !pcsr->Cpage().FLeafPage() );

	//	calculate required space for separator with current prefix
	//
	ULONG 	cbReq = CbBTICbReq( pfucb, pcsr, kdfSep );

	//	get last node in page
	//
	pcsr->SetILine( pmergePath->iLine );
	NDGet( pfucb, pcsr );
	Assert( !FNDVersion( pfucb->kdfCurr ) );

	ULONG	cbSizeCurr = CbNDNodeSizeCompressed( pfucb->kdfCurr );

	//	check if new separator key would cause overflow
	//
	if ( cbReq > cbSizeCurr )
		{
		const BOOL	fOverflow = FBTISplit( pfucb, pcsr, cbReq - cbSizeCurr );

		return fOverflow;
		}

	return fFalse;
	}


//	UNDONE: we can do without the allocation and copy by
//			copying kdfCurr into kdfParentSep
//			and ordering merge/empty page operations bottom-down
//
//	copies new page separator key from last - 1 node in current page
//
ERR ErrBTIMergeCopySeparatorKey( MERGEPATH 	*pmergePath,
								 MERGE		*pmergeLeaf,
								 FUCB 		*pfucb )
	{
	Assert( NULL != pmergeLeaf );
	Assert( mergetypePartialRight != pmergeLeaf->mergetype );
	Assert( pmergeLeaf->kdfParentSep.key.FNull() );
	Assert( pmergeLeaf->kdfParentSep.data.FNull() );

	Assert( !pmergePath->csr.Cpage().FLeafPage() );
	Assert( pmergePath->iLine == pmergePath->csr.Cpage().Clines() - 1 );
	Assert( pmergePath->iLine > 0 );

	pmergePath->csr.SetILine( pmergePath->iLine - 1 );
	NDGet( pfucb, &pmergePath->csr );
	Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );

	pmergeLeaf->kdfParentSep.key.Nullify();
	pmergeLeaf->kdfParentSep.key.suffix.SetPv( PvOSMemoryHeapAlloc( pfucb->kdfCurr.key.Cb() ) );
	if ( pmergeLeaf->kdfParentSep.key.suffix.Pv() == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	//	copy separator key into alocated memory
	//
	pfucb->kdfCurr.key.CopyIntoBuffer( pmergeLeaf->kdfParentSep.key.suffix.Pv() );
	pmergeLeaf->kdfParentSep.key.suffix.SetCb( pfucb->kdfCurr.key.Cb() );

	Assert( !pmergeLeaf->fAllocParentSep );
	Assert( !pmergeLeaf->kdfParentSep.key.FNull() );
	pmergeLeaf->fAllocParentSep = fTrue;

	//	page pointer should have pgno as data
	//
	pmergeLeaf->kdfParentSep.data.SetCb( sizeof( PGNO ) );
	return JET_errSuccess;
	}


//	from leaf to root
//
VOID BTIReleaseMergePaths( MERGEPATH *pmergePathLeaf )
	{
	MERGEPATH *pmergePath = pmergePathLeaf;

	for ( ; pmergePath != NULL; )
		{
		//	save parent
		//
		MERGEPATH *pmergePathParent = pmergePath->pmergePathParent;

		BTIReleaseOneMergePath( pmergePath );
		pmergePath = pmergePathParent;
		}
	}


//	performs merge by going through pages top-down
//
ERR ErrBTIMergeOrEmptyPage( FUCB *pfucb, MERGEPATH *pmergePathLeaf )
	{
	ERR			err = JET_errSuccess;
	MERGE		*pmerge = pmergePathLeaf->pmerge;
	LGPOS		lgpos;

	Assert( NULL != pmerge );
	Assert( mergetypeNone != pmerge->mergetype );

	//	upgrade latches
	//
	CallR( ErrBTIMergeUpgradeLatches( pfucb->ifmp, pmergePathLeaf ) );

	//	log merge operation as a multi-page operation
	//	there can be no failures after this
	//		till space release operations
	//
	err = ErrLGMerge( pfucb, pmergePathLeaf, &lgpos );

	// on error, return to before dirty dbtime on all pages
	if ( JET_errSuccess > err )
		{
		BTIMergeRevertDbtime( pmergePathLeaf );
		}
	CallR ( err );

	BTIMergeSetLgpos( pmergePathLeaf, lgpos );

	BTIPerformMerge( pfucb, pmergePathLeaf );

	//	check if the merge performed is correct
	//
	BTICheckMerge( pfucb, pmergePathLeaf );

	//	release all latches
	//	so space can latch root successfully
	//
	BTIMergeReleaseLatches( pmergePathLeaf );

	//	release empty pages -- ignores errors
	//
	BTIReleaseEmptyPages( pfucb, pmergePathLeaf );

	return err;
	}


//	performs merge or empty page operation
//		by calling one-level merge at each level top-down
//
VOID BTIPerformMerge( FUCB *pfucb, MERGEPATH *pmergePathLeaf )
	{
	MERGEPATH	*pmergePath;

	//	go to root
	//	since we need to process pages bottom-down
	//
	for ( pmergePath = pmergePathLeaf;
		  pmergePath->pmergePathParent != NULL;
		  pmergePath = pmergePath->pmergePathParent )
		{
		}

	//	process pages top-down
	//
	for ( ; pmergePath != NULL; pmergePath = pmergePath->pmergePathChild )
		{
		if ( pmergePath->csr.Latch() == latchWrite ||
			 PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering )
			{
			BTIPerformOneMerge( pfucb, pmergePath, pmergePathLeaf->pmerge );
			switch ( pmergePath->pmerge ? pmergePath->pmerge->mergetype : mergetypeNone )
				{
				case mergetypeEmptyPage:
					PERFIncCounterTable( cBTEmptyPageMerge, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );
					break;

				case mergetypeFullRight:
					PERFIncCounterTable( cBTRightMerge, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );
					break;

				case mergetypePartialRight:
					PERFIncCounterTable( cBTPartialMerge, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );
					break;

				default:
					break;
				}
			}
		else
			{
//			Assert( fFalse );
			}
		}
	}


//	processes one page for merge or empty page operation
//	depending on the operation selection in pmergePath->flags
//
VOID BTIPerformOneMerge( FUCB 		*pfucb,
						 MERGEPATH 	*pmergePath,
						 MERGE 		*pmergeLeaf )
	{
	CSR		*pcsr = &pmergePath->csr;

	Assert( !FBTIUpdatablePage( *pcsr ) || pcsr->FDirty() );

	Assert( !pmergePath->fKeyChange || !pmergePath->fDeleteNode );
	Assert( !pmergePath->fEmptyPage ||
			!pmergePath->fKeyChange && !pmergePath->fDeleteNode );
	Assert( !pmergePath->fEmptyPage ||
			mergetypePartialRight != pmergeLeaf->mergetype );

	//	if leaf page,
	//		fix all flag deleted versions of nodes in page to operNull
	//		if merge,
	//			move nodes to right page
	//		if not partial merge
	//			fix siblings
	//
	if ( NULL == pmergePath->pmergePathChild )
		{
		Assert( pmergePath->pmerge == pmergeLeaf );
		const MERGETYPE	mergetype = pmergeLeaf->mergetype;

		Assert( mergetype != mergetypeNone );
		Assert( !FBTIUpdatablePage( *pcsr ) || pcsr->Cpage().FLeafPage() );

		if ( mergetypeEmptyPage != mergetype )
			{
			BTIMergeMoveNodes( pfucb, pmergePath );
			}

		//	delete flag deleted nodes that have no active version
		//	if there is a version nullify it
		//
		BTIMergeDeleteFlagDeletedNodes( pfucb, pmergePath );

		if ( mergetypePartialRight != mergetype )
			{
			//	fix siblings
			BTIMergeFixSiblings( PinstFromIfmp( pfucb->ifmp ), pmergePath );
			}

#ifdef LV_MERGE_BUG
		if ( mergetypeEmptyPage != mergetype
			&& pcsr->Cpage().FLeafPage()
			&& pcsr->Cpage().FLongValuePage() )
			{
			extern VOID	LVICheckLVMerge( FUCB *pfucb, MERGEPATH *pmergePath );
			LVICheckLVMerge( pfucb, pmergePath );
			}
#endif
		}

	//	if page not write latched [no redo needed]
	//		do nothing
	else if ( !FBTIUpdatablePage( *pcsr ) )
		{
		Assert( PinstFromIfmp( pfucb->ifmp )->FRecovering() );
		}

	//	if fDeleteNode,
	//		delete node
	//		if page pointer is last node and
	//		there is no right sibling to leaf page,
	//			fix new last key to NULL
	//
	else if ( pmergePath->fDeleteNode )
		{
		Assert( !pmergePath->csr.Cpage().FLeafPage() );
		Assert( pmergePath->csr.Cpage().Clines() > 1 );
		Assert( mergetypePartialRight != pmergeLeaf->mergetype );

		const BOOL fFixLastNodeToNull = FBTINullKeyedLastNode( pfucb, pmergePath );

		NDDelete( pcsr );
		if ( fFixLastNodeToNull )
			{
			Assert( pmergeLeaf->mergetype == mergetypeEmptyPage );
			Assert( !FBTIUpdatablePage( pmergeLeaf->pmergePath->csr ) ||
					pmergeLeaf->pmergePath->csr.Cpage().PgnoNext() == pgnoNull );
			Assert( pcsr->Cpage().Clines() == pmergePath->iLine );
			Assert( pcsr->ILine() > 0 );

			pcsr->DecrementILine();
			KEY keyNull;
			keyNull.Nullify();
			BTIChangeKeyOfPagePointer( pfucb, pcsr, keyNull );
			}
		}

	//	if fKeyChange
	//		change the key of seeked node to new separator
	//
	else if ( pmergePath->fKeyChange )
		{
		Assert( !pmergeLeaf->kdfParentSep.key.FNull() );

		pcsr->SetILine( pmergePath->iLine );
		BTIChangeKeyOfPagePointer( pfucb,
								   pcsr,
								   pmergeLeaf->kdfParentSep.key );
		}

	else
		{
		Assert( pmergePath->fEmptyPage );
		}

	if ( pmergePath->fEmptyPage &&
		 FBTIUpdatablePage( pmergePath->csr ) )
		{
		//	set page flag to Empty
		//
		pmergePath->csr.Cpage().SetEmpty();
		}

	return;
	}


//	changes the key of a page pointer node to given key
//
VOID BTIChangeKeyOfPagePointer( FUCB *pfucb, CSR *pcsr, const KEY& key )
	{
	Assert( !pcsr->Cpage().FLeafPage() );

	NDGet( pfucb, pcsr );
	Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
	Assert( !pfucb->kdfCurr.key.FNull() );

	LittleEndian<PGNO>	le_pgno = *((UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv() );
	Assert( le_pgno != pgnoNull );

	//	delete node and re-insert with given key
	//
	NDDelete( pcsr );

	KEYDATAFLAGS	kdfInsert;

	kdfInsert.fFlags	= 0;
	kdfInsert.data.SetCb( sizeof( PGNO ) );
	kdfInsert.data.SetPv( &le_pgno );
	kdfInsert.key		= key;

	BTIComputePrefixAndInsert( pfucb, pcsr, kdfInsert );
	}


//	release latches on pages that are not required
//
VOID BTIMergeReleaseUnneededPages( MERGEPATH *pmergePathLeaf )
	{
	MERGEPATH 	*pmergePath;

	//	go to root
	//	release latches top-down
	//
	for ( pmergePath = pmergePathLeaf;
		  pmergePath->pmergePathParent != NULL;
		  pmergePath = pmergePath->pmergePathParent )
		{
		}

	Assert( NULL == pmergePath->pmergePathParent );
	for ( ; NULL != pmergePath;  )
		{

		//	check if page is needed
		//		-- either there is a merge/empty page at this level
		//		   or there is a merge/empty page one level below
		//				when we need write latch for deleting page pointer
		//		   or there is a key change at this level
		//
		MERGE	*pmerge = pmergePath->pmerge;

		if ( !pmergePath->fKeyChange &&
			 !pmergePath->fEmptyPage &&
			 !pmergePath->fDeleteNode &&
			 pmergePath->pmergePathChild != NULL )
			{
			Assert( NULL == pmergePath->pmergePathParent );

			//	release latch and pmergePath at this level
			//
			MERGEPATH *pmergePathT = pmergePath;

			Assert( !pmergePath->fDeleteNode );
			Assert( !pmergePath->fKeyChange );
			Assert( !pmergePath->fEmptyPage );
			Assert( !pmergePath->csr.Cpage().FLeafPage() );
			Assert( NULL != pmergePath->pmergePathChild );
			if ( mergetypeNone != pmergePathLeaf->pmerge->mergetype )
				{
				//	parent of merged or emptied page must not be released
				//
				Assert( pmergePath->pmergePathChild->pmergePathChild != NULL );
				Assert( !pmergePath->pmergePathChild->csr.Cpage().FLeafPage() );
				}
			Assert( pmergePath->csr.Latch() == latchRIW );

			pmergePath = pmergePath->pmergePathChild;

			//	release latches on these pages
			//
			BTIReleaseOneMergePath( pmergePathT );
			}
		else
			{
			pmergePath = pmergePath->pmergePathChild;
			}
		}
	}


//	upgrade to write latch on all pages invloved in the merge/emptypage
//
LOCAL ERR ErrBTIMergeUpgradeLatches( const IFMP ifmp, MERGEPATH * const pmergePathLeaf )
	{
	ERR				err;
	MERGEPATH 		* pmergePath;
	const DBTIME	dbtimeMerge		= rgfmp[ifmp].DbtimeIncrementAndGet();

	Assert( dbtimeMerge > 1 );
	Assert( PinstFromIfmp( ifmp )->m_plog->m_fRecoveringMode != fRecoveringRedo );

	//	go to root
	//	since we need to latch top-down
	//
	for ( pmergePath = pmergePathLeaf;
		  pmergePath->pmergePathParent != NULL;
		  pmergePath = pmergePath->pmergePathParent )
		{
		}

	Assert( NULL == pmergePath->pmergePathParent );
	for ( ; NULL != pmergePath;  )
		{
		//	check if write latch is needed
		//		-- either there is a merge/empty page at this level
		//		   or there is a merge/empty page one level below
		//				when we need write latch for deleting page pointer
		//		   or there is a key change at this level
		//
		MERGE	*pmerge = pmergePath->pmerge;

		if ( pmergePath->fKeyChange ||
			 pmergePath->fEmptyPage ||
			 pmergePath->fDeleteNode ||
			 pmergePath->pmergePathChild == NULL )
			{
			Assert( latchWrite != pmergePath->csr.Latch() );

			if ( pmergePath->pmergePathChild == NULL )
				{
				//	leaf-level
				//	write latch left, current and right pages in order
				//
				Assert( NULL != pmerge );
				Assert( mergetypeNone != pmerge->mergetype );
				Assert( pmergePath->csr.Cpage().FLeafPage() );

				pmerge->dbtimeLeftBefore = dbtimeNil;
				pmerge->dbtimeRightBefore = dbtimeNil;

				if ( pgnoNull != pmerge->csrLeft.Pgno() )
					{
					Assert( pmerge->csrLeft.Cpage().FLeafPage() );

					pmerge->csrLeft.UpgradeFromRIWLatch();

					if ( pmerge->csrLeft.Dbtime() < dbtimeMerge )
						{
						pmerge->dbtimeLeftBefore = pmerge->csrLeft.Dbtime();
						pmerge->csrLeft.CoordinatedDirty( dbtimeMerge );
						}
					else
						{
						FireWall();
						Call( ErrERRCheck( JET_errDbTimeCorrupted ) );
						}
					}

				if (	pmerge->mergetype == mergetypePartialRight ||
						pmerge->mergetype == mergetypeFullRight )
					{
					Assert( pgnoNull != pmerge->csrRight.Pgno() );

					//  depend the right page on the merge page so that the data
					//  moved from the merge page to the right page will always
					//  be available no matter when we crash

					Call( ErrBFDepend(	pmerge->csrRight.Cpage().PBFLatch(),
										pmergePath->csr.Cpage().PBFLatch() ) );
					}

				pmergePath->csr.UpgradeFromRIWLatch();

				if ( pmergePath->csr.Dbtime() < dbtimeMerge )
					{
					pmergePath->dbtimeBefore = pmergePath->csr.Dbtime();
					pmergePath->csr.CoordinatedDirty( dbtimeMerge );
					}
				else
					{
					FireWall();
					Call( ErrERRCheck( JET_errDbTimeCorrupted ) );
					}

				if ( pgnoNull != pmerge->csrRight.Pgno() )
					{
					Assert( pmerge->csrRight.Cpage().FLeafPage() );

					pmerge->csrRight.UpgradeFromRIWLatch();

					if ( pmerge->csrRight.Dbtime() < dbtimeMerge )
						{
						pmerge->dbtimeRightBefore = pmerge->csrRight.Dbtime();
						pmerge->csrRight.CoordinatedDirty( dbtimeMerge );
						}
					else
						{
						FireWall();
						Call( ErrERRCheck( JET_errDbTimeCorrupted ) );
						}
					}
				}
			else
				{
				Assert( !pmergePath->csr.Cpage().FLeafPage() );
				pmergePath->csr.UpgradeFromRIWLatch();

				if ( pmergePath->csr.Dbtime() < dbtimeMerge )
					{
					pmergePath->dbtimeBefore = pmergePath->csr.Dbtime();
					pmergePath->csr.CoordinatedDirty( dbtimeMerge );
					}
				else
					{
					FireWall();
					Call( ErrERRCheck( JET_errDbTimeCorrupted ) );
					}
				}

			pmergePath = pmergePath->pmergePathChild;
			}
		else
			{
			//	release latch and pmergePath at this level
			//
			AssertTracking();
			MERGEPATH *pmergePathT = pmergePath;

			Assert( !pmergePath->fDeleteNode );
			Assert( !pmergePath->fKeyChange );
			Assert( !pmergePath->fEmptyPage );
			Assert( !pmergePath->csr.Cpage().FLeafPage() );
			Assert( NULL != pmergePath->pmergePathChild );
			Assert( pmergePath->pmergePathChild->pmergePathChild != NULL );
			Assert( !pmergePath->pmergePathChild->csr.Cpage().FLeafPage() );
			Assert( pmergePath->csr.Latch() == latchRIW );

			pmergePath = pmergePath->pmergePathChild;

			//	UNDONE:	release latches on these pages
			//
			BTIReleaseOneMergePath( pmergePathT );
			}
		}

	return JET_errSuccess;

HandleError:
	Assert( err < 0 );
	BTIMergeRevertDbtime( pmergePathLeaf );
	return err;
	}


//	sets lgpos for every page involved in merge or empty page operation
//
VOID BTIMergeSetLgpos( MERGEPATH *pmergePathLeaf, const LGPOS& lgpos )
	{
	MERGEPATH	*pmergePath = pmergePathLeaf;

	for ( ; pmergePath != NULL && pmergePath->csr.Latch() == latchWrite;
		  pmergePath = pmergePath->pmergePathParent )
		{
		Assert( pmergePath->csr.FDirty() );

		pmergePath->csr.Cpage().SetLgposModify( lgpos );

		MERGE	*pmerge = pmergePath->pmerge;

		if ( pmerge != NULL )
			{
			if ( pmerge->csrLeft.Pgno() != pgnoNull )
				{
				Assert( pmerge->csrLeft.Cpage().FLeafPage() );
				pmerge->csrLeft.Cpage().SetLgposModify( lgpos );
				}

			if ( pmerge->csrRight.Pgno() != pgnoNull )
				{
				Assert( pmerge->csrRight.Cpage().FLeafPage() );
				pmerge->csrRight.Cpage().SetLgposModify( lgpos );
				}
			}
		}

#ifdef DEBUG
	for ( ; NULL != pmergePath; pmergePath = pmergePath->pmergePathParent )
		{
		Assert( pmergePath->csr.Latch() == latchRIW );
		}
#endif
	}


//	releases all latches held by merge or empty page operation
//
VOID BTIMergeReleaseLatches( MERGEPATH *pmergePathLeaf )
	{
	MERGEPATH	*pmergePath = pmergePathLeaf;

	for ( ; pmergePath != NULL; pmergePath = pmergePath->pmergePathParent )
		{
		Assert( pmergePath->csr.FLatched() );
		pmergePath->csr.ReleasePage();

		if ( pmergePath->pmerge != NULL )
			{
			if ( pmergePath->pmerge->csrLeft.FLatched() )
				{
				pmergePath->pmerge->csrLeft.ReleasePage();
				}

			if ( pmergePath->pmerge->csrRight.FLatched() )
				{
				pmergePath->pmerge->csrRight.ReleasePage();
				}
			}
		}
	}


//	release every page marked empty
//
VOID BTIReleaseEmptyPages( FUCB *pfucb, MERGEPATH *pmergePathLeaf )
	{
	MERGEPATH	*pmergePath = pmergePathLeaf;
	const BOOL	fAvailExt	= FFUCBAvailExt( pfucb );
	const BOOL	fOwnExt		= FFUCBOwnExt( pfucb );

	//	fake out cursor to make it think it's not a space cursor
	if ( fAvailExt )
		{
		Assert( !fOwnExt );
		FUCBResetAvailExt( pfucb );
		}
	else if ( fOwnExt )
		{
		FUCBResetOwnExt( pfucb );
		}
	Assert( !FFUCBSpace( pfucb ) );

	Assert( pmergePathLeaf->fEmptyPage ||
			mergetypePartialRight == pmergePathLeaf->pmerge->mergetype );
	Assert( !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	for ( ; pmergePath != NULL; pmergePath = pmergePath->pmergePathParent )
		{
		//	if empty page
		//		release space to FDP
		//
		Assert( !pmergePath->csr.FLatched() );
		if ( pmergePath->fEmptyPage )
			{

			//	space flags reset at the top of this function in order to fake out SPFreeExtent()
			Assert( !FFUCBSpace( pfucb ) );

			//	UNDONE:	track lost space because of inability
			//			to split availExt tree with the released space
			//
			//	UNDONE: we will leak the space if ErrSPFreeExt() fails
			//
			Assert( pmergePath->csr.Pgno() != PgnoRoot( pfucb ) );
			const ERR	errFreeExt	= ErrSPFreeExt( pfucb, pmergePath->csr.Pgno(), 1 );
#ifdef DEBUG
			if ( !FSPExpectedError( errFreeExt ) )
				{
				CallS( errFreeExt );
				}
#endif
			}
		}

	Assert( !FFUCBSpace( pfucb ) );
	if ( fAvailExt )
		{
		FUCBSetAvailExt( pfucb );
		}
	else if ( fOwnExt )
		{
		FUCBSetOwnExt( pfucb );
		}
	}


//	nullify every inactive flag-deleted version in page
//	delete node if flag-deleted with no active version
//
VOID BTIMergeDeleteFlagDeletedNodes( FUCB *pfucb, MERGEPATH *pmergePath )
	{
	SHORT		iline;
	CSR			*pcsr = &pmergePath->csr;

	if ( !FBTIUpdatablePage( *pcsr ) )
		{
		Assert( PinstFromIfmp( pfucb->ifmp )->FRecovering() );
		return;
		}
	Assert( latchWrite == pcsr->Latch() );

	Assert( pcsr->Cpage().FLeafPage() );
	Assert( pmergePath->pmergePathChild == NULL );

	const MERGE	*pmerge = pmergePath->pmerge;

	for ( iline = SHORT( pcsr->Cpage().Clines() - 1 ); iline >= 0; iline-- )
		{
		const LINEINFO	*plineinfo = &pmerge->rglineinfo[iline];

		pcsr->SetILine( iline );
		NDGet( pfucb, pcsr );

		if ( FNDDeleted( pfucb->kdfCurr ) )
			{
			if ( FNDVersion( pfucb->kdfCurr ) && !plineinfo->fVerActive )
				{
				BOOKMARK	bm;

				NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );

				VERNullifyInactiveVersionsOnBM( pfucb, bm );
				}
			}

		if ( mergetypePartialRight == pmerge->mergetype &&
			 pmerge->ilineMerge <= iline )
			{
			//	node has moved
			//
			NDDelete( pcsr );
			}
		}
	}


//	fix siblings of leaf page merged or emptied
//	to point to each other
//
VOID BTIMergeFixSiblings( INST *pinst, MERGEPATH *pmergePath )
	{
	MERGE	*pmerge = pmergePath->pmerge;

	Assert( !FBTIUpdatablePage( pmergePath->csr ) ||
			pmergePath->csr.Cpage().FLeafPage() );
	Assert( pmergePath->pmergePathChild == NULL );
	Assert( pmerge != NULL );

	if ( pmerge->csrLeft.Pgno() != pgnoNull &&
		 FBTIUpdatablePage( pmerge->csrLeft ) )
		{
		Assert( !FBTIUpdatablePage( pmergePath->csr ) ||
				pmergePath->csr.Cpage().PgnoPrev() != pgnoNull );
		Assert( pmerge->csrLeft.Latch() == latchWrite );
		Assert( pmerge->csrLeft.FDirty() );

		pmerge->csrLeft.Cpage().SetPgnoNext( pmerge->csrRight.Pgno() );
		}
	else if ( !pinst->FRecovering() )
		{
		Assert( pmergePath->csr.Cpage().PgnoPrev() == pgnoNull );
		}
	else
		{
		Assert( pgnoNull == pmerge->csrLeft.Pgno() &&
					( !FBTIUpdatablePage( pmergePath->csr ) ||
					  pgnoNull == pmergePath->csr.Cpage().PgnoPrev() ) ||
				!FBTIUpdatablePage( pmerge->csrLeft ) );
		}

	if ( pmerge->csrRight.Pgno() != pgnoNull &&
		 FBTIUpdatablePage( pmerge->csrRight ) )
		{
		Assert( !FBTIUpdatablePage( pmergePath->csr ) ||
				pmergePath->csr.Cpage().PgnoNext() != pgnoNull );
		Assert( pmerge->csrRight.Latch() == latchWrite );
		Assert( pmerge->csrRight.FDirty() );

		pmerge->csrRight.Cpage().SetPgnoPrev( pmerge->csrLeft.Pgno() );
		}
	else  if (!pinst->m_plog->m_fRecovering )
		{
		Assert( pmergePath->csr.Cpage().PgnoNext() == pgnoNull );
		}
	else
		{
		Assert( pgnoNull == pmerge->csrRight.Pgno() &&
					( !FBTIUpdatablePage( pmergePath->csr ) ||
					  pgnoNull == pmergePath->csr.Cpage().PgnoNext() ) ||
				!FBTIUpdatablePage( pmerge->csrRight ) );
		}
	}


//	move undeleted nodes >= ilineMerge from current page to right page
//	set cbUncommittedFree on right page
//
VOID BTIMergeMoveNodes( FUCB *pfucb, MERGEPATH *pmergePath )
	{
	CSR			*pcsrSrc = &pmergePath->csr;
	CSR			*pcsrDest = &pmergePath->pmerge->csrRight;
	MERGE		*pmerge = pmergePath->pmerge;
	INT			iline;
	const INT	clines = pmerge->clines;
	const INT	ilineMerge = pmerge->ilineMerge;

	if ( !FBTIUpdatablePage( *pcsrDest ) )
		{
		goto MoveUndoInfo;
		}
	Assert( latchWrite == pcsrDest->Latch() );

	Assert( FBTIUpdatablePage( *pcsrSrc ) );
	Assert( FBTIUpdatablePage( *pcsrDest ) );

	Assert( mergetypeFullRight == pmerge->mergetype ||
			mergetypePartialRight == pmerge->mergetype );
	Assert( 0 == pmerge->ilineMerge ||
			mergetypePartialRight == pmerge->mergetype );
	Assert( clines > ilineMerge );
	Assert( clines == pcsrSrc->Cpage().Clines() );
	Assert( NULL != pmerge );
	Assert( pmerge->csrRight.Pgno() != pgnoNull );
	Assert( pcsrSrc->Cpage().PgnoNext() == pcsrDest->Pgno() );
	Assert( pcsrDest->Cpage().PgnoPrev() == pcsrSrc->Pgno() );

	Assert( latchWrite == pmergePath->pmerge->csrRight.Latch() );

	pcsrDest->SetILine( 0 );
	for ( iline = clines - 1; iline >= ilineMerge; iline-- )
		{
		LINEINFO *plineinfo = &pmerge->rglineinfo[iline];

#ifdef DEBUG
		pcsrSrc->SetILine( iline );
		NDGet( pfucb, pcsrSrc );
///		Assert( pfucb->kdfCurr.fFlags == plineinfo->kdf.fFlags );
		Assert( FKeysEqual( pfucb->kdfCurr.key, plineinfo->kdf.key ) );
		Assert( FDataEqual( pfucb->kdfCurr.data, plineinfo->kdf.data ) );
#endif

		if ( FNDDeleted( plineinfo->kdf ) && !plineinfo->fVerActive )
			{
			continue;
			}

#ifdef DEBUG
		//	check cbPrefix
		//
		NDGetPrefix( pfucb, pcsrDest );
		const INT	cbCommon = CbCommonKey( pfucb->kdfCurr.key,
											plineinfo->kdf.key );
		if ( cbCommon > cbPrefixOverhead )
			{
			Assert( cbCommon == plineinfo->cbPrefix );
			}
		else
			{
			Assert( 0 == plineinfo->cbPrefix );
			}
#endif

		//	copy node to start of destination page
		//
		Assert( !FNDDeleted( plineinfo->kdf ) );
		Assert( pcsrDest->ILine() == 0 );
		NDInsert( pfucb, pcsrDest, &plineinfo->kdf, plineinfo->cbPrefix );
		}

	//	add uncommitted freed space caused by move to destination page
	//
	Assert( PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering ||
			pcsrDest->Cpage().CbUncommittedFree() +
				pmerge->cbSizeMaxTotal -
				pmerge->cbSizeTotal  ==
				pmerge->cbUncFreeDest );
	pcsrDest->Cpage().SetCbUncommittedFree( pmerge->cbUncFreeDest );

MoveUndoInfo:
	KEY		keySep;

	if ( mergetypePartialRight == pmerge->mergetype )
		{
		Assert( pmerge->ilineMerge > 0 );
		Assert( pmerge->fAllocParentSep );

		keySep = pmerge->kdfParentSep.key;
		}
	else
		{
		keySep.Nullify();
		}

	if ( FBTIUpdatablePage( *pcsrSrc ) )
		{
		VERMoveUndoInfo( pfucb, pcsrSrc, pcsrDest, keySep );
		}
	else
		{
		//	if we didn't need to redo the source page, we shouldn't need to redo the
		//	destination page
		Assert( !FBTIUpdatablePage( *pcsrDest ) );
		}
	return;
	}


//	checks merge/empty page operation
//
INLINE VOID BTICheckMerge( FUCB *pfucb, MERGEPATH *pmergePathLeaf )
	{
#ifdef DEBUG
	MERGEPATH	*pmergePath;

	//	check leaf level merge/empty page
	//
	BTICheckMergeLeaf( pfucb, pmergePathLeaf );

	//	check operation at internal levels
	//
	for ( pmergePath = pmergePathLeaf->pmergePathParent;
		  pmergePath != NULL;
		  pmergePath = pmergePath->pmergePathParent )
		{
		BTICheckMergeInternal( pfucb, pmergePath, pmergePathLeaf->pmerge );
		}
#endif
	}

//	checks merge/empty page operation at leaf-level
//
VOID BTICheckMergeLeaf( FUCB *pfucb, MERGEPATH *pmergePath )
	{
#ifdef DEBUG
	MERGE	*pmerge		= pmergePath->pmerge;
	CSR		*pcsr		= &pmergePath->csr;
	CSR		*pcsrRight	= &pmerge->csrRight;
	CSR		*pcsrLeft	= &pmerge->csrLeft;

	Assert( pmerge != NULL );

	MERGETYPE 		mergetype = pmerge->mergetype;
	const DBTIME	dbtime = pcsr->Dbtime();

	Assert( mergetypeFullRight == mergetype ||
			mergetypeEmptyPage == mergetype ||
			mergetypePartialRight == mergetype );
	Assert( pcsr->Cpage().FLeafPage() );
	Assert( pmergePath->pmergePathParent != NULL );
	Assert( pmergePath->pmergePathParent->csr.Dbtime() == dbtime );

	if ( mergetypeEmptyPage != mergetype )
		{
		Assert( latchWrite == pcsrRight->Latch() );
		Assert( pcsrRight->Pgno() != pgnoNull );
		}

	//	check sibling pages point to each other
	//
	if ( pmergePath->fEmptyPage )
		{
		Assert( pcsrRight->Pgno() != pcsr->Pgno() );
		if ( pcsrRight->Pgno() != pgnoNull )
			{
			Assert( pcsrRight->Dbtime() == dbtime );
			Assert( latchWrite == pcsrRight->Latch() );
			Assert( pcsrRight->Cpage().PgnoPrev() == pcsrLeft->Pgno() );
			}

		Assert( pcsrLeft->Pgno() != pcsr->Pgno() );
		if ( pcsrLeft->Pgno() != pgnoNull )
			{
			Assert( pcsrLeft->Dbtime() == dbtime );
			Assert( latchWrite == pcsrLeft->Latch() );
			Assert( pcsrLeft->Cpage().PgnoNext() == pcsrRight->Pgno() );
			}
		}

	//	check last node in left page has key less than page pointer
	//

	//	check first node in right page has key >= page pointer key
	//
#endif  //  DEBUG
	}


//	checks internal page after a merge/empty page operation
//
VOID BTICheckMergeInternal( FUCB 		*pfucb,
							MERGEPATH 	*pmergePath,
							MERGE 		*pmergeLeaf )
	{
#ifdef DEBUG
	Assert( pmergePath->pmerge == NULL );

	CSR 			*pcsr	= &pmergePath->csr;
	const SHORT 	clines	= SHORT( pcsr->Cpage().Clines() );
	const DBTIME	dbtime	= pcsr->Dbtime();

	Assert( !pcsr->Cpage().FLeafPage() );
	Assert( pcsr->Latch() == latchRIW
		|| pcsr->Dbtime() == dbtime );

	//	if empty page,
	//		return
	//
	if ( pmergePath->fEmptyPage )
		{
		Assert( pmergePath->csr.Cpage().Clines() == 1 );
		return;
		}

	Assert( pmergePath->pmergePathParent == NULL ||
			!pmergePath->pmergePathParent->fEmptyPage );

	if ( pmergePath->fKeyChange ||
		 pmergePath->fDeleteNode )
		{
		Assert( pcsr->Latch() == latchWrite );
		}
	else
		{
		//	UNDONE:	change this later to Assert( fFalse )
		//			since the page should be released
		//
///		Assert( pcsr->Latch() == latchRIW );
		Assert( fFalse );
		}

	//	for every node in page
	//	check that it does not point to an empty page
	//
	for ( SHORT iline = 0; iline < clines; iline++ )
		{
		pcsr->SetILine( iline );
		NDGet( pfucb, pcsr );

		Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
		PGNO pgnoChild = *( (UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv() );

		MERGEPATH	*pmergePathT = pmergeLeaf->pmergePath;
		Assert( pmergePathT->pmergePathChild == NULL );

		for ( ;
			  pmergePathT != NULL;
			  pmergePathT = pmergePathT->pmergePathParent )
			{
			if ( pmergePathT->fEmptyPage )
				{
				Assert( pgnoChild != pmergePathT->csr.Pgno() );
				}
			}
		}

	//	check last node in page has same key
	//	as parent pointer
	//
	if ( pmergePath->pmergePathParent == NULL )
		{
		//	if root page, check if last node is NULL-keyed
		//
		Assert( !pcsr->Cpage().FLeafPage() );

		pcsr->SetILine( pcsr->Cpage().Clines() - 1 );
		NDGet( pfucb, pcsr );

		Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
		Assert( !pcsr->Cpage().FRootPage() ||
				pfucb->kdfCurr.key.FNull() );

		return;
		}

	pcsr->SetILine( clines - 1 );
	NDGet( pfucb, pcsr );
	const KEYDATAFLAGS kdfLast = pfucb->kdfCurr;

	CSR		*pcsrParent = &pmergePath->pmergePathParent->csr;

	Assert( pcsrParent->Latch() == latchRIW
		|| pcsrParent->Dbtime() == dbtime );
	Assert( !pmergePath->pmergePathParent->fDeleteNode );
	pcsrParent->SetILine( pmergePath->pmergePathParent->iLine );
	NDGet( pfucb, pcsrParent );

	Assert( FKeysEqual( kdfLast.key, pfucb->kdfCurr.key ) );
#endif  //  DEBUG
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\callback.cxx ===
#include "std.hxx"

//  store an array of all the librarys we have open, close them at termination
//  we assume there will be a very small number of callback DLLs used so a relatively
//  poor memory allocation scheme is used

LOCAL const CHAR chSep 				= '!';	//  callbacks are of the form DLL!Function

struct LIBRARYMAP
	{
	char * 	szLibrary;
	LIBRARY	library;
	};

LOCAL INT			clibrary		= 0;
LOCAL LIBRARYMAP * 	rglibrarymap 	= NULL;

LOCAL CCriticalSection critCallback( CLockBasicInfo( CSyncBasicInfo( szCritCallbacks ), rankCallbacks, 0 ) );


//  ================================================================
ERR ErrCALLBACKInit()
//  ================================================================
	{
	clibrary = 0;
	rglibrarymap = NULL;
	return JET_errSuccess;
	}


//  ================================================================
VOID CALLBACKTerm()
//  ================================================================
//
//  Close all the module handles
//
//-
	{
	INT ilibrary;
	for( ilibrary = 0; ilibrary < clibrary; ++ilibrary )
		{
		UtilFreeLibrary( rglibrarymap[ilibrary].library );
		OSMemoryHeapFree( rglibrarymap[ilibrary].szLibrary );
		}
	OSMemoryHeapFree( rglibrarymap );
	}


//  ================================================================
LOCAL BOOL FCALLBACKISearchForLibrary( const char * const szLibrary, LIBRARY * plibrary )
//  ================================================================
	{
	//  see if the library is already loaded
	INT ilibrary;
	for( ilibrary = 0; ilibrary < clibrary; ++ilibrary )
		{
		if( 0 == _stricmp( szLibrary, rglibrarymap[ilibrary].szLibrary ) )
			{
			// this library is already loaded
			*plibrary = rglibrarymap[ilibrary].library;		
			return fTrue;
			}
		}
	return fFalse;
	}


//  ================================================================
ERR ErrCALLBACKResolve( const CHAR * const szCallback, JET_CALLBACK * pcallback )
//  ================================================================
	{	
	JET_ERR err = JET_errSuccess;
	Assert( pcallback );

	CHAR szCallbackT[JET_cbColumnMost+1+3];
	Assert( strlen( szCallback ) < sizeof( szCallbackT ) );

	ENTERCRITICALSECTION entercritcallback( &critCallback );

	//	do not use sizeof(szCallbackT) here because three characters
	//	are reserved in szCallbackT for '@32'.
	//
	if ( strlen( szCallback ) > JET_cbColumnMost )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		goto HandleError;
		}
	strcpy( szCallbackT, szCallback );
	const CHAR * const szLibrary = szCallbackT;
	CHAR * const pchSep = strchr( szCallbackT, chSep );
	CHAR * const szFunction = pchSep + 1;
	if( NULL == pchSep )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		goto HandleError;
		}
	*pchSep = 0;

	LIBRARY library;
	
	if( !FCALLBACKISearchForLibrary( szLibrary, &library ) )
		{
		if( FUtilLoadLibrary( szLibrary, &library, fGlobalEseutil ) )
			{
			//  we were able to load the library. allocate a new rglibrary array
			//
			//  swap the arrays so that threads not in the critical section
			//	can continue to traverse the array.
			//
			const INT clibraryT = clibrary + 1;
			LIBRARYMAP * const rglibrarymapOld = rglibrarymap;
			LIBRARYMAP * const rglibrarymapNew = (LIBRARYMAP *)PvOSMemoryHeapAlloc( clibraryT * sizeof( LIBRARYMAP ) );
			CHAR * const szLibraryT = (CHAR *)PvOSMemoryHeapAlloc( strlen( szLibrary ) + 1 );

			//	check for memory allocation failure
			//
			if( NULL == rglibrarymapNew || NULL == szLibraryT )
				{
				if( NULL != rglibrarymapNew )
					{
					OSMemoryHeapFree( rglibrarymapNew );
					}
				if( NULL != szLibraryT )
					{
					OSMemoryHeapFree( szLibraryT );
					}
				UtilFreeLibrary( library );
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
				
			strcpy( szLibraryT, szLibrary );
			memcpy( rglibrarymapNew, rglibrarymapOld, clibrary * sizeof( LIBRARYMAP ) );
			rglibrarymapNew[clibrary].szLibrary = szLibraryT;
			rglibrarymapNew[clibrary].library = library;
			
			Assert( rglibrarymapOld == rglibrarymap );
			Assert( clibraryT - 1 == clibrary );
			rglibrarymap = rglibrarymapNew;
			clibrary = clibraryT;
			if( NULL != rglibrarymapOld )
				{
				OSMemoryHeapFree( rglibrarymapOld );
				}
			}
		else
			{
			//  log the fact that we couldn't find the callback
			const CHAR *rgszT[1];
			rgszT[0] = szLibrary;
			UtilReportEvent( eventError, GENERAL_CATEGORY, FILE_NOT_FOUND_ERROR_ID, 1, rgszT );
			Call( ErrERRCheck( JET_errCallbackNotResolved ) );
			}
		}

	//  we now have the library
	*pcallback = (JET_CALLBACK)PfnUtilGetProcAddress( library, szFunction );
	if( NULL == *pcallback )
		{
		strcat( szFunction, "@32" );
		*pcallback = (JET_CALLBACK)PfnUtilGetProcAddress( library, szFunction );
		if( NULL == *pcallback )
			{	
			const CHAR *rgszT[2];
			rgszT[0] = szFunction;
			rgszT[1] = szLibrary;
			UtilReportEvent( eventError, GENERAL_CATEGORY, FUNCTION_NOT_FOUND_ERROR_ID, 2, rgszT );		
			Call( ErrERRCheck( JET_errCallbackNotResolved ) );
			}
		}

HandleError:
	return err;
	}


ERR VTAPI ErrIsamSetLS(
	JET_SESID		sesid,
	JET_VTID		vtid,
	JET_LS			ls,
	JET_GRBIT		grbit )
	{
	ERR				err;
 	PIB				*ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB			*pfucb		= reinterpret_cast<FUCB *>( vtid );
	const BOOL		fReset		= ( grbit & JET_bitLSReset );
	const LSTORE	lsT			= ( fReset ? JET_LSNil : ls );

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	if ( NULL == PinstFromPpib( ppib )->m_pfnRuntimeCallback )
		{
		return ErrERRCheck( JET_errLSCallbackNotSpecified );
		}

	if ( grbit & JET_bitLSTable )
		{
		if ( grbit & JET_bitLSCursor )
			{
			err = ErrERRCheck( JET_errInvalidGrbit );
			}
		else
			{
			err = pfucb->u.pfcb->ErrSetLS( lsT );
			}
		}
	else
		{
		err = ErrSetLS( pfucb, lsT );
		}

	return err;
	}

ERR VTAPI ErrIsamGetLS(
	JET_SESID		sesid,
	JET_VTID		vtid,
	JET_LS			*pls,
	JET_GRBIT		grbit )
	{
	ERR				err;
 	PIB				*ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB			*pfucb		= reinterpret_cast<FUCB *>( vtid );
	const BOOL		fReset		= ( grbit & JET_bitLSReset );

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	if ( grbit & JET_bitLSTable )
		{
		if ( grbit & JET_bitLSCursor )
			{
			err = ErrERRCheck( JET_errInvalidGrbit );
			}
		else
			{
			err = pfucb->u.pfcb->ErrGetLS( pls, fReset );
			}
		}
	else
		{
		err = ErrGetLS( pfucb, pls, fReset );
		}

	//	if successfully able to retrieve LS, there must be an associated callback
	Assert( err < 0 || NULL != PinstFromPpib( ppib )->m_pfnRuntimeCallback );

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\cres.cxx ===
#include "std.hxx"

#ifdef DEBUG
VOID CRES::DBGUpdateStat( BOOL fAlloc )
	{
	if ( fAlloc )
		{
		m_cBlockUsed++;
		if ( m_cBlockUsed > m_cBlockPeakUse )
			{
			m_cBlockPeakUse = m_cBlockUsed;
			}
		}
	else
		{
		m_cBlockUsed--;
		}
	}


VOID CRES::DBGPrintStat(  ) const
	{
	CHAR	*sz;
	
	static char *rgszName[] = {
		"FCB",
		"FUCB",
		"TDB",
		"IDB",
		"PIB",
		"SCB",
		"VER",
		};

	if ( ( sz = GetDebugEnvValue( (CHAR *)szVerbose ) ) != NULL )
		{
		DBGprintf( "%s resource %d allocated %d peak allocation.\n",
			rgszName[m_resid], m_cBlockUsed, m_cBlockPeakUse );

		OSMemoryHeapFree( sz );
		}
	}
#endif /* DEBUG */


CRES::CRES( INST *pinst, RESID resid, INT cbBlock, INT cBlocksAllocated, ERR *perr )
	:	m_crit( CLockBasicInfo( CSyncBasicInfo( szRES ), rankRES, 0 ) )
	{	
	ERR		err = JET_errSuccess;

	//	Check parameters
	
#if defined(_MIPS_) || defined(_ALPHA_) || defined(_M_PPC)
	Assert( cbBlock % 4 == 0 );
#endif

	Assert( IbAlignForAllPlatforms( cbBlock ) == cbBlock );
#ifdef PCACHE_OPTIMIZATION
	//
	//	the size of the allocated resource should be on a 32-byte boundary,
	//	for cache locality.
	//
#ifdef _WIN64
	//	UNDONE: cache alignment for 64 bit build
#else
	Assert( cbBlock == 16 || cbBlock % 32 == 0 );
#endif
#endif

	m_cbBlock = 0;
	m_cBlocksAllocated = 0;

#ifdef DEBUG
	m_cBlockUsed = 0;
	m_cBlockPeakUse = 0;
#endif

	m_cBlockAvail = 0;
	m_pbBlockAvail = NULL;
	m_cBlockCommit = 0;
	m_cBlockCommitThreshold = 0;
	m_iBlockToCommit = 0;
	m_pbPreferredThreshold = 0;
	
	m_pinst = pinst;

	//	allocate space for resources

	m_pbBlocksAllocated = static_cast<BYTE *>( PvOSMemoryPageReserve( cBlocksAllocated * cbBlock, NULL ) );

	//	if try to allocate more than zero and fail then out of memory

	if ( m_pbBlocksAllocated == NULL && cBlocksAllocated > 0 )
		{
		*perr = ErrERRCheck( JET_errOutOfMemory );
		return;
		}

	Assert( FAlignedForAllPlatforms( m_pbBlocksAllocated ) );
#ifdef PCACHE_OPTIMIZATION
	Assert( ( (ULONG) m_pbBlocksAllocated & 31 ) == 0 );
#endif

	//	Initialize other varialbes

	m_resid = resid;
	m_cbBlock = cbBlock;
	m_cBlocksAllocated = cBlocksAllocated;

	if ( resid == residVER )
		{
		m_cBlockCommitThreshold = m_cBlocksAllocated;
		m_iBlockToCommit = 0;
		}
	else
		m_pbPreferredThreshold = m_pbBlocksAllocated + m_cBlocksAllocated * m_cbBlock;


#ifdef GLOBAL_VERSTORE_MEMPOOL
	Assert( ( NULL != pinst && residVER != resid )	//	only version store not instanced
		|| ( NULL == pinst && residVER == resid ) );
#else
	Assert( NULL != pinst );						//	should be impossible -- all CRES are instanced
#endif

	*perr = JET_errSuccess;
	return;
	}


#ifdef MEM_CHECK
const _TCHAR szAssertFile[] 	= _T( "assert.txt" );

char rgszRESID[][5] =
	{
	"FCB",
	"FUCB",
	"TDB",
	"IDB",
	"PIB",
	"SCB",
	"VER"
	};
#endif  //  MEM_CHECK

CRES::~CRES( )
	{

	// nothing to do, we faild in the constructor
	// when allocating this
	if ( NULL == m_pbBlocksAllocated )
		return;

#ifdef MEM_CHECK
	//	dump stats to the debug stream

	DBGPrintStat();

	if ( g_fMemCheck )
		{
		if ( m_cbBlock < cbMemoryPage )
			{
			Assert( ( m_cBlockCommit - m_cBlockPeakUse ) * m_cbBlock <= cbMemoryPage );
			}
		else
			{
			Assert( m_cBlockCommit <= m_cBlockCommitThreshold  );
			}

		if ( ( ( NULL == m_pinst ) || 
			   ( m_pinst->m_fTermInProgress && !m_pinst->m_fTermAbruptly ) ) && 
			 m_cBlockUsed > 0 )
			{
			_TCHAR szT[80];
	
			DumpAlloc( szAssertFile );
			_stprintf( szT, _T( "%d %s not freed on resource pool destruction!" ), m_cBlockUsed, rgszRESID[m_resid] );
			EnforceSz( fFalse, szT );
			}
		}
#endif // MEM_CHECK

	Assert ( m_pbBlocksAllocated );
	OSMemoryPageDecommit( m_pbBlocksAllocated, m_cBlocksAllocated * m_cbBlock );
	OSMemoryPageFree( m_pbBlocksAllocated );
	m_pbBlocksAllocated = NULL;
	
	return;
	}


BYTE *CRES::PbAlloc( const char* szFile, unsigned long ulLine )
	{
	BYTE	*pb;

#ifdef RFS2
	switch ( m_resid )
		{
		case residFCB:
			if (!RFSAlloc( FCBAllocResource ) )
				return NULL;
			break;
		case residFUCB:
			if (!RFSAlloc( FUCBAllocResource ) )
				return NULL;
			break;
		case residTDB:
			if (!RFSAlloc( TDBAllocResource ) )
				return NULL;
			break;
		case residIDB:
			if (!RFSAlloc( IDBAllocResource ) )
				return NULL;
			break;
		case residPIB:
			if (!RFSAlloc( PIBAllocResource ) )
				return NULL;
			break;
		case residSCB:
			if (!RFSAlloc( SCBAllocResource ) )
				return NULL;
			break;
		case residVER:
			if (!RFSAlloc( VERAllocResource ) )
				return NULL;
			break;
		default:
			if (!RFSAlloc( UnknownAllocResource ) )
				return NULL;
			break;
		};
#endif

	m_crit.Enter();

	pb = m_pbBlockAvail;
	
	if ( pb != NULL )
		{
		m_cBlockAvail--;

		Assert( FAlignedForAllPlatforms( pb ) );
#ifdef PCACHE_OPTIMIZATION
#ifdef _WIN64
	//	UNDONE: cache alignment for 64 bit build
#else
		Assert( (ULONG)pb % 32 == 0 );
#endif
#endif
		m_pbBlockAvail = (BYTE *) ( (BLK*) pb)->pblkNext;

		Assert( FContains( pb ) );
		}
		
	Assert( m_cBlockCommit <= m_cBlocksAllocated );
	
	/*	commit new resource if have uncommitted available
	/**/
	if ( pb == NULL && m_cBlockCommit < m_cBlocksAllocated )
		{
		INT cBlock;

		/*	there must be at least 1 block left
		/**/

		if ( m_resid == residVER )
			{
			//	Allocate blocks circularly

			Assert( m_cbBlock > cbMemoryPage );
			cBlock = 1;
			pb = m_pbBlocksAllocated + ( m_iBlockToCommit * m_cbBlock );
			}
		else
			{
			/*	commit one pages of memory at a time
			/**/
			cBlock = ( ( ( ( ( ( m_cBlockCommit * m_cbBlock ) + cbMemoryPage - 1 )
				/ cbMemoryPage ) + 1 ) * cbMemoryPage )
				/ m_cbBlock ) - m_cBlockCommit - 1;
			Assert( cBlock > 0 && cBlock <= (LONG) ( cbMemoryPage/sizeof(BYTE *) ) );
			if ( cBlock > m_cBlocksAllocated - m_cBlockCommit )
				cBlock = m_cBlocksAllocated - m_cBlockCommit;
			
			pb = m_pbBlocksAllocated + ( m_cBlockCommit * m_cbBlock );
			}

		Assert( FAlignedForAllPlatforms( pb ) );
		
		if ( !FOSMemoryPageCommit( pb, cBlock * m_cbBlock ) )
			{
			//	UNDONE: log event.

			pb = NULL;
			}
		else
			{
			if ( m_resid == residVER )
				m_iBlockToCommit = ( m_iBlockToCommit + cBlock )
									% ( m_cBlocksAllocated + m_cBlockCommitThreshold );

			m_cBlockCommit += cBlock;

			/*	if surplus blocks, then link to resource
			/**/
			if ( cBlock > 1 )
				{
				BYTE	*pbLink		= pb + m_cbBlock;
				BYTE	*pbLinkMax	= pb + ( ( cBlock - 1 ) * m_cbBlock );

				Assert( m_pbBlockAvail == NULL );
				Assert( FAlignedForAllPlatforms( pbLink ) );
#ifdef PCACHE_OPTIMIZATION
#ifdef _WIN64
				//	UNDONE: cache alignment for 64 bit build
#else
				Assert( (ULONG)pbLink % 32 == 0 );
#endif
#endif
				m_pbBlockAvail = pbLink;
				m_cBlockAvail += cBlock - 1;

				/*	link surplus blocks into resource free list
				/**/
				for ( ; pbLink < pbLinkMax; pbLink += m_cbBlock )
					{
					Assert( FAlignedForAllPlatforms( pbLink + m_cbBlock ) );
					((BLK*)pbLink)->pblkNext = (BLK*)( pbLink + m_cbBlock );
					}
				((BLK*)pbLink)->pblkNext = NULL;
				}
			Assert( FContains( pb ) );
			}
		}
	else if ( pbNil == pb && residVER == m_resid && m_cBlockCommit == m_cBlocksAllocated )
		{
		// free list should be empty
		Assert( pbNil == m_pbBlockAvail );

		// This is simple because the block size is a multiple of the
		// page size, so we don't need to think about extra free blocks, etc.
		Assert( 0 == m_cbBlock % ::OSMemoryPageCommitGranularity() );
		pb = reinterpret_cast< BYTE* >( PvOSMemoryPageAlloc( m_cbBlock, NULL ) );
		// Valid to return NULL from this PbAlloc if unsuccessful

		if ( pbNil != pb )
			{
			Assert( ! FContains( pb ) );
			}
		}

#ifdef DEBUG
	/*	for setting break point:
	/**/
	if ( pb == NULL )
		pb = NULL;
	else
		{
		DBGUpdateStat( fTrue );

		/*	set resource space to 0xff
		/**/
		memset( pb, chCRESAllocFill, m_cbBlock );

		Assert( FAlignedForAllPlatforms( pb ) );
		}
#endif  //  DEBUG
	
	m_crit.Leave();

	InsertAlloc( pb, szFile, ulLine );
	return pb;
	}


VOID CRES::Release( BYTE *pb )
	{
	DeleteAlloc( pb );
#ifdef DEBUG
	memset( pb + sizeof(BLK), chCRESFreeFill, m_cbBlock - sizeof(BLK) );
#endif  //  DEBUG

	m_crit.Enter();

	DBGUpdateStat( fFalse );

	if ( m_resid == residVER )
		{
		// if block is outside reserve region
		if ( ! FContains( pb ) )
			{
			// decommit & return to OS
			::OSMemoryPageFree( pb );
			}
		else
			{			
			SIZE_T iBlock = ( pb - m_pbBlocksAllocated ) / m_cbBlock;

			//	if we are still within the range of threshold i.e.
			//	(m_iBlockToCommit - m_cBlockCommitThreshold) <= ibBlock < m_iBlockToCommit
			//	then we simply put it into the avail list.

			BOOL fWithinThresholdRange;
			if ( m_iBlockToCommit > m_cBlockCommitThreshold )
				{
				// regular non-wraparound case

				fWithinThresholdRange = (
					   ( m_iBlockToCommit - m_cBlockCommitThreshold ) <= iBlock
					&& iBlock < m_iBlockToCommit );
				}
			else
				{
				//	A wrap around case

				fWithinThresholdRange = (
					   ( ( m_cBlocksAllocated + m_cBlockCommitThreshold )
					   - ( m_iBlockToCommit - m_cBlockCommitThreshold ) ) <= iBlock
					|| iBlock < m_iBlockToCommit );
				}

			if ( !fWithinThresholdRange )
				{
				OSMemoryPageDecommit( pb, m_cbBlock );
				m_cBlockCommit--;
				}
			else
				{
				//	put to the head of avail list for next use.

				BLK *pblk = (BLK *) pb;
				BLK **ppblk = (BLK **) &m_pbBlockAvail;
				pblk->pblkNext = *ppblk;
				*ppblk = pblk;

				m_cBlockAvail++;
				}
			}
		}
	else if ( pb >= m_pbPreferredThreshold )
		{
		Assert( m_cbBlock < cbMemoryPage );
		Assert( pb < PbMax() );

		// We need to ensure that we first re-use resources below the
		// preferred threshold.

		BYTE	*pbT;
		BYTE	*pbLast = NULL;

		for ( pbT = m_pbBlockAvail;
			  pbT != NULL &&  pbT < m_pbPreferredThreshold;
			  pbT = (BYTE *)((BLK*)pbT)->pblkNext )
			{
			pbLast = pbT;
			}
			
		((BLK*)pb)->pblkNext = (BLK*)pbT;
		
		if ( pbLast != NULL )
			{
			Assert( ((BLK* )pbLast)->pblkNext == (BLK*)pbT );
			((BLK*)pbLast)->pblkNext = (BLK*)pb;
			}
		else
			{
			Assert( m_pbBlockAvail == pbT );
			m_pbBlockAvail = pb;
			}

		m_cBlockAvail++;	
		}
	else if ( pb != m_pbBlockAvail )
		{
		// Memory freed is below the preferred threshold, so just put it at
		// the head of the free list.

		((BLK*)pb)->pblkNext = (BLK*)m_pbBlockAvail;
		m_pbBlockAvail = pb;

		m_cBlockAvail++;
		}
	else
		{
		//	prevent double-free
		FireWall();
		}
	
	m_crit.Leave();
	}


#ifdef MEM_CHECK

#define icalMax 100001

struct CAL
	{
	VOID		*pv;
	ULONG		ulLine;
	const char	*szFile;
	};

CAL rgcal[icalMax] = { { NULL, 0, 0 } };
CCriticalSection critCAL( CLockBasicInfo( CSyncBasicInfo( szCALGlobal ), rankCALGlobal, 0 ) );

LONG CRES::LHash( const void * const pv )
	{
	return (LONG)(( DWORD_PTR( pv ) / m_cbBlock ) % icalMax);
	}

VOID CRES::DumpAlloc( const char* szDumpFile )
	{
	if ( !g_fMemCheck )
		{
		return;
		}
	INT		ical;

	CPRINTFFILE cprintf( szDumpFile );
	
	cprintf( "    Address             File(Line)\n" );
    cprintf( "    ==================  ==============================================================\n" );

	critCAL.Enter();
	for ( ical = 0; ical < icalMax; ical++ )
		{
		if ( rgcal[ical].pv == NULL )
			{
			continue;
			}
		else
			{
			cprintf(	"    0x%016I64X  %s(%d)\n",
						QWORD( rgcal[ical].pv ),
						rgcal[ical].szFile,
						rgcal[ical].ulLine );
			}
		}
	critCAL.Leave();
	}

VOID CRES::InsertAlloc( void* pv, const char* szFile, unsigned long ulLine )
	{
	if ( !g_fMemCheck )
		{
		return;
		}
	INT		icalHash 	= LHash( pv );
	INT		ical 		= icalHash;

	/*	do not track failed allocations
	/**/
	if ( pv == NULL )
		return;

	critCAL.Enter();
	do
		{
		if ( rgcal[ical].pv == NULL )
			{
			rgcal[ical].pv = pv;
			rgcal[ical].ulLine = ulLine;
			rgcal[ical].szFile = szFile;
			critCAL.Leave();
			return;
			}
		if ( ++ical == icalMax )
			{
			ical = 0;
			}
		}
	while ( ical != icalHash );
	critCAL.Leave();
	AssertSz( fFalse, "Insufficient entries to track current block allocations" );
	DumpAlloc( szAssertFile );
	}

VOID CRES::DeleteAlloc( void* pv )
	{
	if ( !g_fMemCheck )
		{
		return;
		}
	INT		icalHash 	= LHash( pv );
	INT		ical 		= icalHash;

	if ( pv == NULL )
		{
		return;
		}

	do
		{
		if ( rgcal[ical].pv == pv )
			{
			rgcal[ical].pv = NULL;
			return;
			}
		if ( ++ical == icalMax )
			{
			ical = 0;
			}
		}
	while ( ical != icalHash );
	AssertSz( fFalse, "Attempt to Release a bad block" );
	}

#endif  //  MEM_CHECK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\cpage.cxx ===
/*******************************************************************

A physical page consists of the page header, a
data array and, at the end of the page, a TAG array
Each TAG in the TAG array holds the length and location
of one data blob. The upper bits of the size and location
are used to hold the flags associated with the data
blob.

One TAG (TAG 0) is reserved for use as an external
header. The external view of the page does not include
this TAG so we must add an offset to each iLine that
we receive as an argument.

Insertions and deletions from the page may cause space
on the page to become fragmented. When there is enough
space on the page for an insertion or replacement but
not enough contigous space the data blobs on the page
are compacted, moving all the free space to the end of
the data array.

Insert/Replace routines expect there to be enough free
space in the page for their operation. 

It is possible to assign one CPAGE to another. e.g.
	CPAGE foo;
	CPAGE bar;
	...
	foo = bar;

There are two caveats:
*  The destination page (foo) must not be currently attached
   to a page, i.e. It must be new or have had Release*Latch()
   called on it.
*  The source page (bar) is destroyed in the process of copying.
   This is done to keep the semantics simple be ensuring that
   there is onlyever one copy of a page, and that every CPAGE
   maps to a unique resource and should be released.
i.e Assignment changes ownership -- like the auto_ptr<T> template

*******************************************************************/

#include "std.hxx"
	
//  ****************************************************************
//  CLASS STATICS
//  ****************************************************************

BOOL			CPAGE::fTested					= fFalse;
BFDirtyFlags	CPAGE::bfdfRecordUpgradeFlags	= bfdfUntidy;
SIZE_T			CPAGE::cbHintCache				= 0;
SIZE_T			CPAGE::maskHintCache			= 0;
DWORD_PTR*		CPAGE::rgdwHintCache			= NULL;


//	flag CPAGEs that are set up by LoadPage()
const DWORD_PTR	CPAGE::dwBFLContextForLoadPageOnly	= 1;


//  ****************************************************************
//  INTERNAL INLINE ROUTINES
//  ****************************************************************


//  ================================================================
BOOL CPAGE::TAG::CmpPtagIb( const TAG* ptag1, const TAG* ptag2 )
//  ================================================================
	{
	return ptag1->Ib() < ptag2->Ib();
	}


//  ================================================================
INLINE VOID CPAGE::TAG::SetIb( USHORT ib )
//  ================================================================
//
//  This sets the ib in a tag. The flags are left unchanged
//
//-
	{
	Assert( (ib & fMaskFlagsFromShort) == 0 );
#ifdef DEBUG_PAGE
	USHORT usFlags = FFlags();
#endif	//  DEBUG_PAGE

	USHORT ibT = ib_;			//	endian conversion
	ibT = (USHORT)(ibT & fMaskFlagsFromShort );	//  clear current ib
	ibT |= ib;						//  set new ib
	ib_ = ibT;
	
#ifdef DEBUG_PAGE
	Assert( Ib() == ib );
	Assert( FFlags() == usFlags );
#endif	//  DEBUG_PAGE
	}


//  ================================================================
INLINE VOID CPAGE::TAG::SetCb( USHORT cb )
//  ================================================================
//
//  Sets the cb in a tag. The flags are left unchanged
//
//-
	{
	Assert( (cb & fMaskFlagsFromShort) == 0 );
#ifdef DEBUG_PAGE
	USHORT usFlags = FFlags();
#endif	//  DEBUG_PAGE

	USHORT	cbT = cb_;			//	endian conversion
	cbT = (USHORT)(cbT & fMaskFlagsFromShort);	//  clear current cb
	cbT |= cb;						//  set new cb
	cb_ = cbT;

#ifdef DEBUG_PAGE
	Assert( Cb() == cb );
	Assert( FFlags() == usFlags );
#endif	//  DEBUG_PAGE	
	}


//  ================================================================
INLINE VOID CPAGE::TAG::SetFlags( USHORT fFlags )
//  ================================================================
//
//  Sets the flags in a TAG. The cb and ib are not changed.
//
//-
	{
#ifdef DEBUG_PAGE
	INT cbOld = Cb();
	INT ibOld = Ib();
#endif	//  DEBUG_PAGE

	USHORT cbT = cb_;			// endian conversion
	USHORT ibT = ib_;			// endian conversion
	cbT = (USHORT)( cbT & fMaskValueFromShort );
	ibT = (USHORT)( ibT & fMaskValueFromShort );
	cbT |= (fFlags << shfCbFlags) & fMaskFlagsFromShort;
	ibT |= (fFlags << shfIbFlags) & fMaskFlagsFromShort;
	cb_ = cbT;
	ib_ = ibT;
	
#ifdef DEBUG_PAGE
	Assert( FFlags() == fFlags );
	Assert( Cb() == cbOld );
	Assert( Ib() == ibOld );
#endif	//  DEBUG_PAGE
	}


//  ================================================================
INLINE INT CPAGE::CbDataTotal_( const DATA * rgdata, INT cdata ) const
//  ================================================================
//
//  Returns the total size of all elements in a DATA array
//
//-
	{
	Assert( rgdata );
	Assert( cdata >= 0 );

	INT cbTotal = 0;
	INT iline	= 0;
	for ( ; iline < cdata; iline++ )
		{
		cbTotal += rgdata[iline].Cb();
		}
	return cbTotal;
	}


//  ================================================================
INLINE INT CPAGE::CbContigousFree_( ) const
//  ================================================================
//
//  Returns the number of bytes available at the end of the last line
//  on the page. This gives the size of the largest item that can be
//  inserted without reorganizing
//
//-
	{
	INT cb = CbPageData() - ((PGHDR *)m_bfl.pv)->ibMicFree;	
	cb -= ((PGHDR *)m_bfl.pv)->itagMicFree * sizeof( CPAGE::TAG );
	return cb;
	}




//  ================================================================
INLINE VOID CPAGE::FreeSpace_( INT cb ) 
//  ================================================================
//
//  Creates the amount of contigous free space passed to it,
//  reorganizing if necessary.
//  If not enough free space can be created we Assert
//
//-
	{
	Assert ( cb <= ((PGHDR*)m_bfl.pv)->cbFree && cb > 0 );
	
	if ( CbContigousFree_( ) < cb )
		{
		ReorganizeData_( );
		}	
	
	Assert( CbContigousFree_( ) >= cb );
	}


//  ================================================================
INLINE VOID CPAGE::CopyData_( const TAG * ptag, const DATA * rgdata, INT cdata )
//  ================================================================
//
//  Copies the data array into the page location pointed to by the TAG
//
//-
	{
	Assert( ptag && rgdata );
	Assert( cdata > 0 );
	
	BYTE * pb = PbFromIb_( ptag->Ib() );
	INT ilineCopy = 0;
	for ( ; ilineCopy < cdata; ilineCopy++ )
		{
		memmove( pb, rgdata[ilineCopy].Pv(), rgdata[ilineCopy].Cb() );
		pb += rgdata[ilineCopy].Cb();
		}	
	
	Assert( PbFromIb_( ptag->Ib() + ptag->Cb() ) == pb );
	}


//  ****************************************************************
//  PUBLIC MEMBER FUNCTIONS 
//  ****************************************************************


#ifdef DEBUG
//  ================================================================
CPAGE::CPAGE( ) :
//  ================================================================
//
//  Sets the member variables to NULL values. In DEBUG we see if we
//  need to run the one-time checks
//
//-
		m_ppib( ppibNil ),
		m_ifmp( 0 ),
		m_pgno( pgnoNull )
	{
	m_bfl.pv		= NULL;
	m_bfl.dwContext	= NULL;
	}

//  ================================================================
CPAGE::~CPAGE( )
//  ================================================================
//
//  Empty destructor
//
//  OPTIMIZATION:  consider inlining this method
//
//-
	{
	//  the page should have been released
	Assert( FAssertUnused_( ) );
	}
#endif	// DEBUG


//  ================================================================
ERR CPAGE::ErrGetNewPage(	PIB * ppib,
							IFMP ifmp,
							PGNO pgno,
							OBJID objidFDP,
							ULONG fFlags,
							BFLatchFlags bflf )
//  ================================================================
//
//  Get and latch a new page buffer from the buffer manager. Initialize the new page.
//
//-
	{
	ASSERT_VALID( ppib );
	Assert( FAssertUnused_( ) );

	PGHDR *ppghdr;
	TAG * ptag;

	//  get the page
	ERR	err;
	Call( ErrBFWriteLatchPage( &m_bfl, ifmp, pgno, BFLatchFlags( bflf | bflfNew ) ) );

	//  set CPAGE member variables
	m_ppib = ppib;
	m_ifmp = ifmp;
	m_pgno = pgno;

#ifndef RTM
ReInit:
#endif	//	!RTM

	//  set the page header variables
	ppghdr = (PGHDR*)m_bfl.pv;
	ppghdr->fFlags				= fFlags;
	ppghdr->objidFDP			= objidFDP;
	ppghdr->cbFree				= (USHORT)CbPageData();
	ppghdr->cbUncommittedFree	= 0;
	ppghdr->ibMicFree			= 0;
	ppghdr->itagMicFree			= 0;
	ppghdr->pgnoNext			= pgnoNull;
	ppghdr->pgnoPrev			= pgnoNull;
	ppghdr->pgnoThis			= pgno;

	if ( PinstFromIfmp( ifmp )->m_plog->m_fRecoveringMode == fRecoveringRedo )
		{
		//	Set a small dbtime. This is purely for debug then real use.
		//	In redo mode, all the latched, dirtied pages' dbtime will be set again.

		ppghdr->dbtimeDirtied = 1;
		}
	else
		{
		///	dbTime will be updated by Dirty()
		///		UpdateDBTime_();
		}

	Assert( (ppghdr->cbFree + sizeof( PGHDR )) == g_cbPage ); 
	Assert( ppghdr->pgnoThis == pgno );

	// insert the line for the external header
	ppghdr->itagMicFree = ctagReserved;
	{
	USHORT cbFree = ppghdr->cbFree;		// endian conversion
	cbFree -= sizeof( CPAGE::TAG );
	ppghdr->cbFree = cbFree;
	}

	ptag = PtagFromItag_( 0 );
	ptag->SetIb( 0 );
	ptag->SetCb( 0 );
	ptag->SetFlags( 0 );

#ifndef RTM
	if( !fTested )
		{
		//  The first time we latch a new page, run the internal test
		err = ErrTest();
		if ( err < JET_errSuccess )
			{
			ReleaseWriteLatch();
			CallR( err );
			}
		CallS( err );
		memset( m_bfl.pv, 0, g_cbPage );
		fTested = fTrue;
		goto ReInit;
		}
#endif	//	!RTM

	SetFNewRecordFormat();
	
	Dirty( bfdfDirty );

	ASSERT_VALID( this );
#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE

HandleError:
	Assert( JET_errSuccess != err || FAssertWriteLatch( ) );
	return err;
	}


//  ================================================================
BOOL CPAGE::FLastNodeHasNullKey() const
//  ================================================================
	{
	const PGHDR * const	ppghdr	= (PGHDR*)m_bfl.pv;
	LINE				line;

	//	should only be called for internal pages
	Assert( FInvisibleSons() );

	//	must be at least one node on the page
	Assert( ppghdr->itagMicFree > ctagReserved );
	GetPtr( ppghdr->itagMicFree - ctagReserved - 1, &line );

	//	internal nodes can't be marked versioned or deleted
	Assert( !( line.fFlags & (fNDVersion|fNDDeleted) ) );

	return ( !( line.fFlags & fNDCompressed )
			&& cbKeyCount + sizeof(PGNO) == line.cb
			&& 0 == *(UnalignedLittleEndian<SHORT> *)line.pv );
	}


//  ================================================================
VOID CPAGE::SetAllFlags( INT fFlags )
//  ================================================================
	{
#ifdef DEBUG_PAGE
	ASSERT_VALID( this );
#endif	//	DEBUG_PAGE
	Assert( FAssertWriteLatch() || FAssertWARLatch() );

	for ( INT itag = ((PGHDR*)m_bfl.pv)->itagMicFree - 1; itag >= ctagReserved; itag-- )
		{
		TAG * const ptag = PtagFromItag_( itag );
		ptag->SetFlags( USHORT( ptag->FFlags() | fFlags ) );
		}

#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE
	}


//  ================================================================
VOID CPAGE::ResetAllFlags( INT fFlags )
//  ================================================================
	{
#ifdef DEBUG_PAGE
	ASSERT_VALID( this );
#endif	//	DEBUG_PAGE
	Assert( FAssertWriteLatch() || FAssertWARLatch() );

	for ( INT itag = ((PGHDR*)m_bfl.pv)->itagMicFree - 1; itag >= ctagReserved; itag-- )
		{
		TAG * const ptag = PtagFromItag_( itag );
		ptag->SetFlags( USHORT( ptag->FFlags() & ~fFlags ) );
		}

#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE
	}


//  ================================================================
VOID CPAGE::Dirty_( const BFDirtyFlags bfdf )
//  ================================================================
//
//  Tells the buffer manager that the page has been modified.
//  Checking the flags is cheaper than setting them (don't need a
//  critical section) so we check the flags to avoid setting them
//  redundantly.
//
//-
	{
#ifdef DEBUG_PAGE
	ASSERT_VALID( this );
#endif	//	DEBUG_PAGE
	Assert(	FAssertWriteLatch() ||
			FAssertWARLatch() );

	//  dirty the buffer.  if the page is in MSOShadow, make it filthy to force
	//  it to disk ASAP

	BFDirtyFlags bfdfT = bfdf;

	//	for the shadow catalog override changes and send them directly to disk
	
	if ( objidFDPMSOShadow == ((PGHDR*)m_bfl.pv)->objidFDP
		&& !PinstFromIfmp( m_ifmp )->m_plog->m_fRecovering
		&& rgfmp[ m_ifmp ].Dbid() != dbidTemp
		&& !fGlobalEseutil
		&& bfdfDirty == bfdf )
		{
		bfdfT = bfdfFilthy;
		}

	BFDirty( &m_bfl, bfdfT );

	//	We do not set pbf->lgposBegin0 until we update lgposModify.
	//	The reason is that we do not log deferred Begin0 until we issue
	//	the first log operation. Currently the sequence is
	//		Dirty -> Update (first) Op -> Log update Op -> update lgposModify and lgposStart
	//	Since we may not have lgposStart until the deferred begin0 is logged
	//	when the first Log Update Op is issued for this transaction.
	//
	//	During redo, since we do not log update op, so the lgposStart will not
	//	be logged, so we have to do it here (dirty).

	if ( rgfmp[ m_ifmp ].FLogOn() && PinstFromIfmp( m_ifmp )->m_plog->m_fRecoveringMode == fRecoveringRedo )
		{
		Assert( !PinstFromIfmp( m_ifmp )->m_plog->m_fLogDisabled );
		Assert( CmpLgpos( &m_ppib->lgposStart, &lgposMax ) != 0 );
		Assert( CmpLgpos( &m_ppib->lgposStart, &lgposMin ) != 0 );
		BFSetLgposBegin0( &m_bfl, m_ppib->lgposStart );
		}
	}


//  ================================================================
VOID CPAGE::ReorganizeAndZero( const CHAR chZero )
//  ================================================================
	{
#ifdef DEBUG_PAGE
	ASSERT_VALID( this );
#endif

	const PGHDR * const ppghdr = (PGHDR*)m_bfl.pv;

	//  fully compact the page if necessary
	if ( CbContigousFree_( ) != ppghdr->cbFree )
		{
///		ReorganizeData_();
		ZeroOutGaps_( chZero );
		}

	BYTE * const pbFree	= PbFromIb_( ppghdr->ibMicFree );
	memset( pbFree, chZero, CbContigousFree_() );
	}


//  ================================================================
ERR CPAGE::ErrCheckPage( CPRINTF * const pcprintf ) const
//  ================================================================
	{
	const PGHDR * const ppghdr = (PGHDR*)m_bfl.pv;
	
	if( ppghdr->cbFree > CbPageData() )
		{
		(*pcprintf)( "page corruption (%d): cbFree too large (%d bytes, expected no more than %d bytes)\r\n",
						ppghdr->pgnoThis, ppghdr->cbFree, CbPageData() );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

	if( (USHORT) ppghdr->cbUncommittedFree > (USHORT) ppghdr->cbFree )
		{
		(*pcprintf)( "page corruption (%d): cbUncommittedFree too large (%d bytes, cbFree is %d bytes)\r\n",
						ppghdr->pgnoThis, ppghdr->cbUncommittedFree, ppghdr->cbFree );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}
		
	if( ppghdr->ibMicFree > CbPageData() )
		{
		(*pcprintf)( "page corruption (%d): ibMicFree too large (%d bytes, expected no more than %d bytes)\r\n",
						ppghdr->pgnoThis, ppghdr->ibMicFree, CbPageData() );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

	if( ppghdr->itagMicFree >= ( g_cbPageMax / sizeof( TAG ) ) )
		{
		(*pcprintf)( "page corruption (%d): itagMicFree too large (%d bytes)\r\n",
						ppghdr->pgnoThis, ppghdr->itagMicFree );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

//	BYTE *rgbBuf = NULL;
//	BFAlloc( (VOID **)&rgbBuf );
//	TAG ** rgptag = (TAG **)rgbBuf;

	TAG * rgptagBuf[ g_cbPageMax / sizeof( TAG ) ];
	TAG ** rgptag = rgptagBuf;

	INT	cbTotal = 0;
	INT iptag 	= 0;
	INT itag 	= 0;
	for ( ; itag < ppghdr->itagMicFree; ++itag )
		{
		TAG * const ptag = PtagFromItag_( itag );
		if( ptag->Cb() < 0 )
			{
			(*pcprintf)( "page corruption (%d): TAG %d corrupted (cb = %d)\r\n",
							ppghdr->pgnoThis, itag, ptag->Cb() );
//			BFFree( rgbBuf );
			return ErrERRCheck( JET_errDatabaseCorrupted );
			}
		if ( 0 == ptag->Cb() )
			{
			continue;
			}
		if( ptag->Ib() < 0 )
			{
			(*pcprintf)( "page corruption (%d): TAG %d corrupted (cb = %d, ib = %d)\r\n",
							ppghdr->pgnoThis, itag, ptag->Cb(), ptag->Ib() );
//			BFFree( rgbBuf );
			return ErrERRCheck( JET_errDatabaseCorrupted );
			}

		if( ptag->Ib() + ptag->Cb() > ppghdr->ibMicFree )
			{
			(*pcprintf)( "page corruption (%d): TAG %d ends in free space (cb = %d, ib = %d, ibMicFree = %d)\r\n",
							ppghdr->pgnoThis, itag, ptag->Cb(), ptag->Ib(), ppghdr->ibMicFree );
//			BFFree( rgbBuf );
			return ErrERRCheck( JET_errDatabaseCorrupted );
			}
			
		cbTotal += ptag->Cb();
		rgptag[iptag++] = ptag;
		}
		
	const INT cptag = iptag;

	//  sort the array by ib
	
	sort( rgptag, rgptag + cptag, TAG::CmpPtagIb );

	//  work through the array, from smallest to second-largest, checking for overlaps
	
	for ( iptag = 0; iptag < cptag - 1; ++iptag )
		{
		const TAG * const ptag 			= rgptag[iptag];
		const TAG * const ptagNext 		= rgptag[iptag+1];

		Assert( ptag->Ib() < ptagNext->Ib() );
		
		if( ptag->Ib() + ptag->Cb() > ptagNext->Ib() )
			{
			(*pcprintf)( "page corruption (%d): TAG overlap ( [cb:%d,ib:%d] overlaps [cb:%d,ib:%d])\r\n",
						ppghdr->pgnoThis, 
						ptag->Cb(), ptag->Ib(), 
						ptagNext->Cb(), ptagNext->Ib() );
//			BFFree( rgbBuf );
			return ErrERRCheck( JET_errDatabaseCorrupted );
			}
		}

	if( ppghdr->cbFree > 0 && cptag > 1 )
		{
		//  ibMicFree may not be correct, but it should always be too larger
		//  ibMicFree becomes wrong if you have three nodes ABC and you delete
		//  B (doesn't change ibMicFree) and then you delete C (ibMicFree should
		//  point to the end of A, but points to the end of B)
		TAG * const ptag 			= rgptag[cptag-1];
		if( ppghdr->ibMicFree < ptag->Ib() + ptag->Cb() )
			{
			(*pcprintf)( "page corruption (%d): ibMicFree is wrong (got %d, expected %d)\r\n",
						ppghdr->pgnoThis, 
						ppghdr->ibMicFree,
						ptag->Cb() + ptag->Ib() );
//			BFFree( rgbBuf );
			return ErrERRCheck( JET_errDatabaseCorrupted );
			}
		}
		
	//  all space on the page should be accounted for
	
	const INT cbAccountedFor = cbTotal + ppghdr->cbFree + (ppghdr->itagMicFree * sizeof( CPAGE::TAG ));
	if( cbAccountedFor != CbPageData() )
		{
		(*pcprintf)( "page corruption (%d): space mismatch (%d bytes accounted for, %d bytes expected)\r\n",
						ppghdr->pgnoThis, cbAccountedFor, CbPageData() );
//		BFFree( rgbBuf );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

	//  make sure the page flags are coherent
	
	if( FIndexPage() && FPrimaryPage() )
		{
		(*pcprintf)( "page corruption (%d): corrupt flags (0x%x)\r\n", Pgno(), FFlags() );
//		BFFree( rgbBuf );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

	if( FLongValuePage() && FIndexPage() )
		{
		(*pcprintf)( "page corruption (%d): corrupt flags (0x%x)\r\n", Pgno(), FFlags() );
//		BFFree( rgbBuf );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

	if( FRepairedPage() )
		{
		(*pcprintf)( "page corruption (%d): repaired page (0x%x)\r\n", Pgno(), FFlags() );
//		BFFree( rgbBuf );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

	if( FEmptyPage() )
		{
		(*pcprintf)( "page corruption (%d): empty page (0x%x)\r\n", Pgno(), FFlags() );
//		BFFree( rgbBuf );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

//	BFFree( rgbBuf );

	return JET_errSuccess;
	}


	
//------------------------------------------------------------------
//  PRIVATE MEMBER FUNCTIONS 
//------------------------------------------------------------------



//  ================================================================
VOID CPAGE::Replace_( INT itag, const DATA * rgdata, INT cdata, INT fFlags )
//  ================================================================
//
//  Replace the specified line. Do not try to replace a line with data elsewhere on
//  the page -- a reorganization will destroy the pointers.
//
//-
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;

	Assert( itag >= 0 && itag < ppghdr->itagMicFree );
	Assert( rgdata );
	Assert( cdata > 0 );
	Assert( FAssertWriteLatch( ) );

	const USHORT	cbTotal = (USHORT)CbDataTotal_( rgdata, cdata );
	Assert( cbTotal >= 0 );

	TAG * const ptag	= PtagFromItag_( itag );
	Assert ( rgdata[0].Pv() != PbFromIb_( ptag->Ib() ) );
	
	const SHORT	cbDiff	= (SHORT)((INT)ptag->Cb() - (INT)cbTotal);	//  shrinking if cbDiff > 0

	//  we should have enough space
	Assert ( cbDiff > 0 || -cbDiff <= ppghdr->cbFree );

	if (	cbDiff >= 0 ||
			(	PbFromIb_( ptag->Ib() ) + ptag->Cb() == PbFromIb_( ppghdr->ibMicFree ) &&
				CbContigousFree_( ) >= -cbDiff ) )
		{

		//  we are either shrinking or we are the last node on the page and there is enough space at the end
		//  of the page for us to grow. the node stays where it is
		if ( ptag->Ib() + ptag->Cb() == ppghdr->ibMicFree )
			{
			ppghdr->ibMicFree = USHORT( ppghdr->ibMicFree - cbDiff );
			}
		ppghdr->cbFree = USHORT( ppghdr->cbFree + cbDiff );
		}
	else
		{

		//  GROWING. we will be moving the line
		//  delete the current line in preparation
		USHORT cbFree = (USHORT)( ppghdr->cbFree + ptag->Cb() );
		ppghdr->cbFree = cbFree;
		ptag->SetIb( 0 );
		ptag->SetCb( 0 );
		ptag->SetFlags( 0 );

#ifdef DEBUG
		//  we cannot have a pointer to anything on the page because we may reorganize the page
		INT idata = 0;
		for ( ; idata < cdata; ++idata )
			{
			Assert( FAssertNotOnPage_( rgdata[idata].Pv() ) );
			}
#endif	//  DEBUG

#ifdef DEBUG_PAGE_SHAKE
		//  force a reorganization
		DebugMoveMemory_();
#endif	//	DEBUG_PAGE_SHAKE

		FreeSpace_( cbTotal );

		ptag->SetIb( ppghdr->ibMicFree );
		ppghdr->ibMicFree = USHORT( ppghdr->ibMicFree + cbTotal );
		ppghdr->cbFree = USHORT( ppghdr->cbFree - cbTotal );
		}
	ptag->SetCb( cbTotal );
	ptag->SetFlags( (USHORT)fFlags );

	CopyData_ ( ptag, rgdata, cdata );

#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE
	}


//  ================================================================
VOID CPAGE::ReplaceFlags_( INT itag, INT fFlags )
//  ================================================================
	{
	Assert( itag >= 0 && itag < ((PGHDR*)m_bfl.pv)->itagMicFree );
	Assert( FAssertWriteLatch() || FAssertWARLatch() );

	TAG * const ptag = PtagFromItag_( itag );
	ptag->SetFlags( (USHORT)fFlags );

#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE
	}


//  ================================================================
VOID CPAGE::Insert_( INT itag, const DATA * rgdata, INT cdata, INT fFlags )
//  ================================================================
//
//  Insert a new line into the page, reorganizing if necessary. If we are
//  inserting at a location where a line exists it will be moved up.
//
//-
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	
	Assert( itag >= 0 && itag <= ppghdr->itagMicFree );
	Assert( rgdata );
	Assert( cdata > 0 );
	Assert( FAssertWriteLatch( ) );

	const USHORT cbTotal = (USHORT)CbDataTotal_( rgdata, cdata );
	Assert( cbTotal >= 0 );

#ifdef DEBUG_PAGE
	//  we cannot have a pointer to anything on the page because we may reorganize the page
	INT idata = 0;
	for ( ; idata < cdata; ++idata )
		{
		Assert( FAssertNotOnPage_( rgdata[idata].pv ) );
		}
#endif	//  DEBUG

	FreeSpace_( cbTotal + sizeof( CPAGE::TAG ) );

	//  expand the tag array and make room
	copy(
		PtagFromItag_( ppghdr->itagMicFree-1 ) ,
		PtagFromItag_( itag-1 ),
		PtagFromItag_( ppghdr->itagMicFree ) );
	ppghdr->itagMicFree = USHORT( ppghdr->itagMicFree + 1 );
///	ShiftTagsUp_( itag );

	TAG * const ptag = PtagFromItag_( itag );
	ptag->SetCb( 0 );
	ptag->SetIb( 0 );
	ptag->SetFlags( 0 );

	ptag->SetIb( ppghdr->ibMicFree );
	ppghdr->ibMicFree = USHORT( ppghdr->ibMicFree + cbTotal );
	ptag->SetCb( cbTotal );
	const USHORT cbFree =	(USHORT)(ppghdr->cbFree - ( cbTotal + sizeof( CPAGE::TAG ) ) );
	ppghdr->cbFree = cbFree;
	ptag->SetFlags( (USHORT)fFlags );

	CopyData_ ( ptag, rgdata, cdata );

#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE
	}


//  ================================================================
VOID CPAGE::Delete_( INT itag )
//  ================================================================
//
//  Delete a line, freeing its space on the page
//
//-
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	
	Assert( itag >= ctagReserved && itag < ppghdr->itagMicFree );	// never delete the external header
	Assert( FAssertWriteLatch( ) );

	const TAG * const ptag = PtagFromItag_( itag );
	
	//  reclaim the free space if it is at the end
	if ( (ptag->Cb() + ptag->Ib()) == ppghdr->ibMicFree )
		{
		const USHORT ibMicFree = (USHORT)( ppghdr->ibMicFree - ptag->Cb() );
		ppghdr->ibMicFree = ibMicFree;
		}

	//  do this before we trash the tag
	
	const USHORT cbFree =	(USHORT)( ppghdr->cbFree + ptag->Cb() + sizeof( CPAGE::TAG ) );
	ppghdr->cbFree = cbFree;

	
///	ShiftTagsDown_( itag );
	ppghdr->itagMicFree = USHORT( ppghdr->itagMicFree - 1 );
	copy_backward(
		PtagFromItag_( ppghdr->itagMicFree ),
		PtagFromItag_( itag ),
		PtagFromItag_( itag-1 ) ); 

#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE
	}


//  ================================================================
INLINE VOID CPAGE::ReorganizeData_( )
//  ================================================================
//
//  Compact the data on the page to be contigous on the lower end of
//  the page. Sort the tags ( actually an array of pointers to TAGS -
//  we cannot reorder the tags on the page) by ib and move the lines
//  down, from first to last.
//
//  OPTIMIZATION:  searching the sorted array of tags for a gap of the right size
//  OPTIMIZATION:  sort an array of itags (2-bytes), not TAG* (4 bytes)
//  OPTIMIZATION:  try to fill gaps with a tag of the appropriate size from the end
//
//-
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	
#ifdef DEBUG_PAGE_REORGANIZE
	// store a copy of the page
	BYTE rgbPage[g_cbPageMax];
	UtilMemCpy( rgbPage, m_bfl.pv, g_cbPage );
	CPAGE cpageT;
	cpageT.m_ppib	= m_ppib;
	cpageT.m_ifmp	= m_ifmp;
	cpageT.m_pgno	= m_pgno;
	cpageT.m_bfl.pv	= rgbPage;
#endif	// DEBUG_PAGE_REORGANIZE

	Assert( ppghdr->itagMicFree > 0 );
	Assert( 0 != ppghdr->cbFree );	// we should have space if we are to reorganize
	
	//  create a temporary array for the tags every tag except the external header
	//  must have at least two bytes of data and there must be at least one empty byte

	BYTE *rgbBuf;
	BFAlloc( (VOID **)&rgbBuf );
	TAG ** rgptag = (TAG **)rgbBuf;

//	TAG * rgptagBuf[ ( g_cbPageMax / ( cbNDNullKeyData ) ) + 1 ];
//	TAG ** rgptag = rgptagBuf;

	//  find all non-zero length tags and put them in the temporary array
	//  only the external header can be zero-length so we check for that
	//  case separately (for speed)
	INT iptag 	= 0;
	INT itag	= 0;
	for ( ; itag < ppghdr->itagMicFree; ++itag )
		{
		TAG * const ptag = PtagFromItag_( itag );
		rgptag[iptag++] = ptag;
		}
		
	const INT cptag = iptag;
	Assert( iptag <= ppghdr->itagMicFree );

	//  sort the array
	sort( rgptag, rgptag + cptag, TAG::CmpPtagIb );

	//  work through the array, from smallest to largest, moving the tags down
	USHORT ibDest		= 0;
	BYTE * pbDest	= PbFromIb_( ibDest );
	for ( iptag = 0; iptag < cptag; ++iptag )
		{
		TAG * const ptag 			= rgptag[iptag];
		const BYTE * const pbSrc	= PbFromIb_( ptag->Ib() );
		
		Assert( pbSrc >= pbDest || ptag->Cb() == 0 );
		memmove( pbDest, pbSrc, ptag->Cb() );
		ptag->SetIb( ibDest );
		
		ibDest = (USHORT)( ibDest + ptag->Cb() );
		pbDest += ptag->Cb();
		}

	ppghdr->ibMicFree = ibDest;

	BFFree( rgbBuf );

#ifdef DEBUG_PAGE_REORGANIZE
	
	//  see that the copy we made has the same info as the current page
	INT itagT;
	for ( itagT = 0; itagT < ppghdr->itagMicFree; ++itagT )
		{
		const TAG * const ptagOld = cpageT.PtagFromItag_( itagT );
		const TAG * const ptagNew = PtagFromItag_( itagT );
		Assert( ptagOld != ptagNew );
		Assert( ptagOld->Cb() == ptagNew->Cb() );
		Assert( cpageT.PbFromIb_( ptagOld->Ib() ) != PbFromIb_( ptagNew->Ib() ) );
		Assert( memcmp(	cpageT.PbFromIb_( ptagOld->Ib() ), PbFromIb_( ptagNew->Ib() ),
				ptagNew->Cb() ) == 0 );  
		}
	cpageT.m_ppib	= ppibNil;
	cpageT.m_ifmp	= 0;
	cpageT.m_pgno	= pgnoNull
	cpageT.m_bfl.pv	= NULL;
	DebugCheckAll( );
#endif	//  DEBUG_PAGE_REORGANIZE
	}

//  ================================================================
INLINE VOID CPAGE::ZeroOutGaps_( const CHAR chZero )
//  ================================================================
//
	//	Code has been cut-and-pasted from ReorganizeData_() above, then
	//	modified slightly to zero out gaps instead of filling them in
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	
#ifdef DEBUG_PAGE_REORGANIZE
	// store a copy of the page
	BYTE rgbPage[g_cbPageMax];
	UtilMemCpy( rgbPage, m_bfl.pv, g_cbPage );
	CPAGE cpageT;
	cpageT.m_ppib	= m_ppib;
	cpageT.m_ifmp	= m_ifmp;
	cpageT.m_pgno	= m_pgno;
	cpageT.m_bfl.pv	= rgbPage;
#endif	// DEBUG_PAGE_REORGANIZE

	Assert( ppghdr->itagMicFree > 0 );
	Assert( 0 != ppghdr->cbFree );	// we should have space if we are to reorganize
	
	//  create a temporary array for the tags every tag except the external header
	//  must have at least two bytes of data and there must be at least one empty byte

	BYTE *rgbBuf;
	BFAlloc( (VOID **)&rgbBuf );
	TAG ** rgptag = (TAG **)rgbBuf;

//	TAG * rgptagBuf[ ( g_cbPageMax / ( cbNDNullKeyData ) ) + 1 ];
//	TAG ** rgptag = rgptagBuf;

	//  find all non-zero length tags and put them in the temporary array
	//  only the external header can be zero-length so we check for that
	//  case separately (for speed)
	INT iptag 	= 0;
	INT itag	= 0;
	for ( ; itag < ppghdr->itagMicFree; ++itag )
		{
		TAG * const ptag = PtagFromItag_( itag );

		if ( ptag->Cb() > 0 )
			{
			rgptag[iptag++] = ptag;
			}
		}
		
	const INT cptag = iptag;
	Assert( iptag <= ppghdr->itagMicFree );

	//  sort the array
	sort( rgptag, rgptag + cptag, TAG::CmpPtagIb );

	//  work through the array, from smallest to largest, filling in gaps
	for ( iptag = 0; iptag < cptag - 1; ++iptag )
		{
		const TAG	* const ptag 			= rgptag[iptag];
		const TAG	* const ptagNext		= rgptag[iptag+1];
		BYTE		* const pbStartZeroing	= PbFromIb_( ptag->Ib() ) + ptag->Cb();
		const SIZE_T cbToZero				= PbFromIb_( ptagNext->Ib() ) - pbStartZeroing;

		Assert( ptag->Ib() < ptagNext->Ib() );

		if ( cbToZero > 0 )
			{
			memset( pbStartZeroing, chZero, cbToZero );
			}
		else
			{
			//	UNDONE: How do we hit the case where ptag->Cb()==0?
			Assert( 0 == cbToZero );
			}
		}

	BFFree( rgbBuf );

#ifdef DEBUG_PAGE_REORGANIZE
	
	//  see that the copy we made has the same info as the current page
	INT itagT;
	for ( itagT = 0; itagT < ppghdr->itagMicFree; ++itagT )
		{
		const TAG * const ptagOld = cpageT.PtagFromItag_( itagT );
		const TAG * const ptagNew = PtagFromItag_( itagT );
		Assert( ptagOld != ptagNew );
		Assert( ptagOld->Cb() == ptagNew->Cb() );
		Assert( cpageT.PbFromIb_( ptagOld->Ib() ) == PbFromIb_( ptagNew->Ib() ) );
		Assert( memcmp(	cpageT.PbFromIb_( ptagOld->Ib() ), PbFromIb_( ptagNew->Ib() ),
				ptagNew->Cb() ) == 0 );  
		}
	cpageT.m_ppib	= ppibNil;
	cpageT.m_ifmp	= 0;
	cpageT.m_pgno	= pgnoNull;
	cpageT.m_bfl.pv	= NULL;
	DebugCheckAll( );
#endif	//  DEBUG_PAGE_REORGANIZE
	}

//------------------------------------------------------------------
//  TEST ROUTINE
//------------------------------------------------------------------


#ifndef RTM

//  ================================================================
ERR CPAGE::TAG::ErrTest()
//  ================================================================
	{
	TAG tag;
	TAG tag2;

	tag.SetIb( 0x0 );
	tag.SetCb( 0x0 );
	tag.SetFlags( 0x0 );
	AssertRTL( tag.Cb() == 0x0 );
	AssertRTL( tag.Ib() == 0x0 );
	AssertRTL( tag.FFlags() == 0x0 );

	tag2.SetIb( 0x0 );
	tag2.SetCb( 0x0 );
	tag2.SetFlags( 0x0 );
	AssertRTL( tag2.Cb() == 0x0 );
	AssertRTL( tag2.Ib() == 0x0 );
	AssertRTL( tag2.FFlags() == 0x0 );

	AssertRTL( CPAGE::TAG::CmpPtagIb( &tag, &tag2 ) == 0 );

	tag.SetIb( 0x2000 );
	tag.SetCb( 0x2000 );
	tag.SetFlags( 0x003F );
	AssertRTL( tag.Cb() == 0x2000 );
	AssertRTL( tag.Ib() == 0x2000 );
	AssertRTL( tag.FFlags() == 0x03F );

	AssertRTL( CPAGE::TAG::CmpPtagIb( &tag, &tag2 ) > 0 );
	AssertRTL( CPAGE::TAG::CmpPtagIb( &tag2, &tag ) < 0 );

	tag2.SetIb( 0x500 );
	tag2.SetCb( 0x1 );
	tag2.SetFlags( 0x0003 );
	AssertRTL( tag2.Cb() == 0x500 );
	AssertRTL( tag2.Ib() == 0x1 );
	AssertRTL( tag2.FFlags() == 0x0003 );

	AssertRTL( CPAGE::TAG::CmpPtagIb( &tag, &tag2 ) > 0 );
	AssertRTL( CPAGE::TAG::CmpPtagIb( &tag2, &tag ) < 0 );
	
	tag2.SetIb( 0xFFF );
	tag2.SetCb( 0xFFF );
	tag2.SetFlags( 0x0030 );
	AssertRTL( tag2.Cb() == 0xFFF );
	AssertRTL( tag2.Ib() == 0xFFF );
	AssertRTL( tag2.FFlags() == 0x0030 );

	tag2.SetIb( 0x123 );
	tag2.SetCb( 0x456 );
	tag2.SetFlags( 0x0002 );
	AssertRTL( tag2.Cb() == 0x123 );
	AssertRTL( tag2.Ib() == 0x456 );
	AssertRTL( tag2.FFlags() == 0x0002 );

	return JET_errSuccess;
	}


//  ================================================================
ERR CPAGE::ErrTest()
//  ================================================================
	{
	const INT cbMaxNodeOld = 4047 + 1;	// the node grows by one byte as we have a 2-byte key size
	const INT cbTestNode = 34;

	INT cb;
	INT ib;

	VOID * const pvBuffer = PvOSMemoryHeapAlloc( g_cbPage );
	if( NULL == pvBuffer )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	//  set the buffer to a known value
	for( ib = 0; ib < g_cbPage; ++ib )
		{
		((BYTE *)pvBuffer)[ib] = (BYTE)ib;
		}

	//  Check the constants
	AssertRTL( 0 == g_cbPage % cchDumpAllocRow );
	AssertRTL( sizeof( CPAGE::TAG ) == 4 );
	AssertRTL( g_cbPage - sizeof( PGHDR ) - sizeof( CPAGE::TAG ) >= cbMaxNodeOld );
	AssertRTL( CbPageData() >= cbMaxNodeOld );
	AssertRTL( ctagReserved > 0 );		

	//  This should be an empty page
	AssertRTL( 0x0 == Clines() );
	AssertRTL( 0x0 == CbUncommittedFree() );
	
	SetPgnoNext( 0x1234 );
	AssertRTL( PgnoNext() == 0x1234 );
	SetPgnoPrev( 0x87654321 );
	AssertRTL( PgnoPrev() == 0x87654321 ); 
	SetPgnoNext( 0x0 );
	AssertRTL( PgnoNext() == 0x0 );
	SetPgnoPrev( 0x0 );
	AssertRTL( PgnoPrev() == 0x0 ); 

	SetFlags( fPageRoot | fPageLeaf | fPageLongValue );
	AssertRTL( ( fPageRoot | fPageLeaf | fPageLongValue ) == FFlags() );
	AssertRTL( FLeafPage() );
	AssertRTL( !FInvisibleSons() );
	AssertRTL( FRootPage() );
	AssertRTL( FFDPPage() );
	AssertRTL( !FEmptyPage() );
	AssertRTL( !FParentOfLeaf() );
	AssertRTL( !FSpaceTree() );
	AssertRTL( !FRepairedPage() );
	AssertRTL( FPrimaryPage() );
	AssertRTL( !FIndexPage() );
	AssertRTL( FLongValuePage() );
	AssertRTL( !FSLVAvailPage() );
	SetEmpty();
	AssertRTL( FLeafPage() );
	AssertRTL( !FInvisibleSons() );
	AssertRTL( FRootPage() );
	AssertRTL( FFDPPage() );
	AssertRTL( FEmptyPage() );
	AssertRTL( !FParentOfLeaf() );
	AssertRTL( !FSpaceTree() );
	AssertRTL( !FRepairedPage() );
	AssertRTL( FPrimaryPage() );
	AssertRTL( !FIndexPage() );
	AssertRTL( FLongValuePage() );
	AssertRTL( !FSLVAvailPage() );
	SetFlags( fPageRoot | fPageLeaf );
	AssertRTL( FPrimaryPage() );
	AssertRTL( !FIndexPage() );
	AssertRTL( !FLongValuePage() );
	AssertRTL( !FSLVAvailPage() );
	SetFlags( 0 );
	AssertRTL( 0 == FFlags() );

	SetCbUncommittedFree( 0x50 );
	AssertRTL( 0x50 == CbUncommittedFree() );
	AddUncommittedFreed( 0x25 );
	AssertRTL( 0x75 == CbUncommittedFree() );
	ReclaimUncommittedFreed( 0x10 );
	AssertRTL( 0x65 == CbUncommittedFree() );
	SetCbUncommittedFree( 0x0 );
	AssertRTL( 0x0 == CbUncommittedFree() );
	
	//  Test inserting one node of each size, up to the maximum
	
	for( cb = 1; cb < CbFree() - sizeof( CPAGE::TAG ); ++cb )
		{		
		DATA data;
		LINE line;
		LINE lineSav;
		
		data.SetPv( pvBuffer );
		data.SetCb( cb );
		
		Insert( 0, &data, 1, fNDVersion );
#ifdef DEBUG
		DebugCheckAll();
#endif	//	DEBUG
		
		GetPtr( 0, &lineSav );
		AssertRTL( lineSav.cb == cb );
		AssertRTL( 0 == memcmp( lineSav.pv, pvBuffer, cb ) );
		AssertRTL( fNDVersion == lineSav.fFlags );
		
		Replace( 0, &data, 1, fNDDeleted | fNDCompressed );
#ifdef DEBUG
		DebugCheckAll();
#endif	//	DEBUG

		//  The replace didn't change the size of the node so it shouldn't have moved
		GetPtr( 0, &line );
		AssertRTL( line.cb == cb );
		AssertRTL( line.pv == lineSav.pv );
		AssertRTL( ( fNDDeleted | fNDCompressed ) == line.fFlags );
		
		Delete( 0 );
#ifdef DEBUG
		DebugCheckAll();
#endif	//	DEBUG
		AssertRTL( 0x0 == Clines() );
		}
		
	OSMemoryHeapFree( pvBuffer );
	return JET_errSuccess;
	}

#endif	//	!RTM


//  Page Hint Cache

//  ================================================================
ERR CPAGE::ErrGetPageHintCacheSize( ULONG_PTR* const pcbPageHintCache )
//  ================================================================
	{
	*pcbPageHintCache = ( maskHintCache + 1 ) * sizeof( DWORD_PTR );
	return JET_errSuccess;
	}

//  ================================================================
ERR CPAGE::ErrSetPageHintCacheSize( const ULONG_PTR cbPageHintCache )
//  ================================================================
	{
	//  clip the requested size to the valid range
	
	const SIZE_T cbPageHintCacheMin = 128;
	const SIZE_T cbPageHintCacheMax = cbHintCache;

	SIZE_T	cbPageHintCacheVal	= cbPageHintCache;
			cbPageHintCacheVal	= max( cbPageHintCacheVal, cbPageHintCacheMin );
			cbPageHintCacheVal	= min( cbPageHintCacheVal, cbPageHintCacheMax );

	//  round the validated size up to the next power of two

	for (	SIZE_T cbPageHintCacheSet = 1;
			cbPageHintCacheSet < cbPageHintCacheVal;
			cbPageHintCacheSet *= 2 );

	//  set the new utilized size of the page hint cache to the new size if it
	//  has grown by a power of two or shrunk by two powers of two.  we try to
	//  minimize size changes as they invalidate the contents of the cache

	if (	maskHintCache < cbPageHintCacheSet / sizeof( DWORD_PTR ) - 1 ||
			maskHintCache > cbPageHintCacheSet / sizeof( DWORD_PTR ) * 2 - 1 )
		{
		maskHintCache = cbPageHintCacheSet / sizeof( DWORD_PTR ) - 1;
		}

	return JET_errSuccess;
	}


//  ================================================================
ERR CPAGE::ErrInit()
//  ================================================================
	{
	ERR err;
	
	//  allocate the hint cache.  the hint cache is a direct map cache
	//  used to store BFLatch hints for the page pointer of each node
	//  in each internal page
	//
	//  NOTE:  due to the fact that this is a direct map cache, it is not
	//  possible to guarantee the consistency of an entire BFLatch structure.
	//  as a result, we only store the dwContext portion of the BFLatch.  the
	//  buffer manager recomputes the other parts of the BFLatch on a hit.
	//  this helps the cache as it allows it have a higher hint density

	ULONG_PTR cbfCacheMax;
	CallS( ErrBFGetCacheSizeMax( &cbfCacheMax ) );
	if ( cbfCacheMax == lCacheSizeDefault )
		{
		cbfCacheMax = ULONG_PTR( QWORD( min( OSMemoryPageReserveTotal(), OSMemoryTotal() ) ) / g_cbPage );
		}

	const SIZE_T cbPageHintCacheMin = OSMemoryPageCommitGranularity();
	const SIZE_T cbPageHintCacheMax = cbfCacheMax * sizeof( DWORD_PTR );

	SIZE_T	cbPageHintCache	= g_cbPageHintCache;
			cbPageHintCache	= max( cbPageHintCache, cbPageHintCacheMin );
			cbPageHintCache	= min( cbPageHintCache, cbPageHintCacheMax );

	for ( cbHintCache = 1; cbHintCache < cbPageHintCache; cbHintCache *= 2 );
	maskHintCache = cbPageHintCacheMin / sizeof( DWORD_PTR ) - 1;

	if ( !( rgdwHintCache = (DWORD_PTR*)PvOSMemoryPageAlloc( cbHintCache, NULL ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	return JET_errSuccess;

HandleError:
	Term();
	return err;
	}

//  ================================================================
VOID CPAGE::Term()
//  ================================================================
	{
	//  free the hint cache

	if ( rgdwHintCache )
		{
		OSMemoryPageFree( (void*) rgdwHintCache );
		rgdwHintCache = NULL;
		}
	}


//------------------------------------------------------------------
//  DEBUG/DEBUGGER_EXTENSION ROUTINES
//------------------------------------------------------------------


#if defined(DEBUGGER_EXTENSION) || defined(DEBUG)


//  ================================================================
INT	CPAGE::DumpAllocMap( CPRINTF * pcprintf )
//  ================================================================
//
//  Prints a 'map' of the page, showing how it is used.
//		H -- header
//		E -- external header
//		* -- data
//		T -- tag
//		. -- unused
//
//-
	{
	const INT cchBuf = g_cbPage;
	_TCHAR rgchBuf[g_cbPageMax];
	
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;

	INT ich = 0;
	for ( ; ich < cchBuf; ++ich )
		{
		//  we have to use a loop, not memset, so this will work with unicode
		rgchBuf[ich] = _T( '.' );
		}

	INT ichBase = 0;

	//  header
	ich = 0;
	for ( ; ich < sizeof( PGHDR ); ++ich )
		{
		rgchBuf[ich+ichBase] = _T( 'H' );
		}
	ichBase = ich;

	const TAG * const ptag = PtagFromItag_( 0 );
	Assert( ptag->Cb() < g_cbPage );
	Assert( ptag->Ib() < g_cbPage );
	ich = ptag->Ib();
	for ( ; ich < (ptag->Cb() + ptag->Ib()); ++ich )
		{
		rgchBuf[ich+ichBase] = _T( 'E' );
		}

	TAG * rgptagBuf[g_cbPageMax/sizeof(TAG)]; 
	TAG ** rgptag = rgptagBuf;

	INT iptag 	= 0;
	INT itag	= 1;
	for ( ; itag < ppghdr->itagMicFree; ++itag )
		{
		TAG * const ptagT = PtagFromItag_( itag );
		rgptag[iptag++] = ptagT;
		}
		
	const INT cptag = iptag;
	Assert( iptag <= ppghdr->itagMicFree );

	//  sort the array
	sort( rgptag, rgptag + cptag, TAG::CmpPtagIb );

	//  nodes
	for ( iptag = 0; iptag < ppghdr->itagMicFree - 1; ++iptag )
		{
		const TAG * const ptagT = rgptag[iptag];
		Assert( ptagT->Cb() < g_cbPage );
		Assert( ptagT->Ib() < g_cbPage );
		ich = ptagT->Ib();
		for ( ; ich < (ptagT->Cb() + ptagT->Ib()); ++ich )
			{
			rgchBuf[ich+ichBase] = ( iptag % 2 ) ? _T( '%' ) : _T( '#' );
			}
		}

	//  tags
	ichBase = g_cbPage;
	ichBase -= sizeof( CPAGE::TAG ) * ppghdr->itagMicFree;

	ich = 0;
	for ( ; ich < (INT)(sizeof( CPAGE::TAG ) * ppghdr->itagMicFree); ++ich )
		{
		rgchBuf[ich+ichBase] = _T( 'T' );
		}

	// print the map
	INT iRow = 0;
	for ( ; iRow < g_cbPage/cchDumpAllocRow; ++iRow )
		{
		_TCHAR rgchLineBuf[cchDumpAllocRow+1+1];
		UtilMemCpy( rgchLineBuf, &(rgchBuf[iRow*cchDumpAllocRow]), cchDumpAllocRow * sizeof( _TCHAR ) );
		rgchLineBuf[cchDumpAllocRow] = _T( '\n' );
		rgchLineBuf[cchDumpAllocRow+1] = 0;
		(*pcprintf)( "%s", rgchLineBuf );
		}
	(*pcprintf)( _T( "\n" ) );

	return 0;
	}


//  ================================================================
INT	CPAGE::DumpTags( CPRINTF * pcprintf, DWORD_PTR dwOffset )
//  ================================================================
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	
	INT itag = 0;
	for ( ; itag < ppghdr->itagMicFree; ++itag )
		{
		const TAG * const ptag = PtagFromItag_( itag );
		if( 0 == dwOffset )
			{
			(*pcprintf)( _T( "TAG %3d    cb:0x%04x    ib:0x%04x    offset:0x%04x-0x%04x    flags:0x%04x" ),
					 itag, 
					 ptag->Cb(),
					 ptag->Ib(),
					 ptag->Ib() + sizeof(PGHDR),
					 ptag->Ib() + sizeof(PGHDR) + ptag->Cb() - 1,
					 ptag->FFlags() );
			}
		else
			{
			const DWORD_PTR		dwAddress = reinterpret_cast<DWORD_PTR>( PbFromIb_( ptag->Ib() ) ) + dwOffset;
			(*pcprintf)( _T( "TAG %3d    address:0x%p-0x%p    cb:0x%04x    ib:0x%04x    flags:0x%04x" ),
					 itag,
					 dwAddress,
					 dwAddress + ptag->Cb() - 1,
					 ptag->Cb(),
					 ptag->Ib(),
					 ptag->FFlags() );
			}
		if( 0 != ptag->FFlags() )
			{
			(*pcprintf)( " (" );
			if( ptag->FFlags() & fNDVersion )
				{
				(*pcprintf)( "v" );
				}
			if( ptag->FFlags() & fNDDeleted )
				{
				(*pcprintf)( "d" );
				}
			if( ptag->FFlags() & fNDCompressed )
				{
				(*pcprintf)( "c" );
				}
			(*pcprintf)( ")" );
			}
		(*pcprintf)( "\n" );
		}
	if ( 0 == ppghdr->itagMicFree )
		{
		(*pcprintf)( _T( "Empty page\n" ) );
		}
	(*pcprintf)( _T( "\n" ) );
	return 0;
	}


//  ================================================================
INT	CPAGE::DumpHeader( CPRINTF * pcprintf, DWORD_PTR dwOffset )
//  ================================================================
//
//  Print the header of the page.
//
//-
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;

	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, pgnoThis, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, objidFDP, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, ulChecksumParity, dwOffset ) );
	
	const ULONG ulChecksumComputed = UlUtilChecksum( reinterpret_cast<const BYTE *>( m_bfl.pv ), g_cbPage );
	if( ulChecksumComputed != ppghdr->ulChecksumParity )
		{
		(*pcprintf)(
			_T( "\t** computed checksum: %u (0x%8.8x)\n" ),
			ulChecksumComputed,
			ulChecksumComputed );
		}

	(*pcprintf)( FORMAT_UINT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, dbtimeDirtied, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, cbFree, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, ibMicFree, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, itagMicFree, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, cbUncommittedFree, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, pgnoNext, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, pgnoPrev, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, fFlags, dwOffset ) );

	if( FLeafPage() )
		{
		(*pcprintf)( _T( "\t\tLeaf page\n" ) );
		}

	if( FParentOfLeaf() )
		{
		(*pcprintf)( _T( "\t\tParent of leaf\n" ) );
		}

	if( FInvisibleSons() )
		{
		(*pcprintf)( _T( "\t\tInternal page\n" ) );
		}
		
	if( FRootPage() )
		{
		(*pcprintf)( _T( "\t\tRoot page\n" ) );
		}

	if( FFDPPage() )
		{
		(*pcprintf)( _T( "\t\tFDP page\n" ) );

		const TAG * const ptag = PtagFromItag_( 0 );
		if ( sizeof(SPACE_HEADER) != ptag->Cb()
			|| ptag->Ib() < 0
			|| ptag->Ib() > g_cbPage - sizeof(PGHDR) - sizeof(TAG) )
			{
			(*pcprintf)( _T( "\t\tCorrupted Space Header\n" ) );
			}
		else
			{
			const SPACE_HEADER	* const psph	= (SPACE_HEADER *)PbFromIb_( ptag->Ib() );
			if ( psph->FMultipleExtent() )
				{
				(*pcprintf)(
					_T( "\t\tMultiple Extent Space (ParentFDP: %d, pgnoOE: %d)\n" ),
					psph->PgnoParent(),
					psph->PgnoOE() );
				}
			else
				{
				(*pcprintf)( _T( "\t\tSingle Extent Space (ParentFDP: %d)\n" ), psph->PgnoParent() );
				}
			}
		}

	if( FEmptyPage() )
		{
		(*pcprintf)( _T( "\t\tEmpty page\n" ) );
		}

	if( FSpaceTree() )
		{
		(*pcprintf)( _T( "\t\tSpace tree page\n" ) );
		}

	if( FRepairedPage() )
		{
		(*pcprintf)( _T( "\t\tRepaired page\n" ) );
		}

	if( FPrimaryPage() )
		{
		(*pcprintf)( _T( "\t\tPrimary page\n" ) );
		}

	if( FIndexPage() )
		{
		(*pcprintf)( _T( "\t\tIndex page " ) );

		if ( FNonUniqueKeys() )
			{
			(*pcprintf)( _T( "(non-unique keys)\n" ) );
			}
		else
			{
			(*pcprintf)( _T( "(unique keys)\n" ) );
			}
		}
	else
		{
		Assert( !FNonUniqueKeys() );
		}

	if( FLongValuePage() )
		{
		(*pcprintf)( _T( "\t\tLong Value page\n" ) );
		}

	if( FSLVAvailPage() )
		{
		(*pcprintf)( _T( "\t\tSLV-Avail page\n" ) );
		}

	if( FSLVOwnerMapPage() )
		{
		(*pcprintf)( _T( "\t\tSLV-OwnerMap page\n" ) );
		}

	(*pcprintf)( _T( "\n" ) );

	return 0;
	}


#endif	//	DEBUGGER_EXTENSION || DEBUG


#ifdef DEBUG


//  ================================================================
VOID CPAGE::AssertValid() const
//  ================================================================
//
//  Do basic sanity checking on the object. Do not call a public method
//  from this, as it will call ASSERT_VALID( this ) again, causing an infinite
//  loop.
//
//-
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	
	ASSERT_VALID( m_ppib );
	Assert( m_bfl.dwContext == dwBFLContextForLoadPageOnly || FBFLatched( &m_bfl ) );
	Assert( ppghdr->cbFree <= CbPageData() );
	Assert( ppghdr->cbUncommittedFree <= ppghdr->cbFree );
	Assert( ppghdr->ibMicFree <= CbPageData() );
	Assert( (USHORT) ppghdr->itagMicFree >= ctagReserved );
	//  we must use a static_cast to do the unsigned/signed conversion
	Assert( (USHORT) ppghdr->itagMicFree <= ( CbPageData() - (USHORT) ppghdr->cbFree ) / static_cast<INT>( sizeof( CPAGE::TAG ) ) ); // external header tag
	Assert( CbContigousFree_() <= ppghdr->cbFree );
	Assert( CbContigousFree_() >= 0 );
	Assert( static_cast<VOID *>( PbFromIb_( ppghdr->ibMicFree ) )
				<= static_cast<VOID *>( PtagFromItag_( ppghdr->itagMicFree - 1 ) ) );
	}									


//  ================================================================
VOID CPAGE::DebugCheckAll( ) const
//  ================================================================
//
//  Extensive checking on the page. This is expensive and slow -- it
//  is O(n^2) with respect to the number of lines.
//
//-
	{
	ASSERT_VALID( this );

	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	INT	cbTotal = 0;
	
	INT itag = 0;
	for ( ; itag < ppghdr->itagMicFree; ++itag )
		{
		const TAG * const ptag = PtagFromItag_( itag );
		Assert( ptag );
		Assert( ptag->Cb() >= 0 );
		if ( 0 == ptag->Cb() )
			{
			continue;
			}
		Assert( ptag->Ib() >= 0 );
		Assert( ptag->Ib() + ptag->Cb() <= ppghdr->ibMicFree );
		cbTotal += ptag->Cb();

		//  check to see that we do not overlap with other tags

		INT itagOther = 0;
		for ( itagOther = 0; itagOther < ppghdr->itagMicFree; ++itagOther )
			{
			if ( ptag->Cb() == 0 )
				{
				continue;
				}
			if ( itagOther != itag )
				{
				const TAG * const ptagOther = PtagFromItag_( itagOther );
				Assert( ptagOther != ptag );
				if ( ptagOther->Cb() == 0 )
					{
					continue;
					}
				Assert( ptagOther->Ib() != ptag->Ib() );
				if ( ptagOther->Ib() < ptag->Ib() )
					{
					Assert( ptagOther->Ib() + ptagOther->Cb()
							<= ptag->Ib() );
					}
				else
					{
					Assert( ptag->Ib() + ptag->Cb() <= ptagOther->Ib() );
					}
				}
			}
		}

	//  all space on the page should be accounted for

	Assert( cbTotal + ppghdr->cbFree + (ppghdr->itagMicFree * sizeof( CPAGE::TAG )) == CbPageData() );
	}


//  ================================================================
VOID CPAGE::DebugMoveMemory_( )
//  ================================================================
//
//  This forces a reorganization of the page by removing the smallest
//  tag, reorganizing the page and then re-intserting it. Watch out
//  for infinite loops with Replace_, which calls this function.  
// 
//-
	{
	BYTE	rgbBuf[g_cbPageMax];
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	INT		cbTag = 0;
	INT		fFlagsTag;

	//  there may not be enough tags to reorganize
	//  we need one to delete and one to move
	if ( ppghdr->itagMicFree < ctagReserved + 2 )
		{
		return;
		}

	//  the page may be fully compacted
	if ( CbContigousFree_( ) == ppghdr->cbFree )
		{
		return;
		}

	//  save the smallest tag with a non-zero size
	//  we only loop to itagMicFree-1 as deleting the last tag is useless
	TAG * ptag 	= NULL;
	INT itag	= ctagReserved;
	for ( ; itag < ppghdr->itagMicFree - 1; ++itag )
		{
		ptag	= PtagFromItag_( itag );
		cbTag 	= ptag->Cb();
		if ( cbTag > 0 )
			{
			break;
			}
		}
	Assert( ptag );

	if ( 0 == cbTag )
		{
		//  nothing to reorganize
		return;
		}
	Assert( itag >= ctagReserved && itag < (ppghdr->itagMicFree - 1) );
	Assert( cbTag > 0 );

	fFlagsTag = ptag->FFlags();
	UtilMemCpy( rgbBuf, PbFromIb_( ptag->Ib() ), cbTag );

	//  reorganize the page
	Delete_( itag );
	ReorganizeData_( );

	//  reinsert the tag
	DATA data;
	data.SetPv( rgbBuf );
	data.SetCb( cbTag );
	Insert_( itag, &data, 1, fFlagsTag );
	}



//  ================================================================
BOOL CPAGE::FAssertDirty( ) const
//  ================================================================
	{
	return m_bfl.pv && FBFDirty( &m_bfl ) != bfdfClean;
	}


//  ================================================================
BOOL CPAGE::FAssertReadLatch( ) const
//  ================================================================
	{
	return m_bfl.dwContext == dwBFLContextForLoadPageOnly || FBFReadLatched( &m_bfl );
	}


//  ================================================================
BOOL CPAGE::FAssertRDWLatch( ) const
//  ================================================================
	{
	return m_bfl.dwContext == dwBFLContextForLoadPageOnly || FBFRDWLatched( &m_bfl );
	}


//  ================================================================
BOOL CPAGE::FAssertWriteLatch( ) const
//  ================================================================
	{
	return m_bfl.dwContext == dwBFLContextForLoadPageOnly || FBFWriteLatched( &m_bfl );
	}


//  ================================================================
BOOL CPAGE::FAssertWARLatch( ) const
//  ================================================================
	{
	return m_bfl.dwContext == dwBFLContextForLoadPageOnly || FBFWARLatched( &m_bfl );
	}


//  ================================================================
BOOL CPAGE::FAssertNotOnPage_( const VOID * pv ) const
//  ================================================================
//
//  Tests to see if the pointer given is on the page or not. Returns
//  fTrue if the pointer is not on the page.
//
//-
	{
	const BYTE * const pb = static_cast<const BYTE *>( pv );
	BOOL fGood =
		pb < reinterpret_cast<const BYTE * >( m_bfl.pv )
		|| pb >= reinterpret_cast<const BYTE * >( m_bfl.pv ) + g_cbPage
		;
	return fGood;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\db.cxx ===
#include "std.hxx"

#ifdef DEBUG
///#define FORCE_ONLINE_DEFRAG
#else
///#define FORCE_ONLINE_DEFRAG
#endif	//	!DEBUG

//
// this function will return one of the followings:
//		JET_errDatabase200Format
//		JET_errDatabase400Format
//		JET_errDatabaseCorrupted
//

LOCAL ERR ErrDBICheck200And400( IFileSystemAPI *const pfsapi, CHAR *szDatabaseName )
	{
	/* persistent database data, in database root node
	/**/
#include <pshpack1.h>

	//	Structures copied from JET200/JET400

	typedef ULONG SRID;

	typedef struct _database_data
		{
		ULONG	ulMagic;
		ULONG	ulVersion;
		ULONG	ulDBTime;
		USHORT	usFlags;
		} P_DATABASE_DATA;

	typedef BYTE	PGTYP;

	typedef struct _threebytes { BYTE b[3]; } THREEBYTES;

	typedef struct _pghdr
		{
		ULONG		ulChecksum;	  		//	checksum of page, always 1st byte
		ULONG		ulDBTime;	  		//	database time page dirtied
		PGNO		pgnoFDP;	  		//	pgno of FDP which owns this page
		SHORT		cbFree;  			//	count free bytes
		SHORT		ibMic;	  			//	minimum used byte
		SHORT		ctagMac; 	  		//	count tags used
		SHORT		itagFree;	  		//	itag of first free tag
		SHORT		cbUncommittedFreed;	//	bytes freed from this page, but *possibly*
										//	  uncommitted (this number will always be
										//	  a subset of cbFree)
		THREEBYTES	pgnoPrev;	  		//	pgno of previous page
		THREEBYTES	pgnoNext;	  		//	pgno of next page
		} PGHDR;

	typedef struct _pgtrlr
		{
		PGTYP	   	pgtyp;
		THREEBYTES 	pgnoThisPage;
		} PGTRLR;

	typedef struct _tag
		{
		SHORT		cb;
		SHORT		ib;
		} TAG;

	typedef struct _page
		{
		PGHDR	   	pghdr;
		TAG  	   	rgtag[1];
		BYTE	   	rgbFiller[ cbPageOld -
						sizeof(PGHDR) -			// pghdr
						sizeof(TAG) -			// rgtag[1]
						sizeof(BYTE) -			// rgbData[1]
						sizeof(PGTYP) -			// pgtyp
						sizeof(THREEBYTES) ];	// pgnoThisPage
		BYTE	   	rgbData[1];
		PGTYP	   	pgtyp;
		THREEBYTES	pgnoThisPage;
		} PAGE;

#include <poppack.h>

#define IbCbFromPtag( ibP, cbP, ptagP )							\
			{	TAG *_ptagT = ptagP;					 		\
			(ibP) = _ptagT->ib;							 		\
			(cbP) = _ptagT->cb;							 		\
			}

	//	node header bits
#define fNDVersion		  		0x80
#define fNDDeleted		  		0x40
#define fNDBackLink		  		0x20
#define fNDFDPPtr				0x10
#define fNDSon					0x08
#define fNDVisibleSon	  		0x04
#define fNDFirstItem  	  		0x02
#define fNDLastItem	  	  		0x01

#define	FNDVisibleSons(b)		( (b) & fNDVisibleSon )
#define	FNDInvisibleSons(b) 	( !( (b) & fNDVisibleSon ) )
#define CbNDKey(pb)				( *( (pb) + 1 ) )
#define	FNDNullSon(b)	 		( !( (b) & fNDSon ) )
#define PbNDSonTable(pb)	  		( (pb) + 1 + 1 + *(pb + 1) )
#define PbNDBackLink(pb)											\
	( PbNDSonTable(pb) + ( FNDNullSon( *(pb) ) ? 0 :				\
	( ( ( *PbNDSonTable(pb) == 1 ) && FNDInvisibleSons( *(pb) ) ) ?	\
	sizeof(PGNO) + 1 : *PbNDSonTable(pb) + 1 ) ) )
#define	FNDBackLink(b)	 		( (b) & fNDBackLink )
#define PbNDData(pb) ( PbNDBackLink(pb) + ( FNDBackLink( *(pb) ) ? sizeof(SRID) : 0 ) )

	ERR	  			err = JET_errSuccess;
	PAGE   			*ppage;
	INT	  			ibTag;
	INT	  			cbTag;
	BYTE  			*pb;
	ULONG			ulVersion;
	IFileAPI	*pfapi;

	CallR( pfsapi->ErrFileOpen( szDatabaseName, &pfapi, fTrue ) );
	if ( ( ppage = (PAGE *)PvOSMemoryPageAlloc( cbPageOld, NULL ) ) == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	err = pfapi->ErrIORead( QWORD( 0 ), cbPageOld, (BYTE* const)ppage );

	/*	since file exists and we are unable to read data,
	/*	it may not be a system.mdb
	/**/
	if ( err == JET_errDiskIO )
		err = ErrERRCheck( JET_errDatabaseCorrupted );

	Call( err );

	IbCbFromPtag(ibTag, cbTag, &ppage->rgtag[0]);
	if ( ibTag < 0 ||
		cbTag < 0 ||
		ibTag < (BYTE*)&ppage->rgtag[1] - (BYTE*)ppage ||
		(BYTE*)ppage + ibTag + cbTag >= (BYTE*)(ppage + 1) )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

	/*	at least FILES, OWNEXT, AVAILEXT
	/**/
	pb = (BYTE *)ppage + ibTag;
	if ( !FNDVisibleSons( *pb ) || CbNDKey( pb ) != 0 || FNDNullSon( *pb ) )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

	/*	check data length
	/**/
	INT cb;
	cb = (INT)( cbTag - ( PbNDData( pb ) - pb ) );
	if ( cb != sizeof(P_DATABASE_DATA) )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

	/*	check database version, for 200 ulVersion should be 1, for 400 ulVersion is 0x400.
	/**/
	ulVersion = ((P_DATABASE_DATA *)PbNDData(pb))->ulVersion;
	if ( ulDAEVersion200 == ulVersion )
		err = ErrERRCheck( JET_errDatabase200Format );
	else if ( ulDAEVersion400 == ulVersion )
		err = ErrERRCheck( JET_errDatabase400Format );
	else
		err = ErrERRCheck( JET_errDatabaseCorrupted );

HandleError:
	if ( ppage != NULL )
		OSMemoryPageFree( (VOID *)ppage );

	delete pfapi;
	return err;
	}


//+local
//	ErrDBInitDatabase
//	========================================================================
//	ErrDBInitDatabase( PIB *ppib, IFMP ifmp, CPG cpgPrimary )
//
//	Initializes database structure.  Structure is customized for
//	system, temporary and user databases which are identified by
//	the ifmp.  Primary extent is set to cpgPrimary but no allocation
//	is performed.  The effect of this routine can be entirely
//	represented with page operations.
//
//	PARAMETERS	ppib			ppib of database creator
//		  		ifmp			ifmp of created database
//		  		cpgPrimary 		number of pages to show in primary extent
//
//	RETURNS		JET_errSuccess or error returned from called routine.
//-
LOCAL ERR ErrDBInitDatabase( PIB *ppib, IFMP ifmp, CPG cpgPrimary )
	{
	ERR				err;
	OBJID			objidFDP;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	//	set up root page
	//
	Call( ErrSPCreate(
				ppib,
				ifmp,
				pgnoNull,
				pgnoSystemRoot,
				cpgPrimary,
				fSPMultipleExtent,
				(ULONG)CPAGE::fPagePrimary,
				&objidFDP ) );
	Assert( objidSystemRoot == objidFDP );

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	return err;

HandleError:
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	return err;
	}


//	to prevent read ahead over-preread, we may want to keep track of last
//	page of the database.

ERR ErrDBSetLastPageAndOpenSLV( IFileSystemAPI *const pfsapi, PIB *ppib, const IFMP ifmp, const BOOL fOpenSLV )
	{
	ERR		err;
	PGNO	pgno;
	IFMP	ifmpT;
	BOOL	fDbOpened	= fFalse;

	ppib->SetFSetAttachDB();

	Call( ErrDBOpenDatabase( ppib, rgfmp[ifmp].SzDatabaseName(), &ifmpT, NO_GRBIT ) );
	Assert( ifmpT == ifmp );
	fDbOpened = fTrue;

	Assert( ppib->FSetAttachDB() );
	Assert( g_cbPage == 1 << g_shfCbPage );
	Call( ErrBTGetLastPgno( ppib, ifmp, &pgno ) );
	rgfmp[ifmp].SetFileSize( QWORD( pgno ) << g_shfCbPage );

	if ( fOpenSLV )
		{
		Call( ErrFILEOpenSLV( pfsapi, ppib, ifmpT ) );
		}

HandleError:
	if ( fDbOpened )
		{
		CallS( ErrDBCloseDatabase( ppib, ifmpT, NO_GRBIT ) );
		}

	ppib->ResetFSetAttachDB();
	return err;
	}


ERR ISAMAPI ErrIsamCreateDatabase(
	JET_SESID	sesid,
	const CHAR	*szDatabaseName,
	const CHAR	*szSLVName,
	const CHAR	*szSLVRoot,
	const ULONG	cpgDatabaseSizeMax,
	JET_DBID	*pjifmp,
	JET_GRBIT	grbit )
	{
	ERR			err;
	PIB			*ppib;
	IFMP		ifmp;

	//	check parameters
	//
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	ppib = (PIB *)sesid;
	CallR( ErrPIBCheck( ppib ) );

	CallR( ErrDBCreateDatabase(
				ppib,
				NULL,
				szDatabaseName,
				szSLVName,
				szSLVRoot,
				cpgDatabaseSizeMax,
				&ifmp,
				dbidMax,
				cpgDatabaseMin,
				grbit,
				NULL ) );

	*pjifmp = (JET_DBID)ifmp;

	return JET_errSuccess;
	}


LOCAL ERR ErrDBGetSLVNameFromDbName( INST* const pinst, IFileSystemAPI *const pfsapi, const CHAR *szDbName, CHAR *szSLVName, CHAR *szSLVRoot )
	{
	ERR		err = JET_errSuccess;
	CHAR	szDbDir[IFileSystemAPI::cchPathMax];
	CHAR	szDbBaseName[IFileSystemAPI::cchPathMax];
	CHAR	szDbExt[IFileSystemAPI::cchPathMax];

	CallS( pfsapi->ErrPathParse( szDbName, szDbDir, szDbBaseName, szDbExt ) );

	if ( NULL != szSLVName )
		{
		CallS( pfsapi->ErrPathBuild( szDbDir, szDbBaseName, szSLVExt, szSLVName ) );
		}

	if ( NULL != szSLVRoot )
		{
		Assert( pinstNil != pinst );
		for ( int ipinst = 0; ipinst < ipinstMax; ipinst++ )
			{
			if ( pinst == g_rgpinst[ ipinst ] )
				break;
			}
		Assert( ipinst < ipinstMax );	//	pinst should always be valid

		sprintf( szSLVRoot, "\\ESE98\\$%d.%d.%s%s$", DwUtilProcessId(), ipinst, szDbBaseName, szSLVExt );
		Assert( strlen( szSLVRoot ) < IFileSystemAPI::cchPathMax );
		}

	return err;
	}


ERR ErrDBCreateDatabase(
	PIB				*ppib,
	IFileSystemAPI	*pfsapiDest,
	const CHAR		*szDatabaseName,
	const CHAR		*szSLVName,
	const CHAR		*szSLVRoot,
	const CPG		cpgDatabaseSizeMax,
	IFMP			*pifmp,
	DBID			dbidGiven,
	CPG				cpgPrimary,
	const ULONG		grbit,
	SIGNATURE		*psignDb )
	{
	ERR				err;
	CHAR  			rgchDbFullName[IFileSystemAPI::cchPathMax];
	CHAR  			rgchSLVFullName[IFileSystemAPI::cchPathMax];
	CHAR  			rgchSLVRootName[IFileSystemAPI::cchPathMax];
	CHAR  			*szDbFullName		= rgchDbFullName;
	CHAR			*szSLVFullName		= rgchSLVFullName;
	CHAR			*szSLVRootName		= rgchSLVRootName;
	BOOL			fDatabaseOpen		= fFalse;
	DBFILEHDR		*pdbfilehdr			= NULL;
	BOOL			fNewDBCreated		= fFalse;
	BOOL			fLogged				= fFalse;
	LGPOS			lgposLogRec;

	CheckPIB( ppib );

	if ( ppib->level > 0 )
		{
		return ErrERRCheck( JET_errInTransaction );
		}

	if ( cpgPrimary == 0 )
		{
		cpgPrimary = cpgDatabaseMin;
		}

	if ( cpgPrimary > pgnoSysMax )
		{
		return ErrERRCheck( JET_errDatabaseInvalidPages );
		}

	if ( grbit & JET_bitDbVersioningOff )
		{
		if ( !( grbit & JET_bitDbRecoveryOff ) )
			{
			return ErrERRCheck( JET_errCannotDisableVersioning );
			}
		}

	INST 			*pinst = PinstFromPpib( ppib );
	LOG 			*plog = pinst->m_plog;
	IFMP 			ifmp;
	IFileSystemAPI	*pfsapi;

	if ( NULL != pfsapiDest )
		{
		pfsapi = pfsapiDest;
		}
	else
		{
		pfsapi = pinst->m_pfsapi;
		}

	//	if recovering and ifmp is given latch the fmp first
	//
	if ( plog->m_fRecovering && dbidGiven < dbidMax && dbidGiven != dbidTemp )
		{
		ifmp = pinst->m_mpdbidifmp[ dbidGiven ];
		FMP::AssertVALIDIFMP( ifmp );

		//	get corresponding ifmp
		//
		CallS( FMP::ErrNewAndWriteLatch(
			&ifmp,
			rgfmp[ifmp].SzDatabaseName(),
			rgfmp[ifmp].SzSLVName(),
			rgfmp[ifmp].SzSLVRoot(),
			ppib,
			pinst,
			pfsapi,
			dbidGiven ) );

		szDbFullName = rgfmp[ifmp].SzDatabaseName();
		szSLVFullName = rgfmp[ifmp].SzSLVName();
		szSLVRootName = rgfmp[ifmp].SzSLVRoot();
		}
	else
		{
		if ( NULL == szDatabaseName || 0 == *szDatabaseName )
			{
			return ErrERRCheck( JET_errDatabaseInvalidPath );
			}

		if ( pinst->m_fCreatePathIfNotExist )
			{
			//	make sure database name has a file at the end of it (no '\')
			//
			Assert( !FOSSTRTrailingPathDelimiter( const_cast< CHAR * >( szDatabaseName ) ) );
			err = ErrUtilCreatePathIfNotExist( pfsapi, szDatabaseName, rgchDbFullName );
			}
		else
			{
			err = pfsapi->ErrPathComplete( szDatabaseName, rgchDbFullName );
			}
		CallR( err == JET_errInvalidPath ? ErrERRCheck( JET_errDatabaseInvalidPath ) : err );

		Assert( szDbFullName == rgchDbFullName );
		Assert( szSLVFullName == rgchSLVFullName );
		Assert( szSLVRootName == rgchSLVRootName );

		//	if SLV name passed in, use that for SLV filename
		//	if no SLV name passed in and JET_bitDbCreateStreamingFile specified, base SLV name off db name
		//	if no SLV name passed in and JET_bitDbCreateStreamingFile NOT specified, don't create SLV file
		//
		if ( NULL != szSLVName && 0 != *szSLVName )
			{
			if ( pinst->m_fCreatePathIfNotExist )
				{
				//	make sure SLV name has a file at the end of it (no '\')
				//
				Assert( !FOSSTRTrailingPathDelimiter( const_cast< CHAR * >( szSLVName ) ) );
				err = ErrUtilCreatePathIfNotExist( pfsapi, szSLVName, rgchSLVFullName );
				}
			else
				{
				err = pfsapi->ErrPathComplete( szSLVName, rgchSLVFullName );
				}
			CallR( err == JET_errInvalidPath ? ErrERRCheck( JET_errSLVInvalidPath ) : err );

			if ( NULL != szSLVRoot && 0 != *szSLVRoot )
				{
				CallR( ErrUTILCheckPathName( szSLVRootName, szSLVRoot, IFileSystemAPI::cchPathMax ) );
				}
			else if ( pinst->FSLVProviderEnabled() )
				{
				//	must ALWAYS specify root name when SLV provider is enabled
				//
				CallR( ErrERRCheck( JET_errSLVRootNotSpecified ) );
				}
			else
				{
				//	auto-generate root name only
				//
				CallR( ErrDBGetSLVNameFromDbName( pinst, pfsapi, szDbFullName, NULL, szSLVRootName ) );
				}
			}
		else if ( grbit & JET_bitDbCreateStreamingFile )
			{
			CallR( ErrDBGetSLVNameFromDbName( pinst, pfsapi, szDbFullName, szSLVFullName, szSLVRootName ) );
			}
		else
			{
			szSLVFullName = NULL;
			szSLVRootName = NULL;
			}

		Assert( dbidTemp == dbidGiven || dbidMax == dbidGiven );
		err = FMP::ErrNewAndWriteLatch( &ifmp, szDbFullName, szSLVFullName, szSLVRootName, ppib, pinst, pfsapi, dbidGiven );
		if ( err != JET_errSuccess )
			{
			if ( JET_wrnDatabaseAttached == err )
				{
				err = ErrERRCheck( JET_errDatabaseDuplicate );
				}
			return err;
			}

		dbidGiven = rgfmp[ ifmp ].Dbid();
		}

	//	from this point we got a valid ifmp entry. Start the creat DB process.
	//
	FMP *pfmp;
	pfmp = &rgfmp[ ifmp ];

	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetCreatingDB();
	pfmp->RwlDetaching().LeaveAsWriter();

	//	check if database file already exists
	//
	if ( dbidGiven != dbidTemp )
		{
		err = ErrUtilPathExists( pfsapi, szDbFullName );
		if ( JET_errFileNotFound != err )
			{
			if ( JET_errSuccess == err ) // database file exists
				{
				// delete db with the same name
				//
				if( grbit & JET_bitDbOverwriteExisting )
					{
					err = pfsapi->ErrFileDelete( szDbFullName );
					}
				else
					{
					err = ErrERRCheck( JET_errDatabaseDuplicate );
					}
				}
			Call( err );
			}

		if ( NULL != szSLVFullName )
			{
			err = ErrUtilPathExists( pfsapi, szSLVFullName );
			if ( JET_errFileNotFound != err )
				{
				if ( JET_errSuccess == err ) // streaming file exists
					{
					//	delete db with the same name
					//
					if( grbit & JET_bitDbOverwriteExisting )
						{
						err = pfsapi->ErrFileDelete( szSLVFullName );
						}
					else
						{
						err = ErrERRCheck( JET_errSLVStreamingFileAlreadyExists );
						}
					}
				Call( err );
				}
			}
		}
	else
		{
		ERR errDelFile;

		errDelFile = pfsapi->ErrFileDelete( szDbFullName );
#ifdef DEBUG
		if ( JET_errSuccess != errDelFile
			&& JET_errFileNotFound != errDelFile
			&& JET_errInvalidPath != errDelFile
			&& !FRFSFailureDetected( OSFileDelete ) )
			{
			CallS( errDelFile );
			}
#endif

#ifdef TEMP_SLV
		//	temp db. always created with streaming file
		//
		Assert( NULL != szSLVFullName );

		errDelFile = pfsapi->ErrFileDelete( szSLVFullName );
#ifdef DEBUG
		if ( JET_errSuccess != errDelFile
			&& JET_errFileNotFound != errDelFile
			&& !FRFSFailureDetected( OSFileDelete ) )
			{
			CallS( errDelFile );
			}
#endif

#else
		Assert( NULL == szSLVFullName );

#endif	//	TEMP_SLV
		}

	//	create an empty database with header only.
	//
	pdbfilehdr = (DBFILEHDR_FIX * )PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( pdbfilehdr == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//	set database non-loggable during create database
	//
	pfmp->ResetLogOn();
	pfmp->SetVersioningOff();

	//	create database header
	//
	memset( pdbfilehdr, 0, g_cbPage );
	pdbfilehdr->le_ulMagic = ulDAEMagic;
	pdbfilehdr->le_ulVersion = ulDAEVersion;
	pdbfilehdr->le_ulUpdate = ulDAEUpdate;
	pdbfilehdr->le_ulCreateVersion = ulDAEVersion;
	pdbfilehdr->le_ulCreateUpdate = ulDAEUpdate;
	Assert( 0 == pdbfilehdr->le_dbtimeDirtied );
	Assert( 0 == pdbfilehdr->le_objidLast );
	Assert( attribDb == pdbfilehdr->le_attrib );

	Assert( 0 == pdbfilehdr->m_ulDbFlags );
	Assert( !pdbfilehdr->FShadowingDisabled() );
	if ( grbit & JET_bitDbShadowingOff )
		{
		pdbfilehdr->SetShadowingDisabled();
		}

	pdbfilehdr->le_dbid = pfmp->Dbid();
	if ( psignDb == NULL )
		SIGGetSignature( &pdbfilehdr->signDb );
	else
		UtilMemCpy( &pdbfilehdr->signDb, psignDb, sizeof( SIGNATURE ) );
	if ( NULL != szSLVFullName )
		{
		Assert( NULL != pfmp->SzSLVName() );
		pdbfilehdr->SetSLVExists();
		pdbfilehdr->signSLV = pdbfilehdr->signDb;
		}
	Assert( !pfmp->FSLVAttached() );
	pdbfilehdr->SetDbstate( JET_dbstateJustCreated );
	Assert( 0 == pdbfilehdr->le_dbtimeDirtied );
	Assert( 0 == pdbfilehdr->le_objidLast );

	pdbfilehdr->le_cbPageSize = g_cbPage;

	if ( plog->m_fLogDisabled || ( grbit & JET_bitDbRecoveryOff ) )
		{
		memset( &pdbfilehdr->signLog, 0, sizeof( SIGNATURE ) );
		}
	else
		{
		Assert( plog->m_fSignLogSet );
		pdbfilehdr->signLog = plog->m_signLog;
		}

	pdbfilehdr->le_filetype	= filetypeDB;

	pfmp->SetDbtimeLast( 0 );
	pfmp->SetObjidLast( 0 );
	Assert( pdbfilehdr->le_dbtimeDirtied == pfmp->DbtimeLast() );
	Assert( pdbfilehdr->le_objidLast == pfmp->ObjidLast() );
	err = pfmp->ErrSetPdbfilehdr( pdbfilehdr );
	if ( err < 0 )
		{
		OSMemoryPageFree( pdbfilehdr );
		goto HandleError;
		}

	//	write database header
	//
	Call( ErrUtilWriteShadowedHeader( pfsapi, szDbFullName, fTrue, (BYTE*)pdbfilehdr, g_cbPage ) );

	fNewDBCreated = fTrue;

	//	set proper database size.
	//
	Call( ErrIOOpenDatabase( pfsapi, ifmp, szDbFullName ) );
	Call( ErrIONewSize( ifmp, cpgPrimary ) );

	//	not in a transaction, but still need to set lgposRC of the buffers
	//	used by this function such that when get checkpoint, it will get
	//	right check point.
	//
	if ( !plog->m_fLogDisabled
		&& !( grbit & JET_bitDbRecoveryOff )
		&& !plog->m_fRecovering )
		{
		plog->m_critLGBuf.Enter();
		plog->GetLgposOfPbEntry( &ppib->lgposStart );
		plog->m_critLGBuf.Leave();
		}

	//	initialize the database file.  Logging of page operations is
	//	turned off, during creation only.  After creation the database
	//	is marked loggable and logging is turned on.
	//
	DBSetOpenDatabaseFlag( ppib, ifmp );
	fDatabaseOpen = fTrue;

	Call( ErrDBInitDatabase( ppib, ifmp, cpgPrimary ) );

	if ( rgfmp[ifmp].Dbid() != dbidTemp )
		{
		//	create system tables
		//
		Call( ErrCATCreate( ppib, ifmp ) );
		}

	Assert( !pfmp->FSLVAttached() );
	if ( pdbfilehdr->FSLVExists() )
		{
		Call( ErrFILECreateSLV( pfsapi, ppib, ifmp, SLV_CREATESLV_ALL ) );
		Assert( pfmp->FSLVAttached() );
		}

	AssertDIRNoLatch( ppib );

	//	flush buffers
	//
	Call( ErrBFFlush( ifmp ) );
	Call( ErrBFFlush( ifmp | ifmpSLV ) );

	Assert( !pfmp->FLogOn() );
	Assert( pfmp->FVersioningOff() );

	//	set database status to loggable if it is.
	//
	if ( grbit & JET_bitDbRecoveryOff )
		{
		Assert( !pfmp->FLogOn() );
		Assert( !pfmp->FReadOnlyAttach() );
		if ( !( grbit & JET_bitDbVersioningOff ) )
			{
			pfmp->ResetVersioningOff();
			}
		}
	else
		{
		Assert( !( grbit & JET_bitDbVersioningOff ) );
		pfmp->ResetVersioningOff();
		pfmp->SetLogOn();
		}

	pfmp->SetDatabaseSizeMax( cpgDatabaseSizeMax );

	if ( pfmp->FLogOn() )
		{
		Assert( pfmp == &rgfmp[ifmp] );
		Assert( UtilCmpFileName( szDbFullName, pfmp->SzDatabaseName() ) == 0 );
		Assert( ( NULL == szSLVFullName && NULL == pfmp->SzSLVName() )
			|| UtilCmpFileName( szSLVFullName, pfmp->SzSLVName() ) == 0 );
		Assert( ( NULL == szSLVRootName && NULL == pfmp->SzSLVRoot() )
			|| UtilCmpFileName( szSLVRootName, pfmp->SzSLVRoot() ) == 0 );
		Assert( pfmp->CpgDatabaseSizeMax() == cpgDatabaseSizeMax );

		Call( ErrLGCreateDB( ppib, ifmp, grbit, &lgposLogRec ) );

		fLogged = fTrue;
		if ( plog->m_fRecovering )
			{
			pdbfilehdr->le_lgposAttach = plog->m_lgposRedo;
			}
		else
			{
			pdbfilehdr->le_lgposAttach = lgposLogRec;
			}
		}

	pdbfilehdr->le_dbtimeDirtied = pfmp->DbtimeLast();
	LGIGetDateTime( &pdbfilehdr->logtimeAttach );

	IOCloseDatabase( ifmp );

	//	set database state to be inconsistent from creating since
	//	the createdatabase op is logged.
	//
	pdbfilehdr->le_objidLast = pfmp->ObjidLast();
	if ( !plog->m_fLogDisabled )
		pdbfilehdr->SetDbstate( JET_dbstateInconsistent, plog->m_plgfilehdr->lgfilehdr.le_lGeneration, &plog->m_plgfilehdr->lgfilehdr.tmCreate );
	else
		pdbfilehdr->SetDbstate( JET_dbstateInconsistent );

	//	set version info
	//
	if ( !plog->m_fRecovering )
		{
		pdbfilehdr->le_dwMajorVersion = dwGlobalMajorVersion;
		pdbfilehdr->le_dwMinorVersion = dwGlobalMinorVersion;
		pdbfilehdr->le_dwBuildNumber = dwGlobalBuildNumber;
		pdbfilehdr->le_lSPNumber = lGlobalSPNumber;
		}
	Assert( pdbfilehdr->le_objidLast );

	if ( pdbfilehdr->FSLVExists() )
		{
		Assert( NULL != pfmp->SzSLVName() );
		Call( ErrSLVSyncHeader(	pfsapi, rgfmp[ifmp].FReadOnlyAttach(), rgfmp[ifmp].SzSLVName(), pdbfilehdr ) );
		}
	else
		{
		Assert( NULL == pfmp->SzSLVName() );
		}

	Call( ErrUtilWriteShadowedHeader(
		pfsapi,
		szDbFullName,
		fTrue,
		(BYTE*)pdbfilehdr,
		g_cbPage ) );

	Call( ErrIOOpenDatabase( pfsapi, ifmp, szDbFullName ) );

	//	make the database attached
	//
	Assert( !( pfmp->FAttached() ) );
	pfmp->SetAttached();

	Assert (! pfmp->FAllowHeaderUpdate() );
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetAllowHeaderUpdate();
	pfmp->RwlDetaching().LeaveAsWriter();

	pfmp->SetDbtimeOldestGuaranteed( pfmp->DbtimeLast() );
	pfmp->SetDbtimeOldestCandidate( pfmp->DbtimeLast() );
	pfmp->SetDbtimeOldestTarget( pfmp->DbtimeLast() );
	pfmp->SetTrxOldestCandidate( pinst->m_trxNewest );
	pfmp->SetTrxOldestTarget( trxMax );

	Call( ErrDBSetLastPageAndOpenSLV( pfsapi, ppib, ifmp, pdbfilehdr->FSLVExists() ) );

	//	create the unicode fixup table
	//
	if( rgfmp[ifmp].Dbid() != dbidTemp && FNORMStringHasUndefinedCharsIsSupported() && !pinst->FRecovering() )
		{
#ifndef RTM
///		CallS( ErrCATTestMSU( ppib, ifmp ) );
#endif	// !RTM
		Call( ErrCATCreateMSU( ppib, ifmp ) );
		}

	//	the database is created and attached.
	//	Make the fmp available for others to open etc.
	//

	//	no need to wrl since it is OK for reader to mistaken it is being created
	//
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->ResetCreatingDB();
	pfmp->ReleaseWriteLatch( ppib );
	pfmp->RwlDetaching().LeaveAsWriter();

	*pifmp = ifmp;

#ifdef FORCE_ONLINE_DEFRAG
	Assert( !pfmp->FReadOnlyAttach() );
	if ( !plog->m_fRecovering && pfmp->FLogOn() )
		{
		Assert( !pfmp->FVersioningOff() );
		CallS( ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentBatchStart ) );
		}
#endif

	return JET_errSuccess;

HandleError:

	//	purge the bad, half-created database
	//
	FCB::DetachDatabase( ifmp, fFalse );
	BFPurge( ifmp );
	BFPurge( ifmp | ifmpSLV );

	if ( fLogged && err < 0 )
		{
		//	we have to take the instance offline if there is an error
		//	during database creation and the creation is logged
		//
		PinstFromPpib( ppib )->SetInstanceUnavailable( err );
		ppib->SetErrRollbackFailure( err );
		}

	if ( FIODatabaseOpen( ifmp ) )
		{
		IOCloseDatabase( ifmp );
		}

	if ( fNewDBCreated )
		{
		(VOID)ErrIODeleteDatabase( pfsapi, ifmp );
		if ( NULL != szSLVFullName )
			{
			(VOID)pfsapi->ErrFileDelete( szSLVFullName );
			}
		if ( fLogged )
			{
			Assert( UtilCmpFileName( szDbFullName, rgfmp[ifmp].SzDatabaseName() ) == 0 );

#ifdef INDEPENDENT_DB_FAILURE
			ErrLGForceDetachDB( ppib, ifmp, fLRForceDetachDeleteDB, &lgposLogRec );
#endif
			}
		}

	if ( fDatabaseOpen )
		{
		DBResetOpenDatabaseFlag( ppib, ifmp );
		}

	if ( pfmp->Pdbfilehdr() )
		{
		pfmp->FreePdbfilehdr();
		}

	FMP::EnterCritFMPPool();
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->ResetCreatingDB();
	pfmp->ReleaseWriteLatchAndFree( ppib );
	pfmp->RwlDetaching().LeaveAsWriter();
	FMP::LeaveCritFMPPool();

	return err;
	}


//	delete db and slv files (currently only used to remove temp db and slv upon shutdown)
//
VOID DBDeleteDbFiles( INST *pinst, IFileSystemAPI *const pfsapi, const CHAR *szDbName )
	{
	CHAR	szSLVName[IFileSystemAPI::cchPathMax];

	CallS( ErrDBGetSLVNameFromDbName( pinst, pfsapi, szDbName, szSLVName, NULL ) );

	(VOID)pfsapi->ErrFileDelete( szDbName );
	(VOID)pfsapi->ErrFileDelete( szSLVName );
	}


ERR ErrDBCheckUniqueSignature( IFMP ifmp )
	{
	ERR				err 		= JET_errSuccess;
	const FMP * 	pfmp 		= &rgfmp[ifmp];
	Assert ( pfmp );
	const INST * 	pinst 		= pfmp->Pinst();
	DBID			dbid;

	if ( pfmp->FReadOnlyAttach() || NULL == pfmp->Pdbfilehdr() )
		return JET_errSuccess;

	Assert ( pfmp->FInUse() );
	Assert ( NULL != pfmp->Pdbfilehdr() );
	Assert ( !pfmp->FSkippedAttach() );

	FMP::EnterCritFMPPool();
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		if ( pinst->m_mpdbidifmp[ dbid ] >= ifmpMax || pinst->m_mpdbidifmp[ dbid ] == ifmp )
			continue;

		FMP	*pfmpT;

		pfmpT = &rgfmp[ pinst->m_mpdbidifmp[ dbid ] ];

		pfmpT->RwlDetaching().EnterAsReader();
		if ( pfmpT->Pdbfilehdr()
			&& 0 == memcmp( &(pfmp->Pdbfilehdr()->signDb), &(pfmpT->Pdbfilehdr()->signDb), sizeof( SIGNATURE ) ) )
			{
			pfmpT->RwlDetaching().LeaveAsReader();
			Call ( ErrERRCheck ( JET_errDatabaseSignInUse ) );
			}
		pfmpT->RwlDetaching().LeaveAsReader();
		}

	Assert ( JET_errSuccess == err );
HandleError:
	FMP::LeaveCritFMPPool();
	return err;
	}

ERR ErrDBReadHeaderCheckConsistency(
	IFileSystemAPI	* const pfsapi,
	FMP				* pfmp )
	{
	ERR				err;
	DBFILEHDR		* pdbfilehdr;
	IFileAPI		* pfapiT;

	//	bring in the database and check its header
	//
	pdbfilehdr = (DBFILEHDR * )PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( NULL == pdbfilehdr )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	//	need to zero out header because we try to read it
	//	later even on failure
	memset( pdbfilehdr, 0, g_cbPage );

	Call( pfsapi->ErrFileOpen( pfmp->SzDatabaseName(), &pfapiT, pfmp->FReadOnlyAttach() ) )

	Assert( pfmp->FInUse() );
	err = ( pfmp->FReadOnlyAttach() ?
			ErrUtilReadShadowedHeader : ErrUtilReadAndFixShadowedHeader )
				(	pfsapi,
					pfmp->SzDatabaseName(),
					(BYTE*)pdbfilehdr,
					g_cbPage,
					OffsetOf( DBFILEHDR, le_cbPageSize ),
					pfapiT );

	delete pfapiT;

	if ( err < 0 )
		{
		//	600 use new checksum method, so read shadow will fail with JET_errDiskIO.
		if ( JET_errDiskIO == err )
			{
			if ( 	ulDAEMagic == pdbfilehdr->le_ulMagic
				 && ulDAEVersion500 == pdbfilehdr->le_ulVersion )
				{
				//	500 has different way of doing checksum. Let's check the version directly.
				//	The magic number stays the same since 500

				err = ErrERRCheck( JET_errDatabase500Format );
				}

			else
				{
				err = ErrDBICheck200And400( pfsapi, pfmp->SzDatabaseName() );

				if ( err != JET_errDatabase200Format && err != JET_errDatabase400Format )
					{
					if ( pdbfilehdr->le_ulMagic == ulDAEMagic )
						err = ErrERRCheck( JET_errInvalidDatabaseVersion );
					else
						err = ErrERRCheck( JET_errDatabaseCorrupted );
					}
				}
			}

		goto HandleError;
		}

	//  the version and update numbers should always increase
	Assert( ulDAEVersion >= ulDAEVersionESE97 );

	//	do version check
	if ( ulDAEMagic != pdbfilehdr->le_ulMagic )
		{
		err = ErrERRCheck( JET_errInvalidDatabaseVersion );
		goto HandleError;
		}
	else if ( pdbfilehdr->le_ulVersion >= ulDAEVersionESE97 )
		{
		//  if the database format needs to be upgraded we will do it after
		//  attaching
		err = JET_errSuccess;
		}
	else
		{
		Assert( pdbfilehdr->le_ulVersion < ulDAEVersion );
		err = ErrERRCheck( JET_errInvalidDatabaseVersion );
		goto HandleError;
		}

	//  do pagesize check
	if ( ( 0 == pdbfilehdr->le_cbPageSize && g_cbPageDefault != g_cbPage )
			|| ( 0 != pdbfilehdr->le_cbPageSize && pdbfilehdr->le_cbPageSize != g_cbPage ) )
			{
			Call( ErrERRCheck( JET_errPageSizeMismatch ) );
			}

	if ( !fGlobalRepair )
		{
		if ( pdbfilehdr->Dbstate() != JET_dbstateConsistent )
			{
			if ( JET_dbstateForceDetach == pdbfilehdr->Dbstate() )
				{
				CHAR		szT1[128];
				const CHAR	*rgszT[3];
				LOGTIME		tm;

				/*	log event that the database is not recovered completely
				/**/
				rgszT[0] = pfmp->SzDatabaseName();
				tm = pdbfilehdr->signDb.logtimeCreate;
				sprintf( szT1, "%d/%d/%d %d:%d:%d",
					(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
					(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
				rgszT[1] = szT1;

				UtilReportEvent(
						eventError,
						LOGGING_RECOVERY_CATEGORY,
						RESTORE_DATABASE_MISSED_ERROR_ID,
						2,
						rgszT,
						0,
						NULL,
						pfmp->Pinst() );
				err = ErrERRCheck( JET_errDatabaseInconsistent );
				}
			else if ( pdbfilehdr->Dbstate() == JET_dbstateBeingConverted )
				{
				const CHAR	*rgszT[1];

				rgszT[0] = pfmp->SzDatabaseName();

				//	attempting to use a database which did not successfully
				//	complete conversion
				UtilReportEvent(
						eventError,
						CONVERSION_CATEGORY,
						CONVERT_INCOMPLETE_ERROR_ID,
						1,
						rgszT,
						0,
						NULL,
						pfmp->Pinst() );
				err = ErrERRCheck( JET_errDatabaseIncompleteUpgrade );
				}
			else
				{
				// we want to return a specific error if the database is from a backup set and not recovered
				if ( 0 != pdbfilehdr->bkinfoFullCur.le_genLow )
					{
					const CHAR	*rgszT[1];

					rgszT[0] = pfmp->SzDatabaseName();

					//	attempting to use a database which did not successfully
					//	complete conversion
					UtilReportEvent(
							eventError,
							LOGGING_RECOVERY_CATEGORY,
							ATTACH_TO_BACKUP_SET_DATABASE_ERROR_ID,
							1,
							rgszT,
							0,
							NULL,
							pfmp->Pinst() );
					err = ErrERRCheck( JET_errSoftRecoveryOnBackupDatabase );
					}
				else
					{
					err = ErrERRCheck( JET_errDatabaseInconsistent );
					}
				}
			goto HandleError;
			}
		}

	// make sure the attached file is a database file
	if ( attribDb != pdbfilehdr->le_attrib
		|| ( filetypeUnknown != pdbfilehdr->le_filetype && filetypeDB != pdbfilehdr->le_filetype ) )
		{
		const CHAR	*rgszT[1];
		rgszT[0] = pfmp->SzDatabaseName();

		UtilReportEvent(
				eventError,
				DATABASE_CORRUPTION_CATEGORY,
				DATABASE_HEADER_ERROR_ID,
				1,
				rgszT,
				0,
				NULL,
				pfmp->Pinst() );

		Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
		}

	Assert( pfmp->Pdbfilehdr() == NULL );
	Call( pfmp->ErrSetPdbfilehdr( pdbfilehdr ) );
	pfmp->SetDbtimeLast( pdbfilehdr->le_dbtimeDirtied );
	Assert( pfmp->Pdbfilehdr()->le_dbtimeDirtied != 0 );
	pfmp->SetObjidLast( pdbfilehdr->le_objidLast );
	Assert( pfmp->Pdbfilehdr()->le_objidLast != 0 );

	return JET_errSuccess;

HandleError:
	Assert( err < 0 );
	Assert( NULL != pdbfilehdr );
	OSMemoryPageFree( (VOID *)pdbfilehdr );
	return err;
	}

VOID DBISetHeaderAfterAttach( DBFILEHDR_FIX *pdbfilehdr, LGPOS lgposAttach, IFMP ifmp, BOOL fKeepBackupInfo )
	{
	LOG *plog = PinstFromIfmp( ifmp )->m_plog;

	//	Update database file header.

	if ( pdbfilehdr->Dbstate() != JET_dbstateInconsistent )
		{
		Assert( pdbfilehdr->Dbstate() == JET_dbstateConsistent );
		if ( plog->m_fLogDisabled )
			{
			pdbfilehdr->SetDbstate( JET_dbstateInconsistent );
			}
		else
			{
			pdbfilehdr->SetDbstate( JET_dbstateInconsistent, plog->m_plgfilehdr->lgfilehdr.le_lGeneration, &plog->m_plgfilehdr->lgfilehdr.tmCreate );
			if ( plog->m_fRecovering )
				{
				pdbfilehdr->SetDbFromRecovery();
				}
			else
				{
				pdbfilehdr->ResetDbFromRecovery();
				}
			}
		}

	Assert( !rgfmp[ifmp].FLogOn() || !plog->m_fLogDisabled );
	Assert( pdbfilehdr->le_dbtimeDirtied >= rgfmp[ifmp].DbtimeLast() );
	Assert( pdbfilehdr->le_objidLast >= rgfmp[ifmp].ObjidLast() );

	if ( objidFDPThreshold < (ULONG)(pdbfilehdr->le_objidLast) )
		{
		const _TCHAR *rgpszT[1] = { rgfmp[ifmp].SzDatabaseName() };
		UtilReportEvent(
				eventWarning,
				GENERAL_CATEGORY,
				ALMOST_OUT_OF_OBJID,
				1,
				rgpszT,
				0,
				NULL,
				PinstFromIfmp( ifmp ) );
		}

	//	reset bkinfo except in the recovering UNDO mode where
	//	we would like to keep the original backup information.

	if ( !fKeepBackupInfo )
		{
		if ( !rgfmp[ifmp].FLogOn()
			|| memcmp( &pdbfilehdr->signLog, &plog->m_signLog, sizeof( SIGNATURE ) ) != 0 )
			{
			//	if no log or the log signaure is not the same as current log signature,
			//	then the bkinfoIncPrev and bfkinfoFullPrev are not meaningful.

			memset( &pdbfilehdr->bkinfoIncPrev, 0, sizeof( BKINFO ) );
			memset( &pdbfilehdr->bkinfoFullPrev, 0, sizeof( BKINFO ) );
			}
		memset( &pdbfilehdr->bkinfoFullCur, 0, sizeof( BKINFO ) );
		// reset the snapshot data as well
		memset( &pdbfilehdr->bkinfoSnapshotCur, 0, sizeof( BKINFO ) );
		}

	if ( fGlobalRepair )
		{
		//	preserve the signature
		}
	else if ( plog->m_fRecovering || rgfmp[ifmp].FLogOn() )
		{
		Assert( !plog->m_fLogDisabled );
		Assert( plog->m_fSignLogSet );
		Assert( 0 != CmpLgpos( lgposMin, rgfmp[ifmp].LgposAttach() ) );
		Assert( 0 == CmpLgpos( lgposMin, rgfmp[ifmp].LgposDetach() ) );

		//	set new attachment time
		pdbfilehdr->le_lgposAttach = lgposAttach;

		//	Set global signature.
		if ( 0 != memcmp( &pdbfilehdr->signLog, &plog->m_signLog, sizeof(SIGNATURE) ) )
			{
			//	must reset lgposConsistent for this log set
			//	keep that order (set lgposConsistent first
			//	then signLog) for the following two lines
			//	it is used by LGLoadAttachmentsFromFMP
			pdbfilehdr->le_lgposConsistent = lgposMin;
			pdbfilehdr->signLog = plog->m_signLog;
			}
		}
	else
		{
		//	must regenerate signDb to disassociate it from the past
		SIGGetSignature( &pdbfilehdr->signDb );
		}

	LGIGetDateTime( &pdbfilehdr->logtimeAttach );

	//	reset detach time
	pdbfilehdr->le_lgposDetach = lgposMin;
	memset( &pdbfilehdr->logtimeDetach, 0, sizeof( LOGTIME ) );

	//	version compatibility checks already performed,
	//	so just update version info
	pdbfilehdr->le_ulVersion = ulDAEVersion;
	pdbfilehdr->le_ulUpdate = ulDAEUpdate;

	pdbfilehdr->le_dbid = rgfmp[ ifmp ].Dbid();
	}


//  ================================================================
INLINE ERR ErrDBTryCreateMSU( IN PIB * const ppib, IN const IFMP ifmp, IN const JET_GRBIT grbit )
//  ================================================================
	{
	ERR			err				= JET_errSuccess;
	CHAR * const szDatabaseName	= rgfmp[ifmp].SzDatabaseName();
	IFMP		ifmpT;

	if( grbit & JET_bitDbReadOnly || fGlobalRepair )
		{
		//	no-one will be modifying the database so it doesn't matter if MSU exists or not
		//	repair doesn't want the table created
		return JET_errSuccess;
		}

	Call( ErrDBOpenDatabase( ppib, szDatabaseName, &ifmpT, NO_GRBIT ) );
	Assert( ifmp == ifmpT );

	if( JET_wrnFileOpenReadOnly == err )
		{
		//	we have attached to a read-only file, but JET_bitDbReadOnly was not specified
		//	no-one will be modifying the database so it doesn't matter if MSU exists or not
		err = JET_errSuccess;
		}
	else
		{
		//	look for MSU. we used to simply create MSU and look for JET_errTableDuplicate
		//	but that led to nullified RCE's filling the version store when a process did
		//	a lot of attaches (BUG 624358)

		err = ErrCATSeekTable( ppib, ifmpT, szMSU, NULL, NULL );
		if( err < JET_errSuccess )
			{
			if( JET_errObjectNotFound == err )
				{
				err = ErrCATCreateMSU( ppib, ifmpT );
				}
			}
		}

	CallS( ErrDBCloseDatabase( ppib, ifmpT, 0 ) );

	Call( err );

	return err;

HandleError:	//	error case only
	//	Detach the database, ignoring any errors since an error already occurred
	Assert( err < 0 );
	(VOID)ErrIsamDetachDatabase( (JET_SESID) ppib, NULL, szDatabaseName );
	return err;

	}

INLINE ERR ErrDBDeleteUnicodeIndexes( PIB *ppib, const IFMP ifmp )
	{
	ERR			err = JET_errSuccess;
	IFMP		ifmpT = 0;
	BOOL		fReadOnly = fFalse;
	BOOL		fIndexesDeleted = fFalse;
	BOOL		fT = fFalse;
	CHAR		*szDatabaseName		= rgfmp[ifmp].SzDatabaseName();

	Call( ErrDBOpenDatabase( ppib, szDatabaseName, &ifmpT, NO_GRBIT ) );
	fReadOnly = ( JET_wrnFileOpenReadOnly == err );
	Assert( ifmp == ifmpT );


	if ( !fReadOnly )
		{
		err = ErrCATDeleteLocalizedIndexes(
					ppib,
					ifmpT,
					&fIndexesDeleted,
					&fT,
					fReadOnly,
					fTrue );

		if ( fIndexesDeleted )
			{
			//	signal version cleanup to reclaim space from
			//	the deleted indices (in case the user recreates
			//	the indices, the hope is that space requests
			//	will be serviced by space released from the
			//	deleted indices)
			//
			VERSignalCleanup( ppib );
			}
		}

	CallS( ErrDBCloseDatabase( ppib, ifmpT, 0 ) );
	Call( err );

	return err;

HandleError:
	//	detach the database, ignoring any errors since an error already occurred
	//
	Assert( err < 0 );
	(VOID)ErrIsamDetachDatabase( (JET_SESID) ppib, NULL, rgfmp[ifmp].SzDatabaseName() );
	return err;
	}

INLINE ERR ErrDBUpgradeForLocalisation( PIB *ppib, const IFMP ifmp, const JET_GRBIT grbit )
	{
	ERR			err;
	INST		* const pinst = PinstFromPpib( ppib );
	IFMP		ifmpT;
	BOOL		fIndexesDeleted		= fFalse;
	BOOL		fIndexCleanupNeeded = fFalse;
	const CHAR	*rgsz[9];

	BOOL		fReadOnly;

	//	Write out header with build # = 0 so that any crash from now
	//	will have buld # 0. This will cause upgrade again till it is done.
	DBFILEHDR_FIX	*pdbfilehdr			= rgfmp[ifmp].Pdbfilehdr();
	CHAR		*szDatabaseName		= rgfmp[ifmp].SzDatabaseName();

//	UNDONE: Is the statement below true??? I don't think it has to be zeroed out because
//	on restart, the version stamp will still be mismatched and index update will still
//	be forced.
//			For JET97 only. We need to zero out build number so that when it crashes
//			in the middle of index delete/create, it will always redo delete/create.
//			pdbfilehdr->dwBuildNumber = 0;
//			Assert( ifmp != PinstFromPpib( ppib )->m_mpdbidifmp[dbidTemp] );
//			err = ErrUtilWriteShadowedHeader( PinstFromPpib( ppib )->m_pfsapi, szFileName, (BYTE*)pdbfilehdr, g_cbPage );

	if( !pinst->m_fEnableIndexChecking && !pinst->m_fEnableIndexCleanup )
		{
		//	we aren't going to check any thing
		//	return without generating any eventlogs or changing the OS version in the header
		return JET_errSuccess;
		}
	
	Call( ErrDBOpenDatabase( ppib, szDatabaseName, &ifmpT, NO_GRBIT ) );
	fReadOnly = ( JET_wrnFileOpenReadOnly == err || grbit & JET_bitDbReadOnly );

	Assert( ifmp == ifmpT );

	if ( 0 == pdbfilehdr->le_dwMajorVersion )
		{
		CHAR	rgszVerInfo[4][16];

		sprintf( rgszVerInfo[0], "%d", dwGlobalMajorVersion );
		sprintf( rgszVerInfo[1], "%d", dwGlobalMinorVersion );
		sprintf( rgszVerInfo[2], "%d", dwGlobalBuildNumber );
		sprintf( rgszVerInfo[3], "%d", lGlobalSPNumber );

		rgsz[0]	= szDatabaseName;
		rgsz[1] = rgszVerInfo[0];
		rgsz[2] = rgszVerInfo[1];
		rgsz[3] = rgszVerInfo[2];
		rgsz[4] = rgszVerInfo[3];

		UtilReportEvent(
				eventInformation,
				DATA_DEFINITION_CATEGORY,
				START_INDEX_CLEANUP_UNKNOWN_VERSION_ID,
				5,
				rgsz,
				0,
				NULL,
				PinstFromPpib( ppib ) );
		}
	else
		{
		CHAR	rgszVerInfo[8][16];

		sprintf( rgszVerInfo[0], "%d", DWORD( pdbfilehdr->le_dwMajorVersion ));
		sprintf( rgszVerInfo[1], "%d", DWORD( pdbfilehdr->le_dwMinorVersion ));
		sprintf( rgszVerInfo[2], "%d", DWORD( pdbfilehdr->le_dwBuildNumber ));
		sprintf( rgszVerInfo[3], "%d", DWORD( pdbfilehdr->le_lSPNumber ));
		sprintf( rgszVerInfo[4], "%d", dwGlobalMajorVersion );
		sprintf( rgszVerInfo[5], "%d", dwGlobalMinorVersion );
		sprintf( rgszVerInfo[6], "%d", dwGlobalBuildNumber );
		sprintf( rgszVerInfo[7], "%d", lGlobalSPNumber );

		rgsz[0]	= szDatabaseName;
		rgsz[1] = rgszVerInfo[0];
		rgsz[2] = rgszVerInfo[1];
		rgsz[3] = rgszVerInfo[2];
		rgsz[4] = rgszVerInfo[3];
		rgsz[5] = rgszVerInfo[4];
		rgsz[6] = rgszVerInfo[5];
		rgsz[7] = rgszVerInfo[6];
		rgsz[8] = rgszVerInfo[7];

		UtilReportEvent(
				eventInformation,
				DATA_DEFINITION_CATEGORY,
				START_INDEX_CLEANUP_KNOWN_VERSION_ID,
				9,
				rgsz,
				0,
				NULL,
				PinstFromPpib( ppib ) );
		}

	if( pinst->m_fEnableIndexChecking )
		{
		err = ErrCATDeleteLocalizedIndexes(
					ppib,
					ifmpT,
					&fIndexesDeleted,
					&fIndexCleanupNeeded,
					( fReadOnly || !( grbit & JET_bitDbDeleteCorruptIndexes ) ),
					fFalse );

		if( err >= JET_errSuccess && fIndexCleanupNeeded )
			{
			if( fReadOnly )
				{
				Assert( !fIndexesDeleted );

				const INT cszT				= 1;
				const CHAR * rgszT[cszT] 	= { rgfmp[ifmp].SzDatabaseName() };

				UtilReportEvent(
					eventInformation,
					DATA_DEFINITION_CATEGORY,
					MSU_CLEANUP_FAIL_RO_ID,
					cszT,
					rgsz,
					0,
					NULL,
					PinstFromPpib( ppib ) );
					
				err = ErrERRCheck( JET_errSecondaryIndexCorrupted );
				}
			else
				{
				err = ErrCATFixupUnicodeIndexes( ppib, ifmpT );
				}
			}
		}
	else if( pinst->m_fEnableIndexCleanup )
		{
		//	fixup the unicode indexes, this will be transparent to the application
		err = ErrCATFixupUnicodeIndexes( ppib, ifmpT );
		}
	else
		{
		//	don't do anything
		err = JET_errSuccess;
		}

	CallS( ErrDBCloseDatabase( ppib, ifmpT, 0 ) );

	Call( err );

	UtilReportEvent(
			eventInformation,
			DATA_DEFINITION_CATEGORY,
			STOP_INDEX_CLEANUP_ID,
			1,
			rgsz,
			0,
			NULL,
			PinstFromPpib( ppib ) );

	//	Update the header with the new version info

	pdbfilehdr->le_dwMajorVersion = dwGlobalMajorVersion;
	pdbfilehdr->le_dwMinorVersion = dwGlobalMinorVersion;
	pdbfilehdr->le_dwBuildNumber = dwGlobalBuildNumber;
	pdbfilehdr->le_lSPNumber = lGlobalSPNumber;
	pdbfilehdr->ResetUpgradeDb();

	if ( fIndexesDeleted )
		{
		//	signal version cleanup to reclaim space from
		//	the deleted indices (in case the user recreates
		//	the indices, the hope is that space requests
		//	will be serviced by space released from the
		//	deleted indices)
		//
		VERSignalCleanup( ppib );
		err = ErrERRCheck( JET_wrnCorruptIndexDeleted );
		}
	else
		{
		err = JET_errSuccess;
		}

	return err;

HandleError:
	//	Detach the database, ignoring any errors since an error already occurred
	Assert( err < 0 );
	(VOID)ErrIsamDetachDatabase( (JET_SESID) ppib, NULL, rgfmp[ifmp].SzDatabaseName() );
	return err;

	}


LOCAL VOID DBReportPartiallyAttachedDb(
	const INST	*pinst,
	const CHAR	*szDbName,
	const ULONG	ulAttachStage,
	const ERR	err )
	{
	CHAR		szErr[16];
	CHAR		szAttachStage[16];
	const CHAR	* rgszT[3]	= { szDbName, szAttachStage, szErr };

	sprintf( szAttachStage, "%d", ulAttachStage );
	sprintf( szErr, "%d", err );
	UtilReportEvent(
			eventError,
			DATABASE_CORRUPTION_CATEGORY,
			DB_PARTIALLY_ATTACHED_ID,
			3,
			rgszT,
			0,
			NULL,
			pinst );
	}

LOCAL VOID DBReportPartiallyDetachedDb(
	const INST	*pinst,
	const CHAR	*szDbName,
	const ERR	err )
	{
	CHAR		szErr[16];
	const CHAR	* rgszT[2]	= { szDbName, szErr };

	sprintf( szErr, "%d", err );
	UtilReportEvent(
			eventError,
			DATABASE_CORRUPTION_CATEGORY,
			DB_PARTIALLY_DETACHED_ID,
			2,
			rgszT,
			0,
			NULL,
			pinst );
	}


#ifndef RTM
//  ================================================================
LOCAL ERR ErrDBCheckMSU( IN PIB * const ppib, IN const CHAR * const szDatabaseName )
//  ================================================================
	{
	const INT crecordsToCheck = 1000;

	ERR		err = JET_errSuccess;

	if( fGlobalRepair )
		{
		//	not sure if the table is OK. don't go traipsing through it
		return JET_errSuccess;
		}

	IFMP ifmp;
	Call( ErrDBOpenDatabase( ppib, const_cast<CHAR *>( szDatabaseName ), &ifmp, NO_GRBIT ) );
	err = ErrCATVerifyMSU( ppib, ifmp, crecordsToCheck, NULL, CPRINTFDEBUG::PcprintfInstance() );
	CallS( ErrDBCloseDatabase( ppib, ifmp, 0 ) );

	Call( err );

	return err;

HandleError:	//	error cases only

	//	Detach the database, ignoring any errors since an error already occurred
	Assert( err < 0 );
	(VOID)ErrIsamDetachDatabase( (JET_SESID) ppib, NULL, rgfmp[ifmp].SzDatabaseName() );
	return err;
	}
#endif


ERR ISAMAPI ErrIsamAttachDatabase(
	JET_SESID			sesid,
	const CHAR			*szDatabaseName,
	const CHAR			*szSLVName,
	const CHAR			*szSLVRoot,
	const ULONG			cpgDatabaseSizeMax,
	JET_GRBIT			grbit )
	{
	PIB					*ppib;
	ERR					err;
	IFMP				ifmp;
	CHAR				rgchSLVName[IFileSystemAPI::cchPathMax];
	CHAR				rgchDbFullName[IFileSystemAPI::cchPathMax];
	CHAR				rgchSLVFullName[IFileSystemAPI::cchPathMax];
	CHAR				rgchSLVRootName[IFileSystemAPI::cchPathMax];
	CHAR				*szDbFullName			= rgchDbFullName;
	CHAR				*szSLVFullName			= rgchSLVFullName;
	CHAR				*szSLVRootName			= rgchSLVRootName;
	LGPOS				lgposLogRec;
	DBFILEHDR			*pdbfilehdr				= NULL;
#ifdef INDEPENDENT_DB_FAILURE
	DBFILEHDR			*pdbfilehdrRevert		= NULL;
#endif
	SLVFILEHDR			*pslvfilehdr			= NULL;
	BOOL				fReadOnly;

	BOOL				fUpgradeForLocalization;
	BOOL				fDeleteMSUTable;

	IFileSystemAPI	*pfsapi;
	enum { ATTACH_NONE, ATTACH_LOGGED, ATTACH_SLV_UPDATED, ATTACH_DB_UPDATED, ATTACH_DB_OPENED, ATTACH_END }
		attachState;
	const CHAR *szAttachState[ATTACH_END] =
		{ "start", "logged attachment", "stream file header updated", "database file header updated", "database opened" };
	attachState = ATTACH_NONE;

	//	check parameters
	//
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	ppib = (PIB *)sesid;

	CallR( ErrPIBCheck( ppib ) );

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;

	if ( ppib->level > 0 )
		return ErrERRCheck( JET_errInTransaction );

	if ( grbit & JET_bitDbVersioningOff )
		return ErrERRCheck( JET_errCannotDisableVersioning );

	if ( NULL == szDatabaseName || 0 == *szDatabaseName )
		return ErrERRCheck( JET_errDatabaseInvalidPath );

	pfsapi = pinst->m_pfsapi;

	//	depend on ErrPathComplete to make same files same name
	//	thereby preventing same file to be multiply attached
	//
	err = ErrUtilPathComplete( pfsapi, szDatabaseName, rgchDbFullName, fTrue );
	//	if ( JET_errFileNotFound == err )
	//		{
	//		must return FileNotFound to retain backward-compatibility
	//		err = ErrERRCheck( JET_errDatabaseNotFound );
	//		}
	CallR( JET_errInvalidPath == err ? ErrERRCheck( JET_errDatabaseInvalidPath ) : err );


	Assert( szDbFullName == rgchDbFullName );
	Assert( szSLVFullName == rgchSLVFullName );

	//	if SLV name passed in, use that for SLV filename
	//	if no SLV name passed, base SLV name off db name
	//	if no SLV name passed in and JET_bitDbCreateStreamingFile NOT specified, don't create SLV file
	//
	if ( NULL != szSLVName && 0 != *szSLVName )
		{
		err = pfsapi->ErrPathComplete( szSLVName, rgchSLVName );
		CallR( err == JET_errInvalidPath ? ErrERRCheck( JET_errSLVInvalidPath ) : err );

		if ( NULL != szSLVRoot && 0 != *szSLVRoot )
			{
			CallR( ErrUTILCheckPathName( szSLVRootName, szSLVRoot, IFileSystemAPI::cchPathMax ) );
			}
		else if ( pinst->FSLVProviderEnabled() )
			{
			//	must ALWAYS specify root name when SLV provider is enabled
			//
			CallR( ErrERRCheck( JET_errSLVRootNotSpecified ) );
			}
		else
			{
			//	auto-generate root name only
			//
			CallR( ErrDBGetSLVNameFromDbName( pinst, pfsapi, szDbFullName, NULL, szSLVRootName ) );
			}
		}
	else
		{
		CallR( ErrDBGetSLVNameFromDbName( pinst, pfsapi, szDbFullName, rgchSLVName, szSLVRootName ) );
		}

	err = ErrUtilPathExists( pfsapi, rgchSLVName, rgchSLVFullName );
	if ( JET_errFileNotFound == err )
		{
		if ( NULL != szSLVName && 0 != *szSLVName )
			{
			//	client specified SLV file, but it doesn't exist
			//
			err = ErrERRCheck( JET_errSLVStreamingFileMissing );
			}
		else
			{
			//	client didn't specify SLV file, so we assume
			//	it has the same base name as the db, but in
			//	fact, an SLV may not have existed at all
			//	assume this is okay and detect true missing
			//	SLV file later when we read the db header
			//
			szSLVFullName = NULL;
			szSLVRootName = NULL;
			err = JET_errSuccess;
			}
		}
	CallR( err );

	//  attaching to the SLV causes us to read the SLVAvail and SLVOwnerMap
	//  trees. we don't want to do this during repair as we haven't checked
	//  them yet. avoid attaching the SLV during integrity/repair and open
	//  the file manually
	//
	if( fGlobalRepair )
		{
		szSLVFullName = NULL;
		szSLVRootName = NULL;
		}

	CallR( ErrUtilPathReadOnly( pfsapi, szDbFullName, &fReadOnly ) );
	if ( fReadOnly && !( grbit & JET_bitDbReadOnly ) )
		{
		err = ErrERRCheck( JET_errDatabaseFileReadOnly );
		return err;
		}

	if ( NULL != szSLVFullName )
		{
		CallR( ErrUtilPathReadOnly( pfsapi, szSLVFullName, &fReadOnly ) );
		if ( fReadOnly && !( grbit & JET_bitDbReadOnly ) )
			{
			err = ErrERRCheck( JET_errSLVStreamingFileReadOnly );
			return err;
			}
		}

	plog->m_critBackupInProgress.Enter();

	if ( plog->m_fBackupInProgress )
		{
		plog->m_critBackupInProgress.Leave();
		return ErrERRCheck( JET_errBackupInProgress );
		}

	err = FMP::ErrNewAndWriteLatch( &ifmp, szDbFullName, szSLVFullName, szSLVRootName, ppib, pinst, pfsapi, dbidMax );
	if ( err != JET_errSuccess )
		{
#ifdef DEBUG
		switch ( err )
			{
			case JET_wrnDatabaseAttached:
			case JET_errOutOfMemory:
			case JET_errDatabaseInUse:
			case JET_errTooManyAttachedDatabases:
			case JET_errDatabaseSharingViolation:
			case JET_errSLVStreamingFileInUse:
			case JET_errDatabaseInvalidPath:
			case JET_errSLVInvalidPath:
				break;
			default:
				CallS( err );		//	force error to be reported in assert
			}
#endif
		plog->m_critBackupInProgress.Leave();
		return err;
		}

	//	from this point we got a valid ifmp entry. Start the attaching DB process.
	//
	FMP *pfmp;
	pfmp = &rgfmp[ ifmp ];

	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetAttachingDB( );
	pfmp->RwlDetaching().LeaveAsWriter();

	//	backup thread will wait on attach complition from this point
	//	as the db is marked as attaching.
	//
	plog->m_critBackupInProgress.Leave();

	//	set database loggable flags
	//
	if ( grbit & JET_bitDbRecoveryOff )
		{
		pfmp->ResetLogOn();
		}
	else
		{
		Assert( pfmp->Dbid() != dbidTemp );

		//	set all databases loggable except Temp if not specified in grbit
		//
		pfmp->SetLogOn();
		}

	// Can only turn versioning off for CreateDatabase().
	// UNDONE:  Is it useful to allow user to turn versioning off for AttachDatabase()?
	//
	Assert( !pfmp->FVersioningOff() );
	pfmp->ResetVersioningOff();

	//	set up FMP before logging
	//
	if ( grbit & JET_bitDbReadOnly )
		{
		pfmp->ResetLogOn();
		pfmp->SetVersioningOff();
		pfmp->SetReadOnlyAttach();
		}
	else
		{
		pfmp->ResetReadOnlyAttach();
		}

	pfmp->SetDatabaseSizeMax( cpgDatabaseSizeMax );

	//	Make sure the database is a good one

	Assert( UtilCmpFileName( pfmp->SzDatabaseName(), szDbFullName ) == 0 );
	Assert( !(grbit & JET_bitDbReadOnly) == !rgfmp[ifmp].FReadOnlyAttach() );
	Call( ErrDBReadHeaderCheckConsistency( pfsapi, pfmp ) );
	pdbfilehdr = pfmp->Pdbfilehdr();
	Assert( NULL != pdbfilehdr );

	//	verify db matches SLV file, if any
	if ( NULL != szSLVFullName )
		{
		Assert ( !fGlobalRepair );
		if ( pdbfilehdr->FSLVExists() )
			{
			IFileAPI *	pfapiT;

			Assert( NULL != pfmp->SzSLVName() );
			Assert( NULL == pslvfilehdr );
			Assert( !(grbit & JET_bitDbReadOnly) == !pfmp->FReadOnlyAttach() );

			pslvfilehdr = (SLVFILEHDR *)PvOSMemoryPageAlloc( g_cbPage, NULL );
			if ( NULL == pslvfilehdr )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			Call( pfsapi->ErrFileOpen( pfmp->SzSLVName(), &pfapiT, pfmp->FReadOnlyAttach() ) )

			err = ErrSLVReadHeader(
						pfsapi,
						pfmp->FReadOnlyAttach(),
						pfmp->SzSLVName(),
						pfmp->Pdbfilehdr(),
						pslvfilehdr,
						pfapiT );

			delete pfapiT;

			Call( err );
			}
		else
			{
			//	database does not believe an SLV should exist, but it does.
			//	Either the client specified an SLV to AttachDatabase()
			//	or he didn't specify one, but an SLV file with the
			//	same base name exists (to minimise confusion, we
			//	don't allow this).
			//
			Call( ErrERRCheck( JET_errDatabaseStreamingFileMismatch ) );
			}
		}
	else if ( fGlobalRepair )
		{
		//  we don't ever want to attach to the SLV during repair
		}
	else if ( pdbfilehdr->FSLVExists() )
		{
		Assert( NULL == pfmp->SzSLVName() );
		Call( ErrERRCheck( JET_errSLVStreamingFileMissing ) );
		}

	if ( !plog->m_fLogDisabled
		&& 0 == memcmp( &pdbfilehdr->signLog, &plog->m_signLog, sizeof(SIGNATURE) ) )
		{
#if 0	//	UNDONE: This logic detects if we are trying to detect a database that
		//	is too far in the future.  Re-enable this code when test scripts
		//	can properly handle this
		if ( CmpLgpos( &pdbfilehdr->lgposAttach, &plog->m_lgposLogRec ) > 0
			|| CmpLgpos( &pdbfilehdr->lgposConsistent, &plog->m_lgposLogRec ) > 0 )
			{
			//	something is gravely wrong - the current lgposAttach
			//	and/or lgposConsistent are ahead of the current log position
			AssertTracking();
			Call( ErrERRCheck( JET_errConsistentTimeMismatch ) );
			}
#endif
		}

	fUpgradeForLocalization = ( !plog->m_fRecovering
					&& FDBUpgradeForLocalization( pdbfilehdr ) );

	fDeleteMSUTable			= ( !plog->m_fRecovering
					&& FDBDeleteMSUTable( pdbfilehdr ) );

	//	update header if upgrade needed
	if ( !pfmp->FReadOnlyAttach() )
		{
#ifdef INDEPENDENT_DB_FAILURE
		//	remember old header in case we need to revert to it
		pdbfilehdrRevert = (DBFILEHDR *) PvOSMemoryPageAlloc( g_cbPage, NULL );
		if ( NULL == pdbfilehdrRevert )
			{
			Call( JET_errOutOfMemory );
			}
		memcpy( pdbfilehdrRevert, pdbfilehdr, sizeof( DBFILEHDR ) );
#endif

		//	log Attach
		Assert( pfmp == &rgfmp[ifmp] );
		Assert( pfmp->Pdbfilehdr() == pdbfilehdr );
		Assert( UtilCmpFileName( szDbFullName, pfmp->SzDatabaseName() ) == 0 );
		Assert( ( NULL == szSLVFullName && NULL == pfmp->SzSLVName() )
			|| UtilCmpFileName( szSLVFullName, pfmp->SzSLVName() ) == 0 );
		Assert( ( NULL == szSLVRootName && NULL == pfmp->SzSLVRoot() )
			|| UtilCmpFileName( szSLVRootName, pfmp->SzSLVRoot() ) == 0 );
		Assert( pfmp->CpgDatabaseSizeMax() == cpgDatabaseSizeMax );
		Call( ErrLGAttachDB(
				ppib,
				ifmp,
				&lgposLogRec ) );

		attachState = ATTACH_LOGGED;

		//	Update database state to be inconsistent
		DBISetHeaderAfterAttach( pdbfilehdr, lgposLogRec, ifmp, fFalse ); // do not keep bkinfo
		Assert( pdbfilehdr->le_objidLast );

		if ( !fGlobalRepair && pdbfilehdr->FSLVExists() )
			{
			Assert( NULL != szSLVFullName );
			Assert( NULL != pslvfilehdr );
			Assert( NULL != pfmp->SzSLVName() );

			Call( ErrSLVSyncHeader(	pfsapi,
									rgfmp[ifmp].FReadOnlyAttach(),
									rgfmp[ifmp].SzSLVName(),
									pdbfilehdr,
									pslvfilehdr ) );
			attachState = ATTACH_SLV_UPDATED;

			}
		else
			{
			Assert( NULL == szSLVFullName );
			Assert( NULL == pslvfilehdr );
			Assert( NULL == pfmp->SzSLVName() );
			}

		Call( ErrUtilWriteShadowedHeader(
					pfsapi,
					szDbFullName,
					fTrue,
					(BYTE*)pdbfilehdr,
					g_cbPage ) );

		attachState = ATTACH_DB_UPDATED;
		}
	else
		{
		Assert( pfmp->FReadOnlyAttach() );
		}

	OSMemoryPageFree( (VOID *)pslvfilehdr );
	pslvfilehdr = NULL;

	Call( ErrIOOpenDatabase( pfsapi, ifmp, szDbFullName ) );

	//	if we fail after this, we must close the db
	attachState = ATTACH_DB_OPENED;

#ifdef INDEPENDENT_DB_FAILURE
	OSMemoryPageFree( (VOID *)pdbfilehdrRevert );
	pdbfilehdrRevert = NULL;
#endif

	//	Make the database attached.

	Assert( !( pfmp->FAttached() ) );
	pfmp->SetAttached();

	Assert (! pfmp->FAllowHeaderUpdate() );
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetAllowHeaderUpdate();
	pfmp->RwlDetaching().LeaveAsWriter();

	pfmp->SetDbtimeOldestGuaranteed( pfmp->DbtimeLast() );
	pfmp->SetDbtimeOldestCandidate( pfmp->DbtimeLast() );
	pfmp->SetDbtimeOldestTarget( pfmp->DbtimeLast() );
	pfmp->SetTrxOldestCandidate( pinst->m_trxNewest );
	pfmp->SetTrxOldestTarget( trxMax );

	//	preread the first 16 pages of the database
	BFPrereadPageRange( ifmp, 1, 16, NULL );

	//	set the last page of the database (ulFileSizeLow), used to prevent over preread.
	//	must call after setting ReadOnly flag because opening SLV uses it
	Call( ErrDBSetLastPageAndOpenSLV( pfsapi, ppib, ifmp, pdbfilehdr->FSLVExists() && !fGlobalRepair ) );

	//	Make the fmp available for others to open etc.
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->ResetAttachingDB();
	pfmp->ReleaseWriteLatch( ppib );
	pfmp->RwlDetaching().LeaveAsWriter();

	err = JET_errSuccess;

	if ( fDeleteMSUTable && !pfmp->FReadOnlyAttach() )
		{
		CallR( ErrCATDeleteMSU( ppib, ifmp ) );
		}

	if ( FNORMStringHasUndefinedCharsIsSupported() )
		{
		//	MSU is only created if the database is on a platform
		//	that supports the requisite API's. There is no guarantee
		//	if its existance so we should always try to recreate it

		CallR( ErrDBTryCreateMSU( ppib, ifmp, grbit ) );
		}

	if ( 0 != ( grbit & JET_bitDbDeleteUnicodeIndexes ) )
		{
		CallR( ErrDBDeleteUnicodeIndexes( ppib, ifmp ) );
		}
	else if ( fUpgradeForLocalization )
		{
		CallR( ErrDBUpgradeForLocalisation( ppib, ifmp, grbit ) );
		CallSx( err, JET_wrnCorruptIndexDeleted );
		}

#ifndef RTM
	ERR wrn;
	wrn = err;
	if( !fGlobalEseutil )
		{
		CallR( ErrDBCheckMSU( ppib, rgfmp[ifmp].SzDatabaseName() ) );
		err = wrn;
		}
#endif

#ifdef FORCE_ONLINE_DEFRAG
	if ( !plog->m_fRecovering && pfmp->FLogOn() )
		{
		Assert( !pfmp->FVersioningOff() );
		Assert( !pfmp->FReadOnlyAttach() );
		CallS( ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentBatchStart ) );
		}
#endif

	return err;

HandleError:
	Assert( err < 0 );

#ifdef INDEPENDENT_DB_FAILURE
	BOOL	fDetached	= fFalse;
	if ( attachState != ATTACH_NONE )
		{
		ERR errOriginal = err;
		switch ( attachState )
			{
			case ATTACH_DB_OPENED:
				{
				ERR errT;
				Assert( pfmp->FAttached() );
				errT = ErrIsamDetachDatabase( sesid, NULL, szDbFullName );
				if ( errT < 0 )
					{
					Assert( UtilCmpFileName( szDbFullName, rgfmp[ifmp].SzDatabaseName() ) == 0 );
					if ( JET_dbstateConsistent != pfmp->Pdbfilehdr()->Dbstate() )
						{
						errT = ErrLGForceDetachDB( ppib, ifmp, 0, &lgposLogRec );
						Assert( errT >= 0 || pinst->m_plog->m_fLGNoMoreLogWrite );
						}
					err = ErrERRCheck( JET_errPartiallyAttachedDB );
					}
				else
					{
					fDetached = fTrue;
					}
				break;
				}
			default:
				Assert( fFalse );

			case ATTACH_LOGGED:
				//	Failed on database header update
				if ( !pdbfilehdr->FSLVExists() )
					{
			case ATTACH_SLV_UPDATED:
					// try to fix only if no FileAccessDenied. Otherwise we couldn't have updated DB header at all
					if ( JET_errFileAccessDenied != errOriginal )
						{
						err = ErrUtilReadShadowedHeader( pfsapi, szDbFullName, (BYTE*)pdbfilehdr, g_cbPage, OffsetOf( DBFILEHDR, le_cbPageSize ) );
						if ( JET_errSuccess == err )
							{
							//	If db header is updated try to revert it
							if ( 0 != memcmp( pdbfilehdr, pdbfilehdrRevert, sizeof( DBFILEHDR ) ) )
								{
				case ATTACH_DB_UPDATED:
								//	revert of db header
								memcpy( pdbfilehdr, pdbfilehdrRevert, sizeof( DBFILEHDR ) );
								err = ErrUtilWriteShadowedHeader( pfsapi, szDbFullName, fTrue, (BYTE*)pdbfilehdr, g_cbPage );
								if ( JET_errSuccess != err )
									{
									ERR errT;
									//	Read new status
									errT = ErrUtilReadShadowedHeader( pfsapi, szDbFullName, (BYTE*)pdbfilehdr, g_cbPage, OffsetOf( DBFILEHDR, le_cbPageSize) );
									//	If databasa header is reverted
									if ( JET_errSuccess == errT && 0 == memcmp( pdbfilehdr, pdbfilehdrRevert, sizeof( DBFILEHDR ) ) )
										{
										err = JET_errSuccess;
										}
	  								}
								}
							}
						}
					else
						{
						err = JET_errSuccess;
						}
 					}
				else
					{
					//	Revert SLV update only if the error is not FileAccessDenied. Otherwise we didn't update the header at all
					if ( JET_errFileAccessDenied != errOriginal )
						{
						err = JET_errSuccess;
						}
					}

				if ( pdbfilehdr->FSLVExists() && JET_errSuccess == err )
					{
					// try to revert SLV header
					memcpy( pdbfilehdr, pdbfilehdrRevert, sizeof( DBFILEHDR ) );
					(VOID)ErrSLVSyncHeader(	pfsapi,
											rgfmp[ifmp].FReadOnlyAttach(),
											rgfmp[ifmp].SzSLVName(),
											pdbfilehdr,
											pslvfilehdr );
					}

				err = ErrERRCheck( JET_errPartiallyAttachedDB );
					{
					ERR errT;
					Assert( UtilCmpFileName( szDbFullName, rgfmp[ifmp].SzDatabaseName() ) == 0 );
					errT = ErrLGForceDetachDB( ppib, ifmp, fLRForceDetachRevertDBHeader, &lgposLogRec );
					Assert( errT >= 0 || pinst->m_plog->m_fLGNoMoreLogWrite );
					}
				break;
			}
		if ( err == JET_errPartiallyAttachedDB )
			{
			DBReportPartiallyAttachedDb( pinst, szDbFullName, attachState, errOriginal );
			}
		}

#else

	const BOOL	fDetached	= fFalse;

	if ( attachState != ATTACH_NONE )
		{
		//	we have to take the instance offline if there is an error
		//	during attach and the attach is logged
		Assert( err < JET_errSuccess );
		pinst->SetInstanceUnavailable( err );
		ppib->SetErrRollbackFailure( err );
		DBReportPartiallyAttachedDb( pinst, szDbFullName, attachState, err );
		}

#endif	//	INDEPENDENT_DB_FAILURE

	Assert( pfmp->CrefWriteLatch() == 1 );
	if ( !fDetached )
		{
		if ( FIODatabaseOpen( ifmp ) )
			{
			BFPurge( ifmp );
			BFPurge( ifmp | ifmpSLV );

			IOCloseDatabase( ifmp );
			}

		FMP::EnterCritFMPPool();
		pfmp->RwlDetaching().EnterAsWriter();
		DBResetFMP(  pfmp, plog, fFalse );
		pfmp->ReleaseWriteLatchAndFree( ppib );
		pfmp->RwlDetaching().LeaveAsWriter();
		FMP::LeaveCritFMPPool();
		}
	else
		{
#ifdef INDEPENDENT_DB_FAILURE
		//	UNDONE: this won't work, because the fmp has already been released
		Assert( fFalse );
		pfmp->RwlDetaching().EnterAsWriter();
		pfmp->ReleaseWriteLatch( ppib );
		pfmp->RwlDetaching().LeaveAsWriter();
#endif
		}

#ifdef INDEPENDENT_DB_FAILURE
	OSMemoryPageFree( (VOID *)pdbfilehdrRevert );
#endif

	OSMemoryPageFree( (VOID *)pslvfilehdr );

	return err;
	}

ERR ErrDBUpgradeDatabase(
	JET_SESID	sesid,
	const CHAR	*szDatabaseName,
	const CHAR	*szSLVName,
	JET_GRBIT	grbit )
	{
#ifdef DISABLE_SLV
	return ErrERRCheck( JET_wrnNyi );
#else
	ERR			err;
	PIB			*ppib					= PpibFromSesid( sesid );
	IFMP		ifmp;
	FMP 		*pfmp					= NULL;
	DBFILEHDR 	*pdbfilehdr				= NULL;
	SLVFILEHDR	*pslvfilehdr			= NULL;
	CHAR		rgchDbFullName[IFileSystemAPI::cchPathMax];
	CHAR		rgchSLVFullName[IFileSystemAPI::cchPathMax];
	CHAR		rgchSLVRootName[IFileSystemAPI::cchPathMax];
	CHAR		*szDbFullName			= rgchDbFullName;
	CHAR		*szSLVFullName			= rgchSLVFullName;
	CHAR		*szSLVRootName			= rgchSLVRootName;
	BOOL		fNeedToAddSLVFile		= fFalse;
	BOOL		fSLVAttached			= fFalse;
	BOOL		fOpenedDb				= fFalse;
	BOOL		fAttachLogged			= fFalse;
	const BOOL	fNeedFormatUpgrade		= fFalse;	//	UNDONE: unsupported

	//	check parameters
	//
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );

	CallR( ErrPIBCheck( ppib ) );

	if ( ppib->level > 0 )
		return ErrERRCheck( JET_errInTransaction );

	if ( NULL == szDatabaseName || 0 == *szDatabaseName )
		return ErrERRCheck( JET_errDatabaseInvalidPath );

	INST				*pinst					= PinstFromPpib( ppib );

	Assert( !pinst->FRecovering() );

	LOG					*plog					= pinst->m_plog;

	//	this never gets called on a the temp database (e.g. we do not need to force the OS file-system)

	IFileSystemAPI	*pfsapi 					= pinst->m_pfsapi;

	Assert( szDbFullName == rgchDbFullName );
	Assert( szSLVFullName == rgchSLVFullName );

	//	depend on ErrPathComplete to make same files same name
	//	thereby preventing same file to be multiply attached
	//
	err = ErrUtilPathComplete( pfsapi, szDatabaseName, szDbFullName, fTrue );
	switch ( err )
		{
		case JET_errInvalidPath:
			err = ErrERRCheck( JET_errDatabaseInvalidPath );
			break;
		case JET_errFileNotFound:
			err = ErrERRCheck( JET_errDatabaseNotFound );
			break;
		default:
			break;
		}
	CallR( err );

	if ( NULL != szSLVName && 0 != *szSLVName )
		{
		err = ErrUtilPathComplete( pfsapi, szSLVName, szSLVFullName, fFalse );
		Assert( JET_errFileNotFound != err );
		CallR( JET_errInvalidPath == err ? ErrERRCheck( JET_errSLVInvalidPath ) : err );
		fNeedToAddSLVFile = fTrue;
		}
	else
		{
		szSLVFullName = NULL;
		}

	Assert( !fNeedToAddSLVFile || szSLVFullName != NULL );

	BOOL	fReadOnly;
	CallR( ErrUtilPathReadOnly( pfsapi, szDbFullName, &fReadOnly ) );
	if ( fReadOnly )
		{
		err = ErrERRCheck( JET_errDatabaseFileReadOnly );
		return err;
		}

	plog->m_critBackupInProgress.Enter();

	if ( plog->m_fBackupInProgress )
		{
		plog->m_critBackupInProgress.Leave();
		return ErrERRCheck( JET_errBackupInProgress );
		}

	//	auto-generate root name.  Tt doesn't matter what it is because
	//	we will be detaching at the end of this function anyways.
	//
	CallR( ErrDBGetSLVNameFromDbName( pinst, pfsapi, szDbFullName, NULL, szSLVRootName ) );

	err = FMP::ErrNewAndWriteLatch( &ifmp, szDbFullName, szSLVFullName, szSLVRootName, ppib, pinst, pfsapi, dbidMax );
	if ( err != JET_errSuccess )
		{
		switch ( err )
			{
			case JET_wrnDatabaseAttached:
				err = ErrERRCheck( JET_errDatabaseInUse );
			case JET_errOutOfMemory:
			case JET_errDatabaseInUse:
			case JET_errTooManyAttachedDatabases:
			case JET_errDatabaseSharingViolation:
			case JET_errDatabaseInvalidPath:
			case JET_errSLVInvalidPath:
				break;
			default:
				CallS( err );
			}

		plog->m_critBackupInProgress.Leave();
		return err;
		}

	//	From this point we got a valid ifmp entry. Start the attaching DB process.

	pfmp = &rgfmp[ ifmp ];

	pfmp->SetCreatingDB();

	plog->m_critBackupInProgress.Leave();

	//	set database loggable flags.

	Assert( pfmp->Dbid() != dbidTemp );

	if ( grbit & JET_bitDbRecoveryOff )
		{
		pfmp->ResetLogOn();
		}
	else
		{
		//	set all databases loggable except Temp if not specified in grbit
		//
		pfmp->SetLogOn();
		}

	pfmp->SetDatabaseSizeMax( 0 );

	//	Make sure the database is a good one

	Assert( UtilCmpFileName( pfmp->SzDatabaseName(), szDbFullName ) == 0 );
	Assert( !rgfmp[ifmp].FReadOnlyAttach() );
	Call( ErrDBReadHeaderCheckConsistency( pfsapi, pfmp ) );

	Assert( NULL != pfmp->Pdbfilehdr() );
	Assert( NULL == pdbfilehdr );

	pdbfilehdr = pfmp->Pdbfilehdr();

	if ( NULL != szSLVFullName )
		{
		Assert( fNeedToAddSLVFile );
		err = ErrUtilPathExists( pfsapi, szSLVFullName );
		if ( err < 0 )
			{
			if ( JET_errFileNotFound != err )
				{
				Call( err );
				}
			if ( pdbfilehdr->FSLVExists() )
				{
				//	db thinks an SLV file should already exist for this database,
				//	but we couldn't find it
				Call( ErrERRCheck( JET_errSLVStreamingFileMissing ) );
				}
			}
		else
			{
			IFileAPI *	pfapiT;
			BOOL		fReadOnly;

			Call( ErrUtilPathReadOnly( pfsapi, szSLVFullName, &fReadOnly ) );
			if ( fReadOnly )
				{
				Call( ErrERRCheck( JET_errSLVStreamingFileReadOnly ) );
				}

			Assert( NULL != pfmp->SzSLVName() );
			Assert( NULL == pslvfilehdr );
			pslvfilehdr = (SLVFILEHDR *)PvOSMemoryPageAlloc( g_cbPage, NULL );
			if ( NULL == pslvfilehdr )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			Call( pfsapi->ErrFileOpen( pfmp->SzSLVName(), &pfapiT, fFalse ) );

			err = ErrSLVReadHeader(	pfsapi,
									fFalse,
									pfmp->SzSLVName(),
									pfmp->Pdbfilehdr(),
									pslvfilehdr,
									pfapiT );

			delete pfapiT;

			if ( err < 0 )
				{
				if ( err != JET_errDatabaseStreamingFileMismatch
					|| pdbfilehdr->FSLVExists()
					|| CmpLgpos( &pslvfilehdr->le_lgposAttach, &pdbfilehdr->le_lgposAttach ) != 0
					|| memcmp( &pslvfilehdr->signDb, &pdbfilehdr->signDb, sizeof( SIGNATURE ) ) != 0 )
					{
					OSMemoryPageFree( (VOID *)pslvfilehdr );
					pslvfilehdr = NULL;
					Call( err );
					}
				err = JET_errSuccess;
				Assert( !pdbfilehdr->FSLVExists() );

				// we will recreate an slv file again

				Call( pfsapi->ErrFileDelete( pfmp->SzSLVName() ) );
				}
			else
				{
				Assert( pdbfilehdr->FSLVExists() );
				fNeedToAddSLVFile = fFalse;
				}
			Assert( 0 <= err );
			}
		}
	else
		{
		Assert( !fNeedToAddSLVFile );
		if ( pdbfilehdr->FSLVExists() )
			{
			Assert( NULL == pfmp->SzSLVName() );
			Call( ErrERRCheck( JET_errSLVStreamingFileMissing ) );
			}
		}

	Assert( !fNeedToAddSLVFile || !pdbfilehdr->FSLVExists() );

	if ( !fNeedToAddSLVFile && !fNeedFormatUpgrade )
		{
		Call( ErrERRCheck( JET_errDatabaseAlreadyUpgraded ) );
		}

	LGPOS lgposLogRec;
	Assert( pfmp == &rgfmp[ifmp] );
	Assert( pfmp->Pdbfilehdr() == pdbfilehdr );
	Assert( UtilCmpFileName( szDbFullName, pfmp->SzDatabaseName() ) == 0 );
	Assert( ( NULL == szSLVFullName && NULL == pfmp->SzSLVName() )
		|| UtilCmpFileName( szSLVFullName, pfmp->SzSLVName() ) == 0 );
	Assert( ( NULL == szSLVRootName && NULL == pfmp->SzSLVRoot() )
		|| UtilCmpFileName( szSLVRootName, pfmp->SzSLVRoot() ) == 0 );
	Assert( pfmp->CpgDatabaseSizeMax() == 0 );
	Call( ErrLGAttachDB(
					ppib,
					ifmp,
					&lgposLogRec ) );
	fAttachLogged = fTrue;

	DBISetHeaderAfterAttach( pdbfilehdr, lgposLogRec, ifmp, fFalse );

	Assert( pdbfilehdr->le_objidLast > 0 );

	if ( fNeedFormatUpgrade )
		{
		if ( pdbfilehdr->FSLVExists() )
			{
			Assert( NULL != pslvfilehdr );
			Assert( !fNeedToAddSLVFile );
			Assert( NULL != pfmp->SzSLVName() );

			Call( ErrSLVSyncHeader(	pfsapi,
									rgfmp[ifmp].FReadOnlyAttach(),
									rgfmp[ifmp].SzSLVName(),
									pdbfilehdr,
									pslvfilehdr ) );
			}
		}
	else
		{
		Assert( !pdbfilehdr->FSLVExists() );
		}

	Call( ErrUtilWriteShadowedHeader(
				pfsapi,
				szDbFullName,
				fTrue,
				(BYTE*)pdbfilehdr,
				g_cbPage ) );

	if ( NULL != pslvfilehdr )
		{
		OSMemoryPageFree( (VOID *)pslvfilehdr );
		pslvfilehdr = NULL;
		}

	//	Make the database attached.
	Assert( !( pfmp->FAttached() ) );
	pfmp->SetAttached();

	Call( ErrIOOpenDatabase( pfsapi, ifmp, szDbFullName ) );
	DBSetOpenDatabaseFlag( ppib, ifmp );

	Assert (! pfmp->FAllowHeaderUpdate() );
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetAllowHeaderUpdate();
	pfmp->RwlDetaching().LeaveAsWriter();
	fOpenedDb = fTrue;

	pfmp->SetDbtimeOldestGuaranteed( pfmp->DbtimeLast() );
	pfmp->SetDbtimeOldestCandidate( pfmp->DbtimeLast() );
	pfmp->SetDbtimeOldestTarget( pfmp->DbtimeLast() );
	pfmp->SetTrxOldestCandidate( pinst->m_trxNewest );
	pfmp->SetTrxOldestTarget( trxMax );

	if ( fNeedToAddSLVFile )
		{
		Assert( NULL != pfmp->SzSLVName() );
		Assert( !pfmp->FSLVAttached() );
		Assert( !pdbfilehdr->FSLVExists() );
		pdbfilehdr->SetSLVExists();
		pdbfilehdr->signSLV = pdbfilehdr->signDb;

		// Check the catalog
		// if we have already set slv record in catalog we will only recreate an SLV file

		PGNO pgno;
		OBJID objidSLV;

		err = ErrCATAccessDbSLVAvail( ppib, ifmp, szSLVAvail, &pgno, &objidSLV );
		if ( err >= 0 )
			{
			err = ErrFILECreateSLV( pfsapi, ppib, ifmp, SLV_CREATESLV_CREATE );
			}
		else
			{
			err =  ErrFILECreateSLV( pfsapi, ppib, ifmp, SLV_CREATESLV_CREATE | SLV_CREATESLV_ATTACH );
			}

		if ( 0 > err )
			{
			pdbfilehdr->ResetSLVExists();
			memset ( &pdbfilehdr->signSLV, 0, sizeof( SIGNATURE ) );
			Call( err );
			}
		fSLVAttached = fTrue;

		// update DB header to mark successfull end of SLV file creation
		Call( ErrUtilWriteShadowedHeader(
						pfsapi,
						szDbFullName,
						fTrue,
						(BYTE*)pdbfilehdr,
						g_cbPage,
						pfmp->Pfapi() ) );

		Assert( !pfmp->FSLVAttached() );

		}
	else
		{
		Assert( fNeedFormatUpgrade );
		}

	Assert( pfmp->FWriteLatchByMe( ppib ) );

	DBResetOpenDatabaseFlag( ppib, ifmp );
	fOpenedDb = fFalse;

	//	Make the fmp available for detach
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->ResetCreatingDB();
	pfmp->ReleaseWriteLatch( ppib );
	pfmp->RwlDetaching().LeaveAsWriter();

	err = ErrIsamDetachDatabase(
				SesidFromPpib( ppib ),
				NULL,
				szDbFullName,
				fSLVAttached ? fLRForceDetachCreateSLV : 0 );
	if ( err < 0 && JET_errSuccess == ppib->ErrRollbackFailure() )
		{
		pinst->SetInstanceUnavailable( err );
		ppib->SetErrRollbackFailure( err );
		}

	return err;


HandleError:
	Assert( err < 0 );
	const BOOL	fDetached	= fFalse;

	if ( pslvfilehdr != NULL )
		{
		OSMemoryPageFree( (VOID *)pslvfilehdr );
		pslvfilehdr = NULL;
		}

	if ( fAttachLogged )
		{
		if ( fOpenedDb )
			{
			DBResetOpenDatabaseFlag( ppib, ifmp );
			}

#ifdef INDEPENDENT_DB_FAILURE
		ERR errT = ErrIsamDetachDatabase( SesidFromPpib( ppib ), NULL, szDbFullName, fSLVAttached ? fLRForceDetachCreateSLV: 0 );
		if ( errT < 0 && JET_dbstateConsistent != rgfmp[ifmp].Pdbfilehdr()->Dbstate() )
			{
			Assert( UtilCmpFileName( szDbFullName, rgfmp[ifmp].SzDatabaseName() ) == 0 );
			errT = ErrLGForceDetachDB( ppib, ifmp, (BYTE)(fSLVAttached? fLRForceDetachCreateSLV: 0), &lgposLogRec );
			Assert( errT >= 0 || PinstFromIfmp( ifmp )->m_plog->m_fLGNoMoreLogWrite );
			}
		else
			{
			fDetached = fTrue;
			}
		err = ( errT < 0 && err >= 0 ? errT : err );
#else
		pinst->SetInstanceUnavailable( err );
		ppib->SetErrRollbackFailure( err );
#endif
		}

	Assert( pfmp->CrefWriteLatch() == 1 );

	if ( !fDetached )
		{
		if ( FIODatabaseOpen( ifmp ) )
			{
			BFPurge( ifmp );
			BFPurge( ifmp | ifmpSLV );

			IOCloseDatabase( ifmp );
			}

		FMP::EnterCritFMPPool();
		pfmp->RwlDetaching().EnterAsWriter();
		DBResetFMP(  pfmp, plog, fFalse );
		pfmp->ReleaseWriteLatchAndFree( ppib );
		pfmp->RwlDetaching().LeaveAsWriter();
		FMP::LeaveCritFMPPool();
		}
	else
		{
#ifdef INDEPENDENT_DB_FAILURE
		//	UNDONE: this won't work, because the fmp has already been released
		Assert( fFalse );
		Assert( NULL == pfmp->Pdbfilehdr() );
		pfmp->RwlDetaching().EnterAsWriter();
		pfmp->ReleaseWriteLatch( ppib );
		pfmp->RwlDetaching().LeaveAsWriter();
#endif
		}

	return err;

#endif	//	DISABLE_SLV
	}


VOID DBResetFMP( FMP *pfmp, LOG *plog, BOOL fDetaching )
	{
	if ( pfmp->FSkippedAttach() )
		{
		Assert( NULL != plog );
		Assert( plog->m_fHardRestore );
		pfmp->ResetSkippedAttach();
		}
	else if ( pfmp->FDeferredAttach() )
		{
		Assert( NULL != plog );
		Assert( plog->m_fRecovering );
		pfmp->ResetDeferredAttach();
		}
	else
		{
		FCB::DetachDatabase( pfmp - rgfmp, fDetaching );
		}

	pfmp->ResetAttached();
#ifdef DEBUG
	pfmp->SetDatabaseSizeMax( 0xffffffff );
#endif
	pfmp->ResetExclusiveOpen( );
	pfmp->ResetLogOn();
	pfmp->ResetReadOnlyAttach();
	pfmp->ResetVersioningOff();

	//	indicate this db entry is detached.

	if ( pfmp->Pdbfilehdr() )
		{
		if ( NULL != plog &&
			 plog->m_fRecovering &&
			 plog->m_fRecoveringMode == fRecoveringRedo &&
			 pfmp->Patchchk() )
			{
			Assert( pfmp->Patchchk() );
			OSMemoryHeapFree( pfmp->Patchchk() );
			pfmp->SetPatchchk( NULL );
			}

		pfmp->FreePdbfilehdr();
		}

	if ( NULL != pfmp->Ppatchhdr() )
		{
		OSMemoryPageFree( pfmp->Ppatchhdr() );
		pfmp->SetPpatchhdr( NULL );
		}

	//	rgfmp[ifmp].szDatabaseName will be released within critFMPPool.
	//	other stream resources will be released within write latch.


#ifdef ELIMINATE_PATCH_FILE
#else
	if ( pfmp->SzPatchPath() )
		{
		Assert( plog->m_fRecovering );
		Assert( plog->m_fHardRestore );
		delete pfmp->PfapiPatch();
		pfmp->SetPfapiPatch( NULL );
		OSMemoryHeapFree( pfmp->SzPatchPath() );
		pfmp->SetSzPatchPath( NULL );
		}
#endif

	//	clean up fmp for future use

	Assert( !pfmp->Pfapi() );

	//	Free the FMP entry.

	pfmp->ResetDetachingDB();
	}


//	INDEPENDENT_DB_FAILURE is a feature that allows a database to be removed from a storage group
//	when it is errant to allow the remainder of the storage group to function normally.  The idea
//	is that the database will be repaired off-line and later re-inserted into the storage group.
//
#ifdef INDEPENDENT_DB_FAILURE
//	szDatabaseName of NULL detaches all user databases.
//
ERR ISAMAPI ErrIsamForceDetachDatabase( JET_SESID sesid, const CHAR *szDatabaseName, const JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppib = NULL;
	IFMP   	ifmp = ifmpMax;
	CHAR   	rgchFullName[IFileSystemAPI::cchPathMax];
	CHAR   	*szFullName = NULL;
	CHAR   	*szFileName = NULL;
	LGPOS	lgposLogRec;
	INST * 	pinst =  PinstFromPpib( (PIB *)sesid );
	FMP *	pfmp = NULL;
	LOG * 	plog = NULL;
	BOOL 	fFMPLatched = fFalse;
	BOOL 	fForceClose = JET_bitForceCloseAndDetach & grbit;

	//	this should not be called on the temp database (it's ok to use the regular file-system)

	//	just find full the database name, don't try to open the file
	//
	Assert ( pinst );
	CallR( pinst->m_pfsapi->ErrPathComplete( szDatabaseName, rgchFullName ) );

	//	find the instance owning the database
	//
	FMP::EnterCritFMPPool();
	for ( IFMP ifmpT = FMP::IfmpMinInUse(); ifmpT <= FMP::IfmpMacInUse(); ifmpT++ )
		{
		FMP	* pfmp = &rgfmp[ ifmpT ];

		if ( !pfmp->FInUse() )
			{
			continue;
			}

		if ( 0 != UtilCmpFileName( pfmp->SzDatabaseName(), rgchFullName ) )
			{
			continue;
			}

		ifmp = ifmpT;
		break;
		}
	FMP::LeaveCritFMPPool();

	if ( ifmpMax == ifmp )
		{
		CallR ( ErrERRCheck( JET_errDatabaseNotFound) );
		}

	szFullName = rgchFullName;

	pfmp = &rgfmp[ ifmp ];
	Assert ( pinst == PinstFromIfmp( ifmp ) );
	plog = pinst->m_plog;

	if ( !pfmp->FAllowForceDetach() )
		{
		CallR ( ErrERRCheck( JET_errForceDetachNotAllowed) );
		}

	Assert ( NULL != pinst );

	CallR ( ErrPIBBeginSession( pinst, &ppib, procidNil, fFalse ) );

	Call( FMP::ErrWriteLatchByNameSz( szFullName, &ifmpT, ppib ) );
	fFMPLatched = fTrue;
	Assert ( ifmpT == ifmp );

	Assert( !pfmp->FDetachingDB( ) );

	pfmp->SetForceDetaching();

#ifdef FORCE_ONLINE_DEFRAG
	if ( !plog->m_fRecovering && pfmp->FLogOn() )
		{
		Assert( !pfmp->FVersioningOff() );
		Assert( !pfmp->FReadOnlyAttach() );
		pfmp->ReleaseWriteLatch( ppib );
		fFMPLatched = fFalse;
		(VOID) ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentBatchStop );
		Assert( JET_wrnDefragNotRunning == err || JET_errSuccess == err );
		Call( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
		fFMPLatched = fTrue;
		pfmp = &rgfmp[ifmp];
		Assert( !pfmp->FDetachingDB( ) );
		}
#endif

	if ( pfmp->CPin() && !fForceClose )
		{
		pfmp->ReleaseWriteLatch( ppib );
		fFMPLatched = fFalse;
		Call( ErrERRCheck( JET_errDatabaseInUse ) );
		}

	if ( pfmp->CPin() )
		{
		Assert ( fForceClose );

		PIB * ppibToClean;

		pfmp->ReleaseWriteLatch( ppib );
		fFMPLatched = fFalse;
		pinst->m_critPIB.Enter();

		for (ppibToClean = pinst->m_ppibGlobal; ppibToClean; ppibToClean = ppibToClean->ppibNext)
			{
			if ( 0 == ppibToClean->rgcdbOpen[ pfmp->Dbid() ] )
				continue;

			RCE	 * prceNewest	= ppibToClean->prceNewest;

			if ( 1 > ppibToClean->level )
				{
				Assert ( prceNil == prceNewest );
				CallS ( ErrDBCloseDatabase( ppibToClean, ifmp, NO_GRBIT ) );
				continue;
				}

			// if first RCE is not from the database we want to force detach
			// where should be no operations on these DB
			if ( NULL != prceNewest && prceNewest->Ifmp() != ifmp )
				{
				CallS ( ErrDBCloseDatabase( ppibToClean, ifmp, NO_GRBIT ) );
				continue;
				}

			// we have the db opened for these session and
			// RCEs regardin these database
			// all RCE should be of these database: we will check that
			// during the rollback process

			Assert ( ifmpMax == ppibToClean->m_ifmpForceDetach );
			ppibToClean->m_ifmpForceDetach = ifmp;
			if ( 1 <= ppibToClean->level )
				{
				pinst->m_critPIB.Leave();
				PIBSetTrxContext( ppibToClean );
				// during force detach, Rollback will clean the the RCE's, etc
				// and we don;t expect any error
				CallS ( ErrIsamRollback( (JET_SESID)ppibToClean, JET_bitForceDetachRollback ) );
				pinst->m_critPIB.Enter();
				}

			Assert ( ppibToClean->level == 0 );
			Assert ( ifmp == ppibToClean->m_ifmpForceDetach );
			ppibToClean->m_ifmpForceDetach = ifmpMax;

			CallS ( ErrDBCloseDatabase( ppibToClean, ifmp, NO_GRBIT ) );
			}
		pinst->m_critPIB.Leave();

		Call( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
		fFMPLatched = fTrue;
		pfmp = &rgfmp[ifmp];
		}

	Assert ( 0 == pfmp->CPin() );

	pinst = PinstFromIfmp( ifmp );
	plog = pinst->m_plog;

	Assert ( NULL != pinst );
	Assert ( pfmp->FAttached( ) );


	//	Enter a critical section to make sure no one, especially the
	//	checkpointer, looking for pdbfilehdr

	//	From this point we got a valid ifmp entry. Start the detaching DB process.

	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetDetachingDB( );
	pfmp->RwlDetaching().LeaveAsWriter();

	Assert( pfmp->Dbid() != dbidTemp );

	//  Let all tasks active on this database complete
	//  From this point on, no additional tasks should be
	//  registered because:
	//		- OLD has terminated
	//		- the version store has been cleaned up
	//		- the database has been closed so no user actions can be performed
	CallS( pfmp->ErrWaitForTasksToComplete() );

	// Call RCE clean again, this time to clean versions on this db that
	// we may have missed.
	err = PverFromIfmp( ifmp )->ErrVERRCEClean( ifmp );
	if ( JET_wrnRemainingVersions == err )
		{
		// it means we didn't cleaned all session using the database
		// that's because they are session with RCEs on multiple databases
		// (and the first RCE wasn't on the one we are detaching)
		// we error out with session sharing violation
		EnforceSz ( JET_wrnRemainingVersions != err,
				"Force detach not allowed if sessions are used cross-databases");
		}
	CallS( err );

	Assert ( FIODatabaseOpen( ifmp ) );
	//	purge all buffers for this ifmp
	// PURGE ALL
	BFPurge( ifmp );
	BFPurge( ifmp | ifmpSLV );

	IOCloseDatabase( ifmp );

	//	log detach database
	Assert( pfmp->Dbid() != dbidTemp );
	Assert( UtilCmpFileName( szFullName, rgfmp[ifmp].SzDatabaseName() ) == 0 );
	Call( ErrLGForceDetachDB( ppib, ifmp , fForceClose? fLRForceDetachCloseSessions: (BYTE)0, &lgposLogRec ) );

	Assert (pfmp->FAllowForceDetach() );

	FMP::EnterCritFMPPool();
	pfmp->RwlDetaching().EnterAsWriter();
	DBResetFMP( pfmp, plog, fTrue );
	pfmp->ReleaseWriteLatchAndFree( ppib );
	fFMPLatched = fFalse;
	pfmp->RwlDetaching().LeaveAsWriter();
	FMP::LeaveCritFMPPool();

	PIBEndSession( ppib );

	return JET_errSuccess;

HandleError:

	//	do not reset detaching. We leave the database in detaching
	//	mode till next restore.

	if ( NULL != ppib )
		{
		pfmp->ResetForceDetaching();

		Assert ( NULL != pfmp );
		if ( fFMPLatched )
			{
			pfmp->RwlDetaching().EnterAsWriter();
			pfmp->ReleaseWriteLatch( ppib );
			pfmp->RwlDetaching().LeaveAsWriter();
			}
		PIBEndSession( ppib );
		ppib = NULL;
		}
	else
		{
		Assert ( !fFMPLatched );
		}

	return err;
	}

#endif	//	INDEPENDENT_DB_FAILURE

LOCAL ERR ErrIsamDetachAllDatabase( JET_SESID sesid, const INT flags )
	{
	ERR					err 		= JET_errSuccess;
	PIB					*ppib 		= PpibFromSesid( sesid );
	INST 				*pinst 		= PinstFromPpib( ppib );

	CallR( ErrPIBCheck( ppib ) );
	Assert ( 0 == ppib->level );

	FMP::EnterCritFMPPool();

	for ( DBID dbidDetach = dbidUserLeast; dbidDetach < dbidMax; dbidDetach++ )
		{
		IFMP ifmp = pinst->m_mpdbidifmp[ dbidDetach ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP *pfmp = &rgfmp[ ifmp ];
		if ( pfmp->FInUse() && pfmp->FAttached() )
			{
			FMP::LeaveCritFMPPool();

			FMP::AssertVALIDIFMP( pinst->m_mpdbidifmp[ dbidDetach ] );
			Assert ( NULL != rgfmp[ pinst->m_mpdbidifmp[ dbidDetach ] ].SzDatabaseName() );
			Call ( ErrIsamDetachDatabase( sesid, NULL, rgfmp[ pinst->m_mpdbidifmp[ dbidDetach ] ].SzDatabaseName(), flags ) );

			FMP::EnterCritFMPPool();
			}
		}

	FMP::LeaveCritFMPPool();

HandleError:
	return err;
	}

//	szDatabaseName of NULL detaches all user databases.
//
ERR ISAMAPI ErrIsamDetachDatabase( JET_SESID sesid, IFileSystemAPI* const pfsapiDB, const CHAR *szDatabaseName, const INT flags )
	{
	// check parameters
	//
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	// there is no unknown flags set
	Assert( (flags & ~(0xf)) == 0 );

	ERR					err 		= JET_errSuccess;
	PIB					*ppib 		= PpibFromSesid( sesid );

	CallR( ErrPIBCheck( ppib ) );

	if ( ppib->level > 0 )
		{
		return ErrERRCheck( JET_errInTransaction );
		}

	IFMP   				ifmp 			= ifmpMax;
	FMP					*pfmp 			= NULL;
	DBFILEHDR_FIX 		*pdbfilehdr 	= NULL;
	LGPOS				lgposLogRec;
	INST 				*pinst 			= PinstFromPpib( ppib );
	LOG 				*plog 			= pinst->m_plog;
	BOOL				fInCritBackup	= fFalse;
	BOOL				fDetachLogged	= fFalse;
	CHAR   				szFullName[IFileSystemAPI::cchPathMax];

	if ( pinst->FInstanceUnavailable() )
		{
		return pinst->ErrInstanceUnavailableErrorCode();
		}
	Assert( JET_errSuccess == ppib->ErrRollbackFailure() );

	//	this should never be called on the temp database (e.g. we do not need to force the OS file-system)

	IFileSystemAPI	*pfsapi			= ( NULL == pfsapiDB ) ? pinst->m_pfsapi : pfsapiDB;

	if ( NULL == szDatabaseName || 0 == *szDatabaseName )
		{
		// this function will go through m_mpdbidifmp and call ErrIsamDetachDatabase for each one
		return ErrIsamDetachAllDatabase( sesid, flags );
		}

	err = ErrUtilPathComplete( pfsapi, szDatabaseName, szFullName, fTrue );
	switch ( err )
		{
		case JET_errFileNotFound:
		case JET_errInvalidPath:
			err = ErrERRCheck( JET_errDatabaseNotFound );
			break;
		}
	CallR( err );

	plog->m_critBackupInProgress.Enter();
	fInCritBackup = fTrue;

	if ( plog->m_fBackupInProgress )
		{
		Call( ErrERRCheck( JET_errBackupInProgress ) );
		}

	Call( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) )
	pfmp = &rgfmp[ ifmp ];

	Assert( !pfmp->FDetachingDB( ) );

#ifdef FORCE_ONLINE_DEFRAG
	if ( !plog->m_fRecovering && pfmp->FLogOn() )
		{
		Assert( !pfmp->FVersioningOff() );
		Assert( !pfmp->FReadOnlyAttach() );
		pfmp->ReleaseWriteLatch( ppib );
		Call( ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentBatchStop ) );
		Assert( JET_wrnDefragNotRunning == err || JET_errSuccess == err );
		Call( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
		pfmp = &rgfmp[ifmp];
		Assert( !pfmp->FDetachingDB( ) );
		}
#endif

	if ( pfmp->CPin() )
		{
		Call( ErrERRCheck( JET_errDatabaseInUse ) );
		}

	if ( !pfmp->FAttached( ) )
		{
		Call( ErrERRCheck( JET_errDatabaseNotFound ) );
		}

	//	Enter a critical section to make sure no one, especially the
	//	checkpointer, looking for pdbfilehdr

	//	From this point we got a valid ifmp entry. Start the detaching DB process.

	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetDetachingDB( );
	pfmp->RwlDetaching().LeaveAsWriter();

	//	the version store will now process all tasks syncronously

	plog->m_critBackupInProgress.Leave();
	fInCritBackup = fFalse;

	Assert( pfmp->Dbid() != dbidTemp );

	if ( !pfmp->FSkippedAttach()
		&& !pfmp->FDeferredAttach() )
		{
		//	BUGFIX: X5:105352
		//	cleanup the version store to allow all tasks to be generated

		Call( PverFromIfmp( ifmp )->ErrVERRCEClean( ifmp ) );

		//	LaurionB 06/09/99
		//
		//	CONSIDER: if there was an active user transaction and it commits
		//	after this call version store cleanup could generate tasks after
		//	the call to ErrWaitForTasksToComplete which would cause an erroneous
		//	JET_errDatabaseInUse
		//
		//	The fix for this is to grab the version store cleanup critical section
		//	and to hold it over to calls to ErrVERRCEClean, ErrWaitForTasksToComplete
		//	and ErrVERRCEClean
		}

	//  Let all tasks active on this database complete
	//  From this point on, no additional tasks should be
	//  registered because:
	//		- OLD has terminated
	//		- the version store has been cleaned up
	//		- the database has been closed so no user actions can be performed
	CallS( pfmp->ErrWaitForTasksToComplete() );

	//	Clean up resources used by the ifmp.
	if ( !pfmp->FSkippedAttach()
		&& !pfmp->FDeferredAttach() )
		{
		// Call RCE clean again, this time to clean versions on this db that
		// we may have missed.
		Call( PverFromIfmp( ifmp )->ErrVERRCEClean( ifmp ) );

		// All versions on this ifmp should be cleanable.
		if ( JET_wrnRemainingVersions == err )
			{
			Assert( fFalse );
			err = ErrERRCheck( JET_errDatabaseInUse );

#ifdef INDEPENDENT_DB_FAILURE
			// UNDONE: check more precise error conditions to
			// allow force detach
			pfmp->SetAllowForceDetach( ppib, err );
#endif

			goto HandleError;
			}
		}

	if ( FIODatabaseOpen( ifmp ) )
		{
		//	flush all database buffers
		//
#ifdef INDEPENDENT_DB_FAILURE
		err = ErrBFFlush( ifmp );
		if ( err < 0 )
			{
			// UNDONE: check more precise error conditions to
			// allow force detach
			pfmp->SetAllowForceDetach( ppib, err );
			goto HandleError;
			}
		err = ErrBFFlush( ifmp | ifmpSLV );
		if ( err < 0 )
			{
			pfmp->SetAllowForceDetach( ppib, err );
			goto HandleError;
			}
#else
		Call( ErrBFFlush( ifmp ) );
		Call( ErrBFFlush( ifmp | ifmpSLV ) );
#endif

		//	purge all buffers for this ifmp
		//
		BFPurge( ifmp );
		BFPurge( ifmp | ifmpSLV );
		}

	//	log detach database

	Assert( pfmp->Dbid() != dbidTemp );
	Assert( UtilCmpFileName( szFullName, rgfmp[ifmp].SzDatabaseName() ) == 0 );

	Call( ErrLGDetachDB( ppib, ifmp, (BYTE)flags, &lgposLogRec ) );
	fDetachLogged = fTrue;

	if ( FIODatabaseOpen( ifmp ) )
		{
		// Now disallow header update by other threads (log writer or checkpoint advancement)
		// 1. For the log writer it is OK to generate a new log w/o updating the header as no log operations
		// for this db will be logged in new logs
		// 2. For the checkpoint: don't advance the checkpoint if db's header weren't update
		Assert ( pfmp->FAllowHeaderUpdate() || pfmp->FReadOnlyAttach() );
		pfmp->RwlDetaching().EnterAsWriter();
		pfmp->ResetAllowHeaderUpdate();
		pfmp->RwlDetaching().LeaveAsWriter();

		IOCloseDatabase( ifmp );
		}
	else
		{
		//	should be impossible
		Assert( fFalse );
		}

	//	Update database file header. If we are detaching a bogus entry,
	//	then the db file should never be opened and pdbfilehdr will be Nil.

	pdbfilehdr = pfmp->Pdbfilehdr();

	if ( !pfmp->FReadOnlyAttach() && pdbfilehdr )
		{

		Assert( !pfmp->FSkippedAttach() );
		Assert( !pfmp->FDeferredAttach() );

		//	If anything fail in this block, we simply occupy the FMP
		//	but bail out to the caller. The database in a state that it can
		//	not be used any more till next restore where FMP said it is
		//	detaching!

		// UNDONE: ask user to restart the engine.

		pdbfilehdr->SetDbstate( JET_dbstateConsistent );

		pdbfilehdr->le_dbtimeDirtied = pfmp->DbtimeLast();
		Assert( pdbfilehdr->le_dbtimeDirtied != 0 );
		pdbfilehdr->le_objidLast = pfmp->ObjidLast();
		Assert( pdbfilehdr->le_objidLast != 0 );

		if ( pfmp->FLogOn() )
			{
			Assert( !plog->m_fLogDisabled );
			Assert( FSIGSignSet( &pdbfilehdr->signLog ) );

			//	Set detachment time.

			if ( plog->m_fRecovering && plog->m_fRecoveringMode == fRecoveringRedo )
				{
				Assert( szDatabaseName );
				pdbfilehdr->le_lgposDetach = plog->m_lgposRedo;
				}
			else
				pdbfilehdr->le_lgposDetach = lgposLogRec;

			pdbfilehdr->le_lgposConsistent = pdbfilehdr->le_lgposDetach;
			}
		LGIGetDateTime( &pdbfilehdr->logtimeDetach );
		pdbfilehdr->logtimeConsistent = pdbfilehdr->logtimeDetach;

		if ( flags & fLRForceDetachRevertDBHeader )
			{
			Assert( pfmp->Patchchk() != NULL );
			ATCHCHK *patchchk = pfmp->Patchchk();
			pdbfilehdr->le_lgposAttach = patchchk->lgposAttach;
			pdbfilehdr->le_lgposDetach = pdbfilehdr->le_lgposConsistent = patchchk->lgposConsistent;
			pdbfilehdr->signDb = patchchk->signDb;
			pdbfilehdr->signLog = patchchk->signLog;
			memset( &pdbfilehdr->logtimeAttach, 0, sizeof( LOGTIME ) );
			memset( &pdbfilehdr->logtimeConsistent, 0, sizeof( LOGTIME ) );
			memset( &pdbfilehdr->logtimeDetach, 0, sizeof( LOGTIME ) );
			}
		//	update the scrub information
		//	we wait until this point so we are sure all scrubbed pages have
		//	been written to disk

		pdbfilehdr->le_dbtimeLastScrub 	= pfmp->DbtimeLastScrub();
		pdbfilehdr->logtimeScrub 		= pfmp->LogtimeScrub();

		memset( &pdbfilehdr->bkinfoSnapshotCur, 0, sizeof( BKINFO ) );

		Assert( pdbfilehdr->le_objidLast );
		if ( !fGlobalRepair )
			{
			if ( pdbfilehdr->FSLVExists() )
				{
				Call( ErrSLVSyncHeader(	pfsapi,
										rgfmp[ifmp].FReadOnlyAttach(),
										rgfmp[ifmp].SzSLVName(),
										pdbfilehdr ) );
				}
			else if ( plog->m_fRecovering && (flags & fLRForceDetachCreateSLV) )
				{
				BOOL fLogOn;
				fLogOn = pfmp->FLogOn();
				// check the SLV and if is right one recreate it and set db header
				SLVFILEHDR *pslvfilehdr;
				pslvfilehdr = NULL;
				err = ErrSLVAllocAndReadHeader(	pfsapi,
												rgfmp[ifmp].FReadOnlyAttach(),
												rgfmp[ifmp].SzSLVName(),
												pdbfilehdr,
												&pslvfilehdr );
				Assert( err < 0 );
				if ( JET_errFileNotFound == err )
					{
					err = JET_errSuccess;
					}
				else if ( JET_errDatabaseStreamingFileMismatch == err
					&& 0 == CmpLgpos( &pslvfilehdr->le_lgposAttach, &pdbfilehdr->le_lgposAttach )
					&& 0 == memcmp( &pslvfilehdr->signDb, &pdbfilehdr->signDb, sizeof( SIGNATURE ) ) )
					{
					OSMemoryPageFree( pslvfilehdr );
#ifdef DEBUG
					pslvfilehdr = NULL;
#endif // DEBUG
					Call( pfsapi->ErrFileDelete( pfmp->SzSLVName() ) );
				 	err = JET_errSuccess;
					}
				else
					{
					OSMemoryPageFree( pslvfilehdr );
#ifdef DEBUG
					pslvfilehdr = NULL;
#endif // DEBUG
					Call( err );
					}
				Assert( NULL == pslvfilehdr );
				pfmp->ResetLogOn();
				pdbfilehdr->SetSLVExists();
				pdbfilehdr->signSLV = pdbfilehdr->signDb;
				err = ErrFILECreateSLV( pfsapi, ppib, ifmp, SLV_CREATESLV_CREATE );
				if ( fLogOn )
					{
					pfmp->SetLogOn();
					}
				if ( err < 0 )
					{
					pdbfilehdr->ResetSLVExists();
					memset( &pdbfilehdr->signSLV, 0, sizeof( SIGNATURE ) );
					Call( err );
					}
				}
			}
		err = ErrUtilWriteShadowedHeader( pfsapi, szDatabaseName, fTrue, (BYTE*)pdbfilehdr, g_cbPage );
		//	Check what have we written
		if ( JET_errSuccess != err )
			{
			ERR errT;
			DBFILEHDR *pdbfilehdrT = NULL;

			pdbfilehdrT = (DBFILEHDR *)PvOSMemoryPageAlloc( g_cbPage, NULL );
			if ( NULL != pdbfilehdrT )
				{
				//	Read new status
				errT = ErrUtilReadShadowedHeader( pfsapi, szDatabaseName, (BYTE*)pdbfilehdrT, g_cbPage, OffsetOf( DBFILEHDR, le_cbPageSize) );
				//	If database header is set properly
				if ( JET_errSuccess == errT && JET_dbstateConsistent == pdbfilehdrT->Dbstate() )
					{
					err = JET_errSuccess;
					}
				(VOID)OSMemoryPageFree( (VOID*)pdbfilehdrT );
				}
			Call( err );
			}

		if ( flags & fLRForceDetachDeleteDB )
			{
			if ( pfmp->SzSLVName() != NULL )
				{
				pfsapi->ErrFileDelete( pfmp->SzSLVName() );
				}
			pfsapi->ErrFileDelete( pfmp->SzDatabaseName() );
			}
		}

	//	Reset and free up FMP

	FMP::EnterCritFMPPool();
	pfmp->RwlDetaching().EnterAsWriter();
	DBResetFMP( pfmp, plog, fTrue );
	pfmp->ReleaseWriteLatchAndFree( ppib );
	pfmp->RwlDetaching().LeaveAsWriter();
	FMP::LeaveCritFMPPool();

	return JET_errSuccess;

HandleError:
	Assert( err < JET_errSuccess );

	//	do not reset detaching. We leave the database in detaching
	//	mode till next restore.

	if ( fDetachLogged )
		{
		//	if failure after detach logged, force shutdown to fix up database
		DBReportPartiallyDetachedDb( pinst, szDatabaseName, err );
		ppib->SetErrRollbackFailure( err );
		pinst->SetInstanceUnavailable( err );

		Assert( NULL != pfmp );
		pfmp->ReleaseWriteLatch( ppib );
		}
	else if ( NULL != pfmp )
		{
		//	detach not logged yet, so database is still usable
		pfmp->RwlDetaching().EnterAsWriter();
		pfmp->ResetDetachingDB( );
		pfmp->ReleaseWriteLatch( ppib );
		pfmp->RwlDetaching().LeaveAsWriter();
		}

	if ( fInCritBackup )
		plog->m_critBackupInProgress.Leave();

	return err;
	}


//	DAE databases are repaired automatically on system restart
//
ERR ISAMAPI ErrIsamRepairDatabase(
	JET_SESID sesid,
	const CHAR  *lszDbFile,
	JET_PFNSTATUS pfnstatus )
	{
	PIB *ppib;

	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	ppib = (PIB*) sesid;

	Assert( fFalse );
	return ErrERRCheck( JET_errFeatureNotAvailable );
	}


ERR ISAMAPI ErrIsamOpenDatabase(
	JET_SESID sesid,
	const CHAR  *szDatabaseName,
	const CHAR  *szConnect,
	JET_DBID *pjdbid,
	JET_GRBIT grbit )
	{
	ERR		err;
	PIB		*ppib;
	IFMP  	ifmp;

	//	initialize return value
	Assert( pjdbid );
	*pjdbid = JET_dbidNil;

	//	check parameters
	//
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	ppib = (PIB *)sesid;

	CallR( ErrPIBCheck( ppib ) );

	CallR( ErrDBOpenDatabase( ppib, (CHAR *)szDatabaseName, &ifmp, grbit ) );

	// we don't have any check to prevent JetOpenDatabase
	// using the temp database name.
	// we check now if we actualy opened the temp db
	if( !FUserIfmp( ifmp ) )
		{
		CallS ( ErrDBCloseDatabase( ppib, ifmp, NO_GRBIT ) );
		return ErrERRCheck( JET_errInvalidDatabase );
		}

	*pjdbid = (JET_DBID)ifmp;

	return JET_errSuccess;
	}


ERR ErrDBOpenDatabaseBySLV( IFileSystemAPI *const pfsapi, PIB *ppib, CHAR *szSLVName, IFMP *pifmp )
	{
	ERR		err = JET_errSuccess;
	CHAR  	rgchSLVFullName[IFileSystemAPI::cchPathMax];
	CHAR  	*szSLVFullName;
	CHAR  	*szSLVFileName;
	IFMP  	ifmp;
	INST	*pinst = PinstFromPpib( ppib );
	LOG		*plog = pinst->m_plog;

	Assert( !plog->m_fRecovering );
	Assert( NULL != szSLVName );
	Assert( 0 != *szSLVName );

	//	this should never be called on the temp database (its ok to use the regular file-system)

	err = pfsapi->ErrPathComplete( szSLVName, rgchSLVFullName );
	CallR( err == JET_errInvalidPath ? ErrERRCheck( JET_errDatabaseInvalidPath ) : err );
	szSLVFullName = rgchSLVFullName;
	szSLVFileName = szSLVFullName;

	CallR( FMP::ErrWriteLatchBySLVNameSz( szSLVFullName, &ifmp, ppib ) );

	FMP *pfmp = &rgfmp[ ifmp ];

	//  during recovering, we could open an non-detached database
	//  to force to initialize the fmp entry.
	//	if database has been detached, then return error.
	//
	if ( !plog->m_fRecovering && !pfmp->FAttached() )
		{
		Call( ErrERRCheck( JET_errDatabaseNotFound ) );
		}
	Assert( !pfmp->FSkippedAttach() );

	if ( pfmp->FReadOnlyAttach() )
		err = ErrERRCheck( JET_wrnFileOpenReadOnly );

	if ( pfmp->FExclusiveByAnotherSession( ppib ) )
		{
		Call( ErrERRCheck( JET_errDatabaseLocked ) );
		}

	Assert( pfmp->Pfapi() );
	DBSetOpenDatabaseFlag( ppib, ifmp );

	//	Allow others to open.

	pfmp->ReleaseWriteLatch( ppib );

	*pifmp = ifmp;
	return err;

HandleError:

	pfmp->ReleaseWriteLatch( ppib );
	return err;
	}


ERR ErrDBOpenDatabase( PIB *ppib, CHAR *szDatabaseName, IFMP *pifmp, ULONG grbit )
	{
	ERR					err = JET_errSuccess;
	CHAR  				rgchFullName[IFileSystemAPI::cchPathMax];
	CHAR  				*szFullName;
	CHAR  				*szFileName;
	IFMP  				ifmp;
	INST				*pinst = PinstFromPpib( ppib );
	LOG					*plog = pinst->m_plog;
	IFileSystemAPI		*pfsapi = NULL;

	if ( plog->m_fRecovering )
		{
		Assert( NULL != szDatabaseName );
		Assert( 0 != *szDatabaseName );
		CallS( FMP::ErrWriteLatchByNameSz( szDatabaseName, &ifmp, ppib ) );
		}

	pfsapi = pinst->m_pfsapi;
	if ( plog->m_fRecovering && dbidTemp != rgfmp[ ifmp ].Dbid() )
		{
		szFileName = szFullName = rgfmp[ifmp].SzDatabaseName();
		}
	else
		{
		if ( NULL == szDatabaseName || 0 == *szDatabaseName )
			{
			return ErrERRCheck( JET_errDatabaseInvalidPath );
			}

		err = ErrUtilPathComplete( pfsapi, szDatabaseName, rgchFullName, fFalse );
		Assert( JET_errFileNotFound != err );
		CallR( err == JET_errInvalidPath ? ErrERRCheck( JET_errDatabaseInvalidPath ) : err );

		szFullName = rgchFullName;
		szFileName = szFullName;
		}

	if ( !plog->m_fRecovering )
		{
		Assert( rgchFullName == szFullName );
		CallR( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
		}

	FMP *pfmp = &rgfmp[ ifmp ];

	if ( g_fOneDatabasePerSession
		&& !plog->m_fRecovering
		&& FUserIfmp( ifmp )
		&& FSomeDatabaseOpen( ppib, ifmp ) )
		{
		Call( ErrERRCheck( JET_errOneDatabasePerSession ) );
		}

	//  during recovering, we could open an non-detached database
	//  to force to initialize the fmp entry.
	//	if database has been detached, then return error.
	//
	if ( !plog->m_fRecovering && !pfmp->FAttached() )
		{
		Call( ErrERRCheck( JET_errDatabaseNotFound ) );
		}

	Assert( !pfmp->FSkippedAttach() );
	Assert( !pfmp->FDeferredAttach() );

	if ( pfmp->FReadOnlyAttach() && !( grbit & JET_bitDbReadOnly ) )
		err = ErrERRCheck( JET_wrnFileOpenReadOnly );

	if ( pfmp->FExclusiveByAnotherSession( ppib ) )
		{
		Call( ErrERRCheck( JET_errDatabaseLocked ) );
		}

	if ( grbit & JET_bitDbExclusive )
		{
#ifdef FORCE_ONLINE_DEFRAG
		if ( pfmp->CPin() > 0 )
			{
			if ( !plog->m_fRecovering && pfmp->FLogOn() )
				{
				Assert( !pfmp->FVersioningOff() );
				Assert( !pfmp->FReadOnlyAttach() );
				pfmp->ReleaseWriteLatch( ppib );
				CallR( ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentBatchStop ) );
				Assert( JET_wrnDefragNotRunning == err || JET_errSuccess == err );
				CallR( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
				Assert( !pfmp->FDetachingDB( ) );
				pfmp = &rgfmp[ifmp];
				}
			Assert( !pfmp->FRunningOLD() );
			}
#endif	//	FORCE_ONLINE_DEFRAG

		if( pfmp->CPin() > 0 )
			{
			Call( ErrERRCheck( JET_errDatabaseInUse ) );
			}
		pfmp->SetExclusiveOpen( ppib );
		}

	Assert( pfmp->Pfapi() );
	DBSetOpenDatabaseFlag( ppib, ifmp );

	//	Allow others to open.

	pfmp->ReleaseWriteLatch( ppib );

	*pifmp = ifmp;
	return err;

HandleError:

	pfmp->ReleaseWriteLatch( ppib );
	return err;
	}


ERR ISAMAPI ErrIsamCloseDatabase( JET_SESID sesid, JET_DBID ifmp, JET_GRBIT grbit )
	{
	ERR	  	err;
	PIB	  	*ppib = (PIB *)sesid;

	//	check parameters
	//
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	CallR( ErrPIBCheck( ppib ) );

	CallR( ErrDBCheckUserDbid( ifmp ) );

	CallR ( ErrDBCloseDatabase( ppib, ifmp, grbit ) );

	Assert( !g_fOneDatabasePerSession || !FSomeDatabaseOpen( ppib ) );

	return JET_errSuccess;
	}


ERR ISAMAPI ErrIsamSetDatabaseSize( JET_SESID sesid, const CHAR *szDatabase, DWORD cpg, DWORD *pcpgReal )
	{
	ERR				err			= JET_errSuccess;
	PIB*			ppib		= (PIB *)sesid;
	IFileSystemAPI*	pfsapi		= PinstFromPpib( ppib )->m_pfsapi;
	DBFILEHDR_FIX*	pdbfilehdr	= NULL;
	IFileAPI*		pfapi		= NULL;
	QWORD			cbFileSize;

	if ( NULL == szDatabase || 0 == *szDatabase )
		return ErrERRCheck( JET_errDatabaseInvalidPath );

	if ( cpg < cpgDatabaseMin )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	if ( !( pdbfilehdr = (DBFILEHDR_FIX*)PvOSMemoryPageAlloc( g_cbPage, NULL ) ) )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	//	this should never be called on the temp database (e.g. we will not need to force the OS file-system)

	Call( ErrUtilReadAndFixShadowedHeader(	pfsapi,
											(CHAR *)szDatabase,
											(BYTE *)pdbfilehdr,
											g_cbPage,
											OffsetOf( DBFILEHDR_FIX, le_cbPageSize ) ) );

	//	Disallow setting size on an inconsistent database

	if ( pdbfilehdr->Dbstate() != JET_dbstateConsistent )
		{
		Call( ErrERRCheck( JET_errDatabaseInconsistent ) );
		}

	//	Set new database size only if it is larger than db size.

	Call( pfsapi->ErrFileOpen( szDatabase, &pfapi ) );
	Call( pfapi->ErrSize( &cbFileSize ) );

	ULONG cpgNow;
	cpgNow = ULONG( ( cbFileSize / g_cbPage ) - cpgDBReserved );

	if ( cpgNow >= cpg )
		{
		*pcpgReal = cpgNow;
		}
	else
		{
		*pcpgReal = cpg;

		cbFileSize = g_cbPage * ( cpg + cpgDBReserved );

		Call( pfapi->ErrSetSize( cbFileSize ) );
	 	}

HandleError:
	OSMemoryPageFree( (void*)pdbfilehdr );
	delete pfapi;
	return err;
	}


ERR ISAMAPI ErrIsamGrowDatabase( JET_SESID sesid, JET_DBID ifmp, DWORD cpg, DWORD *pcpgReal )
	{
	ERR		err			= JET_errSuccess;
	PIB*	ppib		= (PIB *)sesid;
	FUCB*	pfucb 		= pfucbNil;
	PGNO	pgnoAlloc	= pgnoNull;
	PGNO	pgnoLast	= pgnoNull;
	CPG		cpgCurrent;
	CPG		cpgExtend;

	Call( ErrSPGetLastPgno( ppib, ifmp, &pgnoLast ) );

	cpgCurrent = pgnoLast + cpgDBReserved;
	cpgExtend = cpg < cpgCurrent ? 0 : cpg - cpgCurrent;

	Call( ErrDIROpen( ppib, pgnoSystemRoot, ifmp, &pfucb ) );
	Call( ErrSPGetExt( pfucb, pgnoSystemRoot, &cpgExtend, cpgExtend, &pgnoAlloc ) );

	Call( ErrSPGetLastPgno( ppib, ifmp, &pgnoLast ) );
	*pcpgReal = pgnoLast + cpgDBReserved;

HandleError:
	if( pfucbNil != pfucb )
		{
		DIRClose( pfucb );
		}
	return err;
	}


ERR ErrDBCloseDatabase( PIB *ppib, IFMP ifmp, ULONG	grbit )
	{
	FMP		*pfmp = &rgfmp[ ifmp ];
	FUCB	*pfucb;
	FUCB	*pfucbNext;

	if ( !( FPIBUserOpenedDatabase( ppib, pfmp->Dbid() ) ) )
		{
		return ErrERRCheck( JET_errDatabaseNotFound );
		}

	/*	get a write latch on this fmp in order to change cPin.
	 */
	pfmp->GetWriteLatch( ppib );

	Assert( FIODatabaseOpen( ifmp ) );
	if ( FLastOpen( ppib, ifmp ) )
		{
		//	close all open FUCBs on this database
		//

		//	get first table FUCB
		//
		pfucb = ppib->pfucbOfSession;
		while ( pfucb != pfucbNil
			&& ( pfucb->ifmp != ifmp || !pfucb->u.pfcb->FPrimaryIndex() ) )
			{
			pfucb = pfucb->pfucbNextOfSession;
			}

		while ( pfucb != pfucbNil )
			{
			//	get next table FUCB
			//
			pfucbNext = pfucb->pfucbNextOfSession;
			while ( pfucbNext != pfucbNil
				&& ( pfucbNext->ifmp != ifmp || !pfucbNext->u.pfcb->FPrimaryIndex() ) )
				{
				pfucbNext = pfucbNext->pfucbNextOfSession;
				}

			if ( !( FFUCBDeferClosed( pfucb ) ) )
				{
				CallS( pfucb->pvtfndef->pfnCloseTable( (JET_SESID)ppib, (JET_TABLEID) pfucb ) );
				}
			pfucb = pfucbNext;
			}
		}

	// if we opened it exclusively, we reset the flag

	DBResetOpenDatabaseFlag( ppib, ifmp );
	if ( pfmp->FExclusiveBySession( ppib ) )
		pfmp->ResetExclusiveOpen( );

	if ( ppib->FSessionOLD() )
		{
		Assert( pfmp->FRunningOLD() );
		pfmp->ResetRunningOLD();
		}

	// Release Write Latch

	pfmp->ReleaseWriteLatch( ppib );

	//	do not close file until file map space needed or database
	//	detached.

	return JET_errSuccess;
	}


ERR ErrDBOpenDatabaseByIfmp( PIB *ppib, IFMP ifmp )
	{
	ERR		err;

	//	Write latch the fmp since we are going to change cPin.

	CallR( FMP::ErrWriteLatchByIfmp( ifmp, ppib ) );

	//	The fmp we latch must be write latched by us and have
	//	a attached database.

	FMP *pfmp = &rgfmp[ ifmp ];
	Assert( pfmp->FWriteLatchByMe(ppib) );
	Assert( pfmp->FAttached() );


	// Allow LV create, RCE clean, and OLD sessions to bypass exclusive lock.
	if ( pfmp->FExclusiveByAnotherSession( ppib )
		&& !FPIBSessionLV( ppib )
		&& !FPIBSessionSystemCleanup( ppib ) )
		{
		//	It is opened by others already.
		err = ErrERRCheck( JET_errDatabaseLocked );
		}
	else
		{
		DBSetOpenDatabaseFlag( ppib, ifmp );

		if ( ppib->FSessionOLD() && !pfmp->FRunningOLD() )
			{
			pfmp->SetRunningOLD();
			}

		err = JET_errSuccess;
		}

	pfmp->ReleaseWriteLatch( ppib );

	return err;
	}


//	ErrDABCloseAllDBs: Close all databases opened by this session
//
ERR ErrDBCloseAllDBs( PIB *ppib )
	{
	DBID	dbid;
	ERR		err;
	INST	*pinst = PinstFromPpib( ppib );

	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;
		while ( FPIBUserOpenedDatabase( ppib, dbid ) )
			CallR( ErrDBCloseDatabase( ppib, ifmp, 0 ) );
		}

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\comp.cxx ===
#include "std.hxx"
#include "_comp.hxx"

#ifdef MINIMAL_FUNCTIONALITY
#else

#ifdef DISABLE_SLV
#else
#define	SLVDEFRAG_HACK
#endif

// UNDONE:  Do these need to be localised?
#define szCompactStatsFile		"DFRGINFO.TXT"
#define szCompactAction			"Defragmentation"
#define szCMPSTATSTableName		"Table Name"
#define szCMPSTATSFixedVarCols	"# Non-Derived Fixed/Variable Columns"
#define szCMPSTATSTaggedCols	"# Non-Derived Tagged Columns"
#define szCMPSTATSColumns		"# Columns"
#define szCMPSTATSSecondaryIdx	"# Secondary Indexes"
#define szCMPSTATSPagesOwned	"Pages Owned (Source DB)"
#define szCMPSTATSPagesAvail	"Pages Avail. (Source DB)"
#define szCMPSTATSInitTime		"Table Create/Init. Time"
#define szCMPSTATSRecordsCopied	"# Records Copied"
#define szCMPSTATSRawData		"Raw Data Bytes Copied"
#define szCMPSTATSRawDataLV		"Raw Data LV Bytes Copied"
#define szCMPSTATSLeafPages		"Leaf Pages Traversed"
#define szCMPSTATSMinLVPages	"Min. LV Pages Traversed"
#define szCMPSTATSRecordsTime	"Copy Records Time"
#define szCMPSTATSTableTime		"Copy Table Time"


//  ================================================================
class CMEMLIST
//  ================================================================
//
//  Allocate a chunk of memory, keep allocating more. All memory
//  can be destroyed.
//
//	Memory is stored in a singly-linked list. The first 4 bytes
//  of memory allocated points to the next chunk
//
//-
	{
	private:
		VOID * m_pvHead;
		ULONG  m_cbAllocated;	//	includes list overhead

	public:
		CMEMLIST();
		~CMEMLIST();

		VOID * PvAlloc( const ULONG cb );
		VOID FreeAllMemory();

	public:
#ifndef RTM
		static void UnitTest();
#endif	//	!RTM

#ifdef DEBUG
		VOID AssertValid() const ;
#endif	//	DEBUG

	private:
		CMEMLIST( const CMEMLIST& );
		CMEMLIST& operator=( const CMEMLIST& );
	};


//  ================================================================
CMEMLIST::CMEMLIST() :
	m_pvHead( 0 ),
	m_cbAllocated( 0 )
//  ================================================================
	{
	}


//  ================================================================
CMEMLIST::~CMEMLIST()
//  ================================================================
	{
	//  Have people call FreeAllMemory to make the code clearer
	Assert( NULL == m_pvHead );	//	CMEMLIST::FreeAllMemory() not called?
	Assert( 0 == m_cbAllocated ); //	CMEMLIST::FreeAllMemory() not called?
	FreeAllMemory();
	}


//  ================================================================
VOID * CMEMLIST::PvAlloc( const ULONG cb )
//  ================================================================
//
//	Get a new chunk of memory, put it at the head of the list
//
//-
	{
	const ULONG cbActualAllocate = cb + sizeof( VOID* );

	//	if allocation too near numeric limit then fail as though OOM
	//
	if ( cbActualAllocate < cb )
		{
		return NULL;
		}
	
	VOID * const pvNew = PvOSMemoryHeapAlloc( cbActualAllocate );
	if( NULL == pvNew )
		{
		return NULL;
		}
		
	VOID * const pvReturn = reinterpret_cast<BYTE *>( pvNew ) + sizeof( VOID* );
	*(reinterpret_cast<VOID **>( pvNew ) ) = m_pvHead;
	m_pvHead = pvNew;

	m_cbAllocated += cbActualAllocate;
	
	return pvReturn;
	}


//  ================================================================
VOID CMEMLIST::FreeAllMemory()
//  ================================================================
	{
	VOID * pv = m_pvHead;
	while( pv )
		{
		VOID * const pvNext = *(reinterpret_cast<VOID **>( pv ) );
		OSMemoryHeapFree( pv );
		pv = pvNext;
		}

	m_cbAllocated 	= 0;
	m_pvHead 		= NULL;
	}


#ifdef DEBUG
//  ================================================================
VOID CMEMLIST::AssertValid() const
//  ================================================================
	{
	const VOID * pv = m_pvHead;
	while( pv )
		{
		const VOID * const pvNext = *((VOID **)( pv ) );
		pv = pvNext;
		}

	if( 0 == m_cbAllocated )
		{
		Assert( NULL == m_pvHead );
		}
	else
		{
		Assert( NULL != m_pvHead );
		}
	}	
#endif	//	DEBUG


#ifndef RTM
//  ================================================================
VOID CMEMLIST::UnitTest()
//  ================================================================
//
//  STATIC function
//
//-
	{
	CMEMLIST cmemlist;

	ULONG	cbAllocated = 0;
	INT		i;
	//	void 	*pvT = NULL;
	
	for( i = 0; i < 64; ++i )
		{
		VOID * const pv = cmemlist.PvAlloc( i );
		AssertRTL( NULL != pv );	//	Out-of-memory is not acceptable during a unit test :-)
		cbAllocated += i + sizeof( VOID* );
		AssertRTL( cbAllocated == cmemlist.m_cbAllocated );
		ASSERT_VALID( &cmemlist );
		}

	cmemlist.FreeAllMemory();
	ASSERT_VALID( &cmemlist );

	(VOID)cmemlist.PvAlloc( 1024 * 1024 );
	ASSERT_VALID( &cmemlist );

	//	pvT = cmemlist.PvAlloc( 0x7fffffff );	//	try an allocation that fails
	//	Assert( NULL == pvT );
	//	ASSERT_VALID( &cmemlist );

	cmemlist.FreeAllMemory();
	ASSERT_VALID( &cmemlist );	
	}
#endif	//	!RTM

struct COMPACTINFO
	{
	PIB				*ppib;
	IFMP			ifmpSrc;
	IFMP			ifmpDest;
	COLUMNIDINFO	rgcolumnids[ccolCMPFixedVar];
	ULONG			ccolSingleValue;
	STATUSINFO		*pstatus;
	BYTE			rgbBuf[g_cbLVBufMax];		// Buffer for copying LV and other misc. usage
	};


INLINE ERR ErrCMPOpenDB(
	COMPACTINFO		*pcompactinfo, 
	const CHAR		*szDatabaseSrc, 
	IFileSystemAPI	*pfsapiDest,
	const CHAR		*szDatabaseDest, 
	const CHAR		*szDatabaseSLVDest )
	{
	ERR			err;
	JET_GRBIT	grbitCreateForDefrag	= JET_bitDbRecoveryOff|JET_bitDbVersioningOff;

	//	open the source DB Exclusive and ReadOnly
	//	UNDONE: JET_bitDbReadOnly currently unsupported
	//	by OpenDatabase (must be specified with AttachDb)
	CallR( ErrDBOpenDatabase(
				pcompactinfo->ppib,
				(CHAR *)szDatabaseSrc, 
				&pcompactinfo->ifmpSrc,
				JET_bitDbExclusive|JET_bitDbReadOnly ) );

	if ( rgfmp[pcompactinfo->ifmpSrc].FSLVAttached() )
		{
		grbitCreateForDefrag |= JET_bitDbCreateStreamingFile;
		}
	else
		{
		szDatabaseSLVDest = NULL;
		}

	//	Create and then open the destination database.
	//	CONSIDER: Should the destination database be deleted
	//	if it already exists?
	Assert( NULL != pfsapiDest );
	err = ErrDBCreateDatabase(
				pcompactinfo->ppib,
				pfsapiDest,
				szDatabaseDest,
				szDatabaseSLVDest,
				NULL,
				0, 
				&pcompactinfo->ifmpDest,
				dbidMax,
				cpgDatabaseMin,
				grbitCreateForDefrag,
				NULL );

	Assert( err <= 0 );		// No warnings.
	if ( err < 0 )
		{
		(VOID)ErrDBCloseDatabase(
						pcompactinfo->ppib,
						pcompactinfo->ifmpSrc,
						NO_GRBIT );
		}

	return err;
	}


LOCAL VOID CMPCopyOneIndex(
	FCB						* const pfcbSrc,
	FCB						*pfcbIndex,
	JET_INDEXCREATE			*pidxcreate,
	JET_TUPLELIMITS			*ptuplelimits,
	JET_CONDITIONALCOLUMN	*pconditionalcolumn )
	{
	TDB						*ptdb = pfcbSrc->Ptdb();
	IDB						*pidb = pfcbIndex->Pidb();

	Assert( pfcbSrc->FTypeTable() );
	Assert( pfcbSrc->FPrimaryIndex() );
	
	Assert( ptdbNil != ptdb );
	Assert( pidbNil != pidb );

	// Derived indexes are inherited at table creation time.
	Assert( !pfcbIndex->FDerivedIndex() );

	Assert( sizeof(JET_INDEXCREATE) == pidxcreate->cbStruct );
	
	pfcbSrc->EnterDML();	// Strictly speaking, not needed because defrag is single-threaded
	
	strcpy( pidxcreate->szIndexName, ptdb->SzIndexName( pidb->ItagIndexName() ) );

	ULONG	cb = (ULONG)strlen( pidxcreate->szIndexName );
	Assert( cb > 0 );
	Assert( cb <= JET_cbNameMost );
	Assert( pidxcreate->szIndexName[cb] == '\0' );

	CHAR	* const szKey = pidxcreate->szKey;
	ULONG	ichKey = 0;
	const IDXSEG* rgidxseg = PidxsegIDBGetIdxSeg( pidb, ptdb );
	
	Assert( pidb->Cidxseg() > 0 );
	Assert( pidb->Cidxseg() <= JET_ccolKeyMost );
	for ( ULONG iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
		{
		const COLUMNID	columnid		= rgidxseg[iidxseg].Columnid();
		const FIELD		* const pfield	= ptdb->Pfield( columnid );

		Assert( pfieldNil != pfield );

		if ( !FFIELDPrimaryIndexPlaceholder( pfield->ffield ) )
			{
			const BOOL		fDerived	= ( FCOLUMNIDTemplateColumn( columnid ) && !ptdb->FTemplateTable() );
			szKey[ichKey++] = ( rgidxseg[iidxseg].FDescending() ? '-' : '+' );
			strcpy( szKey+ichKey, ptdb->SzFieldName( pfield->itagFieldName, fDerived ) );
			cb = (ULONG)strlen( szKey+ichKey );
			Assert( cb > 0 );
			Assert( cb <= JET_cbNameMost );
		
			Assert( szKey[ichKey+cb] == '\0' );
			ichKey += cb + 1;		// +1 for segment's null terminator.
			}
		else
			{
			//	must be first column in primary index
			Assert( pidb->FPrimary() );
			Assert( 0 == iidxseg );
			Assert( 0 == ichKey );
			}
		}
		
	szKey[ichKey++] = '\0';	// double-null termination

	Assert( ichKey > 2 );

	Assert( pidb->CbVarSegMac() > 0 );
	Assert( pidb->CbVarSegMac() <= KEY::CbKeyMost( pidb->FPrimary() ) );

	pidxcreate->cbKey 		= ichKey;
	pidxcreate->grbit 		= pidb->GrbitFromFlags() | JET_bitIndexUnicode;

	if ( pidb->FTuples() )
		{
		pidxcreate->grbit |= JET_bitIndexTupleLimits;
		ptuplelimits->chLengthMin = pidb->ChTuplesLengthMin();
		ptuplelimits->chLengthMax = pidb->ChTuplesLengthMax();
		ptuplelimits->chToIndexMax = pidb->ChTuplesToIndexMax();
		pidxcreate->ptuplelimits = ptuplelimits;
		}
	else
		{
		pidxcreate->cbVarSegMac = pidb->CbVarSegMac();
		}

	Assert( lcidNone != pidb->Lcid() );
	Assert( NULL != pidxcreate->pidxunicode );
	*( pidxcreate->pidxunicode ) = *( pidb->Pidxunicode() );

	pidxcreate->rgconditionalcolumn = pconditionalcolumn;
	pidxcreate->cConditionalColumn	= pidb->CidxsegConditional();

	rgidxseg = PidxsegIDBGetIdxSegConditional( pidb, ptdb );
	for( iidxseg = 0; iidxseg < pidxcreate->cConditionalColumn; ++iidxseg )
		{
		CHAR * const szConditionalKey = szKey + ichKey;

		const COLUMNID	columnid	= rgidxseg[iidxseg].Columnid();
		const FIELD		*pfield		= ptdb->Pfield( columnid );
		const BOOL		fDerived	= FCOLUMNIDTemplateColumn( columnid ) && !ptdb->FTemplateTable();

		Assert( pfieldNil != pfield );

		strcpy( szConditionalKey, ptdb->SzFieldName( pfield->itagFieldName, fDerived ) );
		ichKey += (ULONG)strlen( szConditionalKey ) + 1;

		pidxcreate->rgconditionalcolumn[iidxseg].cbStruct 		= sizeof( JET_CONDITIONALCOLUMN );
		pidxcreate->rgconditionalcolumn[iidxseg].szColumnName 	= szConditionalKey;
		pidxcreate->rgconditionalcolumn[iidxseg].grbit			= ( rgidxseg[iidxseg].FMustBeNull()
												? JET_bitIndexColumnMustBeNull
												: JET_bitIndexColumnMustBeNonNull );
		}

	pfcbSrc->LeaveDML();
	
	pidxcreate->ulDensity = pfcbSrc->UlDensity();
	}

LOCAL ERR ErrCMPCreateTableColumnIndex( 
	COMPACTINFO		*pcompactinfo, 
	FCB				* const pfcbSrc,
	JET_TABLECREATE2	*ptablecreate,
	JET_COLUMNLIST	*pcolumnList, 
	COLUMNIDINFO	*columnidInfo, 
	JET_COLUMNID	**pmpcolumnidcolumnidTagged )
	{
	ERR				err;
	PIB				*ppib = pcompactinfo->ppib;
	FCB				*pfcbIndex;
	ULONG			cColumns;
	ULONG			cbColumnids;
	ULONG			cbAllocate;
	ULONG			cSecondaryIndexes;
	ULONG			cIndexesToCreate;
	ULONG			cConditionalColumns;
	ULONG			ccolSingleValue = 0;
	ULONG			cbActual;
	JET_COLUMNID	*mpcolumnidcolumnidTagged = NULL;
	FID				fidTaggedHighest = 0;
	ULONG			cTagged = 0;
	BOOL			fLocalAlloc = fFalse;
	ULONG			cbDefaultRecRemaining = cbRECRecordMost;

	//	All memory allocated from this will be freed at the end of the function
	CMEMLIST		cmemlist;

	const INT		cbName			= JET_cbNameMost+1;	// index/column name plus terminator
	const INT		cbLangid		= sizeof(LANGID)+2;	// langid plus double-null terminator
	const INT		cbCbVarSegMac	= sizeof(BYTE)+2;	// cbVarSegMac plus double-null terminator
	const INT		cbKeySegment	= 1+cbName;			// +/- prefix plus name
	const INT		cbKey			= ( JET_ccolKeyMost * cbKeySegment ) + 1;	// plus 1 for double-null terminator
	const INT		cbKeyExtended	= cbKey + cbLangid + cbCbVarSegMac;

	Assert( ptablecreate->cCreated == 0 );

	// Allocate a pool of memory for:
	//		1) list of source table columnids
	//		2) the JET_COLUMNCREATE structures
	//		3) buffer for column names
	//		4) buffer for default values
	//		5) the JET_INDEXCREATE structures
	//		6) buffer for index names
	//		7) buffer for index keys.

	cColumns = pcolumnList->cRecord;

	//	start by allocating space for the source table columnids, adjusted for alignment
	cbColumnids = cColumns * sizeof(JET_COLUMNID);
	cbColumnids = ( ( cbColumnids + sizeof(SIZE_T) - 1 ) / sizeof(SIZE_T) ) * sizeof(SIZE_T);

	cbAllocate = cbColumnids +
					( cColumns *
						( sizeof(JET_COLUMNCREATE) +	// JET_COLUMNCREATE structures
						cbName ) );						// column names

	// Derived indexes will get inherited from template -- don't count
	// them as ones that need to be created.
	Assert( ( pfcbSrc->FSequentialIndex() && pfcbSrc->Pidb() == pidbNil )
		|| ( !pfcbSrc->FSequentialIndex() && pfcbSrc->Pidb() != pidbNil ) );
	cIndexesToCreate = ( pfcbSrc->Pidb() != pidbNil && !pfcbSrc->FDerivedIndex() ? 1 : 0 );
	cConditionalColumns = 0;
	cSecondaryIndexes = 0;
	for ( pfcbIndex = pfcbSrc->PfcbNextIndex();
		pfcbIndex != pfcbNil;
		pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		cConditionalColumns += pfcbIndex->Pidb()->CidxsegConditional();
		cSecondaryIndexes++;
		Assert( pfcbIndex->FTypeSecondaryIndex() );
		Assert( pfcbIndex->Pidb() != pidbNil );
		if ( !pfcbIndex->FDerivedIndex() )
			cIndexesToCreate++;
		}

	//	ensure primary extent is large enough to at least accommodate the primary index
	//	and each secondary index
	ptablecreate->ulPages = max( cSecondaryIndexes+1, ptablecreate->ulPages );

	cbAllocate +=
		cIndexesToCreate *
			(
			sizeof( JET_INDEXCREATE )	// JET_INDEXCREATE
			+ cbName					// index name
			+ cbKeyExtended				// index key, plus langid and cbVarSegmac
			+ sizeof( JET_UNICODEINDEX )
			+ sizeof( JET_TUPLELIMITS )
			);

	cbAllocate += cConditionalColumns * ( sizeof( JET_CONDITIONALCOLUMN ) + cbKeySegment );

	cbAllocate += cbDefaultRecRemaining;		// all default values must fit in an intrinsic record

	// WARNING: To ensure that columnids and JET_COLUMN/INDEXCREATE
	// structs are 4-byte aligned, arrange everything in the following
	// order:
	//		1) list of source table columnids
	//		2) JET_COLUMNCREATE structures
	//		3) JET_INDEXCREATE structures
	//		4) JET_UNICODEINDEX structures
	//		5) JET_TUPLELIMIT structures
	//		6) JET_CONDITIONALCOLUMN structures
	//		7) buffer for column names
	//		8) buffer for index names
	//		9) buffer for index keys
	//		10) buffer for default values
			

	// Can we use the buffer hanging off pcompactinfo?
	JET_COLUMNID	*pcolumnidSrc;
	if ( cbAllocate <= g_cbLVBuf )
		{
		pcolumnidSrc = (JET_COLUMNID *)pcompactinfo->rgbBuf;
		}
	else
		{
		pcolumnidSrc = static_cast<JET_COLUMNID *>( PvOSMemoryHeapAlloc( cbAllocate ) );
		if ( pcolumnidSrc == NULL )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			return err;
			}
		fLocalAlloc = fTrue;
		}
	
	JET_COLUMNID	* const rgcolumnidSrc = pcolumnidSrc;
	BYTE			* const pbMax = (BYTE *)rgcolumnidSrc + cbAllocate;
	memset( (BYTE *)pcolumnidSrc, 0, cbAllocate );
	
	// JET_COLUMNCREATE structures follow the tagged columnid map.
	JET_COLUMNCREATE *pcolcreateCurr		= (JET_COLUMNCREATE *)( (BYTE *)rgcolumnidSrc + cbColumnids );
	JET_COLUMNCREATE * const rgcolcreate	= pcolcreateCurr;
	Assert( (BYTE *)rgcolcreate < pbMax );

	// JET_INDEXCREATE structures follow the JET_COLUMNCREATE structures
	JET_INDEXCREATE	*pidxcreateCurr = (JET_INDEXCREATE *)( rgcolcreate + cColumns );
	JET_INDEXCREATE	* const rgidxcreate = pidxcreateCurr;
	Assert( (BYTE *)rgidxcreate < pbMax );

	//	JET_UNICODEINDEX structures follow the JET_INDEXCREATE structures
	JET_UNICODEINDEX	*pidxunicodeCurr		= (JET_UNICODEINDEX *)( rgidxcreate + cIndexesToCreate );
	JET_UNICODEINDEX	* const rgidxunicode	= pidxunicodeCurr;
	Assert( (BYTE *)rgidxunicode < pbMax );

	//	JET_TUPLELIMITS structures follow the JET_UNICODEINDEX structures
	JET_TUPLELIMITS		*ptuplelimitsCurr		= (JET_TUPLELIMITS *)( rgidxunicode + cIndexesToCreate );
	JET_TUPLELIMITS		* const rgtuplelimits	= ptuplelimitsCurr;
	Assert( (BYTE *)rgtuplelimits < pbMax );

	// JET_CONDITIONALCOLUMN structures follow the JET_TUPLELIMITS structures
	JET_CONDITIONALCOLUMN	*pconditionalcolumnCurr 	= (JET_CONDITIONALCOLUMN *)( rgtuplelimits + cIndexesToCreate  );
	JET_CONDITIONALCOLUMN	* const rgconditionalcolumn = pconditionalcolumnCurr;
	Assert( (BYTE *)rgconditionalcolumn < pbMax );

	// Column names follow the JET_CONDITIONALCOLUMN structures.
	CHAR	*szCurrColumn = (CHAR *)( rgconditionalcolumn + cConditionalColumns );
	CHAR	* const rgszColumns = szCurrColumn;
	Assert( (BYTE *)rgszColumns < pbMax );

	// Index names follow the column names.
	CHAR	*szCurrIndex = (CHAR *)( rgszColumns + ( cColumns * cbName ) );
	CHAR	* const rgszIndexes = szCurrIndex;
	Assert( (BYTE *)rgszIndexes < pbMax );

	// Index/Conditional Column keys follow the index names.
	CHAR	*szCurrKey = ( CHAR *)( rgszIndexes + ( cIndexesToCreate * cbName ) );
	CHAR	* const rgszKeys = szCurrKey;
	Assert( (BYTE *)rgszKeys < pbMax );

	// Default values follow the keys.
	BYTE	*pbCurrDefault = (BYTE *)( rgszKeys + ( cIndexesToCreate * cbKeyExtended) + ( cConditionalColumns * cbKeySegment ) );
	BYTE	* const rgbDefaultValues = pbCurrDefault;
	Assert( rgbDefaultValues < pbMax );

	Assert( rgbDefaultValues + cbRECRecordMost == pbMax );

	err = ErrDispMove( 
				reinterpret_cast<JET_SESID>( ppib ),
				pcolumnList->tableid,
				JET_MoveFirst,
				NO_GRBIT );

	/* loop though all the columns in the table for the src tbl and
	/* copy the information in the destination database
	/**/
	cColumns = 0;
	while ( err >= 0 )
		{
		memset( pcolcreateCurr, 0, sizeof( JET_COLUMNCREATE ) );
		pcolcreateCurr->cbStruct = sizeof(JET_COLUMNCREATE);

		/* retrieve info from table and create all the columns
		/**/
		Assert( (BYTE *)szCurrColumn + JET_cbNameMost + 1 <= (BYTE *)rgszIndexes );
		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					pcolumnList->columnidcolumnname,
					szCurrColumn,
					JET_cbN